{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _AddForwardedIps(self, forwarded_ips, interface):\n    for address in forwarded_ips:\n      self.ip_forwarding_utils.AddForwardedIp(address, interface)", "response": "Configure the forwarded IP addresses on the network interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _RemoveForwardedIps(self, forwarded_ips, interface):\n    for address in forwarded_ips:\n      self.ip_forwarding_utils.RemoveForwardedIp(address, interface)", "response": "Removes the forwarded IP addresses from the network interface."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling the forwarded IPs on a network interface.", "response": "def HandleForwardedIps(self, interface, forwarded_ips, interface_ip=None):\n    \"\"\"Handle changes to the forwarded IPs on a network interface.\n\n    Args:\n      interface: string, the output device to configure.\n      forwarded_ips: list, the forwarded IP address strings desired.\n      interface_ip: string, current interface ip address.\n    \"\"\"\n    desired = self.ip_forwarding_utils.ParseForwardedIps(forwarded_ips)\n    configured = self.ip_forwarding_utils.GetForwardedIps(\n        interface, interface_ip)\n    to_add = sorted(set(desired) - set(configured))\n    to_remove = sorted(set(configured) - set(desired))\n    self._LogForwardedIpChanges(\n        configured, desired, to_add, to_remove, interface)\n    self._AddForwardedIps(to_add, interface)\n    self._RemoveForwardedIps(to_remove, interface)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef EnableNetworkInterfaces(\n      self, interfaces, logger, dhclient_script=None):\n    \"\"\"Enable the list of network interfaces.\n\n    Args:\n      interfaces: list of string, the output device names to enable.\n      logger: logger object, used to write to SysLog and serial port.\n      dhclient_script: string, the path to a dhclient script used by dhclient.\n    \"\"\"\n    interfaces_to_up = [i for i in interfaces if i != 'eth0']\n    if interfaces_to_up:\n      logger.info('Enabling the Ethernet interfaces %s.', interfaces_to_up)\n      self._WriteIfcfg(interfaces_to_up, logger)\n      self._Ifup(interfaces_to_up, logger)", "response": "Enable the list of network interfaces."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _WriteIfcfg(self, interfaces, logger):\n    for interface in interfaces:\n      interface_config = os.path.join(\n          self.network_path, 'ifcfg-%s' % interface)\n      interface_content = [\n          '# Added by Google.',\n          'STARTMODE=hotplug',\n          'BOOTPROTO=dhcp',\n          'DHCLIENT_SET_DEFAULT_ROUTE=yes',\n          'DHCLIENT_ROUTE_PRIORITY=10%s00' % interface,\n          '',\n      ]\n      with open(interface_config, 'w') as interface_file:\n        interface_file.write('\\n'.join(interface_content))\n      logger.info('Created ifcfg file for interface %s.', interface)", "response": "Write ifcfg files for multi - NIC support."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nactivating network interfaces. Args: interfaces: list of string, the output device names to enable. logger: logger object, used to write to SysLog and serial port.", "response": "def _Ifup(self, interfaces, logger):\n    \"\"\"Activate network interfaces.\n\n    Args:\n      interfaces: list of string, the output device names to enable.\n      logger: logger object, used to write to SysLog and serial port.\n    \"\"\"\n    ifup = ['/usr/sbin/wicked', 'ifup', '--timeout', '1']\n    try:\n      subprocess.check_call(ifup + interfaces)\n    except subprocess.CalledProcessError:\n      logger.warning('Could not activate interfaces %s.', interfaces)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef HandleNetworkInterfaces(self, result):\n    network_interfaces = self._ExtractInterfaceMetadata(result)\n\n    if self.network_setup_enabled:\n      self.network_setup.EnableNetworkInterfaces(\n          [interface.name for interface in network_interfaces[1:]])\n\n    for interface in network_interfaces:\n      if self.ip_forwarding_enabled:\n        self.ip_forwarding.HandleForwardedIps(\n            interface.name, interface.forwarded_ips, interface.ip)", "response": "Called when the network interfaces metadata changes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _ExtractInterfaceMetadata(self, metadata):\n    interfaces = []\n    for network_interface in metadata:\n      mac_address = network_interface.get('mac')\n      interface = self.network_utils.GetNetworkInterface(mac_address)\n      ip_addresses = []\n      if interface:\n        ip_addresses.extend(network_interface.get('forwardedIps', []))\n        if self.ip_aliases:\n          ip_addresses.extend(network_interface.get('ipAliases', []))\n        if self.target_instance_ips:\n          ip_addresses.extend(network_interface.get('targetInstanceIps', []))\n        interfaces.append(NetworkDaemon.NetworkInterface(\n            interface, ip_addresses, network_interface.get('ip', [])))\n      else:\n        message = 'Network interface not found for MAC address: %s.'\n        self.logger.warning(message, mac_address)\n    return interfaces", "response": "Extracts network interfaces from the metadata response."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds the final URL to be passed to urllib. urlparse.", "response": "def _build_url(self, query_params):\n        \"\"\"Build the final URL to be passed to urllib\n\n        :param query_params: A dictionary of all the query parameters\n        :type query_params: dictionary\n        :return: string\n        \"\"\"\n        url = ''\n        count = 0\n        while count < len(self._url_path):\n            url += '/{}'.format(self._url_path[count])\n            count += 1\n\n        # add slash\n        if self.append_slash:\n            url += '/'\n\n        if query_params:\n            url_values = urlencode(sorted(query_params.items()), True)\n            url = '{}?{}'.format(url, url_values)\n\n        if self._version:\n            url = self._build_versioned_url(url)\n        else:\n            url = '{}{}'.format(self.host, url)\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _build_client(self, name=None):\n        url_path = self._url_path + [name] if name else self._url_path\n        return Client(host=self.host,\n                      version=self._version,\n                      request_headers=self.request_headers,\n                      url_path=url_path,\n                      append_slash=self.append_slash,\n                      timeout=self.timeout)", "response": "Build a new Client object based on the current url segment."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking the API call and return the response.", "response": "def _make_request(self, opener, request, timeout=None):\n        \"\"\"Make the API call and return the response. This is separated into\n           it's own function, so we can mock it easily for testing.\n\n        :param opener:\n        :type opener:\n        :param request: url payload to request\n        :type request: urllib.Request object\n        :param timeout: timeout value or None\n        :type timeout: float\n        :return: urllib response\n        \"\"\"\n        timeout = timeout or self.timeout\n        try:\n            return opener.open(request, timeout=timeout)\n        except HTTPError as err:\n            exc = handle_error(err)\n            exc.__cause__ = None\n            raise exc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndecoding airborn position from a pair of even and odd position message.", "response": "def airborne_position(msg0, msg1, t0, t1):\n    \"\"\"Decode airborn position from a pair of even and odd position message\n\n    Args:\n        msg0 (string): even message (28 bytes hexadecimal string)\n        msg1 (string): odd message (28 bytes hexadecimal string)\n        t0 (int): timestamps for the even message\n        t1 (int): timestamps for the odd message\n\n    Returns:\n        (float, float): (latitude, longitude) of the aircraft\n    \"\"\"\n\n    mb0 = common.hex2bin(msg0)[32:]\n    mb1 = common.hex2bin(msg1)[32:]\n\n    # 131072 is 2^17, since CPR lat and lon are 17 bits each.\n    cprlat_even = common.bin2int(mb0[22:39]) / 131072.0\n    cprlon_even = common.bin2int(mb0[39:56]) / 131072.0\n    cprlat_odd = common.bin2int(mb1[22:39]) / 131072.0\n    cprlon_odd = common.bin2int(mb1[39:56]) / 131072.0\n\n    air_d_lat_even = 360.0 / 60\n    air_d_lat_odd = 360.0 / 59\n\n    # compute latitude index 'j'\n    j = common.floor(59 * cprlat_even - 60 * cprlat_odd + 0.5)\n\n    lat_even = float(air_d_lat_even * (j % 60 + cprlat_even))\n    lat_odd = float(air_d_lat_odd * (j % 59 + cprlat_odd))\n\n    if lat_even >= 270:\n        lat_even = lat_even - 360\n\n    if lat_odd >= 270:\n        lat_odd = lat_odd - 360\n\n    # check if both are in the same latidude zone, exit if not\n    if common.cprNL(lat_even) != common.cprNL(lat_odd):\n        return None\n\n    # compute ni, longitude index m, and longitude\n    if (t0 > t1):\n        lat = lat_even\n        nl = common.cprNL(lat)\n        ni = max(common.cprNL(lat)- 0, 1)\n        m = common.floor(cprlon_even * (nl-1) - cprlon_odd * nl + 0.5)\n        lon = (360.0 / ni) * (m % ni + cprlon_even)\n    else:\n        lat = lat_odd\n        nl = common.cprNL(lat)\n        ni = max(common.cprNL(lat) - 1, 1)\n        m = common.floor(cprlon_even * (nl-1) - cprlon_odd * nl + 0.5)\n        lon = (360.0 / ni) * (m % ni + cprlon_odd)\n\n    if lon > 180:\n        lon = lon - 360\n\n    return round(lat, 5), round(lon, 5)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef airborne_position_with_ref(msg, lat_ref, lon_ref):\n\n\n    mb = common.hex2bin(msg)[32:]\n\n    cprlat = common.bin2int(mb[22:39]) / 131072.0\n    cprlon = common.bin2int(mb[39:56]) / 131072.0\n\n    i = int(mb[21])\n    d_lat = 360.0/59 if i else 360.0/60\n\n    j = common.floor(lat_ref / d_lat) \\\n        + common.floor(0.5 + ((lat_ref % d_lat) / d_lat) - cprlat)\n\n    lat = d_lat * (j + cprlat)\n\n    ni = common.cprNL(lat) - i\n\n    if ni > 0:\n        d_lon = 360.0 / ni\n    else:\n        d_lon = 360.0\n\n    m = common.floor(lon_ref / d_lon) \\\n        + common.floor(0.5 + ((lon_ref % d_lon) / d_lon) - cprlon)\n\n    lon = d_lon * (m + cprlon)\n\n    return round(lat, 5), round(lon, 5)", "response": "Decode airborne position with only one message and no knowing reference nearby location."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndecoding aircraft altitude in feet AttributeNames", "response": "def altitude(msg):\n    \"\"\"Decode aircraft altitude\n\n    Args:\n        msg (string): 28 bytes hexadecimal message string\n\n    Returns:\n        int: altitude in feet\n    \"\"\"\n\n    tc = common.typecode(msg)\n\n    if tc<9 or tc==19 or tc>22:\n        raise RuntimeError(\"%s: Not a airborn position message\" % msg)\n\n    mb = common.hex2bin(msg)[32:]\n\n    if tc < 19:\n        # barometric altitude\n        q = mb[15]\n        if q:\n            n = common.bin2int(mb[8:15]+mb[16:20])\n            alt = n * 25 - 1000\n        else:\n            alt = None\n    else:\n        # GNSS altitude, meters -> feet\n        alt = common.bin2int(mb[8:20]) * 3.28084\n\n    return alt"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a hexdecimal string to binary string with zero fillings.", "response": "def hex2bin(hexstr):\n    \"\"\"Convert a hexdecimal string to binary string, with zero fillings. \"\"\"\n    num_of_bits = len(hexstr) * 4\n    binstr = bin(int(hexstr, 16))[2:].zfill(int(num_of_bits))\n    return binstr"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef crc(msg, encode=False):\n\n    # the polynominal generattor code for CRC [1111111111111010000001001]\n    generator = np.array([1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,1])\n    ng = len(generator)\n\n    msgnpbin = bin2np(hex2bin(msg))\n\n    if encode:\n        msgnpbin[-24:] = [0] * 24\n\n    # loop all bits, except last 24 piraty bits\n    for i in range(len(msgnpbin)-24):\n        if msgnpbin[i] == 0:\n            continue\n\n        # perform XOR, when 1\n        msgnpbin[i:i+ng] = np.bitwise_xor(msgnpbin[i:i+ng], generator)\n\n    # last 24 bits\n    reminder = np2bin(msgnpbin[-24:])\n    return reminder", "response": "Detects if a bit error occurs in the Mode - S message and returns the message checksum or partity bits"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the ICAO address from an Mode - S message containing DF4 5 16 or 21.", "response": "def icao(msg):\n    \"\"\"Calculate the ICAO address from an Mode-S message\n    with DF4, DF5, DF20, DF21\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        String: ICAO address in 6 bytes hexadecimal string\n    \"\"\"\n\n    DF = df(msg)\n\n    if DF in (11, 17, 18):\n        addr = msg[2:8]\n    elif DF in (0, 4, 5, 16, 20, 21):\n        c0 = bin2int(crc(msg, encode=True))\n        c1 = hex2int(msg[-6:])\n        addr = '%06X' % (c0 ^ c1)\n    else:\n        addr = None\n\n    return addr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking whether the ICAO address is assigned.", "response": "def is_icao_assigned(icao):\n    \"\"\" Check whether the ICAO address is assigned (Annex 10, Vol 3)\"\"\"\n\n    if (icao is None) or (not isinstance(icao, str)) or (len(icao)!=6):\n        return False\n\n    icaoint = hex2int(icao)\n\n    if 0x200000 < icaoint < 0x27FFFF: return False      # AFI\n    if 0x280000 < icaoint < 0x28FFFF: return False      # SAM\n    if 0x500000 < icaoint < 0x5FFFFF: return False      # EUR, NAT\n    if 0x600000 < icaoint < 0x67FFFF: return False      # MID\n    if 0x680000 < icaoint < 0x6F0000: return False      # ASIA\n    if 0x900000 < icaoint < 0x9FFFFF: return False      # NAM, PAC\n    if 0xB00000 < icaoint < 0xBFFFFF: return False      # CAR\n    if 0xD00000 < icaoint < 0xDFFFFF: return False      # future\n    if 0xF00000 < icaoint < 0xFFFFFF: return False      # future\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cprNL(lat):\n\n    if lat == 0:\n        return 59\n\n    if lat == 87 or lat == -87:\n        return 2\n\n    if lat > 87 or lat < -87:\n        return 1\n\n    nz = 15\n    a = 1 - np.cos(np.pi / (2 * nz))\n    b = np.cos(np.pi / 180.0 * abs(lat)) ** 2\n    nl = 2 * np.pi / (np.arccos(1 - a/b))\n    NL = floor(nl)\n    return NL", "response": "function in CPR decoding"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef idcode(msg):\n\n    if df(msg) not in [5, 21]:\n        raise RuntimeError(\"Message must be Downlink Format 5 or 21.\")\n\n    mbin = hex2bin(msg)\n\n    C1 = mbin[19]\n    A1 = mbin[20]\n    C2 = mbin[21]\n    A2 = mbin[22]\n    C4 = mbin[23]\n    A4 = mbin[24]\n    # _ = mbin[25]\n    B1 = mbin[26]\n    D1 = mbin[27]\n    B2 = mbin[28]\n    D2 = mbin[29]\n    B4 = mbin[30]\n    D4 = mbin[31]\n\n    byte1 = int(A4+A2+A1, 2)\n    byte2 = int(B4+B2+B1, 2)\n    byte3 = int(C4+C2+C1, 2)\n    byte4 = int(D4+D2+D1, 2)\n\n    return str(byte1) + str(byte2) + str(byte3) + str(byte4)", "response": "Computes identity code from DF5 or DF21 message."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the altitude code from DF4 or DF20 message.", "response": "def altcode(msg):\n    \"\"\"Computes the altitude from DF4 or DF20 message, bit 20-32.\n    credit: @fbyrkjeland\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        int: altitude in ft\n    \"\"\"\n\n    if df(msg) not in [0, 4, 16, 20]:\n        raise RuntimeError(\"Message must be Downlink Format 0, 4, 16, or 20.\")\n\n    # Altitude code, bit 20-32\n    mbin = hex2bin(msg)\n\n    mbit = mbin[25]   # M bit: 26\n    qbit = mbin[27]   # Q bit: 28\n\n\n    if mbit == '0':         # unit in ft\n        if qbit == '1':     # 25ft interval\n            vbin = mbin[19:25] + mbin[26] + mbin[28:32]\n            alt = bin2int(vbin) * 25 - 1000\n        if qbit == '0':     # 100ft interval, above 50175ft\n            C1 = mbin[19]\n            A1 = mbin[20]\n            C2 = mbin[21]\n            A2 = mbin[22]\n            C4 = mbin[23]\n            A4 = mbin[24]\n            # _ = mbin[25]\n            B1 = mbin[26]\n            # D1 = mbin[27]     # always zero\n            B2 = mbin[28]\n            D2 = mbin[29]\n            B4 = mbin[30]\n            D4 = mbin[31]\n\n            graystr =  D2 + D4 + A1 + A2 + A4 + B1 + B2 + B4 + C1 + C2 + C4\n            alt = gray2alt(graystr)\n\n    if mbit == '1':         # unit in meter\n        vbin = mbin[19:25] + mbin[26:31]\n        alt = int(bin2int(vbin) * 3.28084)  # convert to ft\n\n    return alt"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts greycode to integer", "response": "def gray2int(graystr):\n    \"\"\"Convert greycode to binary\"\"\"\n    num = bin2int(graystr)\n    num ^= (num >> 8)\n    num ^= (num >> 4)\n    num ^= (num >> 2)\n    num ^= (num >> 1)\n    return num"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if the data bits are all zeros", "response": "def allzeros(msg):\n    \"\"\"check if the data bits are all zeros\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        bool: True or False\n    \"\"\"\n    d = hex2bin(data(msg))\n\n    if bin2int(d) > 0:\n        return False\n    else:\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if a message is likely to be BDS code 2 0 0", "response": "def is30(msg):\n    \"\"\"Check if a message is likely to be BDS code 2,0\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        bool: True or False\n    \"\"\"\n\n    if allzeros(msg):\n        return False\n\n    d = hex2bin(data(msg))\n\n    if d[0:8] != '00110000':\n        return False\n\n    # threat type 3 not assigned\n    if d[28:30] == '11':\n        return False\n\n    # reserved for ACAS III, in far future\n    if bin2int(d[15:22]) >= 48:\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef position(msg0, msg1, t0, t1, lat_ref=None, lon_ref=None):\n    tc0 = typecode(msg0)\n    tc1 = typecode(msg1)\n\n    if (5<=tc0<=8 and 5<=tc1<=8):\n        if (not lat_ref) or (not lon_ref):\n            raise RuntimeError(\"Surface position encountered, a reference \\\n                               position lat/lon required. Location of \\\n                               receiver can be used.\")\n        else:\n            return surface_position(msg0, msg1, t0, t1, lat_ref, lon_ref)\n\n    elif (9<=tc0<=18 and 9<=tc1<=18):\n        # Airborne position with barometric height\n        return airborne_position(msg0, msg1, t0, t1)\n\n    elif (20<=tc0<=22 and 20<=tc1<=22):\n        # Airborne position with GNSS height\n        return airborne_position(msg0, msg1, t0, t1)\n\n    else:\n        raise RuntimeError(\"incorrect or inconsistant message types\")", "response": "Decode position from a pair of even and odd message and return the corresponding aircraft object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecode position with only one message and aircraft knowing reference nearby location such as previously availabe calculated location ground station or airport location etc.", "response": "def position_with_ref(msg, lat_ref, lon_ref):\n    \"\"\"Decode position with only one message,\n    knowing reference nearby location, such as previously\n    calculated location, ground station, or airport location, etc.\n    Works with both airborne and surface position messages.\n    The reference position shall be with in 180NM (airborne) or 45NM (surface)\n    of the true position.\n\n    Args:\n        msg (string): even message (28 bytes hexadecimal string)\n        lat_ref: previous known latitude\n        lon_ref: previous known longitude\n\n    Returns:\n        (float, float): (latitude, longitude) of the aircraft\n    \"\"\"\n\n    tc = typecode(msg)\n\n    if 5<=tc<=8:\n        return surface_position_with_ref(msg, lat_ref, lon_ref)\n\n    elif 9<=tc<=18 or 20<=tc<=22:\n        return airborne_position_with_ref(msg, lat_ref, lon_ref)\n\n    else:\n        raise RuntimeError(\"incorrect or inconsistant message types\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndecoding aircraft altitude in feet", "response": "def altitude(msg):\n    \"\"\"Decode aircraft altitude\n\n    Args:\n        msg (string): 28 bytes hexadecimal message string\n\n    Returns:\n        int: altitude in feet\n    \"\"\"\n\n    tc = typecode(msg)\n\n    if tc<5 or tc==19 or tc>22:\n        raise RuntimeError(\"%s: Not a position message\" % msg)\n\n    if tc>=5 and tc<=8:\n        # surface position, altitude 0\n        return 0\n\n    msgbin = common.hex2bin(msg)\n    q = msgbin[47]\n    if q:\n        n = common.bin2int(msgbin[40:47]+msgbin[48:52])\n        alt = n * 25 - 1000\n        return alt\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the speed heading and vertical rate of a specific message", "response": "def velocity(msg):\n    \"\"\"Calculate the speed, heading, and vertical rate\n    (handles both airborne or surface message)\n\n    Args:\n        msg (string): 28 bytes hexadecimal message string\n\n    Returns:\n        (int, float, int, string): speed (kt), ground track or heading (degree),\n            rate of climb/descend (ft/min), and speed type\n            ('GS' for ground speed, 'AS' for airspeed)\n    \"\"\"\n\n    if 5 <= typecode(msg) <= 8:\n        return surface_velocity(msg)\n\n    elif typecode(msg) == 19:\n        return airborne_velocity(msg)\n\n    else:\n        raise RuntimeError(\"incorrect or inconsistant message types, expecting 4<TC<9 or TC=19\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef speed_heading(msg):\n    spd, trk_or_hdg, rocd, tag = velocity(msg)\n    return spd, trk_or_hdg", "response": "Get speed and ground track or heading from the velocity message\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating NUCp Navigation Uncertainty Category - Position", "response": "def nuc_p(msg):\n    \"\"\"Calculate NUCp, Navigation Uncertainty Category - Position (ADS-B version 1)\n\n    Args:\n        msg (string): 28 bytes hexadecimal message string,\n\n    Returns:\n        int: Horizontal Protection Limit\n        int: 95% Containment Radius - Horizontal (meters)\n        int: 95% Containment Radius - Vertical (meters)\n\n    \"\"\"\n    tc = typecode(msg)\n\n    if typecode(msg) < 5 or typecode(msg) > 22:\n        raise RuntimeError(\n            \"%s: Not a surface position message (5<TC<8), \\\n            airborne position message (8<TC<19), \\\n            or airborne position with GNSS height (20<TC<22)\" % msg\n        )\n\n    try:\n        NUCp = uncertainty.TC_NUCp_lookup[tc]\n        HPL = uncertainty.NUCp[NUCp]['HPL']\n        RCu = uncertainty.NUCp[NUCp]['RCu']\n        RCv = uncertainty.NUCp[NUCp]['RCv']\n    except KeyError:\n        HPL, RCu, RCv = uncertainty.NA, uncertainty.NA, uncertainty.NA\n\n\n    if tc in [20, 21]:\n        RCv = uncertainty.NA\n\n    return HPL, RCu, RCv"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate NUCv Navigation Uncertainty Category - Velocity", "response": "def nuc_v(msg):\n    \"\"\"Calculate NUCv, Navigation Uncertainty Category - Velocity (ADS-B version 1)\n\n    Args:\n        msg (string): 28 bytes hexadecimal message string,\n\n    Returns:\n        int or string: 95% Horizontal Velocity Error\n        int or string: 95% Vertical Velocity Error\n    \"\"\"\n    tc = typecode(msg)\n\n    if tc != 19:\n        raise RuntimeError(\"%s: Not an airborne velocity message, expecting TC = 19\" % msg)\n\n\n    msgbin = common.hex2bin(msg)\n    NUCv = common.bin2int(msgbin[42:45])\n\n    try:\n        HVE = uncertainty.NUCv[NUCv]['HVE']\n        VVE = uncertainty.NUCv[NUCv]['VVE']\n    except KeyError:\n        HVE, VVE = uncertainty.NA, uncertainty.NA\n\n    return HVE, VVE"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nic_v1(msg, NICs):\n    if typecode(msg) < 5 or typecode(msg) > 22:\n        raise RuntimeError(\n            \"%s: Not a surface position message (5<TC<8), \\\n            airborne position message (8<TC<19), \\\n            or airborne position with GNSS height (20<TC<22)\" % msg\n        )\n\n    tc = typecode(msg)\n    NIC = uncertainty.TC_NICv1_lookup[tc]\n\n    if isinstance(NIC, dict):\n        NIC = NIC[NICs]\n\n    try:\n        Rc = uncertainty.NICv1[NIC][NICs]['Rc']\n        VPL = uncertainty.NICv1[NIC][NICs]['VPL']\n    except KeyError:\n        Rc, VPL = uncertainty.NA, uncertainty.NA\n\n    return Rc, VPL", "response": "Calculate NIC navigation integrity category for ADS - B version 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating NIC navigation integrity category for ADS - B version 2", "response": "def nic_v2(msg, NICa, NICbc):\n    \"\"\"Calculate NIC, navigation integrity category, for ADS-B version 2\n\n    Args:\n        msg (string): 28 bytes hexadecimal message string\n        NICa (int or string): NIC supplement - A\n        NICbc (int or srting): NIC supplement - B or C\n\n    Returns:\n        int or string: Horizontal Radius of Containment\n    \"\"\"\n    if typecode(msg) < 5 or typecode(msg) > 22:\n        raise RuntimeError(\n            \"%s: Not a surface position message (5<TC<8), \\\n            airborne position message (8<TC<19), \\\n            or airborne position with GNSS height (20<TC<22)\" % msg\n        )\n\n    tc = typecode(msg)\n    NIC = uncertainty.TC_NICv2_lookup[tc]\n\n    if 20<=tc<=22:\n        NICs = 0\n    else:\n        NICs = NICa*2 + NICbc\n\n    try:\n        if isinstance(NIC, dict):\n            NIC = NIC[NICs]\n\n        Rc = uncertainty.NICv2[NIC][NICs]['Rc']\n    except KeyError:\n        Rc = uncertainty.NA\n\n    return Rc"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nobtaining NIC supplement bit from a status operation message.", "response": "def nic_s(msg):\n    \"\"\"Obtain NIC supplement bit, TC=31 message\n\n    Args:\n        msg (string): 28 bytes hexadecimal message string\n\n    Returns:\n        int: NICs number (0 or 1)\n    \"\"\"\n    tc = typecode(msg)\n\n    if tc != 31:\n        raise RuntimeError(\"%s: Not a status operation message, expecting TC = 31\" % msg)\n\n    msgbin = common.hex2bin(msg)\n    nic_s = int(msgbin[75])\n\n    return nic_s"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nic_a_c(msg):\n    tc = typecode(msg)\n\n    if tc != 31:\n        raise RuntimeError(\"%s: Not a status operation message, expecting TC = 31\" % msg)\n\n    msgbin = common.hex2bin(msg)\n    nic_a = int(msgbin[75])\n    nic_c = int(msgbin[51])\n\n    return nic_a, nic_c", "response": "Obtain NICa and NICc number from a status operation message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nic_b(msg):\n    tc = typecode(msg)\n\n    if tc < 9 or tc > 18:\n        raise RuntimeError(\"%s: Not a airborne position message, expecting 8<TC<19\" % msg)\n\n    msgbin = common.hex2bin(msg)\n    nic_b = int(msgbin[39])\n\n    return nic_b", "response": "Obtain NICb from a message in the NICs base - 2 format."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nac_p(msg):\n    tc = typecode(msg)\n\n    if tc not in [29, 31]:\n        raise RuntimeError(\"%s: Not a target state and status message, \\\n                           or operation status message, expecting TC = 29 or 31\" % msg)\n\n    msgbin = common.hex2bin(msg)\n\n    if tc == 29:\n        NACp = common.bin2int(msgbin[71:75])\n    elif tc == 31:\n        NACp = common.bin2int(msgbin[76:80])\n\n    try:\n        EPU = uncertainty.NACp[NACp]['EPU']\n        VEPU = uncertainty.NACp[NACp]['VEPU']\n    except KeyError:\n        EPU, VEPU = uncertainty.NA, uncertainty.NA\n\n    return EPU, VEPU", "response": "Calculate NACp Navigation Accuracy Category - Position\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef nac_v(msg):\n    tc = typecode(msg)\n\n    if tc != 19:\n        raise RuntimeError(\"%s: Not an airborne velocity message, expecting TC = 19\" % msg)\n\n    msgbin = common.hex2bin(msg)\n    NACv = common.bin2int(msgbin[42:45])\n\n    try:\n        HFOMr = uncertainty.NACv[NACv]['HFOMr']\n        VFOMr = uncertainty.NACv[NACv]['VFOMr']\n    except KeyError:\n        HFOMr, VFOMr = uncertainty.NA, uncertainty.NA\n\n    return HFOMr, VFOMr", "response": "Calculate NACv Navigation Accuracy Category - Velocity\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates SIL Surveillance Integrity Level", "response": "def sil(msg, version):\n    \"\"\"Calculate SIL, Surveillance Integrity Level\n\n    Args:\n        msg (string): 28 bytes hexadecimal message string with TC = 29, 31\n\n    Returns:\n        int or string: Probability of exceeding Horizontal Radius of Containment RCu\n        int or string: Probability of exceeding Vertical Integrity Containment Region VPL\n        string: SIL supplement based on per \"hour\" or \"sample\", or 'unknown'\n    \"\"\"\n    tc = typecode(msg)\n\n    if tc not in [29, 31]:\n        raise RuntimeError(\"%s: Not a target state and status messag, \\\n                           or operation status message, expecting TC = 29 or 31\" % msg)\n\n    msgbin = common.hex2bin(msg)\n\n    if tc == 29:\n        SIL = common.bin2int(msgbin[76:78])\n    elif tc == 31:\n        SIL = common.bin2int(msgbin[82:84])\n\n    try:\n        PE_RCu = uncertainty.SIL[SIL]['PE_RCu']\n        PE_VPL = uncertainty.SIL[SIL]['PE_VPL']\n    except KeyError:\n        PE_RCu, PE_VPL = uncertainty.NA, uncertainty.NA\n\n    base = 'unknown'\n\n    if version == 2:\n        if tc == 29:\n            SIL_SUP = common.bin2int(msgbin[39])\n        elif tc == 31:\n            SIL_SUP = common.bin2int(msgbin[86])\n\n        if SIL_SUP == 0:\n            base = \"hour\"\n        elif SIL_SUP == 1:\n            base = \"sample\"\n\n    return PE_RCu, PE_VPL, base"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is50(msg):\n\n    if allzeros(msg):\n        return False\n\n    d = hex2bin(data(msg))\n\n    # status bit 1, 12, 24, 35, 46\n\n    if wrongstatus(d, 1, 3, 11):\n        return False\n\n    if wrongstatus(d, 12, 13, 23):\n        return False\n\n    if wrongstatus(d, 24, 25, 34):\n        return False\n\n    if wrongstatus(d, 35, 36, 45):\n        return False\n\n    if wrongstatus(d, 46, 47, 56):\n        return False\n\n    roll = roll50(msg)\n    if (roll is not None) and abs(roll) > 60:\n        return False\n\n    gs = gs50(msg)\n    if gs is not None and gs > 600:\n        return False\n\n    tas = tas50(msg)\n    if tas is not None and tas > 500:\n        return False\n\n    if (gs is not None) and (tas is not None) and (abs(tas - gs) > 200):\n        return False\n\n    return True", "response": "Check if a message is likely to be BDS code 5 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef roll50(msg):\n    d = hex2bin(data(msg))\n\n    if d[0] == '0':\n        return None\n\n    sign = int(d[1])    # 1 -> left wing down\n    value = bin2int(d[2:11])\n\n    if sign:\n        value = value - 512\n\n    angle = value * 45.0 / 256.0    # degree\n    return round(angle, 1)", "response": "Roll angle in degrees from BDS 5 0 message to BDS 5 0 message"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef trk50(msg):\n    d = hex2bin(data(msg))\n\n    if d[11] == '0':\n        return None\n\n    sign = int(d[12])   # 1 -> west\n    value = bin2int(d[13:23])\n\n    if sign:\n        value = value - 1024\n\n    trk = value * 90.0 / 512.0\n\n    # convert from [-180, 180] to [0, 360]\n    if trk < 0:\n        trk = 360 + trk\n\n    return round(trk, 3)", "response": "True track angle BDS 5 0 message"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef gs50(msg):\n    d = hex2bin(data(msg))\n\n    if d[23] == '0':\n        return None\n\n    spd = bin2int(d[24:34]) * 2    # kts\n    return spd", "response": "Ground speed in knots of BDS 5 0 message"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tas50(msg):\n    d = hex2bin(data(msg))\n\n    if d[45] == '0':\n        return None\n\n    tas = bin2int(d[46:56]) * 2   # kts\n    return tas", "response": "Aircraft true airspeed BDS 5 0 message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if a message is likely to be BDS code 5 3", "response": "def is53(msg):\n    \"\"\"Check if a message is likely to be BDS code 5,3\n    (Air-referenced state vector)\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        bool: True or False\n    \"\"\"\n\n    if allzeros(msg):\n        return False\n\n    d = hex2bin(data(msg))\n\n    # status bit 1, 13, 24, 34, 47\n\n    if wrongstatus(d, 1, 3, 12):\n        return False\n\n    if wrongstatus(d, 13, 14, 23):\n        return False\n\n    if wrongstatus(d, 24, 25, 33):\n        return False\n\n    if wrongstatus(d, 34, 35, 46):\n        return False\n\n    if wrongstatus(d, 47, 49, 56):\n        return False\n\n    ias = ias53(msg)\n    if ias is not None and ias > 500:\n        return False\n\n    mach = mach53(msg)\n    if mach is not None and mach > 1:\n        return False\n\n    tas = tas53(msg)\n    if tas is not None and tas > 500:\n        return False\n\n    vr = vr53(msg)\n    if vr is not None and abs(vr) > 8000:\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nindicates airspeed DBS 5 3 message returning the knots in knots53 if the message is not in knots53 otherwise None.", "response": "def ias53(msg):\n    \"\"\"Indicated airspeed, DBS 5,3 message\n\n    Args:\n        msg (String): 28 bytes hexadecimal message\n\n    Returns:\n        int: indicated arispeed in knots\n    \"\"\"\n    d = hex2bin(data(msg))\n\n    if d[12] == '0':\n        return None\n\n    ias = bin2int(d[13:23])    # knots\n    return ias"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the MACH number of the message in the next 28 bytes of the message.", "response": "def mach53(msg):\n    \"\"\"MACH number, DBS 5,3 message\n\n    Args:\n        msg (String): 28 bytes hexadecimal message\n\n    Returns:\n        float: MACH number\n    \"\"\"\n    d = hex2bin(data(msg))\n\n    if d[23] == '0':\n        return None\n\n    mach = bin2int(d[24:33]) * 0.008\n    return round(mach, 3)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_beast_buffer(self):\n        '''\n        <esc> \"1\" : 6 byte MLAT timestamp, 1 byte signal level,\n            2 byte Mode-AC\n        <esc> \"2\" : 6 byte MLAT timestamp, 1 byte signal level,\n            7 byte Mode-S short frame\n        <esc> \"3\" : 6 byte MLAT timestamp, 1 byte signal level,\n            14 byte Mode-S long frame\n        <esc> \"4\" : 6 byte MLAT timestamp, status data, DIP switch\n            configuration settings (not on Mode-S Beast classic)\n        <esc><esc>: true 0x1a\n        <esc> is 0x1a, and \"1\", \"2\" and \"3\" are 0x31, 0x32 and 0x33\n\n        timestamp:\n        wiki.modesbeast.com/Radarcape:Firmware_Versions#The_GPS_timestamp\n        '''\n\n        messages_mlat = []\n        msg = []\n        i = 0\n\n        # process the buffer until the last divider <esc> 0x1a\n        # then, reset the self.buffer with the remainder\n\n        while i < len(self.buffer):\n            if (self.buffer[i:i+2] == [0x1a, 0x1a]):\n                msg.append(0x1a)\n                i += 1\n            elif (i == len(self.buffer) - 1) and (self.buffer[i] == 0x1a):\n                # special case where the last bit is 0x1a\n                msg.append(0x1a)\n            elif self.buffer[i] == 0x1a:\n                if i == len(self.buffer) - 1:\n                    # special case where the last bit is 0x1a\n                    msg.append(0x1a)\n                elif len(msg) > 0:\n                    messages_mlat.append(msg)\n                    msg = []\n            else:\n                msg.append(self.buffer[i])\n            i += 1\n\n        # save the reminder for next reading cycle, if not empty\n        if len(msg) > 0:\n            reminder = []\n            for i, m in enumerate(msg):\n                if (m == 0x1a) and (i < len(msg)-1):\n                    # rewind 0x1a, except when it is at the last bit\n                    reminder.extend([m, m])\n                else:\n                    reminder.append(m)\n            self.buffer = [0x1a] + msg\n        else:\n            self.buffer = []\n\n        # extract messages\n        messages = []\n        for mm in messages_mlat:\n            ts = time.time()\n\n            msgtype = mm[0]\n            # print(''.join('%02X' % i for i in mm))\n\n            if msgtype == 0x32:\n                # Mode-S Short Message, 7 byte, 14-len hexstr\n                msg = ''.join('%02X' % i for i in mm[8:15])\n            elif msgtype == 0x33:\n                # Mode-S Long Message, 14 byte, 28-len hexstr\n                msg = ''.join('%02X' % i for i in mm[8:22])\n            else:\n                # Other message tupe\n                continue\n\n            if len(msg) not in [14, 28]:\n                # incomplete message\n                continue\n\n            messages.append([msg, ts])\n        return messages", "response": "Read the Beast buffer and return a list of the messages and the message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the skysense stream format from the buffer.", "response": "def read_skysense_buffer(self):\n        \"\"\"Skysense stream format.\n\n        ::\n\n            ----------------------------------------------------------------------------------\n            Field      SS MS MS MS MS MS MS MS MS MS MS MS MS MS MS TS TS TS TS TS TS RS RS RS\n            ----------------------------------------------------------------------------------\n            Position:   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\n            ----------------------------------------------------------------------------------\n\n            SS field - Start character\n            Position 0:\n              1 byte = 8 bits\n              Start character '$'\n\n            MS field - Payload\n            Postion 1 through 14:\n              14 bytes = 112 bits\n              Mode-S payload\n              In case of DF types that only carry 7 bytes of information\n                position 8 through 14 are set to 0x00.\n\n            TS field - Time stamp\n            Position 15 through 20:\n              6 bytes = 48 bits\n              Time stamp with fields as:\n\n                Lock Status - Status of internal time keeping mechanism\n                Equal to 1 if operating normally\n                Bit 47 - 1 bit\n\n                Time of day in UTC seconds, between 0 and 86399\n                Bits 46 through 30 - 17 bits\n\n                Nanoseconds into current second, between 0 and 999999999\n                Bits 29 through 0 - 30 bits\n\n            RS field - Signal Level\n            Position 21 through 23:\n              3 bytes = 24 bits\n              RSSI (received signal strength indication) and relative\n                noise level with fields\n\n              RNL, Q12.4 unsigned fixed point binary with 4 fractional\n                bits and 8 integer bits.\n              This is and indication of the noise level of the message.\n                Roughly 40 counts per 10dBm.\n              Bits 23 through 12 - 12 bits\n\n              RSSI, Q12.4 unsigned fixed point binary with 4 fractional\n                bits and 8 integer bits.\n              This is an indication of the signal level of the received\n                message in ADC counts. Roughly 40 counts per 10dBm.\n              Bits 11 through 0 - 12 bits\n        \"\"\"\n        SS_MSGLENGTH = 24\n        SS_STARTCHAR = 0x24\n\n        if len(self.buffer) <= SS_MSGLENGTH:\n            return None\n\n        messages = []\n        while len(self.buffer) > SS_MSGLENGTH:\n            i = 0\n            if self.buffer[i] == SS_STARTCHAR and self.buffer[i+SS_MSGLENGTH] == SS_STARTCHAR:\n                i += 1\n                if (self.buffer[i]>>7):\n                    #Long message\n                    payload = self.buffer[i:i+14]\n                else:\n                    #Short message\n                    payload = self.buffer[i:i+7]\n                msg = ''.join('%02X' % j for j in payload)\n                i += 14 #Both message types use 14 bytes\n                tsbin = self.buffer[i:i+6]\n                sec   = ( (tsbin[0] & 0x7f) << 10) | (tsbin[1] << 2 ) | (tsbin[2] >> 6)\n                nano  = ( (tsbin[2] & 0x3f) << 24) | (tsbin[3] << 16) | (tsbin[4] << 8) | tsbin[5]\n                ts = sec + nano*1.0e-9\n                i += 6\n                #Signal and noise level - Don't care for now\n                i += 3\n                self.buffer = self.buffer[SS_MSGLENGTH:]\n                messages.append( [msg,ts] )\n            else:\n                self.buffer = self.buffer[1:]\n        return messages"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if a message is likely to be BDS code 1 0 0", "response": "def is10(msg):\n    \"\"\"Check if a message is likely to be BDS code 1,0\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        bool: True or False\n    \"\"\"\n\n    if allzeros(msg):\n        return False\n\n    d = hex2bin(data(msg))\n\n    # first 8 bits must be 0x10\n    if d[0:8] != '00010000':\n        return False\n\n    # bit 10 to 14 are reserved\n    if bin2int(d[9:14]) != 0:\n        return False\n\n    # overlay capabilty conflict\n    if d[14] == '1' and bin2int(d[16:23]) < 5:\n        return False\n    if d[14] == '0' and bin2int(d[16:23]) > 4:\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is17(msg):\n\n    if allzeros(msg):\n        return False\n\n    d = hex2bin(data(msg))\n\n    if bin2int(d[28:56]) != 0:\n        return False\n\n    caps = cap17(msg)\n\n    # basic BDS codes for ADS-B shall be supported\n    #   assuming ADS-B out is installed (2017EU/2020US mandate)\n    # if not set(['BDS05', 'BDS06', 'BDS08', 'BDS09', 'BDS20']).issubset(caps):\n    #     return False\n\n    # at least you can respond who you are\n    if 'BDS20' not in caps:\n        return False\n\n    return True", "response": "Check if a message is likely to be BDS code 1 7"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cap17(msg):\n    allbds = ['05', '06', '07', '08', '09', '0A', '20', '21', '40', '41',\n              '42', '43', '44', '45', '48', '50', '51', '52', '53', '54',\n              '55', '56', '5F', '60', 'NA', 'NA', 'E1', 'E2']\n\n    d = hex2bin(data(msg))\n    idx = [i for i, v in enumerate(d[:28]) if v=='1']\n    capacity = ['BDS'+allbds[i] for i in idx if allbds[i] is not 'NA']\n\n    return capacity", "response": "Extract capacities from BDS 1 7 message"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process_raw(self, adsb_ts, adsb_msgs, commb_ts, commb_msgs, tnow=None):\n        if tnow is None:\n            tnow = time.time()\n\n        self.t = tnow\n\n        local_updated_acs_buffer = []\n        output_buffer = []\n\n        # process adsb message\n        for t, msg in zip(adsb_ts, adsb_msgs):\n            icao = pms.icao(msg)\n            tc = pms.adsb.typecode(msg)\n\n            if icao not in self.acs:\n                self.acs[icao] = {\n                    'live': None,\n                    'call': None,\n                    'lat': None,\n                    'lon': None,\n                    'alt': None,\n                    'gs': None,\n                    'trk': None,\n                    'roc': None,\n                    'tas': None,\n                    'roll': None,\n                    'rtrk': None,\n                    'ias': None,\n                    'mach': None,\n                    'hdg': None,\n                    'ver' : None,\n                    'HPL' : None,\n                    'RCu' : None,\n                    'RCv' : None,\n                    'HVE' : None,\n                    'VVE' : None,\n                    'Rc' : None,\n                    'VPL' : None,\n                    'EPU' : None,\n                    'VEPU' : None,\n                    'HFOMr' : None,\n                    'VFOMr' : None,\n                    'PE_RCu' : None,\n                    'PE_VPL' : None,\n                }\n\n            self.acs[icao]['t'] = t\n            self.acs[icao]['live'] = int(t)\n\n            if 1 <= tc <= 4:\n                cs = pms.adsb.callsign(msg)\n                self.acs[icao]['call'] = cs\n                output_buffer.append([t, icao, 'cs', cs])\n\n            if (5 <= tc <= 8) or (tc == 19):\n                vdata = pms.adsb.velocity(msg)\n                if vdata is None:\n                    continue\n\n                spd, trk, roc, tag = vdata\n                if tag != 'GS':\n                    continue\n                if (spd is None) or (trk is None):\n                    continue\n\n                self.acs[icao]['gs'] = spd\n                self.acs[icao]['trk'] = trk\n                self.acs[icao]['roc'] = roc\n                self.acs[icao]['tv'] = t\n\n                output_buffer.append([t, icao, 'gs', spd])\n                output_buffer.append([t, icao, 'trk', trk])\n                output_buffer.append([t, icao, 'roc', roc])\n\n\n            if (5 <= tc <= 18):\n                oe = pms.adsb.oe_flag(msg)\n                self.acs[icao][oe] = msg\n                self.acs[icao]['t'+str(oe)] = t\n\n                if ('tpos' in self.acs[icao]) and (t - self.acs[icao]['tpos'] < 180):\n                    # use single message decoding\n                    rlat = self.acs[icao]['lat']\n                    rlon = self.acs[icao]['lon']\n                    latlon = pms.adsb.position_with_ref(msg, rlat, rlon)\n                elif ('t0' in self.acs[icao]) and ('t1' in self.acs[icao]) and \\\n                     (abs(self.acs[icao]['t0'] - self.acs[icao]['t1']) < 10):\n                    # use multi message decoding\n                    try:\n                        latlon = pms.adsb.position(\n                            self.acs[icao][0],\n                            self.acs[icao][1],\n                            self.acs[icao]['t0'],\n                            self.acs[icao]['t1'],\n                            self.lat0, self.lon0\n                            )\n                    except:\n                        # mix of surface and airborne position message\n                        continue\n                else:\n                    latlon = None\n\n                if latlon is not None:\n                    self.acs[icao]['tpos'] = t\n                    self.acs[icao]['lat'] = latlon[0]\n                    self.acs[icao]['lon'] = latlon[1]\n\n                    alt = pms.adsb.altitude(msg)\n                    self.acs[icao]['alt'] = alt\n\n                    output_buffer.append([t, icao, 'lat', latlon[0]])\n                    output_buffer.append([t, icao, 'lon', latlon[1]])\n                    output_buffer.append([t, icao, 'alt', alt])\n\n                    local_updated_acs_buffer.append(icao)\n\n            # Uncertainty & accuracy\n            ac = self.acs[icao]\n\n            if 9 <= tc <= 18:\n                ac['nic_bc'] = pms.adsb.nic_b(msg)\n\n            if (5 <= tc <= 8) or (9 <= tc <= 18) or (20 <= tc <= 22):\n                ac['HPL'], ac['RCu'], ac['RCv'] = pms.adsb.nuc_p(msg)\n\n                if (ac['ver'] == 1) and ('nic_s' in ac.keys()):\n                    ac['Rc'], ac['VPL'] = pms.adsb.nic_v1(msg, ac['nic_s'])\n                elif (ac['ver'] == 2) and ('nic_a' in ac.keys()) and ('nic_bc' in ac.keys()):\n                    ac['Rc'] = pms.adsb.nic_v2(msg, ac['nic_a'], ac['nic_bc'])\n\n            if tc == 19:\n                ac['HVE'], ac['VVE'] = pms.adsb.nuc_v(msg)\n                if ac['ver'] in [1, 2]:\n                    ac['HFOMr'], ac['VFOMr'] = pms.adsb.nac_v(msg)\n\n            if tc == 29:\n                ac['PE_RCu'], ac['PE_VPL'], ac['base'] = pms.adsb.sil(msg, ac['ver'])\n                ac['EPU'], ac['VEPU'] = pms.adsb.nac_p(msg)\n\n            if tc == 31:\n                ac['ver']  = pms.adsb.version(msg)\n                ac['EPU'], ac['VEPU'] = pms.adsb.nac_p(msg)\n                ac['PE_RCu'], ac['PE_VPL'], ac['sil_base'] = pms.adsb.sil(msg, ac['ver'])\n\n                if ac['ver']  == 1:\n                    ac['nic_s'] = pms.adsb.nic_s(msg)\n                elif ac['ver']  == 2:\n                    ac['nic_a'], ac['nic_bc'] = pms.adsb.nic_a_c(msg)\n\n\n        # process commb message\n        for t, msg in zip(commb_ts, commb_msgs):\n            icao = pms.icao(msg)\n\n            if icao not in self.acs:\n                continue\n\n            bds = pms.bds.infer(msg)\n\n            if bds == 'BDS50':\n                roll50 = pms.commb.roll50(msg)\n                trk50 = pms.commb.trk50(msg)\n                rtrk50 = pms.commb.rtrk50(msg)\n                gs50 = pms.commb.gs50(msg)\n                tas50 = pms.commb.tas50(msg)\n\n                self.acs[icao]['t50'] = t\n                if tas50:\n                    self.acs[icao]['tas'] = tas50\n                    output_buffer.append([t, icao, 'tas50', tas50])\n                if roll50:\n                    self.acs[icao]['roll'] = roll50\n                    output_buffer.append([t, icao, 'roll50', roll50])\n                if rtrk50:\n                    self.acs[icao]['rtrk'] = rtrk50\n                    output_buffer.append([t, icao, 'rtrk50', rtrk50])\n\n                if trk50:\n                    output_buffer.append([t, icao, 'trk50', trk50])\n                if gs50:\n                    output_buffer.append([t, icao, 'gs50', gs50])\n\n            elif bds == 'BDS60':\n                ias60 = pms.commb.ias60(msg)\n                hdg60 = pms.commb.hdg60(msg)\n                mach60 = pms.commb.mach60(msg)\n                roc60baro = pms.commb.vr60baro(msg)\n                roc60ins = pms.commb.vr60ins(msg)\n\n                if ias60 or hdg60 or mach60:\n                    self.acs[icao]['t60'] = t\n                if ias60:\n                    self.acs[icao]['ias'] = ias60\n                if hdg60:\n                    self.acs[icao]['hdg'] = hdg60\n                if mach60:\n                    self.acs[icao]['mach'] = mach60\n\n                if roc60baro:\n                    output_buffer.append([t, icao, 'roc60baro', roc60baro])\n                if roc60ins:\n                    output_buffer.append([t, icao, 'roc60ins', roc60ins])\n\n        # clear up old data\n        for icao in list(self.acs.keys()):\n            if self.t - self.acs[icao]['live'] > self.cache_timeout:\n                del self.acs[icao]\n                continue\n\n        if self.dumpto is not None:\n            dh = str(datetime.datetime.now().strftime(\"%Y%m%d_%H\"))\n            fn = self.dumpto + '/pymodes_dump_%s.csv' % dh\n            output_buffer.sort(key=lambda x: x[0])\n            with open(fn, \"a\") as f:\n                writer = csv.writer(f)\n                writer.writerows(output_buffer)\n\n        return", "response": "process a chunk of adsb and commb messages recieved in the same calendar time period"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_aircraft(self):\n        acs = self.acs\n        icaos = list(acs.keys())\n        for icao in icaos:\n            if acs[icao]['lat'] is None:\n                acs.pop(icao)\n        return acs", "response": "get all aircrafts in memeory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef airborne_velocity(msg):\n\n    if common.typecode(msg) != 19:\n        raise RuntimeError(\"%s: Not a airborne velocity message, expecting TC=19\" % msg)\n\n    mb = common.hex2bin(msg)[32:]\n\n    subtype = common.bin2int(mb[5:8])\n\n    if common.bin2int(mb[14:24]) == 0 or common.bin2int(mb[25:35]) == 0:\n        return None\n\n    if subtype in (1, 2):\n        v_ew_sign = -1 if mb[13]=='1' else 1\n        v_ew = common.bin2int(mb[14:24]) - 1       # east-west velocity\n\n        v_ns_sign = -1 if mb[24]=='1' else 1\n        v_ns = common.bin2int(mb[25:35]) - 1       # north-south velocity\n\n        v_we = v_ew_sign * v_ew\n        v_sn = v_ns_sign * v_ns\n\n        spd = math.sqrt(v_sn*v_sn + v_we*v_we)  # unit in kts\n        spd = int(spd)\n\n        trk = math.atan2(v_we, v_sn)\n        trk = math.degrees(trk)                 # convert to degrees\n        trk = trk if trk >= 0 else trk + 360    # no negative val\n\n        tag = 'GS'\n        trk_or_hdg = round(trk, 2)\n\n    else:\n        if mb[13] == '0':\n            hdg = None\n        else:\n            hdg = common.bin2int(mb[14:24]) / 1024.0 * 360.0\n            hdg = round(hdg, 2)\n\n        trk_or_hdg = hdg\n\n        spd = common.bin2int(mb[25:35])\n        spd = None if spd==0 else spd-1\n\n        if mb[24]=='0':\n            tag = 'IAS'\n        else:\n            tag = 'TAS'\n\n    vr_sign = -1 if mb[36]=='1' else 1\n    vr = common.bin2int(mb[37:46])\n    rocd = None if vr==0 else int(vr_sign*(vr-1)*64)\n\n    return spd, trk_or_hdg, rocd, tag", "response": "Calculate the speed ground track or heading and vertical rate of the airborne."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndecode the differece between GNSS and barometric altitude.", "response": "def altitude_diff(msg):\n    \"\"\"Decode the differece between GNSS and barometric altitude\n\n    Args:\n        msg (string): 28 bytes hexadecimal message string, TC=19\n\n    Returns:\n        int: Altitude difference in ft. Negative value indicates GNSS altitude\n            below barometric altitude.\n    \"\"\"\n    tc = common.typecode(msg)\n\n    if tc != 19:\n        raise RuntimeError(\"%s: Not a airborne velocity message, expecting TC=19\" % msg)\n\n    msgbin = common.hex2bin(msg)\n    sign = -1 if int(msgbin[80]) else 1\n    value = common.bin2int(msgbin[81:88])\n\n    if value == 0 or value == 127:\n        return None\n    else:\n        return sign * (value - 1) * 25"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is50or60(msg, spd_ref, trk_ref, alt_ref):\n    def vxy(v, angle):\n        vx = v * np.sin(np.radians(angle))\n        vy = v * np.cos(np.radians(angle))\n        return vx, vy\n\n    if not (bds50.is50(msg) and bds60.is60(msg)):\n        return None\n\n    h50 = bds50.trk50(msg)\n    v50 = bds50.gs50(msg)\n\n    if h50 is None or v50 is None:\n        return 'BDS50,BDS60'\n\n    h60 = bds60.hdg60(msg)\n    m60 = bds60.mach60(msg)\n    i60 = bds60.ias60(msg)\n\n    if h60 is None or (m60 is None and i60 is None):\n        return 'BDS50,BDS60'\n\n    m60 = np.nan if m60 is None else m60\n    i60 = np.nan if i60 is None else i60\n\n    XY5 = vxy(v50*aero.kts, h50)\n    XY6m = vxy(aero.mach2tas(m60, alt_ref*aero.ft), h60)\n    XY6i = vxy(aero.cas2tas(i60*aero.kts, alt_ref*aero.ft), h60)\n\n    allbds = ['BDS50', 'BDS60', 'BDS60']\n\n    X = np.array([XY5, XY6m, XY6i])\n    Mu = np.array(vxy(spd_ref*aero.kts, trk_ref))\n\n    # compute Mahalanobis distance matrix\n    # Cov = [[20**2, 0], [0, 20**2]]\n    # mmatrix = np.sqrt(np.dot(np.dot(X-Mu, np.linalg.inv(Cov)), (X-Mu).T))\n    # dist = np.diag(mmatrix)\n\n    # since the covariance matrix is identity matrix,\n    #     M-dist is same as eculidian distance\n    try:\n        dist = np.linalg.norm(X-Mu, axis=1)\n        BDS = allbds[np.nanargmin(dist)]\n    except ValueError:\n        return 'BDS50,BDS60'\n\n    return BDS", "response": "Return the BDS50 and DBS60 version of the message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninferring the most likely BDS code of a message.", "response": "def infer(msg, mrar=False):\n    \"\"\"Estimate the most likely BDS code of an message.\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n        mrar (bool): Also infer MRAR (BDS 44) and MHR (BDS 45). Defaults to False.\n\n    Returns:\n        String or None: BDS version, or possible versions, or None if nothing matches.\n\n    \"\"\"\n    df = common.df(msg)\n\n    if common.allzeros(msg):\n        return 'EMPTY'\n\n    # For ADS-B / Mode-S extended squitter\n    if df == 17:\n        tc = common.typecode(msg)\n\n        if 1 <= tc <= 4:\n            return 'BDS08'  # indentification and category\n        if 5 <= tc <= 8:\n            return 'BDS06'  # surface movement\n        if 9 <= tc <= 18:\n            return 'BDS05'  # airborne position, baro-alt\n        if tc == 19:\n            return 'BDS09'  # airborne velocity\n        if 20 <= tc <= 22:\n            return 'BDS05'  # airborne position, gnss-alt\n        if tc == 28:\n            return 'BDS61'  # aircraft status\n        if tc == 29:\n            return 'BDS62'  # target state and status\n        if tc == 31:\n            return 'BDS65'  # operational status\n\n    # For Comm-B replies\n    IS10 = bds10.is10(msg)\n    IS17 = bds17.is17(msg)\n    IS20 = bds20.is20(msg)\n    IS30 = bds30.is30(msg)\n    IS40 = bds40.is40(msg)\n    IS50 = bds50.is50(msg)\n    IS60 = bds60.is60(msg)\n    IS44 = bds44.is44(msg)\n    IS45 = bds45.is45(msg)\n\n    if mrar:\n        allbds = np.array([\"BDS10\", \"BDS17\", \"BDS20\", \"BDS30\", \"BDS40\",\n                           \"BDS44\", \"BDS45\", \"BDS50\", \"BDS60\"])\n        mask = [IS10, IS17, IS20, IS30, IS40, IS44, IS45, IS50, IS60]\n    else:\n        allbds = np.array([\"BDS10\", \"BDS17\", \"BDS20\", \"BDS30\", \"BDS40\",\n                           \"BDS50\", \"BDS60\"])\n        mask = [IS10, IS17, IS20, IS30, IS40, IS50, IS60]\n\n    bds = ','.join(sorted(allbds[mask]))\n\n    if len(bds) == 0:\n        return None\n    else:\n        return bds"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is40(msg):\n\n    if allzeros(msg):\n        return False\n\n    d = hex2bin(data(msg))\n\n    # status bit 1, 14, and 27\n\n    if wrongstatus(d, 1, 2, 13):\n        return False\n\n    if wrongstatus(d, 14, 15, 26):\n        return False\n\n    if wrongstatus(d, 27, 28, 39):\n        return False\n\n    if wrongstatus(d, 48, 49, 51):\n        return False\n\n    if wrongstatus(d, 54, 55, 56):\n        return False\n\n    # bits 40-47 and 52-53 shall all be zero\n\n    if bin2int(d[39:47]) != 0:\n        return False\n\n    if bin2int(d[51:53]) != 0:\n        return False\n\n    return True", "response": "Check if a message is likely to be BDS code 4 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef alt40mcp(msg):\n    d = hex2bin(data(msg))\n\n    if d[0] == '0':\n        return None\n\n    alt = bin2int(d[1:13]) * 16    # ft\n    return alt", "response": "Selected altitude in MCP or FCU"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nselecting altitude in FMS", "response": "def alt40fms(msg):\n    \"\"\"Selected altitude, FMS\n\n    Args:\n        msg (String): 28 bytes hexadecimal message (BDS40) string\n\n    Returns:\n        int: altitude in feet\n    \"\"\"\n    d = hex2bin(data(msg))\n\n    if d[13] == '0':\n        return None\n\n    alt = bin2int(d[14:26]) * 16    # ft\n    return alt"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if a message is likely to be BDS code 4 4.", "response": "def is44(msg):\n    \"\"\"Check if a message is likely to be BDS code 4,4.\n\n    Meteorological routine air report\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        bool: True or False\n\n    \"\"\"\n    if allzeros(msg):\n        return False\n\n    d = hex2bin(data(msg))\n\n    # status bit 5, 35, 47, 50\n    if wrongstatus(d, 5, 6, 23):\n        return False\n\n    if wrongstatus(d, 35, 36, 46):\n        return False\n\n    if wrongstatus(d, 47, 48, 49):\n        return False\n\n    if wrongstatus(d, 50, 51, 56):\n        return False\n\n    # Bits 1-4 indicate source, values > 4 reserved and should not occur\n    if bin2int(d[0:4]) > 4:\n        return False\n\n    vw = wind44(msg)\n    if vw is not None and vw[0] > 250:\n        return False\n\n    temp, temp2 = temp44(msg)\n    if min(temp, temp2) > 60 or max(temp, temp2) < -80:\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wind44(msg):\n    d = hex2bin(data(msg))\n\n    status = int(d[4])\n    if not status:\n        return None\n\n    speed = bin2int(d[5:14])   # knots\n    direction = bin2int(d[14:23]) * 180.0 / 256.0  # degree\n\n    return round(speed, 0), round(direction, 1)", "response": "Wind speed and direction."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hum44(msg):\n    d = hex2bin(data(msg))\n\n    if d[49] == '0':\n        return None\n\n    hm = bin2int(d[50:56]) * 100.0 / 64    # %\n\n    return round(hm, 1)", "response": "Returns the percentage of humidity in a base - 28 message"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecode a pair of even and odd position message and yield the correct solution.", "response": "def surface_position(msg0, msg1, t0, t1, lat_ref, lon_ref):\n    \"\"\"Decode surface position from a pair of even and odd position message,\n    the lat/lon of receiver must be provided to yield the correct solution.\n\n    Args:\n        msg0 (string): even message (28 bytes hexadecimal string)\n        msg1 (string): odd message (28 bytes hexadecimal string)\n        t0 (int): timestamps for the even message\n        t1 (int): timestamps for the odd message\n        lat_ref (float): latitude of the receiver\n        lon_ref (float): longitude of the receiver\n\n    Returns:\n        (float, float): (latitude, longitude) of the aircraft\n    \"\"\"\n\n    msgbin0 = common.hex2bin(msg0)\n    msgbin1 = common.hex2bin(msg1)\n\n    # 131072 is 2^17, since CPR lat and lon are 17 bits each.\n    cprlat_even = common.bin2int(msgbin0[54:71]) / 131072.0\n    cprlon_even = common.bin2int(msgbin0[71:88]) / 131072.0\n    cprlat_odd = common.bin2int(msgbin1[54:71]) / 131072.0\n    cprlon_odd = common.bin2int(msgbin1[71:88]) / 131072.0\n\n    air_d_lat_even = 90.0 / 60\n    air_d_lat_odd = 90.0 / 59\n\n    # compute latitude index 'j'\n    j = common.floor(59 * cprlat_even - 60 * cprlat_odd + 0.5)\n\n    # solution for north hemisphere\n    lat_even_n = float(air_d_lat_even * (j % 60 + cprlat_even))\n    lat_odd_n = float(air_d_lat_odd * (j % 59 + cprlat_odd))\n\n    # solution for north hemisphere\n    lat_even_s = lat_even_n - 90.0\n    lat_odd_s = lat_odd_n - 90.0\n\n    # chose which solution corrispondes to receiver location\n    lat_even = lat_even_n if lat_ref > 0 else lat_even_s\n    lat_odd = lat_odd_n if lat_ref > 0 else lat_odd_s\n\n    # check if both are in the same latidude zone, rare but possible\n    if common.cprNL(lat_even) != common.cprNL(lat_odd):\n        return None\n\n    # compute ni, longitude index m, and longitude\n    if (t0 > t1):\n        lat = lat_even\n        nl = common.cprNL(lat_even)\n        ni = max(common.cprNL(lat_even) - 0, 1)\n        m = common.floor(cprlon_even * (nl-1) - cprlon_odd * nl + 0.5)\n        lon = (90.0 / ni) * (m % ni + cprlon_even)\n    else:\n        lat = lat_odd\n        nl = common.cprNL(lat_odd)\n        ni = max(common.cprNL(lat_odd) - 1, 1)\n        m = common.floor(cprlon_even * (nl-1) - cprlon_odd * nl + 0.5)\n        lon = (90.0 / ni) * (m % ni + cprlon_odd)\n\n    # four possible longitude solutions\n    lons = [lon, lon + 90.0, lon + 180.0, lon + 270.0]\n\n    # the closest solution to receiver is the correct one\n    dls = [abs(lon_ref - l) for l in lons]\n    imin = min(range(4), key=dls.__getitem__)\n    lon = lons[imin]\n\n    return round(lat, 5), round(lon, 5)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndecode a message in the format of a 2 - byte surface position format to a 2 - byte surface velocity format.", "response": "def surface_velocity(msg):\n    \"\"\"Decode surface velocity from from a surface position message\n    Args:\n        msg (string): 28 bytes hexadecimal message string\n\n    Returns:\n        (int, float, int, string): speed (kt), ground track (degree),\n            rate of climb/descend (ft/min), and speed type\n            ('GS' for ground speed, 'AS' for airspeed)\n    \"\"\"\n\n    if common.typecode(msg) < 5 or common.typecode(msg) > 8:\n        raise RuntimeError(\"%s: Not a surface message, expecting 5<TC<8\" % msg)\n\n    mb = common.hex2bin(msg)[32:]\n\n    # ground track\n    trk_status = int(mb[12])\n    if trk_status == 1:\n        trk = common.bin2int(mb[13:20]) * 360.0 / 128.0\n        trk = round(trk, 1)\n    else:\n        trk = None\n\n    # ground movment / speed\n    mov = common.bin2int(mb[5:12])\n\n    if mov == 0 or mov > 124:\n        spd = None\n    elif mov == 1:\n        spd = 0\n    elif mov == 124:\n        spd = 175\n    else:\n        movs = [2, 9, 13, 39, 94, 109, 124]\n        kts = [0.125, 1, 2, 15, 70, 100, 175]\n        i = next(m[0] for m in enumerate(movs) if m[1] > mov)\n        step = (kts[i] - kts[i-1]) * 1.0 / (movs[i]-movs[i-1])\n        spd = kts[i-1] + (mov-movs[i-1]) * step\n        spd = round(spd, 2)\n\n    return spd, trk, 0, 'GS'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is20(msg):\n\n    if allzeros(msg):\n        return False\n\n    d = hex2bin(data(msg))\n\n    if d[0:8] != '00100000':\n        return False\n\n    cs = cs20(msg)\n\n    if '#' in cs:\n        return False\n\n    return True", "response": "Check if a message is likely to be BDS code 2 0 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if a message is likely to be BDS code 6 0 0", "response": "def is60(msg):\n    \"\"\"Check if a message is likely to be BDS code 6,0\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        bool: True or False\n    \"\"\"\n\n    if allzeros(msg):\n        return False\n\n    d = hex2bin(data(msg))\n\n    # status bit 1, 13, 24, 35, 46\n\n    if wrongstatus(d, 1, 2, 12):\n        return False\n\n    if wrongstatus(d, 13, 14, 23):\n        return False\n\n    if wrongstatus(d, 24, 25, 34):\n        return False\n\n    if wrongstatus(d, 35, 36, 45):\n        return False\n\n    if wrongstatus(d, 46, 47, 56):\n        return False\n\n    ias = ias60(msg)\n    if ias is not None and ias > 500:\n        return False\n\n    mach = mach60(msg)\n    if mach is not None and mach > 1:\n        return False\n\n    vr_baro = vr60baro(msg)\n    if vr_baro is not None and abs(vr_baro) > 6000:\n        return False\n\n    vr_ins = vr60ins(msg)\n    if vr_ins is not None and abs(vr_ins) > 6000:\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ias60(msg):\n    d = hex2bin(data(msg))\n\n    if d[12] == '0':\n        return None\n\n    ias = bin2int(d[13:23])    # kts\n    return ias", "response": "Indicated airspeed in knots"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef vr60baro(msg):\n    d = hex2bin(data(msg))\n\n    if d[34] == '0':\n        return None\n\n    sign = int(d[35])    # 1 -> negative value, two's complement\n    value = bin2int(d[36:45])\n\n    if value == 0 or value == 511:  # all zeros or all ones\n        return 0\n\n    value = value - 512 if sign else value\n\n    roc = value * 32   # feet/min\n    return roc", "response": "Vertical rate from barometric measurement"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if a message is likely to be BDS code 4 5.", "response": "def is45(msg):\n    \"\"\"Check if a message is likely to be BDS code 4,5.\n\n    Meteorological hazard report\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        bool: True or False\n\n    \"\"\"\n    if allzeros(msg):\n        return False\n\n    d = hex2bin(data(msg))\n\n    # status bit 1, 4, 7, 10, 13, 16, 27, 39\n    if wrongstatus(d, 1, 2, 3):\n        return False\n\n    if wrongstatus(d, 4, 5, 6):\n        return False\n\n    if wrongstatus(d, 7, 8, 9):\n        return False\n\n    if wrongstatus(d, 10, 11, 12):\n        return False\n\n    if wrongstatus(d, 13, 14, 15):\n        return False\n\n    if wrongstatus(d, 16, 17, 26):\n        return False\n\n    if wrongstatus(d, 27, 28, 38):\n        return False\n\n    if wrongstatus(d, 39, 40, 51):\n        return False\n\n    # reserved\n    if bin2int(d[51:56]) != 0:\n        return False\n\n    temp = temp45(msg)\n    if temp:\n        if temp > 60 or temp < -80:\n            return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef turb45(msg):\n    d = hex2bin(data(msg))\n    if d[0] == '0':\n        return None\n\n    turb = bin2int(d[1:3])\n    return turb", "response": "Turbulence. turb45 - > Turbulence level"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ws45(msg):\n    d = hex2bin(data(msg))\n    if d[3] == '0':\n        return None\n\n    ws = bin2int(d[4:6])\n    return ws", "response": "Wind shear.\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        int: Wind shear level. 0=NIL, 1=Light, 2=Moderate, 3=Severe"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mb45(msg):\n    d = hex2bin(data(msg))\n    if d[6] == '0':\n        return None\n\n    mb = bin2int(d[7:9])\n    return mb", "response": "Microburst.\n    - Returns the level of the next message in the message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ic45(msg):\n    d = hex2bin(data(msg))\n    if d[9] == '0':\n        return None\n\n    ic = bin2int(d[10:12])\n    return ic", "response": "Icing.\n    - Returns the Icing level."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wv45(msg):\n    d = hex2bin(data(msg))\n    if d[12] == '0':\n        return None\n\n    ws = bin2int(d[13:15])\n    return ws", "response": "Wake vortex.\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        int: Wake vortex level. 0=NIL, 1=Light, 2=Moderate, 3=Severe"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef temp45(msg):\n    d = hex2bin(data(msg))\n\n    sign = int(d[16])\n    value = bin2int(d[17:26])\n\n    if sign:\n        value = value - 512\n\n    temp = value * 0.25   # celsius\n    temp = round(temp, 1)\n\n    return temp", "response": "Static air temperature.\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        float: tmeperature in Celsius degree"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef p45(msg):\n    d = hex2bin(data(msg))\n    if d[26] == '0':\n        return None\n    p = bin2int(d[27:38])    # hPa\n    return p", "response": "Average static pressure in a message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rh45(msg):\n    d = hex2bin(data(msg))\n    if d[38] == '0':\n        return None\n    rh = bin2int(d[39:51]) * 16\n    return rh", "response": "Radio height.\n\n    Args:\n        msg (String): 28 bytes hexadecimal message string\n\n    Returns:\n        int: radio height in ft"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef distance(lat1, lon1, lat2, lon2, H=0):\n\n    # phi = 90 - latitude\n    phi1 = np.radians(90.0 - lat1)\n    phi2 = np.radians(90.0 - lat2)\n\n    # theta = longitude\n    theta1 = np.radians(lon1)\n    theta2 = np.radians(lon2)\n\n    cos = np.sin(phi1) * np.sin(phi2) * np.cos(theta1 - theta2) + np.cos(phi1) * np.cos(phi2)\n    cos = np.where(cos>1, 1, cos)\n\n    arc = np.arccos(cos)\n    dist = arc * (r_earth + H)   # meters, radius of earth\n    return dist", "response": "Compute spherical distance from two locations in spherical coordinates."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntrue Airspeed to Mach number", "response": "def tas2mach(Vtas, H):\n    \"\"\"True Airspeed to Mach number\"\"\"\n    a = vsound(H)\n    Mach = Vtas/a\n    return Mach"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mach2tas(Mach, H):\n    a = vsound(H)\n    Vtas = Mach*a\n    return Vtas", "response": "Mach number to True Airspeed"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tas2eas(Vtas, H):\n    rho = density(H)\n    Veas = Vtas * np.sqrt(rho/rho0)\n    return Veas", "response": "True Airspeed to Equivalent Airspeed"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalibrating Airspeed to True Airspeed", "response": "def cas2tas(Vcas, H):\n    \"\"\"Calibrated Airspeed to True Airspeed\"\"\"\n    p, rho, T = atmos(H)\n    qdyn = p0*((1.+rho0*Vcas*Vcas/(7.*p0))**3.5-1.)\n    Vtas = np.sqrt(7.*p/rho*((1.+qdyn/p)**(2./7.)-1.))\n    return Vtas"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalibrate Airspeed to Mach number", "response": "def cas2mach(Vcas, H):\n    \"\"\"Calibrated Airspeed to Mach number\"\"\"\n    Vtas = cas2tas(Vcas, H)\n    Mach = tas2mach(Vtas, H)\n    return Mach"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef markdown_imgur_uploader(request):\n    if request.method == 'POST' and request.is_ajax():\n        if 'markdown-image-upload' in request.FILES:\n            image = request.FILES['markdown-image-upload']\n            data = imgur_uploader(image)\n            return HttpResponse(data, content_type='application/json')\n        return HttpResponse(_('Invalid request!'))\n    return HttpResponse(_('Invalid request!'))", "response": "Makdown image upload for uploading to imgur. com\n    and represent as json to markdown editor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef markdown_search_user(request):\n    data = {}\n    username = request.GET.get('username')\n    if username is not None \\\n            and username != '' \\\n            and ' ' not in username:\n        users = User.objects.filter(\n            Q(username__icontains=username)\n        ).filter(is_active=True)\n        if users.exists():\n            data.update({\n                'status': 200,\n                'data': [{'username': u.username} for u in users]\n            })\n            return HttpResponse(\n                json.dumps(data, cls=LazyEncoder),\n                content_type='application/json')\n        data.update({\n            'status': 204,\n            'error': _('No users registered as `%(username)s` '\n                       'or user is unactived.') % {'username': username}\n        })\n    else:\n        data.update({\n            'status': 204,\n            'error': _('Validation Failed for field `username`')\n        })\n    return HttpResponse(\n        json.dumps(data, cls=LazyEncoder),\n        content_type='application/json')", "response": "Markdown search user method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handleMatch(self, m):\n        username = self.unescape(m.group(2))\n\n        \"\"\"Makesure `username` is registered and actived.\"\"\"\n        if MARTOR_ENABLE_CONFIGS['mention'] == 'true':\n            if username in [u.username for u in User.objects.exclude(is_active=False)]:\n                url = '{0}{1}/'.format(MARTOR_MARKDOWN_BASE_MENTION_URL, username)\n                el = markdown.util.etree.Element('a')\n                el.set('href', url)\n                el.set('class', 'direct-mention-link')\n                el.text = markdown.util.AtomicString('@' + username)\n                return el", "response": "Makesure username is registered and actived."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef imgur_uploader(image):\n    url_api = 'https://api.imgur.com/3/upload.json'\n    headers = {'Authorization': 'Client-ID ' + MARTOR_IMGUR_CLIENT_ID}\n    response = requests.post(\n        url_api,\n        headers=headers,\n        data={\n            'key': MARTOR_IMGUR_API_KEY,\n            'image': base64.b64encode(image.read()),\n            'type': 'base64',\n            'name': image.name\n        }\n    )\n\n    \"\"\"\n    Some function we got from `response`:\n\n    ['connection', 'content', 'cookies', 'elapsed', 'encoding', 'headers','history',\n    'is_permanent_redirect', 'is_redirect', 'iter_content', 'iter_lines', 'json',\n    'links', 'ok', 'raise_for_status', 'raw', 'reason', 'request', 'status_code', 'text', 'url']\n    \"\"\"\n    if response.status_code == 200:\n        respdata = json.loads(response.content.decode('utf-8'))\n        return json.dumps({\n            'status': respdata['status'],\n            'link': respdata['data']['link'],\n            'name': respdata['data']['name']\n        })\n    elif response.status_code == 415:\n        # Unsupport File type\n        return json.dumps({\n            'status': response.status_code,\n            'error': response.reason\n        })\n    return json.dumps({\n        'status': response.status_code,\n        'error': response.content.decode('utf-8')\n    })", "response": "Basic imgur uploader return as json data."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrender the markdown content to HTML.", "response": "def markdownify(markdown_content):\n    \"\"\"\n    Render the markdown content to HTML.\n\n    Basic:\n        >>> from martor.utils import markdownify\n        >>> content = \"![awesome](http://i.imgur.com/hvguiSn.jpg)\"\n        >>> markdownify(content)\n        '<p><img alt=\"awesome\" src=\"http://i.imgur.com/hvguiSn.jpg\" /></p>'\n        >>>\n    \"\"\"\n    try:\n        return markdown.markdown(\n            markdown_content,\n            safe_mode=MARTOR_MARKDOWN_SAFE_MODE,\n            extensions=MARTOR_MARKDOWN_EXTENSIONS,\n            extension_configs=MARTOR_MARKDOWN_EXTENSION_CONFIGS\n        )\n    except Exception:\n        raise VersionNotCompatible(\"The markdown isn't compatible, please reinstall \"\n                                   \"your python markdown into Markdown>=3.0\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of SliceViewContext s.", "response": "def _ctxs(self):\n        \"\"\"\n        :rtype: list of SliceViewContext\n        \"\"\"\n        return [self._tab_widget.widget(index).context for index in range(0, self._tab_widget.count())]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_segy_view_widget(self, ind, widget, name=None):\n\n        if self._context is None:\n            self._segywidgets.append(widget)\n            self.initialize()\n            return 0 # return 0 for first widget index\n\n        self._tab_widget.updatesEnabled = False\n        widget.show_toolbar(toolbar=True, layout_combo=False, colormap=True, save=True, settings=True)\n        self._modify_qtree(widget.settings_window.qtree, [0, 1, 2, 4])\n\n        if name is None:\n            name = os.path.basename(widget.slice_data_source.source_filename)\n\n        id = self._tab_widget.insertTab(ind, widget, name)\n\n        widget.context.data_changed.connect(self._local_data_changed)\n        self._tab_widget.updatesEnabled = True\n\n        return id", "response": "Adds a SegyViewWidget to the SegyTabWidget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the internal _indexes and _index attributes of the current object.", "response": "def indexes(self, indexes):\n        \"\"\" :type indexes: list[int] \"\"\"\n        self._indexes = indexes\n        self._index = len(indexes) / 2"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the x - index of the data set.", "response": "def x_indexes(self, indexes):\n        \"\"\" :type indexes: list[int] \"\"\"\n        self._assert_shape(self._data, indexes, self._y_indexes)\n        self._x_indexes = indexes\n        self.x_index = len(indexes) / 2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the y - index of the data set.", "response": "def y_indexes(self, indexes):\n        \"\"\" :type indexes: list[int] \"\"\"\n        self._assert_shape(self._data, self._x_indexes, indexes)\n        self._y_indexes = indexes\n        self.y_index = len(indexes) / 2"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef data(self, data):\n        self._assert_shape(data, self._x_indexes, self._y_indexes)\n        data[data == -np.inf] = 0.0\n        data[data == np.inf] = 0.0\n        self._data = data\n        self._min_value = np.nanmin(self.data)\n        self._max_value = np.nanmax(self.data)\n        self._data_x_indexes = list(range(data.shape[0]))\n        self._data_y_indexes = list(range(data.shape[1]))\n        self._dirty = False", "response": "Sets the data of the current object to the given data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef index(self, index):\n        if self._index != index:\n            self._dirty = True\n        self._index = index", "response": "Sets the index of the assessment."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a slice of the image.", "response": "def create_slice(self, context):\n        \"\"\" :type context: dict \"\"\"\n        model = self._model\n        axes = self._image.axes\n        \"\"\" :type: matplotlib.axes.Axes \"\"\"\n\n        axes.set_title(model.title, fontsize=12)\n        axes.tick_params(axis='both')\n        axes.set_ylabel(model.y_axis_name, fontsize=9)\n        axes.set_xlabel(model.x_axis_name, fontsize=9)\n\n        axes.get_xaxis().set_major_formatter(FuncFormatter(model.x_axis_formatter))\n        axes.get_xaxis().set_major_locator(AutoLocator())\n\n        axes.get_yaxis().set_major_formatter(FuncFormatter(model.y_axis_formatter))\n        axes.get_yaxis().set_major_locator(AutoLocator())\n\n        for label in (axes.get_xticklabels() + axes.get_yticklabels()):\n            label.set_fontsize(9)\n\n        self._reset_zoom()\n\n        axes.add_patch(self._vertical_indicator)\n        axes.add_patch(self._horizontal_indicator)\n        self._update_indicators(context)\n\n        self._image.set_cmap(cmap=context['colormap'])\n\n        self._view_limits = context[\"view_limits\"][self._model.index_direction['name']]\n\n        if model.data is not None:\n            self._image.set_data(model.data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef data_changed(self, context):\n        model = self._model\n        self._image.set_data(model.data)\n        self._image.set_extent((0, model.width, model.height, 0))", "response": "Called when the data of the resource store has changed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef context_changed(self, context):\n        self._image.set_cmap(context['colormap'])\n        self._image.set_clim(context['min'], context['max'])\n        self._image.set_interpolation(context['interpolation'])\n        self._update_indicators(context)\n\n        self._set_view_limits()\n\n        if self._model.index_direction is not SliceDirection.depth:\n            self._image.axes.set_ylabel(context['samples_unit'])", "response": "Updates the image with the new context."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the indicators of the related elements in the related elements.", "response": "def _update_indicators(self, context):\n        \"\"\" :type context: dict \"\"\"\n        model = self._model\n        self._vertical_indicator.set_height(model.height + 1)\n        self._vertical_indicator.set_width(1)\n        self._horizontal_indicator.set_width(model.width + 1)\n        self._horizontal_indicator.set_height(1)\n\n        show_indicators = context['show_indicators']\n\n        self._vertical_indicator.set_visible(model.x_index is not None and show_indicators)\n        self._horizontal_indicator.set_visible(model.y_index is not None and show_indicators)\n\n        if model.x_index is not None and show_indicators:\n            self._vertical_indicator.set_x(model.x_index)\n\n        if model.y_index is not None and show_indicators:\n            self._horizontal_indicator.set_y(model.y_index)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_index_for_direction(self, index_direction, index):\n        indexes = self._slice_data_source.indexes_for_direction(index_direction)\n\n        if index < 0:\n            index = 0\n        elif index >= len(indexes):\n            index = len(indexes) - 1\n\n        for m in self._available_slice_models:\n            if m.index_direction == index_direction:\n                m.index = index\n\n            if m.x_index_direction == index_direction:\n                m.x_index = index\n\n            if m.y_index_direction == index_direction:\n                m.y_index = index\n\n        self.load_data()", "response": "Updates the index of the slice in the specified direction."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_spec(self, index):\n        user_data = self.itemData(index)\n        \"\"\" :type: QVariant\"\"\"\n        spec = user_data.toPyObject()\n        return {str(key): value for key, value in spec.items()}", "response": "Returns a dictionary of the user s spec."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _create_icon(self, color_map_name, image, values):\n\n        color_map = ScalarMappable(cmap=color_map_name)\n        rgba = color_map.to_rgba(values, bytes=True)\n\n        color_table = [qRgb(c[0], c[1], c[2]) for c in rgba]\n        image.setColorTable(color_table)\n\n        return QPixmap.fromImage(image).scaledToWidth(128)", "response": "Create an icon from a color map and a numpy array."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef index(self, axes):\n        return None if axes is self._colormap_axes else self._axes.index(axes)", "response": "Returns the index of the n - tuple of the n - tuple of the given axes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting package version as listed in __version__ in init. py.", "response": "def get_version(package):\n    \"\"\"\n    Return package version as listed in `__version__` in `init.py`.\n    \"\"\"\n    init_py = codecs.open(os.path.join(package, '__init__.py'), encoding='utf-8').read()\n    return re.search(\"^__version__ = ['\\\"]([^'\\\"]+)['\\\"]\", init_py, re.MULTILINE).group(1)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the entry url given and entry page a blog page instance.", "response": "def get_entry_url(entry, blog_page, root_page):\n    \"\"\"\n    Get the entry url given and entry page a blog page instances.\n    It will use an url or another depending if blog_page is the root page.\n    \"\"\"\n    if root_page == blog_page:\n        return reverse('entry_page_serve', kwargs={\n            'year': entry.date.strftime('%Y'),\n            'month': entry.date.strftime('%m'),\n            'day': entry.date.strftime('%d'),\n            'slug': entry.slug\n        })\n    else:\n        # The method get_url_parts provides a tuple with a custom URL routing\n        # scheme. In the last position it finds the subdomain of the blog, which\n        # it is used to construct the entry url.\n        # Using the stripped subdomain it allows Puput to generate the urls for\n        # every sitemap level\n        blog_path = strip_prefix_and_ending_slash(blog_page.specific.last_url_part)\n        return reverse('entry_page_serve_slug', kwargs={\n            'blog_path': blog_path,\n            'year': entry.date.strftime('%Y'),\n            'month': entry.date.strftime('%m'),\n            'day': entry.date.strftime('%d'),\n            'slug': entry.slug\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_feeds_url(blog_page, root_page):\n    if root_page == blog_page:\n        return reverse('blog_page_feed')\n    else:\n        blog_path = strip_prefix_and_ending_slash(blog_page.specific.last_url_part)\n        return reverse('blog_page_feed_slug', kwargs={'blog_path': blog_path})", "response": "Get the url of the feeds of a blog page."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_blockquote_feature(features):\n    feature_name = 'blockquote'\n    type_ = 'blockquote'\n    tag = 'blockquote'\n\n    control = {\n        'type': type_,\n        'label': '\u275d',\n        'description': 'Quote',\n        'element': 'blockquote',\n    }\n\n    features.register_editor_plugin(\n        'draftail',\n        feature_name,\n        draftail_features.BlockFeature(control)\n    )\n\n    features.register_converter_rule(\n        'contentstate',\n        feature_name,\n        {\n            'from_database_format': {tag: BlockElementHandler(type_)},\n            'to_database_format': {'block_map': {type_: tag}},\n        }\n    )\n    features.default_features.append(feature_name)", "response": "Register the blockquote feature."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninstalling all packages in dependency list via pip.", "response": "def install_dependencies(dependencies, verbose=False):\n    \"\"\"Install all packages in dependency list via pip.\"\"\"\n    if not dependencies:\n        return\n\n    stdout = stderr = None if verbose else subprocess.DEVNULL\n    with tempfile.TemporaryDirectory() as req_dir:\n        req_file = Path(req_dir) / \"requirements.txt\"\n\n        with open(req_file, \"w\") as f:\n            for dependency in dependencies:\n                f.write(f\"{dependency}\\n\")\n\n        pip = [\"python3\", \"-m\", \"pip\", \"install\", \"-r\", req_file]\n        # Unless we are in a virtualenv, we need --user\n        if sys.base_prefix == sys.prefix and not hasattr(sys, \"real_prefix\"):\n            pip.append(\"--user\")\n\n        try:\n            subprocess.check_call(pip, stdout=stdout, stderr=stderr)\n        except subprocess.CalledProcessError:\n            raise Error(_(\"failed to install dependencies\"))\n\n        # Reload sys.path, to find recently installed packages\n        importlib.reload(site)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef install_translations(config):\n\n    if not config:\n        return\n\n    from . import _translation\n    checks_translation = gettext.translation(domain=config[\"domain\"],\n                                             localedir=internal.check_dir / config[\"localedir\"],\n                                             fallback=True)\n    _translation.add_fallback(checks_translation)", "response": "Installs translations according to config as a fallback to existing translations"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef await_results(url, pings=45, sleep=2):\n\n    print(\"Checking...\", end=\"\", flush=True)\n    for _ in range(pings):\n        # Query for check results.\n        res = requests.post(url)\n        if res.status_code != 200:\n            continue\n        payload = res.json()\n        if payload[\"complete\"]:\n            break\n        print(\".\", end=\"\", flush=True)\n        time.sleep(sleep)\n    else:\n        # Terminate if no response\n        print()\n        raise Error(\n            _(\"check50 is taking longer than normal!\\nSee https://cs50.me/checks/{} for more detail.\").format(commit_hash))\n    print()\n\n    # TODO: Should probably check payload[\"checks\"][\"version\"] here to make sure major version is same as __version__\n    # (otherwise we may not be able to parse results)\n    return (CheckResult(**result) for result in payload[\"checks\"][\"results\"])", "response": "Wait until the url returns a results payload."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef include(*paths):\n    cwd = os.getcwd()\n    for path in paths:\n        _copy((internal.check_dir / path).resolve(), cwd)", "response": "Copy files and directories from the check directory to the current directory"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhashing the file using SHA - 256.", "response": "def hash(file):\n    \"\"\"\n    Hashes file using SHA-256.\n\n    :param file: name of file to be hashed\n    :type file: str\n    :rtype: str\n    :raises check50.Failure: if ``file`` does not exist\n\n    \"\"\"\n\n    exists(file)\n    log(_(\"hashing {}...\").format(file))\n\n    # https://stackoverflow.com/a/22058673\n    with open(file, \"rb\") as f:\n        sha256 = hashlib.sha256()\n        for block in iter(lambda: f.read(65536), b\"\"):\n            sha256.update(block)\n        return sha256.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nasserts that all given paths exist.", "response": "def exists(*paths):\n    \"\"\"\n    Assert that all given paths exist.\n\n    :params paths: files/directories to be checked for existence\n    :raises check50.Failure: if any ``path in paths`` does not exist\n\n    Example usage::\n\n        check50.exists(\"foo.c\", \"foo.h\")\n\n    \"\"\"\n    for path in paths:\n        log(_(\"checking that {} exists...\").format(path))\n        if not os.path.exists(path):\n            raise Failure(_(\"{} not found\").format(path))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef import_checks(path):\n    dir = internal.check_dir / path\n    file = internal.load_config(dir)[\"checks\"]\n    mod = internal.import_file(dir.name, (dir / file).resolve())\n    sys.modules[dir.name] = mod\n    return mod", "response": "Imports the checks module given relative path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget raw representation of s truncating if too long.", "response": "def _raw(s):\n    \"\"\"Get raw representation of s, truncating if too long.\"\"\"\n\n    if isinstance(s, list):\n        s = \"\\n\".join(_raw(item) for item in s)\n\n    if s == EOF:\n        return \"EOF\"\n\n    s = repr(s)  # Get raw representation of string\n    s = s[1:-1]  # Strip away quotation marks\n    if len(s) > 15:\n        s = s[:15] + \"...\"  # Truncate if too long\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncopy src to dst recursively if src is a directory.", "response": "def _copy(src, dst):\n    \"\"\"Copy src to dst, copying recursively if src is a directory.\"\"\"\n    try:\n        shutil.copy(src, dst)\n    except IsADirectoryError:\n        if os.path.isdir(dst):\n            dst = os.path.join(dst, os.path.basename(src))\n        shutil.copytree(src, dst)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stdin(self, line, prompt=True, timeout=3):\n        if line == EOF:\n            log(\"sending EOF...\")\n        else:\n            log(_(\"sending input {}...\").format(line))\n\n        if prompt:\n            try:\n                self.process.expect(\".+\", timeout=timeout)\n            except (TIMEOUT, EOF):\n                raise Failure(_(\"expected prompt for input, found none\"))\n            except UnicodeDecodeError:\n                raise Failure(_(\"output not valid ASCII text\"))\n        try:\n            if line == EOF:\n                self.process.sendeof()\n            else:\n                self.process.sendline(line)\n        except OSError:\n            pass\n        return self", "response": "Send a line to the stdin optionally expect a prompt."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stdout(self, output=None, str_output=None, regex=True, timeout=3):\n        if output is None:\n            self._wait(timeout)\n            return self.process.before.replace(\"\\r\\n\", \"\\n\").lstrip(\"\\n\")\n\n        try:\n            output = output.read()\n        except AttributeError:\n            pass\n\n        expect = self.process.expect if regex else self.process.expect_exact\n\n        if str_output is None:\n            str_output = output\n\n        if output == EOF:\n            log(_(\"checking for EOF...\"))\n        else:\n            output = output.replace(\"\\n\", \"\\r\\n\")\n            log(_(\"checking for output \\\"{}\\\"...\").format(str_output))\n\n        try:\n            expect(output, timeout=timeout)\n        except EOF:\n            result = self.process.before + self.process.buffer\n            if self.process.after != EOF:\n                result += self.process.after\n            raise Mismatch(str_output, result.replace(\"\\r\\n\", \"\\n\"))\n        except TIMEOUT:\n            raise Failure(_(\"did not find \\\"{}\\\"\").format(_raw(str_output)))\n        except UnicodeDecodeError:\n            raise Failure(_(\"output not valid ASCII text\"))\n        except Exception:\n            raise Failure(_(\"check50 could not verify output\"))\n\n        # If we expected EOF and we still got output, report an error.\n        if output == EOF and self.process.before:\n            raise Mismatch(EOF, self.process.before.replace(\"\\r\\n\", \"\\n\"))\n\n        return self", "response": "Retrieve all output from stdout."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck that the process survives for timeout.", "response": "def reject(self, timeout=1):\n        \"\"\"\n        Check that the process survives for timeout. Useful for checking whether program is waiting on input.\n\n        :param timeout: number of seconds to wait\n        :type timeout: int / float\n        :raises check50.Failure: if process ends before ``timeout``\n\n        \"\"\"\n        log(_(\"checking that input was rejected...\"))\n        try:\n            self._wait(timeout)\n        except Failure as e:\n            if not isinstance(e.__cause__, TIMEOUT):\n                raise\n        else:\n            raise Failure(_(\"expected program to reject input, but it did not\"))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef exit(self, code=None, timeout=5):\n        self._wait(timeout)\n\n        if code is None:\n            return self.exitcode\n\n        log(_(\"checking that program exited with status {}...\").format(code))\n        if self.exitcode != code:\n            raise Failure(_(\"expected exit code {}, not {}\").format(code, self.exitcode))\n        return self", "response": "Exit the process with the given exit code."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload configuration file from check_dir and apply it to unspecified values.", "response": "def load_config(check_dir):\n    \"\"\"\n    Load configuration file from ``check_dir / \".cs50.yaml\"``, applying\n    defaults to unspecified values.\n\n    :param check_dir: directory from which to load config file\n    :type check_dir: str / Path\n    :rtype: dict\n    \"\"\"\n\n    # Defaults for top-level keys\n    options = {\n        \"checks\": \"__init__.py\",\n        \"dependencies\": None,\n        \"translations\": None\n    }\n\n    # Defaults for translation keys\n    translation_options = {\n        \"localedir\": \"locale\",\n        \"domain\": \"messages\",\n    }\n\n    config_file = Path(check_dir) / \".cs50.yaml\"\n\n    with open(config_file) as f:\n        config = lib50.config.load(f.read(), \"check50\")\n\n    if isinstance(config, dict):\n        options.update(config)\n\n    if options[\"translations\"]:\n        if isinstance(options[\"translations\"], dict):\n            translation_options.update(options[\"translations\"])\n        options[\"translations\"] = translation_options\n\n    if isinstance(options[\"checks\"], dict):\n        # Compile simple checks\n        with open(check_dir / \"__init__.py\", \"w\") as f:\n            f.write(simple.compile(options[\"checks\"]))\n        options[\"checks\"] = \"__init__.py\"\n\n    return options"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef import_file(name, path):\n    spec = importlib.util.spec_from_file_location(name, path)\n    mod = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(mod)\n    return mod", "response": "Imports a file given a raw file path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compile(*files, exe_name=None, cc=CC, **cflags):\n\n    if not files:\n        raise RuntimeError(_(\"compile requires at least one file\"))\n\n    if exe_name is None and files[0].endswith(\".c\"):\n        exe_name = Path(files[0]).stem\n\n    files = \" \".join(files)\n\n    flags = CFLAGS.copy()\n    flags.update(cflags)\n    flags = \" \".join((f\"-{flag}\" + (f\"={value}\" if value is not True else \"\")).replace(\"_\", \"-\")\n                     for flag, value in flags.items() if value)\n\n    out_flag = f\" -o {exe_name} \" if exe_name is not None else \" \"\n\n    run(f\"{cc} {files}{out_flag}{flags}\").exit(0)", "response": "Compile a list of files into a new executable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef valgrind(command, env={}):\n    xml_file = tempfile.NamedTemporaryFile()\n    internal.register.after_check(lambda: _check_valgrind(xml_file))\n\n    # Ideally we'd like for this whole command not to be logged.\n    return run(f\"valgrind --show-leak-kinds=all --xml=yes --xml-file={xml_file.name} -- {command}\", env=env)", "response": "Run a command with valgrind."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if valgrind errors occurred.", "response": "def _check_valgrind(xml_file):\n    \"\"\"Log and report any errors encountered by valgrind.\"\"\"\n    log(_(\"checking for valgrind errors...\"))\n\n    # Load XML file created by valgrind\n    xml = ET.ElementTree(file=xml_file)\n\n    # Ensure that we don't get duplicate error messages.\n    reported = set()\n    for error in xml.iterfind(\"error\"):\n        # Type of error valgrind encountered\n        kind = error.find(\"kind\").text\n\n        # Valgrind's error message\n        what = error.find(\"xwhat/text\" if kind.startswith(\"Leak_\") else \"what\").text\n\n        # Error message that we will report\n        msg = [\"\\t\", what]\n\n        # Find first stack frame within student's code.\n        for frame in error.iterfind(\"stack/frame\"):\n            obj = frame.find(\"obj\")\n            if obj is not None and internal.run_dir in Path(obj.text).parents:\n                file, line = frame.find(\"file\"), frame.find(\"line\")\n                if file is not None and line is not None:\n                    msg.append(f\": ({_('file')}: {file.text}, {_('line')}: {line.text})\")\n                break\n\n        msg = \"\".join(msg)\n        if msg not in reported:\n            log(msg)\n            reported.add(msg)\n\n    # Only raise exception if we encountered errors.\n    if reported:\n        raise Failure(_(\"valgrind tests failed; rerun with --log for more information.\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _timeout(seconds):\n\n    def _handle_timeout(*args):\n        raise Timeout(seconds)\n\n    signal.signal(signal.SIGALRM, _handle_timeout)\n    signal.alarm(seconds)\n    try:\n        yield\n    finally:\n        signal.alarm(0)\n        signal.signal(signal.SIGALRM, signal.SIG_DFL)", "response": "Context manager that runs code block until timeout is reached."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check(dependency=None, timeout=60):\n            check50.exists(\"hello.c\")\n\n        @check50.check(exists) # Mark 'compiles' as a check that depends on 'exists'\n        def compiles():\n            \\\"\"\"hello.c compiles\\\"\"\"\n            check50.c.compile(\"hello.c\")\n\n        @check50.check(compiles)\n        def prints_hello():\n            \\\"\"\"prints \"Hello, world!\\\\\\\\n\\\"\"\"\n            # Since 'prints_hello', depends on 'compiles' it inherits the compiled binary\n            check50.run(\"./hello\").stdout(\"[Hh]ello, world!?\\\\n\", \"hello, world\\\\n\").exit()\n\n    \"\"\"\n    def decorator(check):\n\n        # Modules are evaluated from the top of the file down, so _check_names will\n        # contain the names of the checks in the order in which they are declared\n        _check_names.append(check.__name__)\n        check._check_dependency = dependency\n\n        @functools.wraps(check)\n        def wrapper(checks_root, dependency_state):\n            # Result template\n            result = CheckResult.from_check(check)\n            # Any shared (returned) state\n            state = None\n\n            try:\n                # Setup check environment, copying disk state from dependency\n                internal.run_dir = checks_root / check.__name__\n                src_dir = checks_root / (dependency.__name__ if dependency else \"-\")\n                shutil.copytree(src_dir, internal.run_dir)\n                os.chdir(internal.run_dir)\n\n                # Run registered functions before/after running check and set timeout\n                with internal.register, _timeout(seconds=timeout):\n                    args = (dependency_state,) if inspect.getfullargspec(check).args else ()\n                    state = check(*args)\n            except Failure as e:\n                result.passed = False\n                result.cause = e.payload\n            except BaseException as e:\n                result.passed = None\n                result.cause = {\"rationale\": _(\"check50 ran into an error while running checks!\")}\n                log(repr(e))\n                for line in traceback.format_tb(e.__traceback__):\n                    log(line.rstrip())\n                log(_(\"Contact sysadmins@cs50.harvard.edu with the URL of this check!\"))\n            else:\n                result.passed = True\n            finally:\n                result.log = _log\n                result.data = _data\n                return result, state\n        return wrapper\n    return decorator", "response": "A decorator that checks that the specified dependency is available on the base directory of the specified object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns all checks in the module and return a list of CheckResults.", "response": "def run(self, files, working_area):\n        \"\"\"\n        Run checks concurrently.\n        Returns a list of CheckResults ordered by declaration order of the checks in the imported module\n        \"\"\"\n\n        # Ensure that dictionary is ordered by check declaration order (via self.check_names)\n        # NOTE: Requires CPython 3.6. If we need to support older versions of Python, replace with OrderedDict.\n        results = {name: None for name in self.check_names}\n        checks_root = working_area.parent\n        with futures.ProcessPoolExecutor() as executor:\n\n            # Start all checks that have no dependencies\n            not_done = set(executor.submit(run_check(name, self.checks_spec, checks_root))\n                           for name, _ in self.child_map[None])\n            not_passed = []\n\n            while not_done:\n                done, not_done = futures.wait(not_done, return_when=futures.FIRST_COMPLETED)\n                for future in done:\n                    # Get result from completed check\n                    result, state = future.result()\n                    results[result.name] = result\n                    if result.passed:\n                        # Dispatch dependent checks\n                        for child_name, _ in self.child_map[result.name]:\n                            not_done.add(executor.submit(\n                                run_check(child_name, self.checks_spec, checks_root, state)))\n                    else:\n                        not_passed.append(result.name)\n\n        for name in not_passed:\n            self._skip_children(name, results)\n\n        return results.values()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _skip_children(self, check_name, results):\n        for name, description in self.child_map[check_name]:\n            if results[name] is None:\n                results[name] = CheckResult(name=name, description=_(description),\n                                            passed=None,\n                                            dependency=check_name,\n                                            cause={\"rationale\": _(\"can't check until a frown turns upside down\")})\n                self._skip_children(name, results)", "response": "Recursively skip the children of check_name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef append_code(original, codefile):\n    with open(codefile) as code, open(original, \"a\") as o:\n        o.write(\"\\n\")\n        o.writelines(code)", "response": "Append the contents of one file to another."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nimporting a Python file given a raw file path.", "response": "def import_(path):\n    \"\"\"Import a Python program given a raw file path\n\n    :param path: path to python file to be imported\n    :type path: str\n    :raises check50.Failure: if ``path`` doesn't exist, or if the Python file at ``path`` throws an exception when imported.\n    \"\"\"\n    exists(path)\n    log(_(\"importing {}...\").format(path))\n    name = Path(path).stem\n    try:\n        return internal.import_file(name, path)\n    except Exception as e:\n        raise Failure(str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncompiles a Python program into byte code.", "response": "def compile(file):\n    \"\"\"\n    Compile a Python program into byte code\n\n    :param file: file to be compiled\n    :raises check50.Failure: if compilation fails e.g. if there is a SyntaxError\n    \"\"\"\n    log(_(\"compiling {} into byte code...\").format(file))\n\n    try:\n        py_compile.compile(file, doraise=True)\n    except py_compile.PyCompileError as e:\n        log(_(\"Exception raised: \"))\n        for line in e.msg.splitlines():\n            log(line)\n\n        raise Failure(_(\"{} raised while compiling {} (rerun with --log for more details)\").format(e.exc_type_name, file))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset check50. txt version", "response": "def _set_version():\n    \"\"\"Set check50 __version__\"\"\"\n    global __version__\n    from pkg_resources import get_distribution, DistributionNotFound\n    import os\n    # https://stackoverflow.com/questions/17583443/what-is-the-correct-way-to-share-package-version-with-setup-py-and-the-package\n    try:\n        dist = get_distribution(\"check50\")\n        # Normalize path for cross-OS compatibility.\n        dist_loc = os.path.normcase(dist.location)\n        here = os.path.normcase(__file__)\n        if not here.startswith(os.path.join(dist_loc, \"check50\")):\n            # This version is not installed, but another version is.\n            raise DistributionNotFound\n    except DistributionNotFound:\n        __version__ = \"locally installed, no version information available\"\n    else:\n        __version__ = dist.version"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends GET request to app.", "response": "def get(self, route, data=None, params=None, follow_redirects=True):\n        \"\"\"Send GET request to app.\n\n        :param route: route to send request to\n        :type route: str\n        :param data: form data to include in request\n        :type data: dict\n        :param params: URL parameters to include in request\n        :param follow_redirects: enable redirection (defaults to ``True``)\n        :type follow_redirects: bool\n        :returns: ``self``\n        :raises check50.Failure: if Flask application throws an uncaught exception\n\n        Example usage::\n\n            check50.flask.app(\"application.py\").get(\"/buy\", params={\"q\": \"02138\"}).content()\n        \"\"\"\n        return self._send(\"GET\", route, data, params, follow_redirects=follow_redirects)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef post(self, route, data=None, params=None, follow_redirects=True):\n\n        return self._send(\"POST\", route, data, params, follow_redirects=follow_redirects)", "response": "Send POST request to app.\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks status code in response returned by application.", "response": "def status(self, code=None):\n        \"\"\"Check status code in response returned by application.\n        If ``code`` is not None, assert that ``code`` is returned by application,\n        else simply return the status code.\n\n        :param code: ``code`` to assert that application returns\n        :type code: int\n\n        Example usage::\n\n            check50.flask.app(\"application.py\").status(200)\n\n            status = check50.flask.app(\"application.py\").get(\"/\").status()\n            if status != 200:\n                raise check50.Failure(f\"expected status code 200, but got {status}\")\n\n        \"\"\"\n        if code is None:\n            return self.response.status_code\n\n        log(_(\"checking that status code {} is returned...\").format(code))\n        if code != self.response.status_code:\n            raise Failure(_(\"expected status code {}, but got {}\").format(\n                code, self.response.status_code))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch for output regex match within content of page regardless of mimetype.", "response": "def raw_content(self, output=None, str_output=None):\n        \"\"\"Searches for `output` regex match within content of page, regardless of mimetype.\"\"\"\n        return self._search_page(output, str_output, self.response.data, lambda regex, content: regex.search(content.decode()))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef content(self, output=None, str_output=None, **kwargs):\n        if self.response.mimetype != \"text/html\":\n            raise Failure(_(\"expected request to return HTML, but it returned {}\").format(\n                self.response.mimetype))\n\n        # TODO: Remove once beautiful soup updates to accomodate python 3.7\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n            content = BeautifulSoup(self.response.data, \"html.parser\")\n\n        return self._search_page(\n            output,\n            str_output,\n            content,\n            lambda regex, content: any(regex.search(str(tag)) for tag in content.find_all(**kwargs)))", "response": "Searches for output regex within HTML page. kwargs are passed to BeautifulSoup s find function to filter for tags."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _send(self, method, route, data, params, **kwargs):\n        route = self._fmt_route(route, params)\n        log(_(\"sending {} request to {}\").format(method.upper(), route))\n        try:\n            self.response = getattr(self._client, method.lower())(route, data=data, **kwargs)\n        except BaseException as e:  # Catch all exceptions thrown by app\n            log(_(\"exception raised in application: {}: {}\").format(type(e).__name__, e))\n            raise Failure(_(\"application raised an exception (rerun with --log for more details)\"))\n        return self", "response": "Send a request to the application."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns compiled check50 checks from simple YAML checks in path.", "response": "def compile(checks):\n    \"\"\"Returns compiled check50 checks from simple YAML checks in path.\"\"\"\n\n    out = [\"import check50\"]\n\n    for name, check in checks.items():\n        out.append(_compile_check(name, check))\n\n    return \"\\n\\n\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates an index of days at time t interpreted in timezone tz.", "response": "def days_at_time(days, t, tz, day_offset=0):\n    \"\"\"\n    Create an index of days at time ``t``, interpreted in timezone ``tz``.\n\n    The returned index is localized to UTC.\n\n    Parameters\n    ----------\n    days : DatetimeIndex\n        An index of dates (represented as midnight).\n    t : datetime.time\n        The time to apply as an offset to each day in ``days``.\n    tz : pytz.timezone\n        The timezone to use to interpret ``t``.\n    day_offset : int\n        The number of days we want to offset @days by\n\n    Examples\n    --------\n    In the example below, the times switch from 13:45 to 12:45 UTC because\n    March 13th is the daylight savings transition for US/Eastern.  All the\n    times are still 8:45 when interpreted in US/Eastern.\n\n    >>> import pandas as pd; import datetime; import pprint\n    >>> dts = pd.date_range('2016-03-12', '2016-03-14')\n    >>> dts_at_845 = days_at_time(dts, datetime.time(8, 45), 'US/Eastern')\n    >>> pprint.pprint([str(dt) for dt in dts_at_845])\n    ['2016-03-12 13:45:00+00:00',\n     '2016-03-13 12:45:00+00:00',\n     '2016-03-14 12:45:00+00:00']\n    \"\"\"\n    days = pd.DatetimeIndex(days).tz_localize(None)\n    if len(days) == 0:\n        return days.tz_localize(UTC)\n\n    # Offset days without tz to avoid timezone issues.\n    delta = pd.Timedelta(\n        days=day_offset,\n        hours=t.hour,\n        minutes=t.minute,\n        seconds=t.second,\n    )\n    return (days + delta).tz_localize(tz).tz_convert(UTC)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef vectorized_sunday_to_monday(dtix):\n    values = dtix.values.copy()\n    values[dtix.weekday == 6] += np.timedelta64(1, 'D')\n    return pd.DatetimeIndex(values)", "response": "A vectorized implementation of pandas. tseries. holiday. sunday_to_monday."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef weekend_boxing_day(start_date=None, end_date=None, observance=None):\n    return Holiday(\n        \"Weekend Boxing Day\",\n        month=12,\n        day=28,\n        days_of_week=(MONDAY, TUESDAY),\n        start_date=start_date,\n        end_date=end_date,\n        observance=observance,\n    )", "response": "returns a new Holiday object for the weekend boxing day"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a list of holidays return whether dt is a holiday or it is on a weekend.", "response": "def is_holiday_or_weekend(holidays, dt):\n    \"\"\"\n    Given a list of holidays, return whether dt is a holiday\n    or it is on a weekend.\n    \"\"\"\n    one_day = timedelta(days=1)\n\n    for h in holidays:\n        if dt in h.dates(dt - one_day, dt + one_day) or \\\n                dt.weekday() in WEEKENDS:\n            return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef next_non_holiday_weekday(holidays, dt):\n    day_of_week = dt.weekday()\n\n    if day_of_week == SUNDAY:\n        while is_holiday_or_weekend(holidays, dt):\n            dt += timedelta(1)\n\n    return dt", "response": "observe the next non - holiday weekday."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compute_all_minutes(opens_in_ns, closes_in_ns):\n    deltas = closes_in_ns - opens_in_ns\n\n    # + 1 because we want 390 mins per standard day, not 389\n    daily_sizes = (deltas // NANOSECONDS_PER_MINUTE) + 1\n    num_minutes = daily_sizes.sum()\n\n    # One allocation for the entire thing. This assumes that each day\n    # represents a contiguous block of minutes.\n    pieces = []\n\n    for open_, size in zip(opens_in_ns, daily_sizes):\n        pieces.append(\n            np.arange(open_,\n                      open_ + size * NANOSECONDS_PER_MINUTE,\n                      NANOSECONDS_PER_MINUTE)\n        )\n\n    out = np.concatenate(pieces).view('datetime64[ns]')\n    assert len(out) == num_minutes\n    return out", "response": "Given arrays of opens and closes returns an array of each minute between the opens and closes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an instance of a TradingCalendar whose name is given.", "response": "def get_calendar(self, name):\n        \"\"\"\n        Retrieves an instance of an TradingCalendar whose name is given.\n\n        Parameters\n        ----------\n        name : str\n            The name of the TradingCalendar to be retrieved.\n\n        Returns\n        -------\n        calendar : calendars.TradingCalendar\n            The desired calendar.\n        \"\"\"\n        canonical_name = self.resolve_alias(name)\n\n        try:\n            return self._calendars[canonical_name]\n        except KeyError:\n            # We haven't loaded this calendar yet, so make a new one.\n            pass\n\n        try:\n            factory = self._calendar_factories[canonical_name]\n        except KeyError:\n            # We don't have a factory registered for this name.  Barf.\n            raise InvalidCalendarName(calendar_name=name)\n\n        # Cache the calendar for future use.\n        calendar = self._calendars[canonical_name] = factory()\n        return calendar"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if we have a calendar with the given name.", "response": "def has_calendar(self, name):\n        \"\"\"\n        Do we have (or have the ability to make) a calendar with ``name``?\n        \"\"\"\n        return (\n            name in self._calendars\n            or name in self._calendar_factories\n            or name in self._aliases\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregister a calendar for retrieval by the get_calendar method.", "response": "def register_calendar(self, name, calendar, force=False):\n        \"\"\"\n        Registers a calendar for retrieval by the get_calendar method.\n\n        Parameters\n        ----------\n        name: str\n            The key with which to register this calendar.\n        calendar: TradingCalendar\n            The calendar to be registered for retrieval.\n        force : bool, optional\n            If True, old calendars will be overwritten on a name collision.\n            If False, name collisions will raise an exception.\n            Default is False.\n\n        Raises\n        ------\n        CalendarNameCollision\n            If a calendar is already registered with the given calendar's name.\n        \"\"\"\n        if force:\n            self.deregister_calendar(name)\n\n        if self.has_calendar(name):\n            raise CalendarNameCollision(calendar_name=name)\n\n        self._calendars[name] = calendar"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nregister a calendar by type.", "response": "def register_calendar_type(self, name, calendar_type, force=False):\n        \"\"\"\n        Registers a calendar by type.\n\n        This is useful for registering a new calendar to be lazily instantiated\n        at some future point in time.\n\n        Parameters\n        ----------\n        name: str\n            The key with which to register this calendar.\n        calendar_type: type\n            The type of the calendar to register.\n        force : bool, optional\n            If True, old calendars will be overwritten on a name collision.\n            If False, name collisions will raise an exception.\n            Default is False.\n\n        Raises\n        ------\n        CalendarNameCollision\n            If a calendar is already registered with the given calendar's name.\n        \"\"\"\n        if force:\n            self.deregister_calendar(name)\n\n        if self.has_calendar(name):\n            raise CalendarNameCollision(calendar_name=name)\n\n        self._calendar_factories[name] = calendar_type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_calendar_alias(self, alias, real_name, force=False):\n        if force:\n            self.deregister_calendar(alias)\n\n        if self.has_calendar(alias):\n            raise CalendarNameCollision(calendar_name=alias)\n\n        self._aliases[alias] = real_name\n\n        # Ensure that the new alias doesn't create a cycle, and back it out if\n        # we did.\n        try:\n            self.resolve_alias(alias)\n        except CyclicCalendarAlias:\n            del self._aliases[alias]\n            raise", "response": "Register an alias for a calendar."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nresolves a calendar alias for retrieval.", "response": "def resolve_alias(self, name):\n        \"\"\"\n        Resolve a calendar alias for retrieval.\n\n        Parameters\n        ----------\n        name : str\n            The name of the requested calendar.\n\n        Returns\n        -------\n        canonical_name : str\n            The real name of the calendar to create/return.\n        \"\"\"\n        seen = []\n\n        while name in self._aliases:\n            seen.append(name)\n            name = self._aliases[name]\n\n            # This is O(N ** 2), but if there's an alias chain longer than 2,\n            # something strange has happened.\n            if name in seen:\n                seen.append(name)\n                raise CyclicCalendarAlias(\n                    cycle=\" -> \".join(repr(k) for k in seen)\n                )\n\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deregister_calendar(self, name):\n        self._calendars.pop(name, None)\n        self._calendar_factories.pop(name, None)\n        self._aliases.pop(name, None)", "response": "Deregisters a calendar with the given name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear_calendars(self):\n        self._calendars.clear()\n        self._calendar_factories.clear()\n        self._aliases.clear()", "response": "Clears all registered calendars"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a Series mapping each holiday in calendar between start and end to that session at time.", "response": "def scheduled_special_times(calendar, start, end, time, tz):\n    \"\"\"\n    Returns a Series mapping each holiday (as a UTC midnight Timestamp)\n    in ``calendar`` between ``start`` and ``end`` to that session at\n    ``time`` (as a UTC Timestamp).\n    \"\"\"\n    days = calendar.holidays(start, end)\n    return pd.Series(\n        index=pd.DatetimeIndex(days, tz=UTC),\n        data=days_at_time(days, time, tz=tz),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _overwrite_special_dates(midnight_utcs,\n                             opens_or_closes,\n                             special_opens_or_closes):\n    \"\"\"\n    Overwrite dates in open_or_closes with corresponding dates in\n    special_opens_or_closes, using midnight_utcs for alignment.\n    \"\"\"\n    # Short circuit when nothing to apply.\n    if not len(special_opens_or_closes):\n        return\n\n    len_m, len_oc = len(midnight_utcs), len(opens_or_closes)\n    if len_m != len_oc:\n        raise ValueError(\n            \"Found misaligned dates while building calendar.\\n\"\n            \"Expected midnight_utcs to be the same length as open_or_closes,\\n\"\n            \"but len(midnight_utcs)=%d, len(open_or_closes)=%d\" % len_m, len_oc\n        )\n\n    # Find the array indices corresponding to each special date.\n    indexer = midnight_utcs.get_indexer(special_opens_or_closes.index)\n\n    # -1 indicates that no corresponding entry was found.  If any -1s are\n    # present, then we have special dates that doesn't correspond to any\n    # trading day.\n    if -1 in indexer:\n        bad_dates = list(special_opens_or_closes[indexer == -1])\n        raise ValueError(\"Special dates %s are not trading days.\" % bad_dates)\n\n    # NOTE: This is a slightly dirty hack.  We're in-place overwriting the\n    # internal data of an Index, which is conceptually immutable.  Since we're\n    # maintaining sorting, this should be ok, but this is a good place to\n    # sanity check if things start going haywire with calendar computations.\n    opens_or_closes.values[indexer] = special_opens_or_closes.values", "response": "Overwrite dates in open_or_closes with corresponding dates in special_opens_or_closes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the number of minutes for the contiguous chunk of sessions between start_session and end_session inclusive.", "response": "def minutes_count_for_sessions_in_range(self, start_session, end_session):\n        \"\"\"\n        Parameters\n        ----------\n        start_session: pd.Timestamp\n            The first session.\n\n        end_session: pd.Timestamp\n            The last session.\n\n        Returns\n        -------\n        int: The total number of minutes for the contiguous chunk of sessions.\n             between start_session and end_session, inclusive.\n        \"\"\"\n        return int(self._minutes_per_session[start_session:end_session].sum())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_open_on_minute(self, dt):\n        return is_open(self.market_opens_nanos, self.market_closes_nanos,\n                       dt.value)", "response": "Returns True if this exchange is open at the given dt."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef next_open(self, dt):\n        idx = next_divider_idx(self.market_opens_nanos, dt.value)\n        return pd.Timestamp(self.market_opens_nanos[idx], tz=UTC)", "response": "Given a dt returns the next open."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a dt returns the next close.", "response": "def next_close(self, dt):\n        \"\"\"\n        Given a dt, returns the next close.\n\n        Parameters\n        ----------\n        dt: pd.Timestamp\n            The dt for which to get the next close.\n\n        Returns\n        -------\n        pd.Timestamp\n            The UTC timestamp of the next close.\n        \"\"\"\n        idx = next_divider_idx(self.market_closes_nanos, dt.value)\n        return pd.Timestamp(self.market_closes_nanos[idx], tz=UTC)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a dt returns the previous open.", "response": "def previous_open(self, dt):\n        \"\"\"\n        Given a dt, returns the previous open.\n\n        Parameters\n        ----------\n        dt: pd.Timestamp\n            The dt for which to get the previous open.\n\n        Returns\n        -------\n        pd.Timestamp\n            The UTC imestamp of the previous open.\n        \"\"\"\n        idx = previous_divider_idx(self.market_opens_nanos, dt.value)\n        return pd.Timestamp(self.market_opens_nanos[idx], tz=UTC)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the previous close.", "response": "def previous_close(self, dt):\n        \"\"\"\n        Given a dt, returns the previous close.\n\n        Parameters\n        ----------\n        dt: pd.Timestamp\n            The dt for which to get the previous close.\n\n        Returns\n        -------\n        pd.Timestamp\n            The UTC timestamp of the previous close.\n        \"\"\"\n        idx = previous_divider_idx(self.market_closes_nanos, dt.value)\n        return pd.Timestamp(self.market_closes_nanos[idx], tz=UTC)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef next_minute(self, dt):\n        idx = next_divider_idx(self._trading_minutes_nanos, dt.value)\n        return self.all_minutes[idx]", "response": "Returns the next exchange minute."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef previous_minute(self, dt):\n\n        idx = previous_divider_idx(self._trading_minutes_nanos, dt.value)\n        return self.all_minutes[idx]", "response": "Returns the previous exchange minute for a given dt."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the label of the next session in the calendar.", "response": "def next_session_label(self, session_label):\n        \"\"\"\n        Given a session label, returns the label of the next session.\n\n        Parameters\n        ----------\n        session_label: pd.Timestamp\n            A session whose next session is desired.\n\n        Returns\n        -------\n        pd.Timestamp\n            The next session label (midnight UTC).\n\n        Notes\n        -----\n        Raises ValueError if the given session is the last session in this\n        calendar.\n        \"\"\"\n        idx = self.schedule.index.get_loc(session_label)\n        try:\n            return self.schedule.index[idx + 1]\n        except IndexError:\n            if idx == len(self.schedule.index) - 1:\n                raise ValueError(\"There is no next session as this is the end\"\n                                 \" of the exchange calendar.\")\n            else:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef previous_session_label(self, session_label):\n        idx = self.schedule.index.get_loc(session_label)\n        if idx == 0:\n            raise ValueError(\"There is no previous session as this is the\"\n                             \" beginning of the exchange calendar.\")\n\n        return self.schedule.index[idx - 1]", "response": "Returns the label of the previous session in the calendar."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the minutes for that session.", "response": "def minutes_for_session(self, session_label):\n        \"\"\"\n        Given a session label, return the minutes for that session.\n\n        Parameters\n        ----------\n        session_label: pd.Timestamp (midnight UTC)\n            A session label whose session's minutes are desired.\n\n        Returns\n        -------\n        pd.DateTimeIndex\n            All the minutes for the given session.\n        \"\"\"\n        return self.minutes_in_range(\n            start_minute=self.schedule.at[session_label, 'market_open'],\n            end_minute=self.schedule.at[session_label, 'market_close'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the execution minutes for a given session label.", "response": "def execution_minutes_for_session(self, session_label):\n        \"\"\"\n        Given a session label, return the execution minutes for that session.\n\n        Parameters\n        ----------\n        session_label: pd.Timestamp (midnight UTC)\n            A session label whose session's minutes are desired.\n\n        Returns\n        -------\n        pd.DateTimeIndex\n            All the execution minutes for the given session.\n        \"\"\"\n        return self.minutes_in_range(\n            start_minute=self.execution_time_from_open(\n                self.schedule.at[session_label, 'market_open'],\n            ),\n            end_minute=self.execution_time_from_close(\n                self.schedule.at[session_label, 'market_close'],\n            ),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn all the sessions in that range inclusive.", "response": "def sessions_in_range(self, start_session_label, end_session_label):\n        \"\"\"\n        Given start and end session labels, return all the sessions in that\n        range, inclusive.\n\n        Parameters\n        ----------\n        start_session_label: pd.Timestamp (midnight UTC)\n            The label representing the first session of the desired range.\n\n        end_session_label: pd.Timestamp (midnight UTC)\n            The label representing the last session of the desired range.\n\n        Returns\n        -------\n        pd.DatetimeIndex\n            The desired sessions.\n        \"\"\"\n        return self.all_sessions[\n            self.all_sessions.slice_indexer(\n                start_session_label,\n                end_session_label\n            )\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sessions_window(self, session_label, count):\n        start_idx = self.schedule.index.get_loc(session_label)\n        end_idx = start_idx + count\n\n        return self.all_sessions[\n            min(start_idx, end_idx):max(start_idx, end_idx) + 1\n        ]", "response": "Returns a list of all sessions in a given window size."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a start and end session label, returns the distance between them. For example, for three consecutive sessions Mon., Tues., and Wed, ``session_distance(Mon, Wed)`` returns 3. If ``start_session`` is after ``end_session``, the value will be negated. Parameters ---------- start_session_label: pd.Timestamp The label of the start session. end_session_label: pd.Timestamp The label of the ending session inclusive. Returns ------- int The distance between the two sessions.", "response": "def session_distance(self, start_session_label, end_session_label):\n        \"\"\"\n        Given a start and end session label, returns the distance between them.\n        For example, for three consecutive sessions Mon., Tues., and Wed,\n        ``session_distance(Mon, Wed)`` returns 3. If ``start_session`` is after\n        ``end_session``, the value will be negated.\n\n        Parameters\n        ----------\n        start_session_label: pd.Timestamp\n            The label of the start session.\n        end_session_label: pd.Timestamp\n            The label of the ending session inclusive.\n\n        Returns\n        -------\n        int\n            The distance between the two sessions.\n        \"\"\"\n        negate = end_session_label < start_session_label\n        if negate:\n            start_session_label, end_session_label = (\n                end_session_label,\n                start_session_label,\n            )\n        start_idx = self.all_sessions.searchsorted(start_session_label)\n        end_idx = self.all_sessions.searchsorted(\n            end_session_label,\n            side='right',\n        )\n\n        out = end_idx - start_idx\n        if negate:\n            out = -out\n\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef minutes_in_range(self, start_minute, end_minute):\n        start_idx = searchsorted(self._trading_minutes_nanos,\n                                 start_minute.value)\n\n        end_idx = searchsorted(self._trading_minutes_nanos,\n                               end_minute.value)\n\n        if end_minute.value == self._trading_minutes_nanos[end_idx]:\n            # if the end minute is a market minute, increase by 1\n            end_idx += 1\n\n        return self.all_minutes[start_idx:end_idx]", "response": "Given start and end minutes return all the calendar minutes in that range inclusive."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef minutes_for_sessions_in_range(self,\n                                      start_session_label,\n                                      end_session_label):\n        \"\"\"\n        Returns all the minutes for all the sessions from the given start\n        session label to the given end session label, inclusive.\n\n        Parameters\n        ----------\n        start_session_label: pd.Timestamp\n            The label of the first session in the range.\n\n        end_session_label: pd.Timestamp\n            The label of the last session in the range.\n\n        Returns\n        -------\n        pd.DatetimeIndex\n            The minutes in the desired range.\n\n        \"\"\"\n        first_minute, _ = self.open_and_close_for_session(start_session_label)\n        _, last_minute = self.open_and_close_for_session(end_session_label)\n\n        return self.minutes_in_range(first_minute, last_minute)", "response": "Returns all the minutes for all the sessions in the given range."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef open_and_close_for_session(self, session_label):\n        sched = self.schedule\n\n        # `market_open` and `market_close` should be timezone aware, but pandas\n        # 0.16.1 does not appear to support this:\n        # http://pandas.pydata.org/pandas-docs/stable/whatsnew.html#datetime-with-tz  # noqa\n        return (\n            sched.at[session_label, 'market_open'].tz_localize(UTC),\n            sched.at[session_label, 'market_close'].tz_localize(UTC),\n        )", "response": "Returns a tuple of timestamps of the open and close of the given session."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a DatetimeIndex representing all the minutes in this calendar.", "response": "def all_minutes(self):\n        \"\"\"\n        Returns a DatetimeIndex representing all the minutes in this calendar.\n        \"\"\"\n        opens_in_ns = self._opens.values.astype(\n            'datetime64[ns]',\n        ).view('int64')\n\n        closes_in_ns = self._closes.values.astype(\n            'datetime64[ns]',\n        ).view('int64')\n\n        return DatetimeIndex(\n            compute_all_minutes(opens_in_ns, closes_in_ns),\n            tz=UTC,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a minute return the label of the containing session.", "response": "def minute_to_session_label(self, dt, direction=\"next\"):\n        \"\"\"\n        Given a minute, get the label of its containing session.\n\n        Parameters\n        ----------\n        dt : pd.Timestamp or nanosecond offset\n            The dt for which to get the containing session.\n\n        direction: str\n            \"next\" (default) means that if the given dt is not part of a\n            session, return the label of the next session.\n\n            \"previous\" means that if the given dt is not part of a session,\n            return the label of the previous session.\n\n            \"none\" means that a KeyError will be raised if the given\n            dt is not part of a session.\n\n        Returns\n        -------\n        pd.Timestamp (midnight UTC)\n            The label of the containing session.\n        \"\"\"\n        if direction == \"next\":\n            try:\n                return self._minute_to_session_label_cache[dt]\n            except KeyError:\n                pass\n\n        idx = searchsorted(self.market_closes_nanos, dt)\n        current_or_next_session = self.schedule.index[idx]\n        self._minute_to_session_label_cache[dt] = current_or_next_session\n\n        if direction == \"next\":\n            return current_or_next_session\n        elif direction == \"previous\":\n            if not is_open(self.market_opens_nanos, self.market_closes_nanos,\n                           dt):\n                # if the exchange is closed, use the previous session\n                return self.schedule.index[idx - 1]\n        elif direction == \"none\":\n            if not is_open(self.market_opens_nanos, self.market_closes_nanos,\n                           dt):\n                # if the exchange is closed, blow up\n                raise ValueError(\"The given dt is not an exchange minute!\")\n        else:\n            # invalid direction\n            raise ValueError(\"Invalid direction parameter: \"\n                             \"{0}\".format(direction))\n\n        return current_or_next_session"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a sorted DatetimeIndex of market minutes return a pd. DatetimeIndex of the corresponding session labels.", "response": "def minute_index_to_session_labels(self, index):\n        \"\"\"\n        Given a sorted DatetimeIndex of market minutes, return a\n        DatetimeIndex of the corresponding session labels.\n\n        Parameters\n        ----------\n        index: pd.DatetimeIndex or pd.Series\n            The ordered list of market minutes we want session labels for.\n\n        Returns\n        -------\n        pd.DatetimeIndex (UTC)\n            The list of session labels corresponding to the given minutes.\n        \"\"\"\n        if not index.is_monotonic_increasing:\n            raise ValueError(\n                \"Non-ordered index passed to minute_index_to_session_labels.\"\n            )\n\n        # Find the indices of the previous open and the next close for each\n        # minute.\n        prev_opens = (\n            self._opens.values.searchsorted(index.values, side='right') - 1\n        )\n        next_closes = (\n            self._closes.values.searchsorted(index.values, side='left')\n        )\n\n        # If they don't match, the minute is outside the trading day. Barf.\n        mismatches = (prev_opens != next_closes)\n        if mismatches.any():\n            # Show the first bad minute in the error message.\n            bad_ix = np.flatnonzero(mismatches)[0]\n            example = index[bad_ix]\n\n            prev_day = prev_opens[bad_ix]\n            prev_open, prev_close = self.schedule.iloc[prev_day]\n            next_open, next_close = self.schedule.iloc[prev_day + 1]\n\n            raise ValueError(\n                \"{num} non-market minutes in minute_index_to_session_labels:\\n\"\n                \"First Bad Minute: {first_bad}\\n\"\n                \"Previous Session: {prev_open} -> {prev_close}\\n\"\n                \"Next Session: {next_open} -> {next_close}\"\n                .format(\n                    num=mismatches.sum(),\n                    first_bad=example,\n                    prev_open=prev_open, prev_close=prev_close,\n                    next_open=next_open, next_close=next_close)\n            )\n\n        return self.schedule.index[prev_opens]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _special_dates(self, calendars, ad_hoc_dates, start_date, end_date):\n        # List of Series for regularly-scheduled times.\n        regular = [\n            scheduled_special_times(\n                calendar,\n                start_date,\n                end_date,\n                time_,\n                self.tz,\n            )\n            for time_, calendar in calendars\n        ]\n\n        # List of Series for ad-hoc times.\n        ad_hoc = [\n            pd.Series(\n                index=pd.to_datetime(datetimes, utc=True),\n                data=days_at_time(datetimes, time_, self.tz),\n            )\n            for time_, datetimes in ad_hoc_dates\n        ]\n\n        merged = regular + ad_hoc\n        if not merged:\n            # Concat barfs if the input has length 0.\n            return pd.Series([])\n\n        result = pd.concat(merged).sort_index()\n        return result.loc[(result >= start_date) & (result <= end_date)]", "response": "Compute a Series of times associated with special dates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading a text file.", "response": "def read(*paths):\n    \"\"\"Read a text file.\"\"\"\n    basedir = os.path.dirname(__file__)\n    fullpath = os.path.join(basedir, *paths)\n    contents = io.open(fullpath, encoding='utf-8').read().strip()\n    return contents"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes a new data processing pipeline.", "response": "def init(arg):\n    \"\"\"Bootstrap a processing pipeline script.\nARG is either a path or a URL for some data to read from, 'hello-world' for a full working code example,\nor leave empty for an interactive walkthrough.\n    \"\"\"\n\n    answers = {'a': 1}\n    if arg == 'interactive':\n        input(\"\"\"Hi There!\n    DataFlows will now bootstrap a data processing flow based on your needs.\n\n    Press any key to start...\n    \"\"\")\n\n    elif arg == 'hello-world':\n        raise NotImplementedError()\n    else:\n        url = arg\n        answers = dict(\n            input='remote',\n            title=os.path.basename(url),\n            input_url=url,\n            processing=[],\n            output='print_n_pkg'\n        )\n        extract_format(answers, url)\n\n    questions = [\n        # Input\n        inquirer.List('input_str',\n                    message='What is the source of your data?',\n                    choices=INPUTS.keys(),\n                    ignore=lambda ctx: ctx.get('input') is not None,\n                    validate=convert_input),\n\n        # Input Parameters\n        inquirer.Text('input_url',\n                    message=\"What is the path of that file\",\n                    ignore=fany(lambda ctx: ctx.get('input') != 'file',\n                                lambda ctx: ctx.get('input_url') is not None),\n                    validate=fall(not_empty, extract_format)),\n        inquirer.List('format',\n                    message=\"We couldn't detect the file format - which is it?\",\n                    choices=FORMATS[:-1],\n                    ignore=fany(lambda ctx: ctx.get('input') != 'file',\n                                lambda ctx: ctx.get('format') in FORMATS)),\n\n        inquirer.Text('input_url',\n                    message=\"Where is that file located (URL)\",\n                    ignore=fany(lambda ctx: ctx.get('input') != 'remote',\n                                lambda ctx: ctx.get('input_url') is not None),\n                    validate=fall(extract_format, not_empty, valid_url)),\n        inquirer.List('format',\n                      message=\"We couldn't detect the source format - which is it\",\n                      choices=FORMATS,\n                      ignore=fany(lambda ctx: ctx['input'] != 'remote',\n                                  lambda ctx: ctx.get('format') in FORMATS)\n                      ),\n        inquirer.Text('sheet',\n                      message=\"Which sheet in the spreadsheet should be processed (name or index)\",\n                      validate=not_empty,\n                      ignore=lambda ctx: ctx.get('format') not in ('xls', 'xlsx', 'ods'),\n                      ),\n        inquirer.Text('input_url',\n                      message=\"What is the connection string to the database\",\n                      validate=not_empty,\n                      ignore=fany(lambda ctx: ctx['input'] != 'sql',\n                                  lambda ctx: ctx.get('input_url') is not None),\n                      ),\n        inquirer.Text('input_db_table',\n                      message=\"...and the name of the database table to extract\",\n                      validate=not_empty,\n                      ignore=fany(lambda ctx: ctx['input'] != 'sql',\n                                  lambda ctx: ctx.get('input_db_table') is not None),\n                      ),\n\n        inquirer.Text('input_url',\n                      message=\"Describe that other source (shortly)\",\n                      ignore=fany(lambda ctx: ctx['input'] != 'other',\n                                  lambda ctx: ctx.get('input_url') is not None),\n                      ),\n\n        # Processing\n        inquirer.Checkbox('processing_str',\n                        message=\"What kind of processing would you like to run on the data\",\n                        choices=PROCESSING.keys(),\n                        ignore=lambda ctx: ctx.get('processing') is not None,\n                        validate=convert_processing),\n\n        # Output\n        inquirer.List('output_str',\n                    message=\"Finally, where would you like the output data\",\n                    choices=OUTPUTS.keys(),\n                    ignore=lambda ctx: ctx.get('output') is not None,\n                    validate=convert_output),\n        inquirer.Text('output_url',\n                      message=\"What is the connection string to the database\",\n                      validate=not_empty,\n                      ignore=fany(lambda ctx: ctx['output'] != 'sql',\n                                  lambda ctx: ctx.get('output_url') is not None),\n                      ),\n        inquirer.Text('output_db_table',\n                      message=\"...and the name of the database table to write to\",\n                      validate=not_empty,\n                      ignore=fany(lambda ctx: ctx['output'] != 'sql',\n                                  lambda ctx: ctx.get('output_db_table') is not None),\n                      ),\n\n        # # Finalize\n        inquirer.Text('title',\n                    message=\"That's it! Now, just provide a title for your processing flow\",\n                    ignore=lambda ctx: ctx.get('title') is not None,\n                    validate=not_empty),\n    ]\n    answers = inquirer.prompt(questions, answers=answers, theme=themes.GreenPassion())\n    if answers is None:\n        return\n    answers['slug'] = slugify.slugify(answers['title'], separator='_')\n\n    filename = '{slug}.py'.format(**answers)\n    with open(filename, 'w') as out:\n        print('Writing processing code into {}'.format(filename))\n        out.write(render(answers))\n\n    try:\n        print('Running {}'.format(filename))\n        ret = subprocess.check_output('python '+filename,\n                                      stderr=subprocess.PIPE, universal_newlines=True, shell=True)\n        print(ret)\n        print('Done!')\n    except subprocess.CalledProcessError as e:\n        print(\"Processing failed, here's the error:\")\n        print(e.stderr)\n        answers = inquirer.prompt([\n            inquirer.Confirm('edit',\n                            message='Would you like to open {} in the default editor?'.format(filename),\n                            default=False)\n        ])\n        if answers['edit']:\n            click.edit(filename=filename)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(self, raw):\n        results = list(self.parse_partial(raw))\n        results.extend(self.parse_finalize())\n        return results[0] if len(results) == 1 else results", "response": "Parses the bytes of this encoding into a Python object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nraising errors for incomplete buffered data that could not be parsed", "response": "def parse_finalize(self):\n        \"\"\"Raises errors for incomplete buffered data that could not be parsed\n        because the end of the input data has been reached.\n\n        Raises\n        ------\n        ~ipfsapi.exceptions.DecodingError\n\n        Returns\n        -------\n            tuple : Always empty\n        \"\"\"\n        try:\n            try:\n                # Raise exception for remaining bytes in bytes decoder\n                self._decoder1.decode(b'', True)\n            except UnicodeDecodeError as error:\n                raise exceptions.DecodingError('json', error)\n\n            # Late raise errors that looked like they could have been fixed if\n            # the caller had provided more data\n            if self._buffer:\n                raise exceptions.DecodingError('json', self._lasterror)\n        finally:\n            # Reset state\n            self._buffer    = []\n            self._lasterror = None\n            self._decoder1.reset()\n\n        return ()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef encode(self, obj):\n        try:\n            result = json.dumps(obj, sort_keys=True, indent=None,\n                                separators=(',', ':'), ensure_ascii=False)\n            if isinstance(result, six.text_type):\n                return result.encode(\"utf-8\")\n            else:\n                return result\n        except (UnicodeEncodeError, TypeError) as error:\n            raise exceptions.EncodingError('json', error)", "response": "Encodes obj as JSON formatted bytes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_finalize(self):\n        try:\n            self._buffer.seek(0, 0)\n            yield pickle.load(self._buffer)\n        except pickle.UnpicklingError as error:\n            raise exceptions.DecodingError('pickle', error)", "response": "Parses the buffered data and yields the result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nencode the object as a pickle binary string.", "response": "def encode(self, obj):\n        \"\"\"Returns ``obj`` serialized as a pickle binary string.\n\n        Raises\n        ------\n        ~ipfsapi.exceptions.EncodingError\n\n        Parameters\n        ----------\n        obj : object\n            Serializable Python object\n\n        Returns\n        -------\n            bytes\n        \"\"\"\n        try:\n            return pickle.dumps(obj)\n        except pickle.PicklingError as error:\n            raise exceptions.EncodingError('pickle', error)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef glob_compile(pat):\n\n    i, n = 0, len(pat)\n    res = ''\n    while i < n:\n        c = pat[i]\n        i = i + 1\n        if c == '/' and len(pat) > (i + 2) and pat[i:(i + 3)] == '**/':\n            # Special-case for \"any number of sub-directories\" operator since\n            # may also expand to no entries:\n            #  Otherwise `a/**/b` would expand to `a[/].*[/]b` which wouldn't\n            #  match the immediate sub-directories of `a`, like `a/b`.\n            i = i + 3\n            res = res + '[/]([^/]*[/])*'\n        elif c == '*':\n            if len(pat) > i and pat[i] == '*':\n                i = i + 1\n                res = res + '.*'\n            else:\n                res = res + '[^/]*'\n        elif c == '?':\n            res = res + '[^/]'\n        elif c == '[':\n            j = i\n            if j < n and pat[j] == '!':\n                j = j + 1\n            if j < n and pat[j] == ']':\n                j = j + 1\n            while j < n and pat[j] != ']':\n                j = j + 1\n            if j >= n:\n                res = res + '\\\\['\n            else:\n                stuff = pat[i:j].replace('\\\\', '\\\\\\\\')\n                i = j + 1\n                if stuff[0] == '!':\n                    stuff = '^' + stuff[1:]\n                elif stuff[0] == '^':\n                    stuff = '\\\\' + stuff\n                res = '%s[%s]' % (res, stuff)\n        else:\n            res = res + re.escape(c)\n    return re.compile('^' + res + '\\Z(?ms)' + '$')", "response": "Translate a shell glob PATTERN to a regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stream_files(files, chunk_size=default_chunk_size):\n    stream = FileStream(files, chunk_size=chunk_size)\n\n    return stream.body(), stream.headers", "response": "Returns a buffered generator which encodes a file or list of files as a multipart form - data with the corresponding headers."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stream_directory(directory,\n                     recursive=False,\n                     patterns='**',\n                     chunk_size=default_chunk_size):\n    \"\"\"Gets a buffered generator for streaming directories.\n\n    Returns a buffered generator which encodes a directory as\n    :mimetype:`multipart/form-data` with the corresponding headers.\n\n    Parameters\n    ----------\n    directory : str\n        The filepath of the directory to stream\n    recursive : bool\n        Stream all content within the directory recursively?\n    patterns : str | list\n        Single *glob* pattern or list of *glob* patterns and compiled\n        regular expressions to match the names of the filepaths to keep\n    chunk_size : int\n        Maximum size of each stream chunk\n    \"\"\"\n    stream = DirectoryStream(directory,\n                             recursive=recursive,\n                             patterns=patterns,\n                             chunk_size=chunk_size)\n\n    return stream.body(), stream.headers", "response": "Returns a buffered generator which encodes a directory as multipart form - data with the corresponding headers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a buffered generator which encodes either files or directories at the given path as multipart - form - data.", "response": "def stream_filesystem_node(path,\n                           recursive=False,\n                           patterns='**',\n                           chunk_size=default_chunk_size):\n    \"\"\"Gets a buffered generator for streaming either files or directories.\n\n    Returns a buffered generator which encodes the file or directory at the\n    given path as :mimetype:`multipart/form-data` with the corresponding\n    headers.\n\n    Parameters\n    ----------\n    path : str\n        The filepath of the directory or file to stream\n    recursive : bool\n        Stream all content within the directory recursively?\n    patterns : str | list\n        Single *glob* pattern or list of *glob* patterns and compiled\n        regular expressions to match the names of the filepaths to keep\n    chunk_size : int\n        Maximum size of each stream chunk\n    \"\"\"\n    is_dir = isinstance(path, six.string_types) and os.path.isdir(path)\n    if recursive or is_dir:\n        return stream_directory(path, recursive, patterns, chunk_size)\n    else:\n        return stream_files(path, chunk_size)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stream_bytes(data, chunk_size=default_chunk_size):\n    stream = BytesStream(data, chunk_size=chunk_size)\n\n    return stream.body(), stream.headers", "response": "Returns a buffered generator which encodes binary data as multipart form - data with the corresponding headers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a buffered generator which encodes a string as Insights.", "response": "def stream_text(text, chunk_size=default_chunk_size):\n    \"\"\"Gets a buffered generator for streaming text.\n\n    Returns a buffered generator which encodes a string as\n    :mimetype:`multipart/form-data` with the corresponding headers.\n\n    Parameters\n    ----------\n    text : str\n        The data bytes to stream\n    chunk_size : int\n        The maximum size of each stream chunk\n\n    Returns\n    -------\n        (generator, dict)\n    \"\"\"\n    if isgenerator(text):\n        def binary_stream():\n            for item in text:\n                if six.PY2 and isinstance(text, six.binary_type):\n                    #PY2: Allow binary strings under Python 2 since\n                    # Python 2 code is not expected to always get the\n                    # distinction between text and binary strings right.\n                    yield text\n                else:\n                    yield text.encode(\"utf-8\")\n        data = binary_stream()\n    elif six.PY2 and isinstance(text, six.binary_type):\n        #PY2: See above.\n        data = text\n    else:\n        data = text.encode(\"utf-8\")\n\n    return stream_bytes(data, chunk_size)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _write_headers(self, headers):\n        if headers:\n            for name in sorted(headers.keys()):\n                yield name.encode(\"ascii\")\n                yield b': '\n                yield headers[name].encode(\"ascii\")\n                yield CRLF\n        yield CRLF", "response": "Yields the HTTP header text for some content."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nyields the opening text of a file section in multipart HTTP.", "response": "def file_open(self, fn):\n        \"\"\"Yields the opening text of a file section in multipart HTTP.\n\n        Parameters\n        ----------\n        fn : str\n            Filename for the file being opened and added to the HTTP body\n        \"\"\"\n        yield b'--'\n        yield self.boundary.encode()\n        yield CRLF\n        headers = content_disposition(fn)\n        headers.update(content_type(fn))\n        for c in self._write_headers(headers):\n            yield c"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef file_chunks(self, fp):\n        fsize = utils.file_size(fp)\n        offset = 0\n        if hasattr(fp, 'readinto'):\n            while offset < fsize:\n                nb = fp.readinto(self._internal)\n                yield self.buf[:nb]\n                offset += nb\n        else:\n            while offset < fsize:\n                nb = min(self.chunk_size, fsize - offset)\n                yield fp.read(nb)\n                offset += nb", "response": "Yields the file chunks of a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a byte generator that yields a maximum of the chunk_size bytes.", "response": "def gen_chunks(self, gen):\n        \"\"\"Generates byte chunks of a given size.\n\n        Takes a bytes generator and yields chunks of a maximum of\n        ``chunk_size`` bytes.\n\n        Parameters\n        ----------\n        gen : generator\n            The bytes generator that produces the bytes\n        \"\"\"\n        for data in gen:\n            size = len(data)\n            if size < self.chunk_size:\n                yield data\n            else:\n                mv = buffer(data)\n                offset = 0\n                while offset < size:\n                    nb = min(self.chunk_size, size - offset)\n                    yield mv[offset:offset + nb]\n                    offset += nb"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef body(self):\n        for fp, need_close in self.files:\n            try:\n                name = os.path.basename(fp.name)\n            except AttributeError:\n                name = ''\n            for chunk in self.gen_chunks(self.envelope.file_open(name)):\n                yield chunk\n            for chunk in self.file_chunks(fp):\n                yield chunk\n            for chunk in self.gen_chunks(self.envelope.file_close()):\n                yield chunk\n            if need_close:\n                fp.close()\n        for chunk in self.close():\n            yield chunk", "response": "Yields the body of the buffered file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _prepare(self):\n        names = []\n\n        added_directories = set()\n\n        def add_directory(short_path):\n            # Do not continue if this directory has already been added\n            if short_path in added_directories:\n                return\n\n            # Scan for first super-directory that has already been added\n            dir_base  = short_path\n            dir_parts = []\n            while dir_base:\n                dir_base, dir_name = os.path.split(dir_base)\n                dir_parts.append(dir_name)\n                if dir_base in added_directories:\n                    break\n\n            # Add missing intermediate directory nodes in the right order\n            while dir_parts:\n                dir_base = os.path.join(dir_base, dir_parts.pop())\n\n                # Create an empty, fake file to represent the directory\n                mock_file = io.StringIO()\n                mock_file.write(u'')\n                # Add this directory to those that will be sent\n                names.append(('files',\n                             (dir_base.replace(os.sep, '/'), mock_file, 'application/x-directory')))\n                # Remember that this directory has already been sent\n                added_directories.add(dir_base)\n\n        def add_file(short_path, full_path):\n            try:\n                # Always add files in wildcard directories\n                names.append(('files', (short_name.replace(os.sep, '/'),\n                                        open(full_path, 'rb'),\n                                        'application/octet-stream')))\n            except OSError:\n                # File might have disappeared between `os.walk()` and `open()`\n                pass\n\n        def match_short_path(short_path):\n            # Remove initial path component so that all files are based in\n            # the target directory itself (not one level above)\n            if os.sep in short_path:\n                path = short_path.split(os.sep, 1)[1]\n            else:\n                return False\n\n            # Convert all path seperators to POSIX style\n            path = path.replace(os.sep, '/')\n\n            # Do the matching and the simplified path\n            for pattern in self.patterns:\n                if pattern.match(path):\n                    return True\n            return False\n\n        # Identify the unecessary portion of the relative path\n        truncate = os.path.dirname(self.directory)\n        # Traverse the filesystem downward from the target directory's uri\n        # Errors: `os.walk()` will simply return an empty generator if the\n        #         target directory does not exist.\n        wildcard_directories = set()\n        for curr_dir, _, files in os.walk(self.directory):\n            # find the path relative to the directory being added\n            if len(truncate) > 0:\n                _, _, short_path = curr_dir.partition(truncate)\n            else:\n                short_path = curr_dir\n            # remove leading / or \\ if it is present\n            if short_path.startswith(os.sep):\n                short_path = short_path[1:]\n\n            wildcard_directory = False\n            if os.path.split(short_path)[0] in wildcard_directories:\n                # Parent directory has matched a pattern, all sub-nodes should\n                # be added too\n                wildcard_directories.add(short_path)\n                wildcard_directory = True\n            else:\n                # Check if directory path matches one of the patterns\n                if match_short_path(short_path):\n                    # Directory matched pattern and it should therefor\n                    # be added along with all of its contents\n                    wildcard_directories.add(short_path)\n                    wildcard_directory = True\n\n            # Always add directories within wildcard directories - even if they\n            # are empty\n            if wildcard_directory:\n                add_directory(short_path)\n\n            # Iterate across the files in the current directory\n            for filename in files:\n                # Find the filename relative to the directory being added\n                short_name = os.path.join(short_path, filename)\n                filepath = os.path.join(curr_dir, filename)\n\n                if wildcard_directory:\n                    # Always add files in wildcard directories\n                    add_file(short_name, filepath)\n                else:\n                    # Add file (and all missing intermediary directories)\n                    # if it matches one of the patterns\n                    if match_short_path(short_name):\n                        add_directory(short_path)\n                        add_file(short_name, filepath)\n        # Send the request and present the response body to the user\n        req = requests.Request(\"POST\", 'http://localhost', files=names)\n        prep = req.prepare()\n        return prep", "response": "Pre - formats the multipart HTTP request to transmit the directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef body(self):\n        for chunk in self.gen_chunks(self.envelope.file_open(self.name)):\n            yield chunk\n        for chunk in self.gen_chunks(self.data):\n            yield chunk\n        for chunk in self.gen_chunks(self.envelope.file_close()):\n            yield chunk\n        for chunk in self.close():\n            yield chunk", "response": "Yields the encoded body."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef request(self, path,\n                args=[], files=[], opts={}, stream=False,\n                decoder=None, headers={}, data=None):\n        \"\"\"Makes an HTTP request to the IPFS daemon.\n\n        This function returns the contents of the HTTP response from the IPFS\n        daemon.\n\n        Raises\n        ------\n        ~ipfsapi.exceptions.ErrorResponse\n        ~ipfsapi.exceptions.ConnectionError\n        ~ipfsapi.exceptions.ProtocolError\n        ~ipfsapi.exceptions.StatusError\n        ~ipfsapi.exceptions.TimeoutError\n\n        Parameters\n        ----------\n        path : str\n            The REST command path to send\n        args : list\n            Positional parameters to be sent along with the HTTP request\n        files : :class:`io.RawIOBase` | :obj:`str` | :obj:`list`\n            The file object(s) or path(s) to stream to the daemon\n        opts : dict\n            Query string paramters to be sent along with the HTTP request\n        decoder : str\n            The encoder to use to parse the HTTP response\n        kwargs : dict\n            Additional arguments to pass to :mod:`requests`\n        \"\"\"\n        url = self.base + path\n\n        params = []\n        params.append(('stream-channels', 'true'))\n        for opt in opts.items():\n            params.append(opt)\n        for arg in args:\n            params.append(('arg', arg))\n\n        method = 'post' if (files or data) else 'get'\n\n        parser = encoding.get_encoding(decoder if decoder else \"none\")\n\n        return self._request(method, url, params, parser, stream,\n                             files, headers, data)", "response": "Makes an HTTP request to the IPFS daemon."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndownloading a file or files from IPFS into the current working directory.", "response": "def download(self, path, args=[], filepath=None, opts={},\n                 compress=True, **kwargs):\n        \"\"\"Makes a request to the IPFS daemon to download a file.\n\n        Downloads a file or files from IPFS into the current working\n        directory, or the directory given by ``filepath``.\n\n        Raises\n        ------\n        ~ipfsapi.exceptions.ErrorResponse\n        ~ipfsapi.exceptions.ConnectionError\n        ~ipfsapi.exceptions.ProtocolError\n        ~ipfsapi.exceptions.StatusError\n        ~ipfsapi.exceptions.TimeoutError\n\n        Parameters\n        ----------\n        path : str\n            The REST command path to send\n        filepath : str\n            The local path where IPFS will store downloaded files\n\n            Defaults to the current working directory.\n        args : list\n            Positional parameters to be sent along with the HTTP request\n        opts : dict\n            Query string paramters to be sent along with the HTTP request\n        compress : bool\n            Whether the downloaded file should be GZip compressed by the\n            daemon before being sent to the client\n        kwargs : dict\n            Additional arguments to pass to :mod:`requests`\n        \"\"\"\n        url = self.base + path\n        wd = filepath or '.'\n\n        params = []\n        params.append(('stream-channels', 'true'))\n        params.append(('archive', 'true'))\n        if compress:\n            params.append(('compress', 'true'))\n\n        for opt in opts.items():\n            params.append(opt)\n        for arg in args:\n            params.append(('arg', arg))\n\n        method = 'get'\n\n        res = self._do_request(method, url, params=params, stream=True,\n                               **kwargs)\n\n        self._do_raise_for_status(res)\n\n        # try to stream download as a tar file stream\n        mode = 'r|gz' if compress else 'r|'\n\n        with tarfile.open(fileobj=res.raw, mode=mode) as tf:\n            tf.extractall(path=wd)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef session(self):\n        self._session = requests.session()\n        yield\n        self._session.close()\n        self._session = None", "response": "A context manager for this client s session. This function closes the current session when this client goes out of the scope."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assert_version(version, minimum=VERSION_MINIMUM, maximum=VERSION_MAXIMUM):\n    # Convert version strings to integer tuples\n    version = list(map(int, version.split('-', 1)[0].split('.')))\n    minimum = list(map(int, minimum.split('-', 1)[0].split('.')))\n    maximum = list(map(int, maximum.split('-', 1)[0].split('.')))\n\n    if minimum > version or version >= maximum:\n        raise exceptions.VersionMismatch(version, minimum, maximum)", "response": "Make sure that the given daemon version is supported by this client\n    version."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect to the daemon and validate that the version number is supported.", "response": "def connect(host=DEFAULT_HOST, port=DEFAULT_PORT, base=DEFAULT_BASE,\n            chunk_size=multipart.default_chunk_size, **defaults):\n    \"\"\"Create a new :class:`~ipfsapi.Client` instance and connect to the\n    daemon to validate that its version is supported.\n\n    Raises\n    ------\n    ~ipfsapi.exceptions.VersionMismatch\n    ~ipfsapi.exceptions.ErrorResponse\n    ~ipfsapi.exceptions.ConnectionError\n    ~ipfsapi.exceptions.ProtocolError\n    ~ipfsapi.exceptions.StatusError\n    ~ipfsapi.exceptions.TimeoutError\n\n\n    All parameters are identical to those passed to the constructor of the\n    :class:`~ipfsapi.Client` class.\n\n    Returns\n    -------\n        ~ipfsapi.Client\n    \"\"\"\n    # Create client instance\n    client = Client(host, port, base, chunk_size, **defaults)\n\n    # Query version number from daemon and validate it\n    assert_version(client.version()['Version'])\n\n    return client"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a file or directory of files to the IPFS.", "response": "def add(self, files, recursive=False, pattern='**', *args, **kwargs):\n        \"\"\"Add a file, or directory of files to IPFS.\n\n        .. code-block:: python\n\n            >>> with io.open('nurseryrhyme.txt', 'w', encoding='utf-8') as f:\n            ...     numbytes = f.write('Mary had a little lamb')\n            >>> c.add('nurseryrhyme.txt')\n            {'Hash': 'QmZfF6C9j4VtoCsTp4KSrhYH47QMd3DNXVZBKaxJdhaPab',\n             'Name': 'nurseryrhyme.txt'}\n\n        Parameters\n        ----------\n        files : str\n            A filepath to either a file or directory\n        recursive : bool\n            Controls if files in subdirectories are added or not\n        pattern : str | list\n            Single `*glob* <https://docs.python.org/3/library/glob.html>`_\n            pattern or list of *glob* patterns and compiled regular expressions\n            to match the names of the filepaths to keep\n        trickle : bool\n            Use trickle-dag format (optimized for streaming) when generating\n            the dag; see `the FAQ <https://github.com/ipfs/faq/issues/218>` for\n            more information (Default: ``False``)\n        only_hash : bool\n            Only chunk and hash, but do not write to disk (Default: ``False``)\n        wrap_with_directory : bool\n            Wrap files with a directory object to preserve their filename\n            (Default: ``False``)\n        chunker : str\n            The chunking algorithm to use\n        pin : bool\n            Pin this object when adding (Default: ``True``)\n\n        Returns\n        -------\n            dict: File name and hash of the added file node\n        \"\"\"\n        #PY2: No support for kw-only parameters after glob parameters\n        opts = {\n            \"trickle\": kwargs.pop(\"trickle\", False),\n            \"only-hash\": kwargs.pop(\"only_hash\", False),\n            \"wrap-with-directory\": kwargs.pop(\"wrap_with_directory\", False),\n            \"pin\": kwargs.pop(\"pin\", True)\n        }\n        if \"chunker\" in kwargs:\n            opts[\"chunker\"] = kwargs.pop(\"chunker\")\n        kwargs.setdefault(\"opts\", opts)\n\n        body, headers = multipart.stream_filesystem_node(\n            files, recursive, pattern, self.chunk_size\n        )\n        return self._client.request('/add', decoder='json',\n                                    data=body, headers=headers, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndownloading a file or directory of files from IPFS.", "response": "def get(self, multihash, **kwargs):\n        \"\"\"Downloads a file, or directory of files from IPFS.\n\n        Files are placed in the current working directory.\n\n        Parameters\n        ----------\n        multihash : str\n            The path to the IPFS object(s) to be outputted\n        \"\"\"\n        args = (multihash,)\n        return self._client.download('/get', args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cat(self, multihash, offset=0, length=-1, **kwargs):\n        opts = {}\n        if offset != 0:\n            opts['offset'] = offset\n        if length != -1:\n            opts['length'] = length\n        args = (multihash,)\n        return self._client.request('/cat', args, opts=opts, **kwargs)", "response": "r Returns the contents of a file identified by hash."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of objects linked to by the given hash.", "response": "def ls(self, multihash, **kwargs):\n        \"\"\"Returns a list of objects linked to by the given hash.\n\n        .. code-block:: python\n\n            >>> c.ls('QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D')\n            {'Objects': [\n              {'Hash': 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D',\n               'Links': [\n                {'Hash': 'Qmd2xkBfEwEs9oMTk77A6jrsgurpF3ugXSg7dtPNFkcNMV',\n                 'Name': 'Makefile',          'Size': 174, 'Type': 2},\n                 \u2026\n                {'Hash': 'QmSY8RfVntt3VdxWppv9w5hWgNrE31uctgTiYwKir8eXJY',\n                 'Name': 'published-version', 'Size': 55,  'Type': 2}\n                ]}\n              ]}\n\n        Parameters\n        ----------\n        multihash : str\n            The path to the IPFS object(s) to list links from\n\n        Returns\n        -------\n            dict : Directory information and contents\n        \"\"\"\n        args = (multihash,)\n        return self._client.request('/ls', args, decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef refs(self, multihash, **kwargs):\n        args = (multihash,)\n        return self._client.request('/refs', args, decoder='json', **kwargs)", "response": "Returns a list of hashes of objects referenced by the given hash."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dict with the size of the block with the given hash.", "response": "def block_stat(self, multihash, **kwargs):\n        \"\"\"Returns a dict with the size of the block with the given hash.\n\n        .. code-block:: python\n\n            >>> c.block_stat('QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D')\n            {'Key':  'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D',\n             'Size': 258}\n\n        Parameters\n        ----------\n        multihash : str\n            The base58 multihash of an existing block to stat\n\n        Returns\n        -------\n            dict : Information about the requested block\n        \"\"\"\n        args = (multihash,)\n        return self._client.request('/block/stat', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef block_get(self, multihash, **kwargs):\n        args = (multihash,)\n        return self._client.request('/block/get', args, **kwargs)", "response": "Returns the raw contents of a block."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of wanted blocks for a given peer.", "response": "def bitswap_wantlist(self, peer=None, **kwargs):\n        \"\"\"Returns blocks currently on the bitswap wantlist.\n\n        .. code-block:: python\n\n            >>> c.bitswap_wantlist()\n            {'Keys': [\n                'QmeV6C6XVt1wf7V7as7Yak3mxPma8jzpqyhtRtCvpKcfBb',\n                'QmdCWFLDXqgdWQY9kVubbEHBbkieKd3uo7MtCm7nTZZE9K',\n                'QmVQ1XvYGF19X4eJqz1s7FJYJqAxFC4oqh3vWJJEXn66cp'\n            ]}\n\n        Parameters\n        ----------\n        peer : str\n            Peer to show wantlist for.\n\n        Returns\n        -------\n            dict : List of wanted blocks\n        \"\"\"\n        args = (peer,)\n        return self._client.request('/bitswap/wantlist', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bitswap_unwant(self, key, **kwargs):\n        args = (key,)\n        return self._client.request('/bitswap/unwant', args, **kwargs)", "response": "Remove a given block from wantlist."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new object from an IPFS template.", "response": "def object_new(self, template=None, **kwargs):\n        \"\"\"Creates a new object from an IPFS template.\n\n        By default this creates and returns a new empty merkledag node, but you\n        may pass an optional template argument to create a preformatted node.\n\n        .. code-block:: python\n\n            >>> c.object_new()\n            {'Hash': 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'}\n\n        Parameters\n        ----------\n        template : str\n            Blueprints from which to construct the new object. Possible values:\n\n             * ``\"unixfs-dir\"``\n             * ``None``\n\n        Returns\n        -------\n            dict : Object hash\n        \"\"\"\n        args = (template,) if template is not None else ()\n        return self._client.request('/object/new', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef object_links(self, multihash, **kwargs):\n        args = (multihash,)\n        return self._client.request('/object/links', args,\n                                    decoder='json', **kwargs)", "response": "Returns the links pointed to by the specified object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting and serialize the DAG node named by multihash.", "response": "def object_get(self, multihash, **kwargs):\n        \"\"\"Get and serialize the DAG node named by multihash.\n\n        .. code-block:: python\n\n            >>> c.object_get('QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D')\n            {'Data': '\\x08\\x01',\n             'Links': [\n                {'Hash': 'Qmd2xkBfEwEs9oMTk77A6jrsgurpF3ugXSg7dtPNFkcNMV',\n                 'Name': 'Makefile',          'Size': 174},\n                {'Hash': 'QmeKozNssnkJ4NcyRidYgDY2jfRZqVEoRGfipkgath71bX',\n                 'Name': 'example',           'Size': 1474},\n                {'Hash': 'QmZAL3oHMQYqsV61tGvoAVtQLs1WzRe1zkkamv9qxqnDuK',\n                 'Name': 'home',              'Size': 3947},\n                {'Hash': 'QmZNPyKVriMsZwJSNXeQtVQSNU4v4KEKGUQaMT61LPahso',\n                 'Name': 'lib',               'Size': 268261},\n                {'Hash': 'QmSY8RfVntt3VdxWppv9w5hWgNrE31uctgTiYwKir8eXJY',\n                 'Name': 'published-version', 'Size': 55}]}\n\n        Parameters\n        ----------\n        multihash : str\n            Key of the object to retrieve, in base58-encoded multihash format\n\n        Returns\n        -------\n            dict : Object data and links\n        \"\"\"\n        args = (multihash,)\n        return self._client.request('/object/get', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef object_put(self, file, **kwargs):\n        body, headers = multipart.stream_files(file, self.chunk_size)\n        return self._client.request('/object/put', decoder='json',\n                                    data=body, headers=headers, **kwargs)", "response": "Stores input as a DAG object and returns its key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget stats for the object with the given multihash.", "response": "def object_stat(self, multihash, **kwargs):\n        \"\"\"Get stats for the DAG node named by multihash.\n\n        .. code-block:: python\n\n            >>> c.object_stat('QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D')\n            {'LinksSize': 256, 'NumLinks': 5,\n             'Hash': 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D',\n             'BlockSize': 258, 'CumulativeSize': 274169, 'DataSize': 2}\n\n        Parameters\n        ----------\n        multihash : str\n            Key of the object to retrieve, in base58-encoded multihash format\n\n        Returns\n        -------\n            dict\n        \"\"\"\n        args = (multihash,)\n        return self._client.request('/object/stat', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef object_patch_append_data(self, multihash, new_data, **kwargs):\n        args = (multihash,)\n        body, headers = multipart.stream_files(new_data, self.chunk_size)\n        return self._client.request('/object/patch/append-data', args,\n                                    decoder='json',\n                                    data=body, headers=headers, **kwargs)", "response": "Creates a new merkledag object based on an existing one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new merkledag object based on an existing object.", "response": "def object_patch_add_link(self, root, name, ref, create=False, **kwargs):\n        \"\"\"Creates a new merkledag object based on an existing one.\n\n        The new object will have a link to the provided object.\n\n        .. code-block:: python\n\n            >>> c.object_patch_add_link(\n            ...     'QmR79zQQj2aDfnrNgczUhvf2qWapEfQ82YQRt3QjrbhSb2',\n            ...     'Johnny',\n            ...     'QmR79zQQj2aDfnrNgczUhvf2qWapEfQ82YQRt3QjrbhSb2'\n            ... )\n            {'Hash': 'QmNtXbF3AjAk59gQKRgEdVabHcSsiPUnJwHnZKyj2x8Z3k'}\n\n        Parameters\n        ----------\n        root : str\n            IPFS hash for the object being modified\n        name : str\n            name for the new link\n        ref : str\n            IPFS hash for the object being linked to\n        create : bool\n            Create intermediary nodes\n\n        Returns\n        -------\n            dict : Hash of new object\n        \"\"\"\n        kwargs.setdefault(\"opts\", {\"create\": create})\n\n        args = ((root, name, ref),)\n        return self._client.request('/object/patch/add-link', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef object_patch_rm_link(self, root, link, **kwargs):\n        args = ((root, link),)\n        return self._client.request('/object/patch/rm-link', args,\n                                    decoder='json', **kwargs)", "response": "Creates a new merkledag object based on an existing object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef object_patch_set_data(self, root, data, **kwargs):\n        args = (root,)\n        body, headers = multipart.stream_files(data, self.chunk_size)\n        return self._client.request('/object/patch/set-data', args,\n                                    decoder='json',\n                                    data=body, headers=headers, **kwargs)", "response": "Create a new merkledag object based on an existing object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef file_ls(self, multihash, **kwargs):\n        args = (multihash,)\n        return self._client.request('/file/ls', args, decoder='json', **kwargs)", "response": "A function to list Unix filesystem objects."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resolve(self, name, recursive=False, **kwargs):\n        kwargs.setdefault(\"opts\", {\"recursive\": recursive})\n\n        args = (name,)\n        return self._client.request('/resolve', args, decoder='json', **kwargs)", "response": "Resolves an identifier and returns the path of the referenced item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a new public key that can be used for name_publish.", "response": "def key_gen(self, key_name, type, size=2048, **kwargs):\n        \"\"\"Adds a new public key that can be used for name_publish.\n\n        .. code-block:: python\n\n            >>> c.key_gen('example_key_name')\n            {'Name': 'example_key_name',\n             'Id': 'QmQLaT5ZrCfSkXTH6rUKtVidcxj8jrW3X2h75Lug1AV7g8'}\n\n        Parameters\n        ----------\n        key_name : str\n            Name of the new Key to be generated. Used to reference the Keys.\n        type : str\n            Type of key to generate. The current possible keys types are:\n\n             * ``\"rsa\"``\n             * ``\"ed25519\"``\n        size : int\n            Bitsize of key to generate\n\n        Returns\n        -------\n            dict : Key name and Key Id\n        \"\"\"\n\n        opts = {\"type\": type, \"size\": size}\n        kwargs.setdefault(\"opts\", opts)\n        args = (key_name,)\n\n        return self._client.request('/key/gen', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef key_rm(self, key_name, *key_names, **kwargs):\n        args = (key_name,) + key_names\n        return self._client.request('/key/rm', args, decoder='json', **kwargs)", "response": "Remove a keypair from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrename a keypair containing a new name.", "response": "def key_rename(self, key_name, new_key_name, **kwargs):\n        \"\"\"Rename a keypair\n\n        .. code-block:: python\n\n            >>> c.key_rename(\"bla\", \"personal\")\n            {\"Was\": \"bla\",\n             \"Now\": \"personal\",\n             \"Id\": \"QmeyrRNxXaasZaoDXcCZgryoBCga9shaHQ4suHAYXbNZF3\",\n             \"Overwrite\": False}\n\n        Parameters\n        ----------\n        key_name : str\n            Current name of the key to rename\n        new_key_name : str\n            New name of the key\n\n        Returns\n        -------\n            dict : List of key names and IDs that have been removed\n        \"\"\"\n        args = (key_name, new_key_name)\n        return self._client.request('/key/rename', args, decoder='json',\n                                    **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef name_publish(self, ipfs_path, resolve=True, lifetime=\"24h\", ttl=None,\n                     key=None, **kwargs):\n        \"\"\"Publishes an object to IPNS.\n\n        IPNS is a PKI namespace, where names are the hashes of public keys, and\n        the private key enables publishing new (signed) values. In publish, the\n        default value of *name* is your own identity public key.\n\n        .. code-block:: python\n\n            >>> c.name_publish('/ipfs/QmfZY61ukoQuCX8e5Pt7v8pRfhkyxwZK \u2026 GZ5d')\n            {'Value': '/ipfs/QmfZY61ukoQuCX8e5Pt7v8pRfhkyxwZKZMTodAtmvyGZ5d',\n             'Name': 'QmVgNoP89mzpgEAAqK8owYoDEyB97MkcGvoWZir8otE9Uc'}\n\n        Parameters\n        ----------\n        ipfs_path : str\n            IPFS path of the object to be published\n        resolve : bool\n            Resolve given path before publishing\n        lifetime : str\n            Time duration that the record will be valid for\n\n            Accepts durations such as ``\"300s\"``, ``\"1.5h\"`` or ``\"2h45m\"``.\n            Valid units are:\n\n             * ``\"ns\"``\n             * ``\"us\"`` (or ``\"\u00b5s\"``)\n             * ``\"ms\"``\n             * ``\"s\"``\n             * ``\"m\"``\n             * ``\"h\"``\n        ttl : int\n            Time duration this record should be cached for\n        key : string\n             Name of the key to be used, as listed by 'ipfs key list'.\n\n        Returns\n        -------\n            dict : IPNS hash and the IPFS path it points at\n        \"\"\"\n        opts = {\"lifetime\": lifetime, \"resolve\": resolve}\n        if ttl:\n            opts[\"ttl\"] = ttl\n        if key:\n            opts[\"key\"] = key\n        kwargs.setdefault(\"opts\", opts)\n\n        args = (ipfs_path,)\n        return self._client.request('/name/publish', args,\n                                    decoder='json', **kwargs)", "response": "Publishes an object to IPNS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef name_resolve(self, name=None, recursive=False,\n                     nocache=False, **kwargs):\n        \"\"\"Gets the value currently published at an IPNS name.\n\n        IPNS is a PKI namespace, where names are the hashes of public keys, and\n        the private key enables publishing new (signed) values. In resolve, the\n        default value of ``name`` is your own identity public key.\n\n        .. code-block:: python\n\n            >>> c.name_resolve()\n            {'Path': '/ipfs/QmfZY61ukoQuCX8e5Pt7v8pRfhkyxwZKZMTodAtmvyGZ5d'}\n\n        Parameters\n        ----------\n        name : str\n            The IPNS name to resolve (defaults to the connected node)\n        recursive : bool\n            Resolve until the result is not an IPFS name (default: false)\n        nocache : bool\n            Do not use cached entries (default: false)\n\n        Returns\n        -------\n            dict : The IPFS path the IPNS hash points at\n        \"\"\"\n        kwargs.setdefault(\"opts\", {\"recursive\": recursive,\n                                   \"nocache\": nocache})\n        args = (name,) if name is not None else ()\n        return self._client.request('/name/resolve', args,\n                                    decoder='json', **kwargs)", "response": "Gets the value currently published at an IPNS name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dns(self, domain_name, recursive=False, **kwargs):\n        kwargs.setdefault(\"opts\", {\"recursive\": recursive})\n\n        args = (domain_name,)\n        return self._client.request('/dns', args, decoder='json', **kwargs)", "response": "Resolves DNS links to the referenced object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pin_add(self, path, *paths, **kwargs):\n        #PY2: No support for kw-only parameters after glob parameters\n        if \"recursive\" in kwargs:\n            kwargs.setdefault(\"opts\", {\"recursive\": kwargs.pop(\"recursive\")})\n\n        args = (path,) + paths\n        return self._client.request('/pin/add', args, decoder='json', **kwargs)", "response": "Adds an object to the local storage."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a pinned object from local storage.", "response": "def pin_rm(self, path, *paths, **kwargs):\n        \"\"\"Removes a pinned object from local storage.\n\n        Removes the pin from the given object allowing it to be garbage\n        collected if needed.\n\n        .. code-block:: python\n\n            >>> c.pin_rm('QmfZY61ukoQuCX8e5Pt7v8pRfhkyxwZKZMTodAtmvyGZ5d')\n            {'Pins': ['QmfZY61ukoQuCX8e5Pt7v8pRfhkyxwZKZMTodAtmvyGZ5d']}\n\n        Parameters\n        ----------\n        path : str\n            Path to object(s) to be unpinned\n        recursive : bool\n            Recursively unpin the object linked to by the specified object(s)\n\n        Returns\n        -------\n            dict : List of IPFS objects that have been unpinned\n        \"\"\"\n        #PY2: No support for kw-only parameters after glob parameters\n        if \"recursive\" in kwargs:\n            kwargs.setdefault(\"opts\", {\"recursive\": kwargs[\"recursive\"]})\n            del kwargs[\"recursive\"]\n\n        args = (path,) + paths\n        return self._client.request('/pin/rm', args, decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlists objects pinned to local storage.", "response": "def pin_ls(self, type=\"all\", **kwargs):\n        \"\"\"Lists objects pinned to local storage.\n\n        By default, all pinned objects are returned, but the ``type`` flag or\n        arguments can restrict that to a specific pin type or to some specific\n        objects respectively.\n\n        .. code-block:: python\n\n            >>> c.pin_ls()\n            {'Keys': {\n                'QmNNPMA1eGUbKxeph6yqV8ZmRkdVat \u2026 YMuz': {'Type': 'recursive'},\n                'QmNPZUCeSN5458Uwny8mXSWubjjr6J \u2026 kP5e': {'Type': 'recursive'},\n                'QmNg5zWpRMxzRAVg7FTQ3tUxVbKj8E \u2026 gHPz': {'Type': 'indirect'},\n                \u2026\n                'QmNiuVapnYCrLjxyweHeuk6Xdqfvts \u2026 wCCe': {'Type': 'indirect'}}}\n\n        Parameters\n        ----------\n        type : \"str\"\n            The type of pinned keys to list. Can be:\n\n             * ``\"direct\"``\n             * ``\"indirect\"``\n             * ``\"recursive\"``\n             * ``\"all\"``\n\n        Returns\n        -------\n            dict : Hashes of pinned IPFS objects and why they are pinned\n        \"\"\"\n        kwargs.setdefault(\"opts\", {\"type\": type})\n\n        return self._client.request('/pin/ls', decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pin_update(self, from_path, to_path, **kwargs):\n        #PY2: No support for kw-only parameters after glob parameters\n        if \"unpin\" in kwargs:\n            kwargs.setdefault(\"opts\", {\"unpin\": kwargs[\"unpin\"]})\n            del kwargs[\"unpin\"]\n\n        args = (from_path, to_path)\n        return self._client.request('/pin/update', args, decoder='json',\n                                    **kwargs)", "response": "Replaces one pin with another."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pin_verify(self, path, *paths, **kwargs):\n        #PY2: No support for kw-only parameters after glob parameters\n        if \"verbose\" in kwargs:\n            kwargs.setdefault(\"opts\", {\"verbose\": kwargs[\"verbose\"]})\n            del kwargs[\"verbose\"]\n\n        args = (path,) + paths\n        return self._client.request('/pin/verify', args, decoder='json',\n                                    stream=True, **kwargs)", "response": "Verify that recursive pins are complete."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef id(self, peer=None, **kwargs):\n        args = (peer,) if peer is not None else ()\n        return self._client.request('/id', args, decoder='json', **kwargs)", "response": "Shows the IPFS Node ID info."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds peers to the bootstrap list.", "response": "def bootstrap_add(self, peer, *peers, **kwargs):\n        \"\"\"Adds peers to the bootstrap list.\n\n        Parameters\n        ----------\n        peer : str\n            IPFS MultiAddr of a peer to add to the list\n\n        Returns\n        -------\n            dict\n        \"\"\"\n        args = (peer,) + peers\n        return self._client.request('/bootstrap/add', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a given multiaddr filter to the list of daemons swarm filters.", "response": "def swarm_filters_add(self, address, *addresses, **kwargs):\n        \"\"\"Adds a given multiaddr filter to the filter list.\n\n        This will add an address filter to the daemons swarm. Filters applied\n        this way will not persist daemon reboots, to achieve that, add your\n        filters to the configuration file.\n\n        .. code-block:: python\n\n            >>> c.swarm_filters_add(\"/ip4/192.168.0.0/ipcidr/16\")\n            {'Strings': ['/ip4/192.168.0.0/ipcidr/16']}\n\n        Parameters\n        ----------\n        address : str\n            Multiaddr to filter\n\n        Returns\n        -------\n            dict : List of swarm filters added\n        \"\"\"\n        args = (address,) + addresses\n        return self._client.request('/swarm/filters/add', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dht_query(self, peer_id, *peer_ids, **kwargs):\n        args = (peer_id,) + peer_ids\n        return self._client.request('/dht/query', args,\n                                    decoder='json', **kwargs)", "response": "Query the DHT for the closest Peer IDs to a given peer ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds peers in the DHT that can provide a specific value.", "response": "def dht_findprovs(self, multihash, *multihashes, **kwargs):\n        \"\"\"Finds peers in the DHT that can provide a specific value.\n\n        .. code-block:: python\n\n            >>> c.dht_findprovs(\"QmNPXDC6wTXVmZ9Uoc8X1oqxRRJr4f1sDuyQu \u2026 mpW2\")\n            [{'ID': 'QmaxqKpiYNr62uSFBhxJAMmEMkT6dvc3oHkrZNpH2VMTLZ',\n              'Extra': '', 'Type': 6, 'Responses': None},\n             {'ID': 'QmaK6Aj5WXkfnWGoWq7V8pGUYzcHPZp4jKQ5JtmRvSzQGk',\n              'Extra': '', 'Type': 6, 'Responses': None},\n             {'ID': 'QmdUdLu8dNvr4MVW1iWXxKoQrbG6y1vAVWPdkeGK4xppds',\n              'Extra': '', 'Type': 6, 'Responses': None},\n             \u2026\n             {'ID': '', 'Extra': '', 'Type': 4, 'Responses': [\n                {'ID': 'QmVgNoP89mzpgEAAqK8owYoDEyB97Mk \u2026 E9Uc', 'Addrs': None}\n              ]},\n             {'ID': 'QmaxqKpiYNr62uSFBhxJAMmEMkT6dvc3oHkrZNpH2VMTLZ',\n              'Extra': '', 'Type': 1, 'Responses': [\n                {'ID': 'QmSHXfsmN3ZduwFDjeqBn1C8b1tcLkxK6yd \u2026 waXw', 'Addrs': [\n                    '/ip4/127.0.0.1/tcp/4001',\n                    '/ip4/172.17.0.8/tcp/4001',\n                    '/ip6/::1/tcp/4001',\n                    '/ip4/52.32.109.74/tcp/1028'\n                  ]}\n              ]}]\n\n        Parameters\n        ----------\n        multihash : str\n            The DHT key to find providers for\n\n        Returns\n        -------\n            dict : List of provider Peer IDs\n        \"\"\"\n        args = (multihash,) + multihashes\n        return self._client.request('/dht/findprovs', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dht_get(self, key, *keys, **kwargs):\n        args = (key,) + keys\n        res = self._client.request('/dht/get', args, decoder='json', **kwargs)\n\n        if isinstance(res, dict) and \"Extra\" in res:\n            return res[\"Extra\"]\n        else:\n            for r in res:\n                if \"Extra\" in r and len(r[\"Extra\"]) > 0:\n                    return r[\"Extra\"]\n        raise exceptions.Error(\"empty response from DHT\")", "response": "Queries the DHT for its best value related to a given key."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends ping messages to the specified peers.", "response": "def ping(self, peer, *peers, **kwargs):\n        \"\"\"Provides round-trip latency information for the routing system.\n\n        Finds nodes via the routing system, sends pings, waits for pongs,\n        and prints out round-trip latency information.\n\n        .. code-block:: python\n\n            >>> c.ping(\"QmTzQ1JRkWErjk39mryYw2WVaphAZNAREyMchXzYQ7c15n\")\n            [{'Success': True,  'Time': 0,\n              'Text': 'Looking up peer QmTzQ1JRkWErjk39mryYw2WVaphAZN \u2026 c15n'},\n             {'Success': False, 'Time': 0,\n              'Text': 'Peer lookup error: routing: not found'}]\n\n        Parameters\n        ----------\n        peer : str\n            ID of peer to be pinged\n        count : int\n            Number of ping messages to send (Default: ``10``)\n\n        Returns\n        -------\n            list : Progress reports from the ping\n        \"\"\"\n        #PY2: No support for kw-only parameters after glob parameters\n        if \"count\" in kwargs:\n            kwargs.setdefault(\"opts\", {\"count\": kwargs[\"count\"]})\n            del kwargs[\"count\"]\n\n        args = (peer,) + peers\n        return self._client.request('/ping', args, decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef config(self, key, value=None, **kwargs):\n        args = (key, value)\n        return self._client.request('/config', args, decoder='json', **kwargs)", "response": "Controls configuration variables.\n\n        .. code-block:: python\n\n            >>> c.config(\"Addresses.Gateway\")\n            {'Key': 'Addresses.Gateway', 'Value': '/ip4/127.0.0.1/tcp/8080'}\n            >>> c.config(\"Addresses.Gateway\", \"/ip4/127.0.0.1/tcp/8081\")\n            {'Key': 'Addresses.Gateway', 'Value': '/ip4/127.0.0.1/tcp/8081'}\n\n        Parameters\n        ----------\n        key : str\n            The key of the configuration entry (e.g. \"Addresses.API\")\n        value : dict\n            The value to set the configuration entry to\n\n        Returns\n        -------\n            dict : Requested/updated key and its (new) value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreplaces the existing config with a user - defined config.", "response": "def config_replace(self, *args, **kwargs):\n        \"\"\"Replaces the existing config with a user-defined config.\n\n        Make sure to back up the config file first if neccessary, as this\n        operation can't be undone.\n        \"\"\"\n        return self._client.request('/config/replace', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchanging the logging output of a running daemon.", "response": "def log_level(self, subsystem, level, **kwargs):\n        r\"\"\"Changes the logging output of a running daemon.\n\n        .. code-block:: python\n\n            >>> c.log_level(\"path\", \"info\")\n            {'Message': \"Changed log level of 'path' to 'info'\\n\"}\n\n        Parameters\n        ----------\n        subsystem : str\n            The subsystem logging identifier (Use ``\"all\"`` for all subsystems)\n        level : str\n            The desired logging level. Must be one of:\n\n             * ``\"debug\"``\n             * ``\"info\"``\n             * ``\"warning\"``\n             * ``\"error\"``\n             * ``\"fatal\"``\n             * ``\"panic\"``\n\n        Returns\n        -------\n            dict : Status message\n        \"\"\"\n        args = (subsystem, level)\n        return self._client.request('/log/level', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads log outputs as they are written.", "response": "def log_tail(self, **kwargs):\n        r\"\"\"Reads log outputs as they are written.\n\n        This function returns an iterator needs to be closed using a context\n        manager (``with``-statement) or using the ``.close()`` method.\n\n        .. code-block:: python\n\n            >>> with c.log_tail() as log_tail_iter:\n            ...     for item in log_tail_iter:\n            ...         print(item)\n            ...\n            {\"event\":\"updatePeer\",\"system\":\"dht\",\n             \"peerID\":\"QmepsDPxWtLDuKvEoafkpJxGij4kMax11uTH7WnKqD25Dq\",\n             \"session\":\"7770b5e0-25ec-47cd-aa64-f42e65a10023\",\n             \"time\":\"2016-08-22T13:25:27.43353297Z\"}\n            {\"event\":\"handleAddProviderBegin\",\"system\":\"dht\",\n             \"peer\":\"QmepsDPxWtLDuKvEoafkpJxGij4kMax11uTH7WnKqD25Dq\",\n             \"session\":\"7770b5e0-25ec-47cd-aa64-f42e65a10023\",\n             \"time\":\"2016-08-22T13:25:27.433642581Z\"}\n            {\"event\":\"handleAddProvider\",\"system\":\"dht\",\"duration\":91704,\n             \"key\":\"QmNT9Tejg6t57Vs8XM2TVJXCwevWiGsZh3kB4HQXUZRK1o\",\n             \"peer\":\"QmepsDPxWtLDuKvEoafkpJxGij4kMax11uTH7WnKqD25Dq\",\n             \"session\":\"7770b5e0-25ec-47cd-aa64-f42e65a10023\",\n             \"time\":\"2016-08-22T13:25:27.433747513Z\"}\n            {\"event\":\"updatePeer\",\"system\":\"dht\",\n             \"peerID\":\"QmepsDPxWtLDuKvEoafkpJxGij4kMax11uTH7WnKqD25Dq\",\n             \"session\":\"7770b5e0-25ec-47cd-aa64-f42e65a10023\",\n             \"time\":\"2016-08-22T13:25:27.435843012Z\"}\n            \u2026\n\n        Returns\n        -------\n            iterable\n        \"\"\"\n        return self._client.request('/log/tail', decoder='json',\n                                    stream=True, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncopying files within the MFS to the specified MFS location.", "response": "def files_cp(self, source, dest, **kwargs):\n        \"\"\"Copies files within the MFS.\n\n        Due to the nature of IPFS this will not actually involve any of the\n        file's content being copied.\n\n        .. code-block:: python\n\n            >>> c.files_ls(\"/\")\n            {'Entries': [\n                {'Size': 0, 'Hash': '', 'Name': 'Software', 'Type': 0},\n                {'Size': 0, 'Hash': '', 'Name': 'test', 'Type': 0}\n            ]}\n            >>> c.files_cp(\"/test\", \"/bla\")\n            ''\n            >>> c.files_ls(\"/\")\n            {'Entries': [\n                {'Size': 0, 'Hash': '', 'Name': 'Software', 'Type': 0},\n                {'Size': 0, 'Hash': '', 'Name': 'bla', 'Type': 0},\n                {'Size': 0, 'Hash': '', 'Name': 'test', 'Type': 0}\n            ]}\n\n        Parameters\n        ----------\n        source : str\n            Filepath within the MFS to copy from\n        dest : str\n            Destination filepath with the MFS to which the file will be\n            copied to\n        \"\"\"\n        args = (source, dest)\n        return self._client.request('/files/cp', args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists contents of a directory within the MFS.", "response": "def files_ls(self, path, **kwargs):\n        \"\"\"Lists contents of a directory in the MFS.\n\n        .. code-block:: python\n\n            >>> c.files_ls(\"/\")\n            {'Entries': [\n                {'Size': 0, 'Hash': '', 'Name': 'Software', 'Type': 0}\n            ]}\n\n        Parameters\n        ----------\n        path : str\n            Filepath within the MFS\n\n        Returns\n        -------\n            dict : Directory entries\n        \"\"\"\n        args = (path,)\n        return self._client.request('/files/ls', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef files_mkdir(self, path, parents=False, **kwargs):\n        kwargs.setdefault(\"opts\", {\"parents\": parents})\n\n        args = (path,)\n        return self._client.request('/files/mkdir', args, **kwargs)", "response": "Creates a directory within the MFS."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns basic stat information for an MFS file.", "response": "def files_stat(self, path, **kwargs):\n        \"\"\"Returns basic ``stat`` information for an MFS file\n        (including its hash).\n\n        .. code-block:: python\n\n            >>> c.files_stat(\"/test\")\n            {'Hash': 'QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn',\n             'Size': 0, 'CumulativeSize': 4, 'Type': 'directory', 'Blocks': 0}\n\n        Parameters\n        ----------\n        path : str\n            Filepath within the MFS\n\n        Returns\n        -------\n            dict : MFS file information\n        \"\"\"\n        args = (path,)\n        return self._client.request('/files/stat', args,\n                                    decoder='json', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving a file from the MFS.", "response": "def files_rm(self, path, recursive=False, **kwargs):\n        \"\"\"Removes a file from the MFS.\n\n        .. code-block:: python\n\n            >>> c.files_rm(\"/bla/file\")\n            b''\n\n        Parameters\n        ----------\n        path : str\n            Filepath within the MFS\n        recursive : bool\n            Recursively remove directories?\n        \"\"\"\n        kwargs.setdefault(\"opts\", {\"recursive\": recursive})\n\n        args = (path,)\n        return self._client.request('/files/rm', args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a file stored in the MFS.", "response": "def files_read(self, path, offset=0, count=None, **kwargs):\n        \"\"\"Reads a file stored in the MFS.\n\n        .. code-block:: python\n\n            >>> c.files_read(\"/bla/file\")\n            b'hi'\n\n        Parameters\n        ----------\n        path : str\n            Filepath within the MFS\n        offset : int\n            Byte offset at which to begin reading at\n        count : int\n            Maximum number of bytes to read\n\n        Returns\n        -------\n            str : MFS file contents\n        \"\"\"\n        opts = {\"offset\": offset}\n        if count is not None:\n            opts[\"count\"] = count\n        kwargs.setdefault(\"opts\", opts)\n\n        args = (path,)\n        return self._client.request('/files/read', args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef files_write(self, path, file, offset=0, create=False, truncate=False,\n                    count=None, **kwargs):\n        \"\"\"Writes to a mutable file in the MFS.\n\n        .. code-block:: python\n\n            >>> c.files_write(\"/test/file\", io.BytesIO(b\"hi\"), create=True)\n            b''\n\n        Parameters\n        ----------\n        path : str\n            Filepath within the MFS\n        file : io.RawIOBase\n            IO stream object with data that should be written\n        offset : int\n            Byte offset at which to begin writing at\n        create : bool\n            Create the file if it does not exist\n        truncate : bool\n            Truncate the file to size zero before writing\n        count : int\n            Maximum number of bytes to read from the source ``file``\n        \"\"\"\n        opts = {\"offset\": offset, \"create\": create, \"truncate\": truncate}\n        if count is not None:\n            opts[\"count\"] = count\n        kwargs.setdefault(\"opts\", opts)\n\n        args = (path,)\n        body, headers = multipart.stream_files(file, self.chunk_size)\n        return self._client.request('/files/write', args,\n                                    data=body, headers=headers, **kwargs)", "response": "Writes to a mutable file in the MFS."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmove files and directories within the MFS.", "response": "def files_mv(self, source, dest, **kwargs):\n        \"\"\"Moves files and directories within the MFS.\n\n        .. code-block:: python\n\n            >>> c.files_mv(\"/test/file\", \"/bla/file\")\n            b''\n\n        Parameters\n        ----------\n        source : str\n            Existing filepath within the MFS\n        dest : str\n            Destination to which the file will be moved in the MFS\n        \"\"\"\n        args = (source, dest)\n        return self._client.request('/files/mv', args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a set of bytes as a file to IPFS.", "response": "def add_bytes(self, data, **kwargs):\n        \"\"\"Adds a set of bytes as a file to IPFS.\n\n        .. code-block:: python\n\n            >>> c.add_bytes(b\"Mary had a little lamb\")\n            'QmZfF6C9j4VtoCsTp4KSrhYH47QMd3DNXVZBKaxJdhaPab'\n\n        Also accepts and will stream generator objects.\n\n        Parameters\n        ----------\n        data : bytes\n            Content to be added as a file\n\n        Returns\n        -------\n            str : Hash of the added IPFS object\n        \"\"\"\n        body, headers = multipart.stream_bytes(data, self.chunk_size)\n        return self._client.request('/add', decoder='json',\n                                    data=body, headers=headers, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a string to the IPFS object.", "response": "def add_str(self, string, **kwargs):\n        \"\"\"Adds a Python string as a file to IPFS.\n\n        .. code-block:: python\n\n            >>> c.add_str(u\"Mary had a little lamb\")\n            'QmZfF6C9j4VtoCsTp4KSrhYH47QMd3DNXVZBKaxJdhaPab'\n\n        Also accepts and will stream generator objects.\n\n        Parameters\n        ----------\n        string : str\n            Content to be added as a file\n\n        Returns\n        -------\n            str : Hash of the added IPFS object\n        \"\"\"\n        body, headers = multipart.stream_text(string, self.chunk_size)\n        return self._client.request('/add', decoder='json',\n                                    data=body, headers=headers, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_json(self, json_obj, **kwargs):\n        return self.add_bytes(encoding.Json().encode(json_obj), **kwargs)", "response": "Adds a json - serializable Python dict as a json file to IPFS."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a picklable Python object as a file to IPFS.", "response": "def add_pyobj(self, py_obj, **kwargs):\n        \"\"\"Adds a picklable Python object as a file to IPFS.\n\n        .. deprecated:: 0.4.2\n           The ``*_pyobj`` APIs allow for arbitrary code execution if abused.\n           Either switch to :meth:`~ipfsapi.Client.add_json` or use\n           ``client.add_bytes(pickle.dumps(py_obj))`` instead.\n\n        Please see :meth:`~ipfsapi.Client.get_pyobj` for the\n        **security risks** of using these methods!\n\n        .. code-block:: python\n\n            >>> c.add_pyobj([0, 1.0, 2j, '3', 4e5])\n            'QmWgXZSUTNNDD8LdkdJ8UXSn55KfFnNvTP1r7SyaQd74Ji'\n\n        Parameters\n        ----------\n        py_obj : object\n            A picklable Python object\n\n        Returns\n        -------\n            str : Hash of the added IPFS object\n        \"\"\"\n        warnings.warn(\"Using `*_pyobj` on untrusted data is a security risk\",\n                      DeprecationWarning)\n        return self.add_bytes(encoding.Pickle().encode(py_obj), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a pickled Python object from the given multihash.", "response": "def get_pyobj(self, multihash, **kwargs):\n        \"\"\"Loads a pickled Python object from IPFS.\n\n        .. deprecated:: 0.4.2\n           The ``*_pyobj`` APIs allow for arbitrary code execution if abused.\n           Either switch to :meth:`~ipfsapi.Client.get_json` or use\n           ``pickle.loads(client.cat(multihash))`` instead.\n\n        .. caution::\n\n            The pickle module is not intended to be secure against erroneous or\n            maliciously constructed data. Never unpickle data received from an\n            untrusted or unauthenticated source.\n\n            Please **read**\n            `this article <https://www.cs.uic.edu/%7Es/musings/pickle/>`_ to\n            understand the security risks of using this method!\n\n        .. code-block:: python\n\n            >>> c.get_pyobj('QmWgXZSUTNNDD8LdkdJ8UXSn55KfFnNvTP1r7SyaQd74Ji')\n            [0, 1.0, 2j, '3', 400000.0]\n\n        Parameters\n        ----------\n        multihash : str\n            Multihash of the IPFS object to load\n\n        Returns\n        -------\n            object : Deserialized IPFS Python object\n        \"\"\"\n        warnings.warn(\"Using `*_pyobj` on untrusted data is a security risk\",\n                      DeprecationWarning)\n        return self.cat(multihash, decoder='pickle', **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pubsub_peers(self, topic=None, **kwargs):\n        args = (topic,) if topic is not None else ()\n        return self._client.request('/pubsub/peers', args,\n                                    decoder='json', **kwargs)", "response": "List the peers that are connected to a topic."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pubsub_pub(self, topic, payload, **kwargs):\n        args = (topic, payload)\n        return self._client.request('/pubsub/pub', args,\n                                    decoder='json', **kwargs)", "response": "Publish a message to a given pubsub topic"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pubsub_sub(self, topic, discover=False, **kwargs):\n        args = (topic, discover)\n        return SubChannel(self._client.request('/pubsub/sub', args,\n                          stream=True, decoder='json'))", "response": "Subscribe to a topic in IPFS."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nguessing the mimetype of a file based on the given filename.", "response": "def guess_mimetype(filename):\n    \"\"\"Guesses the mimetype of a file based on the given ``filename``.\n\n    .. code-block:: python\n\n        >>> guess_mimetype('example.txt')\n        'text/plain'\n        >>> guess_mimetype('/foo/bar/example')\n        'application/octet-stream'\n\n    Parameters\n    ----------\n    filename : str\n        The file name or path for which the mimetype is to be guessed\n    \"\"\"\n    fn = os.path.basename(filename)\n    return mimetypes.guess_type(fn)[0] or 'application/octet-stream'"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ls_dir(dirname):\n    ls = os.listdir(dirname)\n    files = [p for p in ls if os.path.isfile(os.path.join(dirname, p))]\n    dirs = [p for p in ls if os.path.isdir(os.path.join(dirname, p))]\n    return files, dirs", "response": "Returns the names of files and subdirectories within a given directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clean_files(files):\n    if isinstance(files, (list, tuple)):\n        for f in files:\n            yield clean_file(f)\n    else:\n        yield clean_file(files)", "response": "Generates tuples with a file - like object and a close indicator."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the size of a file in bytes.", "response": "def file_size(f):\n    \"\"\"Returns the size of a file in bytes.\n\n    Raises\n    ------\n    OSError : Accessing the given file path failed\n\n    Parameters\n    ----------\n    f : io.IOBase | str\n        The file path or object for which the size should be determined\n    \"\"\"\n    if isinstance(f, (six.string_types, six.text_type)):\n        return os.path.getsize(f)\n    else:\n        cur = f.tell()\n        f.seek(0, 2)\n        size = f.tell()\n        f.seek(cur)\n        return size"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new revision file.", "response": "def revision(directory, message, autogenerate, sql, head, splice, branch_label,\n             version_path, rev_id):\n    \"\"\"Create a new revision file.\"\"\"\n    _revision(directory, message, autogenerate, sql, head, splice,\n              branch_label, version_path, rev_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef migrate(directory, message, sql, head, splice, branch_label, version_path,\n            rev_id, x_arg):\n    \"\"\"Autogenerate a new revision file (Alias for 'revision --autogenerate')\"\"\"\n    _migrate(directory, message, sql, head, splice, branch_label, version_path,\n             rev_id, x_arg)", "response": "Migrate a new revision file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef merge(directory, message, branch_label, rev_id, revisions):\n    _merge(directory, revisions, message, branch_label, rev_id)", "response": "Merge two revisions together creating a new revision file"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupgrade to a later version", "response": "def upgrade(directory, sql, tag, x_arg, revision):\n    \"\"\"Upgrade to a later version\"\"\"\n    _upgrade(directory, revision, sql, tag, x_arg)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef downgrade(directory, sql, tag, x_arg, revision):\n    _downgrade(directory, revision, sql, tag, x_arg)", "response": "Revert to a previous version"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting changeset scripts in chronological order.", "response": "def history(directory, rev_range, verbose, indicate_current):\n    \"\"\"List changeset scripts in chronological order.\"\"\"\n    _history(directory, rev_range, verbose, indicate_current)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stamp(directory, sql, tag, revision):\n    _stamp(directory, revision, sql, tag)", "response": "stamp the revision table with the given revision"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns migrations in offline mode.", "response": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url, target_metadata=target_metadata, literal_binds=True\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_metadata(bind):\n    if bind == '':\n        bind = None\n    m = MetaData()\n    for t in target_metadata.tables.values():\n        if t.info.get('bind_key') == bind:\n            t.tometadata(m)\n    return m", "response": "Return the metadata for a bind."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_migrations_offline():\n    # for the --sql use case, run migrations for each URL into\n    # individual files.\n\n    engines = {\n        '': {\n            'url': context.config.get_main_option('sqlalchemy.url')\n        }\n    }\n    for name in bind_names:\n        engines[name] = rec = {}\n        rec['url'] = context.config.get_section_option(name, \"sqlalchemy.url\")\n\n    for name, rec in engines.items():\n        logger.info(\"Migrating database %s\" % (name or '<default>'))\n        file_ = \"%s.sql\" % name\n        logger.info(\"Writing output to %s\" % file_)\n        with open(file_, 'w') as buffer:\n            context.configure(\n                url=rec['url'],\n                output_buffer=buffer,\n                target_metadata=get_metadata(name),\n                literal_binds=True,\n            )\n            with context.begin_transaction():\n                context.run_migrations(engine_name=name)", "response": "Run migrations in offline mode."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun migrations in online mode.", "response": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n\n    # this callback is used to prevent an auto-migration from being generated\n    # when there are no changes to the schema\n    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html\n    def process_revision_directives(context, revision, directives):\n        if getattr(config.cmd_opts, 'autogenerate', False):\n            script = directives[0]\n            if len(script.upgrade_ops_list) >= len(bind_names) + 1:\n                empty = True\n                for upgrade_ops in script.upgrade_ops_list:\n                    if not upgrade_ops.is_empty():\n                        empty = False\n                if empty:\n                    directives[:] = []\n                    logger.info('No changes in schema detected.')\n\n    # for the direct-to-DB use case, start a transaction on all\n    # engines, then run all migrations, then commit all transactions.\n    engines = {\n        '': {\n            'engine': engine_from_config(\n                config.get_section(config.config_ini_section),\n                prefix='sqlalchemy.',\n                poolclass=pool.NullPool,\n            )\n        }\n    }\n    for name in bind_names:\n        engines[name] = rec = {}\n        rec['engine'] = engine_from_config(\n            context.config.get_section(name),\n            prefix='sqlalchemy.',\n            poolclass=pool.NullPool)\n\n    for name, rec in engines.items():\n        engine = rec['engine']\n        rec['connection'] = conn = engine.connect()\n\n        if USE_TWOPHASE:\n            rec['transaction'] = conn.begin_twophase()\n        else:\n            rec['transaction'] = conn.begin()\n\n    try:\n        for name, rec in engines.items():\n            logger.info(\"Migrating database %s\" % (name or '<default>'))\n            context.configure(\n                connection=rec['connection'],\n                upgrade_token=\"%s_upgrades\" % name,\n                downgrade_token=\"%s_downgrades\" % name,\n                target_metadata=get_metadata(name),\n                process_revision_directives=process_revision_directives,\n                **current_app.extensions['migrate'].configure_args\n            )\n            context.run_migrations(engine_name=name)\n\n        if USE_TWOPHASE:\n            for rec in engines.values():\n                rec['transaction'].prepare()\n\n        for rec in engines.values():\n            rec['transaction'].commit()\n    except:\n        for rec in engines.values():\n            rec['transaction'].rollback()\n        raise\n    finally:\n        for rec in engines.values():\n            rec['connection'].close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new migration repository", "response": "def init(directory=None, multidb=False):\n    \"\"\"Creates a new migration repository\"\"\"\n    if directory is None:\n        directory = current_app.extensions['migrate'].directory\n    config = Config()\n    config.set_main_option('script_location', directory)\n    config.config_file_name = os.path.join(directory, 'alembic.ini')\n    config = current_app.extensions['migrate'].\\\n        migrate.call_configure_callbacks(config)\n    if multidb:\n        command.init(config, directory, 'flask-multidb')\n    else:\n        command.init(config, directory, 'flask')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef revision(directory=None, message=None, autogenerate=False, sql=False,\n             head='head', splice=False, branch_label=None, version_path=None,\n             rev_id=None):\n    \"\"\"Create a new revision file.\"\"\"\n    config = current_app.extensions['migrate'].migrate.get_config(directory)\n    if alembic_version >= (0, 7, 0):\n        command.revision(config, message, autogenerate=autogenerate, sql=sql,\n                         head=head, splice=splice, branch_label=branch_label,\n                         version_path=version_path, rev_id=rev_id)\n    else:\n        command.revision(config, message, autogenerate=autogenerate, sql=sql)", "response": "Create a new revision file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef merge(directory=None, revisions='', message=None, branch_label=None,\n          rev_id=None):\n    \"\"\"Merge two revisions together.  Creates a new migration file\"\"\"\n    if alembic_version >= (0, 7, 0):\n        config = current_app.extensions['migrate'].migrate.get_config(\n            directory)\n        command.merge(config, revisions, message=message,\n                      branch_label=branch_label, rev_id=rev_id)\n    else:\n        raise RuntimeError('Alembic 0.7.0 or greater is required')", "response": "Merge two revisions together."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef upgrade(directory=None, revision='head', sql=False, tag=None, x_arg=None):\n    config = current_app.extensions['migrate'].migrate.get_config(directory,\n                                                                  x_arg=x_arg)\n    command.upgrade(config, revision, sql=sql, tag=tag)", "response": "Upgrade to a later version"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting changeset scripts in chronological order.", "response": "def history(directory=None, rev_range=None, verbose=False, indicate_current=False):\n    \"\"\"List changeset scripts in chronological order.\"\"\"\n    config = current_app.extensions['migrate'].migrate.get_config(directory)\n    if alembic_version >= (0, 9, 9):\n        command.history(config, rev_range, verbose=verbose, indicate_current=indicate_current)\n    elif alembic_version >= (0, 7, 0):\n        command.history(config, rev_range, verbose=verbose)\n    else:\n        command.history(config, rev_range)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshows current available heads in the script directory", "response": "def heads(directory=None, verbose=False, resolve_dependencies=False):\n    \"\"\"Show current available heads in the script directory\"\"\"\n    if alembic_version >= (0, 7, 0):\n        config = current_app.extensions['migrate'].migrate.get_config(\n            directory)\n        command.heads(config, verbose=verbose,\n                      resolve_dependencies=resolve_dependencies)\n    else:\n        raise RuntimeError('Alembic 0.7.0 or greater is required')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef branches(directory=None, verbose=False):\n    config = current_app.extensions['migrate'].migrate.get_config(directory)\n    if alembic_version >= (0, 7, 0):\n        command.branches(config, verbose=verbose)\n    else:\n        command.branches(config)", "response": "Show current branch points"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef current(directory=None, verbose=False, head_only=False):\n    config = current_app.extensions['migrate'].migrate.get_config(directory)\n    if alembic_version >= (0, 7, 0):\n        command.current(config, verbose=verbose, head_only=head_only)\n    else:\n        command.current(config)", "response": "Display the current revision for each database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stamp(directory=None, revision='head', sql=False, tag=None):\n    config = current_app.extensions['migrate'].migrate.get_config(directory)\n    command.stamp(config, revision, sql=sql, tag=tag)", "response": "stamp the revision table with the given revision ; don t run any\n    migrations"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _create_session(\n            self,\n            alias,\n            url,\n            headers,\n            cookies,\n            auth,\n            timeout,\n            max_retries,\n            backoff_factor,\n            proxies,\n            verify,\n            debug,\n            disable_warnings):\n        \"\"\" Create Session: create a HTTP session to a server\n\n        ``url`` Base url of the server\n\n        ``alias`` Robot Framework alias to identify the session\n\n        ``headers`` Dictionary of default headers\n\n        ``cookies`` Dictionary of cookies\n\n        ``auth`` List of username & password for HTTP Basic Auth\n\n        ``timeout`` Connection timeout\n\n        ``max_retries`` The maximum number of retries each connection should attempt.\n\n        ``backoff_factor`` The pause between for each retry\n\n        ``proxies`` Dictionary that contains proxy urls for HTTP and HTTPS communication\n\n        ``verify`` Whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n\n        ``debug`` Enable http verbosity option more information\n                https://docs.python.org/2/library/httplib.html#httplib.HTTPConnection.set_debuglevel\n\n        ``disable_warnings`` Disable requests warning useful when you have large number of testcases\n        \"\"\"\n\n        self.builtin.log('Creating session: %s' % alias, 'DEBUG')\n        s = session = requests.Session()\n        s.headers.update(headers)\n        s.auth = auth if auth else s.auth\n        s.proxies = proxies if proxies else s.proxies\n\n        try:\n            max_retries = int(max_retries)\n        except ValueError as err:\n            raise ValueError(\"Error converting max_retries parameter: %s\"   % err)\n\n        if max_retries > 0:\n            http = requests.adapters.HTTPAdapter(max_retries=Retry(total=max_retries, backoff_factor=backoff_factor))\n            https = requests.adapters.HTTPAdapter(max_retries=Retry(total=max_retries, backoff_factor=backoff_factor))\n\n            # Replace the session's original adapters\n            s.mount('http://', http)\n            s.mount('https://', https)\n\n        # Disable requests warnings, useful when you have large number of testcase\n        # you will observe drastical changes in Robot log.html and output.xml files size\n        if disable_warnings:\n            logging.basicConfig() # you need to initialize logging, otherwise you will not see anything from requests\n            logging.getLogger().setLevel(logging.ERROR)\n            requests_log = logging.getLogger(\"requests\")\n            requests_log.setLevel(logging.ERROR)\n            requests_log.propagate = True\n            if not verify:\n                requests.packages.urllib3.disable_warnings()\n\n        # verify can be a Boolean or a String\n        if isinstance(verify, bool):\n            s.verify = verify\n        elif isinstance(verify, str) or isinstance(verify, unicode):\n            if verify.lower() == 'true' or verify.lower() == 'false':\n                s.verify = self.builtin.convert_to_boolean(verify)\n            else:\n                # String for CA_BUNDLE, not a Boolean String\n                s.verify = verify\n        else:\n            # not a Boolean nor a String\n            s.verify = verify\n\n        # cant pass these into the Session anymore\n        self.timeout = float(timeout) if timeout is not None else None\n        self.cookies = cookies\n        self.verify = verify if self.builtin.convert_to_boolean(verify) != True else None\n\n        s.url = url\n\n        # Enable http verbosity\n        if int(debug) >= 1:\n            self.debug = int(debug)\n            httplib.HTTPConnection.debuglevel = self.debug\n\n        self._cache.register(session, alias=alias)\n        return session", "response": "Create a HTTP session to a server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_session(self, alias, url, headers={}, cookies={},\n                       auth=None, timeout=None, proxies=None,\n                       verify=False, debug=0, max_retries=3, backoff_factor=0.10, disable_warnings=0):\n        \"\"\" Create Session: create a HTTP session to a server\n\n        ``url`` Base url of the server\n\n        ``alias`` Robot Framework alias to identify the session\n\n        ``headers`` Dictionary of default headers\n\n        ``cookies`` Dictionary of cookies\n\n        ``auth`` List of username & password for HTTP Basic Auth\n\n        ``timeout`` Connection timeout\n\n        ``proxies`` Dictionary that contains proxy urls for HTTP and HTTPS communication\n\n        ``verify`` Whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n                 Defaults to False.\n\n        ``debug`` Enable http verbosity option more information\n                https://docs.python.org/2/library/httplib.html#httplib.HTTPConnection.set_debuglevel\n\n        ``max_retries`` The maximum number of retries each connection should attempt.\n\n        ``backoff_factor`` The pause between for each retry\n\n        ``disable_warnings`` Disable requests warning useful when you have large number of testcases\n        \"\"\"\n        auth = requests.auth.HTTPBasicAuth(*auth) if auth else None\n\n        logger.info('Creating Session using : alias=%s, url=%s, headers=%s, \\\n                    cookies=%s, auth=%s, timeout=%s, proxies=%s, verify=%s, \\\n                    debug=%s ' % (alias, url, headers, cookies, auth, timeout,\n                                  proxies, verify, debug))\n\n        return self._create_session(\n            alias,\n            url,\n            headers,\n            cookies,\n            auth,\n            timeout,\n            max_retries,\n            backoff_factor,\n            proxies,\n            verify,\n            debug,\n            disable_warnings)", "response": "Create a HTTP session to a server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a NTLM Session object.", "response": "def create_ntlm_session(\n            self,\n            alias,\n            url,\n            auth,\n            headers={},\n            cookies={},\n            timeout=None,\n            proxies=None,\n            verify=False,\n            debug=0,\n            max_retries=3,\n            backoff_factor=0.10,\n            disable_warnings=0):\n        \"\"\" Create Session: create a HTTP session to a server\n\n        ``url`` Base url of the server\n\n        ``alias`` Robot Framework alias to identify the session\n\n        ``headers`` Dictionary of default headers\n\n        ``cookies`` Dictionary of cookies\n\n        ``auth`` ['DOMAIN', 'username', 'password'] for NTLM Authentication\n\n        ``timeout`` Connection timeout\n\n        ``proxies`` Dictionary that contains proxy urls for HTTP and HTTPS communication\n\n        ``verify`` Whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n                 Defaults to False.\n\n        ``debug`` Enable http verbosity option more information\n                https://docs.python.org/2/library/httplib.html#httplib.HTTPConnection.set_debuglevel\n\n        ``max_retries`` The maximum number of retries each connection should attempt.\n\n        ``backoff_factor`` The pause between for each retry\n\n        ``disable_warnings`` Disable requests warning useful when you have large number of testcases\n        \"\"\"\n        if not HttpNtlmAuth:\n            raise AssertionError('Requests NTLM module not loaded')\n        elif len(auth) != 3:\n            raise AssertionError('Incorrect number of authentication arguments'\n                                 ' - expected 3, got {}'.format(len(auth)))\n        else:\n            ntlm_auth = HttpNtlmAuth('{}\\\\{}'.format(auth[0], auth[1]),\n                                     auth[2])\n            logger.info('Creating NTLM Session using : alias=%s, url=%s, \\\n                        headers=%s, cookies=%s, ntlm_auth=%s, timeout=%s, \\\n                        proxies=%s, verify=%s, debug=%s '\n                        % (alias, url, headers, cookies, ntlm_auth,\n                           timeout, proxies, verify, debug))\n\n            return self._create_session(\n                alias,\n                url,\n                headers,\n                cookies,\n                ntlm_auth,\n                timeout,\n                max_retries,\n                backoff_factor,\n                proxies,\n                verify,\n                debug,\n                disable_warnings)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a Digest Session", "response": "def create_digest_session(self, alias, url, auth, headers={}, cookies={},\n                              timeout=None, proxies=None, verify=False,\n                              debug=0, max_retries=3,backoff_factor=0.10, disable_warnings=0):\n        \"\"\" Create Session: create a HTTP session to a server\n\n        ``url`` Base url of the server\n\n        ``alias`` Robot Framework alias to identify the session\n\n        ``headers`` Dictionary of default headers\n\n        ``cookies`` Dictionary of cookies\n\n        ``auth`` ['DOMAIN', 'username', 'password'] for NTLM Authentication\n\n        ``timeout`` Connection timeout\n\n        ``proxies`` Dictionary that contains proxy urls for HTTP and HTTPS communication\n\n        ``verify`` Whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n                 Defaults to False.\n\n        ``debug`` Enable http verbosity option more information\n                https://docs.python.org/2/library/httplib.html#httplib.HTTPConnection.set_debuglevel\n\n        ``max_retries`` The maximum number of retries each connection should attempt.\n\n        ``backoff_factor`` The pause between for each retry\n\n        ``disable_warnings`` Disable requests warning useful when you have large number of testcases\n        \"\"\"\n        digest_auth = requests.auth.HTTPDigestAuth(*auth) if auth else None\n\n        return self._create_session(\n            alias,\n            url,\n            headers,\n            cookies,\n            digest_auth,\n            timeout,\n            max_retries,\n            backoff_factor,\n            proxies,\n            verify,\n            debug,\n            disable_warnings)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_client_cert_session(self, alias, url, headers={}, cookies={},\n                       client_certs=None, timeout=None, proxies=None,\n                       verify=False, debug=0, max_retries=3, backoff_factor=0.10, disable_warnings=0):\n        \"\"\" Create Session: create a HTTP session to a server\n\n        ``url`` Base url of the server\n\n        ``alias`` Robot Framework alias to identify the session\n\n        ``headers`` Dictionary of default headers\n\n        ``cookies`` Dictionary of cookies\n\n        ``client_certs`` ['client certificate', 'client key'] PEM files containing the client key and certificate\n\n        ``timeout`` Connection timeout\n\n        ``proxies`` Dictionary that contains proxy urls for HTTP and HTTPS communication\n\n        ``verify`` Whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n                 Defaults to False.\n\n        ``debug`` Enable http verbosity option more information\n                https://docs.python.org/2/library/httplib.html#httplib.HTTPConnection.set_debuglevel\n\n        ``max_retries`` The maximum number of retries each connection should attempt.\n\n        ``backoff_factor`` The pause between for each retry\n\n        ``disable_warnings`` Disable requests warning useful when you have large number of testcases\n        \"\"\"\n\n        logger.info('Creating Session using : alias=%s, url=%s, headers=%s, \\\n                    cookies=%s, client_certs=%s, timeout=%s, proxies=%s, verify=%s, \\\n                    debug=%s ' % (alias, url, headers, cookies, client_certs, timeout,\n                                  proxies, verify, debug))\n\n        session = self._create_session(\n            alias,\n            url,\n            headers,\n            cookies,\n            None,\n            timeout,\n            max_retries,\n            backoff_factor,\n            proxies,\n            verify,\n            debug,\n            disable_warnings)\n\n        session.cert = tuple(client_certs)\n        return session", "response": "Create a HTTP session to a server with a client certificate."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating a HTTP Session Headers dictionary with the given headers and cookies", "response": "def update_session(self, alias, headers=None, cookies=None):\n        \"\"\"Update Session Headers: update a HTTP Session Headers\n\n        ``alias`` Robot Framework alias to identify the session\n\n        ``headers`` Dictionary of headers merge into session\n        \"\"\"\n        session = self._cache.switch(alias)\n        session.headers = merge_setting(headers, session.headers)\n        session.cookies = merge_cookies(session.cookies, cookies)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_json(self, content, pretty_print=False):\n        if PY3:\n            if isinstance(content, bytes):\n                content = content.decode(encoding='utf-8')\n        if pretty_print:\n            json_ = self._json_pretty_print(content)\n        else:\n            json_ = json.loads(content)\n        logger.info('To JSON using : content=%s ' % (content))\n        logger.info('To JSON using : pretty_print=%s ' % (pretty_print))\n\n        return json_", "response": "Convert a string to a JSON object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a GET request to the cache object found using the given alias uri headers and json data.", "response": "def get_request(\n            self,\n            alias,\n            uri,\n            headers=None,\n            json=None,\n            params=None,\n            allow_redirects=None,\n            timeout=None):\n        \"\"\" Send a GET request on the session object found using the\n        given `alias`\n\n        ``alias`` that will be used to identify the Session object in the cache\n\n        ``uri`` to send the GET request to\n\n        ``params`` url parameters to append to the uri\n\n        ``headers`` a dictionary of headers to use with the request\n\n        ``json`` json data to send in the body of the :class:`Request`.\n\n        ``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n        ``timeout`` connection timeout\n        \"\"\"\n        session = self._cache.switch(alias)\n        redir = True if allow_redirects is None else allow_redirects\n\n        response = self._get_request(\n            session, uri, params, headers, json, redir, timeout)\n\n        logger.info(\n            'Get Request using : alias=%s, uri=%s, headers=%s json=%s' %\n            (alias, uri, headers, json))\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a POST request to the server.", "response": "def post_request(\n            self,\n            alias,\n            uri,\n            data=None,\n            json=None,\n            params=None,\n            headers=None,\n            files=None,\n            allow_redirects=None,\n            timeout=None):\n        \"\"\" Send a POST request on the session object found using the\n        given `alias`\n\n        ``alias`` that will be used to identify the Session object in the cache\n\n        ``uri`` to send the POST request to\n\n        ``data`` a dictionary of key-value pairs that will be urlencoded\n               and sent as POST data\n               or binary data that is sent as the raw body content\n               or passed as such for multipart form data if ``files`` is also\n                  defined\n\n        ``json`` a value that will be json encoded\n               and sent as POST data if files or data is not specified\n\n        ``params`` url parameters to append to the uri\n\n        ``headers`` a dictionary of headers to use with the request\n\n        ``files`` a dictionary of file names containing file data to POST to the server\n\n        ``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n        ``timeout`` connection timeout\n        \"\"\"\n        session = self._cache.switch(alias)\n        if not files:\n            data = self._format_data_according_to_header(session, data, headers)\n        redir = True if allow_redirects is None else allow_redirects\n\n        response = self._body_request(\n            \"post\",\n            session,\n            uri,\n            data,\n            json,\n            params,\n            files,\n            headers,\n            redir,\n            timeout)\n        dataStr = self._format_data_to_log_string_according_to_header(data, headers)\n        logger.info('Post Request using : alias=%s, uri=%s, data=%s, headers=%s, files=%s, allow_redirects=%s '\n                    % (alias, uri, dataStr, headers, files, redir))\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a PUT request to the cache object found using the given alias.", "response": "def put(\n            self,\n            alias,\n            uri,\n            data=None,\n            headers=None,\n            allow_redirects=None,\n            timeout=None):\n        \"\"\" **Deprecated- See Put Request now**\n\n        Send a PUT request on the session object found using the\n        given `alias`\n\n        ``alias`` that will be used to identify the Session object in the cache\n\n        ``uri`` to send the PUT request to\n\n        ``headers`` a dictionary of headers to use with the request\n\n        ``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n        ``timeout`` connection timeout\n        \"\"\"\n        logger.warn(\"Deprecation Warning: Use Put Request in the future\")\n        session = self._cache.switch(alias)\n        data = self._utf8_urlencode(data)\n        redir = True if allow_redirects is None else allow_redirects\n\n        response = self._body_request(\n            \"put\",\n            session,\n            uri,\n            data,\n            None,\n            None,\n            None,\n            headers,\n            redir,\n            timeout)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_request(\n            self,\n            alias,\n            uri,\n            data=None,\n            json=None,\n            params=None,\n            headers=None,\n            allow_redirects=None,\n            timeout=None):\n        \"\"\" Send a DELETE request on the session object found using the\n        given `alias`\n\n        ``alias`` that will be used to identify the Session object in the cache\n\n        ``uri`` to send the DELETE request to\n\n        ``json`` a value that will be json encoded\n               and sent as request data if data is not specified\n\n        ``headers`` a dictionary of headers to use with the request\n\n        ``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n        ``timeout`` connection timeout\n        \"\"\"\n        session = self._cache.switch(alias)\n        data = self._format_data_according_to_header(session, data, headers)\n        redir = True if allow_redirects is None else allow_redirects\n\n        response = self._delete_request(\n            session, uri, data, json, params, headers, redir, timeout)\n\n        if isinstance(data, bytes):\n            data = data.decode('utf-8')\n        logger.info('Delete Request using : alias=%s, uri=%s, data=%s, \\\n                    headers=%s, allow_redirects=%s ' % (alias, uri, data, headers, redir))\n\n        return response", "response": "Send a DELETE request to the cache object found using the given alias."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete(\n            self,\n            alias,\n            uri,\n            data=(),\n            headers=None,\n            allow_redirects=None,\n            timeout=None):\n        \"\"\" * * *   Deprecated- See Delete Request now   * * *\n\n        Send a DELETE request on the session object found using the\n        given `alias`\n\n        ``alias`` that will be used to identify the Session object in the cache\n\n        ``uri`` to send the DELETE request to\n\n        ``headers`` a dictionary of headers to use with the request\n\n        ``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n        ``timeout`` connection timeout\n        \"\"\"\n        logger.warn(\"Deprecation Warning: Use Delete Request in the future\")\n        session = self._cache.switch(alias)\n        data = self._utf8_urlencode(data)\n        redir = True if allow_redirects is None else allow_redirects\n\n        response = self._delete_request(\n            session, uri, data, json, None, headers, redir, timeout)\n\n        return response", "response": "Send a DELETE request to the cache object identified by alias."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a HEAD request to the cache object found using the given alias and uri.", "response": "def head_request(\n            self,\n            alias,\n            uri,\n            headers=None,\n            allow_redirects=None,\n            timeout=None):\n        \"\"\" Send a HEAD request on the session object found using the\n        given `alias`\n\n        ``alias`` that will be used to identify the Session object in the cache\n\n        ``uri`` to send the HEAD request to\n\n        ``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n        ``headers`` a dictionary of headers to use with the request\n        \"\"\"\n        session = self._cache.switch(alias)\n        redir = False if allow_redirects is None else allow_redirects\n        response = self._head_request(session, uri, headers, redir, timeout)\n        logger.info('Head Request using : alias=%s, uri=%s, headers=%s, \\\n        allow_redirects=%s ' % (alias, uri, headers, redir))\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef head(\n            self,\n            alias,\n            uri,\n            headers=None,\n            allow_redirects=None,\n            timeout=None):\n        \"\"\" **Deprecated- See Head Request now**\n\n        Send a HEAD request on the session object found using the\n        given `alias`\n\n        ``alias`` that will be used to identify the Session object in the cache\n\n        ``uri`` to send the HEAD request to\n\n        ``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n        ``headers`` a dictionary of headers to use with the request\n        \"\"\"\n        logger.warn(\"Deprecation Warning: Use Head Request in the future\")\n        session = self._cache.switch(alias)\n        redir = False if allow_redirects is None else allow_redirects\n        response = self._head_request(session, uri, headers, redir, timeout)\n\n        return response", "response": "Send a HEAD request to the cache object identified by the given alias."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef options_request(\n            self,\n            alias,\n            uri,\n            headers=None,\n            allow_redirects=None,\n            timeout=None):\n        \"\"\" Send an OPTIONS request on the session object found using the\n        given `alias`\n\n        ``alias`` that will be used to identify the Session object in the cache\n\n        ``uri`` to send the OPTIONS request to\n\n        ``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n        ``headers`` a dictionary of headers to use with the request\n        \"\"\"\n        session = self._cache.switch(alias)\n        redir = True if allow_redirects is None else allow_redirects\n        response = self._options_request(session, uri, headers, redir, timeout)\n        logger.info(\n            'Options Request using : alias=%s, uri=%s, headers=%s, allow_redirects=%s ' %\n            (alias, uri, headers, redir))\n\n        return response", "response": "Send an OPTIONS request to the cache object found using the given alias."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend an OPTIONS request to the cache object identified by the given alias.", "response": "def options(\n            self,\n            alias,\n            uri,\n            headers=None,\n            allow_redirects=None,\n            timeout=None):\n        \"\"\" **Deprecated- See Options Request now**\n\n        Send an OPTIONS request on the session object found using the\n        given `alias`\n\n        ``alias`` that will be used to identify the Session object in the cache\n\n        ``uri`` to send the OPTIONS request to\n\n        ``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n        ``headers`` a dictionary of headers to use with the request\n        \"\"\"\n        logger.warn(\"Deprecation Warning: Use Options Request in the future\")\n        session = self._cache.switch(alias)\n        redir = True if allow_redirects is None else allow_redirects\n        response = self._options_request(session, uri, headers, redir, timeout)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_url(self, session, uri):\n        url = session.url\n        if uri:\n            slash = '' if uri.startswith('/') else '/'\n            url = \"%s%s%s\" % (session.url, slash, uri)\n        return url", "response": "Helper method to get the full url of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _json_pretty_print(self, content):\n        temp = json.loads(content)\n        return json.dumps(\n            temp,\n            sort_keys=True,\n            indent=4,\n            separators=(\n                ',',\n                ': '))", "response": "Pretty print a JSON object to pretty print\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_measurements(\n        self, measurement='Weight', lower_bound=None, upper_bound=None\n    ):\n        \"\"\" Returns measurements of a given name between two dates.\"\"\"\n        if upper_bound is None:\n            upper_bound = datetime.date.today()\n        if lower_bound is None:\n            lower_bound = upper_bound - datetime.timedelta(days=30)\n\n        # If they entered the dates in the opposite order, let's\n        # just flip them around for them as a convenience\n        if lower_bound > upper_bound:\n            lower_bound, upper_bound = upper_bound, lower_bound\n\n        # get the URL for the main check in page\n        document = self._get_document_for_url(\n            self._get_url_for_measurements()\n        )\n\n        # gather the IDs for all measurement types\n        measurement_ids = self._get_measurement_ids(document)\n\n        # select the measurement ID based on the input\n        if measurement in measurement_ids.keys():\n            measurement_id = measurement_ids[measurement]\n        else:\n            raise ValueError(\n                \"Measurement '%s' does not exist.\" % measurement\n            )\n\n        page = 1\n        measurements = OrderedDict()\n\n        # retrieve entries until finished\n        while True:\n            # retrieve the HTML from MyFitnessPal\n            document = self._get_document_for_url(\n                self._get_url_for_measurements(page, measurement_id)\n            )\n\n            # parse the HTML for measurement entries and add to dictionary\n            results = self._get_measurements(document)\n            measurements.update(results)\n\n            # stop if there are no more entries\n            if len(results) == 0:\n                break\n\n            # continue if the lower bound has not been reached\n            elif list(results.keys())[-1] > lower_bound:\n                page += 1\n                continue\n\n            # otherwise stop\n            else:\n                break\n\n        # remove entries that are not within the dates specified\n        for date in list(measurements.keys()):\n            if not upper_bound >= date >= lower_bound:\n                del measurements[date]\n\n        return measurements", "response": "Returns a dictionary of all the measurements of a given name between two dates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the value of the measurement for today s date.", "response": "def set_measurements(\n        self, measurement='Weight', value=None\n    ):\n        \"\"\" Sets measurement for today's date.\"\"\"\n        if value is None:\n            raise ValueError(\n                \"Cannot update blank value.\"\n            )\n\n        # get the URL for the main check in page\n        # this is left in because we need to parse\n        # the 'measurement' name to set the value.\n        document = self._get_document_for_url(\n            self._get_url_for_measurements()\n        )\n\n        # gather the IDs for all measurement types\n        measurement_ids = self._get_measurement_ids(document)\n\n        # check if the measurement exists before going too far\n        if measurement not in measurement_ids.keys():\n            raise ValueError(\n                \"Measurement '%s' does not exist.\" % measurement\n            )\n\n        # build the update url.\n        update_url = parse.urljoin(\n                    self.BASE_URL,\n                    'measurements/save'\n        )\n\n        # setup a dict for the post\n        data = {}\n\n        # here's where we need that required element\n        data['authenticity_token'] = self._authenticity_token\n\n        # Weight has it's own key value pair\n        if measurement == 'Weight':\n            data['weight[display_value]'] = value\n\n        # the other measurements have generic names with\n        # an incrementing numeric index.\n        measurement_index = 0\n\n        # iterate all the measurement_ids\n        for measurement_id in measurement_ids.keys():\n            # create the measurement_type[n]\n            # key value pair\n            n = str(measurement_index)\n            meas_type = 'measurement_type[' + n + ']'\n            meas_val = 'measurement_value[' + n + ']'\n\n            data[meas_type] = measurement_ids[measurement_id]\n\n            # and if it corresponds to the value we want to update\n            if measurement == measurement_id:\n                # create the measurement_value[n]\n                # key value pair and assign it the value.\n                data[meas_val] = value\n            else:\n                # otherwise, create the key value pair and leave it blank\n                data[meas_val] = \"\"\n\n            measurement_index += 1\n\n        # now post it.\n        result = self.session.post(\n            update_url,\n            data=data\n        )\n\n        # throw an error if it failed.\n        if not result.ok:\n            raise RuntimeError(\n                \"Unable to update measurement in MyFitnessPal: \"\n                \"status code: {status}\".format(\n                    status=result.status_code\n                )\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn list of measurement choices.", "response": "def get_measurement_id_options(self):\n        \"\"\" Returns list of measurement choices.\"\"\"\n        # get the URL for the main check in page\n        document = self._get_document_for_url(\n            self._get_url_for_measurements()\n        )\n\n        # gather the IDs for all measurement types\n        measurement_ids = self._get_measurement_ids(document)\n        return measurement_ids"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if the running system s terminal supports color.", "response": "def file_supports_color(file_obj):\n    \"\"\"\n    Returns True if the running system's terminal supports color.\n\n    Borrowed from Django\n    https://github.com/django/django/blob/master/django/core/management/color.py\n    \"\"\"\n    plat = sys.platform\n    supported_platform = plat != 'Pocket PC' and (plat != 'win32' or\n                                                  'ANSICON' in os.environ)\n\n    is_a_tty = file_is_a_tty(file_obj)\n\n    return (supported_platform and is_a_tty)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_report(identifier=None):\n    '''\n    Returns the session referred to by identifier\n    '''\n    path = os.path.join(\n        report_dir(),\n        identifier + '.pyireport'\n    )\n    return ProfilerSession.load(path)", "response": "Returns the session referred to by identifier"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_report(session):\n    '''\n    Saves the session to a temp file, and returns that path.\n    Also prunes the number of reports to 10 so there aren't loads building up.\n    '''\n    # prune this folder to contain the last 10 sessions\n    previous_reports = glob.glob(os.path.join(report_dir(), '*.pyireport'))\n    previous_reports.sort(reverse=True)\n    while len(previous_reports) > 10:\n        report_file = previous_reports.pop()\n        os.remove(report_file)\n\n    identifier = time.strftime('%Y-%m-%dT%H-%M-%S', time.localtime(session.start_time))\n\n    path = os.path.join(\n        report_dir(),\n        identifier + '.pyireport'\n    )\n    session.save(path)\n    return path, identifier", "response": "Saves the session to a temp file and returns that path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_first_pyinstrument_frame_processor(frame, options):\n    '''\n    The first frame when using the command line is always the __main__ function. I want to remove\n    that from the output.\n    '''\n    if frame is None:\n        return None\n\n    if 'pyinstrument' in frame.file_path and len(frame.children) == 1:\n        frame = frame.children[0]\n        frame.remove_from_parent()\n        return frame\n\n    return frame", "response": "Remove the first pyinstrument frame processor."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the internal frame records and returns a tree of Frame objects.", "response": "def root_frame(self, trim_stem=True):\n        ''' \n        Parses the internal frame records and returns a tree of Frame objects\n        '''\n        root_frame = None\n\n        frame_stack = []\n\n        for frame_tuple in self.frame_records:\n            identifier_stack = frame_tuple[0]\n            time = frame_tuple[1]\n\n            # now we must create a stack of frame objects and assign this time to the leaf\n            for stack_depth, frame_identifier in enumerate(identifier_stack):\n                if stack_depth < len(frame_stack):\n                    if frame_identifier != frame_stack[stack_depth].identifier:\n                        # trim any frames after and including this one\n                        del frame_stack[stack_depth:]\n\n                if stack_depth >= len(frame_stack):\n                    frame = Frame(frame_identifier)\n                    frame_stack.append(frame)\n                    \n                    if stack_depth == 0:\n                        # There should only be one root frame, as far as I know\n                        assert root_frame is None, ASSERTION_MESSAGE\n                        root_frame = frame\n                    else:\n                        parent = frame_stack[stack_depth-1]\n                        parent.add_child(frame)\n\n            # trim any extra frames\n            del frame_stack[stack_depth+1:]  # pylint: disable=W0631\n\n            # assign the time to the final frame\n            frame_stack[-1].add_child(SelfTimeFrame(self_time=time))\n        \n        if root_frame is None:\n            return None\n        \n        if trim_stem:\n            root_frame = self._trim_stem(root_frame)\n        \n        return root_frame"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving this frame from its parent and nulls the parent link", "response": "def remove_from_parent(self):\n        '''\n        Removes this frame from its parent, and nulls the parent link\n        '''\n        if self.parent:\n            self.parent._children.remove(self)\n            self.parent._invalidate_time_caches()\n            self.parent = None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef total_self_time(self):\n        '''\n        The total amount of self time in this frame (including self time recorded by SelfTimeFrame\n        children)\n        '''\n        self_time = self.self_time\n        for child in self.children:\n            if isinstance(child, SelfTimeFrame):\n                self_time += child.self_time\n        return self_time", "response": "Returns the total amount of self time in this frame including self time recorded by children."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_child(self, frame, after=None):\n        '''\n        Adds a child frame, updating the parent link.\n        Optionally, insert the frame in a specific position by passing the frame to insert\n        this one after.\n        '''\n        frame.remove_from_parent()\n        frame.parent = self\n        if after is None:\n            self._children.append(frame)\n        else:\n            index = self._children.index(after) + 1\n            self._children.insert(index, frame)\n\n        self._invalidate_time_caches()", "response": "Adds a child frame to the link."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef file_path_short(self):\n        if not hasattr(self, '_file_path_short'):\n            if self.file_path:\n                result = None\n\n                for path in sys.path:\n                    # On Windows, if self.file_path and path are on different drives, relpath\n                    # will result in exception, because it cannot compute a relpath in this case.\n                    # The root cause is that on Windows, there is no root dir like '/' on Linux.\n                    try:\n                        candidate = os.path.relpath(self.file_path, path)\n                    except ValueError:\n                        continue\n\n                    if not result or (len(candidate.split(os.sep)) < len(result.split(os.sep))):\n                        result = candidate\n\n                self._file_path_short = result\n            else:\n                self._file_path_short = None\n\n        return self._file_path_short", "response": "Return the path resolved against the closest entry in sys. path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef exit_frames(self):\n        '''\n        Returns a list of frames whose children include a frame outside of the group\n        '''\n        if self._exit_frames is None:\n            exit_frames = []\n            for frame in self.frames:\n                if any(c.group != self for c in frame.children):\n                    exit_frames.append(frame)\n            self._exit_frames = exit_frames\n\n        return self._exit_frames", "response": "Returns a list of frames whose children include a frame outside of the group\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef first_interesting_frame(self):\n        root_frame = self.root_frame()\n        frame = root_frame\n\n        while len(frame.children) <= 1:\n            if frame.children:\n                frame = frame.children[0]\n            else:\n                # there are no branches\n                return root_frame\n\n        return frame", "response": "Traverse down the frame hierarchy until a frame with more than one child\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a timeline into a time - aggregate summary.", "response": "def aggregate_repeated_calls(frame, options):\n    '''\n    Converts a timeline into a time-aggregate summary.\n\n    Adds together calls along the same call stack, so that repeated calls appear as the same\n    frame. Removes time-linearity - frames are sorted according to total time spent.\n\n    Useful for outputs that display a summary of execution (e.g. text and html outputs)\n    '''\n    if frame is None:\n        return None\n\n    children_by_identifier = {}\n\n    # iterate over a copy of the children since it's going to mutate while we're iterating\n    for child in frame.children:\n        if child.identifier in children_by_identifier:\n            aggregate_frame = children_by_identifier[child.identifier]\n\n            # combine the two frames, putting the children and self_time into the aggregate frame.\n            aggregate_frame.self_time += child.self_time\n            if child.children:\n                aggregate_frame.add_children(child.children)\n\n            # remove this frame, it's been incorporated into aggregate_frame\n            child.remove_from_parent()\n        else:\n            # never seen this identifier before. It becomes the aggregate frame.\n            children_by_identifier[child.identifier] = child\n\n    # recurse into the children\n    for child in frame.children:\n        aggregate_repeated_calls(child, options=options)\n\n    # sort the children by time\n    # it's okay to use the internal _children list, sinde we're not changing the tree\n    # structure.\n    frame._children.sort(key=methodcaller('time'), reverse=True)  # pylint: disable=W0212\n\n    return frame"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncombine consecutive self time frames into one.", "response": "def merge_consecutive_self_time(frame, options):\n    '''\n    Combines consecutive 'self time' frames\n    '''\n    if frame is None:\n        return None\n\n    previous_self_time_frame = None\n\n    for child in frame.children:\n        if isinstance(child, SelfTimeFrame):\n            if previous_self_time_frame:\n                # merge\n                previous_self_time_frame.self_time += child.self_time\n                child.remove_from_parent()\n            else:\n                # keep a reference, maybe it'll be added to on the next loop\n                previous_self_time_frame = child\n        else:\n            previous_self_time_frame = None\n    \n    for child in frame.children:\n        merge_consecutive_self_time(child, options=options)\n    \n    return frame"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_unnecessary_self_time_nodes(frame, options):\n    '''\n    When a frame has only one child, and that is a self-time frame, remove that node, since it's\n    unnecessary - it clutters the output and offers no additional information.\n    '''\n    if frame is None:\n        return None\n\n    if len(frame.children) == 1 and isinstance(frame.children[0], SelfTimeFrame):\n        child = frame.children[0]\n        frame.self_time += child.self_time\n        child.remove_from_parent()\n    \n    for child in frame.children:\n        remove_unnecessary_self_time_nodes(child, options=options)\n    \n    return frame", "response": "Removes unnecessary self - time nodes from a frame."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving nodes that represent less than e. g. 1% of the output", "response": "def remove_irrelevant_nodes(frame, options, total_time=None):\n    '''\n    Remove nodes that represent less than e.g. 1% of the output\n    '''\n    if frame is None:\n        return None\n    \n    if total_time is None:\n        total_time = frame.time()\n\n    filter_threshold = options.get('filter_threshold', 0.01)\n\n    for child in frame.children:\n        proportion_of_total = child.time() / total_time\n\n        if proportion_of_total < filter_threshold:\n            frame.self_time += child.time()\n            child.remove_from_parent()\n        \n    for child in frame.children:\n        remove_irrelevant_nodes(child, options=options, total_time=total_time)\n\n    return frame"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndecorate a function using a caller.", "response": "def decorate(func, caller, extras=()):\n    \"\"\"\n    decorate(func, caller) decorates a function using a caller.\n    \"\"\"\n    evaldict = dict(_call_=caller, _func_=func)\n    es = ''\n    for i, extra in enumerate(extras):\n        ex = '_e%d_' % i\n        evaldict[ex] = extra\n        es += ex + ', '\n    fun = FunctionMaker.create(\n        func, \"return _call_(_func_, %s%%(shortsignature)s)\" % es,\n        evaldict, __wrapped__=func)\n    if hasattr(func, '__qualname__'):\n        fun.__qualname__ = func.__qualname__\n    return fun"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dispatch_on(*dispatch_args):\n    assert dispatch_args, 'No dispatch args passed'\n    dispatch_str = '(%s,)' % ', '.join(dispatch_args)\n\n    def check(arguments, wrong=operator.ne, msg=''):\n        \"\"\"Make sure one passes the expected number of arguments\"\"\"\n        if wrong(len(arguments), len(dispatch_args)):\n            raise TypeError('Expected %d arguments, got %d%s' %\n                            (len(dispatch_args), len(arguments), msg))\n\n    def gen_func_dec(func):\n        \"\"\"Decorator turning a function into a generic function\"\"\"\n\n        # first check the dispatch arguments\n        argset = set(getfullargspec(func).args)\n        if not set(dispatch_args) <= argset:\n            raise NameError('Unknown dispatch arguments %s' % dispatch_str)\n\n        typemap = {}\n\n        def vancestors(*types):\n            \"\"\"\n            Get a list of sets of virtual ancestors for the given types\n            \"\"\"\n            check(types)\n            ras = [[] for _ in range(len(dispatch_args))]\n            for types_ in typemap:\n                for t, type_, ra in zip(types, types_, ras):\n                    if issubclass(t, type_) and type_ not in t.mro():\n                        append(type_, ra)\n            return [set(ra) for ra in ras]\n\n        def ancestors(*types):\n            \"\"\"\n            Get a list of virtual MROs, one for each type\n            \"\"\"\n            check(types)\n            lists = []\n            for t, vas in zip(types, vancestors(*types)):\n                n_vas = len(vas)\n                if n_vas > 1:\n                    raise RuntimeError(\n                        'Ambiguous dispatch for %s: %s' % (t, vas))\n                elif n_vas == 1:\n                    va, = vas\n                    mro = type('t', (t, va), {}).mro()[1:]\n                else:\n                    mro = t.mro()\n                lists.append(mro[:-1])  # discard t and object\n            return lists\n\n        def register(*types):\n            \"\"\"\n            Decorator to register an implementation for the given types\n            \"\"\"\n            check(types)\n\n            def dec(f):\n                check(getfullargspec(f).args, operator.lt, ' in ' + f.__name__)\n                typemap[types] = f\n                return f\n            return dec\n\n        def dispatch_info(*types):\n            \"\"\"\n            An utility to introspect the dispatch algorithm\n            \"\"\"\n            check(types)\n            lst = []\n            for anc in itertools.product(*ancestors(*types)):\n                lst.append(tuple(a.__name__ for a in anc))\n            return lst\n\n        def _dispatch(dispatch_args, *args, **kw):\n            types = tuple(type(arg) for arg in dispatch_args)\n            try:  # fast path\n                f = typemap[types]\n            except KeyError:\n                pass\n            else:\n                return f(*args, **kw)\n            combinations = itertools.product(*ancestors(*types))\n            next(combinations)  # the first one has been already tried\n            for types_ in combinations:\n                f = typemap.get(types_)\n                if f is not None:\n                    return f(*args, **kw)\n\n            # else call the default implementation\n            return func(*args, **kw)\n\n        return FunctionMaker.create(\n            func, 'return _f_(%s, %%(shortsignature)s)' % dispatch_str,\n            dict(_f_=_dispatch), register=register, default=func,\n            typemap=typemap, vancestors=vancestors, ancestors=ancestors,\n            dispatch_info=dispatch_info, __wrapped__=func)\n\n    gen_func_dec.__name__ = 'dispatch_on' + dispatch_str\n    return gen_func_dec", "response": "Decorator that returns a function that dispatches on the given arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_in_browser(self, session, output_filename=None):\n        if output_filename is None:\n            output_file = tempfile.NamedTemporaryFile(suffix='.html', delete=False)\n            output_filename = output_file.name\n            with codecs.getwriter('utf-8')(output_file) as f:\n                f.write(self.render(session))\n        else:\n            with codecs.open(output_filename, 'w', 'utf-8') as f:\n                f.write(self.render(session))\n\n        from pyinstrument.vendor.six.moves import urllib\n        url = urllib.parse.urlunparse(('file', '', output_filename, '', '', ''))\n        webbrowser.open(url)\n        return output_filename", "response": "Open the rendered HTML in a webbrowser."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self):\n        '''compile the JS, then run superclass implementation'''\n\n        if subprocess.call(['npm', '--version']) != 0:\n            raise RuntimeError('npm is required to build the HTML renderer.')\n\n        self.check_call(['npm', 'install'], cwd=HTML_RENDERER_DIR)\n        self.check_call(['npm', 'run', 'build'], cwd=HTML_RENDERER_DIR)\n\n        self.copy_file(HTML_RENDERER_DIR+'/dist/js/app.js', 'pyinstrument/renderers/html_resources/app.js')\n\n        setuptools.command.build_py.build_py.run(self)", "response": "compile the JS then run superclass implementation"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deprecated(func, *args, **kwargs):\n    ''' Marks a function as deprecated. '''\n    warnings.warn(\n        '{} is deprecated and should no longer be used.'.format(func),\n        DeprecationWarning,\n        stacklevel=3\n    )\n    return func(*args, **kwargs)", "response": "Mark a function as deprecated."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deprecated_option(option_name, message=''):\n    ''' Marks an option as deprecated. '''\n    def caller(func, *args, **kwargs):\n        if option_name in kwargs:\n            warnings.warn(\n                '{} is deprecated. {}'.format(option_name, message),\n                DeprecationWarning,\n                stacklevel=3\n            )\n            \n        return func(*args, **kwargs)\n    return decorator(caller)", "response": "Mark an option as deprecated."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef THUMBNAIL_OPTIONS(self):\n        from django.core.exceptions import ImproperlyConfigured\n\n        size = self._setting('DJNG_THUMBNAIL_SIZE', (200, 200))\n        if not (isinstance(size, (list, tuple)) and len(size) == 2 and isinstance(size[0], int) and isinstance(size[1], int)):\n            raise ImproperlyConfigured(\"'DJNG_THUMBNAIL_SIZE' must be a 2-tuple of integers.\")\n        return {'crop': True, 'size': size}", "response": "Return the options for uploading thumbnailed images."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_context(self, name, value, attrs):\n        context = super(NgWidgetMixin, self).get_context(name, value, attrs)\n        if callable(getattr(self._field, 'update_widget_rendering_context', None)):\n            self._field.update_widget_rendering_context(context)\n        return context", "response": "Override get_context to update the rendering context if needed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef errors(self):\n        if not hasattr(self, '_errors_cache'):\n            self._errors_cache = self.form.get_field_errors(self)\n        return self._errors_cache", "response": "Returns a tupleErrorList for this field."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef css_classes(self, extra_classes=None):\n        if hasattr(extra_classes, 'split'):\n            extra_classes = extra_classes.split()\n        extra_classes = set(extra_classes or [])\n        # field_css_classes is an optional member of a Form optimized for django-angular\n        field_css_classes = getattr(self.form, 'field_css_classes', None)\n        if hasattr(field_css_classes, 'split'):\n            extra_classes.update(field_css_classes.split())\n        elif isinstance(field_css_classes, (list, tuple)):\n            extra_classes.update(field_css_classes)\n        elif isinstance(field_css_classes, dict):\n            extra_field_classes = []\n            for key in ('*', self.name):\n                css_classes = field_css_classes.get(key)\n                if hasattr(css_classes, 'split'):\n                    extra_field_classes = css_classes.split()\n                elif isinstance(css_classes, (list, tuple)):\n                    if '__default__' in css_classes:\n                        css_classes.remove('__default__')\n                        extra_field_classes.extend(css_classes)\n                    else:\n                        extra_field_classes = css_classes\n            extra_classes.update(extra_field_classes)\n        return super(NgBoundField, self).css_classes(extra_classes)", "response": "Returns a string of space - separated CSS classes for the wrapping element of this input field."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns server side errors for the given field.", "response": "def get_field_errors(self, field):\n        \"\"\"\n        Return server side errors. Shall be overridden by derived forms to add their\n        extra errors for AngularJS.\n        \"\"\"\n        identifier = format_html('{0}[\\'{1}\\']', self.form_name, field.name)\n        errors = self.errors.get(field.html_name, [])\n        return self.error_class([SafeTuple(\n            (identifier, self.field_error_css_classes, '$pristine', '$pristine', 'invalid', e)) for e in errors])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_widget_attrs(self, bound_field, attrs):\n        if bound_field.field.has_subwidgets() is False:\n            widget_classes = getattr(self, 'widget_css_classes', None)\n            if widget_classes:\n                if 'class' in attrs:\n                    attrs['class'] += ' ' + widget_classes\n                else:\n                    attrs.update({'class': widget_classes})\n        return attrs", "response": "Updates the widget attributes which shall be added to the widget when rendering this field."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert_widgets(self):\n        warnings.warn(\"Will be removed after dropping support for Django-1.10\", PendingDeprecationWarning)\n        widgets_module = getattr(self, 'widgets_module', 'djng.widgets')\n        for field in self.base_fields.values():\n            if hasattr(field, 'get_converted_widget'):\n                new_widget = field.get_converted_widget(widgets_module)\n                if new_widget:\n                    field.widget = new_widget", "response": "Convert all widgets in the base fields to the new ones."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrectifies the data fields that were submitted through a multipart request", "response": "def rectify_multipart_form_data(self, data):\n        \"\"\"\n        If a widget was converted and the Form data was submitted through a multipart request,\n        then these data fields must be converted to suit the Django Form validation\n        \"\"\"\n        for name, field in self.base_fields.items():\n            try:\n                field.implode_multi_values(name, data)\n            except AttributeError:\n                pass\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rectify_ajax_form_data(self, data):\n        for name, field in self.base_fields.items():\n            try:\n                data[name] = field.convert_ajax_data(data.get(name, {}))\n            except AttributeError:\n                pass\n        return data", "response": "If a widget was converted and the Form data was submitted through an Ajax request,\n        then these data fields must be converted to suit the Django Form validation"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_field_errors(self, bound_field):\n        errors = super(NgFormValidationMixin, self).get_field_errors(bound_field)\n        if bound_field.is_hidden:\n            return errors\n        identifier = format_html('{0}[\\'{1}\\']', self.form_name, self.add_prefix(bound_field.name))\n        potential_errors = bound_field.field.get_potential_errors()\n        errors.extend([SafeTuple((identifier, self.field_error_css_classes, '$dirty', pe[0], 'invalid', force_text(pe[1])))\n                       for pe in potential_errors])\n        if not isinstance(bound_field.field.widget, widgets.PasswordInput):\n            # all valid fields shall display OK tick after changed into dirty state\n            errors.append(SafeTuple((identifier, self.field_error_css_classes, '$dirty', '$valid', 'valid', '')))\n            if bound_field.value():\n                # valid bound fields shall display OK tick, even in pristine state\n                errors.append(SafeTuple((identifier, self.field_error_css_classes, '$pristine', '$valid', 'valid', '')))\n        return errors", "response": "Returns a list of potential errors which may occur in the form field."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef as_div(self):\n        # wrap non-field-errors into <div>-element to prevent re-boxing\n        error_row = '<div class=\"djng-line-spreader\">%s</div>'\n        div_element = self._html_output(\n            normal_row='<div%(html_class_attr)s>%(label)s%(field)s%(help_text)s%(errors)s</div>',\n            error_row=error_row,\n            row_ender='</div>',\n            help_text_html='<span class=\"help-block\">%s</span>',\n            errors_on_separate_row=False)\n        return div_element", "response": "Returns this form rendered as HTML with <div class = form - group s for each form field."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef djng_locale_script(context, default_language='en'):\n    language = get_language_from_request(context['request'])\n    if not language:\n        language = default_language\n    return format_html('angular-locale_{}.js', language.lower())", "response": "Returns a script tag for including the proper locale script in any HTML page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the dictionary of attributes used while rendering the input widget", "response": "def update_widget_attrs(self, bound_field, attrs):\n        \"\"\"\n        Update the dictionary of attributes used  while rendering the input widget\n        \"\"\"\n        bound_field.form.update_widget_attrs(bound_field, attrs)\n        widget_classes = self.widget.attrs.get('class', None)\n        if widget_classes:\n            if 'class' in attrs:\n                attrs['class'] += ' ' + widget_classes\n            else:\n                attrs.update({'class': widget_classes})\n        return attrs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a regex pattern matching valid email addresses.", "response": "def get_email_regex(self):\n        \"\"\"\n        Return a regex pattern matching valid email addresses. Uses the same\n        logic as the django validator, with the folowing exceptions:\n\n        - Internationalized domain names not supported\n        - IP addresses not supported\n        - Strips lookbehinds (not supported in javascript regular expressions)\n        \"\"\"\n        validator = self.default_validators[0]\n        user_regex = validator.user_regex.pattern.replace('\\Z', '@')\n        domain_patterns = ([re.escape(domain) + '$' for domain in\n                            validator.domain_whitelist] +\n                           [validator.domain_regex.pattern.replace('\\Z', '$')])\n        domain_regex = '({0})'.format('|'.join(domain_patterns))\n        email_regex = user_regex + domain_regex\n        return re.sub(r'\\(\\?\\<[^()]*?\\)', '', email_regex)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of errors if the MultipleChoiceField is required.", "response": "def get_multiple_choices_required(self):\n        \"\"\"\n        Add only the required message, but no 'ng-required' attribute to the input fields,\n        otherwise all Checkboxes of a MultipleChoiceField would require the property \"checked\".\n        \"\"\"\n        errors = []\n        if self.required:\n            msg = _(\"At least one checkbox has to be selected.\")\n            errors.append(('$error.multifield', msg))\n        return errors"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_ajax_data(self, field_data):\n        data = [key for key, val in field_data.items() if val]\n        return data", "response": "Convert the data sent using Ajax to a list of keys."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads url name args and kwargs from GET parameters reverses the url and resolves view function Returns the result of the resolved view function", "response": "def process_request(self, request):\n        \"\"\"\n        Reads url name, args, kwargs from GET parameters, reverses the url and resolves view function\n        Returns the result of resolved view function, called with provided args and kwargs\n        Since the view function is called directly, it isn't ran through middlewares, so the middlewares must\n        be added manually\n        The final result is exactly the same as if the request was for the resolved view.\n\n        Parametrized urls:\n        djangoUrl.reverse can be used with parametrized urls of $resource\n        In that case the reverse url is something like: /angular/reverse/?djng_url_name=orders&djng_url_kwarg_id=:id\n        $resource can either replace the ':id' part with say 2 and we can proceed as usual,\n        reverse with reverse('orders', kwargs={'id': 2}).\n\n        If it's not replaced we want to reverse to url we get a request to url\n        '/angular/reverse/?djng_url_name=orders&djng_url_kwarg_id=' which\n        gives a request.GET QueryDict {u'djng_url_name': [u'orders'], u'djng_url_kwarg_id': [u'']}\n\n        In that case we want to ignore the id param and only reverse to url with name 'orders' and no params.\n        So we ignore args and kwargs that are empty strings.\n        \"\"\"\n        if request.path == self.ANGULAR_REVERSE:\n            url_name = request.GET.get('djng_url_name')\n            url_args = request.GET.getlist('djng_url_args', [])\n            url_kwargs = {}\n\n            # Remove falsy values (empty strings)\n            url_args = filter(lambda x: x, url_args)\n\n            # Read kwargs\n            for param in request.GET:\n                if param.startswith('djng_url_kwarg_'):\n                    # Ignore kwargs that are empty strings\n                    if request.GET[param]:\n                        url_kwargs[param[15:]] = request.GET[param]  # [15:] to remove 'djng_url_kwarg' prefix\n\n            url = unquote(reverse(url_name, args=url_args, kwargs=url_kwargs))\n            assert not url.startswith(self.ANGULAR_REVERSE), \"Prevent recursive requests\"\n\n            # rebuild the request object with a different environ\n            request.path = request.path_info = url\n            request.environ['PATH_INFO'] = url\n            query = request.GET.copy()\n            for key in request.GET:\n                if key.startswith('djng_url'):\n                    query.pop(key, None)\n            if six.PY3:\n                request.environ['QUERY_STRING'] = query.urlencode()\n            else:\n                request.environ['QUERY_STRING'] = query.urlencode().encode('utf-8')\n\n            # Reconstruct GET QueryList in the same way WSGIRequest.GET function works\n            request.GET = http.QueryDict(request.environ['QUERY_STRING'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_all_remote_methods(resolver=None, ns_prefix=''):\n    if not resolver:\n        resolver = get_resolver(get_urlconf())\n    result = {}\n    for name in resolver.reverse_dict.keys():\n        if not isinstance(name, six.string_types):\n            continue\n        try:\n            url = reverse(ns_prefix + name)\n            resmgr = resolve(url)\n            ViewClass = import_string('{0}.{1}'.format(resmgr.func.__module__, resmgr.func.__name__))\n            if isclass(ViewClass) and issubclass(ViewClass, JSONResponseMixin):\n                result[name] = _get_remote_methods_for(ViewClass, url)\n        except (NoReverseMatch, ImproperlyConfigured):\n            pass\n    for namespace, ns_pattern in resolver.namespace_dict.items():\n        sub_res = get_all_remote_methods(ns_pattern[1], ns_prefix + namespace + ':')\n        if sub_res:\n            result[namespace] = sub_res\n    return result", "response": "Returns a dictionary that contains all remote methods for all the modules in the order they are defined."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dispatch(self, request, *args, **kwargs):\n        allowed_methods = self.get_allowed_methods()\n        try:\n            if request.method == 'GET' and 'GET' in allowed_methods:\n                if 'pk' in request.GET or self.slug_field in request.GET:\n                    return self.ng_get(request, *args, **kwargs)\n                return self.ng_query(request, *args, **kwargs)\n            elif request.method == 'POST' and 'POST' in allowed_methods:\n                return self.ng_save(request, *args, **kwargs)\n            elif request.method == 'DELETE' and 'DELETE' in allowed_methods:\n                return self.ng_delete(request, *args, **kwargs)\n        except self.model.DoesNotExist as e:\n            return self.error_json_response(e.args[0], 404)\n        except NgMissingParameterError as e:\n            return self.error_json_response(e.args[0])\n        except JSONResponseException as e:\n            return self.error_json_response(e.args[0], e.status_code)\n        except ValidationError as e:\n            if hasattr(e, 'error_dict'):\n                return self.error_json_response('Form not valid', detail=e.message_dict)\n            else:\n                return self.error_json_response(e.message)\n\n        return self.error_json_response('This view can not handle method {0}'.format(request.method), 405)", "response": "Override dispatch to call appropriate methods"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns serialized queryset or single object as python dictionary", "response": "def serialize_queryset(self, queryset):\n        \"\"\"\n        Return serialized queryset or single object as python dictionary\n        serialize() only works on iterables, so to serialize a single object we put it in a list\n        \"\"\"\n        object_data = []\n        is_queryset = False\n        query_fields = self.get_fields()\n        try:\n            iter(queryset)\n            is_queryset = True\n            raw_data = serializers.serialize(self.serializer_name, queryset, fields=query_fields,\n                                             use_natural_keys=self.serialize_natural_keys)\n        except TypeError:  # Not iterable\n            raw_data = serializers.serialize(self.serializer_name, [queryset, ], fields=query_fields,\n                                             use_natural_keys=self.serialize_natural_keys)\n\n        for obj in raw_data:  # Add pk to fields\n            obj['fields']['pk'] = obj['pk']\n            object_data.append(obj['fields'])\n\n        if is_queryset:\n            return object_data\n        return object_data[0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving an object in the database.", "response": "def ng_save(self, request, *args, **kwargs):\n        \"\"\"\n        Called on $save()\n        Use modelform to save new object or modify an existing one\n        \"\"\"\n        form = self.get_form(self.get_form_class())\n        if form.is_valid():\n            obj = form.save()\n            return self.build_json_response(obj)\n\n        raise ValidationError(form.errors)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ng_delete(self, request, *args, **kwargs):\n        if 'pk' not in request.GET:\n            raise NgMissingParameterError(\"Object id is required to delete.\")\n\n        obj = self.get_object()\n        response = self.build_json_response(obj)\n        obj.delete()\n        return response", "response": "Delete object and return it s data in JSON encoding"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering the choice field as a list of strings.", "response": "def render(self):\n        \"\"\"\n        Outputs a <div ng-form=\"name\"> for this set of choice fields to nest an ngForm.\n        \"\"\"\n        start_tag = format_html('<div {}>', mark_safe(' '.join(self.field_attrs)))\n        output = [start_tag]\n        for widget in self:\n            output.append(force_text(widget))\n        output.append('</div>')\n        return mark_safe('\\n'.join(output))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _post_clean(self):\n        super(NgModelFormMixin, self)._post_clean()\n        if self._errors and self.prefix:\n            self._errors = ErrorDict((self.add_prefix(name), value) for name, value in self._errors.items())", "response": "Rewrite the error dictionary so that the keys correspond to the model fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary specifying the initial values for this form.", "response": "def get_initial_data(self):\n        \"\"\"\n        Return a dictionary specifying the defaults for this form. This dictionary can be used to\n        inject the initial values for an Angular controller using the directive:\n        ``ng-init={{ thisform.get_initial_data|js|safe }}``.\n        \"\"\"\n        data = {}\n        ng_models = hasattr(self, 'Meta') and getattr(self.Meta, 'ng_models', []) or []\n        for name, field in self.fields.items():\n            if 'ng-model' in self.ng_directives or name in ng_models:\n                data[name] = self.initial.get(name) if self.initial else field.initial\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_resize(self, signum=None, frame=None):\n        'Tries to catch resize signals sent from the terminal.'\n\n        w, h = utils.get_terminal_size()\n        self.term_width = w", "response": "Tries to catch resize signals sent from the terminal."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef init(self):\n        '''\n        (re)initialize values to original state so the progressbar can be\n        used (again)\n        '''\n        self.previous_value = None\n        self.last_update_time = None\n        self.start_time = None\n        self.updates = 0\n        self.end_time = None\n        self.extra = dict()\n        self._last_update_timer = timeit.default_timer()", "response": "Initialize the internal state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef percentage(self):\n        '''Return current percentage, returns None if no max_value is given\n\n        >>> progress = ProgressBar()\n        >>> progress.max_value = 10\n        >>> progress.min_value = 0\n        >>> progress.value = 0\n        >>> progress.percentage\n        0.0\n        >>>\n        >>> progress.value = 1\n        >>> progress.percentage\n        10.0\n        >>> progress.value = 10\n        >>> progress.percentage\n        100.0\n        >>> progress.min_value = -10\n        >>> progress.percentage\n        100.0\n        >>> progress.value = 0\n        >>> progress.percentage\n        50.0\n        >>> progress.value = 5\n        >>> progress.percentage\n        75.0\n        >>> progress.value = -5\n        >>> progress.percentage\n        25.0\n        >>> progress.max_value = None\n        >>> progress.percentage\n        '''\n        if self.max_value is None or self.max_value is base.UnknownLength:\n            return None\n        elif self.max_value:\n            todo = self.value - self.min_value\n            total = self.max_value - self.min_value\n            percentage = todo / total\n        else:\n            percentage = 1\n\n        return percentage * 100", "response": "Return current percentage of the current set of items in the current set. Returns None if no max_value is given\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _needs_update(self):\n        'Returns whether the ProgressBar should redraw the line.'\n\n        if self.poll_interval:\n            delta = timeit.default_timer() - self._last_update_timer\n            poll_status = delta > self.poll_interval.total_seconds()\n        else:\n            delta = 0\n            poll_status = False\n\n        # Do not update if value increment is not large enough to\n        # add more bars to progressbar (according to current\n        # terminal width)\n        try:\n            divisor = self.max_value / self.term_width  # float division\n            if self.value // divisor == self.previous_value // divisor:\n                return poll_status or self.end_time\n            else:\n                return True\n        except Exception:\n            # ignore any division errors\n            pass\n\n        return poll_status or self.end_time", "response": "Returns whether the ProgressBar should redraw the line."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the ProgressBar to a new value.", "response": "def update(self, value=None, force=False, **kwargs):\n        'Updates the ProgressBar to a new value.'\n        if self.start_time is None:\n            self.start()\n            return self.update(value, force=force, **kwargs)\n\n        if value is not None and value is not base.UnknownLength:\n            if self.max_value is base.UnknownLength:\n                # Can't compare against unknown lengths so just update\n                pass\n            elif self.min_value <= value <= self.max_value:  # pragma: no cover\n                # Correct value, let's accept\n                pass\n            elif self.max_error:\n                raise ValueError(\n                    'Value %s is out of range, should be between %s and %s'\n                    % (value, self.min_value, self.max_value))\n            else:\n                self.max_value = value\n\n            self.previous_value = self.value\n            self.value = value\n\n        minimum_update_interval = self._MINIMUM_UPDATE_INTERVAL\n        delta = timeit.default_timer() - self._last_update_timer\n        if delta < minimum_update_interval and not force:\n            # Prevent updating too often\n            return\n\n        # Save the updated values for dynamic messages\n        for key in kwargs:\n            if key in self.dynamic_messages:\n                self.dynamic_messages[key] = kwargs[key]\n            else:\n                raise TypeError(\n                    'update() got an unexpected keyword ' +\n                    'argument {0!r}'.format(key))\n\n        if self._needs_update() or force:\n            self.updates += 1\n            ResizableMixin.update(self, value=value)\n            ProgressBarBase.update(self, value=value)\n            StdRedirectMixin.update(self, value=value)\n\n            # Only flush if something was actually written\n            self.fd.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start(self, max_value=None, init=True):\n        '''Starts measuring time, and prints the bar at 0%.\n\n        It returns self so you can use it like this:\n\n        Args:\n            max_value (int): The maximum value of the progressbar\n            reinit (bool): Initialize the progressbar, this is useful if you\n                wish to reuse the same progressbar but can be disabled if\n                data needs to be passed along to the next run\n\n        >>> pbar = ProgressBar().start()\n        >>> for i in range(100):\n        ...    # do something\n        ...    pbar.update(i+1)\n        ...\n        >>> pbar.finish()\n        '''\n        if init:\n            self.init()\n\n        # Prevent multiple starts\n        if self.start_time is not None:  # pragma: no cover\n            return self\n\n        if max_value is not None:\n            self.max_value = max_value\n\n        if self.max_value is None:\n            self.max_value = self._DEFAULT_MAXVAL\n\n        StdRedirectMixin.start(self, max_value=max_value)\n        ResizableMixin.start(self, max_value=max_value)\n        ProgressBarBase.start(self, max_value=max_value)\n\n        # Constructing the default widgets is only done when we know max_value\n        if self.widgets is None:\n            self.widgets = self.default_widgets()\n\n        if self.prefix:\n            self.widgets.insert(0, widgets.FormatLabel(\n                self.prefix, new_style=True))\n\n        if self.suffix:\n            self.widgets.append(widgets.FormatLabel(\n                self.suffix, new_style=True))\n\n        for widget in self.widgets:\n            interval = getattr(widget, 'INTERVAL', None)\n            if interval is not None:\n                self.poll_interval = min(\n                    self.poll_interval or interval,\n                    interval,\n                )\n\n        self.num_intervals = max(100, self.term_width)\n\n        if self.max_value is not base.UnknownLength and self.max_value < 0:\n            raise ValueError('Value out of range')\n\n        self.start_time = self.last_update_time = datetime.now()\n        self._last_update_timer = timeit.default_timer()\n        self.update(self.min_value, force=True)\n\n        return self", "response": "Starts measuring time and prints the bar at 0%."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinishing the progress bar.", "response": "def finish(self, end='\\n', dirty=False):\n        '''\n        Puts the ProgressBar bar in the finished state.\n\n        Also flushes and disables output buffering if this was the last\n        progressbar running.\n\n        Args:\n            end (str): The string to end the progressbar with, defaults to a\n                newline\n            dirty (bool): When True the progressbar kept the current state and\n                won't be set to 100 percent\n        '''\n\n        if not dirty:\n            self.end_time = datetime.now()\n            self.update(self.max_value, force=True)\n\n        StdRedirectMixin.finish(self, end=end)\n        ResizableMixin.finish(self)\n        ProgressBarBase.finish(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap the examples so they generate readable output", "response": "def example(fn):\n    '''Wrap the examples so they generate readable output'''\n\n    @functools.wraps(fn)\n    def wrapped():\n        try:\n            sys.stdout.write('Running: %s\\n' % fn.__name__)\n            fn()\n            sys.stdout.write('\\n')\n        except KeyboardInterrupt:\n            sys.stdout.write('\\nSkipping example.\\n\\n')\n            # Sleep a bit to make killing the script easier\n            time.sleep(0.2)\n\n    examples.append(wrapped)\n    return wrapped"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _calculate_eta(self, progress, data, value, elapsed):\n        '''Updates the widget to show the ETA or total time when finished.'''\n        if elapsed:\n            # The max() prevents zero division errors\n            per_item = elapsed.total_seconds() / max(value, 1e-6)\n            remaining = progress.max_value - data['value']\n            eta_seconds = remaining * per_item\n        else:\n            eta_seconds = 0\n\n        return eta_seconds", "response": "Calculates the ETA or total time when finished."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload standard graph validation sets", "response": "def load_stdgraphs(size: int) -> List[nx.Graph]:\n    \"\"\"Load standard graph validation sets\n\n    For each size (from 6 to 32 graph nodes) the dataset consists of\n    100 graphs drawn from the Erd\u0151s-R\u00e9nyi ensemble with edge\n    probability 50%.\n    \"\"\"\n    from pkg_resources import resource_stream\n\n    if size < 6 or size > 32:\n        raise ValueError('Size out of range.')\n\n    filename = 'datasets/data/graph{}er100.g6'.format(size)\n    fdata = resource_stream('quantumflow', filename)\n    return nx.read_graph6(fdata)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_mnist(size: int = None,\n               border: int = _MNIST_BORDER,\n               blank_corners: bool = False,\n               nums: List[int] = None) \\\n        -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Download and rescale the MNIST database of handwritten digits\n\n    MNIST is a dataset of 60,000 28x28 grayscale images handwritten digits,\n    along with a test set of 10,000 images. We use Keras to download and\n    access the dataset. The first invocation of this method may take a while\n    as the dataset has to be downloaded and cached.\n\n    If size is None, then we return the original MNIST data.\n    For rescaled MNIST, we chop off the border, downsample to the\n    desired size with Lanczos resampling, and then (optionally) zero out the\n    corner pixels.\n\n    Returns (x_train, y_train, x_test, y_test)\n\n    x_train ndarray of shape (60000, size, size)\n    y_train ndarray of shape (60000,)\n    x_test ndarray of shape (10000, size, size)\n    y_test ndarray of shape (10000,)\n    \"\"\"\n    # DOCME: Fix up formatting above,\n    # DOCME: Explain nums argument\n\n    # JIT import since keras startup is slow\n    from keras.datasets import mnist\n\n    def _filter_mnist(x: np.ndarray, y: np.ndarray, nums: List[int] = None) \\\n            -> Tuple[np.ndarray, np.ndarray]:\n        xt = []\n        yt = []\n        items = len(y)\n        for n in range(items):\n            if nums is not None and y[n] in nums:\n                xt.append(x[n])\n                yt.append(y[n])\n        xt = np.stack(xt)\n        yt = np.stack(yt)\n        return xt, yt\n\n    def _rescale(imgarray: np.ndarray, size: int) -> np.ndarray:\n        N = imgarray.shape[0]\n\n        # Chop off border\n        imgarray = imgarray[:, border:-border, border:-border]\n\n        rescaled = np.zeros(shape=(N, size, size), dtype=np.float)\n        for n in range(0, N):\n            img = Image.fromarray(imgarray[n])\n            img = img.resize((size, size), Image.LANCZOS)\n            rsc = np.asarray(img).reshape((size, size))\n            rsc = 256.*rsc/rsc.max()\n            rescaled[n] = rsc\n\n        return rescaled.astype(dtype=np.uint8)\n\n    def _blank_corners(imgarray: np.ndarray) -> None:\n        # Zero out corners\n        sz = imgarray.shape[1]\n        corner = (sz//2)-1\n        for x in range(0, corner):\n            for y in range(0, corner-x):\n                imgarray[:, x, y] = 0\n                imgarray[:, -(1+x), y] = 0\n                imgarray[:, -(1+x), -(1+y)] = 0\n                imgarray[:, x, -(1+y)] = 0\n\n    (x_train, y_train), (x_test, y_test) = mnist.load_data()\n\n    if nums:\n        x_train, y_train = _filter_mnist(x_train, y_train, nums)\n        x_test, y_test = _filter_mnist(x_test, y_test, nums)\n\n    if size:\n        x_train = _rescale(x_train, size)\n        x_test = _rescale(x_test, size)\n\n    if blank_corners:\n        _blank_corners(x_train)\n        _blank_corners(x_test)\n\n    return x_train, y_train, x_test, y_test", "response": "Load the MNIST dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef astensor(array: TensorLike) -> BKTensor:\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "response": "Covert numpy array to tensorflow tensor"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef inner(tensor0: BKTensor, tensor1: BKTensor) -> BKTensor:\n    # Note: Relying on fact that vdot flattens arrays\n    N = rank(tensor0)\n    axes = list(range(N))\n    return tf.tensordot(tf.math.conj(tensor0), tensor1, axes=(axes, axes))", "response": "Return the inner product between two states"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a QAOA circuit for the Quadratic Unconstrained Binary Optimization problem.", "response": "def qubo_circuit(\n        graph: nx.Graph,\n        steps: int,\n        beta: Sequence,\n        gamma: Sequence) -> Circuit:\n    \"\"\"\n    A QAOA circuit for the Quadratic Unconstrained Binary Optimization\n    problem (i.e. an Ising model).\n\n    Args:\n        graph : a networkx graph instance with optional edge and node weights\n        steps : number of QAOA steps\n        beta  : driver parameters (One per step)\n        gamma : cost parameters (One per step)\n\n    \"\"\"\n\n    qubits = list(graph.nodes())\n\n    # Initialization\n    circ = Circuit()\n    for q0 in qubits:\n        circ += H(q0)\n\n    # Run for given number of QAOA steps\n    for p in range(0, steps):\n\n        # Cost\n        for q0, q1 in graph.edges():\n            weight = graph[q0][q1].get('weight', 1.0)\n            # Note factor of pi due to parameterization of ZZ gate\n            circ += ZZ(-weight * gamma[p] / np.pi, q0, q1)\n\n        for q0 in qubits:\n            node_weight = graph.nodes[q0].get('weight', None)\n            if node_weight is not None:\n                circ += RZ(node_weight, q0)\n\n        # Drive\n        for q0 in qubits:\n            circ += RX(beta[p], q0)\n\n    return circ"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef depth(self, local: bool = True) -> int:\n        G = self.graph\n        if not local:\n            def remove_local(dagc: DAGCircuit) \\\n                    -> Generator[Operation, None, None]:\n                for elem in dagc:\n                    if dagc.graph.degree[elem] > 2:\n                        yield elem\n            G = DAGCircuit(remove_local(self)).graph\n\n        return nx.dag_longest_path_length(G) - 1", "response": "Return the depth of the current circuit."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef components(self) -> List['DAGCircuit']:\n        comps = nx.weakly_connected_component_subgraphs(self.graph)\n        return [DAGCircuit(comp) for comp in comps]", "response": "Split DAGCircuit into independent components"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsplitting the DAGCircuit into layers where the operations within each layer operate on different qubits.", "response": "def layers(self) -> Circuit:\n        \"\"\"Split DAGCircuit into layers, where the operations within each\n        layer operate on different qubits (and therefore commute).\n\n        Returns: A Circuit of Circuits, one Circuit per layer\n        \"\"\"\n        node_depth: Dict[Qubit, int] = {}\n        G = self.graph\n\n        for elem in self:\n            depth = np.max(list(node_depth.get(prev, -1) + 1\n                           for prev in G.predecessors(elem)))\n            node_depth[elem] = depth\n\n        depth_nodes = invert_map(node_depth, one_to_one=False)\n\n        layers = []\n        for nd in range(0, self.depth()):\n            elements = depth_nodes[nd]\n            circ = Circuit(list(elements))\n            layers.append(circ)\n\n        return Circuit(layers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef zero_state(qubits: Union[int, Qubits]) -> State:\n    N, qubits = qubits_count_tuple(qubits)\n    ket = np.zeros(shape=[2] * N)\n    ket[(0,) * N] = 1\n    return State(ket, qubits)", "response": "Return the all - zero state on N qubits"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef w_state(qubits: Union[int, Qubits]) -> State:\n    N, qubits = qubits_count_tuple(qubits)\n    ket = np.zeros(shape=[2] * N)\n    for n in range(N):\n        idx = np.zeros(shape=N, dtype=int)\n        idx[n] += 1\n        ket[tuple(idx)] = 1 / sqrt(N)\n    return State(ket, qubits)", "response": "Return a W state on N qubits"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ghz_state(qubits: Union[int, Qubits]) -> State:\n    N, qubits = qubits_count_tuple(qubits)\n    ket = np.zeros(shape=[2] * N)\n    ket[(0, ) * N] = 1 / sqrt(2)\n    ket[(1, ) * N] = 1 / sqrt(2)\n    return State(ket, qubits)", "response": "Return a GHZ state on N qubits"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef random_state(qubits: Union[int, Qubits]) -> State:\n    N, qubits = qubits_count_tuple(qubits)\n    ket = np.random.normal(size=([2] * N)) \\\n        + 1j * np.random.normal(size=([2] * N))\n    return State(ket, qubits).normalize()", "response": "Return a random state from the space of N qubits"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef join_states(*states: State) -> State:\n    vectors = [ket.vec for ket in states]\n    vec = reduce(outer_product, vectors)\n    return State(vec.tensor, vec.qubits)", "response": "Join two states into a larger qubit state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting a state vector", "response": "def print_state(state: State, file: TextIO = None) -> None:\n    \"\"\"Print a state vector\"\"\"\n    state = state.vec.asarray()\n    for index, amplitude in np.ndenumerate(state):\n        ket = \"\".join([str(n) for n in index])\n        print(ket, \":\", amplitude, file=file)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef print_probabilities(state: State, ndigits: int = 4,\n                        file: TextIO = None) -> None:\n    \"\"\"\n    Pretty print state probabilities.\n\n    Args:\n        state:\n        ndigits: Number of digits of accuracy\n        file: Output stream (Defaults to stdout)\n    \"\"\"\n    prob = bk.evaluate(state.probabilities())\n    for index, prob in np.ndenumerate(prob):\n        prob = round(prob, ndigits)\n        if prob == 0.0:\n            continue\n        ket = \"\".join([str(n) for n in index])\n        print(ket, \":\", prob, file=file)", "response": "Pretty print state probabilities."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mixed_density(qubits: Union[int, Qubits]) -> Density:\n    N, qubits = qubits_count_tuple(qubits)\n    matrix = np.eye(2**N) / 2**N\n    return Density(matrix, qubits)", "response": "Returns the completely mixed density matrix"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef random_density(qubits: Union[int, Qubits]) -> Density:\n    N, qubits = qubits_count_tuple(qubits)\n    size = (2**N, 2**N)\n    ginibre_ensemble = (np.random.normal(size=size) +\n                        1j * np.random.normal(size=size)) / np.sqrt(2.0)\n    matrix = ginibre_ensemble @ np.transpose(np.conjugate(ginibre_ensemble))\n    matrix /= np.trace(matrix)\n\n    return Density(matrix, qubits=qubits)", "response": "A randomly sampled Density from the Hilbert\u2013Schmidt\n                ensemble of mixed quantum states"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef join_densities(*densities: Density) -> Density:\n    vectors = [rho.vec for rho in densities]\n    vec = reduce(outer_product, vectors)\n\n    memory = dict(ChainMap(*[rho.memory for rho in densities]))  # TESTME\n    return Density(vec.tensor, vec.qubits, memory)", "response": "Join two mixed states into a larger qubit state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a copy of this state with new qubits", "response": "def relabel(self, qubits: Qubits) -> 'State':\n        \"\"\"Return a copy of this state with new qubits\"\"\"\n        return State(self.vec.tensor, qubits, self._memory)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a copy of this state with qubit labels permuted", "response": "def permute(self, qubits: Qubits) -> 'State':\n        \"\"\"Return a copy of this state with qubit labels permuted\"\"\"\n        vec = self.vec.permute(qubits)\n        return State(vec.tensor, vec.qubits, self._memory)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef normalize(self) -> 'State':\n        tensor = self.tensor / bk.ccast(bk.sqrt(self.norm()))\n        return State(tensor, self.qubits, self._memory)", "response": "Return a new state with the normalized tensor."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the state probabilities of the current object.", "response": "def probabilities(self) -> bk.BKTensor:\n        \"\"\"\n        Returns:\n            The state probabilities\n        \"\"\"\n        value = bk.absolute(self.tensor)\n        return value * value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsampling the state in the computational basis the given number of trials and return the counts of each output configuration.", "response": "def sample(self, trials: int) -> np.ndarray:\n        \"\"\"Measure the state in the computational basis the the given number\n        of trials, and return the counts of each output configuration.\n        \"\"\"\n        # TODO: Can we do this within backend?\n        probs = np.real(bk.evaluate(self.probabilities()))\n        res = np.random.multinomial(trials, probs.ravel())\n        res = res.reshape(probs.shape)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef expectation(self, diag_hermitian: bk.TensorLike,\n                    trials: int = None) -> bk.BKTensor:\n        \"\"\"Return the expectation of a measurement. Since we can only measure\n        our computer in the computational basis, we only require the diagonal\n        of the Hermitian in that basis.\n\n        If the number of trials is specified, we sample the given number of\n        times. Else we return the exact expectation (as if we'd performed an\n        infinite number of trials. )\n        \"\"\"\n        if trials is None:\n            probs = self.probabilities()\n        else:\n            probs = bk.real(bk.astensorproduct(self.sample(trials) / trials))\n\n        diag_hermitian = bk.astensorproduct(diag_hermitian)\n        return bk.sum(bk.real(diag_hermitian) * probs)", "response": "Return the expectation of a measurement."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmeasures the state in the computational basis.", "response": "def measure(self) -> np.ndarray:\n        \"\"\"Measure the state in the computational basis.\n\n        Returns:\n            A [2]*bits array of qubit states, either 0 or 1\n        \"\"\"\n        # TODO: Can we do this within backend?\n        probs = np.real(bk.evaluate(self.probabilities()))\n        indices = np.asarray(list(np.ndindex(*[2] * self.qubit_nb)))\n        res = np.random.choice(probs.size, p=probs.ravel())\n        res = indices[res]\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a pure state to a density matrix", "response": "def asdensity(self) -> 'Density':\n        \"\"\"Convert a pure state to a density matrix\"\"\"\n        matrix = bk.outer(self.tensor, bk.conj(self.tensor))\n        return Density(matrix, self.qubits, self._memory)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef partial_trace(self, qubits: Qubits) -> 'Density':\n        vec = self.vec.partial_trace(qubits)\n        return Density(vec.tensor, vec.qubits, self._memory)", "response": "Return the partial trace over the specified qubits"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef relabel(self, qubits: Qubits) -> 'Density':\n        return Density(self.vec.tensor, qubits, self._memory)", "response": "Return a copy of this state with new qubits"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a copy of this state with qubit labels permuted", "response": "def permute(self, qubits: Qubits) -> 'Density':\n        \"\"\"Return a copy of this state with qubit labels permuted\"\"\"\n        vec = self.vec.permute(qubits)\n        return Density(vec.tensor, vec.qubits, self._memory)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normalize(self) -> 'Density':\n        tensor = self.tensor / self.trace()\n        return Density(tensor, self.qubits, self._memory)", "response": "Return a new Density object with the normalized tensor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef probabilities(self) -> bk.BKTensor:\n        prob = bk.productdiag(self.tensor)\n        return prob", "response": "Returns the state probabilities"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef benchmark(N, gates):\n    qubits = list(range(0, N))\n    ket = qf.zero_state(N)\n\n    for n in range(0, N):\n        ket = qf.H(n).run(ket)\n\n    for _ in range(0, (gates-N)//3):\n        qubit0, qubit1 = random.sample(qubits, 2)\n        ket = qf.X(qubit0).run(ket)\n        ket = qf.T(qubit1).run(ket)\n        ket = qf.CNOT(qubit0, qubit1).run(ket)\n\n    return ket.vec.tensor", "response": "Create and run a circuit with N qubits and given number of gates"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef benchmark_gops(N, gates, reps):\n    t = timeit.timeit(lambda: benchmark(N, gates), number=reps)\n    gops = (GATES*REPS)/t\n    gops = int((gops * 100) + 0.5) / 100.0\n    return gops", "response": "Benchmark performance in GOPS"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sandwich_decompositions(coords0, coords1, samples=SAMPLES):\n    decomps = []\n    for _ in range(samples):\n        circ = qf.Circuit()\n        circ += qf.CANONICAL(*coords0, 0, 1)\n        circ += qf.random_gate([0])\n        circ += qf.random_gate([1])\n        circ += qf.CANONICAL(*coords1, 0, 1)\n        gate = circ.asgate()\n\n        coords = qf.canonical_coords(gate)\n        decomps.append(coords)\n\n    return decomps", "response": "Create composite gates decompose and return a list\n    of canonical coordinates"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct and display 3D plot of canonical coordinates", "response": "def display_weyl(decomps):\n    \"\"\"Construct and display 3D plot of canonical coordinates\"\"\"\n    tx, ty, tz = list(zip(*decomps))\n\n    rcParams['axes.labelsize'] = 24\n    rcParams['font.family'] = 'serif'\n    rcParams['font.serif'] = ['Computer Modern Roman']\n    rcParams['text.usetex'] = True\n    fig = pyplot.figure()\n    ax = Axes3D(fig)\n    ax.scatter(tx, ty, tz)\n    ax.plot((1,), (1,), (1,))\n    ax.plot((0, 1, 1/2, 0, 1/2, 1, 1/2, 1/2),\n            (0, 0, 1/2, 0, 1/2, 0, 1/2, 1/2),\n            (0, 0, 0, 0, 1/2, 0, 0, 1/2))\n    ax.plot((0, 1/2, 1, 1/2, 1/2),\n            (0, 1/4, 0, 1/4, 1/2),\n            (0, 1/4, 0, 1/4, 0))\n\n    points = [(0, 0, 0), (1/4, 0, 0), (1/2, 0, 0), (3/4, 0, 0), (1, 0, 0),\n              (1/4, 1/4, 0), (1/2, 1/4, 0), (3/4, 1/4, 0), (1/2, 1/2, 0),\n              (1/4, 1/4, 1/4), (1/2, 1/4, 1/4), (3/4, 1/4, 1/4),\n              (1/2, 1/2, 1/4), (1/2, 1/2, 1/2)]\n\n    ax.scatter(*zip(*points))\n    eps = 0.04\n    ax.text(0, 0, 0-2*eps, 'I', ha='center')\n    ax.text(1, 0, 0-2*eps, 'I', ha='center')\n    ax.text(1/2, 1/2, 0-2*eps, 'iSWAP', ha='center')\n    ax.text(1/2, 1/2, 1/2+eps, 'SWAP', ha='center')\n    ax.text(1/2, 0, 0-2*eps, 'CNOT', ha='center')\n\n    # More coordinate labels\n    # ax.text(1/4-eps, 1/4, 1/4, '$\\sqrt{SWAP}$', ha='right')\n    # ax.text(3/4+eps, 1/4, 1/4, '$\\sqrt{SWAP}^\\dagger$', ha='left')\n    # ax.text(1/4, 0, 0-2*eps, '$\\sqrt{{CNOT}}$', ha='center')\n    # ax.text(3/4, 0, 0-2*eps, '$\\sqrt{{CNOT}}$', ha='center')\n    # ax.text(1/2, 1/4, 0-2*eps, 'B', ha='center')\n    # ax.text(1/2, 1/4, 1/4+eps, 'ECP', ha='center')\n    # ax.text(1/4, 1/4, 0-2*eps, '$\\sqrt{iSWAP}$', ha='center')\n    # ax.text(3/4, 1/4, 0-2*eps, '$\\sqrt{iSWAP}$', ha='center')\n    # ax.text(1/2, 1/2+eps, 1/4, 'PSWAP(1/2)', ha='left')\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(-1/4, 3/4)\n    ax.set_zlim(-1/4, 3/4)\n\n    # Get rid of the panes\n    ax.w_xaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))\n    ax.w_yaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))\n    ax.w_zaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))\n\n    # Get rid of the spines\n    ax.w_xaxis.line.set_color((1.0, 1.0, 1.0, 0.0))\n    ax.w_yaxis.line.set_color((1.0, 1.0, 1.0, 0.0))\n    ax.w_zaxis.line.set_color((1.0, 1.0, 1.0, 0.0))\n\n    # Get rid of the ticks\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.set_zticks([])\n\n    pyplot.show()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the Pauli sigma_X operator acting on the given qubit", "response": "def sX(qubit: Qubit, coefficient: complex = 1.0) -> Pauli:\n    \"\"\"Return the Pauli sigma_X operator acting on the given qubit\"\"\"\n    return Pauli.sigma(qubit, 'X', coefficient)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sY(qubit: Qubit, coefficient: complex = 1.0) -> Pauli:\n    return Pauli.sigma(qubit, 'Y', coefficient)", "response": "Return the Pauli sigma_Y operator acting on the given qubit"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the Pauli sigma_Z operator acting on the given qubit", "response": "def sZ(qubit: Qubit, coefficient: complex = 1.0) -> Pauli:\n    \"\"\"Return the Pauli sigma_Z operator acting on the given qubit\"\"\"\n    return Pauli.sigma(qubit, 'Z', coefficient)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the Pauli sigma_I operator.", "response": "def sI(qubit: Qubit, coefficient: complex = 1.0) -> Pauli:\n    \"\"\"Return the Pauli sigma_I (identity) operator. The qubit is irrelevant,\n    but kept as an  argument for consistency\"\"\"\n    return Pauli.sigma(qubit, 'I', coefficient)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pauli_sum(*elements: Pauli) -> Pauli:\n    terms = []\n\n    key = itemgetter(0)\n    for term, grp in groupby(heapq.merge(*elements, key=key), key=key):\n        coeff = sum(g[1] for g in grp)\n        if not isclose(coeff, 0.0):\n            terms.append((term, coeff))\n\n    return Pauli(tuple(terms))", "response": "Return the sum of elements of the Pauli algebra"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the product of elements of the Pauli algebra", "response": "def pauli_product(*elements: Pauli) -> Pauli:\n    \"\"\"Return the product of elements of the Pauli algebra\"\"\"\n    result_terms = []\n\n    for terms in product(*elements):\n        coeff = reduce(mul, [term[1] for term in terms])\n        ops = (term[0] for term in terms)\n        out = []\n        key = itemgetter(0)\n        for qubit, qops in groupby(heapq.merge(*ops, key=key), key=key):\n            res = next(qops)[1]  # Operator: X Y Z\n            for op in qops:\n                pair = res + op[1]\n                res, rescoeff = PAULI_PROD[pair]\n                coeff *= rescoeff\n            if res != 'I':\n                out.append((qubit, res))\n\n        p = Pauli(((tuple(out), coeff),))\n        result_terms.append(p)\n\n    return pauli_sum(*result_terms)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the element of the Pauli algebra to a non - negative integer power.", "response": "def pauli_pow(pauli: Pauli, exponent: int) -> Pauli:\n    \"\"\"\n    Raise an element of the Pauli algebra to a non-negative integer power.\n    \"\"\"\n\n    if not isinstance(exponent, int) or exponent < 0:\n        raise ValueError(\"The exponent must be a non-negative integer.\")\n\n    if exponent == 0:\n        return Pauli.identity()\n\n    if exponent == 1:\n        return pauli\n\n    # https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    y = Pauli.identity()\n    x = pauli\n    n = exponent\n    while n > 1:\n        if n % 2 == 0:  # Even\n            x = x * x\n            n = n // 2\n        else:           # Odd\n            y = x * y\n            x = x * x\n            n = (n - 1) // 2\n    return x * y"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef paulis_close(pauli0: Pauli, pauli1: Pauli, tolerance: float = TOLERANCE) \\\n        -> bool:\n    \"\"\"Returns: True if Pauli elements are almost identical.\"\"\"\n    pauli = pauli0 - pauli1\n    d = sum(abs(coeff)**2 for _, coeff in pauli.terms)\n    return d <= tolerance", "response": "Returns True if the Pauli elements are almost identical."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef paulis_commute(element0: Pauli, element1: Pauli) -> bool:\n\n    def _coincident_parity(term0: PauliTerm, term1: PauliTerm) -> bool:\n        non_similar = 0\n        key = itemgetter(0)\n\n        op0 = term0[0]\n        op1 = term1[0]\n        for _, qops in groupby(heapq.merge(op0, op1, key=key), key=key):\n\n            listqops = list(qops)\n            if len(listqops) == 2 and listqops[0][1] != listqops[1][1]:\n                non_similar += 1\n        return non_similar % 2 == 0\n\n    for term0, term1 in product(element0, element1):\n        if not _coincident_parity(term0, term1):\n            return False\n\n    return True", "response": "Returns true if the two elements of the Pauli algebra commute."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngathers the terms of a Pauli polynomial into commuting sets.", "response": "def pauli_commuting_sets(element: Pauli) -> Tuple[Pauli, ...]:\n    \"\"\"Gather the terms of a Pauli polynomial into commuting sets.\n\n    Uses the algorithm defined in (Raeisi, Wiebe, Sanders,\n    arXiv:1108.4318, 2011) to find commuting sets. Except uses commutation\n    check from arXiv:1405.5749v2\n    \"\"\"\n    if len(element) < 2:\n        return (element,)\n\n    groups: List[Pauli] = []  # typing: List[Pauli]\n\n    for term in element:\n        pterm = Pauli((term,))\n\n        assigned = False\n        for i, grp in enumerate(groups):\n            if paulis_commute(grp, pterm):\n                groups[i] = grp + pterm\n                assigned = True\n                break\n        if not assigned:\n            groups.append(pterm)\n\n    return tuple(groups)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef astensor(array: TensorLike) -> BKTensor:\n    array = np.asarray(array, dtype=CTYPE)\n    return array", "response": "Converts a numpy array to the backend s tensor object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef astensorproduct(array: TensorLike) -> BKTensor:\n    tensor = astensor(array)\n    N = int(math.log2(size(tensor)))\n    array = tensor.reshape([2]*N)\n    return array", "response": "Converts a numpy array to the backend s tensor object and reshapes\n    to [ 2 ] N"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the inner product between two tensors", "response": "def inner(tensor0: BKTensor, tensor1: BKTensor) -> BKTensor:\n    \"\"\"Return the inner product between two tensors\"\"\"\n    # Note: Relying on fact that vdot flattens arrays\n    return np.vdot(tensor0, tensor1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef productdiag(tensor: BKTensor) -> BKTensor:\n    N = rank(tensor)\n    tensor = reshape(tensor, [2**(N//2), 2**(N//2)])\n    tensor = np.diag(tensor)\n    tensor = reshape(tensor, [2]*(N//2))\n    return tensor", "response": "Returns the matrix diagonal of the product tensor"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninverts a dictionary. If not one_to_one then the inverted map will contain lists of former keys as values.", "response": "def invert_map(mapping: dict, one_to_one: bool = True) -> dict:\n    \"\"\"Invert a dictionary. If not one_to_one then the inverted\n    map will contain lists of former keys as values.\n    \"\"\"\n    if one_to_one:\n        inv_map = {value: key for key, value in mapping.items()}\n    else:\n        inv_map = {}\n        for key, value in mapping.items():\n            inv_map.setdefault(value, set()).add(key)\n\n    return inv_map"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a sequence of bits to an integer.", "response": "def bitlist_to_int(bitlist: Sequence[int]) -> int:\n    \"\"\"Converts a sequence of bits to an integer.\n\n    >>> from quantumflow.utils import bitlist_to_int\n    >>> bitlist_to_int([1, 0, 0])\n    4\n    \"\"\"\n    return int(''.join([str(d) for d in bitlist]), 2)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef int_to_bitlist(x: int, pad: int = None) -> Sequence[int]:\n    if pad is None:\n        form = '{:0b}'\n    else:\n        form = '{:0' + str(pad) + 'b}'\n\n    return [int(b) for b in form.format(x)]", "response": "Converts an integer to a binary sequence of bits."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef deprecated(func: Callable) -> Callable:\n    @functools.wraps(func)\n    def _new_func(*args: Any, **kwargs: Any) -> Any:\n        warnings.simplefilter('always', DeprecationWarning)  # turn off filter\n        warnings.warn(\"Call to deprecated function {}.\".format(func.__name__),\n                      category=DeprecationWarning,\n                      stacklevel=2)\n        warnings.simplefilter('default', DeprecationWarning)  # reset filter\n        return func(*args, **kwargs)\n    return _new_func", "response": "This is a decorator which can be used to mark functions\n    as deprecated. It will result in a warning being emitted\n        when the function is used."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the number of unique spanning trees of a graph using Kirchhoff s matrix tree theorem.", "response": "def spanning_tree_count(graph: nx.Graph) -> int:\n    \"\"\"Return the number of unique spanning trees of a graph, using\n    Kirchhoff's matrix tree theorem.\n    \"\"\"\n    laplacian = nx.laplacian_matrix(graph).toarray()\n    comatrix = laplacian[:-1, :-1]\n    det = np.linalg.det(comatrix)\n    count = int(round(det))\n    return count"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the octagonal tiling graph of MxNx8 nodes M and N.", "response": "def octagonal_tiling_graph(M: int, N: int) -> nx.Graph:\n    \"\"\"Return the octagonal tiling graph (4.8.8, truncated square tiling,\n    truncated quadrille) of MxNx8 nodes\n\n    The 'positions' node attribute gives node coordinates for the octagonal\n    tiling. (Nodes are located on a square lattice, and edge lengths are\n    uneven)\n    \"\"\"\n\n    grp = nx.Graph()\n    octogon = [[(1, 0), (0, 1)],\n               [(0, 1), (0, 2)],\n               [(0, 2), (1, 3)],\n               [(1, 3), (2, 3)],\n               [(2, 3), (3, 2)],\n               [(3, 2), (3, 1)],\n               [(3, 1), (2, 0)],\n               [(2, 0), (1, 0)]]\n    left = [[(1, 0), (1, -1)], [(2, 0), (2, -1)]]\n    up = [[(0, 1), (-1, 1)], [(0, 2), (-1, 2)]]\n\n    for m in range(M):\n        for n in range(N):\n            edges = octogon\n            if n != 0:\n                edges = edges + left\n            if m != 0:\n                edges = edges + up\n\n            for (x0, y0), (x1, y1) in edges:\n                grp.add_edge((m*4+x0, n*4+y0), (m*4+x1, n*4+y1))\n\n    positions = {node: node for node in grp}\n    nx.set_node_attributes(grp, positions, 'positions')\n\n    return grp"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a floating point number to a Fraction with a small denominator.", "response": "def rationalize(flt: float, denominators: Set[int] = None) -> Fraction:\n    \"\"\"Convert a floating point number to a Fraction with a small\n    denominator.\n\n    Args:\n        flt:            A floating point number\n        denominators:   Collection of standard denominators. Default is\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 16, 32, 64, 128, 256, 512,\n            1024, 2048, 4096, 8192\n\n    Raises:\n        ValueError:     If cannot rationalize float\n    \"\"\"\n    if denominators is None:\n        denominators = _DENOMINATORS\n    frac = Fraction.from_float(flt).limit_denominator()\n    if frac.denominator not in denominators:\n        raise ValueError('Cannot rationalize')\n    return frac"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef symbolize(flt: float) -> sympy.Symbol:\n    try:\n        ratio = rationalize(flt)\n        res = sympy.simplify(ratio)\n    except ValueError:\n        ratio = rationalize(flt/np.pi)\n        res = sympy.simplify(ratio) * sympy.pi\n    return res", "response": "Attempt to convert a real number into a simpler symbolic taxonomy representation."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pyquil_to_image(program: pyquil.Program) -> PIL.Image:  # pragma: no cover\n    circ = pyquil_to_circuit(program)\n    latex = circuit_to_latex(circ)\n    img = render_latex(latex)\n    return img", "response": "Returns an image of a pyquil circuit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef circuit_to_pyquil(circuit: Circuit) -> pyquil.Program:\n    prog = pyquil.Program()\n\n    for elem in circuit.elements:\n        if isinstance(elem, Gate) and elem.name in QUIL_GATES:\n            params = list(elem.params.values()) if elem.params else []\n            prog.gate(elem.name, params, elem.qubits)\n        elif isinstance(elem, Measure):\n            prog.measure(elem.qubit, elem.cbit)\n        else:\n            # FIXME: more informative error message\n            raise ValueError('Cannot convert operation to pyquil')\n\n    return prog", "response": "Convert a QuantumFlow circuit to a pyQuil program"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pyquil_to_circuit(program: pyquil.Program) -> Circuit:\n\n    circ = Circuit()\n    for inst in program.instructions:\n        # print(type(inst))\n        if isinstance(inst, pyquil.Declare):            # Ignore\n            continue\n        if isinstance(inst, pyquil.Halt):               # Ignore\n            continue\n        if isinstance(inst, pyquil.Pragma):             # TODO Barrier?\n            continue\n        elif isinstance(inst, pyquil.Measurement):\n            circ += Measure(inst.qubit.index)\n        # elif isinstance(inst, pyquil.ResetQubit):     # TODO\n        #     continue\n        elif isinstance(inst, pyquil.Gate):\n            defgate = STDGATES[inst.name]\n            gate = defgate(*inst.params)\n            qubits = [q.index for q in inst.qubits]\n            gate = gate.relabel(qubits)\n            circ += gate\n        else:\n            raise ValueError('PyQuil program is not protoquil')\n\n    return circ", "response": "Convert a ProtoQuil program to a QuantumFlow Circuit"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef quil_to_program(quil: str) -> Program:\n    pyquil_instructions = pyquil.parser.parse(quil)\n    return pyquil_to_program(pyquil_instructions)", "response": "Parse a quil program and return a Program object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a pyQuil program to a QuantumFlow program.", "response": "def pyquil_to_program(program: pyquil.Program) -> Program:\n    \"\"\"Convert a  pyQuil program to a QuantumFlow Program\"\"\"\n    def _reg(mem: Any) -> Any:\n        if isinstance(mem, pyquil.MemoryReference):\n            return Register(mem.name)[mem.offset]\n        return mem\n\n    prog = Program()\n    for inst in program:\n        if isinstance(inst, pyquil.Gate):\n            qubits = [q.index for q in inst.qubits]\n            if inst.name in STDGATES:\n                defgate = STDGATES[inst.name]\n                gate = defgate(*inst.params)\n                gate = gate.relabel(qubits)\n                prog += gate\n            else:\n                prog += Call(inst.name, inst.params, qubits)\n\n        elif isinstance(inst, pyquil.ClassicalEqual):\n            prog += EQ(_reg(inst.target), _reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalLessThan):\n            prog += LT(_reg(inst.target), _reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalLessEqual):\n            prog += LE(_reg(inst.target), _reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalGreaterThan):\n            prog += GT(_reg(inst.target), _reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalGreaterEqual):\n            prog += GE(_reg(inst.target), _reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalAdd):\n            prog += Add(_reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalMul):\n            prog += Mul(_reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalDiv):\n            prog += Div(_reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalSub):\n            prog += Sub(_reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalAnd):\n            prog += And(_reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalExchange):\n            prog += Exchange(_reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalInclusiveOr):\n            prog += Ior(_reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalMove):\n            # Also handles deprecated ClassicalTrue and ClassicalFalse\n            prog += Move(_reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalNeg):\n            prog += Neg(_reg(inst.target))\n\n        elif isinstance(inst, pyquil.ClassicalNot):\n            prog += Not(_reg(inst.target))\n\n        elif isinstance(inst, pyquil.ClassicalExclusiveOr):\n            target = _reg(inst.left)\n            source = _reg(inst.right)\n            prog += Xor(target, source)\n\n        elif isinstance(inst, pyquil.Declare):\n            prog += Declare(inst.name,\n                            inst.memory_type,\n                            inst.memory_size,\n                            inst.shared_region)\n\n        elif isinstance(inst, pyquil.Halt):\n            prog += Halt()\n\n        elif isinstance(inst, pyquil.Jump):\n            prog += Jump(inst.target.name)\n\n        elif isinstance(inst, pyquil.JumpTarget):\n            prog += Label(inst.label.name)\n\n        elif isinstance(inst, pyquil.JumpWhen):\n            prog += JumpWhen(inst.target.name, _reg(inst.condition))\n\n        elif isinstance(inst, pyquil.JumpUnless):\n            prog += JumpUnless(inst.target.name, _reg(inst.condition))\n\n        elif isinstance(inst, pyquil.Pragma):\n            prog += Pragma(inst.command, inst.args, inst.freeform_string)\n\n        elif isinstance(inst, pyquil.Measurement):\n            if inst.classical_reg is None:\n                prog += Measure(inst.qubit.index)\n            else:\n                prog += Measure(inst.qubit.index, _reg(inst.classical_reg))\n\n        elif isinstance(inst, pyquil.Nop):\n            prog += Nop()\n\n        elif isinstance(inst, pyquil.Wait):\n            prog += Wait()\n\n        elif isinstance(inst, pyquil.Reset):\n            prog += Reset()\n\n        elif isinstance(inst, pyquil.ResetQubit):\n            prog += Reset(inst.qubit)\n\n        elif isinstance(inst, pyquil.ClassicalStore):\n            prog += Store(inst.target, _reg(inst.left), _reg(inst.right))\n\n        elif isinstance(inst, pyquil.ClassicalLoad):\n            prog += Load(_reg(inst.target), inst.left, _reg(inst.right))\n\n        # elif isinstance(inst, pyquil.ClassicalConvert):\n        #     prog += Convert(inst.target, _reg(inst.left), _reg(inst.right))\n\n        else:\n            raise ValueError('Unknown pyQuil instruction: {}'\n                             .format(str(inst)))   # pragma: no cover\n\n    return prog"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a QuantumFlow state to a pyQuil Wavefunction", "response": "def state_to_wavefunction(state: State) -> pyquil.Wavefunction:\n    \"\"\"Convert a QuantumFlow state to a pyQuil Wavefunction\"\"\"\n    # TODO: qubits?\n    amplitudes = state.vec.asarray()\n\n    # pyQuil labels states backwards.\n    amplitudes = amplitudes.transpose()\n    amplitudes = amplitudes.reshape([amplitudes.size])\n    return pyquil.Wavefunction(amplitudes)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading a pyQuil program and initialize the QVM into a fresh state.", "response": "def load(self, binary: pyquil.Program) -> 'QuantumFlowQVM':\n        \"\"\"\n        Load a pyQuil program, and initialize QVM into a fresh state.\n\n        Args:\n            binary: A pyQuil program\n        \"\"\"\n\n        assert self.status in ['connected', 'done']\n        prog = quil_to_program(str(binary))\n\n        self._prog = prog\n        self.program = binary\n        self.status = 'loaded'\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self) -> 'QuantumFlowQVM':\n        assert self.status in ['loaded']\n        self.status = 'running'\n        self._ket = self._prog.run()\n        # Should set state to 'done' after run complete.\n        # Makes no sense to keep status at running. But pyQuil's\n        # QuantumComputer calls wait() after run, which expects state to be\n        # 'running', and whose only effect to is to set state to 'done'\n        return self", "response": "Run a previously loaded program and return self."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wavefunction(self) -> pyquil.Wavefunction:\n        assert self.status == 'done'\n        assert self._ket is not None\n        wavefn = state_to_wavefunction(self._ket)\n        return wavefn", "response": "Return the wavefunction of a completed program."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of circuit identities each consisting of a name and and two equivalent Circuits.", "response": "def identities():\n    \"\"\" Return a list of circuit identities, each consisting of a name, and\n    two equivalent Circuits.\"\"\"\n\n    circuit_identities = []\n\n    # Pick random parameter\n    theta = np.pi * np.random.uniform()\n\n    # Single qubit gate identities\n\n    name = \"Hadamard is own inverse\"\n    circ0 = Circuit([H(0), H(0)])\n    circ1 = Circuit([I(0)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Hadamards convert X to Z\"\n    circ0 = Circuit([H(0), X(0), H(0)])\n    circ1 = Circuit([Z(0)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Hadamards convert Z to X\"\n    circ0 = Circuit([H(0), Z(0), H(0)])\n    circ1 = Circuit([X(0)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"S sandwich converts X to Y\"\n    circ0 = Circuit([S(0).H, X(0), S(0)])\n    circ1 = Circuit([Y(0)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"S sandwich converts Y to X\"\n    circ0 = Circuit([S(0), Y(0), S(0).H])\n    circ1 = Circuit([X(0)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Hadamards convert RZ to RX\"\n    circ0 = Circuit([H(0), RZ(theta, 0), H(0)])\n    circ1 = Circuit([RX(theta, 0)])\n    circuit_identities.append([name, circ0, circ1])\n\n    # ZYZ Decompositions\n\n    name = \"Hadamard ZYZ decomposition\"\n    circ0 = Circuit([H(0)])\n    circ1 = Circuit([Z(0), Y(0)**0.5])\n    circuit_identities.append([name, circ0, circ1])\n\n    # CNOT identities\n\n    name = \"CZ to CNOT\"\n    circ0 = Circuit([CZ(0, 1)])\n    circ1 = Circuit([H(1), CNOT(0, 1), H(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"SWAP to 3 CNOTs\"\n    circ0 = Circuit([SWAP(0, 1)])\n    circ1 = Circuit([CNOT(0, 1), CNOT(1, 0), CNOT(0, 1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"SWAP to 3 CZs\"\n    circ0 = Circuit([SWAP(0, 1)])\n    circ1 = Circuit([H(1), CZ(0, 1), H(0), H(1), CZ(1, 0), H(0), H(1),\n                     CZ(0, 1), H(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"ISWAP decomposition to SWAP and CNOT\"\n    circ0 = Circuit([ISWAP(0, 1)])\n    circ1 = Circuit([SWAP(0, 1), H(1), CNOT(0, 1), H(1), S(0), S(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"ISWAP decomposition to SWAP and CZ\"\n    # This makes it clear why you can commute RZ's across ISWAP\n    circ0 = Circuit([ISWAP(0, 1)])\n    circ1 = Circuit([SWAP(0, 1), CZ(0, 1), S(0), S(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    # http://info.phys.unm.edu/~caves/courses/qinfo-f14/lectures/lectures21-23.pdf\n    name = \"CNOT sandwich with X on control\"\n    circ0 = Circuit([CNOT(0, 1), X(0), CNOT(0, 1)])\n    circ1 = Circuit([X(0), X(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    # http://info.phys.unm.edu/~caves/courses/qinfo-f14/lectures/lectures21-23.pdf\n    name = \"CNOT sandwich with Z on target\"\n    circ0 = Circuit([CNOT(0, 1), Z(1), CNOT(0, 1)])\n    circ1 = Circuit([Z(0), Z(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"DCNOT (Double-CNOT) to iSWAP\"\n    circ0 = Circuit([CNOT(0, 1), CNOT(1, 0)])\n    circ1 = Circuit([H(0), S(0).H, S(1).H, ISWAP(0, 1), H(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    # Commuting single qubit gates across 2 qubit games\n\n    name = \"Commute X on CNOT target\"\n    circ0 = Circuit([X(1), CNOT(0, 1)])\n    circ1 = Circuit([CNOT(0, 1), X(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Commute X on CNOT control\"\n    circ0 = Circuit([X(0), CNOT(0, 1)])\n    circ1 = Circuit([CNOT(0, 1), X(0), X(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Commute Z on CNOT target\"\n    circ0 = Circuit([Z(1), CNOT(0, 1)])\n    circ1 = Circuit([CNOT(0, 1), Z(0), Z(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Commute Z on CNOT control\"\n    circ0 = Circuit([Z(0), CNOT(0, 1)])\n    circ1 = Circuit([CNOT(0, 1), Z(0)])\n    circuit_identities.append([name, circ0, circ1])\n\n    #  Canonical gate identities\n\n    name = \"Canonical gates: CZ to ZZ\"\n    circ0 = Circuit([CZ(0, 1),\n                     S(0),\n                     S(1)])\n    circ1 = Circuit([ZZ(0.5, 0, 1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Canonical gates: XX to ZZ\"\n    circ0 = Circuit([H(0), H(1),\n                     XX(0.5, 0, 1),\n                     H(0), H(1)])\n    circ1 = Circuit([ZZ(0.5, 0, 1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Canonical gates: CNOT to XX\"\n    circ0 = Circuit([CNOT(0, 1)])\n    circ1 = Circuit([H(0),\n                     XX(0.5, 0, 1),\n                     H(0), H(1),\n                     S(0).H, S(1).H,\n                     H(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Canonical gates: SWAP to Canonical\"\n    circ0 = Circuit([SWAP(0, 1)])\n    circ1 = Circuit([CANONICAL(0.5, 0.5, 0.5, 0, 1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"ISWAP to Canonical\"\n    circ0 = Circuit([ISWAP(0, 1)])\n    circ1 = Circuit([CANONICAL(0.5, 0.5, 1.0, 0, 1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"ISWAP to Canonical in Weyl chamber\"\n    circ0 = Circuit([ISWAP(0, 1)])\n    circ1 = Circuit([X(0), CANONICAL(0.5, 0.5, 0.0, 0, 1), X(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"DCNOT to Canonical\"\n    circ0 = Circuit([CNOT(0, 1), CNOT(1, 0)])\n    circ1 = Circuit([H(0), S(0).H, S(1).H, X(0),\n                     CANONICAL(0.5, 0.5, 0.0, 0, 1), X(1), H(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    # Multi-qubit circuits\n\n    name = \"CNOT controls commute\"\n    circ0 = Circuit([CNOT(1, 0), CNOT(1, 2)])\n    circ1 = Circuit([CNOT(1, 2), CNOT(1, 0)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"CNOT targets commute\"\n    circ0 = Circuit([CNOT(0, 1), CNOT(2, 1)])\n    circ1 = Circuit([CNOT(2, 1), CNOT(0, 1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Commutation of CNOT target/control\"\n    circ0 = Circuit([CNOT(0, 1), CNOT(1, 2)])\n    circ1 = Circuit([CNOT(1, 2), CNOT(0, 2), CNOT(0, 1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Indirect CNOT and 4 CNOTS with intermediate qubit\"\n    circ0 = Circuit([CNOT(0, 2), I(1)])\n    circ1 = Circuit([CNOT(0, 1),\n                     CNOT(1, 2),\n                     CNOT(0, 1),\n                     CNOT(1, 2)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"CZs with shared shared qubit commute\"\n    circ0 = Circuit([CZ(0, 1), CZ(1, 2)])\n    circ1 = Circuit([CZ(1, 2), CZ(0, 1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"Toffoli gate CNOT decomposition\"\n    circ0 = Circuit([CCNOT(0, 1, 2)])\n    circ1 = ccnot_circuit([0, 1, 2])\n    circuit_identities.append([name, circ0, circ1])\n\n    # Parametric circuits\n\n    name = \"ZZ to CNOTs\"  # 1108.4318\n    circ0 = Circuit([ZZ(theta/np.pi, 0, 1)])\n    circ1 = Circuit([CNOT(0, 1), RZ(theta, 1), CNOT(0, 1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"XX to CNOTs\"  # 1108.4318\n    circ0 = Circuit([XX(theta/np.pi, 0, 1)])\n    circ1 = Circuit([H(0), H(1), CNOT(0, 1), RZ(theta, 1), CNOT(0, 1),\n                     H(0), H(1)])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"XX to CNOTs (2)\"\n    circ0 = Circuit([XX(theta/np.pi, 0, 1)])\n    circ1 = Circuit([Y(0)**0.5, Y(1)**0.5, CNOT(0, 1), RZ(theta, 1),\n                     CNOT(0, 1), Y(0)**-0.5, Y(1)**-0.5])\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"YY to CNOTs\"\n    circ0 = Circuit([YY(theta/np.pi, 0, 1)])\n    circ1 = Circuit([X(0)**0.5, X(1)**0.5, CNOT(0, 1), RZ(theta, 1),\n                     CNOT(0, 1), X(0)**-0.5, X(1)**-0.5])\n    circuit_identities.append([name, circ0, circ1])\n\n    def cphase_to_zz(gate: CPHASE):\n        t = - gate.params['theta'] / (2 * np.pi)\n        q0, q1 = gate.qubits\n        circ = Circuit([ZZ(t, q0, q1), TZ(-t, q0), TZ(-t, q1)])\n        return circ\n\n    def cphase00_to_zz(gate: CPHASE00):\n        t = - gate.params['theta'] / (2 * np.pi)\n        q0, q1 = gate.qubits\n        circ = Circuit([X(0), X(1),\n                        ZZ(t, q0, q1), TZ(-t, q0), TZ(-t, q1),\n                        X(0), X(1)])\n        return circ\n\n    def cphase01_to_zz(gate: CPHASE00):\n        t = - gate.params['theta'] / (2 * np.pi)\n        q0, q1 = gate.qubits\n        circ = Circuit([X(0),\n                        ZZ(t, q0, q1), TZ(-t, q0), TZ(-t, q1),\n                        X(0)])\n        return circ\n\n    def cphase10_to_zz(gate: CPHASE00):\n        t = - gate.params['theta'] / (2 * np.pi)\n        q0, q1 = gate.qubits\n        circ = Circuit([X(1),\n                        ZZ(t, q0, q1), TZ(-t, q0), TZ(-t, q1),\n                        X(1)])\n        return circ\n\n    name = \"CPHASE to ZZ\"\n    gate = CPHASE(theta, 0, 1)\n    circ0 = Circuit([gate])\n    circ1 = cphase_to_zz(gate)\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"CPHASE00 to ZZ\"\n    gate = CPHASE00(theta, 0, 1)\n    circ0 = Circuit([gate])\n    circ1 = cphase00_to_zz(gate)\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"CPHASE01 to ZZ\"\n    gate = CPHASE01(theta, 0, 1)\n    circ0 = Circuit([gate])\n    circ1 = cphase01_to_zz(gate)\n    circuit_identities.append([name, circ0, circ1])\n\n    name = \"CPHASE10 to ZZ\"\n    gate = CPHASE10(theta, 0, 1)\n    circ0 = Circuit([gate])\n    circ1 = cphase10_to_zz(gate)\n    circuit_identities.append([name, circ0, circ1])\n\n    return circuit_identities"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef evaluate(tensor: BKTensor) -> TensorLike:\n    if isinstance(tensor, _DTYPE):\n        if torch.numel(tensor) == 1:\n            return tensor.item()\n        if tensor.numel() == 2:\n            return tensor[0].cpu().numpy() + 1.0j * tensor[1].cpu().numpy()\n\n        return tensor[0].cpu().numpy() + 1.0j * tensor[1].cpu().numpy()\n    return tensor", "response": "Return the value of a tensor"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rank(tensor: BKTensor) -> int:\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "response": "Return the number of dimensions of a tensor"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inner(tensor0: BKTensor, tensor1: BKTensor) -> BKTensor:\n    N = torch.numel(tensor0[0])\n    tensor0_real = tensor0[0].contiguous().view(N)\n    tensor0_imag = tensor0[1].contiguous().view(N)\n    tensor1_real = tensor1[0].contiguous().view(N)\n    tensor1_imag = tensor1[1].contiguous().view(N)\n\n    res = (torch.matmul(tensor0_real, tensor1_real)\n           + torch.matmul(tensor0_imag, tensor1_imag),\n           torch.matmul(tensor0_real, tensor1_imag)\n           - torch.matmul(tensor0_imag, tensor1_real))\n\n    return _DTYPE(res)", "response": "Return the inner product between two tensors"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the quantum fidelity between pure states.", "response": "def state_fidelity(state0: State, state1: State) -> bk.BKTensor:\n    \"\"\"Return the quantum fidelity between pure states.\"\"\"\n    assert state0.qubits == state1.qubits   # FIXME\n    tensor = bk.absolute(bk.inner(state0.tensor, state1.tensor))**bk.fcast(2)\n    return tensor"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef state_angle(ket0: State, ket1: State) -> bk.BKTensor:\n    return fubini_study_angle(ket0.vec, ket1.vec)", "response": "The Fubini - Study angle between states."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef states_close(state0: State, state1: State,\n                 tolerance: float = TOLERANCE) -> bool:\n    \"\"\"Returns True if states are almost identical.\n\n    Closeness is measured with the metric Fubini-Study angle.\n    \"\"\"\n    return vectors_close(state0.vec, state1.vec, tolerance)", "response": "Returns True if states are almost identical."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the purity of a mixed quantum state.", "response": "def purity(rho: Density) -> bk.BKTensor:\n    \"\"\"\n    Calculate the purity of a mixed quantum state.\n\n    Purity, defined as tr(rho^2), has an upper bound of 1 for a pure state,\n    and a lower bound of 1/D (where D is the Hilbert space dimension) for a\n    competently mixed state.\n\n    Two closely related measures are the linear entropy, 1- purity, and the\n    participation ratio, 1/purity.\n    \"\"\"\n    tensor = rho.tensor\n    N = rho.qubit_nb\n    matrix = bk.reshape(tensor, [2**N, 2**N])\n    return bk.trace(bk.matmul(matrix, matrix))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the fidelity F between two mixed quantum states.", "response": "def fidelity(rho0: Density, rho1: Density) -> float:\n    \"\"\"Return the fidelity F(rho0, rho1) between two mixed quantum states.\n\n    Note: Fidelity cannot be calculated entirely within the tensor backend.\n    \"\"\"\n    assert rho0.qubit_nb == rho1.qubit_nb   # FIXME\n\n    rho1 = rho1.permute(rho0.qubits)\n    op0 = asarray(rho0.asoperator())\n    op1 = asarray(rho1.asoperator())\n\n    fid = np.real((np.trace(sqrtm(sqrtm(op0) @ op1 @ sqrtm(op0)))) ** 2)\n    fid = min(fid, 1.0)\n    fid = max(fid, 0.0)     # Correct for rounding errors\n\n    return fid"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bures_distance(rho0: Density, rho1: Density) -> float:\n    fid = fidelity(rho0, rho1)\n    op0 = asarray(rho0.asoperator())\n    op1 = asarray(rho1.asoperator())\n    tr0 = np.trace(op0)\n    tr1 = np.trace(op1)\n\n    return np.sqrt(tr0 + tr1 - 2.*np.sqrt(fid))", "response": "Return the Bures distance between mixed quantum states rho0 and rho1."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the Bures angle between mixed quantum states.", "response": "def bures_angle(rho0: Density, rho1: Density) -> float:\n    \"\"\"Return the Bures angle between mixed quantum states\n\n    Note: Bures angle cannot be calculated within the tensor backend.\n    \"\"\"\n    return np.arccos(np.sqrt(fidelity(rho0, rho1)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef densities_close(rho0: Density, rho1: Density,\n                    tolerance: float = TOLERANCE) -> bool:\n    \"\"\"Returns True if densities are almost identical.\n\n    Closeness is measured with the metric Fubini-Study angle.\n    \"\"\"\n    return vectors_close(rho0.vec, rho1.vec, tolerance)", "response": "Returns True if densities are almost identical."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the von - Neumann entropy of a mixed quantum state.", "response": "def entropy(rho: Density, base: float = None) -> float:\n    \"\"\"\n    Returns the von-Neumann entropy of a mixed quantum state.\n\n    Args:\n        rho:    A density matrix\n        base:   Optional logarithm base. Default is base e, and entropy is\n                measures in nats. For bits set base to 2.\n\n    Returns:\n        The von-Neumann entropy of rho\n    \"\"\"\n    op = asarray(rho.asoperator())\n    probs = np.linalg.eigvalsh(op)\n    probs = np.maximum(probs, 0.0)  # Compensate for floating point errors\n    return scipy.stats.entropy(probs, base=base)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes the bipartite von - Neumann mutual information of a mixed .", "response": "def mutual_info(rho: Density,\n                qubits0: Qubits,\n                qubits1: Qubits = None,\n                base: float = None) -> float:\n    \"\"\"Compute the bipartite von-Neumann mutual information of a mixed\n    quantum state.\n\n    Args:\n        rho:    A density matrix of the complete system\n        qubits0: Qubits of system 0\n        qubits1: Qubits of system 1. If none, taken to be all remaining qubits\n        base:   Optional logarithm base. Default is base e\n\n    Returns:\n        The bipartite von-Neumann mutual information.\n    \"\"\"\n    if qubits1 is None:\n        qubits1 = tuple(set(rho.qubits) - set(qubits0))\n\n    rho0 = rho.partial_trace(qubits1)\n    rho1 = rho.partial_trace(qubits0)\n\n    ent = entropy(rho, base)\n    ent0 = entropy(rho0, base)\n    ent1 = entropy(rho1, base)\n\n    return ent0 + ent1 - ent"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef gates_close(gate0: Gate, gate1: Gate,\n                tolerance: float = TOLERANCE) -> bool:\n    \"\"\"Returns: True if gates are almost identical.\n\n    Closeness is measured with the gate angle.\n    \"\"\"\n    return vectors_close(gate0.vec, gate1.vec, tolerance)", "response": "Returns True if the gates are almost identical."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the channels are almost identical.", "response": "def channels_close(chan0: Channel, chan1: Channel,\n                   tolerance: float = TOLERANCE) -> bool:\n    \"\"\"Returns: True if channels are almost identical.\n\n    Closeness is measured with the channel angle.\n    \"\"\"\n    return vectors_close(chan0.vec, chan1.vec, tolerance)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef diamond_norm(chan0: Channel, chan1: Channel) -> float:\n    # Kudos: Based on MatLab code written by Marcus P. da Silva\n    # (https://github.com/BBN-Q/matlab-diamond-norm/)\n\n    if set(chan0.qubits) != set(chan1.qubits):\n        raise ValueError('Channels must operate on same qubits')\n\n    if chan0.qubits != chan1.qubits:\n        chan1 = chan1.permute(chan0.qubits)\n\n    N = chan0.qubit_nb\n    dim = 2**N\n\n    choi0 = asarray(chan0.choi())\n    choi1 = asarray(chan1.choi())\n\n    delta_choi = choi0 - choi1\n\n    # Density matrix must be Hermitian, positive semidefinite, trace 1\n    rho = cvx.Variable([dim, dim], complex=True)\n    constraints = [rho == rho.H]\n    constraints += [rho >> 0]\n    constraints += [cvx.trace(rho) == 1]\n\n    # W must be Hermitian, positive semidefinite\n    W = cvx.Variable([dim**2, dim**2], complex=True)\n    constraints += [W == W.H]\n    constraints += [W >> 0]\n\n    constraints += [(W - cvx.kron(np.eye(dim), rho)) << 0]\n\n    J = cvx.Parameter([dim**2, dim**2], complex=True)\n    objective = cvx.Maximize(cvx.real(cvx.trace(J.H * W)))\n\n    prob = cvx.Problem(objective, constraints)\n\n    J.value = delta_choi\n    prob.solve()\n\n    dnorm = prob.value * 2\n\n    # Diamond norm is between 0 and 2. Correct for floating point errors\n    dnorm = min(2, dnorm)\n    dnorm = max(0, dnorm)\n\n    return dnorm", "response": "Return the diamond norm between two completely positive channels."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef outer_product(vec0: QubitVector, vec1: QubitVector) -> QubitVector:\n    R = vec0.rank\n    R1 = vec1.rank\n\n    N0 = vec0.qubit_nb\n    N1 = vec1.qubit_nb\n\n    if R != R1:\n        raise ValueError('Incompatibly vectors. Rank must match')\n\n    if not set(vec0.qubits).isdisjoint(vec1.qubits):\n        raise ValueError('Overlapping qubits')\n\n    qubits: Qubits = tuple(vec0.qubits) + tuple(vec1.qubits)\n\n    tensor = bk.outer(vec0.tensor, vec1.tensor)\n\n    # Interleave (super)-operator axes\n    # R = 1  perm = (0, 1)\n    # R = 2  perm = (0, 2, 1, 3)\n    # R = 4  perm = (0, 4, 1, 5, 2, 6, 3, 7)\n    tensor = bk.reshape(tensor, ([2**N0] * R) + ([2**N1] * R))\n    perm = [idx for ij in zip(range(0, R), range(R, 2*R)) for idx in ij]\n    tensor = bk.transpose(tensor, perm)\n\n    return QubitVector(tensor, qubits)", "response": "Direct product of two qubit vectors."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the Fubini - Study angle between two qubits.", "response": "def fubini_study_angle(vec0: QubitVector, vec1: QubitVector) -> bk.BKTensor:\n    \"\"\"Calculate the Fubini\u2013Study metric between elements of a Hilbert space.\n\n    The Fubini\u2013Study metric is a distance measure between vectors in a\n    projective Hilbert space. For gates this space is the Hilbert space of\n    operators induced by the Hilbert-Schmidt inner product.\n    For 1-qubit rotation gates, RX, RY and RZ, this is half the angle (theta)\n    in the Bloch sphere.\n\n    The Fubini\u2013Study metric between states is equal to the Burr angle\n    between pure states.\n    \"\"\"\n    if vec0.rank != vec1.rank or vec0.qubit_nb != vec1.qubit_nb:\n        raise ValueError('Incompatibly vectors. Qubits and rank must match')\n\n    vec1 = vec1.permute(vec0.qubits)  # Make sure qubits in same order\n\n    t0 = vec0.tensor\n    t1 = vec1.tensor\n    hs01 = bk.inner(t0, t1)  # Hilbert-Schmidt inner product\n    hs00 = bk.inner(t0, t0)\n    hs11 = bk.inner(t1, t1)\n    ratio = bk.absolute(hs01) / bk.sqrt(bk.absolute(hs00*hs11))\n    ratio = bk.minimum(ratio, bk.fcast(1.))  # Compensate for rounding errors.\n    return bk.arccos(ratio)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if vectors in close in the projective Hilbert space.", "response": "def vectors_close(vec0: QubitVector, vec1: QubitVector,\n                  tolerance: float = TOLERANCE) -> bool:\n    \"\"\"Return True if vectors in close in the projective Hilbert space.\n\n    Similarity is measured with the Fubini\u2013Study metric.\n    \"\"\"\n    if vec0.rank != vec1.rank:\n        return False\n\n    if vec0.qubit_nb != vec1.qubit_nb:\n        return False\n\n    if set(vec0.qubits) ^ set(vec1.qubits):\n        return False\n\n    return bk.evaluate(fubini_study_angle(vec0, vec1)) <= tolerance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef qubits_count_tuple(qubits: Union[int, Qubits]) -> Tuple[int, Qubits]:\n    if isinstance(qubits, int):\n        return qubits, tuple(range(qubits))\n    return len(qubits), qubits", "response": "Utility method for unraveling qubits"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns tensor with qubit indices flattened", "response": "def flatten(self) -> bk.BKTensor:\n        \"\"\"Return tensor with with qubit indices flattened\"\"\"\n        N = self.qubit_nb\n        R = self.rank\n        return bk.reshape(self.tensor, [2**N]*R)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef relabel(self, qubits: Qubits) -> 'QubitVector':\n        qubits = tuple(qubits)\n        assert len(qubits) == self.qubit_nb\n        vec = copy(self)\n        vec.qubits = qubits\n        return vec", "response": "Return a copy of this vector with new qubits"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef permute(self, qubits: Qubits) -> 'QubitVector':\n\n        if qubits == self.qubits:\n            return self\n\n        N = self.qubit_nb\n        assert len(qubits) == N\n\n        # Will raise a value error if qubits don't match\n        indices = [self.qubits.index(q) for q in qubits]  # type: ignore\n        perm: List[int] = []\n        for rr in range(0, self.rank):\n            perm += [rr * N + idx for idx in indices]\n        tensor = bk.transpose(self.tensor, perm)\n\n        return QubitVector(tensor, qubits)", "response": "Permute the order of the qubits"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the conjugate transpose of this tensor.", "response": "def H(self) -> 'QubitVector':\n        \"\"\"Return the conjugate transpose of this tensor.\"\"\"\n        N = self.qubit_nb\n        R = self.rank\n\n        # (super) operator transpose\n        tensor = self.tensor\n        tensor = bk.reshape(tensor, [2**(N*R//2)] * 2)\n        tensor = bk.transpose(tensor)\n        tensor = bk.reshape(tensor, [2] * R * N)\n\n        tensor = bk.conj(tensor)\n\n        return QubitVector(tensor, self.qubits)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the norm of this vector", "response": "def norm(self) -> bk.BKTensor:\n        \"\"\"Return the norm of this vector\"\"\"\n        return bk.absolute(bk.inner(self.tensor, self.tensor))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the trace of the current set of entries of the current set of entries.", "response": "def trace(self) -> bk.BKTensor:\n        \"\"\"\n        Return the trace, the sum of the diagonal elements of the (super)\n        operator.\n        \"\"\"\n        N = self.qubit_nb\n        R = self.rank\n        if R == 1:\n            raise ValueError('Cannot take trace of vector')\n\n        tensor = bk.reshape(self.tensor, [2**(N*R//2)] * 2)\n        tensor = bk.trace(tensor)\n        return tensor"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef partial_trace(self, qubits: Qubits) -> 'QubitVector':\n        N = self.qubit_nb\n        R = self.rank\n        if R == 1:\n            raise ValueError('Cannot take trace of vector')\n\n        new_qubits: List[Qubit] = list(self.qubits)\n        for q in qubits:\n            new_qubits.remove(q)\n\n        if not new_qubits:\n            raise ValueError('Cannot remove all qubits with partial_trace.')\n\n        indices = [self.qubits.index(qubit) for qubit in qubits]\n        subscripts = list(EINSUM_SUBSCRIPTS)[0:N*R]\n        for idx in indices:\n            for r in range(1, R):\n                subscripts[r * N + idx] = subscripts[idx]\n        subscript_str = ''.join(subscripts)\n\n        # Only numpy's einsum works with repeated subscripts\n        tensor = self.asarray()\n        tensor = np.einsum(subscript_str, tensor)\n\n        return QubitVector(tensor, new_qubits)", "response": "Return the partial trace over some subset of qubits."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fit_zyz(target_gate):\n\n    steps = 1000\n\n    dev = '/gpu:0' if bk.DEVICE == 'gpu' else '/cpu:0'\n\n    with tf.device(dev):\n        t = tf.Variable(tf.random.normal([3]))\n\n        def loss_fn():\n            \"\"\"Loss\"\"\"\n            gate = qf.ZYZ(t[0], t[1], t[2])\n            ang = qf.fubini_study_angle(target_gate.vec, gate.vec)\n            return ang\n\n        opt = tf.optimizers.Adam(learning_rate=0.001)\n        opt.minimize(loss_fn, var_list=[t])\n\n        for step in range(steps):\n            opt.minimize(loss_fn, var_list=[t])\n            loss = loss_fn()\n            print(step, loss.numpy())\n            if loss < 0.01:\n                break\n        else:\n            print(\"Failed to coverge\")\n\n    return bk.evaluate(t)", "response": "Fits a universal ZYZ gate to a universal ZYZ object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes program state. Called by program. run and. evolve.", "response": "def _initilize(self, state: State) -> State:\n        \"\"\"Initialize program state. Called by program.run() and .evolve()\"\"\"\n\n        targets = {}\n        for pc, instr in enumerate(self):\n            if isinstance(instr, Label):\n                targets[instr.target] = pc\n\n        state = state.update({PC: 0,\n                              TARGETS: targets,\n                              NAMEDGATES: STDGATES.copy()})\n        return state"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self, ket: State = None) -> State:\n        if ket is None:\n            qubits = self.qubits\n            ket = zero_state(qubits)\n\n        ket = self._initilize(ket)\n\n        pc = 0\n        while pc >= 0 and pc < len(self):\n            instr = self.instructions[pc]\n            ket = ket.update({PC: pc + 1})\n            ket = instr.run(ket)\n            pc = ket.memory[PC]\n\n        return ket", "response": "Compiles and runs a program."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a copy of this Gate with new qubits", "response": "def relabel(self, qubits: Qubits) -> 'Gate':\n        \"\"\"Return a copy of this Gate with new qubits\"\"\"\n        gate = copy(self)\n        gate.vec = gate.vec.relabel(qubits)\n        return gate"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npermute the order of the qubits", "response": "def permute(self, qubits: Qubits) -> 'Gate':\n        \"\"\"Permute the order of the qubits\"\"\"\n        vec = self.vec.permute(qubits)\n        return Gate(vec.tensor, qubits=vec.qubits)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply the action of this gate upon a state", "response": "def run(self, ket: State) -> State:\n        \"\"\"Apply the action of this gate upon a state\"\"\"\n        qubits = self.qubits\n        indices = [ket.qubits.index(q) for q in qubits]\n        tensor = bk.tensormul(self.tensor, ket.tensor, indices)\n        return State(tensor, ket.qubits, ket.memory)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying the action of this gate upon a density", "response": "def evolve(self, rho: Density) -> Density:\n        \"\"\"Apply the action of this gate upon a density\"\"\"\n        # TODO: implement without explicit channel creation?\n        chan = self.aschannel()\n        return chan.evolve(rho)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef aschannel(self) -> 'Channel':\n        N = self.qubit_nb\n        R = 4\n\n        tensor = bk.outer(self.tensor, self.H.tensor)\n        tensor = bk.reshape(tensor, [2**N]*R)\n        tensor = bk.transpose(tensor, [0, 3, 1, 2])\n\n        return Channel(tensor, self.qubits)", "response": "Converts a Gate into a Channel"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting the gate tensor to the special unitary group.", "response": "def su(self) -> 'Gate':\n        \"\"\"Convert gate tensor to the special unitary group.\"\"\"\n        rank = 2**self.qubit_nb\n        U = asarray(self.asoperator())\n        U /= np.linalg.det(U) ** (1/rank)\n        return Gate(tensor=U, qubits=self.qubits)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a copy of this channel with new qubits", "response": "def relabel(self, qubits: Qubits) -> 'Channel':\n        \"\"\"Return a copy of this channel with new qubits\"\"\"\n        chan = copy(self)\n        chan.vec = chan.vec.relabel(qubits)\n        return chan"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef permute(self, qubits: Qubits) -> 'Channel':\n        vec = self.vec.permute(qubits)\n        return Channel(vec.tensor, qubits=vec.qubits)", "response": "Return a copy of this channel with qubits in new order."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sharp(self) -> 'Channel':\n\n        N = self.qubit_nb\n\n        tensor = self.tensor\n        tensor = bk.reshape(tensor, [2**N] * 4)\n        tensor = bk.transpose(tensor, (0, 2, 1, 3))\n        tensor = bk.reshape(tensor, [2] * 4 * N)\n        return Channel(tensor, self.qubits)", "response": "Return the sharp transpose of the superoperator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the Choi matrix representation of this super operator", "response": "def choi(self) -> bk.BKTensor:\n        \"\"\"Return the Choi matrix representation of this super\n        operator\"\"\"\n        # Put superop axes in [ok, ib, ob, ik] and reshape to matrix\n        N = self.qubit_nb\n        return bk.reshape(self.sharp.tensor, [2**(N*2)] * 2)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying the action of this channel upon a density", "response": "def evolve(self, rho: Density) -> Density:\n        \"\"\"Apply the action of this channel upon a density\"\"\"\n        N = rho.qubit_nb\n        qubits = rho.qubits\n\n        indices = list([qubits.index(q) for q in self.qubits]) + \\\n            list([qubits.index(q) + N for q in self.qubits])\n\n        tensor = bk.tensormul(self.tensor, rho.tensor, indices)\n        return Density(tensor, qubits, rho.memory)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the partial trace over the specified qubits", "response": "def partial_trace(self, qubits: Qubits) -> 'Channel':\n        \"\"\"Return the partial trace over the specified qubits\"\"\"\n        vec = self.vec.partial_trace(qubits)\n        return Channel(vec.tensor, vec.qubits)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fcast(value: float) -> TensorLike:\n    newvalue = tf.cast(value, FTYPE)\n    if DEVICE == 'gpu':\n        newvalue = newvalue.gpu()  # Why is this needed?  # pragma: no cover\n    return newvalue", "response": "Cast to float tensor"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef astensor(array: TensorLike) -> BKTensor:\n    tensor = tf.convert_to_tensor(array, dtype=CTYPE)\n    if DEVICE == 'gpu':\n        tensor = tensor.gpu()  # pragma: no cover\n\n    # size = np.prod(np.array(tensor.get_shape().as_list()))\n    N = int(math.log2(size(tensor)))\n    tensor = tf.reshape(tensor, ([2]*N))\n\n    return tensor", "response": "Convert to product tensor"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef count_operations(elements: Iterable[Operation]) \\\n        -> Dict[Type[Operation], int]:\n    \"\"\"Return a count of different operation types given a colelction of\n    operations, such as a Circuit or DAGCircuit\n    \"\"\"\n    op_count: Dict[Type[Operation], int] = defaultdict(int)\n    for elem in elements:\n        op_count[type(elem)] += 1\n    return dict(op_count)", "response": "Return a count of different operation types given a colelction of\n    operations such as a Circuit or DAGCircuit\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef map_gate(gate: Gate, args: Sequence[Qubits]) -> Circuit:\n    circ = Circuit()\n\n    for qubits in args:\n        circ += gate.relabel(qubits)\n\n    return circ", "response": "Applies the same gate all input qubits in the argument list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef qft_circuit(qubits: Qubits) -> Circuit:\n    # Kudos: Adapted from Rigetti Grove, grove/qft/fourier.py\n\n    N = len(qubits)\n    circ = Circuit()\n    for n0 in range(N):\n        q0 = qubits[n0]\n        circ += H(q0)\n        for n1 in range(n0+1, N):\n            q1 = qubits[n1]\n            angle = pi / 2 ** (n1-n0)\n            circ += CPHASE(angle, q1, q0)\n    circ.extend(reversal_circuit(qubits))\n    return circ", "response": "Returns the Quantum Fourier Transform circuit for the given qubits."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a circuit to reverse qubits", "response": "def reversal_circuit(qubits: Qubits) -> Circuit:\n    \"\"\"Returns a circuit to reverse qubits\"\"\"\n    N = len(qubits)\n    circ = Circuit()\n    for n in range(N // 2):\n        circ += SWAP(qubits[n], qubits[N-1-n])\n    return circ"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef control_circuit(controls: Qubits, gate: Gate) -> Circuit:\n    # Kudos: Adapted from Rigetti Grove's utility_programs.py\n    # grove/utils/utility_programs.py::ControlledProgramBuilder\n\n    circ = Circuit()\n    if len(controls) == 1:\n        q0 = controls[0]\n        if isinstance(gate, X):\n            circ += CNOT(q0, gate.qubits[0])\n        else:\n            cgate = control_gate(q0, gate)\n            circ += cgate\n    else:\n        circ += control_circuit(controls[-1:], gate ** 0.5)\n        circ += control_circuit(controls[0:-1], X(controls[-1]))\n        circ += control_circuit(controls[-1:], gate ** -0.5)\n        circ += control_circuit(controls[0:-1], X(controls[-1]))\n        circ += control_circuit(controls[0:-1], gate ** 0.5)\n    return circ", "response": "Generates a control circuit for a target gate controlled by a collection of control qubits."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a Circuit that is the CCNOT gate.", "response": "def ccnot_circuit(qubits: Qubits) -> Circuit:\n    \"\"\"Standard decomposition of CCNOT (Toffoli) gate into\n    six CNOT gates (Plus Hadamard and T gates.) [Nielsen2000]_\n\n    .. [Nielsen2000]\n        M. A. Nielsen and I. L. Chuang, Quantum Computation and Quantum\n        Information, Cambridge University Press (2000).\n    \"\"\"\n    if len(qubits) != 3:\n        raise ValueError('Expected 3 qubits')\n\n    q0, q1, q2 = qubits\n\n    circ = Circuit()\n    circ += H(q2)\n    circ += CNOT(q1, q2)\n    circ += T(q2).H\n    circ += CNOT(q0, q2)\n    circ += T(q2)\n    circ += CNOT(q1, q2)\n    circ += T(q2).H\n    circ += CNOT(q0, q2)\n    circ += T(q1)\n    circ += T(q2)\n    circ += H(q2)\n    circ += CNOT(q0, q1)\n    circ += T(q0)\n    circ += T(q1).H\n    circ += CNOT(q0, q1)\n\n    return circ"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a ZYZ gate.", "response": "def zyz_circuit(t0: float, t1: float, t2: float, q0: Qubit) -> Circuit:\n    \"\"\"Circuit equivalent of 1-qubit ZYZ gate\"\"\"\n    circ = Circuit()\n    circ += TZ(t0, q0)\n    circ += TY(t1, q0)\n    circ += TZ(t2, q0)\n    return circ"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef phase_estimation_circuit(gate: Gate, outputs: Qubits) -> Circuit:\n    circ = Circuit()\n    circ += map_gate(H(), list(zip(outputs)))  # Hadamard on all output qubits\n\n    for cq in reversed(outputs):\n        cgate = control_gate(cq, gate)\n        circ += cgate\n        gate = gate @ gate\n\n    circ += qft_circuit(outputs).H\n\n    return circ", "response": "Returns a circuit for quantum phase estimation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef addition_circuit(\n        addend0: Qubits,\n        addend1: Qubits,\n        carry: Qubits) -> Circuit:\n    \"\"\"Returns a quantum circuit for ripple-carry addition. [Cuccaro2004]_\n\n    Requires two carry qubit (input and output). The result is returned in\n    addend1.\n\n    .. [Cuccaro2004]\n        A new quantum ripple-carry addition circuit, Steven A. Cuccaro,\n        Thomas G. Draper, Samuel A. Kutin, David Petrie Moulton\n        arXiv:quant-ph/0410184 (2004)\n    \"\"\"\n\n    if len(addend0) != len(addend1):\n        raise ValueError('Number of addend qubits must be equal')\n\n    if len(carry) != 2:\n        raise ValueError('Expected 2 carry qubits')\n\n    def _maj(qubits: Qubits) -> Circuit:\n        q0, q1, q2 = qubits\n        circ = Circuit()\n        circ += CNOT(q2, q1)\n        circ += CNOT(q2, q0)\n        circ += CCNOT(q0, q1, q2)\n        return circ\n\n    def _uma(qubits: Qubits) -> Circuit:\n        q0, q1, q2 = qubits\n        circ = Circuit()\n        circ += CCNOT(q0, q1, q2)\n        circ += CNOT(q2, q0)\n        circ += CNOT(q0, q1)\n        return circ\n\n    qubits = [carry[0]] + list(chain.from_iterable(\n        zip(reversed(addend1), reversed(addend0)))) + [carry[1]]\n\n    circ = Circuit()\n\n    for n in range(0, len(qubits)-3, 2):\n        circ += _maj(qubits[n:n+3])\n\n    circ += CNOT(qubits[-2], qubits[-1])\n\n    for n in reversed(range(0, len(qubits)-3, 2)):\n        circ += _uma(qubits[n:n+3])\n\n    return circ", "response": "Returns a Circuit that adds the addend0 and addend1 to the ripple - carry addend1."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ghz_circuit(qubits: Qubits) -> Circuit:\n    circ = Circuit()\n\n    circ += H(qubits[0])\n    for q0 in range(0, len(qubits)-1):\n        circ += CNOT(qubits[q0], qubits[q0+1])\n\n    return circ", "response": "Returns a Circuit that prepares a multi - qubit Bell state from the zero\n    state."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nappend gates from other to the end of this circuit", "response": "def extend(self, other: Operation) -> None:\n        \"\"\"Append gates from circuit to the end of this circuit\"\"\"\n        if isinstance(other, Circuit):\n            self.elements.extend(other.elements)\n        else:\n            self.elements.extend([other])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a sorted list of qubits acted upon by this circuit", "response": "def qubits(self) -> Qubits:\n        \"\"\"Returns: Sorted list of qubits acted upon by this circuit\n\n        Raises:\n            TypeError: If qubits cannot be sorted into unique order.\n        \"\"\"\n        qbs = [q for elem in self.elements for q in elem.qubits]    # gather\n        qbs = list(set(qbs))                                        # unique\n        qbs = sorted(qbs)                                           # sort\n        return tuple(qbs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\napply the action of this circuit upon a state.", "response": "def run(self, ket: State = None) -> State:\n        \"\"\"\n        Apply the action of this circuit upon a state.\n\n        If no initial state provided an initial zero state will be created.\n        \"\"\"\n        if ket is None:\n            qubits = self.qubits\n            ket = zero_state(qubits=qubits)\n\n        for elem in self.elements:\n            ket = elem.run(ket)\n        return ket"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef asgate(self) -> Gate:\n        gate = identity_gate(self.qubits)\n        for elem in self.elements:\n            gate = elem.asgate() @ gate\n        return gate", "response": "Return the action of this circuit as a gate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef join_channels(*channels: Channel) -> Channel:\n    vectors = [chan.vec for chan in channels]\n    vec = reduce(outer_product, vectors)\n    return Channel(vec.tensor, vec.qubits)", "response": "Join two channels acting on different qubits into a single channel\n    acting on all qubits"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef channel_to_kraus(chan: Channel) -> 'Kraus':\n    qubits = chan.qubits\n    N = chan.qubit_nb\n\n    choi = asarray(chan.choi())\n    evals, evecs = np.linalg.eig(choi)\n    evecs = np.transpose(evecs)\n\n    assert np.allclose(evals.imag, 0.0)  # FIXME exception\n    assert np.all(evals.real >= 0.0)     # FIXME exception\n\n    values = np.sqrt(evals.real)\n\n    ops = []\n    for i in range(2**(2*N)):\n        if not np.isclose(values[i], 0.0):\n            mat = np.reshape(evecs[i], (2**N, 2**N))*values[i]\n            g = Gate(mat, qubits)\n            ops.append(g)\n\n    return Kraus(ops)", "response": "Convert a channel superoperator into a Kraus operator representation of the same channel."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if the collection of weighted Kraus operators are complete.", "response": "def kraus_iscomplete(kraus: Kraus) -> bool:\n    \"\"\"Returns True if the collection of (weighted) Kraus operators are\n    complete. (Which is necessary for a CPTP map to preserve trace)\n    \"\"\"\n    qubits = kraus.qubits\n    N = kraus.qubit_nb\n\n    ident = Gate(np.eye(2**N), qubits)  # FIXME\n\n    tensors = [(op.H @ op @ ident).asoperator() for op in kraus.operators]\n    tensors = [t*w for t, w in zip(tensors, kraus.weights)]\n\n    tensor = reduce(np.add, tensors)\n    res = Gate(tensor, qubits)\n\n    return almost_identity(res)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef aschannel(self) -> Channel:\n        qubits = self.qubits\n        N = len(qubits)\n        ident = Gate(np.eye(2**N), qubits=qubits).aschannel()\n\n        channels = [op.aschannel() @ ident for op in self.operators]\n        if self.weights is not None:\n            channels = [c*w for c, w in zip(channels, self.weights)]\n        channel = reduce(add, channels)\n        return channel", "response": "Returns the action of Kraus operators as a superoperator Channel"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying the action of this Kraus quantum operation upon a state", "response": "def run(self, ket: State) -> State:\n        \"\"\"Apply the action of this Kraus quantum operation upon a state\"\"\"\n        res = [op.run(ket) for op in self.operators]\n        probs = [asarray(ket.norm()) * w for ket, w in zip(res, self.weights)]\n        probs = np.asarray(probs)\n        probs /= np.sum(probs)\n        newket = np.random.choice(res, p=probs)\n        return newket.normalize()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef evolve(self, rho: Density) -> Density:\n        qubits = rho.qubits\n        results = [op.evolve(rho) for op in self.operators]\n        tensors = [rho.tensor * w for rho, w in zip(results, self.weights)]\n        tensor = reduce(add, tensors)\n        return Density(tensor, qubits)", "response": "Apply the action of this Kraus quantum operation upon a density"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef H(self) -> 'Kraus':\n        operators = [op.H for op in self.operators]\n        return Kraus(operators, self.weights)", "response": "Return the complex conjugate of this Kraus operation"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef asgate(self) -> Gate:\n        return np.random.choice(self.operators, p=self.weights)", "response": "Return one of the composite Kraus operators at random with\n        the appropriate weights"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef circuit_to_latex(circ: Circuit,\n                     qubits: Qubits = None,\n                     document: bool = True) -> str:\n    \"\"\"\n    Create an image of a quantum circuit in LaTeX.\n\n    Can currently draw X, Y, Z, H, T, S, T_H, S_H, RX, RY, RZ, TX, TY, TZ,\n    TH, CNOT, CZ, SWAP, ISWAP, CCNOT, CSWAP, XX, YY, ZZ, CAN, P0 and P1 gates,\n    and the RESET operation.\n\n    Args:\n        circ:       A quantum Circuit\n        qubits:     Optional qubit list to specify qubit order\n        document:   If false, just the qcircuit latex is returned. Else the\n                    circuit image is wrapped in a standalone LaTeX document\n                    ready for typesetting.\n    Returns:\n        A LaTeX string representation of the circuit.\n\n    Raises:\n        NotImplementedError: For unsupported gates.\n\n    Refs:\n        LaTeX Qcircuit package\n            (https://arxiv.org/pdf/quant-ph/0406003).\n    \"\"\"\n    if qubits is None:\n        qubits = circ.qubits\n    N = len(qubits)\n    qubit_idx = dict(zip(qubits, range(N)))\n    layers = _display_layers(circ, qubits)\n\n    layer_code = []\n    code = [r'\\lstick{' + str(q) + r'}' for q in qubits]\n    layer_code.append(code)\n\n    def _two_qubit_gate(top, bot, label):\n        if bot-top == 1:\n            code_top = r'\\multigate{1}{%s}' % label\n            code_bot = r'\\ghost{%s}' % label\n        else:\n            code_top = r'\\sgate{%s}{%s}' % (label, str(bot - top))\n            code_bot = r'\\gate{%s}' % (label)\n        return code_top, code_bot\n\n    for layer in layers.elements:\n        code = [r'\\qw'] * N\n        assert isinstance(layer, Circuit)\n        for gate in layer:\n            idx = [qubit_idx[q] for q in gate.qubits]\n\n            name = gate.name\n\n            if isinstance(gate, I):\n                pass\n            elif(len(idx) == 1) and name in ['X', 'Y', 'Z', 'H', 'T', 'S']:\n                code[idx[0]] = r'\\gate{' + gate.name + '}'\n            elif isinstance(gate, S_H):\n                code[idx[0]] = r'\\gate{S^\\dag}'\n            elif isinstance(gate, T_H):\n                code[idx[0]] = r'\\gate{T^\\dag}'\n            elif isinstance(gate, RX):\n                theta = _latex_format(gate.params['theta'])\n                code[idx[0]] = r'\\gate{R_x(%s)}' % theta\n            elif isinstance(gate, RY):\n                theta = _latex_format(gate.params['theta'])\n                code[idx[0]] = r'\\gate{R_y(%s)}' % theta\n            elif isinstance(gate, RZ):\n                theta = _latex_format(gate.params['theta'])\n                code[idx[0]] = r'\\gate{R_z(%s)}' % theta\n            elif isinstance(gate, TX):\n                t = _latex_format(gate.params['t'])\n                code[idx[0]] = r'\\gate{X^{%s}}' % t\n            elif isinstance(gate, TY):\n                t = _latex_format(gate.params['t'])\n                code[idx[0]] = r'\\gate{Y^{%s}}' % t\n            elif isinstance(gate, TZ):\n                t = _latex_format(gate.params['t'])\n                code[idx[0]] = r'\\gate{Z^{%s}}' % t\n            elif isinstance(gate, TH):\n                t = _latex_format(gate.params['t'])\n                code[idx[0]] = r'\\gate{H^{%s}}' % t\n            elif isinstance(gate, CNOT):\n                code[idx[0]] = r'\\ctrl{' + str(idx[1] - idx[0]) + '}'\n                code[idx[1]] = r'\\targ'\n            elif isinstance(gate, XX):\n                label = r'X\\!X^{%s}' % _latex_format(gate.params['t'])\n                top = min(idx)\n                bot = max(idx)\n                code[top], code[bot] = _two_qubit_gate(top, bot, label)\n            elif isinstance(gate, YY):\n                label = r'Y\\!Y^{%s}' % _latex_format(gate.params['t'])\n                top = min(idx)\n                bot = max(idx)\n                code[top], code[bot] = _two_qubit_gate(top, bot, label)\n            elif isinstance(gate, ZZ):\n                label = r'Z\\!Z^{%s}' % _latex_format(gate.params['t'])\n                top = min(idx)\n                bot = max(idx)\n                code[top], code[bot] = _two_qubit_gate(top, bot, label)\n            elif isinstance(gate, CPHASE):\n                theta = _latex_format(gate.params['theta'])\n                label = r'\\text{CPHASE}({%s})' % theta\n                top = min(idx)\n                bot = max(idx)\n                code[top], code[bot] = _two_qubit_gate(top, bot, label)\n            elif isinstance(gate, PSWAP):\n                theta = _latex_format(gate.params['theta'])\n                label = r'\\text{PSWAP}({%s})' % theta\n                top = min(idx)\n                bot = max(idx)\n                code[top], code[bot] = _two_qubit_gate(top, bot, label)\n            elif isinstance(gate, CZ):\n                code[idx[0]] = r'\\ctrl{' + str(idx[1] - idx[0]) + '}'\n                code[idx[1]] = r'\\ctrl{' + str(idx[0] - idx[1]) + '}'\n            elif isinstance(gate, SWAP):\n                code[idx[0]] = r'\\qswap \\qwx[' + str(idx[1] - idx[0]) + ']'\n                code[idx[1]] = r'\\qswap'\n            elif isinstance(gate, CAN):\n                tx = _latex_format(gate.params['tx'])\n                ty = _latex_format(gate.params['ty'])\n                tz = _latex_format(gate.params['tz'])\n                label = r'{\\text{CAN}(%s, %s, %s)}' % (tx, ty, tz)\n                top = min(idx)\n                bot = max(idx)\n                code[top], code[bot] = _two_qubit_gate(top, bot, label)\n            elif isinstance(gate, ISWAP):\n                label = r'{ \\text{iSWAP}}'\n                top = min(idx)\n                bot = max(idx)\n                code[top], code[bot] = _two_qubit_gate(top, bot, label)\n            elif isinstance(gate, CCNOT):\n                code[idx[0]] = r'\\ctrl{' + str(idx[1]-idx[0]) + '}'\n                code[idx[1]] = r'\\ctrl{' + str(idx[2]-idx[1]) + '}'\n                code[idx[2]] = r'\\targ'\n            elif isinstance(gate, CSWAP):\n                code[idx[0]] = r'\\ctrl{' + str(idx[1]-idx[0]) + '}'\n                code[idx[1]] = r'\\qswap \\qwx[' + str(idx[2] - idx[1]) + ']'\n                code[idx[2]] = r'\\qswap'\n            elif isinstance(gate, P0):\n                code[idx[0]] = r'\\push{\\ket{0}\\!\\!\\bra{0}} \\qw'\n            elif isinstance(gate, P1):\n                code[idx[0]] = r'\\push{\\ket{1}\\!\\!\\bra{1}} \\qw'\n            elif isinstance(gate, Reset):\n                for i in idx:\n                    code[i] = r'\\push{\\rule{0.1em}{0.5em}\\, \\ket{0}\\,} \\qw'\n            elif isinstance(gate, Measure):\n                code[idx[0]] = r'\\meter'\n            else:\n                raise NotImplementedError(str(gate))\n\n        layer_code.append(code)\n\n    code = [r'\\qw'] * N\n    layer_code.append(code)\n\n    latex_lines = [''] * N\n\n    for line, wire in enumerate(zip(*layer_code)):\n        latex = '& ' + ' & '.join(wire)\n        if line < N - 1:  # Not last line\n            latex += r' \\\\'\n        latex_lines[line] = latex\n\n    latex_code = _QCIRCUIT % '\\n'.join(latex_lines)\n\n    if document:\n        latex_code = _DOCUMENT_HEADER + latex_code + _DOCUMENT_FOOTER\n\n    return latex_code", "response": "Converts a Circuit into LaTeX format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nseparating a circuit into groups of gates that do not visually overlap", "response": "def _display_layers(circ: Circuit, qubits: Qubits) -> Circuit:\n    \"\"\"Separate a circuit into groups of gates that do not visually overlap\"\"\"\n    N = len(qubits)\n    qubit_idx = dict(zip(qubits, range(N)))\n    gate_layers = DAGCircuit(circ).layers()\n\n    layers = []\n    lcirc = Circuit()\n    layers.append(lcirc)\n    unused = [True] * N\n\n    for gl in gate_layers:\n        assert isinstance(gl, Circuit)\n        for gate in gl:\n            indices = [qubit_idx[q] for q in gate.qubits]\n\n            if not all(unused[min(indices):max(indices)+1]):\n                # New layer\n                lcirc = Circuit()\n                layers.append(lcirc)\n                unused = [True] * N\n\n            unused[min(indices):max(indices)+1] = \\\n                [False] * (max(indices) - min(indices) + 1)\n            lcirc += gate\n\n    return Circuit(layers)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef render_latex(latex: str) -> PIL.Image:      # pragma: no cover\n    tmpfilename = 'circ'\n    with tempfile.TemporaryDirectory() as tmpdirname:\n        tmppath = os.path.join(tmpdirname, tmpfilename)\n        with open(tmppath + '.tex', 'w') as latex_file:\n            latex_file.write(latex)\n\n        subprocess.run([\"pdflatex\",\n                        \"-halt-on-error\",\n                        \"-output-directory={}\".format(tmpdirname),\n                        \"{}\".format(tmpfilename+'.tex')],\n                       stdout=subprocess.PIPE,\n                       stderr=subprocess.DEVNULL,\n                       check=True)\n\n        subprocess.run(['pdftocairo',\n                        '-singlefile',\n                        '-png',\n                        '-q',\n                        tmppath + '.pdf',\n                        tmppath])\n        img = PIL.Image.open(tmppath + '.png')\n\n    return img", "response": "Convert a LaTeX document into an image."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef circuit_to_image(circ: Circuit,\n                     qubits: Qubits = None) -> PIL.Image:   # pragma: no cover\n    \"\"\"Create an image of a quantum circuit.\n\n    A convenience function that calls circuit_to_latex() and render_latex().\n\n    Args:\n        circ:       A quantum Circuit\n        qubits:     Optional qubit list to specify qubit order\n\n    Returns:\n        Returns: A PIL Image (Use img.show() to display)\n\n    Raises:\n        NotImplementedError: For unsupported gates.\n        OSError: If an external dependency is not installed.\n    \"\"\"\n    latex = circuit_to_latex(circ, qubits)\n    img = render_latex(latex)\n    return img", "response": "Create an image of a quantum circuit."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats an object as a latex string.", "response": "def _latex_format(obj: Any) -> str:\n    \"\"\"Format an object as a latex string.\"\"\"\n    if isinstance(obj, float):\n        try:\n            return sympy.latex(symbolize(obj))\n        except ValueError:\n            return \"{0:.4g}\".format(obj)\n\n    return str(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fit_zyz(target_gate):\n    assert bk.BACKEND == 'eager'\n\n    tf = bk.TL\n    tfe = bk.tfe\n\n    steps = 4000\n\n    dev = '/gpu:0' if bk.DEVICE == 'gpu' else '/cpu:0'\n\n    with tf.device(dev):\n        t = tfe.Variable(np.random.normal(size=[3]), name='t')\n\n        def loss_fn():\n            \"\"\"Loss\"\"\"\n            gate = qf.ZYZ(t[0], t[1], t[2])\n            ang = qf.fubini_study_angle(target_gate.vec, gate.vec)\n            return ang\n\n        loss_and_grads = tfe.implicit_value_and_gradients(loss_fn)\n        # opt = tf.train.GradientDescentOptimizer(learning_rate=0.005)\n        opt = tf.train.AdamOptimizer(learning_rate=0.001)\n        # train = opt.minimize(ang, var_list=[t])\n\n        for step in range(steps):\n            loss, grads_and_vars = loss_and_grads()\n            sys.stdout.write('\\r')\n            sys.stdout.write(\"step: {:3d} loss: {:10.9f}\".format(step,\n                                                                 loss.numpy()))\n            if loss < 0.0001:\n                break\n            opt.apply_gradients(grads_and_vars)\n\n        print()\n    return bk.evaluate(t)", "response": "Fits a universal ZYZ gate to a universal ZYZ object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_versions(file: typing.TextIO = None) -> None:\n\n    print('** QuantumFlow dependencies (> python -m quantumflow.meta) **')\n    print('quantumflow \\t', qf.__version__, file=file)\n    print('python      \\t', sys.version[0:5], file=file)\n    print('numpy       \\t', np.__version__, file=file)\n    print('networkx    \\t', nx.__version__, file=file)\n    print('cvxpy      \\t', cvx.__version__, file=file)\n    print('pyquil      \\t', pyquil.__version__, file=file)\n\n    print(bk.name, '   \\t', bk.version, '(BACKEND)', file=file)", "response": "Prints version strings of currently installed dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfits a universal ZYZ gate to a tensorflow example. Given an arbitrary one - qubit gate use gradient descent to find corresponding parameters of a universal ZYZ gate.", "response": "def fit_zyz(target_gate):\n    \"\"\"\n    Tensorflow example. Given an arbitrary one-qubit gate, use gradient\n    descent to find corresponding parameters of a universal ZYZ gate.\n    \"\"\"\n\n    assert bk.BACKEND == 'tensorflow'\n\n    tf = bk.TL\n    steps = 4000\n\n    t = tf.get_variable('t', [3])\n    gate = qf.ZYZ(t[0], t[1], t[2])\n\n    ang = qf.fubini_study_angle(target_gate.vec, gate.vec)\n    opt = tf.train.AdamOptimizer(learning_rate=0.001)\n    train = opt.minimize(ang, var_list=[t])\n\n    with tf.Session() as sess:\n        init_op = tf.global_variables_initializer()\n        sess.run(init_op)\n\n        for step in range(steps):\n            sess.run(train)\n            loss = sess.run(ang)\n            sys.stdout.write('\\r')\n            sys.stdout.write(\"step: {} gate_angle: {}\".format(step, loss))\n            if loss < 0.0001:\n                break\n        print()\n        return sess.run(t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprepare a 4 - qubit W state using sqrt iswaps and local gates", "response": "def prepare_w4():\n    \"\"\"\n    Prepare a 4-qubit W state using sqrt(iswaps) and local gates\n    \"\"\"\n    circ = qf.Circuit()\n    circ += qf.X(1)\n\n    circ += qf.ISWAP(1, 2) ** 0.5\n    circ += qf.S(2)\n    circ += qf.Z(2)\n\n    circ += qf.ISWAP(2, 3) ** 0.5\n    circ += qf.S(3)\n    circ += qf.Z(3)\n\n    circ += qf.ISWAP(0, 1) ** 0.5\n    circ += qf.S(0)\n    circ += qf.Z(0)\n\n    ket = circ.run()\n\n    return ket"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bloch_decomposition(gate: Gate) -> Circuit:\n    if gate.qubit_nb != 1:\n        raise ValueError('Expected 1-qubit gate')\n\n    U = asarray(gate.asoperator())\n    U /= np.linalg.det(U) ** (1/2)\n\n    nx = - U[0, 1].imag\n    ny = - U[0, 1].real\n    nz = - U[0, 0].imag\n    N = np.sqrt(nx**2 + ny**2 + nz**2)\n    if N == 0:  # Identity\n        nx, ny, nz = 1, 1, 1\n    else:\n        nx /= N\n        ny /= N\n        nz /= N\n    sin_halftheta = N\n    cos_halftheta = U[0, 0].real\n    theta = 2 * np.arctan2(sin_halftheta, cos_halftheta)\n\n    # We return a Circuit (rather than just a gate) to keep the\n    # interface of decomposition routines uniform.\n    return Circuit([RN(theta, nx, ny, nz, *gate.qubits)])", "response": "Returns a 1 - qubit decomposition of a 1 - qubit gate into a 1 - qubit RN gate"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef zyz_decomposition(gate: Gate) -> Circuit:\n    if gate.qubit_nb != 1:\n        raise ValueError('Expected 1-qubit gate')\n\n    q, = gate.qubits\n\n    U = asarray(gate.asoperator())\n    U /= np.linalg.det(U) ** (1/2)    # SU(2)\n\n    if abs(U[0, 0]) > abs(U[1, 0]):\n        theta1 = 2 * np.arccos(min(abs(U[0, 0]), 1))\n    else:\n        theta1 = 2 * np.arcsin(min(abs(U[1, 0]), 1))\n\n    cos_halftheta1 = np.cos(theta1/2)\n    if not np.isclose(cos_halftheta1, 0.0):\n        phase = U[1, 1] / cos_halftheta1\n        theta0_plus_theta2 = 2 * np.arctan2(np.imag(phase), np.real(phase))\n    else:\n        theta0_plus_theta2 = 0.0\n\n    sin_halftheta1 = np.sin(theta1/2)\n    if not np.isclose(sin_halftheta1, 0.0):\n        phase = U[1, 0] / sin_halftheta1\n        theta0_sub_theta2 = 2 * np.arctan2(np.imag(phase), np.real(phase))\n    else:\n        theta0_sub_theta2 = 0.0\n\n    theta0 = (theta0_plus_theta2 + theta0_sub_theta2) / 2\n    theta2 = (theta0_plus_theta2 - theta0_sub_theta2) / 2\n\n    t0 = theta0/np.pi\n    t1 = theta1/np.pi\n    t2 = theta2/np.pi\n\n    circ1 = Circuit()\n    circ1 += TZ(t2, q)\n    circ1 += TY(t1, q)\n    circ1 += TZ(t0, q)\n\n    return circ1", "response": "Returns the Euler Z - Y - Z decomposition of a local 1 - qubit gate."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef kronecker_decomposition(gate: Gate) -> Circuit:\n    # An alternative approach would be to take partial traces, but\n    # this approach appears to be more robust.\n\n    if gate.qubit_nb != 2:\n        raise ValueError('Expected 2-qubit gate')\n\n    U = asarray(gate.asoperator())\n    rank = 2**gate.qubit_nb\n    U /= np.linalg.det(U) ** (1/rank)\n\n    R = np.stack([U[0:2, 0:2].reshape(4),\n                  U[0:2, 2:4].reshape(4),\n                  U[2:4, 0:2].reshape(4),\n                  U[2:4, 2:4].reshape(4)])\n    u, s, vh = np.linalg.svd(R)\n    v = vh.transpose()\n    A = (np.sqrt(s[0]) * u[:, 0]).reshape(2, 2)\n    B = (np.sqrt(s[0]) * v[:, 0]).reshape(2, 2)\n\n    q0, q1 = gate.qubits\n    g0 = Gate(A, qubits=[q0])\n    g1 = Gate(B, qubits=[q1])\n\n    if not gates_close(gate, Circuit([g0, g1]).asgate()):\n        raise ValueError(\"Gate cannot be decomposed into two 1-qubit gates\")\n\n    circ = Circuit()\n    circ += zyz_decomposition(g0)\n    circ += zyz_decomposition(g1)\n\n    assert gates_close(gate, circ.asgate())  # Sanity check\n\n    return circ", "response": "Decomposes a 2 - qubit unitary composed of two 1 - qubit local gates."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef canonical_coords(gate: Gate) -> Sequence[float]:\n    circ = canonical_decomposition(gate)\n    gate = circ.elements[6]  # type: ignore\n    params = [gate.params[key] for key in ('tx', 'ty', 'tz')]\n    return params", "response": "Returns the canonical coordinates of a 2 - qubit gate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef canonical_decomposition(gate: Gate) -> Circuit:\n\n    # Implementation note: The canonical decomposition is easy. Constraining\n    # canonical coordinates to the Weyl chamber is easy. But doing the\n    # canonical decomposition with the canonical gate in the Weyl chamber\n    # proved to be surprisingly tricky.\n\n    # Unitary transform to Magic Basis of Bell states\n    Q = np.asarray([[1, 0, 0, 1j],\n                    [0, 1j, 1, 0],\n                    [0, 1j, -1, 0],\n                    [1, 0, 0, -1j]]) / np.sqrt(2)\n    Q_H = Q.conj().T\n\n    if gate.qubit_nb != 2:\n        raise ValueError('Expected 2-qubit gate')\n\n    U = asarray(gate.asoperator())\n    rank = 2**gate.qubit_nb\n    U /= np.linalg.det(U) ** (1/rank)  # U is in SU(4) so det U = 1\n\n    U_mb = Q_H @ U @ Q   # Transform gate to Magic Basis [1, (eq. 17, 18)]\n    M = U_mb.transpose() @ U_mb         # Construct M matrix [1, (eq. 22)]\n\n    # Diagonalize symmetric complex matrix\n    eigvals, eigvecs = _eig_complex_symmetric(M)\n\n    lambdas = np.sqrt(eigvals)          # Eigenvalues of F\n    # Lambdas only fixed up to a sign. So make sure det F = 1 as it should\n    det_F = np.prod(lambdas)\n    if det_F.real < 0:\n        lambdas[0] *= -1\n\n    coords, signs, perm = _constrain_to_weyl(lambdas)\n\n    # Construct local and canonical gates in magic basis\n    lambdas = (lambdas*signs)[perm]\n    O2 = (np.diag(signs) @ eigvecs.transpose())[perm]\n    F = np.diag(lambdas)\n    O1 = U_mb @ O2.transpose() @ F.conj()\n\n    # Sanity check: Make sure O1 and O2 are orthogonal\n    assert np.allclose(np.eye(4), O2.transpose() @ O2)  # Sanity check\n    assert np.allclose(np.eye(4), O1.transpose() @ O1)  # Sanity check\n\n    # Sometimes O1 & O2 end up with det = -1, instead of +1 as they should.\n    # We can commute a diagonal matrix through F to fix this up.\n    neg = np.diag([-1, 1, 1, 1])\n    if np.linalg.det(O2).real < 0:\n        O2 = neg @ O2\n        O1 = O1 @ neg\n\n    # Transform gates back from magic basis\n    K1 = Q @ O1 @ Q_H\n    A = Q @ F @ Q_H\n    K2 = Q @ O2 @ Q_H\n\n    assert gates_close(Gate(U), Gate(K1 @ A @ K2))  # Sanity check\n    canon = CANONICAL(coords[0], coords[1], coords[2], 0, 1)\n\n    # Sanity check\n    assert gates_close(Gate(A, qubits=gate.qubits), canon, tolerance=1e-4)\n\n    # Decompose local gates into the two component 1-qubit gates\n    gateK1 = Gate(K1, qubits=gate.qubits)\n    circK1 = kronecker_decomposition(gateK1)\n    assert gates_close(gateK1, circK1.asgate())  # Sanity check\n\n    gateK2 = Gate(K2, qubits=gate.qubits)\n    circK2 = kronecker_decomposition(gateK2)\n    assert gates_close(gateK2, circK2.asgate())  # Sanity check\n\n    # Build and return circuit\n    circ = Circuit()\n    circ += circK2\n    circ += canon\n    circ += circK1\n\n    return circ", "response": "Decompose a 2 - qubit gate by removing local 1 - qubit gates to leave the canonical one - qubit gates."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef maxcut_qaoa(\n        graph,\n        steps=DEFAULT_STEPS,\n        learning_rate=LEARNING_RATE,\n        verbose=False):\n    \"\"\"QAOA Maxcut using tensorflow\"\"\"\n\n    if not isinstance(graph, nx.Graph):\n        graph = nx.from_edgelist(graph)\n\n    init_scale = 0.01\n    init_bias = 0.5\n\n    init_beta = normal(loc=init_bias, scale=init_scale, size=[steps])\n    init_gamma = normal(loc=init_bias, scale=init_scale, size=[steps])\n\n    beta = tf.get_variable('beta', initializer=init_beta)\n    gamma = tf.get_variable('gamma', initializer=init_gamma)\n\n    circ = qubo_circuit(graph, steps, beta, gamma)\n    cuts = graph_cuts(graph)\n    maxcut = cuts.max()\n    expect = circ.run().expectation(cuts)\n    loss = - expect\n\n    # === Optimization ===\n    opt = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)\n    train = opt.minimize(loss, var_list=[beta, gamma])\n\n    with tf.Session() as sess:\n        init_op = tf.global_variables_initializer()\n        sess.run(init_op)\n\n        block = 10\n        min_difference = 0.0001\n        last_ratio = -1\n        for step in range(0, MAX_OPT_STEPS, block):\n            for _ in range(block):\n                sess.run(train)\n            ratio = sess.run(expect) / maxcut\n            if ratio - last_ratio < min_difference:\n                break\n            last_ratio = ratio\n\n            if verbose:\n                print(\"# step: {}  ratio: {:.4f}%\".format(step, ratio))\n\n        opt_beta = sess.run(beta)\n        opt_gamma = sess.run(gamma)\n\n    return ratio, opt_beta, opt_gamma", "response": "QAOA Maxcut using tensorflow"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the K - qubit identity gate", "response": "def identity_gate(qubits: Union[int, Qubits]) -> Gate:\n    \"\"\"Returns the K-qubit identity gate\"\"\"\n    _, qubits = qubits_count_tuple(qubits)\n    return I(*qubits)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndirect product of two gates.", "response": "def join_gates(*gates: Gate) -> Gate:\n    \"\"\"Direct product of two gates. Qubit count is the sum of each gate's\n    bit count.\"\"\"\n    vectors = [gate.vec for gate in gates]\n    vec = reduce(outer_product, vectors)\n    return Gate(vec.tensor, vec.qubits)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a conditional unitary gate.", "response": "def conditional_gate(control: Qubit, gate0: Gate, gate1: Gate) -> Gate:\n    \"\"\"Return a conditional unitary gate. Do gate0 on bit 1 if bit 0 is zero,\n    else do gate1 on 1\"\"\"\n    assert gate0.qubits == gate1.qubits  # FIXME\n\n    tensor = join_gates(P0(control), gate0).tensor\n    tensor += join_gates(P1(control), gate1).tensor\n    gate = Gate(tensor=tensor, qubits=[control, *gate0.qubits])\n    return gate"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn true if gate tensor is almost unitary.", "response": "def almost_unitary(gate: Gate) -> bool:\n    \"\"\"Return true if gate tensor is (almost) unitary\"\"\"\n    res = (gate @ gate.H).asoperator()\n    N = gate.qubit_nb\n    return np.allclose(asarray(res), np.eye(2**N), atol=TOLERANCE)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns true if gate tensor is almost identity", "response": "def almost_identity(gate: Gate) -> bool:\n    \"\"\"Return true if gate tensor is (almost) the identity\"\"\"\n    N = gate.qubit_nb\n    return np.allclose(asarray(gate.asoperator()), np.eye(2**N))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef almost_hermitian(gate: Gate) -> bool:\n    return np.allclose(asarray(gate.asoperator()),\n                       asarray(gate.H.asoperator()))", "response": "Return true if gate tensor is almost Hermitian."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprepares a 16 - qubit W state using sqrt iswaps and linear gates respecting linear topology", "response": "def prepare_w16():\n    \"\"\"\n    Prepare a 16-qubit W state using sqrt(iswaps) and local gates,\n    respecting linear topology\n\n    \"\"\"\n    ket = qf.zero_state(16)\n    circ = w16_circuit()\n    ket = circ.run(ket)\n    return ket"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef w16_circuit() -> qf.Circuit:\n\n    gates = [\n        qf.X(7),\n\n        qf.ISWAP(7, 8) ** 0.5,\n        qf.S(8),\n        qf.Z(8),\n\n        qf.SWAP(7, 6),\n        qf.SWAP(6, 5),\n        qf.SWAP(5, 4),\n\n        qf.SWAP(8, 9),\n        qf.SWAP(9, 10),\n        qf.SWAP(10, 11),\n\n\n        qf.ISWAP(4, 3) ** 0.5,\n        qf.S(3),\n        qf.Z(3),\n\n        qf.ISWAP(11, 12) ** 0.5,\n        qf.S(12),\n        qf.Z(12),\n\n        qf.SWAP(3, 2),\n        qf.SWAP(4, 5),\n        qf.SWAP(11, 10),\n        qf.SWAP(12, 13),\n\n\n        qf.ISWAP(2, 1) ** 0.5,\n        qf.S(1),\n        qf.Z(1),\n\n        qf.ISWAP(5, 6) ** 0.5,\n        qf.S(6),\n        qf.Z(6),\n\n        qf.ISWAP(10, 9) ** 0.5,\n        qf.S(9),\n        qf.Z(9),\n\n        qf.ISWAP(13, 14) ** 0.5,\n        qf.S(14),\n        qf.Z(14),\n\n\n        qf.ISWAP(1, 0) ** 0.5,\n        qf.S(0),\n        qf.Z(0),\n\n        qf.ISWAP(2, 3) ** 0.5,\n        qf.S(3),\n        qf.Z(3),\n\n        qf.ISWAP(5, 4) ** 0.5,\n        qf.S(4),\n        qf.Z(4),\n\n        qf.ISWAP(6, 7) ** 0.5,\n        qf.S(7),\n        qf.Z(7),\n\n        qf.ISWAP(9, 8) ** 0.5,\n        qf.S(8),\n        qf.Z(8),\n\n        qf.ISWAP(10, 11) ** 0.5,\n        qf.S(11),\n        qf.Z(11),\n\n        qf.ISWAP(13, 12) ** 0.5,\n        qf.S(12),\n        qf.Z(12),\n\n        qf.ISWAP(14, 15) ** 0.5,\n        qf.S(15),\n        qf.Z(15),\n        ]\n    circ = qf.Circuit(gates)\n\n    return circ", "response": "Returns a 16 - qubit W state circuit for the given 16 - qubit W state."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef muted(*streams):\n  devnull = open(os.devnull, 'w')\n  try:\n    old_streams = [os.dup(s.fileno()) for s in streams]\n    for s in streams:\n      os.dup2(devnull.fileno(), s.fileno())\n    yield\n  finally:\n    for o,n in zip(old_streams, streams):\n      os.dup2(o, n.fileno())\n    devnull.close()", "response": "A context manager to redirect stdout and stderr to / dev / null."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if a given function exists in the current platform.", "response": "def has_function(function_name, libraries=None):\n  \"\"\"Checks if a given functions exists in the current platform.\"\"\"\n  compiler = distutils.ccompiler.new_compiler()\n  with muted(sys.stdout, sys.stderr):\n    result = compiler.has_function(\n        function_name, libraries=libraries)\n  if os.path.exists('a.out'):\n    os.remove('a.out')\n  return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting the build command.", "response": "def run(self):\n    \"\"\"Execute the build command.\"\"\"\n\n    module = self.distribution.ext_modules[0]\n    base_dir = os.path.dirname(__file__)\n\n    if base_dir:\n      os.chdir(base_dir)\n\n    exclusions = []\n\n    for define in self.define or []:\n      module.define_macros.append(define)\n\n    for library in self.libraries or []:\n      module.libraries.append(library)\n\n    building_for_windows = self.plat_name in ('win32','win-amd64')\n    building_for_osx = 'macosx' in self.plat_name\n    building_for_linux = 'linux' in self.plat_name\n    building_for_freebsd = 'freebsd' in self.plat_name\n    building_for_openbsd = 'openbsd' in self.plat_name # need testing\n\n    if building_for_linux:\n      module.define_macros.append(('USE_LINUX_PROC', '1'))\n    elif building_for_windows:\n      module.define_macros.append(('USE_WINDOWS_PROC', '1'))\n      module.define_macros.append(('_CRT_SECURE_NO_WARNINGS', '1'))\n      module.libraries.append('kernel32')\n      module.libraries.append('advapi32')\n      module.libraries.append('user32')\n      module.libraries.append('crypt32')\n      module.libraries.append('ws2_32')\n    elif building_for_osx:\n      module.define_macros.append(('USE_MACH_PROC', '1'))\n      module.include_dirs.append('/usr/local/opt/openssl/include')\n      module.include_dirs.append('/opt/local/include')\n      module.library_dirs.append('/opt/local/lib')\n      module.include_dirs.append('/usr/local/include')\n      module.library_dirs.append('/usr/local/lib')\n    elif building_for_freebsd:\n      module.define_macros.append(('USE_FREEBSD_PROC', '1'))\n      module.include_dirs.append('/opt/local/include')\n      module.library_dirs.append('/opt/local/lib')\n      module.include_dirs.append('/usr/local/include')\n      module.library_dirs.append('/usr/local/lib')\n    elif building_for_openbsd:\n      module.define_macros.append(('USE_OPENBSD_PROC', '1'))\n      module.include_dirs.append('/opt/local/include')\n      module.library_dirs.append('/opt/local/lib')\n      module.include_dirs.append('/usr/local/include')\n      module.library_dirs.append('/usr/local/lib')\n    else:\n      module.define_macros.append(('USE_NO_PROC', '1'))\n\n    if has_function('memmem'):\n      module.define_macros.append(('HAVE_MEMMEM', '1'))\n    if has_function('strlcpy'):\n      module.define_macros.append(('HAVE_STRLCPY', '1'))\n    if has_function('strlcat'):\n      module.define_macros.append(('HAVE_STRLCAT', '1'))\n\n    if self.enable_profiling:\n      module.define_macros.append(('PROFILING_ENABLED', '1'))\n\n    if self.dynamic_linking:\n      module.libraries.append('yara')\n    else:\n      if not self.define or not ('HASH_MODULE', '1') in self.define:\n        if (has_function('MD5_Init', libraries=['crypto']) and\n            has_function('SHA256_Init', libraries=['crypto'])):\n          module.define_macros.append(('HASH_MODULE', '1'))\n          module.define_macros.append(('HAVE_LIBCRYPTO', '1'))\n          module.libraries.append('crypto')\n        else:\n          exclusions.append('yara/libyara/modules/hash.c')\n\n      if self.enable_magic:\n        module.define_macros.append(('MAGIC_MODULE', '1'))\n        module.libraries.append('magic')\n      else:\n        exclusions.append('yara/libyara/modules/magic.c')\n\n      if self.enable_cuckoo:\n        module.define_macros.append(('CUCKOO_MODULE', '1'))\n        module.libraries.append('jansson')\n      else:\n        exclusions.append('yara/libyara/modules/cuckoo.c')\n\n      if self.enable_dotnet:\n        module.define_macros.append(('DOTNET_MODULE', '1'))\n      else:\n        exclusions.append('yara/libyara/modules/dotnet.c')\n\n      if self.enable_dex:\n        module.define_macros.append(('DEX_MODULE', '1'))\n      else:\n        exclusions.append('yara/libyara/modules/dex.c')\n\n      if self.enable_macho:\n        module.define_macros.append(('MACHO_MODULE', '1'))\n      else:\n        exclusions.append('yara/libyara/modules/macho.c')\n\n      exclusions = [os.path.normpath(x) for x in exclusions]\n\n      for directory, _, files in os.walk('yara/libyara/'):\n        for x in files:\n          x = os.path.normpath(os.path.join(directory, x))\n          if x.endswith('.c') and x not in exclusions:\n            module.sources.append(x)\n\n    build_ext.run(self)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def handle_agent_message(self, agent_addr, message):\n        message_handlers = {\n            AgentHello: self.handle_agent_hello,\n            AgentJobStarted: self.handle_agent_job_started,\n            AgentJobDone: self.handle_agent_job_done,\n            AgentJobSSHDebug: self.handle_agent_job_ssh_debug,\n            Pong: self._handle_pong\n        }\n        try:\n            func = message_handlers[message.__class__]\n        except:\n            raise TypeError(\"Unknown message type %s\" % message.__class__)\n        self._create_safe_task(func(agent_addr, message))", "response": "Dispatch messages received from agents to the right handlers"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndispatches messages received from clients to the right handlers", "response": "async def handle_client_message(self, client_addr, message):\n        \"\"\"Dispatch messages received from clients to the right handlers\"\"\"\n\n        # Verify that the client is registered\n        if message.__class__ != ClientHello and client_addr not in self._registered_clients:\n            await ZMQUtils.send_with_addr(self._client_socket, client_addr, Unknown())\n            return\n\n        message_handlers = {\n            ClientHello: self.handle_client_hello,\n            ClientNewJob: self.handle_client_new_job,\n            ClientKillJob: self.handle_client_kill_job,\n            ClientGetQueue: self.handle_client_get_queue,\n            Ping: self.handle_client_ping\n        }\n        try:\n            func = message_handlers[message.__class__]\n        except:\n            raise TypeError(\"Unknown message type %s\" % message.__class__)\n        self._create_safe_task(func(client_addr, message))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend the update to all the containers in the given list of clients.", "response": "async def send_container_update_to_client(self, client_addrs):\n        \"\"\" :param client_addrs: list of clients to which we should send the update \"\"\"\n        self._logger.debug(\"Sending containers updates...\")\n        available_containers = tuple(self._containers.keys())\n        msg = BackendUpdateContainers(available_containers)\n        for client in client_addrs:\n            await ZMQUtils.send_with_addr(self._client_socket, client, msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle a ClientHello message. Send the available containers to the client.", "response": "async def handle_client_hello(self, client_addr, _: ClientHello):\n        \"\"\" Handle an ClientHello message. Send available containers to the client \"\"\"\n        self._logger.info(\"New client connected %s\", client_addr)\n        self._registered_clients.add(client_addr)\n        await self.send_container_update_to_client([client_addr])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def handle_client_ping(self, client_addr, _: Ping):\n        await ZMQUtils.send_with_addr(self._client_socket, client_addr, Pong())", "response": "Handle a Ping message. Pong the client."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def handle_client_new_job(self, client_addr, message: ClientNewJob):\n        self._logger.info(\"Adding a new job %s %s to the queue\", client_addr, message.job_id)\n        self._waiting_jobs[(client_addr, message.job_id)] = message\n        await self.update_queue()", "response": "Handle a ClientNewJob message. Add a job to the queue and trigger an update."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling a ClientKillJob message. Remove a job from the waiting list or send a JobDone message to the right agent.", "response": "async def handle_client_kill_job(self, client_addr, message: ClientKillJob):\n        \"\"\" Handle an ClientKillJob message. Remove a job from the waiting list or send the kill message to the right agent. \"\"\"\n        # Check if the job is not in the queue\n        if (client_addr, message.job_id) in self._waiting_jobs:\n            del self._waiting_jobs[(client_addr, message.job_id)]\n            # Do not forget to send a JobDone\n            await ZMQUtils.send_with_addr(self._client_socket, client_addr, BackendJobDone(message.job_id, (\"killed\", \"You killed the job\"),\n                                                                                           0.0, {}, {}, {}, \"\", None, \"\", \"\"))\n        # If the job is running, transmit the info to the agent\n        elif (client_addr, message.job_id) in self._job_running:\n            agent_addr = self._job_running[(client_addr, message.job_id)][0]\n            await ZMQUtils.send_with_addr(self._agent_socket, agent_addr, BackendKillJob((client_addr, message.job_id)))\n        else:\n            self._logger.warning(\"Client %s attempted to kill unknown job %s\", str(client_addr), str(message.job_id))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling a ClientGetQueue message. Send back info about the job queue", "response": "async def handle_client_get_queue(self, client_addr, _: ClientGetQueue):\n        \"\"\" Handles a ClientGetQueue message. Send back info about the job queue\"\"\"\n        #jobs_running: a list of tuples in the form\n        #(job_id, is_current_client_job, agent_name, info, launcher, started_at, max_end)\n        jobs_running = list()\n\n        for backend_job_id, content in self._job_running.items():\n            jobs_running.append((content[1].job_id, backend_job_id[0] == client_addr, self._registered_agents[content[0]],\n                                 content[1].course_id+\"/\"+content[1].task_id,\n                                 content[1].launcher, int(content[2]), int(content[2])+content[1].time_limit))\n\n        #jobs_waiting: a list of tuples in the form\n        #(job_id, is_current_client_job, info, launcher, max_time)\n        jobs_waiting = list()\n\n        for job_client_addr, msg in self._waiting_jobs.items():\n            if isinstance(msg, ClientNewJob):\n                jobs_waiting.append((msg.job_id, job_client_addr[0] == client_addr, msg.course_id+\"/\"+msg.task_id, msg.launcher,\n                                     msg.time_limit))\n\n        await ZMQUtils.send_with_addr(self._client_socket, client_addr, BackendGetQueue(jobs_running, jobs_waiting))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def update_queue(self):\n\n        # For now, round-robin\n        not_found_for_agent = []\n\n        while len(self._available_agents) > 0 and len(self._waiting_jobs) > 0:\n            agent_addr = self._available_agents.pop(0)\n\n            # Find first job that can be run on this agent\n            found = False\n            client_addr, job_id, job_msg = None, None, None\n            for (client_addr, job_id), job_msg in self._waiting_jobs.items():\n                if job_msg.environment in self._containers_on_agent[agent_addr]:\n                    found = True\n                    break\n\n            if not found:\n                self._logger.debug(\"Nothing to do for agent %s\", agent_addr)\n                not_found_for_agent.append(agent_addr)\n                continue\n\n            # Remove the job from the queue\n            del self._waiting_jobs[(client_addr, job_id)]\n\n            job_id = (client_addr, job_msg.job_id)\n            self._job_running[job_id] = (agent_addr, job_msg, time.time())\n            self._logger.info(\"Sending job %s %s to agent %s\", client_addr, job_msg.job_id, agent_addr)\n            await ZMQUtils.send_with_addr(self._agent_socket, agent_addr, BackendNewJob(job_id, job_msg.course_id, job_msg.task_id,\n                                                                                        job_msg.inputdata, job_msg.environment,\n                                                                                        job_msg.enable_network, job_msg.time_limit,\n                                                                                        job_msg.hard_time_limit, job_msg.mem_limit,\n                                                                                        job_msg.debug))\n\n        # Do not forget to add again for which we did not find jobs to do\n        self._available_agents += not_found_for_agent", "response": "Send waiting jobs to available agents and send them to the queue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling an AgentJobStarted message. Send the data back to the client", "response": "async def handle_agent_job_started(self, agent_addr, message: AgentJobStarted):\n        \"\"\"Handle an AgentJobStarted message. Send the data back to the client\"\"\"\n        self._logger.debug(\"Job %s %s started on agent %s\", message.job_id[0], message.job_id[1], agent_addr)\n        await ZMQUtils.send_with_addr(self._client_socket, message.job_id[0], BackendJobStarted(message.job_id[1]))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def handle_agent_job_done(self, agent_addr, message: AgentJobDone):\n\n        if agent_addr in self._registered_agents:\n            self._logger.info(\"Job %s %s finished on agent %s\", message.job_id[0], message.job_id[1], agent_addr)\n\n            # Remove the job from the list of running jobs\n            del self._job_running[message.job_id]\n\n            # Sent the data back to the client\n            await ZMQUtils.send_with_addr(self._client_socket, message.job_id[0], BackendJobDone(message.job_id[1], message.result,\n                                                                                                 message.grade, message.problems,\n                                                                                                 message.tests, message.custom,\n                                                                                                 message.state, message.archive,\n                                                                                                 message.stdout, message.stderr))\n\n            # The agent is available now\n            self._available_agents.append(agent_addr)\n        else:\n            self._logger.warning(\"Job result %s %s from non-registered agent %s\", message.job_id[0], message.job_id[1], agent_addr)\n\n        # update the queue\n        await self.update_queue()", "response": "Handle an AgentJobDone message. Send the data back to the client and start a new job if needed"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles an AgentJobSSHDebug message. Send the data back to the client", "response": "async def handle_agent_job_ssh_debug(self, _, message: AgentJobSSHDebug):\n        \"\"\"Handle an AgentJobSSHDebug message. Send the data back to the client\"\"\"\n        await ZMQUtils.send_with_addr(self._client_socket, message.job_id[0], BackendJobSSHDebug(message.job_id[1], message.host, message.port,\n                                                                                                 message.password))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npinging the agents and delete the agents.", "response": "async def _do_ping(self):\n        \"\"\" Ping the agents \"\"\"\n\n        # the list() call here is needed, as we remove entries from _registered_agents!\n        for agent_addr, friendly_name in list(self._registered_agents.items()):\n            try:\n                ping_count = self._ping_count.get(agent_addr, 0)\n                if ping_count > 5:\n                    self._logger.warning(\"Agent %s (%s) does not respond: removing from list.\", agent_addr, friendly_name)\n                    delete_agent = True\n                else:\n                    self._ping_count[agent_addr] = ping_count + 1\n                    await ZMQUtils.send_with_addr(self._agent_socket, agent_addr, Ping())\n                    delete_agent = False\n            except:\n                # This should not happen, but it's better to check anyway.\n                self._logger.exception(\"Failed to send ping to agent %s (%s). Removing it from list.\", agent_addr, friendly_name)\n                delete_agent = True\n\n            if delete_agent:\n                try:\n                    await self._delete_agent(agent_addr)\n                except:\n                    self._logger.exception(\"Failed to delete agent %s (%s)!\", agent_addr, friendly_name)\n\n        self._loop.call_later(1, self._create_safe_task, self._do_ping())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def _delete_agent(self, agent_addr):\n        self._available_agents = [agent for agent in self._available_agents if agent != agent_addr]\n        del self._registered_agents[agent_addr]\n        await self._recover_jobs(agent_addr)", "response": "Deletes an agent from the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def _recover_jobs(self, agent_addr):\n        for (client_addr, job_id), (agent, job_msg, _) in reversed(list(self._job_running.items())):\n            if agent == agent_addr:\n                await ZMQUtils.send_with_addr(self._client_socket, client_addr,\n                                              BackendJobDone(job_id, (\"crash\", \"Agent restarted\"),\n                                                             0.0, {}, {}, {}, \"\", None, None, None))\n                del self._job_running[(client_addr, job_id)]\n\n        await self.update_queue()", "response": "Recover the jobs sent to a crashed agent"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _create_safe_task(self, coroutine):\n        task = self._loop.create_task(coroutine)\n        task.add_done_callback(self.__log_safe_task)\n        return task", "response": "Creates a safe task with the given coroutine."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a valid date and return a new object.", "response": "def parse_date(date, default=None):\n    \"\"\" Parse a valid date \"\"\"\n    if date == \"\":\n        if default is not None:\n            return default\n        else:\n            raise Exception(\"Unknown format for \" + date)\n\n    for format_type in [\"%Y-%m-%d %H:%M:%S\", \"%Y-%m-%d %H:%M\", \"%Y-%m-%d %H\", \"%Y-%m-%d\", \"%d/%m/%Y %H:%M:%S\", \"%d/%m/%Y %H:%M\", \"%d/%m/%Y %H\",\n                        \"%d/%m/%Y\"]:\n        try:\n            return datetime.strptime(date, format_type)\n        except ValueError:\n            pass\n    raise Exception(\"Unknown format for \" + date)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if the task is not yet accessible", "response": "def before_start(self, when=None):\n        \"\"\" Returns True if the task/course is not yet accessible \"\"\"\n        if when is None:\n            when = datetime.now()\n\n        return self._val[0] > when"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the course or task is still open.", "response": "def is_open(self, when=None):\n        \"\"\" Returns True if the course/task is still open \"\"\"\n        if when is None:\n            when = datetime.now()\n\n        return self._val[0] <= when and when <= self._val[1]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the course or task is still open with the soft deadline.", "response": "def is_open_with_soft_deadline(self, when=None):\n        \"\"\" Returns True if the course/task is still open with the soft deadline \"\"\"\n        if when is None:\n            when = datetime.now()\n\n        return self._val[0] <= when and when <= self._soft_end"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_always_accessible(self):\n        return self._val[0] == datetime.min and self._val[1] == datetime.max", "response": "Returns true if the course or task is always accessible"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_never_accessible(self):\n        return self._val[0] == datetime.max and self._val[1] == datetime.max", "response": "Returns true if the course or task is never accessible"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_std_start_date(self):\n        first, _ = self._val\n        if first != datetime.min and first != datetime.max:\n            return first.strftime(\"%Y-%m-%d %H:%M:%S\")\n        else:\n            return \"\"", "response": "Returns the start date of the current user s system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_std_end_date(self):\n        _, second = self._val\n        if second != datetime.max:\n            return second.strftime(\"%Y-%m-%d %H:%M:%S\")\n        else:\n            return \"\"", "response": "Returns the end date of the current user s infrastructure."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef new_job(self, task, inputdata, launcher_name=\"Unknown\", debug=False):\n        job_semaphore = threading.Semaphore(0)\n\n        def manage_output(result, grade, problems, tests, custom, state, archive, stdout, stderr):\n            \"\"\" Manages the output of this job \"\"\"\n            manage_output.job_return = (result, grade, problems, tests, custom, state, archive, stdout, stderr)\n            job_semaphore.release()\n\n        manage_output.job_return = None\n\n        self._client.new_job(task, inputdata, manage_output, launcher_name, debug)\n        job_semaphore.acquire()\n        job_return = manage_output.job_return\n        return job_return", "response": "Runs a new job."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets request handler for GET_AUTH", "response": "def GET_AUTH(self):\n        \"\"\" GET request \"\"\"\n        return self.template_helper.get_renderer().queue(*self.submission_manager.get_job_queue_snapshot(), datetime.fromtimestamp)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the user info to reset", "response": "def get_reset_data(self, data):\n        \"\"\" Returns the user info to reset \"\"\"\n        error = False\n        reset = None\n        msg = \"\"\n        user = self.database.users.find_one({\"reset\": data[\"reset\"]})\n        if user is None:\n            error = True\n            msg = \"Invalid reset hash.\"\n        else:\n            reset = {\"hash\": data[\"reset\"], \"username\": user[\"username\"], \"realname\": user[\"realname\"]}\n\n        return msg, error, reset"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a user in the database.", "response": "def register_user(self, data):\n        \"\"\" Parses input and register user \"\"\"\n        error = False\n        msg = \"\"\n\n        email_re = re.compile(\n            r\"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\"  # dot-atom\n            r'|^\"([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-011\\013\\014\\016-\\177])*\"'  # quoted-string\n            r')@(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?$', re.IGNORECASE)  # domain\n\n        # Check input format\n        if re.match(r\"^[-_|~0-9A-Z]{4,}$\", data[\"username\"], re.IGNORECASE) is None:\n            error = True\n            msg = _(\"Invalid username format.\")\n        elif email_re.match(data[\"email\"]) is None:\n            error = True\n            msg = _(\"Invalid email format.\")\n        elif len(data[\"passwd\"]) < 6:\n            error = True\n            msg = _(\"Password too short.\")\n        elif data[\"passwd\"] != data[\"passwd2\"]:\n            error = True\n            msg = _(\"Passwords don't match !\")\n\n        if not error:\n            existing_user = self.database.users.find_one({\"$or\": [{\"username\": data[\"username\"]}, {\"email\": data[\"email\"]}]})\n            if existing_user is not None:\n                error = True\n                if existing_user[\"username\"] == data[\"username\"]:\n                    msg = _(\"This username is already taken !\")\n                else:\n                    msg = _(\"This email address is already in use !\")\n            else:\n                passwd_hash = hashlib.sha512(data[\"passwd\"].encode(\"utf-8\")).hexdigest()\n                activate_hash = hashlib.sha512(str(random.getrandbits(256)).encode(\"utf-8\")).hexdigest()\n                self.database.users.insert({\"username\": data[\"username\"],\n                                            \"realname\": data[\"realname\"],\n                                            \"email\": data[\"email\"],\n                                            \"password\": passwd_hash,\n                                            \"activate\": activate_hash,\n                                            \"bindings\": {},\n                                            \"language\": self.user_manager._session.get(\"language\", \"en\")})\n                try:\n                    web.sendmail(web.config.smtp_sendername, data[\"email\"], _(\"Welcome on INGInious\"),\n                                 _(\"\"\"Welcome on INGInious !\n\nTo activate your account, please click on the following link :\n\"\"\")\n                                 + web.ctx.home + \"/register?activate=\" + activate_hash)\n                    msg = _(\"You are succesfully registered. An email has been sent to you for activation.\")\n                except:\n                    error = True\n                    msg = _(\"Something went wrong while sending you activation email. Please contact the administrator.\")\n\n        return msg, error"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lost_passwd(self, data):\n        error = False\n        msg = \"\"\n\n        # Check input format\n        email_re = re.compile(\n            r\"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\"  # dot-atom\n            r'|^\"([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-011\\013\\014\\016-\\177])*\"'  # quoted-string\n            r')@(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?$', re.IGNORECASE)  # domain\n        if email_re.match(data[\"recovery_email\"]) is None:\n            error = True\n            msg = _(\"Invalid email format.\")\n\n        if not error:\n            reset_hash = hashlib.sha512(str(random.getrandbits(256)).encode(\"utf-8\")).hexdigest()\n            user = self.database.users.find_one_and_update({\"email\": data[\"recovery_email\"]}, {\"$set\": {\"reset\": reset_hash}})\n            if user is None:\n                error = True\n                msg = _(\"This email address was not found in database.\")\n            else:\n                try:\n                    web.sendmail(web.config.smtp_sendername, data[\"recovery_email\"], _(\"INGInious password recovery\"),\n                                 _(\"\"\"Dear {realname},\n\nSomeone (probably you) asked to reset your INGInious password. If this was you, please click on the following link :\n\"\"\").format(realname=user[\"realname\"]) + web.ctx.home + \"/register?reset=\" + reset_hash)\n                    msg = _(\"An email has been sent to you to reset your password.\")\n                except:\n                    error = True\n                    msg = _(\"Something went wrong while sending you reset email. Please contact the administrator.\")\n\n        return msg, error", "response": "Send a reset link to user to recover its password."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreset the user password", "response": "def reset_passwd(self, data):\n        \"\"\" Reset the user password \"\"\"\n        error = False\n        msg = \"\"\n\n        # Check input format\n        if len(data[\"passwd\"]) < 6:\n            error = True\n            msg = _(\"Password too short.\")\n        elif data[\"passwd\"] != data[\"passwd2\"]:\n            error = True\n            msg = _(\"Passwords don't match !\")\n\n        if not error:\n            passwd_hash = hashlib.sha512(data[\"passwd\"].encode(\"utf-8\")).hexdigest()\n            user = self.database.users.find_one_and_update({\"reset\": data[\"reset_hash\"]},\n                                                           {\"$set\": {\"password\": passwd_hash},\n                                                            \"$unset\": {\"reset\": True, \"activate\": True}})\n            if user is None:\n                error = True\n                msg = _(\"Invalid reset hash.\")\n            else:\n                msg = _(\"Your password has been successfully changed.\")\n\n        return msg, error"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the object representing the task", "response": "def get_task(self, course, taskid):\n        \"\"\"\n        :param course: a Course object\n        :param taskid: the task id of the task\n        :raise InvalidNameException, TaskNotFoundException, TaskUnreadableException\n        :return: an object representing the task, of the type given in the constructor\n        \"\"\"\n        if not id_checker(taskid):\n            raise InvalidNameException(\"Task with invalid name: \" + taskid)\n        if self._cache_update_needed(course, taskid):\n            self._update_cache(course, taskid)\n\n        return self._cache[(course.get_id(), taskid)][0]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_task_descriptor_content(self, courseid, taskid):\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n        if not id_checker(taskid):\n            raise InvalidNameException(\"Task with invalid name: \" + taskid)\n\n        descriptor_path, descriptor_manager = self._get_task_descriptor_info(courseid, taskid)\n        try:\n            task_content = descriptor_manager.load(self.get_task_fs(courseid, taskid).get(descriptor_path))\n        except Exception as e:\n            raise TaskUnreadableException(str(e))\n        return task_content", "response": "returns the content of the task descriptor as a dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_task_descriptor_extension(self, courseid, taskid):\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n        if not id_checker(taskid):\n            raise InvalidNameException(\"Task with invalid name: \" + taskid)\n        descriptor_path = self._get_task_descriptor_info(courseid, taskid)[0]\n        return splitext(descriptor_path)[1]", "response": "returns the extension of the task in the course"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a FileSystemProvider to the folder containing the task files", "response": "def get_task_fs(self, courseid, taskid):\n        \"\"\"\n        :param courseid: the course id of the course\n        :param taskid: the task id of the task\n        :raise InvalidNameException\n        :return: A FileSystemProvider to the folder containing the task files\n        \"\"\"\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n        if not id_checker(taskid):\n            raise InvalidNameException(\"Task with invalid name: \" + taskid)\n        return self._filesystem.from_subfolder(courseid).from_subfolder(taskid)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the content of the task descriptor with the dict in content.", "response": "def update_task_descriptor_content(self, courseid, taskid, content, force_extension=None):\n        \"\"\"\n        Update the task descriptor with the dict in content\n        :param courseid: the course id of the course\n        :param taskid: the task id of the task\n        :param content: the content to put in the task file\n        :param force_extension: If None, save it the same format. Else, save with the given extension\n        :raise InvalidNameException, TaskNotFoundException, TaskUnreadableException\n        \"\"\"\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n        if not id_checker(taskid):\n            raise InvalidNameException(\"Task with invalid name: \" + taskid)\n\n        if force_extension is None:\n            path_to_descriptor, descriptor_manager = self._get_task_descriptor_info(courseid, taskid)\n        elif force_extension in self.get_available_task_file_extensions():\n            path_to_descriptor = \"task.\" + force_extension\n            descriptor_manager = self._task_file_managers[force_extension]\n        else:\n            raise TaskReaderNotFoundException()\n\n        try:\n            self.get_task_fs(courseid, taskid).put(path_to_descriptor, descriptor_manager.dump(content))\n        except:\n            raise TaskNotFoundException()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the list of all available tasks in a course", "response": "def get_readable_tasks(self, course):\n        \"\"\" Returns the list of all available tasks in a course \"\"\"\n        course_fs = self._filesystem.from_subfolder(course.get_id())\n        tasks = [\n            task[0:len(task)-1]  # remove trailing /\n            for task in course_fs.list(folders=True, files=False, recursive=False)\n            if self._task_file_exists(course_fs.from_subfolder(task))]\n        return tasks"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _task_file_exists(self, task_fs):\n        for filename in [\"task.{}\".format(ext) for ext in self.get_available_task_file_extensions()]:\n            if task_fs.exists(filename):\n                return True\n        return False", "response": "Returns true if a task file exists in this directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_all_possible_task_files(self, courseid, taskid):\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n        if not id_checker(taskid):\n            raise InvalidNameException(\"Task with invalid name: \" + taskid)\n        task_fs = self.get_task_fs(courseid, taskid)\n        for ext in self.get_available_task_file_extensions():\n            try:\n                task_fs.delete(\"task.\"+ext)\n            except:\n                pass", "response": "Deletes all possible task files in the task directory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting all the tasks in a course", "response": "def get_all_tasks(self, course):\n        \"\"\"\n        :return: a table containing taskid=>Task pairs\n        \"\"\"\n        tasks = self.get_readable_tasks(course)\n        output = {}\n        for task in tasks:\n            try:\n                output[task] = self.get_task(course, task)\n            except:\n                pass\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the name of the task descriptor file manager and the name of the task file manager", "response": "def _get_task_descriptor_info(self, courseid, taskid):\n        \"\"\"\n        :param courseid: the course id of the course\n        :param taskid: the task id of the task\n        :raise InvalidNameException, TaskNotFoundException\n        :return: a tuple, containing:\n            (descriptor filename,\n             task file manager for the descriptor)\n        \"\"\"\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n        if not id_checker(taskid):\n            raise InvalidNameException(\"Task with invalid name: \" + taskid)\n\n        task_fs = self.get_task_fs(courseid, taskid)\n        for ext, task_file_manager in self._task_file_managers.items():\n            if task_fs.exists(\"task.\"+ext):\n                return \"task.\" + ext, task_file_manager\n\n        raise TaskNotFoundException()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _cache_update_needed(self, course, taskid):\n        if not id_checker(taskid):\n            raise InvalidNameException(\"Task with invalid name: \" + taskid)\n\n        task_fs = self.get_task_fs(course.get_id(), taskid)\n\n        if (course.get_id(), taskid) not in self._cache:\n            return True\n\n        try:\n            last_update, __, __ = self._get_last_updates(course, taskid, task_fs, False)\n        except:\n            raise TaskNotFoundException()\n\n        last_modif = self._cache[(course.get_id(), taskid)][1]\n        for filename, mftime in last_update.items():\n            if filename not in last_modif or last_modif[filename] < mftime:\n                return True\n\n        return False", "response": "Returns True if an update of the cache is needed."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _update_cache(self, course, taskid):\n        if not id_checker(taskid):\n            raise InvalidNameException(\"Task with invalid name: \" + taskid)\n\n        task_fs = self.get_task_fs(course.get_id(), taskid)\n        last_modif, translation_fs, task_content = self._get_last_updates(course, taskid, task_fs, True)\n\n        self._cache[(course.get_id(), taskid)] = (\n            self._task_class(course, taskid, task_content, task_fs, translation_fs, self._hook_manager, self._task_problem_types),\n            last_modif\n        )", "response": "Updates the cache with the contents of the task."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncleans the cache of all the tasks for a given course.", "response": "def update_cache_for_course(self, courseid):\n        \"\"\"\n        Clean/update the cache of all the tasks for a given course (id)\n        :param courseid:\n        \"\"\"\n        to_drop = []\n        for (cid, tid) in self._cache:\n            if cid == courseid:\n                to_drop.append(tid)\n        for tid in to_drop:\n            del self._cache[(courseid, tid)]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete the content of the task folder", "response": "def delete_task(self, courseid, taskid):\n        \"\"\"\n        :param courseid: the course id of the course\n        :param taskid: the task id of the task\n        :raise InvalidNameException or CourseNotFoundException\n        Erase the content of the task folder\n        \"\"\"\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n        if not id_checker(taskid):\n            raise InvalidNameException(\"Task with invalid name: \" + taskid)\n\n        task_fs = self.get_task_fs(courseid, taskid)\n\n        if task_fs.exists():\n            task_fs.delete()\n            get_course_logger(courseid).info(\"Task %s erased from the factory.\", taskid)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dict of available containers in the form of a dict of form of a dict of the form of a dict of the form of a dict of the form of a dict of the form of a dict of the form of a dict of the form of a dict of the form of a dict of the form of the form of a dict of the form of the form of a dict of the form of the form of the object.", "response": "def get_containers(self):\n        \"\"\"\n        :return: a dict of available containers in the form\n        {\n            \"name\": {                          #for example, \"default\"\n                \"id\": \"container img id\",      #             \"sha256:715c5cb5575cdb2641956e42af4a53e69edf763ce701006b2c6e0f4f39b68dd3\"\n                \"created\": 12345678            # create date\n                \"ports\": [22, 434]             # list of ports needed\n            }\n        }\n        \"\"\"\n\n        # First, create a dict with {\"id\": {\"title\": \"alias\", \"created\": 000, \"ports\": [0, 1]}}\n        images = {}\n        for x in self._docker.images.list(filters={\"label\": \"org.inginious.grading.name\"}):\n            try:\n                title = x.labels[\"org.inginious.grading.name\"]\n                created = datetime.strptime(x.attrs['Created'][:-4], \"%Y-%m-%dT%H:%M:%S.%f\").timestamp()\n                ports = [int(y) for y in x.labels[\"org.inginious.grading.ports\"].split(\n                    \",\")] if \"org.inginious.grading.ports\" in x.labels else []\n                images[x.attrs['Id']] = {\"title\": title, \"created\": created, \"ports\": ports}\n            except:\n                logging.getLogger(\"inginious.agent\").exception(\"Container %s is badly formatted\", title)\n\n        # Then, we keep only the last version of each name\n        latest = {}\n        for img_id, img_c in images.items():\n            if img_c[\"title\"] not in latest or latest[img_c[\"title\"]][\"created\"] < img_c[\"created\"]:\n                latest[img_c[\"title\"]] = {\"id\": img_id, \"created\": img_c[\"created\"], \"ports\": img_c[\"ports\"]}\n        return latest"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_host_ip(self, env_with_dig='ingi/inginious-c-default'):\n        try:\n            container = self._docker.containers.create(env_with_dig, command=\"dig +short myip.opendns.com @resolver1.opendns.com\")\n            container.start()\n            response = container.wait()\n            assert response[\"StatusCode\"] == 0 if isinstance(response, dict) else response == 0\n            answer = container.logs(stdout=True, stderr=False).decode('utf8').strip()\n            container.remove(v=True, link=False, force=True)\n            return answer\n        except:\n            return None", "response": "Get the external IP of the host of the Docker daemon. Uses OpenDNS internally."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a container in the Docker system.", "response": "def create_container(self, environment, network_grading, mem_limit, task_path, sockets_path,\n                         course_common_path, course_common_student_path, ports=None):\n        \"\"\"\n        Creates a container.\n        :param environment: env to start (name/id of a docker image)\n        :param network_grading: boolean to indicate if the network should be enabled in the container or not\n        :param mem_limit: in Mo\n        :param task_path: path to the task directory that will be mounted in the container\n        :param sockets_path: path to the socket directory that will be mounted in the container\n        :param ports: dictionary in the form {docker_port: external_port}\n        :return: the container id\n        \"\"\"\n        task_path = os.path.abspath(task_path)\n        sockets_path = os.path.abspath(sockets_path)\n        course_common_path = os.path.abspath(course_common_path)\n        course_common_student_path = os.path.abspath(course_common_student_path)\n        if ports is None:\n            ports = {}\n\n        response = self._docker.containers.create(\n            environment,\n            stdin_open=True,\n            mem_limit=str(mem_limit) + \"M\",\n            memswap_limit=str(mem_limit) + \"M\",\n            mem_swappiness=0,\n            oom_kill_disable=True,\n            network_mode=(\"bridge\" if (network_grading or len(ports) > 0) else 'none'),\n            ports=ports,\n            volumes={\n                task_path: {'bind': '/task'},\n                sockets_path: {'bind': '/sockets'},\n                course_common_path: {'bind': '/course/common', 'mode': 'ro'},\n                course_common_student_path: {'bind': '/course/common/student', 'mode': 'ro'}\n            }\n        )\n        return response.id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_container_student(self, parent_container_id, environment, network_grading, mem_limit,  student_path,\n                                 socket_path, systemfiles_path, course_common_student_path):\n        \"\"\"\n        Creates a student container\n        :param parent_container_id: id of the \"parent\" container\n        :param environment: env to start (name/id of a docker image)\n        :param network_grading: boolean to indicate if the network should be enabled in the container or not (share the parent stack)\n        :param mem_limit: in Mo\n        :param student_path: path to the task directory that will be mounted in the container\n        :param socket_path: path to the socket that will be mounted in the container\n        :param systemfiles_path: path to the systemfiles folder containing files that can override partially some defined system files\n        :return: the container id\n        \"\"\"\n        student_path = os.path.abspath(student_path)\n        socket_path = os.path.abspath(socket_path)\n        systemfiles_path = os.path.abspath(systemfiles_path)\n        course_common_student_path = os.path.abspath(course_common_student_path)\n\n        response = self._docker.containers.create(\n            environment,\n            stdin_open=True,\n            command=\"_run_student_intern\",\n            mem_limit=str(mem_limit) + \"M\",\n            memswap_limit=str(mem_limit) + \"M\",\n            mem_swappiness=0,\n            oom_kill_disable=True,\n            network_mode=('none' if not network_grading else ('container:' + parent_container_id)),\n            volumes={\n                student_path: {'bind': '/task/student'},\n                 socket_path: {'bind': '/__parent.sock'},\n                 systemfiles_path: {'bind': '/task/systemfiles', 'mode': 'ro'},\n                 course_common_student_path: {'bind': '/course/common/student', 'mode': 'ro'}\n            }\n        )\n        return response.id", "response": "Creates a student container"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the full stdout and stderr of a container", "response": "def get_logs(self, container_id):\n        \"\"\" Return the full stdout/stderr of a container\"\"\"\n        stdout = self._docker.containers.get(container_id).logs(stdout=True, stderr=False).decode('utf8')\n        stderr = self._docker.containers.get(container_id).logs(stdout=False, stderr=True).decode('utf8')\n        return stdout, stderr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an iterable that contains dictionnaries with the stats of the running container.", "response": "def get_stats(self, container_id):\n        \"\"\"\n        :param container_id:\n        :return: an iterable that contains dictionnaries with the stats of the running container. See the docker api for content.\n        \"\"\"\n        return self._docker.containers.get(container_id).stats(decode=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_container(self, container_id):\n        self._docker.containers.get(container_id).remove(v=True, link=False, force=True)", "response": "Removes a container from the container store"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nkill a container :param signal: custom signal. Default is SIGKILL.", "response": "def kill_container(self, container_id, signal=None):\n        \"\"\"\n        Kills a container\n        :param signal: custom signal. Default is SIGKILL.\n        \"\"\"\n        self._docker.containers.get(container_id).kill(signal)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an iterable that returns all the events from the Docker API.", "response": "def event_stream(self, filters=None):\n        \"\"\"\n        :param filters: filters to apply on messages. See docker api.\n        :return: an iterable that contains events from docker. See the docker api for content.\n        \"\"\"\n        if filters is None:\n            filters = {}\n        return self._docker.events(decode=True, filters=filters)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef close_socket(self):\n        try:\n            self.docker_py_sock._sock.close()  # pylint: disable=protected-access\n        except AttributeError:\n            pass\n        self.docker_py_sock.close()", "response": "Correctly closes the socket"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _checkpath(self, path):\n        if path.startswith(\"/\") or \"..\" in path or path.strip() != path:\n            raise NotFoundException()", "response": "Checks that a given path is valid. Raises NotFoundException if it s not."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef POST_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        course, __ = self.get_course_and_check_rights(courseid, allow_all_staff=False)\n        user_input = web.input(tasks=[], aggregations=[], users=[])\n\n        if \"submission\" in user_input:\n            # Replay a unique submission\n            submission = self.database.submissions.find_one({\"_id\": ObjectId(user_input.submission)})\n            if submission is None:\n                raise web.notfound()\n\n            web.header('Content-Type', 'application/json')\n            self.submission_manager.replay_job(course.get_task(submission[\"taskid\"]), submission)\n            return json.dumps({\"status\": \"waiting\"})\n        else:\n            # Replay several submissions, check input\n            tasks = course.get_tasks()\n            error = False\n            msg = _(\"Selected submissions were set for replay.\")\n            for i in user_input.tasks:\n                if i not in tasks.keys():\n                    msg = _(\"Task with id {} does not exist !\").format(i)\n                    error = True\n\n            if not error:\n                # Load submissions\n                submissions, __ = self.get_selected_submissions(course, user_input.filter_type, user_input.tasks, user_input.users, user_input.aggregations, user_input.type)\n                for submission in submissions:\n                    self.submission_manager.replay_job(tasks[submission[\"taskid\"]], submission)\n\n            return self.show_page(course, web.input(), msg, error)", "response": "Handles POST request for the submission and replay the submission."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget request handler for GET_AUTH", "response": "def GET_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        \"\"\" GET request \"\"\"\n        course, __ = self.get_course_and_check_rights(courseid, allow_all_staff=False)\n        return self.show_page(course, web.input())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves user profile modifications", "response": "def save_profile(self, userdata, data):\n        \"\"\" Save user profile modifications \"\"\"\n        result = userdata\n        error = False\n\n        # Check if updating username.\n        if not userdata[\"username\"] and \"username\" in data:\n            if re.match(r\"^[-_|~0-9A-Z]{4,}$\", data[\"username\"], re.IGNORECASE) is None:\n                error = True\n                msg = _(\"Invalid username format.\")\n            elif self.database.users.find_one({\"username\": data[\"username\"]}):\n                error = True\n                msg = _(\"Username already taken\")\n            else:\n                result = self.database.users.find_one_and_update({\"email\": userdata[\"email\"]},\n                                                                 {\"$set\": {\"username\": data[\"username\"]}},\n                                                                 return_document=ReturnDocument.AFTER)\n                if not result:\n                    error = True\n                    msg = _(\"Incorrect email.\")\n                else:\n                    self.user_manager.connect_user(result[\"username\"], result[\"realname\"], result[\"email\"],\n                                                   result[\"language\"])\n                    msg = _(\"Profile updated.\")\n            return result, msg, error\n\n        # Check if updating the password.\n        if self.app.allow_registration and len(data[\"passwd\"]) in range(1, 6):\n            error = True\n            msg = _(\"Password too short.\")\n            return result, msg, error\n        elif self.app.allow_registration and len(data[\"passwd\"]) > 0 and data[\"passwd\"] != data[\"passwd2\"]:\n            error = True\n            msg = _(\"Passwords don't match !\")\n            return result, msg, error\n        elif self.app.allow_registration and len(data[\"passwd\"]) >= 6:\n            oldpasswd_hash = hashlib.sha512(data[\"oldpasswd\"].encode(\"utf-8\")).hexdigest()\n            passwd_hash = hashlib.sha512(data[\"passwd\"].encode(\"utf-8\")).hexdigest()\n\n            match = {\"username\": self.user_manager.session_username()}\n            if \"password\" in userdata:\n                match[\"password\"] = oldpasswd_hash\n\n            result = self.database.users.find_one_and_update(match,\n                                                             {\"$set\": {\"password\": passwd_hash}},\n                                                             return_document=ReturnDocument.AFTER)\n            if not result:\n                error = True\n                msg = _(\"Incorrect old password.\")\n                return result, msg, error\n\n        # Check if updating language\n        if data[\"language\"] != userdata[\"language\"]:\n            language = data[\"language\"] if data[\"language\"] in self.app.available_languages else \"en\"\n            result = self.database.users.find_one_and_update({\"username\": self.user_manager.session_username()},\n                                                             {\"$set\": {\"language\": language}},\n                                                             return_document=ReturnDocument.AFTER)\n            if not result:\n                error = True\n                msg = _(\"Incorrect username.\")\n                return result, msg, error\n            else:\n                self.user_manager.set_session_language(language)\n\n        # Checks if updating name\n        if len(data[\"realname\"]) > 0:\n            result = self.database.users.find_one_and_update({\"username\": self.user_manager.session_username()},\n                                                             {\"$set\": {\"realname\": data[\"realname\"]}},\n                                                             return_document=ReturnDocument.AFTER)\n            if not result:\n                error = True\n                msg = _(\"Incorrect username.\")\n                return result, msg, error\n            else:\n                self.user_manager.set_session_realname(data[\"realname\"])\n        else:\n            error = True\n            msg = _(\"Name is too short.\")\n            return result, msg, error\n\n        msg = _(\"Profile updated.\")\n        return result, msg, error"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets request handler for GET_AUTH", "response": "def GET_AUTH(self):  # pylint: disable=arguments-differ\n        \"\"\" GET request \"\"\"\n        userdata = self.database.users.find_one({\"email\": self.user_manager.session_email()})\n\n        if not userdata:\n            raise web.notfound()\n\n        return self.template_helper.get_renderer().preferences.profile(\"\", False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef POST_AUTH(self):  # pylint: disable=arguments-differ\n        userdata = self.database.users.find_one({\"email\": self.user_manager.session_email()})\n\n        if not userdata:\n            raise web.notfound()\n\n        msg = \"\"\n        error = False\n        data = web.input()\n        if \"save\" in data:\n            userdata, msg, error = self.save_profile(userdata, data)\n\n        return self.template_helper.get_renderer().preferences.profile(msg, error)", "response": "POST request handler for user profile"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init(plugin_manager, course_factory, client, config):\n    courseid = config.get('courseid', 'external')\n    course = course_factory.get_course(courseid)\n    page_pattern = config.get('page_pattern', '/external')\n    return_fields = re.compile(config.get('return_fields', '^(result|text|problems)$'))\n\n    client_buffer = ClientBuffer(client)\n    client_sync = ClientSync(client)\n\n    class ExternalGrader(INGIniousPage):\n\n        \"\"\" Manages job from outside, using the default input \"\"\"\n\n        def GET(self):\n            \"\"\" GET request \"\"\"\n            return \"\"\"\n            <!DOCTYPE html>\n            <html>\n                <head>\n                    <title>External grade POST test</title>\n                </head>\n                <body>\n                    <form method=\"post\">\n                        <textarea style=\"width:100%; height:400px;\" name=\"input\">{\"question1\":\"print 'Hello World!'\"}</textarea><br/>\n                        <input type=\"text\" name=\"taskid\" value=\"helloworld\"/> (taskid)<br/>\n                        <input type=\"checkbox\" name=\"async\"/> async?<br/>\n                        <input type=\"submit\"/>\n                    </form>\n                </body>\n            </html>\"\"\"\n\n        def keep_only_config_return_values(self, job_return):\n            \"\"\" Keep only some useful return values \"\"\"\n            return {key: value for key, value in job_return.items() if return_fields.match(key)}\n\n        def POST(self):\n            \"\"\" POST request \"\"\"\n            web.header('Access-Control-Allow-Origin', '*')\n            web.header('Content-Type', 'application/json')\n            post_input = web.input()\n\n            if \"input\" in post_input and \"taskid\" in post_input:\n                # New job\n                try:\n                    task_input = json.loads(post_input.input)\n                except:\n                    return json.dumps({\"status\": \"error\", \"status_message\": \"Cannot decode input\"})\n\n                try:\n                    task = course.get_task(post_input.taskid)\n                except:\n                    return json.dumps({\"status\": \"error\", \"status_message\": \"Cannot open task\"})\n\n                if not task.input_is_consistent(task_input, self.default_allowed_file_extensions, self.default_max_file_size):\n                    return json.dumps({\"status\": \"error\", \"status_message\": \"Input is not consistent with the task\"})\n\n                if post_input.get(\"async\") is None:\n                    # New sync job\n                    try:\n                        result, grade, problems, tests, custom, state, archive, stdout, stderr = client_sync.new_job(task, task_input, \"Plugin - Simple Grader\")\n                        job_return = {\"result\":result, \"grade\": grade, \"problems\": problems, \"tests\": tests, \"custom\": custom, \"state\": state, \"archive\": archive, \"stdout\": stdout, \"stderr\": stderr}\n                    except:\n                        return json.dumps({\"status\": \"error\", \"status_message\": \"An internal error occurred\"})\n\n                    return json.dumps(dict(list({\"status\": \"done\"}.items()) + list(self.keep_only_config_return_values(job_return).items())))\n                else:\n                    # New async job\n                    jobid = client_buffer.new_job(task, task_input, \"Plugin - Simple Grader\")\n                    return json.dumps({\"status\": \"done\", \"jobid\": str(jobid)})\n            elif \"jobid\" in post_input:\n                # Get status of async job\n                if client_buffer.is_waiting(post_input[\"jobid\"]):\n                    return json.dumps({\"status\": \"waiting\"})\n                elif client_buffer.is_done(post_input[\"jobid\"]):\n                    result, grade, problems, tests, custom, state, archive, stdout, stderr = client_buffer.get_result(post_input[\"jobid\"])\n                    job_return = {\"result\": result, \"grade\": grade, \"problems\": problems, \"tests\": tests,\n                                  \"custom\": custom, \"archive\": archive, \"stdout\": stdout, \"stderr\": stderr}\n                    return json.dumps(dict(list({\"status\": \"done\"}.items()) + list(self.keep_only_config_return_values(job_return).items())))\n                else:\n                    return json.dumps({\"status\": \"error\", \"status_message\": \"There is no job with jobid {}\".format(post_input[\"jobid\"])})\n            else:\n                return json.dumps({\"status\": \"error\", \"status_message\": \"Unknown request type\"})\n\n    plugin_manager.add_page(page_pattern, ExternalGrader)", "response": "Initialize the external grader plugin."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef API_GET(self, courseid=None):  # pylint: disable=arguments-differ\n        output = []\n\n        if courseid is None:\n            courses = self.course_factory.get_all_courses()\n        else:\n            try:\n                courses = {courseid: self.course_factory.get_course(courseid)}\n            except:\n                raise APINotFound(\"Course not found\")\n\n        username = self.user_manager.session_username()\n        user_info = self.database.users.find_one({\"username\": username})\n\n        for courseid, course in courses.items():\n            if self.user_manager.course_is_open_to_user(course, username, False) or course.is_registration_possible(user_info):\n                data = {\n                    \"id\": courseid,\n                    \"name\": course.get_name(self.user_manager.session_language()),\n                    \"require_password\": course.is_password_needed_for_registration(),\n                    \"is_registered\": self.user_manager.course_is_open_to_user(course, username, False)\n                }\n                if self.user_manager.course_is_open_to_user(course, username, False):\n                    data[\"tasks\"] = {taskid: task.get_name(self.user_manager.session_language()) for taskid, task in course.get_tasks().items()}\n                    data[\"grade\"] = self.user_manager.get_course_cache(username, course)[\"grade\"]\n                output.append(data)\n\n        return 200, output", "response": "This function returns a list of courses available to the connected client."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert the output to what the client asks for", "response": "def _api_convert_output(return_value):\n    \"\"\" Convert the output to what the client asks \"\"\"\n    content_type = web.ctx.environ.get('CONTENT_TYPE', 'text/json')\n\n    if \"text/json\" in content_type:\n        web.header('Content-Type', 'text/json; charset=utf-8')\n        return json.dumps(return_value)\n    if \"text/html\" in content_type:\n        web.header('Content-Type', 'text/html; charset=utf-8')\n        dump = yaml.dump(return_value)\n        return \"<pre>\" + web.websafe(dump) + \"</pre>\"\n    if \"text/yaml\" in content_type or \\\n                    \"text/x-yaml\" in content_type or \\\n                    \"application/yaml\" in content_type or \\\n                    \"application/x-yaml\" in content_type:\n        web.header('Content-Type', 'text/yaml; charset=utf-8')\n        dump = yaml.dump(return_value)\n        return dump\n    web.header('Content-Type', 'text/json; charset=utf-8')\n    return json.dumps(return_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef GET(self, *args, **kwargs):\n        return self._handle_api(self.API_GET, args, kwargs)", "response": "Handle a GET request"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef PUT(self, *args, **kwargs):\n        return self._handle_api(self.API_PUT, args, kwargs)", "response": "This is the PUT method. It is used to make an HTTP PUT request."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef PATCH(self, *args, **kwargs):\n        return self._handle_api(self.API_PATCH, args, kwargs)", "response": "A version of the PATCH method."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef OPTIONS(self, *args, **kwargs):\n        return self._handle_api(self.API_OPTIONS, args, kwargs)", "response": "Handle an OPTIONS request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _handle_api(self, handler, handler_args, handler_kwargs):\n        try:\n            status_code, return_value = handler(*handler_args, **handler_kwargs)\n        except APIError as error:\n            return error.send()\n\n        web.ctx.status = _convert_http_status(status_code)\n        return _api_convert_output(return_value)", "response": "Handle call to subclasses and convert the output to an appropriate value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _guess_available_methods(self):\n        available_methods = []\n        for m in [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"]:\n            self_method = getattr(type(self), \"API_{}\".format(m))\n            super_method = getattr(APIPage, \"API_{}\".format(m))\n            if self_method != super_method:\n                available_methods.append(m)\n        return available_methods", "response": "Guess the method implemented by the subclass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _verify_authentication(self, handler, args, kwargs):\n        if not self.user_manager.session_logged_in():\n            raise APIForbidden()\n        return handler(*args, **kwargs)", "response": "Verify that the user is authenticated"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send(self):\n        web.ctx.status = _convert_http_status(self.status_code)\n        return _api_convert_output(self.return_value)", "response": "Send the API Exception to the client"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _before_submission_insertion(self, task, inputdata, debug, obj):\n        username = self._user_manager.session_username()\n\n        if task.is_group_task() and not self._user_manager.has_staff_rights_on_course(task.get_course(), username):\n            group = self._database.aggregations.find_one(\n                {\"courseid\": task.get_course_id(), \"groups.students\": username},\n                {\"groups\": {\"$elemMatch\": {\"students\": username}}})\n\n            obj.update({\"username\": group[\"groups\"][0][\"students\"]})\n        else:\n            obj.update({\"username\": [username]})\n\n        lti_info = self._user_manager.session_lti_info()\n        if lti_info is not None and task.get_course().lti_send_back_grade():\n            outcome_service_url = lti_info[\"outcome_service_url\"]\n            outcome_result_id = lti_info[\"outcome_result_id\"]\n            outcome_consumer_key = lti_info[\"consumer_key\"]\n\n            # safety check\n            if outcome_result_id is None or outcome_service_url is None:\n                self._logger.error(\"outcome_result_id or outcome_service_url is None, but grade needs to be sent back to TC! Ignoring.\")\n                return\n\n            obj.update({\"outcome_service_url\": outcome_service_url,\n                        \"outcome_result_id\": outcome_result_id,\n                        \"outcome_consumer_key\": outcome_consumer_key})", "response": "Called before any new submission is inserted into the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls after any new submission is inserted into the database.", "response": "def _after_submission_insertion(self, task, inputdata, debug, submission, submissionid):\n        \"\"\"\n                Called after any new submission is inserted into the database, but before starting the job.  Should be overridden in subclasses.\n                :param task: Task related to the submission\n                :param inputdata: input of the student\n                :param debug: True, False or \"ssh\". See add_job.\n                :param submission: the new document that was inserted (do not contain _id)\n                :param submissionid: submission id of the submission\n                \"\"\"\n        # If we are submitting for a group, send the group (user list joined with \",\") as username\n        if \"group\" not in [p.get_id() for p in task.get_problems()]:  # do not overwrite\n            username = self._user_manager.session_username()\n            if task.is_group_task() and not self._user_manager.has_staff_rights_on_course(task.get_course(), username):\n                group = self._database.aggregations.find_one(\n                    {\"courseid\": task.get_course_id(), \"groups.students\": username},\n                    {\"groups\": {\"$elemMatch\": {\"students\": username}}})\n                inputdata[\"username\"] = ','.join(group[\"groups\"][0][\"students\"])\n\n        return self._delete_exceeding_submissions(self._user_manager.session_username(), task)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreplays a submission to the queue", "response": "def replay_job(self, task, submission, copy=False, debug=False):\n        \"\"\"\n        Replay a submission: add the same job in the queue, keeping submission id, submission date and input data\n        :param submission: Submission to replay\n        :param copy: If copy is true, the submission will be copied to admin submissions before replay\n        :param debug: If debug is true, more debug data will be saved\n        \"\"\"\n        if not self._user_manager.session_logged_in():\n            raise Exception(\"A user must be logged in to submit an object\")\n\n        # Don't enable ssh debug\n        ssh_callback = lambda host, port, password: self._handle_ssh_callback(submission[\"_id\"], host, port, password)\n\n        # Load input data and add username to dict\n        inputdata = bson.BSON.decode(self._gridfs.get(submission[\"input\"]).read())\n\n        if not copy:\n            submissionid = submission[\"_id\"]\n            username = submission[\"username\"][0] # TODO: this may be inconsistent with add_job\n\n            # Remove the submission archive : it will be regenerated\n            if submission.get(\"archive\", None) is not None:\n                self._gridfs.delete(submission[\"archive\"])\n        else:\n            del submission[\"_id\"]\n            username = self._user_manager.session_username()\n            submission[\"username\"] = [username]\n            submission[\"submitted_on\"] = datetime.now()\n            inputdata[\"@username\"] = username\n            inputdata[\"@lang\"] = self._user_manager.session_language()\n            submission[\"input\"] = self._gridfs.put(bson.BSON.encode(inputdata))\n            submission[\"tests\"] = {} # Be sure tags are reinitialized\n            submissionid = self._database.submissions.insert(submission)\n\n        jobid = self._client.new_job(task, inputdata,\n                                     (lambda result, grade, problems, tests, custom, state, archive, stdout, stderr:\n                                      self._job_done_callback(submissionid, task, result, grade, problems, tests, custom, state, archive, stdout, stderr, copy)),\n                                     \"Frontend - {}\".format(submission[\"username\"]), debug, ssh_callback)\n\n        # Clean the submission document in db\n        self._database.submissions.update(\n            {\"_id\": submission[\"_id\"]},\n            {\"$set\": {\"jobid\": jobid, \"status\": \"waiting\", \"response_type\": task.get_response_type()},\n             \"$unset\": {\"result\": \"\", \"grade\": \"\", \"text\": \"\", \"tests\": \"\", \"problems\": \"\", \"archive\": \"\", \"state\": \"\", \"custom\": \"\"}\n             })\n\n        if not copy:\n            self._logger.info(\"Replaying submission %s - %s - %s - %s\", submission[\"username\"], submission[\"courseid\"],\n                              submission[\"taskid\"], submission[\"_id\"])\n        else:\n            self._logger.info(\"Copying submission %s - %s - %s - %s as %s\", submission[\"username\"], submission[\"courseid\"],\n                              submission[\"taskid\"], submission[\"_id\"], self._user_manager.session_username())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_submission(self, submissionid, user_check=True):\n        sub = self._database.submissions.find_one({'_id': ObjectId(submissionid)})\n        if user_check and not self.user_is_submission_owner(sub):\n            return None\n        return sub", "response": "Get a submission from the database"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a job to the queue and returns a submission id.", "response": "def add_job(self, task, inputdata, debug=False):\n        \"\"\"\n        Add a job in the queue and returns a submission id.\n        :param task:  Task instance\n        :type task: inginious.frontend.tasks.WebAppTask\n        :param inputdata: the input as a dictionary\n        :type inputdata: dict\n        :param debug: If debug is true, more debug data will be saved\n        :type debug: bool or string\n        :returns: the new submission id and the removed submission id\n        \"\"\"\n        if not self._user_manager.session_logged_in():\n            raise Exception(\"A user must be logged in to submit an object\")\n\n        username = self._user_manager.session_username()\n\n        # Prevent student from submitting several submissions together\n        waiting_submission = self._database.submissions.find_one({\n            \"courseid\": task.get_course_id(),\n            \"taskid\": task.get_id(),\n            \"username\": username,\n            \"status\": \"waiting\"})\n\n        if waiting_submission is not None:\n            raise Exception(\"A submission is already pending for this task!\")\n\n        obj = {\n            \"courseid\": task.get_course_id(),\n            \"taskid\": task.get_id(),\n            \"status\": \"waiting\",\n            \"submitted_on\": datetime.now(),\n            \"username\": [username],\n            \"response_type\": task.get_response_type()\n        }\n\n        # Send additional data to the client in inputdata. For now, the username and the language. New fields can be added with the\n        # new_submission hook\n        inputdata[\"@username\"] = username\n        inputdata[\"@lang\"] = self._user_manager.session_language()\n        # Retrieve input random\n        states = self._database.user_tasks.find_one({\"courseid\": task.get_course_id(), \"taskid\": task.get_id(), \"username\": username}, {\"random\": 1, \"state\": 1})\n        inputdata[\"@random\"] = states[\"random\"] if \"random\" in states else []\n        inputdata[\"@state\"] = states[\"state\"] if \"state\" in states else \"\"\n\n        self._hook_manager.call_hook(\"new_submission\", submission=obj, inputdata=inputdata)\n        obj[\"input\"] = self._gridfs.put(bson.BSON.encode(inputdata))\n\n        self._before_submission_insertion(task, inputdata, debug, obj)\n        submissionid = self._database.submissions.insert(obj)\n        to_remove = self._after_submission_insertion(task, inputdata, debug, obj, submissionid)\n\n        ssh_callback = lambda host, port, password: self._handle_ssh_callback(submissionid, host, port, password)\n\n        jobid = self._client.new_job(task, inputdata,\n                                     (lambda result, grade, problems, tests, custom, state, archive, stdout, stderr:\n                                      self._job_done_callback(submissionid, task, result, grade, problems, tests, custom, state, archive, stdout, stderr, True)),\n                                     \"Frontend - {}\".format(username), debug, ssh_callback)\n\n        self._database.submissions.update(\n            {\"_id\": submissionid, \"status\": \"waiting\"},\n            {\"$set\": {\"jobid\": jobid}}\n        )\n\n        self._logger.info(\"New submission from %s - %s - %s/%s - %s\", self._user_manager.session_username(),\n                          self._user_manager.session_email(), task.get_course_id(), task.get_id(),\n                          web.ctx['ip'])\n\n        return submissionid, to_remove"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _delete_exceeding_submissions(self, username, task, max_submissions_bound=-1):\n\n        if max_submissions_bound <= 0:\n            max_submissions = task.get_stored_submissions()\n        elif task.get_stored_submissions() <= 0:\n            max_submissions = max_submissions_bound\n        else:\n            max_submissions = min(max_submissions_bound, task.get_stored_submissions())\n\n        if max_submissions <= 0:\n            return []\n        tasks = list(self._database.submissions.find(\n            {\"username\": username, \"courseid\": task.get_course_id(), \"taskid\": task.get_id()},\n            projection=[\"_id\", \"status\", \"result\", \"grade\", \"submitted_on\"],\n            sort=[('submitted_on', pymongo.ASCENDING)]))\n\n        # List the entries to keep\n        to_keep = set([])\n\n        if task.get_evaluate() == 'best':\n            # Find the best \"status\"=\"done\" and \"result\"=\"success\"\n            idx_best = -1\n            for idx, val in enumerate(tasks):\n                if val[\"status\"] == \"done\":\n                    if idx_best == -1 or tasks[idx_best][\"grade\"] < val[\"grade\"]:\n                        idx_best = idx\n\n            # Always keep the best submission\n            if idx_best != -1:\n                to_keep.add(tasks[idx_best][\"_id\"])\n        elif task.get_evaluate() == 'student':\n            user_task = self._database.user_tasks.find_one({\n                \"courseid\": task.get_course_id(),\n                \"taskid\": task.get_id(),\n                \"username\": username\n            })\n\n            submissionid = user_task.get('submissionid', None)\n            if submissionid:\n                to_keep.add(submissionid)\n\n        # Always keep running submissions\n        for val in tasks:\n            if val[\"status\"] == \"waiting\":\n                to_keep.add(val[\"_id\"])\n\n        while len(to_keep) < max_submissions and len(tasks) > 0:\n            to_keep.add(tasks.pop()[\"_id\"])\n\n        to_delete = {val[\"_id\"] for val in tasks}.difference(to_keep)\n        self._database.submissions.delete_many({\"_id\": {\"$in\": list(to_delete)}})\n\n        return list(map(str, to_delete))", "response": "Deletes exceeding submissions from the database"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_input_from_submission(self, submission, only_input=False):\n        inp = bson.BSON.decode(self._gridfs.get(submission['input']).read())\n        if only_input:\n            return inp\n        else:\n            submission[\"input\"] = inp\n            return submission", "response": "Get the input of a submission."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_feedback_from_submission(self, submission, only_feedback=False, show_everything=False, translation=gettext.NullTranslations()):\n        if only_feedback:\n            submission = {\"text\": submission.get(\"text\", None), \"problems\": dict(submission.get(\"problems\", {}))}\n        if \"text\" in submission:\n            submission[\"text\"] = ParsableText(submission[\"text\"], submission[\"response_type\"], show_everything, translation).parse()\n        if \"problems\" in submission:\n            for problem in submission[\"problems\"]:\n                if isinstance(submission[\"problems\"][problem], str):  # fallback for old-style submissions\n                    submission[\"problems\"][problem] = (submission.get('result', 'crash'), ParsableText(submission[\"problems\"][problem],\n                                                                                                       submission[\"response_type\"],\n                                                                                                       show_everything, translation).parse())\n                else:  # new-style submission\n                    submission[\"problems\"][problem] = (submission[\"problems\"][problem][0], ParsableText(submission[\"problems\"][problem][1],\n                                                                                                        submission[\"response_type\"],\n                                                                                                        show_everything, translation).parse())\n        return submission", "response": "Get the feedback from a submission."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntells if a submission is running", "response": "def is_running(self, submissionid, user_check=True):\n        \"\"\" Tells if a submission is running/in queue \"\"\"\n        submission = self.get_submission(submissionid, user_check)\n        return submission[\"status\"] == \"waiting\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_done(self, submissionid_or_submission, user_check=True):\n        # TODO: not a very nice way to avoid too many database call. Should be refactored.\n        if isinstance(submissionid_or_submission, dict):\n            submission = submissionid_or_submission\n        else:\n            submission = self.get_submission(submissionid_or_submission, False)\n        if user_check and not self.user_is_submission_owner(submission):\n            return None\n        return submission[\"status\"] == \"done\" or submission[\"status\"] == \"error\"", "response": "Tells if a submission is done and its result is available."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nattempt to kill the remote job associated with this submissionid.", "response": "def kill_running_submission(self, submissionid, user_check=True):\n        \"\"\" Attempt to kill the remote job associated with this submission id.\n        :param submissionid:\n        :param user_check: Check if the current user owns this submission\n        :return: True if the job was killed, False if an error occurred\n        \"\"\"\n        submission = self.get_submission(submissionid, user_check)\n        if not submission:\n            return False\n        if \"jobid\" not in submission:\n            return False\n\n        return self._client.kill_job(submission[\"jobid\"])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if the current user is the owner of this jobid false otherwise", "response": "def user_is_submission_owner(self, submission):\n        \"\"\" Returns true if the current user is the owner of this jobid, false else \"\"\"\n        if not self._user_manager.session_logged_in():\n            raise Exception(\"A user must be logged in to verify if he owns a jobid\")\n\n        return self._user_manager.session_username() in submission[\"username\"]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_user_submissions(self, task):\n        if not self._user_manager.session_logged_in():\n            raise Exception(\"A user must be logged in to get his submissions\")\n\n        cursor = self._database.submissions.find({\"username\": self._user_manager.session_username(),\n                                                  \"taskid\": task.get_id(), \"courseid\": task.get_course_id()})\n        cursor.sort([(\"submitted_on\", -1)])\n        return list(cursor)", "response": "Get all the user s submissions for a given task"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_user_last_submissions(self, limit=5, request=None):\n        if request is None:\n            request = {}\n\n        request.update({\"username\": self._user_manager.session_username()})\n\n        # Before, submissions were first sorted by submission date, then grouped\n        # and then resorted by submission date before limiting. Actually, grouping\n        # and pushing, keeping the max date, followed by result filtering is much more\n        # efficient\n        data = self._database.submissions.aggregate([\n            {\"$match\": request},\n            {\"$group\": {\"_id\": {\"courseid\": \"$courseid\", \"taskid\": \"$taskid\"},\n                        \"submitted_on\": {\"$max\": \"$submitted_on\"},\n                        \"submissions\": {\"$push\": {\n                            \"_id\": \"$_id\",\n                            \"result\": \"$result\",\n                            \"status\" : \"$status\",\n                            \"courseid\": \"$courseid\",\n                            \"taskid\": \"$taskid\",\n                            \"submitted_on\": \"$submitted_on\"\n                        }},\n            }},\n            {\"$project\": {\n                \"submitted_on\": 1,\n                \"submissions\": {\n                    # This could be replaced by $filter if mongo v3.2 is set as dependency\n                    \"$setDifference\": [\n                        {\"$map\": {\n                            \"input\": \"$submissions\",\n                            \"as\": \"submission\",\n                            \"in\": {\n                                \"$cond\": [{\"$eq\": [\"$submitted_on\", \"$$submission.submitted_on\"]}, \"$$submission\", False]\n                            }\n                        }},\n                        [False]\n                    ]\n                }\n            }},\n            {\"$sort\": {\"submitted_on\": pymongo.DESCENDING}},\n            {\"$limit\": limit}\n        ])\n\n        return [item[\"submissions\"][0] for item in data]", "response": "Get the last 5 submissions of a user"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a tar file containing all the submissions and the associated aggregations.", "response": "def get_submission_archive(self, submissions, sub_folders, aggregations, archive_file=None):\n        \"\"\"\n        :param submissions: a list of submissions\n        :param sub_folders: possible values:\n            []: put all submissions in /\n            ['taskid']: put all submissions for each task in a different directory /taskid/\n            ['username']: put all submissions for each user in a different directory /username/\n            ['taskid','username']: /taskid/username/\n            ['username','taskid']: /username/taskid/\n        :return: a file-like object containing a tgz archive of all the submissions\n        \"\"\"\n        tmpfile = archive_file if archive_file is not None else tempfile.TemporaryFile()\n        tar = tarfile.open(fileobj=tmpfile, mode='w:gz')\n\n        for submission in submissions:\n            submission = self.get_input_from_submission(submission)\n\n            submission_yaml = io.BytesIO(inginious.common.custom_yaml.dump(submission).encode('utf-8'))\n\n            # Considering multiple single submissions for each user\n            for username in submission[\"username\"]:\n                # Compute base path in the tar file\n                base_path = \"/\"\n                for sub_folder in sub_folders:\n                    if sub_folder == 'taskid':\n                        base_path = submission['taskid'] + base_path\n                    elif sub_folder == 'username':\n                        base_path = '_' + '-'.join(submission['username']) + base_path\n                        base_path = base_path[1:]\n                    elif sub_folder == 'aggregation':\n                        if username in aggregations:\n                            if aggregations[username] is None:\n                                # If classrooms are not used, and user is not grouped, his classroom is replaced by None\n                                base_path = '_' + '-'.join(submission['username']) + base_path\n                                base_path = base_path[1:]\n                            else:\n                                base_path = (aggregations[username][\"description\"] +\n                                             \" (\" + str(aggregations[username][\"_id\"]) + \")\").replace(\" \", \"_\") + base_path\n\n                    base_path = '/' + base_path\n                base_path = base_path[1:]\n\n                submission_yaml_fname = base_path + str(submission[\"_id\"]) + '/submission.test'\n\n                # Avoid putting two times the same submission on the same place\n                if submission_yaml_fname not in tar.getnames():\n\n                    info = tarfile.TarInfo(name=submission_yaml_fname)\n                    info.size = submission_yaml.getbuffer().nbytes\n                    info.mtime = time.mktime(submission[\"submitted_on\"].timetuple())\n\n                    # Add file in tar archive\n                    tar.addfile(info, fileobj=submission_yaml)\n\n                    # If there is an archive, add it too\n                    if 'archive' in submission and submission['archive'] is not None and submission['archive'] != \"\":\n                        subfile = self._gridfs.get(submission['archive'])\n                        subtar = tarfile.open(fileobj=subfile, mode=\"r:gz\")\n\n                        for member in subtar.getmembers():\n                            subtarfile = subtar.extractfile(member)\n                            member.name = base_path + str(submission[\"_id\"]) + \"/archive/\" + member.name\n                            tar.addfile(member, subtarfile)\n\n                        subtar.close()\n                        subfile.close()\n\n                    # If there files that were uploaded by the student, add them\n                    if submission['input'] is not None:\n                        for pid, problem in submission['input'].items():\n                            # If problem is a dict, it is a file (from the specification of the problems)\n                            if isinstance(problem, dict):\n                                # Get the extension (match extensions with more than one dot too)\n                                DOUBLE_EXTENSIONS = ['.tar.gz', '.tar.bz2', '.tar.bz', '.tar.xz']\n                                ext = \"\"\n                                if not problem['filename'].endswith(tuple(DOUBLE_EXTENSIONS)):\n                                    _, ext = os.path.splitext(problem['filename'])\n                                else:\n                                    for t_ext in DOUBLE_EXTENSIONS:\n                                        if problem['filename'].endswith(t_ext):\n                                            ext = t_ext\n\n                                subfile = io.BytesIO(problem['value'])\n                                taskfname = base_path + str(submission[\"_id\"]) + '/uploaded_files/' + pid + ext\n\n                                # Generate file info\n                                info = tarfile.TarInfo(name=taskfname)\n                                info.size = subfile.getbuffer().nbytes\n                                info.mtime = time.mktime(submission[\"submitted_on\"].timetuple())\n\n                                # Add file in tar archive\n                                tar.addfile(info, fileobj=subfile)\n\n        # Close tarfile and put tempfile cursor at 0\n        tar.close()\n        tmpfile.seek(0)\n        return tmpfile"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle the ssh callback for a submission", "response": "def _handle_ssh_callback(self, submission_id, host, port, password):\n        \"\"\" Handles the creation of a remote ssh server \"\"\"\n        if host is not None:  # ignore late calls (a bit hacky, but...)\n            obj = {\n                \"ssh_host\": host,\n                \"ssh_port\": port,\n                \"ssh_password\": password\n            }\n            self._database.submissions.update_one({\"_id\": submission_id}, {\"$set\": obj})"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dictionnary of LocalFSProvider for each usable FileSystemProvider", "response": "def get_filesystems_providers():\n    \"\"\" Returns a dictionnary of {\"fs_name\": fs_class}, for each usable FileSystemProvider\"\"\"\n    providers = {\"local\": LocalFSProvider}\n    plugged_providers = pkg_resources.iter_entry_points(\"inginious.filesystems\")\n    for pp in plugged_providers:\n        providers[pp.name] = pp.load()\n    return providers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngive a dictionary containing an entry module which contains a FSProvider identifier parse the configuration and return a new FSProvider instance.", "response": "def filesystem_from_config_dict(config_fs):\n    \"\"\" Given a dict containing an entry \"module\" which contains a FSProvider identifier, parse the configuration and returns a fs_provider.\n        Exits if there is an error.\n    \"\"\"\n    if \"module\" not in config_fs:\n        print(\"Key 'module' should be defined for the filesystem provider ('fs' configuration option)\", file=sys.stderr)\n        exit(1)\n\n    filesystem_providers = get_filesystems_providers()\n    if config_fs[\"module\"] not in filesystem_providers:\n        print(\"Unknown filesystem provider \"+config_fs[\"module\"], file=sys.stderr)\n        exit(1)\n\n    fs_class = filesystem_providers[config_fs[\"module\"]]\n    fs_args_needed = fs_class.get_needed_args()\n\n    fs_args = {}\n    for arg_name, (arg_type, arg_required, _) in fs_args_needed.items():\n        if arg_name in config_fs:\n            fs_args[arg_name] = arg_type(config_fs[arg_name])\n        elif arg_required:\n            print(\"fs option {} is required\".format(arg_name), file=sys.stderr)\n            exit(1)\n\n    try:\n        return fs_class.init_from_args(**fs_args)\n    except:\n        print(\"Unable to load class \" + config_fs[\"module\"], file=sys.stderr)\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a partially configured argparse parser, containing all the wanted data BUT the filesystem, this function will configure the parser to get the correct FS from the commandline, and return a tuple (args, filesystem_provider).", "response": "def get_args_and_filesystem(parser):\n    \"\"\"Given a partially configured argparse parser, containing all the wanted data BUT the filesystem, this function will configure the parser\n       to get the correct FS from the commandline, and return a tuple (args, filesystem_provider).\n    \"\"\"\n    filesystem_providers = get_filesystems_providers()\n\n    fs_group = parser.add_mutually_exclusive_group()\n    fs_group.add_argument(\"--tasks\", help=\"Path to the task directory. \"\n                                          \"By default, it is ./tasks. You must ensure that this directory is synchronized at any time\"\n                                          \"with the backend and the client. Either this option or --fs must be indicated, but not both.\",\n                          type=str, default=\"./tasks\")\n    fs_group.add_argument(\"--fs\", help=\"(advanced users only) Name of the FSProvider to use. Using a FSProvider will add new args to be filled. \"\n                                       \"Either --fs or --tasks must be filled, but not both.\", type=str, choices=filesystem_providers.keys())\n    parser.add_argument(\"--fs-help\", help=\"Display help to fill arguments for --fs. Only checked if --fs is filled.\", action=\"store_true\")\n\n    # Partial parsing of the args, to get the value of --fs\n    args = parser.parse_known_args()[0]\n\n    # check fs\n    if args.fs is not None:\n        fs_class = filesystem_providers[args.fs]\n        fs_args_needed = fs_class.get_needed_args()\n\n        fs_args_group = parser.add_argument_group(\"FSProvider arguments\")\n        for arg_name, (arg_type, arg_required, arg_desc) in fs_args_needed.items():\n            fs_args_group.add_argument(\"--fs-\" + arg_name, type=arg_type, help=arg_desc, required=arg_required)\n        if args.fs_help:\n            parser.parse_args([\"--help\"])\n        args = parser.parse_args()\n\n        returned_args = {}\n        for arg_name in fs_args_needed:\n            val = getattr(args, (\"fs-\" + arg_name).replace(\"-\", \"_\"))\n            if val is not None:\n                returned_args[arg_name] = val\n\n        try:\n            fsprovider = fs_class.init_from_args(**returned_args)\n        except:\n            print(\"Unable to load class \" + args.fs, file=sys.stderr)\n            raise\n    else:\n        # Verify that everything can finally be parsed\n        args = parser.parse_args()\n        fsprovider = LocalFSProvider(args.tasks)\n\n    return args, fsprovider"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncloses all the running tasks watching for a container timeout.", "response": "async def clean(self):\n        \"\"\" Close all the running tasks watching for a container timeout. All references to\n            containers are removed: any attempt to was_killed after a call to clean() will return None.\n        \"\"\"\n        for x in self._running_asyncio_tasks:\n            x.cancel()\n        self._container_had_error = set()\n        self._watching = set()\n        self._running_asyncio_tasks = set()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def was_killed(self, container_id):\n        if container_id in self._watching:\n            self._watching.remove(container_id)\n        if container_id in self._container_had_error:\n            self._container_had_error.remove(container_id)\n            return \"timeout\"\n        return None", "response": "Check if a container was killed."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def _handle_container_timeout(self, container_id, timeout):\n        try:\n            docker_stats = await self._docker_interface.get_stats(container_id)\n            source = AsyncIteratorWrapper(docker_stats)\n            nano_timeout = timeout * (10 ** 9)\n            async for upd in source:\n                if upd is None:\n                    await self._kill_it_with_fire(container_id)\n                self._logger.debug(\"%i\", upd['cpu_stats']['cpu_usage']['total_usage'])\n                if upd['cpu_stats']['cpu_usage']['total_usage'] > nano_timeout:\n                    self._logger.info(\"Killing container %s as it used %i CPU seconds (max was %i)\",\n                                      container_id, int(upd['cpu_stats']['cpu_usage']['total_usage'] / (10 ** 9)), timeout)\n                    await self._kill_it_with_fire(container_id)\n                    return\n        except asyncio.CancelledError:\n            pass\n        except:\n            self._logger.exception(\"Exception in _handle_container_timeout\")", "response": "Check timeout with docker stats\n        :param container_id:\n        :param timeout: in seconds (cpu time)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nkill a container if it used its hard time.", "response": "async def _handle_container_hard_timeout(self, container_id, hard_timeout):\n        \"\"\"\n        Kills a container (should be called with loop.call_later(hard_timeout, ...)) and displays a message on the log\n        :param container_id:\n        :param hard_timeout:\n        :return:\n        \"\"\"\n        if container_id in self._watching:\n            self._logger.info(\"Killing container %s as it used its %i wall time seconds\",\n                              container_id, hard_timeout)\n            await self._kill_it_with_fire(container_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nkilling a container with fire.", "response": "async def _kill_it_with_fire(self, container_id):\n        \"\"\"\n        Kill a container, with fire.\n        \"\"\"\n        if container_id in self._watching:\n            self._watching.remove(container_id)\n            self._container_had_error.add(container_id)\n            try:\n                await self._docker_interface.kill_container(container_id)\n            except:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_homepath(self, ignore_session=False, force_cookieless=False):\n        if not ignore_session and self._session.get(\"session_id\") is not None and self._session.get(\"cookieless\", False):\n            return web.ctx.homepath + \"/@\" + self._session.get(\"session_id\") + \"@\"\n        elif not ignore_session and force_cookieless:\n            return web.ctx.homepath + \"/@@\"\n        else:\n            return web.ctx.homepath", "response": "Returns the homepath of the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load(self, session_id=None):\n\n        if session_id is None:\n            cookie_name = self._config.cookie_name\n            self._data[\"session_id\"] = web.cookies().get(cookie_name)\n            self._data[\"cookieless\"] = False\n        else:\n            if session_id == '':\n                self._data[\"session_id\"] = None  # will be created\n            else:\n                self._data[\"session_id\"] = session_id\n            self._data[\"cookieless\"] = True\n\n        # protection against session_id tampering\n        if self._data[\"session_id\"] and not self._valid_session_id(self._data[\"session_id\"]):\n            self._data[\"session_id\"] = None\n\n        self._check_expiry()\n        if self._data[\"session_id\"]:\n            d = self.store[self._data[\"session_id\"]]\n            self.update(d)\n            self._validate_ip()\n\n        if not self._data[\"session_id\"]:\n            self._data[\"session_id\"] = self._generate_session_id()\n\n            if self._initializer:\n                if isinstance(self._initializer, dict):\n                    self.update(deepcopy(self._initializer))\n                elif hasattr(self._initializer, '__call__'):\n                    self._initializer()\n\n        self._data[\"ip\"] = web.ctx.ip", "response": "Load the session from the store."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _generate_session_id(self):\n\n        while True:\n            rand = os.urandom(16)\n            now = time.time()\n            secret_key = self._config.secret_key\n            session_id = hashlib.sha1((\"%s%s%s%s\" % (rand, now, utils.safestr(web.ctx.ip), secret_key)).encode(\"utf-8\"))\n            session_id = session_id.hexdigest()\n            if session_id not in self.store:\n                break\n        return session_id", "response": "Generate a random id for session"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _cleanup(self):\n        current_time = time.time()\n        timeout = self._config.timeout\n        if current_time - self._last_cleanup_time > timeout:\n            self.store.cleanup(timeout)\n            self._last_cleanup_time = current_time", "response": "Cleanup the stored sessions"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls when an expired session is atime", "response": "def expired(self):\n        \"\"\"Called when an expired session is atime\"\"\"\n        self._data[\"_killed\"] = True\n        self.save()\n        raise SessionExpired(self._config.expired_message)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete account from DB", "response": "def delete_account(self, data):\n        \"\"\" Delete account from DB \"\"\"\n        error = False\n        msg = \"\"\n\n        username = self.user_manager.session_username()\n\n        # Check input format\n        result = self.database.users.find_one_and_delete({\"username\": username,\n                                                          \"email\": data.get(\"delete_email\", \"\")})\n        if not result:\n            error = True\n            msg = _(\"The specified email is incorrect.\")\n        else:\n            self.database.submissions.remove({\"username\": username})\n            self.database.user_tasks.remove({\"username\": username})\n\n            all_courses = self.course_factory.get_all_courses()\n\n            for courseid, course in all_courses.items():\n                if self.user_manager.course_is_open_to_user(course, username):\n                    self.user_manager.course_unregister_user(course, username)\n\n            self.user_manager.disconnect_user()\n            raise web.seeother(\"/index\")\n\n        return msg, error"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef GET_AUTH(self):  # pylint: disable=arguments-differ\n        userdata = self.database.users.find_one({\"username\": self.user_manager.session_username()})\n\n        if not userdata or not self.app.allow_deletion:\n            raise web.notfound()\n\n        return self.template_helper.get_renderer().preferences.delete(\"\", False)", "response": "GET request handler for GET_AUTH"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npost request for user delete", "response": "def POST_AUTH(self):  # pylint: disable=arguments-differ\n        \"\"\" POST request \"\"\"\n        userdata = self.database.users.find_one({\"username\": self.user_manager.session_username()})\n\n        if not userdata or not self.app.allow_deletion:\n            raise web.notfound()\n\n        msg = \"\"\n        error = False\n        data = web.input()\n        if \"delete\" in data:\n            msg, error = self.delete_account(data)\n\n        return self.template_helper.get_renderer().preferences.delete(msg, error)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserialize a Python object into a YAML stream.", "response": "def dump(data, stream=None, **kwds):\n    \"\"\"\n        Serialize a Python object into a YAML stream.\n        If stream is None, return the produced string instead.\n        Dict keys are produced in the order in which they appear in OrderedDicts.\n\n        Safe version.\n\n        If objects are not \"conventional\" objects, they will be dumped converted to string with the str() function.\n        They will then not be recovered when loading with the load() function.\n    \"\"\"\n\n    # Display OrderedDicts correctly\n    class OrderedDumper(SafeDumper):\n        pass\n\n    def _dict_representer(dumper, data):\n        return dumper.represent_mapping(\n            original_yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,\n            list(data.items()))\n\n    # Display long strings correctly\n    def _long_str_representer(dumper, data):\n        if data.find(\"\\n\") != -1:\n            # Drop some uneeded data\n            # \\t are forbidden in YAML\n            data = data.replace(\"\\t\", \"    \")\n            # empty spaces at end of line are always useless in INGInious, and forbidden in YAML\n            data = \"\\n\".join([p.rstrip() for p in data.split(\"\\n\")])\n            return dumper.represent_scalar('tag:yaml.org,2002:str', data, style='|')\n        else:\n            return dumper.represent_scalar('tag:yaml.org,2002:str', data)\n\n    # Default representation for some odd objects\n    def _default_representer(dumper, data):\n        return _long_str_representer(dumper, str(data))\n\n    OrderedDumper.add_representer(str, _long_str_representer)\n    OrderedDumper.add_representer(str, _long_str_representer)\n    OrderedDumper.add_representer(OrderedDict, _dict_representer)\n    OrderedDumper.add_representer(None, _default_representer)\n\n    s = original_yaml.dump(data, stream, OrderedDumper, encoding='utf-8', allow_unicode=True, default_flow_style=False, indent=4, **kwds)\n\n    if s is not None:\n        return s.decode('utf-8')\n    else:\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _check_for_parsable_text(self, val):\n        if isinstance(val, ParsableText):\n            return val.original_content()\n        if isinstance(val, list):\n            for key, val2 in enumerate(val):\n                val[key] = self._check_for_parsable_text(val2)\n            return val\n        if isinstance(val, dict):\n            for key, val2 in val.items():\n                val[key] = self._check_for_parsable_text(val2)\n        return val", "response": "Helper method to remove parsable text from a dict recursively"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the list of tasks available to the connected client.", "response": "def API_GET(self, courseid, taskid=None):  # pylint: disable=arguments-differ\n        \"\"\"\n            List tasks available to the connected client. Returns a dict in the form\n\n            ::\n\n                {\n                    \"taskid1\":\n                    {\n                        \"name\": \"Name of the course\",     #the name of the course\n                        \"authors\": [],\n                        \"deadline\": \"\",\n                        \"status\": \"success\"               # can be \"succeeded\", \"failed\" or \"notattempted\"\n                        \"grade\": 0.0,\n                        \"grade_weight\": 0.0,\n                        \"context\": \"\"                     # context of the task, in RST\n                        \"problems\":                       # dict of the subproblems\n                        {\n                                                          # see the format of task.yaml for the content of the dict. Contains everything but\n                                                          # responses of multiple-choice and match problems.\n                        }\n                    }\n                    #...\n                }\n\n            If you use the endpoint /api/v0/courses/the_course_id/tasks/the_task_id, this dict will contain one entry or the page will return 404 Not\n            Found.\n        \"\"\"\n\n        try:\n            course = self.course_factory.get_course(courseid)\n        except:\n            raise APINotFound(\"Course not found\")\n\n        if not self.user_manager.course_is_open_to_user(course, lti=False):\n            raise APIForbidden(\"You are not registered to this course\")\n\n        if taskid is None:\n            tasks = course.get_tasks()\n        else:\n            try:\n                tasks = {taskid: course.get_task(taskid)}\n            except:\n                raise APINotFound(\"Task not found\")\n\n        output = []\n        for taskid, task in tasks.items():\n            task_cache = self.user_manager.get_task_cache(self.user_manager.session_username(), task.get_course_id(), task.get_id())\n\n            data = {\n                \"id\": taskid,\n                \"name\": task.get_name(self.user_manager.session_language()),\n                \"authors\": task.get_authors(self.user_manager.session_language()),\n                \"deadline\": task.get_deadline(),\n                \"status\": \"notviewed\" if task_cache is None else \"notattempted\" if task_cache[\"tried\"] == 0 else \"succeeded\" if task_cache[\"succeeded\"] else \"failed\",\n                \"grade\": task_cache.get(\"grade\", 0.0) if task_cache is not None else 0.0,\n                \"grade_weight\": task.get_grading_weight(),\n                \"context\": task.get_context(self.user_manager.session_language()).original_content(),\n                \"problems\": []\n            }\n\n            for problem in task.get_problems():\n                pcontent = problem.get_original_content()\n                pcontent[\"id\"] = problem.get_id()\n                if pcontent[\"type\"] == \"match\":\n                    del pcontent[\"answer\"]\n                if pcontent[\"type\"] == \"multiple_choice\":\n                    pcontent[\"choices\"] = {key: val[\"text\"] for key, val in enumerate(pcontent[\"choices\"])}\n                pcontent = self._check_for_parsable_text(pcontent)\n                data[\"problems\"].append(pcontent)\n\n            output.append(data)\n\n        return 200, output"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_input():\n    file = open(_input_file, 'r')\n    result = json.loads(file.read().strip('\\0').strip())\n    file.close()\n    return result", "response": "Load the input file and return it as a dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_input(problem):\n    input_data = load_input()\n    pbsplit = problem.split(\":\")\n    problem_input = input_data['input'][pbsplit[0]]\n    if isinstance(problem_input, dict) and \"filename\" in problem_input and \"value\" in problem_input:\n        if len(pbsplit) > 1 and pbsplit[1] == 'filename':\n            return problem_input[\"filename\"]\n        else:\n            return open(problem_input[\"value\"], 'rb').read()\n    else:\n        return problem_input", "response": "Returns the specified problem answer in the form \n         problem"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_template(input_filename, output_filename=''):\n    data = load_input()\n    with open(input_filename, 'rb') as file:\n        template = file.read().decode(\"utf-8\")\n    \n    # Check if 'input' in data\n    if not 'input' in data:\n        raise ValueError(\"Could not find 'input' in data\")\n    \n    # Parse template\n    for field in data['input']:\n        subs = [\"filename\", \"value\"] if isinstance(data['input'][field], dict) and \"filename\" in data['input'][field] and \"value\" in data['input'][field] else [\"\"]\n        for sub in subs:\n            displayed_field = field + (\":\" if sub else \"\") + sub\n            regex = re.compile(\"@([^@]*)@\" + displayed_field + '@([^@]*)@')\n            for prefix, postfix in set(regex.findall(template)):\n                if sub == \"value\":\n                    text = open(data['input'][field][sub], 'rb').read().decode('utf-8')\n                elif sub:\n                    text = data['input'][field][sub]\n                else:\n                    text = data['input'][field]\n                rep = \"\\n\".join([prefix + v + postfix for v in text.splitlines()])\n                template = template.replace(\"@{0}@{1}@{2}@\".format(prefix, displayed_field, postfix), rep)\n    \n    if output_filename == '':\n        output_filename=input_filename\n    \n    # Ensure directory of resulting file exists\n    try:\n        os.makedirs(os.path.dirname(output_filename))\n    except OSError as e:\n        pass\n\n    # Write file\n    with open(output_filename, 'wb') as file:\n        file.write(template.encode(\"utf-8\"))", "response": "Parses a template file and returns a new file with all occurences of the problem_id key in the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _callable_once(func):\n\n    def once(*args, **kwargs):\n        if not once.called:\n            once.called = True\n            return func(*args, **kwargs)\n\n    once.called = False\n    return once", "response": "Returns a function that is only callable once."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nasking the backend to update the queue.", "response": "async def _ask_queue_update(self):\n        \"\"\" Send a ClientGetQueue message to the backend, if one is not already sent \"\"\"\n        try:\n            while True:\n                await asyncio.sleep(self._queue_update_timer)\n                if self._queue_update_last_attempt == 0 or self._queue_update_last_attempt > self._queue_update_last_attempt_max:\n                    if self._queue_update_last_attempt:\n                        self._logger.error(\"Asking for a job queue update despite previous update not yet received\")\n                    else:\n                        self._logger.debug(\"Asking for a job queue update\")\n\n                    self._queue_update_last_attempt = 1\n                    await self._simple_send(ClientGetQueue())\n                else:\n                    self._logger.error(\"Not asking for a job queue update as previous update not yet received\")\n        except asyncio.CancelledError:\n            return\n        except KeyboardInterrupt:\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def _handle_job_queue_update(self, message: BackendGetQueue):\n        self._logger.debug(\"Received job queue update\")\n        self._queue_update_last_attempt = 0\n        self._queue_cache = message\n\n        # Do some precomputation\n        new_job_queue_cache = {}\n        # format is job_id: (nb_jobs_before, max_remaining_time)\n        for (job_id, is_local, _, _2, _3, _4, max_end) in message.jobs_running:\n            if is_local:\n                new_job_queue_cache[job_id] = (-1, max_end - time.time())\n        wait_time = 0\n        nb_tasks = 0\n        for (job_id, is_local, _, _2, timeout) in message.jobs_waiting:\n            if timeout > 0:\n                wait_time += timeout\n            if is_local:\n                new_job_queue_cache[job_id] = (nb_tasks, wait_time)\n            nb_tasks += 1\n\n        self._queue_job_cache = new_job_queue_cache", "response": "Handle a BackendGetQueue update message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new job to the job queue.", "response": "def new_job(self, task, inputdata, callback, launcher_name=\"Unknown\", debug=False, ssh_callback=None):\n        \"\"\" Add a new job. Every callback will be called once and only once.\n\n        :type task: Task\n        :param inputdata: input from the student\n        :type inputdata: Storage or dict\n        :param callback: a function that will be called asynchronously in the client's process, with the results.\n            it's signature must be (result, grade, problems, tests, custom, archive), where:\n            result is itself a tuple containing the result string and the main feedback (i.e. ('success', 'You succeeded');\n            grade is a number between 0 and 100 indicating the grade of the users;\n            problems is a dict of tuple, in the form {'problemid': result};\n            test is a dict of tests made in the container\n            custom is a dict containing random things set in the container\n            archive is either None or a bytes containing a tgz archive of files from the job\n        :type callback: __builtin__.function or __builtin__.instancemethod\n        :param launcher_name: for informational use\n        :type launcher_name: str\n        :param debug: Either True(outputs more info), False(default), or \"ssh\" (starts a remote ssh server. ssh_callback needs to be defined)\n        :type debug: bool or string\n        :param ssh_callback: a callback function that will be called with (host, port, password), the needed credentials to connect to the\n                             remote ssh server. May be called with host, port, password being None, meaning no session was open.\n        :type ssh_callback: __builtin__.function or __builtin__.instancemethod or None\n        :return: the new job id\n        \"\"\"\n        job_id = str(uuid.uuid4())\n\n        if debug == \"ssh\" and ssh_callback is None:\n            self._logger.error(\"SSH callback not set in %s/%s\", task.get_course_id(), task.get_id())\n            callback((\"crash\", \"SSH callback not set.\"), 0.0, {}, {}, {}, None, \"\", \"\")\n            return\n        # wrap ssh_callback to ensure it is called at most once, and that it can always be called to simplify code\n        ssh_callback = _callable_once(ssh_callback if ssh_callback is not None else lambda _1, _2, _3: None)\n\n        environment = task.get_environment()\n        if environment not in self._available_containers:\n            self._logger.warning(\"Env %s not available for task %s/%s\", environment, task.get_course_id(), task.get_id())\n            ssh_callback(None, None, None)  # ssh_callback must be called once\n            callback((\"crash\", \"Environment not available.\"), 0.0, {}, {}, \"\", {}, None, \"\", \"\")\n            return\n\n        enable_network = task.allow_network_access_grading()\n\n        try:\n            limits = task.get_limits()\n            time_limit = int(limits.get('time', 20))\n            hard_time_limit = int(limits.get('hard_time', 3 * time_limit))\n            mem_limit = int(limits.get('memory', 200))\n        except:\n            self._logger.exception(\"Cannot retrieve limits for task %s/%s\", task.get_course_id(), task.get_id())\n            ssh_callback(None, None, None)  # ssh_callback must be called once\n            callback((\"crash\", \"Error while reading task limits\"), 0.0, {}, {}, \"\", {}, None, \"\", \"\")\n            return\n\n        msg = ClientNewJob(job_id, task.get_course_id(), task.get_id(), inputdata, environment, enable_network, time_limit,\n                           hard_time_limit, mem_limit, debug, launcher_name)\n        self._loop.call_soon_threadsafe(asyncio.ensure_future, self._create_transaction(msg, task=task, callback=callback,\n                                                                                        ssh_callback=ssh_callback))\n\n        return job_id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nkill a running job.", "response": "def kill_job(self, job_id):\n        \"\"\"\n        Kills a running job\n        \"\"\"\n        self._loop.call_soon_threadsafe(asyncio.ensure_future, self._simple_send(ClientKillJob(job_id)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisplay main course list page", "response": "def show_page(self):\n        \"\"\"  Display main course list page \"\"\"\n        username = self.user_manager.session_username()\n        user_info = self.database.users.find_one({\"username\": username})\n        all_courses = self.course_factory.get_all_courses()\n\n        # Display\n        open_courses = {courseid: course for courseid, course in all_courses.items() if course.is_open_to_non_staff()}\n        open_courses = OrderedDict(sorted(iter(open_courses.items()), key=lambda x: x[1].get_name(self.user_manager.session_language())))\n\n        return self.template_helper.get_renderer().index(open_courses, user_info)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate rst codeblock for given text and language", "response": "def get_codeblock(language, text):\n    \"\"\" Generates rst codeblock for given text and language \"\"\"\n    rst = \"\\n\\n.. code-block:: \" + language + \"\\n\\n\"\n    for line in text.splitlines():\n        rst += \"\\t\" + line + \"\\n\"\n\n    rst += \"\\n\"\n    return rst"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_imageblock(filename, format=''):\n    _, extension = os.path.splitext(filename)\n\n    with open(filename, \"rb\") as image_file:\n        encoded_string = base64.b64encode(image_file.read()).decode('utf-8')\n\n    return '\\n\\n.. raw:: html\\n\\n\\t<img src=\"data:image/' + (format if format else extension[1:]) + ';base64,' + encoded_string +'\">\\n'", "response": "Generates rst raw block for given image filename and format"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates rst admonition block given a bootstrap alert css class title and text", "response": "def get_admonition(cssclass, title, text):\n    \"\"\" Generates rst admonition block given a bootstrap alert css class, title, and text\"\"\"\n    rst = (\"\\n\\n.. admonition:: \" + title + \"\\n\") if title else \"\\n\\n.. note:: \\n\"\n    rst += \"\\t:class: alert alert-\" + cssclass + \"\\n\\n\"\n    for line in text.splitlines():\n        rst += \"\\t\" + line + \"\\n\"\n\n    rst += \"\\n\"\n    return rst"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef indent_block(amount, text, indent_char='\\t'):\n    rst = \"\"\n    for line in text.splitlines():\n        if amount > 0:\n            rst += indent_char*amount + line + \"\\n\"\n        else:\n            rst += ''.join([c for i,c in enumerate(line) if (c == indent_char and (i+1) > abs(amount)) or (not c == indent_char)]) + \"\\n\"\n    return rst", "response": "Indent a block of text"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading a message from a bytestring", "response": "def load(cls, bmessage):\n        \"\"\"\n        From a bytestring given by a (distant) call to Message.dump(), retrieve the original message\n        :param bmessage: bytestring given by a .dump() call on a message\n        :return: the original message\n        \"\"\"\n        message_dict = msgpack.loads(bmessage, encoding=\"utf8\", use_list=False)\n\n        try:\n            obj = MessageMeta._registered_messages[message_dict[\"type\"]].__new__(MessageMeta._registered_messages[message_dict[\"type\"]])\n            object.__setattr__(obj, \"__dict__\", message_dict)\n        except:\n            raise TypeError(\"Unknown message type\") from None\n\n        if not obj._verify():  # pylint: disable=protected-access\n            raise TypeError(\"Invalid message content\")\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init():\n    if \"_\" not in builtins.__dict__:  # avoid installing lang two times\n        os.environ[\"LANGUAGE\"] = inginious.input.get_lang()\n        if inginious.DEBUG:\n            gettext.install(\"messages\", get_lang_dir_path())\n        else:\n            gettext.install(\"messages\", get_lang_dir_path())", "response": "Install gettext with the default parameters"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the status of the user in the cluster.", "response": "def API_GET(self):  # pylint: disable=arguments-differ\n        \"\"\"\n            Returns {\"authenticated\": false} or {\"authenticated\": true, \"username\": \"your_username\"} (always 200 OK)\n        \"\"\"\n        if self.user_manager.session_logged_in():\n            return 200, {\"authenticated\": True, \"username\": self.user_manager.session_username()}\n        else:\n            return 200, {\"authenticated\": False}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nauthenticate the remote client. Takes as input a list of keys and values for the auth method and returns a dict of the form 200 OK and a username of the user s session username. Returns 403 Forbidden", "response": "def API_POST(self):  # pylint: disable=arguments-differ\n        \"\"\"\n            Authenticates the remote client. Takes as input:\n\n            auth_method_id\n                an id for an auth method as returned be /api/v0/auth_methods\n\n            input_key_1\n                the first input key and its value\n\n            input_key_2\n                the first input key and its value\n\n            ...\n                ...\n\n            Response: a dict in the form {\"status\": \"success\"} (200 OK) or {\"status\": \"error\"} (403 Forbidden)\n        \"\"\"\n\n        user_input = web.input()\n        if \"auth_method_id\" not in user_input:\n            raise APIInvalidArguments()\n\n        try:\n            auth_method_id = int(user_input[\"auth_method_id\"])\n        except:\n            raise APIInvalidArguments()\n\n        del user_input[\"auth_method_id\"]\n\n        try:\n            if \"login\" in user_input and \"password\" in user_input and \\\n                            self.user_manager.auth_user(user_input[\"login\"].strip(), user_input[\"password\"]) is not None:\n                    return 200, {\"status\": \"success\", \"username\": self.user_manager.session_username()}\n        except:\n            pass\n        return 403, {\"status\": \"error\"}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning all the auth methods available.", "response": "def API_GET(self):\n        \"\"\"\n            Returns all the auth methods available. (200 OK)\n\n            Response: list of auth methods. The value of the dict is an auth method, represented by:\n\n            id\n                id of the auth method\n\n            name\n                the name of the authentication method, typically displayed by the webapp\n\n            input\n                a dictionary containing as key the name of the input (in the HTML sense of name), and, as value,\n                a dictionary containing two fields:\n\n                name\n                    the placeholder for the input\n\n                type\n                    text or password\n        \"\"\"\n        to_display = []\n        for key, (name, data) in self.user_manager.get_auth_methods().items():\n            to_display.append({\n                \"id\": key,\n                \"name\": name,\n                \"input\": [{\"id\": ik, \"name\": iv[\"placeholder\"], \"type\": iv[\"type\"]} for ik, iv in data[\"input\"].items()]\n            })\n\n        return 200, to_display"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef GET_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        course, __ = self.get_course_and_check_rights(courseid, allow_all_staff=False)\n        return self.page(course)", "response": "GET request for the given course"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef POST_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        course, __ = self.get_course_and_check_rights(courseid, allow_all_staff=False)\n\n        errors = []\n        course_content = {}\n        try:\n            data = web.input()\n            course_content = self.course_factory.get_course_descriptor_content(courseid)\n            course_content['name'] = data['name']\n            if course_content['name'] == \"\":\n                errors.append(_('Invalid name'))\n            course_content['description'] = data['description']\n            course_content['admins'] = list(map(str.strip, data['admins'].split(',')))\n            if not self.user_manager.user_is_superadmin() and self.user_manager.session_username() not in course_content['admins']:\n                errors.append(_('You cannot remove yourself from the administrators of this course'))\n            course_content['tutors'] = list(map(str.strip, data['tutors'].split(',')))\n            if len(course_content['tutors']) == 1 and course_content['tutors'][0].strip() == \"\":\n                course_content['tutors'] = []\n\n            course_content['groups_student_choice'] = True if data[\"groups_student_choice\"] == \"true\" else False\n\n            if course_content.get('use_classrooms', True) != (data['use_classrooms'] == \"true\"):\n                self.database.aggregations.delete_many({\"courseid\": course.get_id()})\n\n            course_content['use_classrooms'] = True if data[\"use_classrooms\"] == \"true\" else False\n\n            if data[\"accessible\"] == \"custom\":\n                course_content['accessible'] = \"{}/{}\".format(data[\"accessible_start\"], data[\"accessible_end\"])\n            elif data[\"accessible\"] == \"true\":\n                course_content['accessible'] = True\n            else:\n                course_content['accessible'] = False\n\n            try:\n                AccessibleTime(course_content['accessible'])\n            except:\n                errors.append(_('Invalid accessibility dates'))\n\n            course_content['allow_unregister'] = True if data[\"allow_unregister\"] == \"true\" else False\n            course_content['allow_preview'] = True if data[\"allow_preview\"] == \"true\" else False\n\n            if data[\"registration\"] == \"custom\":\n                course_content['registration'] = \"{}/{}\".format(data[\"registration_start\"], data[\"registration_end\"])\n            elif data[\"registration\"] == \"true\":\n                course_content['registration'] = True\n            else:\n                course_content['registration'] = False\n\n            try:\n                AccessibleTime(course_content['registration'])\n            except:\n                errors.append(_('Invalid registration dates'))\n\n            course_content['registration_password'] = data['registration_password']\n            if course_content['registration_password'] == \"\":\n                course_content['registration_password'] = None\n\n            course_content['registration_ac'] = data['registration_ac']\n            if course_content['registration_ac'] not in [\"None\", \"username\", \"binding\", \"email\"]:\n                errors.append(_('Invalid ACL value'))\n            if course_content['registration_ac'] == \"None\":\n                course_content['registration_ac'] = None\n            course_content['registration_ac_list'] = data['registration_ac_list'].splitlines()\n\n            course_content['is_lti'] = 'lti' in data and data['lti'] == \"true\"\n            course_content['lti_keys'] = dict([x.split(\":\") for x in data['lti_keys'].splitlines() if x])\n\n            for lti_key in course_content['lti_keys'].keys():\n                if not re.match(\"^[a-zA-Z0-9]*$\", lti_key):\n                    errors.append(_(\"LTI keys must be alphanumerical.\"))\n\n            course_content['lti_send_back_grade'] = 'lti_send_back_grade' in data and data['lti_send_back_grade'] == \"true\"\n        except:\n            errors.append(_('User returned an invalid form.'))\n\n        if len(errors) == 0:\n            self.course_factory.update_course_descriptor_content(courseid, course_content)\n            errors = None\n            course, __ = self.get_course_and_check_rights(courseid, allow_all_staff=False)  # don't forget to reload the modified course\n\n        return self.page(course, errors, errors is None)", "response": "POST request for a course"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all data and display the page", "response": "def page(self, course, errors=None, saved=False):\n        \"\"\" Get all data and display the page \"\"\"\n        return self.template_helper.get_renderer().course_admin.settings(course, errors, saved)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncopies src to dest, recursively and with file overwrite.", "response": "def _recursive_overwrite(self, src, dest):\n        \"\"\"\n        Copy src to dest, recursively and with file overwrite.\n        \"\"\"\n        if os.path.isdir(src):\n            if not os.path.isdir(dest):\n                os.makedirs(dest)\n            files = os.listdir(src)\n            for f in files:\n                self._recursive_overwrite(os.path.join(src, f),\n                                          os.path.join(dest, f))\n        else:\n            shutil.copyfile(src, dest, follow_symlinks=False)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the plugin_manager and the submission git saver", "response": "def init(plugin_manager, _, _2, config):\n    \"\"\"\n        Init the plugin\n\n        Available configuration:\n        ::\n\n            plugins:\n                - plugin_module: inginious.frontend.plugins.git_repo\n                  repo_directory: \"./repo_submissions\"\n\n    \"\"\"\n    submission_git_saver = SubmissionGitSaver(plugin_manager, config)\n    submission_git_saver.daemon = True\n    submission_git_saver.start()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a new submission to the queue", "response": "def add(self, submission, archive, _):\n        \"\"\" Add a new submission to the repo (add the to queue, will be saved async)\"\"\"\n        self.queue.put((submission, submission[\"result\"], submission[\"grade\"], submission[\"problems\"], submission[\"tests\"], submission[\"custom\"], archive))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving a new submission in the repo", "response": "def save(self, submission, result, grade, problems, tests, custom, archive):  # pylint: disable=unused-argument\n        \"\"\" saves a new submission in the repo (done async) \"\"\"\n        # Save submission to repo\n        self._logger.info(\"Save submission \" + str(submission[\"_id\"]) + \" to git repo\")\n        # Verify that the directory for the course exists\n        if not os.path.exists(os.path.join(self.repopath, submission[\"courseid\"])):\n            os.mkdir(os.path.join(self.repopath, submission[\"courseid\"]))\n        # Idem with the task\n        if not os.path.exists(os.path.join(self.repopath, submission[\"courseid\"], submission[\"taskid\"])):\n            os.mkdir(os.path.join(self.repopath, submission[\"courseid\"], submission[\"taskid\"]))\n        # Idem with the username, but empty it\n        dirname = os.path.join(self.repopath, submission[\"courseid\"], submission[\"taskid\"], str.join(\"-\", submission[\"username\"]))\n        if os.path.exists(dirname):\n            shutil.rmtree(dirname)\n        os.mkdir(dirname)\n        # Now we can put the input, the output and the zip\n        open(os.path.join(dirname, 'submitted_on'), \"w+\").write(str(submission[\"submitted_on\"]))\n        open(os.path.join(dirname, 'input.yaml'), \"w+\").write(inginious.common.custom_yaml.dump(submission[\"input\"]))\n        result_obj = {\n            \"result\": result[0],\n            \"text\": result[1],\n            \"problems\": problems\n        }\n        open(os.path.join(dirname, 'result.yaml'), \"w+\").write(inginious.common.custom_yaml.dump(result_obj))\n        if archive is not None:\n            os.mkdir(os.path.join(dirname, 'output'))\n            tar = tarfile.open(mode='r:gz', fileobj=io.BytesIO(archive))\n            tar.extractall(os.path.join(dirname, 'output'))\n            tar.close()\n\n        self.git.add('--all', '.')\n        title = \" - \".join([str(submission[\"courseid\"]) + \"/\" + str(submission[\"taskid\"]),\n                            str(submission[\"_id\"]),\n                            str.join(\"-\", submission[\"username\"]),\n                            (\"success\" if result[0] == \"success\" else \"failed\")])\n        self.git.commit('-m', title)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_description(self, translated=False):\n        if translated and self._description != \"\":\n            return _(self._description)\n        return self._description", "response": "Returns the description of this tag \n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a textual description of the type", "response": "def get_type_as_str(self):\n        \"\"\" Return a textual description of the type \"\"\"\n        if self.get_type() == 0:\n            return _(\"Skill\")\n        elif self.get_type() == 1:\n            return _(\"Misconception\")\n        elif self.get_type() == 2:\n            return _(\"Category\")\n        else:\n            return _(\"Unknown type\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_tags_from_dict(cls, tag_dict):\n        tag_list_common = []\n        tag_list_misconception = []\n        tag_list_organisational = []\n        for tag in tag_dict:\n            try:\n                id = tag_dict[tag][\"id\"]\n                name = tag_dict[tag][\"name\"]\n                visible = tag_dict[tag][\"visible\"]\n                description = tag_dict[tag][\"description\"]\n                type = tag_dict[tag][\"type\"]\n                \n                if type == 2:\n                    tag_list_organisational.insert(int(tag), Tag(id, name, description, visible, type))\n                elif type == 1:\n                    tag_list_misconception.insert(int(tag), Tag(id, name, description, visible, type))\n                else:\n                    tag_list_common.insert(int(tag), Tag(id, name, description, visible, type))\n            except KeyError:\n                pass\n        return tag_list_common, tag_list_misconception, tag_list_organisational", "response": "Creates a tuple of list of Tag objects based on the dictionary of tags."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_format(cls, tags):\n        common, _, _ = tags\n        for tag in common:\n            if tag.get_type() != 0:  # Unknown type -> incorrect\n                return False\n        return True", "response": "Check the tags arg only contains valid type for tags\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets request for the AUTH section", "response": "def GET_AUTH(self, courseid, aggregationid):  # pylint: disable=arguments-differ\n        \"\"\" GET request \"\"\"\n        course, __ = self.get_course_and_check_rights(courseid)\n\n        if course.is_lti():\n            raise web.notfound()\n\n        return self.page(course, aggregationid)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget all data and display the page", "response": "def page(self, course, aggregationid):\n        \"\"\" Get all data and display the page \"\"\"\n        aggregation = self.database.aggregations.find_one({\"_id\": ObjectId(aggregationid)})\n\n        data = list(self.database.submissions.aggregate(\n            [\n                {\n                    \"$match\":\n                        {\n                            \"courseid\": course.get_id(),\n                            \"username\": {\"$in\": aggregation[\"students\"]}\n                        }\n                },\n                {\n                    \"$group\":\n                        {\n                            \"_id\": \"$taskid\",\n                            \"tried\": {\"$sum\": 1},\n                            \"succeeded\": {\"$sum\": {\"$cond\": [{\"$eq\": [\"$result\", \"success\"]}, 1, 0]}},\n                            \"grade\": {\"$max\": \"$grade\"}\n                        }\n                }\n            ]))\n\n        tasks = course.get_tasks()\n        result = dict([(taskid, {\"taskid\": taskid, \"name\": tasks[taskid].get_name(self.user_manager.session_language()), \"tried\": 0, \"status\": \"notviewed\",\n                                 \"grade\": 0, \"url\": self.submission_url_generator(aggregationid, taskid)}) for taskid in tasks])\n\n        for taskdata in data:\n            if taskdata[\"_id\"] in result:\n                result[taskdata[\"_id\"]][\"tried\"] = taskdata[\"tried\"]\n                if taskdata[\"tried\"] == 0:\n                    result[taskdata[\"_id\"]][\"status\"] = \"notattempted\"\n                elif taskdata[\"succeeded\"]:\n                    result[taskdata[\"_id\"]][\"status\"] = \"succeeded\"\n                else:\n                    result[taskdata[\"_id\"]][\"status\"] = \"failed\"\n                result[taskdata[\"_id\"]][\"grade\"] = taskdata[\"grade\"]\n\n        if \"csv\" in web.input():\n            return make_csv(result)\n\n        results = sorted(list(result.values()), key=lambda result: (tasks[result[\"taskid\"]].get_order(), result[\"taskid\"]))\n        return self.template_helper.get_renderer().course_admin.aggregation_info(course, aggregation, results)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the agent. Answer to the requests made by the Backend. May raise an asyncio.CancelledError, in which case the agent should clean itself and restart completely.", "response": "async def run(self):\n        \"\"\"\n        Runs the agent. Answer to the requests made by the Backend.\n        May raise an asyncio.CancelledError, in which case the agent should clean itself and restart completely.\n        \"\"\"\n        self._logger.info(\"Agent started\")\n        self.__backend_socket.connect(self.__backend_addr)\n\n        # Tell the backend we are up and have `concurrency` threads available\n        self._logger.info(\"Saying hello to the backend\")\n        await ZMQUtils.send(self.__backend_socket, AgentHello(self.__friendly_name, self.__concurrency, self.environments))\n        self.__last_ping = time.time()\n\n        run_listen = self._loop.create_task(self.__run_listen())\n\n        self._loop.call_later(1, self._create_safe_task, self.__check_last_ping(run_listen))\n\n        await run_listen"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if the last ping is too old. Kills the run_listen task if it is.", "response": "async def __check_last_ping(self, run_listen):\n        \"\"\" Check if the last timeout is too old. If it is, kills the run_listen task \"\"\"\n        if self.__last_ping < time.time()-10:\n            self._logger.warning(\"Last ping too old. Restarting the agent.\")\n            run_listen.cancel()\n            self.__cancel_remaining_safe_tasks()\n        else:\n            self._loop.call_later(1, self._create_safe_task, self.__check_last_ping(run_listen))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def __run_listen(self):\n        while True:\n            message = await ZMQUtils.recv(self.__backend_socket)\n            await self.__handle_backend_message(message)", "response": "Listen to the backend"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def __handle_backend_message(self, message):\n        message_handlers = {\n            BackendNewJob: self.__handle_new_job,\n            BackendKillJob: self.kill_job,\n            Ping: self.__handle_ping\n        }\n        try:\n            func = message_handlers[message.__class__]\n        except:\n            raise TypeError(\"Unknown message type %s\" % message.__class__)\n        self._create_safe_task(func(message))", "response": "Dispatch messages received from clients to the right handlers"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles a Ping message. Pong the backend.", "response": "async def __handle_ping(self, _ : Ping):\n        \"\"\" Handle a Ping message. Pong the backend \"\"\"\n        self.__last_ping = time.time()\n        await ZMQUtils.send(self.__backend_socket, Pong())"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends the SSH info to the backend.", "response": "async def send_ssh_job_info(self, job_id: BackendJobId, host: str, port: int, key: str):\n        \"\"\"\n        Send info about the SSH debug connection to the backend/client. Must be called *at most once* for each job.\n        :exception JobNotRunningException: is raised when the job is not running anymore (send_job_result already called)\n        :exception TooManyCallsException: is raised when this function has been called more than once\n        \"\"\"\n        if job_id not in self.__running_job:\n            raise JobNotRunningException()\n        if self.__running_job[job_id]:\n            raise TooManyCallsException()\n        self.__running_job[job_id] = True  # now we have sent ssh info\n        await ZMQUtils.send(self.__backend_socket, AgentJobSSHDebug(job_id, host, port, key))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending the result of a job to the backend.", "response": "async def send_job_result(self, job_id: BackendJobId, result: str, text: str = \"\", grade: float = None, problems: Dict[str, SPResult] = None,\n                              tests: Dict[str, Any] = None, custom: Dict[str, Any] = None, state: str = \"\", archive: Optional[bytes] = None,\n                              stdout: Optional[str] = None, stderr: Optional[str] = None):\n        \"\"\"\n        Send the result of a job back to the backend. Must be called *once and only once* for each job\n        :exception JobNotRunningException: is raised when send_job_result is called more than once for a given job_id\n        \"\"\"\n        if job_id not in self.__running_job:\n            raise JobNotRunningException()\n        del self.__running_job[job_id]\n\n        if grade is None:\n            if result == \"success\":\n                grade = 100.0\n            else:\n                grade = 0.0\n        if problems is None:\n            problems = {}\n        if custom is None:\n            custom = {}\n        if tests is None:\n            tests = {}\n\n        await ZMQUtils.send(self.__backend_socket, AgentJobDone(job_id, (result, text), round(grade, 2), problems, tests, custom, state, archive, stdout, stderr))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls self. _loop. create_task with a safe ( == with logged exception coroutine.", "response": "def _create_safe_task(self, coroutine):\n        \"\"\" Calls self._loop.create_task with a safe (== with logged exception) coroutine. When run() ends, these tasks\n            are automatically cancelled\"\"\"\n        task = self._loop.create_task(coroutine)\n        self.__asyncio_tasks_running.add(task)\n        task.add_done_callback(self.__remove_safe_task)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_csv(data):\n    # Convert sub-dicts to news cols\n    for entry in data:\n        rval = entry\n        if isinstance(data, dict):\n            rval = data[entry]\n        todel = []\n        toadd = {}\n        for key, val in rval.items():\n            if isinstance(val, dict):\n                for key2, val2 in val.items():\n                    toadd[str(key) + \"[\" + str(key2) + \"]\"] = val2\n                todel.append(key)\n        for k in todel:\n            del rval[k]\n        for k, v in toadd.items():\n            rval[k] = v\n\n    # Convert everything to CSV\n    columns = set()\n    output = [[]]\n    if isinstance(data, dict):\n        output[0].append(\"id\")\n        for entry in data:\n            for col in data[entry]:\n                columns.add(col)\n    else:\n        for entry in data:\n            for col in entry:\n                columns.add(col)\n\n    columns = sorted(columns)\n\n    for col in columns:\n        output[0].append(col)\n\n    if isinstance(data, dict):\n        for entry in data:\n            new_output = [str(entry)]\n            for col in columns:\n                new_output.append(str(data[entry][col]) if col in data[entry] else \"\")\n            output.append(new_output)\n    else:\n        for entry in data:\n            new_output = []\n            for col in columns:\n                new_output.append(str(entry[col]) if col in entry else \"\")\n            output.append(new_output)\n\n    csv_string = io.StringIO()\n    csv_writer = UnicodeWriter(csv_string)\n    for row in output:\n        csv_writer.writerow(row)\n    csv_string.seek(0)\n    web.header('Content-Type', 'text/csv; charset=utf-8')\n    web.header('Content-disposition', 'attachment; filename=export.csv')\n    return csv_string.read()", "response": "Returns the content of a CSV file with the data of the dict data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the HTML of the administration menu.", "response": "def get_menu(course, current, renderer, plugin_manager, user_manager):\n    \"\"\" Returns the HTML of the menu used in the administration. ```current``` is the current page of section \"\"\"\n    default_entries = []\n    if user_manager.has_admin_rights_on_course(course):\n        default_entries += [(\"settings\", \"<i class='fa fa-cog fa-fw'></i>&nbsp; \" + _(\"Course settings\"))]\n\n    default_entries += [(\"stats\", \"<i class='fa fa-area-chart fa-fw'></i>&nbsp; \" + _(\"Stats\")),\n                        (\"students\", \"<i class='fa fa-user fa-fw'></i>&nbsp; \" + _(\"Students\"))]\n\n    if not course.is_lti():\n        default_entries += [(\"aggregations\", \"<i class='fa fa-group fa-fw'></i>&nbsp; \" +\n                             (_(\"Classrooms\") if course.use_classrooms() else _(\"Teams\")))]\n\n    default_entries += [(\"tasks\", \"<i class='fa fa-tasks fa-fw'></i>&nbsp; \" + _(\"Tasks\")),\n                        (\"submissions\", \"<i class='fa fa-search fa-fw'></i>&nbsp; \" + _(\"View submissions\")),\n                        (\"download\", \"<i class='fa fa-download fa-fw'></i>&nbsp; \" + _(\"Download submissions\"))]\n\n    if user_manager.has_admin_rights_on_course(course):\n        if web.ctx.app_stack[0].webdav_host:\n            default_entries += [(\"webdav\", \"<i class='fa fa-folder-open fa-fw'></i>&nbsp; \" + _(\"WebDAV access\"))]\n        default_entries += [(\"replay\", \"<i class='fa fa-refresh fa-fw'></i>&nbsp; \" + _(\"Replay submissions\")),\n                            (\"danger\", \"<i class='fa fa-bomb fa-fw'></i>&nbsp; \" + _(\"Danger zone\"))]\n\n    # Hook should return a tuple (link,name) where link is the relative link from the index of the course administration.\n    additional_entries = [entry for entry in plugin_manager.call_hook('course_admin_menu', course=course) if entry is not None]\n\n    return renderer.course_admin.menu(course, default_entries + additional_entries, current)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_course_and_check_rights(self, courseid, taskid=None, allow_all_staff=True):\n\n        try:\n            course = self.course_factory.get_course(courseid)\n            if allow_all_staff:\n                if not self.user_manager.has_staff_rights_on_course(course):\n                    raise web.notfound()\n            else:\n                if not self.user_manager.has_admin_rights_on_course(course):\n                    raise web.notfound()\n\n            if taskid is None:\n                return course, None\n            else:\n                return course, course.get_task(taskid)\n        except:\n            raise web.notfound()", "response": "Returns the course and task with id courseid and checks the rights of the user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the list of submissions that have been selected by the admin", "response": "def get_selected_submissions(self, course, filter_type, selected_tasks, users, aggregations, stype):\n        \"\"\"\n        Returns the submissions that have been selected by the admin\n        :param course: course\n        :param filter_type: users or aggregations\n        :param selected_tasks: selected tasks id\n        :param users: selected usernames\n        :param aggregations: selected aggregations\n        :param stype: single or all submissions\n        :return:\n        \"\"\"\n        if filter_type == \"users\":\n            self._validate_list(users)\n            aggregations = list(self.database.aggregations.find({\"courseid\": course.get_id(),\n                                                                 \"students\": {\"$in\": users}}))\n            # Tweak if not using classrooms : classroom['students'] may content ungrouped users\n            aggregations = dict([(username,\n                                  aggregation if course.use_classrooms() or (\n                                      len(aggregation['groups']) and\n                                      username in aggregation['groups'][0][\"students\"]\n                                  ) else None\n                                  ) for aggregation in aggregations for username in users])\n\n        else:\n            self._validate_list(aggregations)\n            aggregations = list(\n                self.database.aggregations.find({\"_id\": {\"$in\": [ObjectId(cid) for cid in aggregations]}}))\n\n            # Tweak if not using classrooms : classroom['students'] may content ungrouped users\n            aggregations = dict([(username,\n                                  aggregation if course.use_classrooms() or (\n                                      len(aggregation['groups']) and\n                                      username in aggregation['groups'][0][\"students\"]\n                                  ) else None\n                                  ) for aggregation in aggregations for username in aggregation[\"students\"]])\n\n        if stype == \"single\":\n            user_tasks = list(self.database.user_tasks.find({\"username\": {\"$in\": list(aggregations.keys())},\n                                                             \"taskid\": {\"$in\": selected_tasks},\n                                                             \"courseid\": course.get_id()}))\n\n            submissionsid = [user_task['submissionid'] for user_task in user_tasks if user_task['submissionid'] is not None]\n            submissions = list(self.database.submissions.find({\"_id\": {\"$in\": submissionsid}}))\n        else:\n            submissions = list(self.database.submissions.find({\"username\": {\"$in\": list(aggregations.keys())},\n                                                               \"taskid\": {\"$in\": selected_tasks},\n                                                               \"courseid\": course.get_id(),\n                                                               \"status\": {\"$in\": [\"done\", \"error\"]}}))\n\n        return submissions, aggregations"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a row to the CSV file", "response": "def writerow(self, row):\n        \"\"\" Writes a row to the CSV file \"\"\"\n        self.writer.writerow(row)\n        # Fetch UTF-8 output from the queue ...\n        data = self.queue.getvalue()\n        # write to the target stream\n        self.stream.write(data)\n        # empty queue\n        self.queue.truncate(0)\n        self.queue.seek(0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting request for the given course", "response": "def GET_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        \"\"\" GET request \"\"\"\n        course, __ = self.get_course_and_check_rights(courseid)\n        if self.user_manager.session_username() in course.get_tutors():\n            raise web.seeother(self.app.get_homepath() + '/admin/{}/tasks'.format(courseid))\n        else:\n            raise web.seeother(self.app.get_homepath() + '/admin/{}/settings'.format(courseid))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the default renderer", "response": "def get_renderer(self, with_layout=True):\n        \"\"\" Get the default renderer \"\"\"\n        if with_layout and self.is_lti():\n            return self._default_renderer_lti\n        elif with_layout:\n            return self._default_renderer\n        else:\n            return self._default_renderer_nolayout"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_custom_renderer(self, dir_path, layout=True):\n\n        # if dir_path/base is a absolute path, os.path.join(something, an_absolute_path) returns an_absolute_path.\n        root_path = inginious.get_root_path()\n\n        if isinstance(layout, str):\n            layout_path = os.path.join(root_path, layout)\n        elif layout is True:\n            layout_path = os.path.join(root_path, self._layout)\n        else:\n            layout_path = None\n\n        return web.template.render(os.path.join(root_path, dir_path),\n                                   globals=self._template_globals,\n                                   base=layout_path)", "response": "Create a custom renderer on templates in the specified directory and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _javascript_helper(self, position):\n        if position not in [\"header\", \"footer\"]:\n            position = \"footer\"\n\n        # Load javascript files from plugins\n        if position == \"header\":\n            entries = [entry for entry in self._plugin_manager.call_hook(\"javascript_header\") if entry is not None]\n        else:\n            entries = [entry for entry in self._plugin_manager.call_hook(\"javascript_footer\") if entry is not None]\n        # Load javascript for the current page\n        entries += self._get_ctx()[\"javascript\"][position]\n        entries = [\"<script src='\" + entry + \"' type='text/javascript' charset='utf-8'></script>\" for entry in entries]\n        return \"\\n\".join(entries)", "response": "Return the javascript file for the current page and the plugins"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds CSS links for the current page and for the plugins", "response": "def _css_helper(self):\n        \"\"\" Add CSS links for the current page and for the plugins \"\"\"\n        entries = [entry for entry in self._plugin_manager.call_hook(\"css\") if entry is not None]\n        # Load javascript for the current page\n        entries += self._get_ctx()[\"css\"]\n        entries = [\"<link href='\" + entry + \"' rel='stylesheet'>\" for entry in entries]\n        return \"\\n\".join(entries)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_ctx(self):\n        if self._WEB_CTX_KEY not in web.ctx:\n            web.ctx[self._WEB_CTX_KEY] = {\n                \"javascript\": {\"footer\": [], \"header\": []},\n                \"css\": []}\n        return web.ctx.get(self._WEB_CTX_KEY)", "response": "Get the web. ctx object for the Template helper"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking a json dump of data that can be used directly in a script tag.", "response": "def _json_safe_dump(self, data):\n        \"\"\" Make a json dump of `data`, that can be used directly in a `<script>` tag. Available as json() inside templates \"\"\"\n        return json.dumps(data).replace(u'<', u'\\\\u003c') \\\n            .replace(u'>', u'\\\\u003e') \\\n            .replace(u'&', u'\\\\u0026') \\\n            .replace(u\"'\", u'\\\\u0027')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget request for the AUTH section of the course", "response": "def GET_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        \"\"\" GET request \"\"\"\n        course, __ = self.get_course_and_check_rights(courseid)\n\n        if course.is_lti():\n            raise web.notfound()\n\n        if \"download\" in web.input():\n            web.header('Content-Type', 'text/x-yaml', unique=True)\n            web.header('Content-Disposition', 'attachment; filename=\"aggregations.yaml\"', unique=True)\n            if course.use_classrooms():\n                aggregations = [{\"default\": aggregation[\"default\"],\n                               \"description\": aggregation[\"description\"],\n                               \"groups\": aggregation[\"groups\"],\n                               \"students\": aggregation[\"students\"],\n                               \"tutors\": aggregation[\"tutors\"]} for aggregation in\n                              self.user_manager.get_course_aggregations(course)]\n            else:\n                aggregations = [{\"default\": aggregation[\"default\"],\n                               \"description\": aggregation[\"description\"],\n                               \"groups\": aggregation[\"groups\"],\n                               \"students\": aggregation[\"students\"],\n                               \"tutors\": aggregation[\"tutors\"]} for aggregation in\n                              self.user_manager.get_course_aggregations(course) if len(aggregation[\"groups\"]) > 0]\n\n            return yaml.dump(aggregations)\n\n        return self.page(course)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef POST_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        course, __ = self.get_course_and_check_rights(courseid)\n\n        if course.is_lti():\n            raise web.notfound()\n\n        error = False\n        try:\n            if self.user_manager.has_admin_rights_on_course(course):\n                data = web.input()\n                if 'classroom' in data:\n                    default = True if self.database.aggregations.find_one({\"courseid\": courseid, \"default\": True}) is None else False\n                    self.database.aggregations.insert({\"default\": default, \"courseid\": courseid, \"students\": [],\n                                                     \"tutors\": [], \"groups\": [],\n                                                     \"description\": data['classroom']})\n                    msg = _(\"New classroom created.\")\n                elif 'default' in data:\n                    self.database.aggregations.find_one_and_update({\"courseid\": courseid, \"default\": True},\n                                                                 {\"$set\": {\"default\": False}})\n                    self.database.aggregations.find_one_and_update({\"_id\": ObjectId(data['default'])},\n                                                                 {\"$set\": {\"default\": True}})\n                    msg = _(\"Default classroom changed.\")\n                else:  # default, but with no classroom detected\n                    msg = _(\"Invalid classroom selected.\")\n            else:\n                msg = _(\"You have no rights to add/change classrooms\")\n                error = True\n        except:\n            msg = _('User returned an invalid form.')\n            error = True\n\n        return self.page(course, msg, error)", "response": "POST request for classrooms"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all data and display the page", "response": "def page(self, course, msg=\"\", error=False):\n        \"\"\" Get all data and display the page \"\"\"\n        aggregations = OrderedDict()\n        taskids = list(course.get_tasks().keys())\n\n        for aggregation in self.user_manager.get_course_aggregations(course):\n            aggregations[aggregation['_id']] = dict(list(aggregation.items()) +\n                                                [(\"tried\", 0),\n                                                 (\"done\", 0),\n                                                 (\"url\", self.submission_url_generator(aggregation['_id']))\n                                                 ])\n\n            data = list(self.database.submissions.aggregate(\n                [\n                    {\n                        \"$match\":\n                            {\n                                \"courseid\": course.get_id(),\n                                \"taskid\": {\"$in\": taskids},\n                                \"username\": {\"$in\": aggregation[\"students\"]}\n                            }\n                    },\n                    {\n                        \"$group\":\n                            {\n                                \"_id\": \"$taskid\",\n                                \"tried\": {\"$sum\": 1},\n                                \"done\": {\"$sum\": {\"$cond\": [{\"$eq\": [\"$result\", \"success\"]}, 1, 0]}}\n                            }\n                    },\n\n                ]))\n\n            for c in data:\n                aggregations[aggregation['_id']][\"tried\"] += 1 if c[\"tried\"] else 0\n                aggregations[aggregation['_id']][\"done\"] += 1 if c[\"done\"] else 0\n\n        my_aggregations, other_aggregations = [], []\n        for aggregation in aggregations.values():\n            if self.user_manager.session_username() in aggregation[\"tutors\"]:\n                my_aggregations.append(aggregation)\n            else:\n                other_aggregations.append(aggregation)\n\n        if \"csv\" in web.input():\n            return make_csv(data)\n\n        return self.template_helper.get_renderer().course_admin.aggregation_list(course, [my_aggregations, other_aggregations], msg, error)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef new_job(self, task, inputdata, launcher_name=\"Unknown\", debug=False):\n        bjobid = uuid.uuid4()\n        self._waiting_jobs.append(str(bjobid))\n        self._client.new_job(task, inputdata,\n                             (lambda result, grade, problems, tests, custom, archive, stdout, stderr:\n                              self._callback(bjobid, result, grade, problems, tests, custom, archive, stdout, stderr)),\n                             launcher_name, debug)\n        return bjobid", "response": "Runs a new job."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the result of the task.", "response": "def get_result(self, bjobid):\n        \"\"\"\n            Get the result of task. Must only be called ONCE, AFTER the task is done (after a successfull call to is_done).\n            :return a tuple (result, grade, problems, tests, custom, archive)\n            result is itself a tuple containing the result string and the main feedback (i.e. ('success', 'You succeeded')\n            grade is a number between 0 and 100 indicating the grade of the users\n            problems is a dict of tuple, in the form {'problemid': result}\n            test is a dict of tests made in the container\n            custom is a dict containing random things set in the container\n            archive is either None or a bytes containing a tgz archive of files from the job\n        \"\"\"\n        result = self._jobs_done[str(bjobid)]\n        del self._jobs_done[str(bjobid)]\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets submissions from the submission manager", "response": "def POST_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        \"\"\" GET request \"\"\"\n        course, __ = self.get_course_and_check_rights(courseid)\n\n        user_input = web.input(tasks=[], aggregations=[], users=[])\n\n        if \"filter_type\" not in user_input or \"type\" not in user_input or \"format\" not in user_input or user_input.format not in self.valid_formats():\n            raise web.notfound()\n\n        tasks = list(course.get_tasks().keys())\n        for i in user_input.tasks:\n            if i not in tasks:\n                raise web.notfound()\n\n        # Load submissions\n        submissions, aggregations = self.get_selected_submissions(course, user_input.filter_type, user_input.tasks,\n                                                    user_input.users, user_input.aggregations, user_input.type)\n\n        self._logger.info(\"Downloading %d submissions from course %s\", len(submissions), courseid)\n        web.header('Content-Type', 'application/x-gzip', unique=True)\n        web.header('Content-Disposition', 'attachment; filename=\"submissions.tgz\"', unique=True)\n        return self.submission_manager.get_submission_archive(submissions, list(reversed(user_input.format.split('/'))), aggregations)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef GET_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        course, __ = self.get_course_and_check_rights(courseid)\n        user_input = web.input()\n\n        # First, check for a particular submission\n        if \"submission\" in user_input:\n            submission = self.database.submissions.find_one({\"_id\": ObjectId(user_input.submission),\n                                                             \"courseid\": course.get_id(),\n                                                             \"status\": {\"$in\": [\"done\", \"error\"]}})\n            if submission is None:\n                raise web.notfound()\n\n            self._logger.info(\"Downloading submission %s - %s - %s - %s\", submission['_id'], submission['courseid'],\n                              submission['taskid'], submission['username'])\n            web.header('Content-Type', 'application/x-gzip', unique=True)\n            web.header('Content-Disposition', 'attachment; filename=\"submissions.tgz\"', unique=True)\n            return self.submission_manager.get_submission_archive([submission], [], {})\n\n        # Else, display the complete page\n\n        tasks, user_data, aggregations, tutored_aggregations,\\\n        tutored_users, checked_tasks, checked_users, show_aggregations = self.show_page_params(course, user_input)\n\n        chosen_format = self.valid_formats()[0]\n        if \"format\" in user_input and user_input.format in self.valid_formats():\n            chosen_format = user_input.format\n            if \"aggregation\" in chosen_format:\n                show_aggregations = True\n\n        return self.template_helper.get_renderer().course_admin.download(course, tasks, user_data, aggregations,\n                                                                         tutored_aggregations, tutored_users,\n                                                                         checked_tasks, checked_users,\n                                                                         self.valid_formats(), chosen_format,\n                                                                         show_aggregations)", "response": "Get the authorised page of a specific course."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init(plugin_manager, _, _2, conf):\n\n    encryption = conf.get(\"encryption\", \"none\")\n    if encryption not in [\"none\", \"ssl\", \"tls\"]:\n        raise Exception(\"Unknown encryption method {}\".format(encryption))\n    if encryption == \"none\":\n        conf[\"encryption\"] = None\n\n    if conf.get(\"port\", 0) == 0:\n        conf[\"port\"] = None\n\n    the_method = LdapAuthMethod(conf.get(\"id\"), conf.get('name', 'LDAP'), conf.get(\"imlink\", \"\"), conf)\n    plugin_manager.add_page(r'/auth/page/([^/]+)', LDAPAuthenticationPage)\n    plugin_manager.register_auth_method(the_method)", "response": "Initialize the LDAP authentication page."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the object needs encoding.", "response": "def needs_encode(obj):\n    '''\n    >>> from re import compile\n    >>> atomics = (True, 1, 1.0, '', None, compile(''), datetime.now(), b'')\n    >>> any(needs_encode(i) for i in atomics)\n    False\n    >>> needs_encode([1, 2, 3])\n    False\n    >>> needs_encode([])\n    False\n    >>> needs_encode([1, [2, 3]])\n    False\n    >>> needs_encode({})\n    False\n    >>> needs_encode({'1': {'2': 3}})\n    False\n    >>> needs_encode({'1': [2]})\n    False\n    >>> needs_encode(b'1')\n    False\n\n    Objects that don't round trip need encoding::\n\n    >>> needs_encode(tuple())\n    True\n    >>> needs_encode(set())\n    True\n    >>> needs_encode([1, [set()]])\n    True\n    >>> needs_encode({'1': {'2': set()}})\n    True\n\n    Mongo rejects dicts with non-string keys so they need encoding too::\n\n    >>> needs_encode({1: 2})\n    True\n    >>> needs_encode({'1': {None: True}})\n    True\n\n\n    '''\n    obtype = type(obj)\n    if obtype in atomic_types:\n        return False\n    if obtype is list:\n        return any(needs_encode(i) for i in obj)\n    if obtype is dict:\n        return any(type(k) not in valid_key_types or needs_encode(v)\n                   for (k, v) in obj.items())\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cleanup(self, timeout):\n        '''\n        Removes all sessions older than ``timeout`` seconds.\n        Called automatically on every session access.\n        '''\n        cutoff = time() - timeout\n        self.collection.remove({_atime: {'$lt': cutoff}})", "response": "Removes all sessions older than timeout seconds."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading the plugin manager.", "response": "def load(self, client, webpy_app, course_factory, task_factory, database, user_manager, submission_manager, config):\n        \"\"\" Loads the plugin manager. Must be done after the initialisation of the client \"\"\"\n        self._app = webpy_app\n        self._task_factory = task_factory\n        self._database = database\n        self._user_manager = user_manager\n        self._submission_manager = submission_manager\n        self._loaded = True\n        for entry in config:\n            module = importlib.import_module(entry[\"plugin_module\"])\n            module.init(self, course_factory, client, entry)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_page(self, pattern, classname):\n        if not self._loaded:\n            raise PluginManagerNotLoadedException()\n        self._app.add_mapping(pattern, classname)", "response": "Add a new page to the web application."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a task file manager. Only available after that the Plugin Manager is loaded.", "response": "def add_task_file_manager(self, task_file_manager):\n        \"\"\" Add a task file manager. Only available after that the Plugin Manager is loaded \"\"\"\n        if not self._loaded:\n            raise PluginManagerNotLoadedException()\n        self._task_factory.add_custom_task_file_manager(task_file_manager)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a new authentication method", "response": "def register_auth_method(self, auth_method):\n        \"\"\"\n            Register a new authentication method\n\n            name\n                the name of the authentication method, typically displayed by the webapp\n\n            input_to_display\n\n            Only available after that the Plugin Manager is loaded\n        \"\"\"\n        if not self._loaded:\n            raise PluginManagerNotLoadedException()\n        self._user_manager.register_auth_method(auth_method)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dump_course(self, courseid):\n        filepath = os.path.join(self.backup_dir, courseid, datetime.datetime.now().strftime(\"%Y%m%d.%H%M%S\") + \".zip\")\n\n        if not os.path.exists(os.path.dirname(filepath)):\n            os.makedirs(os.path.dirname(filepath))\n\n        with zipfile.ZipFile(filepath, \"w\", allowZip64=True) as zipf:\n            aggregations = self.database.aggregations.find({\"courseid\": courseid})\n            zipf.writestr(\"aggregations.json\", bson.json_util.dumps(aggregations), zipfile.ZIP_DEFLATED)\n\n            user_tasks = self.database.user_tasks.find({\"courseid\": courseid})\n            zipf.writestr(\"user_tasks.json\", bson.json_util.dumps(user_tasks), zipfile.ZIP_DEFLATED)\n\n            submissions = self.database.submissions.find({\"courseid\": courseid})\n            zipf.writestr(\"submissions.json\", bson.json_util.dumps(submissions), zipfile.ZIP_DEFLATED)\n\n            submissions.rewind()\n\n            for submission in submissions:\n                for key in [\"input\", \"archive\"]:\n                    if key in submission and type(submission[key]) == bson.objectid.ObjectId:\n                        infile = self.submission_manager.get_gridfs().get(submission[key])\n                        zipf.writestr(key + \"/\" + str(submission[key]) + \".data\", infile.read(), zipfile.ZIP_DEFLATED)\n\n        self._logger.info(\"Course %s dumped to backup directory.\", courseid)\n        self.wipe_course(courseid)", "response": "Dump all information about a given course in database and remove it from db"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef restore_course(self, courseid, backup):\n        self.wipe_course(courseid)\n\n        filepath = os.path.join(self.backup_dir, courseid, backup + \".zip\")\n        with zipfile.ZipFile(filepath, \"r\") as zipf:\n\n            aggregations = bson.json_util.loads(zipf.read(\"aggregations.json\").decode(\"utf-8\"))\n            if len(aggregations) > 0:\n                self.database.aggregations.insert(aggregations)\n\n            user_tasks = bson.json_util.loads(zipf.read(\"user_tasks.json\").decode(\"utf-8\"))\n            if len(user_tasks) > 0:\n                self.database.user_tasks.insert(user_tasks)\n\n            submissions = bson.json_util.loads(zipf.read(\"submissions.json\").decode(\"utf-8\"))\n            for submission in submissions:\n                for key in [\"input\", \"archive\"]:\n                    if key in submission and type(submission[key]) == bson.objectid.ObjectId:\n                        submission[key] = self.submission_manager.get_gridfs().put(zipf.read(key + \"/\" + str(submission[key]) + \".data\"))\n\n            if len(submissions) > 0:\n                self.database.submissions.insert(submissions)\n\n        self._logger.info(\"Course %s restored from backup directory.\", courseid)", "response": "Restores a course to a date specified in backup."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_course(self, courseid):\n        # Wipes the course (delete database)\n        self.wipe_course(courseid)\n\n        # Deletes the course from the factory (entire folder)\n        self.course_factory.delete_course(courseid)\n\n        # Removes backup\n        filepath = os.path.join(self.backup_dir, courseid)\n        if os.path.exists(os.path.dirname(filepath)):\n            for backup in glob.glob(os.path.join(filepath, '*.zip')):\n                os.remove(backup)\n\n        self._logger.info(\"Course %s files erased.\", courseid)", "response": "Erase all course data"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets request for a specific course", "response": "def GET_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        \"\"\" GET request \"\"\"\n        course, __ = self.get_course_and_check_rights(courseid, allow_all_staff=False)\n\n        data = web.input()\n\n        if \"download\" in data:\n            filepath = os.path.join(self.backup_dir, courseid, data[\"download\"] + '.zip')\n\n            if not os.path.exists(os.path.dirname(filepath)):\n                raise web.notfound()\n\n            web.header('Content-Type', 'application/zip', unique=True)\n            web.header('Content-Disposition', 'attachment; filename=\"' + data[\"download\"] + '.zip' + '\"', unique=True)\n\n            return open(filepath, 'rb')\n\n        else:\n            return self.page(course)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef POST_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        course, __ = self.get_course_and_check_rights(courseid, allow_all_staff=False)\n\n        msg = \"\"\n        error = False\n\n        data = web.input()\n        if not data.get(\"token\", \"\") == self.user_manager.session_token():\n            msg = _(\"Operation aborted due to invalid token.\")\n            error = True\n        elif \"wipeall\" in data:\n            if not data.get(\"courseid\", \"\") == courseid:\n                msg = _(\"Wrong course id.\")\n                error = True\n            else:\n                try:\n                    self.dump_course(courseid)\n                    msg = _(\"All course data have been deleted.\")\n                except:\n                    msg = _(\"An error occurred while dumping course from database.\")\n                    error = True\n        elif \"restore\" in data:\n            if \"backupdate\" not in data:\n                msg = \"No backup date selected.\"\n                error = True\n            else:\n                try:\n                    dt = datetime.datetime.strptime(data[\"backupdate\"], \"%Y%m%d.%H%M%S\")\n                    self.restore_course(courseid, data[\"backupdate\"])\n                    msg = _(\"Course restored to date : {}.\").format(dt.strftime(\"%Y-%m-%d %H:%M:%S\"))\n                except:\n                    msg = _(\"An error occurred while restoring backup.\")\n                    error = True\n        elif \"deleteall\" in data:\n            if not data.get(\"courseid\", \"\") == courseid:\n                msg = _(\"Wrong course id.\")\n                error = True\n            else:\n                try:\n                    self.delete_course(courseid)\n                    web.seeother(self.app.get_homepath() + '/index')\n                except:\n                    msg = _(\"An error occurred while deleting the course data.\")\n                    error = True\n\n        return self.page(course, msg, error)", "response": "POST request for the course"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef page(self, course, msg=\"\", error=False):\n        thehash = hashlib.sha512(str(random.getrandbits(256)).encode(\"utf-8\")).hexdigest()\n        self.user_manager.set_session_token(thehash)\n\n        backups = self.get_backup_list(course)\n\n        return self.template_helper.get_renderer().course_admin.danger_zone(course, thehash, backups, msg, error)", "response": "Get all data and display the page"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_input(self, template_helper, language, seed):\n        header = ParsableText(self.gettext(language,self._header), \"rst\",\n                              translation=self._translations.get(language, gettext.NullTranslations()))\n        return str(DisplayableCodeProblem.get_renderer(template_helper).tasks.code(self.get_id(), header, 8, 0, self._language, self._optional, self._default))", "response": "Show BasicCodeProblem and derivatives"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nshow input file box", "response": "def show_input(self, template_helper, language, seed):\n        \"\"\" Show FileBox \"\"\"\n        header = ParsableText(self.gettext(language, self._header), \"rst\",\n                              translation=self._translations.get(language, gettext.NullTranslations()))\n        return str(DisplayableFileProblem.get_renderer(template_helper).tasks.file(self.get_id(), header, self._max_size, self._allowed_exts))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_input(self, template_helper, language, seed):\n        choices = []\n        limit = self._limit\n        if limit == 0:\n            limit = len(self._choices)  # no limit\n\n        rand = Random(\"{}#{}#{}\".format(self.get_task().get_id(), self.get_id(), seed))\n\n        # Ensure that the choices are random\n        # we *do* need to copy the choices here\n        random_order_choices = list(self._choices)\n        rand.shuffle(random_order_choices)\n\n        if self._multiple:\n            # take only the valid choices in the first pass\n            for entry in random_order_choices:\n                if entry['valid']:\n                    choices.append(entry)\n                    limit = limit - 1\n            # take everything else in a second pass\n            for entry in random_order_choices:\n                if limit == 0:\n                    break\n                if not entry['valid']:\n                    choices.append(entry)\n                    limit = limit - 1\n        else:\n            # need to have ONE valid entry\n            for entry in random_order_choices:\n                if not entry['valid'] and limit > 1:\n                    choices.append(entry)\n                    limit = limit - 1\n            for entry in random_order_choices:\n                if entry['valid'] and limit > 0:\n                    choices.append(entry)\n                    limit = limit - 1\n\n        rand.shuffle(choices)\n\n        header = ParsableText(self.gettext(language, self._header), \"rst\",\n                              translation=self._translations.get(language, gettext.NullTranslations()))\n\n        return str(DisplayableMultipleChoiceProblem.get_renderer(template_helper).tasks.multiple_choice(\n            self.get_id(), header, self._multiple, choices,\n            lambda text: ParsableText(self.gettext(language, text) if text else \"\", \"rst\",\n                                      translation=self._translations.get(language, gettext.NullTranslations()))))", "response": "Show the input for the multiple choice problem"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_input(self, template_helper, language, seed):\n        header = ParsableText(self.gettext(language, self._header), \"rst\",\n                              translation=self._translations.get(language, gettext.NullTranslations()))\n        return str(DisplayableMatchProblem.get_renderer(template_helper).tasks.match(self.get_id(), header))", "response": "Show the input for this match"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the selected submission for the given course and task. Returns a boolean indicating whether the operation was successful or not.", "response": "def set_selected_submission(self, course, task, submissionid):\n        \"\"\" Set submission whose id is `submissionid` to selected grading submission for the given course/task.\n            Returns a boolean indicating whether the operation was successful or not.\n        \"\"\"\n\n        submission = self.submission_manager.get_submission(submissionid)\n\n        # Do not continue if submission does not exist or is not owned by current user\n        if not submission:\n            return False\n\n        # Check if the submission if from this task/course!\n        if submission[\"taskid\"] != task.get_id() or submission[\"courseid\"] != course.get_id():\n            return False\n\n        is_staff = self.user_manager.has_staff_rights_on_course(course, self.user_manager.session_username())\n\n        # Do not enable submission selection after deadline\n        if not task.get_accessible_time().is_open() and not is_staff:\n            return False\n\n        # Only allow to set submission if the student must choose their best submission themselves\n        if task.get_evaluate() != 'student' and not is_staff:\n            return False\n\n        # Check if task is done per group/team\n        if task.is_group_task() and not is_staff:\n            group = self.database.aggregations.find_one(\n                {\"courseid\": task.get_course_id(), \"groups.students\": self.user_manager.session_username()},\n                {\"groups\": {\"$elemMatch\": {\"students\": self.user_manager.session_username()}}})\n            students = group[\"groups\"][0][\"students\"]\n        else:\n            students = [self.user_manager.session_username()]\n\n        # Check if group/team is the same\n        if students == submission[\"username\"]:\n            self.database.user_tasks.update_many(\n                {\"courseid\": task.get_course_id(), \"taskid\": task.get_id(), \"username\": {\"$in\": students}},\n                {\"$set\": {\"submissionid\": submission['_id'],\n                          \"grade\": submission['grade'],\n                          \"succeeded\": submission[\"result\"] == \"success\"}})\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the course and task and return the appropriate template class.", "response": "def GET(self, courseid, taskid, isLTI):\n        \"\"\" GET request \"\"\"\n        username = self.user_manager.session_username()\n\n        # Fetch the course\n        try:\n            course = self.course_factory.get_course(courseid)\n        except exceptions.CourseNotFoundException as ex:\n            raise web.notfound(str(ex))\n\n        if isLTI and not self.user_manager.course_is_user_registered(course):\n            self.user_manager.course_register_user(course, force=True)\n\n        if not self.user_manager.course_is_open_to_user(course, username, isLTI):\n            return self.template_helper.get_renderer().course_unavailable()\n\n        # Fetch the task\n        try:\n            tasks = OrderedDict((tid, t) for tid, t in course.get_tasks().items() if self.user_manager.task_is_visible_by_user(t, username, isLTI))\n            task = tasks[taskid]\n        except exceptions.TaskNotFoundException as ex:\n            raise web.notfound(str(ex))\n\n        if not self.user_manager.task_is_visible_by_user(task, username, isLTI):\n            return self.template_helper.get_renderer().task_unavailable()\n\n        # Compute previous and next taskid\n        keys = list(tasks.keys())\n        index = keys.index(taskid)\n        previous_taskid = keys[index - 1] if index > 0 else None\n        next_taskid = keys[index + 1] if index < len(keys) - 1 else None\n\n        self.user_manager.user_saw_task(username, courseid, taskid)\n\n        is_staff = self.user_manager.has_staff_rights_on_course(course, username)\n\n        userinput = web.input()\n        if \"submissionid\" in userinput and \"questionid\" in userinput:\n            # Download a previously submitted file\n            submission = self.submission_manager.get_submission(userinput[\"submissionid\"], user_check=not is_staff)\n            if submission is None:\n                raise web.notfound()\n            sinput = self.submission_manager.get_input_from_submission(submission, True)\n            if userinput[\"questionid\"] not in sinput:\n                raise web.notfound()\n\n            if isinstance(sinput[userinput[\"questionid\"]], dict):\n                # File uploaded previously\n                mimetypes.init()\n                mime_type = mimetypes.guess_type(urllib.request.pathname2url(sinput[userinput[\"questionid\"]]['filename']))\n                web.header('Content-Type', mime_type[0])\n                return sinput[userinput[\"questionid\"]]['value']\n            else:\n                # Other file, download it as text\n                web.header('Content-Type', 'text/plain')\n                return sinput[userinput[\"questionid\"]]\n        else:\n            # Generate random inputs and save it into db\n            random.seed(str(username if username is not None else \"\") + taskid + courseid + str(\n                time.time() if task.regenerate_input_random() else \"\"))\n            random_input_list = [random.random() for i in range(task.get_number_input_random())]\n\n            user_task = self.database.user_tasks.find_one_and_update(\n                {\n                    \"courseid\": task.get_course_id(),\n                    \"taskid\": task.get_id(),\n                    \"username\": self.user_manager.session_username()\n                },\n                {\n                    \"$set\": {\"random\": random_input_list}\n                },\n                return_document=ReturnDocument.AFTER\n            )\n\n            submissionid = user_task.get('submissionid', None)\n            eval_submission = self.database.submissions.find_one({'_id': ObjectId(submissionid)}) if submissionid else None\n\n            students = [self.user_manager.session_username()]\n            if task.is_group_task() and not self.user_manager.has_admin_rights_on_course(course, username):\n                group = self.database.aggregations.find_one(\n                    {\"courseid\": task.get_course_id(), \"groups.students\": self.user_manager.session_username()},\n                    {\"groups\": {\"$elemMatch\": {\"students\": self.user_manager.session_username()}}})\n                if group is not None and len(group[\"groups\"]) > 0:\n                    students = group[\"groups\"][0][\"students\"]\n                # we don't care for the other case, as the student won't be able to submit.\n\n            submissions = self.submission_manager.get_user_submissions(task) if self.user_manager.session_logged_in() else []\n            user_info = self.database.users.find_one({\"username\": username})\n\n            # Display the task itself\n            return self.template_helper.get_renderer().task(user_info, course, task, submissions,\n                                                            students, eval_submission, user_task, previous_taskid, next_taskid, self.webterm_link, random_input_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef POST(self, courseid, taskid, isLTI):\n        username = self.user_manager.session_username()\n\n        course = self.course_factory.get_course(courseid)\n        if not self.user_manager.course_is_open_to_user(course, username, isLTI):\n            return self.template_helper.get_renderer().course_unavailable()\n\n        task = course.get_task(taskid)\n        if not self.user_manager.task_is_visible_by_user(task, username, isLTI):\n            return self.template_helper.get_renderer().task_unavailable()\n\n        self.user_manager.user_saw_task(username, courseid, taskid)\n\n        is_staff = self.user_manager.has_staff_rights_on_course(course, username)\n        is_admin = self.user_manager.has_admin_rights_on_course(course, username)\n\n        userinput = web.input()\n        if \"@action\" in userinput and userinput[\"@action\"] == \"submit\":\n            # Verify rights\n            if not self.user_manager.task_can_user_submit(task, username, isLTI):\n                return json.dumps({\"status\": \"error\", \"text\": _(\"You are not allowed to submit for this task.\")})\n\n            # Retrieve input random and check still valid\n            random_input = self.database.user_tasks.find_one({\"courseid\": task.get_course_id(), \"taskid\": task.get_id(), \"username\": username}, { \"random\": 1 })\n            random_input = random_input[\"random\"] if \"random\" in random_input else []\n            for i in range(0, len(random_input)):\n                s = \"@random_\" + str(i)\n                if s not in userinput or float(userinput[s]) != random_input[i]:\n                    return json.dumps({\"status\": \"error\", \"text\": _(\"Your task has been regenerated. This current task is outdated.\")})\n\n            # Reparse user input with array for multiple choices\n            init_var = {\n                problem.get_id(): problem.input_type()()\n                for problem in task.get_problems() if problem.input_type() in [dict, list]\n            }\n            userinput = task.adapt_input_for_backend(web.input(**init_var))\n\n            if not task.input_is_consistent(userinput, self.default_allowed_file_extensions, self.default_max_file_size):\n                web.header('Content-Type', 'application/json')\n                return json.dumps({\"status\": \"error\", \"text\": _(\"Please answer to all the questions and verify the extensions of the files \"\n                                                              \"you want to upload. Your responses were not tested.\")})\n            del userinput['@action']\n\n            # Get debug info if the current user is an admin\n            debug = is_admin\n            if \"@debug-mode\" in userinput:\n                if userinput[\"@debug-mode\"] == \"ssh\" and debug:\n                    debug = \"ssh\"\n                del userinput['@debug-mode']\n\n            # Start the submission\n            try:\n                submissionid, oldsubids = self.submission_manager.add_job(task, userinput, debug)\n                web.header('Content-Type', 'application/json')\n                return json.dumps({\"status\": \"ok\", \"submissionid\": str(submissionid), \"remove\": oldsubids, \"text\": _(\"<b>Your submission has been sent...</b>\")})\n            except Exception as ex:\n                web.header('Content-Type', 'application/json')\n                return json.dumps({\"status\": \"error\", \"text\": str(ex)})\n\n        elif \"@action\" in userinput and userinput[\"@action\"] == \"check\" and \"submissionid\" in userinput:\n            result = self.submission_manager.get_submission(userinput['submissionid'], user_check=not is_staff)\n            if result is None:\n                web.header('Content-Type', 'application/json')\n                return json.dumps({'status': \"error\", \"text\": _(\"Internal error\")})\n            elif self.submission_manager.is_done(result, user_check=not is_staff):\n                web.header('Content-Type', 'application/json')\n                result = self.submission_manager.get_input_from_submission(result)\n                result = self.submission_manager.get_feedback_from_submission(result, show_everything=is_staff)\n\n                # user_task always exists as we called user_saw_task before\n                user_task = self.database.user_tasks.find_one({\n                    \"courseid\":task.get_course_id(),\n                    \"taskid\": task.get_id(),\n                    \"username\": {\"$in\": result[\"username\"]}\n                })\n\n                default_submissionid = user_task.get('submissionid', None)\n                if default_submissionid is None:\n                    # This should never happen, as user_manager.update_user_stats is called whenever a submission is done.\n                    return json.dumps({'status': \"error\", \"text\": _(\"Internal error\")})\n\n                return self.submission_to_json(task, result, is_admin, False, default_submissionid == result['_id'], tags=task.get_tags())\n            else:\n                web.header('Content-Type', 'application/json')\n                return self.submission_to_json(task, result, is_admin)\n\n        elif \"@action\" in userinput and userinput[\"@action\"] == \"load_submission_input\" and \"submissionid\" in userinput:\n            submission = self.submission_manager.get_submission(userinput[\"submissionid\"], user_check=not is_staff)\n            submission = self.submission_manager.get_input_from_submission(submission)\n            submission = self.submission_manager.get_feedback_from_submission(submission, show_everything=is_staff)\n            if not submission:\n                raise web.notfound()\n            web.header('Content-Type', 'application/json')\n\n            return self.submission_to_json(task, submission, is_admin, True, tags=task.get_tags())\n\n        elif \"@action\" in userinput and userinput[\"@action\"] == \"kill\" and \"submissionid\" in userinput:\n            self.submission_manager.kill_running_submission(userinput[\"submissionid\"])  # ignore return value\n            web.header('Content-Type', 'application/json')\n            return json.dumps({'status': 'done'})\n        elif \"@action\" in userinput and userinput[\"@action\"] == \"set_submission\" and \"submissionid\" in userinput:\n            web.header('Content-Type', 'application/json')\n            if task.get_evaluate() != 'student':\n                return json.dumps({'status': \"error\"})\n\n            if self.set_selected_submission(course, task, userinput[\"submissionid\"]):\n                return json.dumps({'status': 'done'})\n            else:\n                return json.dumps({'status': 'error'})\n        else:\n            raise web.notfound()", "response": "POST a new submission"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef submission_to_json(self, task, data, debug, reloading=False, replace=False, tags={}):\n\n        if \"ssh_host\" in data:\n            return json.dumps({'status': \"waiting\", 'text': \"<b>SSH server active</b>\",\n                               'ssh_host': data[\"ssh_host\"], 'ssh_port': data[\"ssh_port\"],\n                               'ssh_password': data[\"ssh_password\"]})\n\n        # Here we are waiting. Let's send some useful information.\n        waiting_data = self.submission_manager.get_job_queue_info(data[\"jobid\"]) if \"jobid\" in data else None\n        if waiting_data is not None and not reloading:\n            nb_tasks_before, approx_wait_time = waiting_data\n            wait_time = round(approx_wait_time)\n            if nb_tasks_before == -1 and wait_time <= 0:\n                text = _(\"<b>INGInious is currently grading your answers.<b/> (almost done)\")\n            elif nb_tasks_before == -1:\n                text = _(\"<b>INGInious is currently grading your answers.<b/> (Approx. wait time: {} seconds)\").format(\n                    wait_time)\n            elif nb_tasks_before == 0:\n                text = _(\"<b>You are next in the waiting queue!</b>\")\n            elif nb_tasks_before == 1:\n                text = _(\"<b>There is one task in front of you in the waiting queue.</b>\")\n            else:\n                text = _(\"<b>There are {} tasks in front of you in the waiting queue.</b>\").format(nb_tasks_before)\n\n            return json.dumps({'status': \"waiting\", 'text': text})\n\n        tojson = {\n            'status': data['status'],\n            'result': data.get('result', 'crash'),\n            'id': str(data[\"_id\"]),\n            'submitted_on': str(data['submitted_on']),\n            'grade': str(data.get(\"grade\", 0.0)),\n            'replace': replace and not reloading  # Replace the evaluated submission\n        }\n\n        if \"text\" in data:\n            tojson[\"text\"] = data[\"text\"]\n        if \"problems\" in data:\n            tojson[\"problems\"] = data[\"problems\"]\n\n        if debug:\n            tojson[\"debug\"] = data\n\n        if tojson['status'] == 'waiting':\n            tojson[\"text\"] = _(\"<b>Your submission has been sent...</b>\")\n        elif tojson[\"result\"] == \"failed\":\n            tojson[\"text\"] = _(\"There are some errors in your answer. Your score is {score}%.\").format(score=data[\"grade\"])\n        elif tojson[\"result\"] == \"success\":\n            tojson[\"text\"] = _(\"Your answer passed the tests! Your score is {score}%.\").format(score=data[\"grade\"])\n        elif tojson[\"result\"] == \"timeout\":\n            tojson[\"text\"] = _(\"Your submission timed out. Your score is {score}%.\").format(score=data[\"grade\"])\n        elif tojson[\"result\"] == \"overflow\":\n            tojson[\"text\"] = _(\"Your submission made an overflow. Your score is {score}%.\").format(score=data[\"grade\"])\n        elif tojson[\"result\"] == \"killed\":\n            tojson[\"text\"] = _(\"Your submission was killed.\")\n        else:\n            tojson[\"text\"] = _(\"An internal error occurred. Please retry later. \"\n                               \"If the error persists, send an email to the course administrator.\")\n\n        tojson[\"text\"] = \"<b>\" + tojson[\"text\"] + \" \" + _(\"[Submission #{submissionid}]\").format(submissionid=data[\"_id\"]) + \"</b>\" + data.get(\"text\", \"\")\n        tojson[\"text\"] = self.plugin_manager.call_hook_recursive(\"feedback_text\", task=task, submission=data, text=tojson[\"text\"])[\"text\"]\n\n        if reloading:\n            # Set status='ok' because we are reloading an old submission.\n            tojson[\"status\"] = 'ok'\n            # And also include input\n            tojson[\"input\"] = data.get('input', {})\n\n        if \"tests\" in data:\n            tojson[\"tests\"] = {}\n            if tags:\n                for tag in tags[0]+tags[1]: # Tags only visible for admins should not appear in the json for students.\n                    if (tag.is_visible_for_student() or debug) and tag.get_id() in data[\"tests\"]:\n                        tojson[\"tests\"][tag.get_id()] = data[\"tests\"][tag.get_id()]\n            if debug: #We add also auto tags when we are admin\n                for tag in data[\"tests\"]:\n                    if tag.startswith(\"*auto-tag-\"):\n                        tojson[\"tests\"][tag] = data[\"tests\"][tag]\n\n        # allow plugins to insert javascript to be run in the browser after the submission is loaded\n        tojson[\"feedback_script\"] = \"\".join(self.plugin_manager.call_hook(\"feedback_script\", task=task, submission=data))\n\n        return json.dumps(tojson, default=str)", "response": "Converts a submission to json"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef GET(self, courseid, taskid, path):  # pylint: disable=arguments-differ\n        try:\n            course = self.course_factory.get_course(courseid)\n            if not self.user_manager.course_is_open_to_user(course):\n                return self.template_helper.get_renderer().course_unavailable()\n\n            path_norm = posixpath.normpath(urllib.parse.unquote(path))\n\n            if taskid == \"$common\":\n                public_folder = course.get_fs().from_subfolder(\"$common\").from_subfolder(\"public\")\n            else:\n\n                task = course.get_task(taskid)\n                if not self.user_manager.task_is_visible_by_user(task):  # ignore LTI check here\n                    return self.template_helper.get_renderer().task_unavailable()\n\n                public_folder = task.get_fs().from_subfolder(\"public\")\n            (method, mimetype_or_none, file_or_url) = public_folder.distribute(path_norm, False)\n\n            if method == \"local\":\n                web.header('Content-Type', mimetype_or_none)\n                return file_or_url\n            elif method == \"url\":\n                raise web.redirect(file_or_url)\n            else:\n                raise web.notfound()\n        except web.HTTPError as error_or_redirect:\n            raise error_or_redirect\n        except:\n            if web.config.debug:\n                raise\n            else:\n                raise web.notfound()", "response": "A GET request for a specific course and task."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a job in the queue", "response": "def add(self, username, courseid, taskid, consumer_key, service_url, result_id):\n        \"\"\" Add a job in the queue\n        :param username:\n        :param courseid:\n        :param taskid:\n        :param consumer_key:\n        :param service_url:\n        :param result_id:\n        \"\"\"\n        search = {\"username\": username, \"courseid\": courseid,\n                  \"taskid\": taskid, \"service_url\": service_url,\n                  \"consumer_key\": consumer_key, \"result_id\": result_id}\n\n        entry = self._database.lis_outcome_queue.find_one_and_update(search, {\"$set\": {\"nb_attempt\": 0}},\n                                                                     return_document=ReturnDocument.BEFORE, upsert=True)\n        if entry is None:  # and it should be\n            self._add_to_queue(self._database.lis_outcome_queue.find_one(search))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _increment_attempt(self, mongo_id):\n        entry = self._database.lis_outcome_queue.find_one_and_update({\"_id\": mongo_id}, {\"$inc\": {\"nb_attempt\": 1}})\n\n        self._add_to_queue(entry)", "response": "Increment the number of attempts for an entry and add it to the outcome queue"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef GET(self):\n        data = self.user_manager.session_lti_info()\n        if data is None:\n            raise web.notfound()\n\n        try:\n            course = self.course_factory.get_course(data[\"task\"][0])\n            if data[\"consumer_key\"] not in course.lti_keys().keys():\n                raise Exception()\n        except:\n            return self.template_helper.get_renderer().lti_bind(False, \"\", None, \"Invalid LTI data\")\n\n        user_profile = self.database.users.find_one({\"ltibindings.\" + data[\"task\"][0] + \".\" + data[\"consumer_key\"]: data[\"username\"]})\n        if user_profile:\n            self.user_manager.connect_user(user_profile[\"username\"], user_profile[\"realname\"], user_profile[\"email\"], user_profile[\"language\"])\n\n        if self.user_manager.session_logged_in():\n            raise web.seeother(self.app.get_homepath() + \"/lti/task\")\n\n        return self.template_helper.get_renderer().lti_login(False)", "response": "Checks if user is authenticated and performs login and returns the login template. Otherwise returns the login template."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_lti_data(self, courseid, taskid):\n        post_input = web.webapi.rawinput(\"POST\")\n        self.logger.debug('_parse_lti_data:' + str(post_input))\n\n        try:\n            course = self.course_factory.get_course(courseid)\n        except exceptions.CourseNotFoundException as ex:\n            raise web.notfound(str(ex))\n\n        try:\n            test = LTIWebPyToolProvider.from_webpy_request()\n            validator = LTIValidator(self.database.nonce, course.lti_keys())\n            verified = test.is_valid_request(validator)\n        except Exception:\n            self.logger.exception(\"...\")\n            self.logger.info(\"Error while validating LTI request for %s\", str(post_input))\n            raise web.forbidden(_(\"Error while validating LTI request\"))\n\n        if verified:\n            self.logger.debug('parse_lit_data for %s', str(post_input))\n            user_id = post_input[\"user_id\"]\n            roles = post_input.get(\"roles\", \"Student\").split(\",\")\n            realname = self._find_realname(post_input)\n            email = post_input.get(\"lis_person_contact_email_primary\", \"\")\n            lis_outcome_service_url = post_input.get(\"lis_outcome_service_url\", None)\n            outcome_result_id = post_input.get(\"lis_result_sourcedid\", None)\n            consumer_key = post_input[\"oauth_consumer_key\"]\n\n            if course.lti_send_back_grade():\n                if lis_outcome_service_url is None or outcome_result_id is None:\n                    self.logger.info('Error: lis_outcome_service_url is None but lti_send_back_grade is True')\n                    raise web.forbidden(_(\"In order to send grade back to the TC, INGInious needs the parameters lis_outcome_service_url and \"\n                                        \"lis_outcome_result_id in the LTI basic-launch-request. Please contact your administrator.\"))\n            else:\n                lis_outcome_service_url = None\n                outcome_result_id = None\n\n            tool_name = post_input.get('tool_consumer_instance_name', 'N/A')\n            tool_desc = post_input.get('tool_consumer_instance_description', 'N/A')\n            tool_url = post_input.get('tool_consumer_instance_url', 'N/A')\n            context_title = post_input.get('context_title', 'N/A')\n            context_label = post_input.get('context_label', 'N/A')\n\n            session_id = self.user_manager.create_lti_session(user_id, roles, realname, email, courseid, taskid, consumer_key,\n                                                              lis_outcome_service_url, outcome_result_id, tool_name, tool_desc, tool_url,\n                                                              context_title, context_label)\n            loggedin = self.user_manager.attempt_lti_login()\n\n            return session_id, loggedin\n        else:\n            self.logger.info(\"Couldn't validate LTI request\")\n            raise web.forbidden(_(\"Couldn't validate LTI request\"))", "response": "Verify and parse the LTI basic launch data for the current course and task."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the most appropriate name to identify the user.", "response": "def _find_realname(self, post_input):\n        \"\"\" Returns the most appropriate name to identify the user \"\"\"\n\n        # First, try the full name\n        if \"lis_person_name_full\" in post_input:\n            return post_input[\"lis_person_name_full\"]\n        if \"lis_person_name_given\" in post_input and \"lis_person_name_family\" in post_input:\n            return post_input[\"lis_person_name_given\"] + post_input[\"lis_person_name_family\"]\n\n        # Then the email\n        if \"lis_person_contact_email_primary\" in post_input:\n            return post_input[\"lis_person_contact_email_primary\"]\n\n        # Then only part of the full name\n        if \"lis_person_name_family\" in post_input:\n            return post_input[\"lis_person_name_family\"]\n        if \"lis_person_name_given\" in post_input:\n            return post_input[\"lis_person_name_given\"]\n\n        return post_input[\"user_id\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef GET_AUTH(self):  # pylint: disable=arguments-differ\n        auth_methods = self.user_manager.get_auth_methods()\n        user_data = self.database.users.find_one({\"username\": self.user_manager.session_username()})\n        bindings = user_data.get(\"bindings\", {})\n        return self.template_helper.get_renderer().preferences.bindings(bindings, auth_methods, \"\", False)", "response": "GET request handler for GET_AUTH"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef POST_AUTH(self):  # pylint: disable=arguments-differ\n        msg = \"\"\n        error = False\n\n        user_data = self.database.users.find_one({\"username\": self.user_manager.session_username()})\n\n        if not user_data:\n            raise web.notfound()\n\n        user_input = web.input()\n        auth_methods = self.user_manager.get_auth_methods()\n\n        if \"auth_binding\" in user_input:\n            auth_binding = user_input[\"auth_binding\"]\n\n            if auth_binding not in auth_methods.keys():\n                error = True\n                msg = _(\"Incorrect authentication binding.\")\n            elif auth_binding not in user_data.get(\"bindings\", {}):\n                raise web.seeother(\"/auth/signin/\" + auth_binding)\n        elif \"revoke_auth_binding\" in user_input:\n            auth_id = user_input[\"revoke_auth_binding\"]\n\n            if auth_id not in auth_methods.keys():\n                error = True\n                msg = _(\"Incorrect authentication binding.\")\n            elif len(user_data.get(\"bindings\", {}).keys()) > 1 or \"password\" in user_data:\n                user_data = self.database.users.find_one_and_update({\"username\": self.user_manager.session_username()},\n                                                        {\"$unset\": {\"bindings.\" + auth_id: 1}})\n            else:\n                error = True\n                msg = _(\"You must set a password before removing all bindings.\")\n\n        bindings = user_data.get(\"bindings\", {})\n\n        return self.template_helper.get_renderer().preferences.bindings(bindings, auth_methods, msg, error)", "response": "Handles POST request for the user authentication."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes statistics about submissions and tags.", "response": "def compute_statistics(tasks, data, ponderation):\n    \"\"\" \n    Compute statistics about submissions and tags.\n    This function returns a tuple of lists following the format describe below:\n    (   \n        [('Number of submissions', 13), ('Evaluation submissions', 2), \u2026], \n        [(<tag>, '61%', '50%'), (<tag>, '76%', '100%'), \u2026]\n    )\n     \"\"\"\n    \n    super_dict = {}\n    for submission in data:\n        task = tasks[submission[\"taskid\"]]\n        username = \"\".join(submission[\"username\"])\n        tags_of_task = task.get_tags()[0] + task.get_tags()[1]\n        for tag in tags_of_task:\n            super_dict.setdefault(tag, {})\n            super_dict[tag].setdefault(username, {})\n            super_dict[tag][username].setdefault(submission[\"taskid\"], [0,0,0,0])\n            super_dict[tag][username][submission[\"taskid\"]][0] += 1\n            if \"tests\" in submission and tag.get_id() in submission[\"tests\"] and submission[\"tests\"][tag.get_id()]:\n                super_dict[tag][username][submission[\"taskid\"]][1] += 1\n\n            if submission[\"best\"]:\n                super_dict[tag][username][submission[\"taskid\"]][2] += 1\n                if \"tests\" in submission and tag.get_id() in submission[\"tests\"] and submission[\"tests\"][tag.get_id()]:\n                    super_dict[tag][username][submission[\"taskid\"]][3] += 1\n\n    output = []\n    for tag in super_dict:\n\n        if not ponderation: \n            results = [0,0,0,0]\n            for username in super_dict[tag]:\n                for task in super_dict[tag][username]:\n                    for i in range (0,4):\n                        results[i] += super_dict[tag][username][task][i] \n            output.append((tag, 100*safe_div(results[1],results[0]), 100*safe_div(results[3],results[2])))\n\n\n        #Ponderation by stud and tasks\n        else:\n            results = ([], [])\n            for username in super_dict[tag]:\n                for task in super_dict[tag][username]:\n                    a = super_dict[tag][username][task]\n                    results[0].append(safe_div(a[1],a[0]))\n                    results[1].append(safe_div(a[3],a[2]))\n            output.append((tag, 100*safe_div(sum(results[0]),len(results[0])), 100*safe_div(sum(results[1]),len(results[1]))))\n\n    return (fast_stats(data), output)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute statistics about submissions", "response": "def fast_stats(data):\n    \"\"\" Compute base statistics about submissions \"\"\"\n    \n    total_submission = len(data)\n    total_submission_best = 0\n    total_submission_best_succeeded = 0\n        \n    for submission in data:\n        if \"best\" in submission and submission[\"best\"]:\n            total_submission_best = total_submission_best + 1\n            if \"result\" in submission and submission[\"result\"] == \"success\":\n                total_submission_best_succeeded += 1\n        \n    statistics = [\n        (_(\"Number of submissions\"), total_submission),\n        (_(\"Evaluation submissions (Total)\"), total_submission_best),\n        (_(\"Evaluation submissions (Succeeded)\"), total_submission_best_succeeded),\n        (_(\"Evaluation submissions (Failed)\"), total_submission_best - total_submission_best_succeeded),\n        # add here new common statistics\n        ]\n    \n    return statistics"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef GET_AUTH(self, courseid, f=None, t=None):  # pylint: disable=arguments-differ\n        course, __ = self.get_course_and_check_rights(courseid)\n        tasks = course.get_tasks()\n        now = datetime.now().replace(minute=0, second=0, microsecond=0)\n\n        error = None\n        if f == None and t == None:\n            daterange = [now - timedelta(days=14), now]\n        else:\n            try:\n                daterange = [datetime.strptime(x[0:16], \"%Y-%m-%dT%H:%M\") for x in (f,t)]\n            except:\n                error = \"Invalid dates\"\n                daterange = [now - timedelta(days=14), now]\n\n        stats_tasks = self._tasks_stats(courseid, tasks, daterange)\n        stats_users = self._users_stats(courseid, daterange)\n        stats_graph = self._graph_stats(courseid, daterange)\n\n        return self.template_helper.get_renderer().course_admin.stats(course, stats_graph, stats_tasks, stats_users, daterange, error)", "response": "Get the authorisation statistics for a course."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _register_transaction(self, send_msg, recv_msg, coroutine_recv, coroutine_abrt, get_key=None, inter_msg=None):\n        if get_key is None:\n            get_key = lambda x: None\n        if inter_msg is None:\n            inter_msg = []\n\n        # format is (other_msg, get_key, recv_handler, abrt_handler,responsible_for)\n        # where responsible_for is the list of classes whose transaction will be killed when this message is received.\n        self._msgs_registered[send_msg.__msgtype__] = ([recv_msg.__msgtype__] + [x.__msgtype__ for x, _ in inter_msg], get_key, None, None, [])\n        self._msgs_registered[recv_msg.__msgtype__] = (\n        [], get_key, coroutine_recv, coroutine_abrt, [recv_msg.__msgtype__] + [x.__msgtype__ for x, _ in inter_msg])\n\n        self._transactions[recv_msg.__msgtype__] = {}\n        for msg_class, handler in inter_msg:\n            self._msgs_registered[msg_class.__msgtype__] = ([], get_key, handler, None, [])\n            self._transactions[msg_class.__msgtype__] = {}", "response": "Register a type of message to be sent and receive."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def _create_transaction(self, msg, *args, **kwargs):\n        recv_msgs, get_key, _1, _2, _3 = self._msgs_registered[msg.__msgtype__]\n        key = get_key(msg)\n\n        if key in self._transactions[recv_msgs[0]]:\n            # If we already have a request for this particular key, just add it on the list of things to call\n            for recv_msg in recv_msgs:\n                self._transactions[recv_msg][key].append((args, kwargs))\n        else:\n            # If that's not the case, add us in the queue, and send the message\n            for recv_msg in recv_msgs:\n                self._transactions[recv_msg][key] = [(args, kwargs)]\n            await ZMQUtils.send(self._socket, msg)", "response": "Create a transaction with the distant server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntasks that ensures Pings are sent periodically to the distant server.", "response": "async def _do_ping(self):\n        \"\"\"\n        Task that ensures Pings are sent periodically to the distant server\n        :return:\n        \"\"\"\n        try:\n            while True:\n                await asyncio.sleep(1)\n                if self._ping_count > 10:\n                    await self._reconnect()\n                else:\n                    self._ping_count += 1\n                    await ZMQUtils.send(self._socket, Ping())\n        except asyncio.CancelledError:\n            return\n        except KeyboardInterrupt:\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling when the remote server is innacessible and the connection has to be restarted.", "response": "async def _reconnect(self):\n        \"\"\"\n        Called when the remote server is innacessible and the connection has to be restarted\n        \"\"\"\n\n        # 1. Close all transactions\n        for msg_class in self._transactions:\n            _1, _2, _3, coroutine_abrt, _4 = self._msgs_registered[msg_class]\n            if coroutine_abrt is not None:\n                for key in self._transactions[msg_class]:\n                    for args, kwargs in self._transactions[msg_class][key]:\n                        self._loop.create_task(coroutine_abrt(key, *args, **kwargs))\n            self._transactions[msg_class] = {}\n\n        # 2. Call on_disconnect\n        await self._on_disconnect()\n\n        # 3. Stop tasks\n        for task in self._restartable_tasks:\n            task.cancel()\n        self._restartable_tasks = []\n\n        # 4. Restart socket\n        self._socket.disconnect(self._router_addr)\n\n        # 5. Re-do start sequence\n        await self.client_start()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def _run_socket(self):\n        try:\n            while True:\n                message = await ZMQUtils.recv(self._socket)\n                msg_class = message.__msgtype__\n                if msg_class in self._handlers_registered:\n                    # If a handler is registered, give the message to it\n                    self._loop.create_task(self._handlers_registered[msg_class](message))\n                elif msg_class in self._transactions:\n                    # If there are transaction associated, check if the key is ok\n                    _1, get_key, coroutine_recv, _2, responsible = self._msgs_registered[msg_class]\n                    key = get_key(message)\n                    if key in self._transactions[msg_class]:\n                        # key exists; call all the coroutines\n                        for args, kwargs in self._transactions[msg_class][key]:\n                            self._loop.create_task(coroutine_recv(message, *args, **kwargs))\n                        # remove all transaction parts\n                        for key2 in responsible:\n                            del self._transactions[key2][key]\n                    else:\n                        # key does not exist\n                        raise Exception(\"Received message %s for an unknown transaction %s\", msg_class, key)\n                else:\n                    raise Exception(\"Received unknown message %s\", msg_class)\n        except asyncio.CancelledError:\n            return\n        except KeyboardInterrupt:\n            return", "response": "This method runs the socket and returns the current thread s ID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef GET_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        course, _ = self.get_course_and_check_rights(courseid)\n        return self.page(course)", "response": "GET request handler for GET_AUTH"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef page(self, course):\n        if not self.webdav_host:\n            raise web.notfound()\n\n        url = self.webdav_host + \"/\" + course.get_id()\n        username = self.user_manager.session_username()\n        apikey = self.user_manager.session_api_key()\n        return self.template_helper.get_renderer().course_admin.webdav(course, url, username, apikey)", "response": "Get all data and display the page"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload the current feedback file", "response": "def load_feedback():\n    \"\"\" Open existing feedback file \"\"\"\n    result = {}\n    if os.path.exists(_feedback_file):\n        f = open(_feedback_file, 'r')\n        cont = f.read()\n        f.close()\n    else:\n        cont = '{}'\n\n    try:\n        result = json.loads(cont) if cont else {}\n    except ValueError as e:\n        result = {\"result\":\"crash\", \"text\":\"Feedback file has been modified by user !\"}\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving the feedback file", "response": "def save_feedback(rdict):\n    \"\"\" Save feedback file \"\"\"\n    # Check for output folder\n    if not os.path.exists(_feedback_dir):\n        os.makedirs(_feedback_dir)\n    \n    jcont = json.dumps(rdict)\n    f = open(_feedback_file, 'w')\n    f.write(jcont)\n    f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting problem specific result value", "response": "def set_problem_result(result, problem_id):\n    \"\"\" Set problem specific result value \"\"\"\n    rdict = load_feedback()\n    if not 'problems' in rdict:\n        rdict['problems'] = {}\n    cur_val = rdict['problems'].get(problem_id, '')\n    rdict['problems'][problem_id] = [result, cur_val] if type(cur_val) == str else [result, cur_val[1]]\n    save_feedback(rdict)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_global_feedback(feedback, append=False):\n    rdict = load_feedback()\n    rdict['text'] = rdict.get('text', '') + feedback if append else feedback\n    save_feedback(rdict)", "response": "Set global feedback in case of error"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_problem_feedback(feedback, problem_id, append=False):\n    rdict = load_feedback()\n    if not 'problems' in rdict:\n        rdict['problems'] = {}\n    cur_val = rdict['problems'].get(problem_id, '')\n    rdict['problems'][problem_id] = (cur_val + feedback if append else feedback) if type(cur_val) == str else [cur_val[0], (cur_val[1] + feedback if append else feedback)]\n    save_feedback(rdict)", "response": "Set problem specific feedback"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the tag to the value True or False.", "response": "def set_tag(tag, value):\n    \"\"\" \n    Set the tag 'tag' to the value True or False. \n    :param value: should be a boolean \n    :param tag: should be the id of the tag. Can not starts with '*auto-tag-'\n    \"\"\" \n    if not tag.startswith(\"*auto-tag-\"):\n        rdict = load_feedback()\n        tests = rdict.setdefault(\"tests\", {})\n        tests[tag] = (value == True)\n        save_feedback(rdict)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a tag with generated id.", "response": "def tag(value):\n    \"\"\"\n    Add a tag with generated id.\n    :param value: everything working with the str() function\n    \"\"\"\n    rdict = load_feedback()\n    tests = rdict.setdefault(\"tests\", {})\n    tests[\"*auto-tag-\" + str(hash(str(value)))] = str(value)\n    save_feedback(rdict)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset a custom value to be given back in the feedback", "response": "def set_custom_value(custom_name, custom_val):\n    \"\"\"\n    Set a custom value to be given back in the feedback\n    :param custom_name: name/key of the entry to be placed in the custom dict\n    :param custom_val: content of the entry to be placed in the custom dict\n    \"\"\"\n    rdict = load_feedback()\n    if not \"custom\" in rdict:\n        rdict[\"custom\"] = {}\n    rdict[\"custom\"][custom_name] = custom_val\n    save_feedback(rdict)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_feedback_from_tpl(tpl_name, parameters, problem_id=None, append=False):\n    inginious.lang.init()\n    lang = get_lang()\n\n    tpl_location = None\n    possible_locations = [\".\".join([tpl_name, lang, \"tpl\"]),\n                          os.path.join(inginious.lang.get_lang_dir_path(), lang, tpl_name) + \".tpl\",\n                          \".\".join([tpl_name, \"tpl\"])]\n    for path in possible_locations:\n        if os.path.exists(path):\n            tpl_location = path\n            break\n\n    if tpl_location is None:\n        output = \"\"\"\n.. error::\n\n    Unable to find template named %s. Please contact your administrator.\n    \n\n    \"\"\" % tpl_name\n\n        if problem_id is None:\n            set_global_feedback(output, append)\n        else:\n            set_problem_feedback(output, problem_id, append)\n        return False\n\n    try:\n        template = Template(open(tpl_location, 'r').read())\n        parameters.update({\"_\": _})\n        output = template.render(parameters)\n        valid = True\n    except Exception:\n        output = \"\"\"\n.. error::\n   \n   An error occured while parsing the feedback template. Here is the full error:\n   \n   ::\n   \n\"\"\"\n        output += \"\\n\".join([\"\\t\\t\"+line for line in traceback.format_exc().split(\"\\n\")])\n        output += \"\\n\\tPlease contact your administrator.\\n\"\n        valid = False\n\n    if problem_id is None:\n        set_global_feedback(output, append)\n    else:\n        set_problem_feedback(output, problem_id, append)\n\n    return valid", "response": "Parse a template file and set it as feedback message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisplaying a BIG warning", "response": "def _display_big_warning(self, content):\n        \"\"\" Displays a BIG warning \"\"\"\n        print(\"\")\n        print(BOLD + WARNING + \"--- WARNING ---\" + ENDC)\n        print(WARNING + content + ENDC)\n        print(\"\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _ask_local_config(self):\n        options = {\"backend\": \"local\", \"local-config\": {}}\n\n        # Concurrency\n        while True:\n            concurrency = self._ask_with_default(\n                \"Maximum concurrency (number of tasks running simultaneously). Leave it empty to use the number of \"\n                \"CPU of your host.\", \"\")\n            if concurrency == \"\":\n                break\n\n            try:\n                concurrency = int(concurrency)\n            except:\n                self._display_error(\"Invalid number\")\n                continue\n\n            if concurrency <= 0:\n                self._display_error(\"Invalid number\")\n                continue\n\n            options[\"local-config\"][\"concurrency\"] = concurrency\n            break\n\n        # Debug hostname\n        hostname = self._ask_with_default(\n            \"What is the external hostname/address of your machine? You can leave this empty and let INGInious \"\n            \"autodetect it.\", \"\")\n        if hostname != \"\":\n            options[\"local-config\"][\"debug_host\"] = hostname\n        self._display_info(\n            \"You can now enter the port range for the remote debugging feature of INGInious. Please verify that these \"\n            \"ports are open in your firewall. You can leave this parameters empty, the default is 64100-64200\")\n\n        # Debug port range\n        port_range = None\n        while True:\n            start_port = self._ask_with_default(\"Beginning of the range\", \"\")\n            if start_port != \"\":\n                try:\n                    start_port = int(start_port)\n                except:\n                    self._display_error(\"Invalid number\")\n                    continue\n                end_port = self._ask_with_default(\"End of the range\", str(start_port + 100))\n                try:\n                    end_port = int(end_port)\n                except:\n                    self._display_error(\"Invalid number\")\n                    continue\n                if start_port > end_port:\n                    self._display_error(\"Invalid range\")\n                    continue\n                port_range = str(start_port) + \"-\" + str(end_port)\n            else:\n                break\n        if port_range != None:\n            options[\"local-config\"][\"debug_ports\"] = port_range\n\n        return options", "response": "Ask some parameters about the local configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nasks the user to choose the backend", "response": "def ask_backend(self):\n        \"\"\" Ask the user to choose the backend \"\"\"\n        response = self._ask_boolean(\n            \"Do you have a local docker daemon (on Linux), do you use docker-machine via a local machine, or do you use \"\n            \"Docker for macOS?\", True)\n        if (response):\n            self._display_info(\"If you use docker-machine on macOS, please see \"\n                               \"http://inginious.readthedocs.io/en/latest/install_doc/troubleshooting.html\")\n            return \"local\"\n        else:\n            self._display_info(\n                \"You will have to run inginious-backend and inginious-agent yourself. Please run the commands without argument \"\n                \"and/or read the documentation for more info\")\n            return self._display_question(\"Please enter the address of your backend\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure_mongodb(self):\n        self._display_info(\"Trying default configuration\")\n\n        host = \"localhost\"\n        database_name = \"INGInious\"\n\n        should_ask = True\n        if self.try_mongodb_opts(host, database_name):\n            should_ask = self._ask_boolean(\n                \"Successfully connected to MongoDB. Do you want to edit the configuration anyway?\", False)\n        else:\n            self._display_info(\"Cannot guess configuration for MongoDB.\")\n\n        while should_ask:\n            self._display_question(\n                \"Please enter the MongoDB host. If you need to enter a password, here is the syntax:\")\n            self._display_question(\"mongodb://USERNAME:PASSWORD@HOST:PORT/AUTHENTIFICATION_DATABASE\")\n            host = self._ask_with_default(\"MongoDB host\", host)\n            database_name = self._ask_with_default(\"Database name\", database_name)\n            if not self.try_mongodb_opts(host, database_name):\n                if self._ask_boolean(\"Cannot connect to MongoDB. Would you like to continue anyway?\", False):\n                    break\n            else:\n                self._display_info(\"Successfully connected to MongoDB\")\n                break\n\n        return {\"mongo_opt\": {\"host\": host, \"database\": database_name}}", "response": "Configure the MongoDB connection"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef configure_task_directory(self):\n        self._display_question(\n            \"Please choose a directory in which to store the course/task files. By default, the tool will put them in the current \"\n            \"directory\")\n        task_directory = None\n        while task_directory is None:\n            task_directory = self._ask_with_default(\"Task directory\", \".\")\n            if not os.path.exists(task_directory):\n                self._display_error(\"Path does not exists\")\n                if self._ask_boolean(\"Would you like to retry?\", True):\n                    task_directory = None\n\n        if os.path.exists(task_directory):\n            self._display_question(\"Demonstration tasks can be downloaded to let you discover INGInious.\")\n            if self._ask_boolean(\"Would you like to download them ?\", True):\n                try:\n                    filename, _ = urllib.request.urlretrieve(\n                        \"https://api.github.com/repos/UCL-INGI/INGInious-demo-tasks/tarball\")\n                    with tarfile.open(filename, mode=\"r:gz\") as thetarfile:\n                        members = thetarfile.getmembers()\n                        commonpath = os.path.commonpath([tarinfo.name for tarinfo in members])\n\n                        for member in members:\n                            member.name = member.name[len(commonpath) + 1:]\n                            if member.name:\n                                thetarfile.extract(member, task_directory)\n\n                    self._display_info(\"Successfully downloaded and copied demonstration tasks.\")\n                except Exception as e:\n                    self._display_error(\"An error occurred while copying the directory: %s\" % str(e))\n        else:\n            self._display_warning(\"Skipping copying the 'test' course because the task dir does not exists\")\n\n        return {\"tasks_directory\": task_directory}", "response": "Configure the task directory"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef download_containers(self, to_download, current_options):\n        if current_options[\"backend\"] == \"local\":\n            self._display_info(\"Connecting to the local Docker daemon...\")\n            try:\n                docker_connection = docker.from_env()\n            except:\n                self._display_error(\"Cannot connect to local Docker daemon. Skipping download.\")\n                return\n\n            for image in to_download:\n                try:\n                    self._display_info(\"Downloading image %s. This can take some time.\" % image)\n                    docker_connection.images.pull(image + \":latest\")\n                except Exception as e:\n                    self._display_error(\"An error occurred while pulling the image: %s.\" % str(e))\n        else:\n            self._display_warning(\n                \"This installation tool does not support the backend configuration directly, if it's not local. You will have to \"\n                \"pull the images by yourself. Here is the list: %s\" % str(to_download))", "response": "Download the chosen containers on all the agents"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure_containers(self, current_options):\n        containers = [\n            (\"default\", \"Default container. For Bash and Python 2 tasks\"),\n            (\"cpp\", \"Contains gcc and g++ for compiling C++\"),\n            (\"java7\", \"Contains Java 7\"),\n            (\"java8scala\", \"Contains Java 8 and Scala\"),\n            (\"mono\", \"Contains Mono, which allows to run C#, F# and many other languages\"),\n            (\"oz\", \"Contains Mozart 2, an implementation of the Oz multi-paradigm language, made for education\"),\n            (\"php\", \"Contains PHP 5\"),\n            (\"pythia0compat\", \"Compatibility container for Pythia 0\"),\n            (\"pythia1compat\", \"Compatibility container for Pythia 1\"),\n            (\"r\", \"Can run R scripts\"),\n            (\"sekexe\", \"Can run an user-mode-linux for advanced tasks\")\n        ]\n\n        default_download = [\"default\"]\n\n        self._display_question(\n            \"The tool will now propose to download some base container image for multiple languages.\")\n        self._display_question(\n            \"Please note that the download of these images can take a lot of time, so choose only the images you need\")\n\n        to_download = []\n        for container_name, description in containers:\n            if self._ask_boolean(\"Download %s (%s) ?\" % (container_name, description),\n                                 container_name in default_download):\n                to_download.append(\"ingi/inginious-c-%s\" % container_name)\n\n        self.download_containers(to_download, current_options)\n\n        wants = self._ask_boolean(\"Do you want to manually add some images?\", False)\n        while wants:\n            image = self._ask_with_default(\"Container image name (leave this field empty to skip)\", \"\")\n            if image == \"\":\n                break\n\n        self._display_info(\"Configuration of the containers done.\")", "response": "Configure the containers for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ldap_plugin(self):\n        name = self._ask_with_default(\"Authentication method name (will be displayed on the login page)\", \"LDAP\")\n        prefix = self._ask_with_default(\"Prefix to append to the username before db storage. Usefull when you have more than one auth method with \"\n                                        \"common usernames.\", \"\")\n        ldap_host = self._ask_with_default(\"LDAP Host\", \"ldap.your.domain.com\")\n\n        encryption = 'none'\n        while True:\n            encryption = self._ask_with_default(\"Encryption (either 'ssl', 'tls', or 'none')\", 'none')\n            if encryption not in ['none', 'ssl', 'tls']:\n                self._display_error(\"Invalid value\")\n            else:\n                break\n\n        base_dn = self._ask_with_default(\"Base DN\", \"ou=people,c=com\")\n        request = self._ask_with_default(\"Request to find a user. '{}' will be replaced by the username\", \"uid={}\")\n        require_cert = self._ask_boolean(\"Require certificate validation?\", encryption is not None)\n\n        return {\n            \"plugin_module\": \"inginious.frontend.plugins.auth.ldap_auth\",\n            \"host\": ldap_host,\n            \"encryption\": encryption,\n            \"base_dn\": base_dn,\n            \"request\": request,\n            \"prefix\": prefix,\n            \"name\": name,\n            \"require_cert\": require_cert\n        }", "response": "Configures the LDAP plugin"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _close_app(app, mongo_client, client):\n    app.stop()\n    client.close()\n    mongo_client.close()", "response": "Closes the app and client."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_app(config):\n    # First, disable debug. It will be enabled in the configuration, later.\n    web.config.debug = False\n\n    config = _put_configuration_defaults(config)\n\n    mongo_client = MongoClient(host=config.get('mongo_opt', {}).get('host', 'localhost'))\n    database = mongo_client[config.get('mongo_opt', {}).get('database', 'INGInious')]\n    gridfs = GridFS(database)\n\n    # Init database if needed\n    db_version = database.db_version.find_one({})\n    if db_version is None:\n        database.submissions.ensure_index([(\"username\", pymongo.ASCENDING)])\n        database.submissions.ensure_index([(\"courseid\", pymongo.ASCENDING)])\n        database.submissions.ensure_index([(\"courseid\", pymongo.ASCENDING), (\"taskid\", pymongo.ASCENDING)])\n        database.submissions.ensure_index([(\"submitted_on\", pymongo.DESCENDING)])  # sort speed\n        database.user_tasks.ensure_index(\n            [(\"username\", pymongo.ASCENDING), (\"courseid\", pymongo.ASCENDING), (\"taskid\", pymongo.ASCENDING)],\n            unique=True)\n        database.user_tasks.ensure_index([(\"username\", pymongo.ASCENDING), (\"courseid\", pymongo.ASCENDING)])\n        database.user_tasks.ensure_index([(\"courseid\", pymongo.ASCENDING), (\"taskid\", pymongo.ASCENDING)])\n        database.user_tasks.ensure_index([(\"courseid\", pymongo.ASCENDING)])\n        database.user_tasks.ensure_index([(\"username\", pymongo.ASCENDING)])\n\n    appli = CookieLessCompatibleApplication(MongoStore(database, 'sessions'))\n\n    # Init gettext\n    available_languages = {\n        \"en\": \"English\",\n        \"fr\": \"Fran\u00e7ais\"\n    }\n\n    for lang in available_languages.keys():\n        appli.add_translation(lang, gettext.translation('messages', get_root_path() + '/frontend/i18n', [lang]))\n\n    builtins.__dict__['_'] = appli.gettext\n\n    if config.get(\"maintenance\", False):\n        template_helper = TemplateHelper(PluginManager(), None,\n                                         'frontend/templates',\n                                         'frontend/templates/layout',\n                                         'frontend/templates/layout_lti',\n                                         config.get('use_minified_js', True))\n        template_helper.add_to_template_globals(\"get_homepath\", appli.get_homepath)\n        template_helper.add_to_template_globals(\"_\", _)\n        appli.template_helper = template_helper\n        appli.init_mapping(urls_maintenance)\n        return appli.wsgifunc(), appli.stop\n\n    default_allowed_file_extensions = config['allowed_file_extensions']\n    default_max_file_size = config['max_file_size']\n\n    zmq_context, __ = start_asyncio_and_zmq(config.get('debug_asyncio', False))\n\n    # Init the different parts of the app\n    plugin_manager = PluginManager()\n\n    # Create the FS provider\n    if \"fs\" in config:\n        fs_provider = filesystem_from_config_dict(config[\"fs\"])\n    else:\n        task_directory = config[\"tasks_directory\"]\n        fs_provider = LocalFSProvider(task_directory)\n\n    default_problem_types = {\n        problem_type.get_type(): problem_type for problem_type in [DisplayableCodeProblem,\n                                                                   DisplayableCodeSingleLineProblem,\n                                                                   DisplayableFileProblem,\n                                                                   DisplayableMultipleChoiceProblem,\n                                                                   DisplayableMatchProblem]\n    }\n\n    course_factory, task_factory = create_factories(fs_provider, default_problem_types, plugin_manager, WebAppCourse, WebAppTask)\n\n    user_manager = UserManager(appli.get_session(), database, config.get('superadmins', []))\n\n    update_pending_jobs(database)\n\n    client = create_arch(config, fs_provider, zmq_context, course_factory)\n\n    lti_outcome_manager = LTIOutcomeManager(database, user_manager, course_factory)\n\n    submission_manager = WebAppSubmissionManager(client, user_manager, database, gridfs, plugin_manager, lti_outcome_manager)\n\n    template_helper = TemplateHelper(plugin_manager, user_manager, 'frontend/templates',\n                                     'frontend/templates/layout',\n                                     'frontend/templates/layout_lti',\n                                     config.get('use_minified_js', True))\n\n\n\n    # Init web mail\n    smtp_conf = config.get('smtp', None)\n    if smtp_conf is not None:\n        web.config.smtp_server = smtp_conf[\"host\"]\n        web.config.smtp_port = int(smtp_conf[\"port\"])\n        web.config.smtp_starttls = bool(smtp_conf.get(\"starttls\", False))\n        web.config.smtp_username = smtp_conf.get(\"username\", \"\")\n        web.config.smtp_password = smtp_conf.get(\"password\", \"\")\n        web.config.smtp_sendername = smtp_conf.get(\"sendername\", \"no-reply@ingnious.org\")\n\n    # Add some helpers for the templates\n    template_helper.add_to_template_globals(\"_\", _)\n    template_helper.add_to_template_globals(\"str\", str)\n    template_helper.add_to_template_globals(\"available_languages\", available_languages)\n    template_helper.add_to_template_globals(\"get_homepath\", appli.get_homepath)\n    template_helper.add_to_template_globals(\"allow_registration\", config.get(\"allow_registration\", True))\n    template_helper.add_to_template_globals(\"user_manager\", user_manager)\n    template_helper.add_to_template_globals(\"default_allowed_file_extensions\", default_allowed_file_extensions)\n    template_helper.add_to_template_globals(\"default_max_file_size\", default_max_file_size)\n    template_helper.add_other(\"course_admin_menu\",\n                              lambda course, current: course_admin_utils.get_menu(course, current, template_helper.get_renderer(False),\n                                                                                  plugin_manager, user_manager))\n    template_helper.add_other(\"preferences_menu\",\n                              lambda current: preferences_utils.get_menu(appli, current, template_helper.get_renderer(False),\n                                                                                 plugin_manager, user_manager))\n\n    # Not found page\n    appli.notfound = lambda: web.notfound(template_helper.get_renderer().notfound('Page not found'))\n\n    # Enable stacktrace display if needed\n    web_debug = config.get('web_debug', False)\n    appli.internalerror = internalerror_generator(template_helper.get_renderer(False))\n    if web_debug is True:\n        web.config.debug = True\n        appli.internalerror = debugerror\n    elif isinstance(web_debug, str):\n        web.config.debug = False\n        appli.internalerror = emailerrors(web_debug, appli.internalerror)\n\n    # Insert the needed singletons into the application, to allow pages to call them\n    appli.plugin_manager = plugin_manager\n    appli.course_factory = course_factory\n    appli.task_factory = task_factory\n    appli.submission_manager = submission_manager\n    appli.user_manager = user_manager\n    appli.template_helper = template_helper\n    appli.database = database\n    appli.gridfs = gridfs\n    appli.default_allowed_file_extensions = default_allowed_file_extensions\n    appli.default_max_file_size = default_max_file_size\n    appli.backup_dir = config.get(\"backup_directory\", './backup')\n    appli.webterm_link = config.get(\"webterm\", None)\n    appli.lti_outcome_manager = lti_outcome_manager\n    appli.allow_registration = config.get(\"allow_registration\", True)\n    appli.allow_deletion = config.get(\"allow_deletion\", True)\n    appli.available_languages = available_languages\n    appli.welcome_page = config.get(\"welcome_page\", None)\n    appli.static_directory = config.get(\"static_directory\", \"./static\")\n    appli.webdav_host = config.get(\"webdav_host\", None)\n\n    # Init the mapping of the app\n    appli.init_mapping(urls)\n\n    # Loads plugins\n    plugin_manager.load(client, appli, course_factory, task_factory, database, user_manager, submission_manager, config.get(\"plugins\", []))\n\n    # Start the inginious.backend\n    client.start()\n\n    return appli.wsgifunc(), lambda: _close_app(appli, mongo_client, client)", "response": "Returns a new app containing all the available languages and their content."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def _init_clean(self):\n        # Data about running containers\n        self._containers_running = {}\n        self._container_for_job = {}\n\n        self._student_containers_running = {}\n        self._student_containers_for_job = {}\n\n        self._containers_killed = dict()\n\n        # Delete tmp_dir, and recreate-it again\n        try:\n            await self._ashutil.rmtree(self._tmp_dir)\n        except OSError:\n            pass\n\n        try:\n            await self._aos.mkdir(self._tmp_dir)\n        except OSError:\n            pass\n\n        # Docker\n        self._docker = AsyncProxy(DockerInterface())\n\n        # Auto discover containers\n        self._logger.info(\"Discovering containers\")\n        self._containers = await self._docker.get_containers()\n\n        self._assigned_external_ports = {}  # container_id : [external_ports]\n\n        if self._address_host is None and len(self._containers) != 0:\n            self._logger.info(\"Guessing external host IP\")\n            self._address_host = await self._docker.get_host_ip(next(iter(self._containers.values()))[\"id\"])\n        if self._address_host is None:\n            self._logger.warning(\n                \"Cannot find external host IP. Please indicate it in the configuration. Remote SSH debug has been deactivated.\")\n            self._external_ports = None\n        else:\n            self._logger.info(\"External address for SSH remote debug is %s\", self._address_host)\n\n        # Watchers\n        self._timeout_watcher = TimeoutWatcher(self._docker)", "response": "Initialize internal state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def _end_clean(self):\n        await self._timeout_watcher.clean()\n\n        async def close_and_delete(container_id):\n            try:\n                await self._docker.remove_container(container_id)\n            except:\n                pass\n\n        for container_id  in self._containers_running:\n            await close_and_delete(container_id)\n        for container_id  in self._student_containers_running:\n            await close_and_delete(container_id)", "response": "Closes the container and all its children."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def _watch_docker_events(self):\n        try:\n            source = AsyncIteratorWrapper(self._docker.sync.event_stream(filters={\"event\": [\"die\", \"oom\"]}))\n            async for i in source:\n                if i[\"Type\"] == \"container\" and i[\"status\"] == \"die\":\n                    container_id = i[\"id\"]\n                    try:\n                        retval = int(i[\"Actor\"][\"Attributes\"][\"exitCode\"])\n                    except asyncio.CancelledError:\n                        raise\n                    except:\n                        self._logger.exception(\"Cannot parse exitCode for container %s\", container_id)\n                        retval = -1\n\n                    if container_id in self._containers_running:\n                        self._create_safe_task(self.handle_job_closing(container_id, retval))\n                    elif container_id in self._student_containers_running:\n                        self._create_safe_task(self.handle_student_job_closing(container_id, retval))\n                elif i[\"Type\"] == \"container\" and i[\"status\"] == \"oom\":\n                    container_id = i[\"id\"]\n                    if container_id in self._containers_running or container_id in self._student_containers_running:\n                        self._logger.info(\"Container %s did OOM, killing it\", container_id)\n                        self._containers_killed[container_id] = \"overflow\"\n                        try:\n                            self._create_safe_task(self._docker.kill_container(container_id))\n                        except asyncio.CancelledError:\n                            raise\n                        except:  # this call can sometimes fail, and that is normal.\n                            pass\n                else:\n                    raise TypeError(str(i))\n        except asyncio.CancelledError:\n            pass\n        except:\n            self._logger.exception(\"Exception in _watch_docker_events\")", "response": "Get raw docker events and convert them to more readable objects and give them to self. _docker_events_subscriber"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def new_job(self, message: BackendNewJob):\n        self._logger.info(\"Received request for jobid %s\", message.job_id)\n        future_results = asyncio.Future()\n        out = await self._loop.run_in_executor(None, lambda: self.__new_job_sync(message, future_results))\n        self._create_safe_task(self.handle_running_container(**out, future_results=future_results))\n        await self._timeout_watcher.register_container(out[\"container_id\"], out[\"orig_time_limit\"], out[\"orig_hard_time_limit\"])", "response": "Handles a new job"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new student container.", "response": "async def create_student_container(self, job_id, parent_container_id, sockets_path, student_path, systemfiles_path,\n                                       course_common_student_path, socket_id,  environment_name, memory_limit,\n                                       time_limit, hard_time_limit, share_network, write_stream):\n        \"\"\"\n        Creates a new student container.\n        :param write_stream: stream on which to write the return value of the container (with a correctly formatted msgpack message)\n        \"\"\"\n        try:\n            self._logger.debug(\"Starting new student container... %s %s %s %s\", environment_name, memory_limit, time_limit, hard_time_limit)\n\n            if environment_name not in self._containers:\n                self._logger.warning(\"Student container asked for an unknown environment %s (not in aliases)\", environment_name)\n                await self._write_to_container_stdin(write_stream, {\"type\": \"run_student_retval\", \"retval\": 254, \"socket_id\": socket_id})\n                return\n\n            environment = self._containers[environment_name][\"id\"]\n\n            try:\n                socket_path = path_join(sockets_path, str(socket_id) + \".sock\")\n                container_id = await self._docker.create_container_student(parent_container_id, environment, share_network,\n                                                                           memory_limit, student_path, socket_path,\n                                                                           systemfiles_path, course_common_student_path)\n            except Exception as e:\n                self._logger.exception(\"Cannot create student container!\")\n                await self._write_to_container_stdin(write_stream, {\"type\": \"run_student_retval\", \"retval\": 254, \"socket_id\": socket_id})\n\n                if isinstance(e, asyncio.CancelledError):\n                    raise\n\n                return\n\n            self._student_containers_for_job[job_id].add(container_id)\n            self._student_containers_running[container_id] = job_id, parent_container_id, socket_id, write_stream\n\n            # send to the container that the sibling has started\n            await self._write_to_container_stdin(write_stream, {\"type\": \"run_student_started\", \"socket_id\": socket_id})\n\n            try:\n                await self._docker.start_container(container_id)\n            except Exception as e:\n                self._logger.exception(\"Cannot start student container!\")\n                await self._write_to_container_stdin(write_stream, {\"type\": \"run_student_retval\", \"retval\": 254, \"socket_id\": socket_id})\n\n                if isinstance(e, asyncio.CancelledError):\n                    raise\n\n                return\n\n            # Verify the time limit\n            await self._timeout_watcher.register_container(container_id, time_limit, hard_time_limit)\n        except asyncio.CancelledError:\n            raise\n        except:\n            self._logger.exception(\"Exception in create_student_container\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a message to the stdin of a container with the right data", "response": "async def _write_to_container_stdin(self, write_stream, message):\n        \"\"\"\n        Send a message to the stdin of a container, with the right data\n        :param write_stream: asyncio write stream to the stdin of the container\n        :param message: dict to be msgpacked and sent\n        \"\"\"\n        msg = msgpack.dumps(message, encoding=\"utf8\", use_bin_type=True)\n        self._logger.debug(\"Sending %i bytes to container\", len(msg))\n        write_stream.write(struct.pack('I', len(msg)))\n        write_stream.write(msg)\n        await write_stream.drain()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling a running container.", "response": "async def handle_running_container(self, job_id, container_id, inputdata, debug, ports, orig_env,\n                                       orig_memory_limit, orig_time_limit, orig_hard_time_limit, sockets_path,\n                                       student_path, systemfiles_path, course_common_student_path, future_results):\n        \"\"\" Talk with a container. Sends the initial input. Allows to start student containers \"\"\"\n        sock = await self._docker.attach_to_container(container_id)\n        try:\n            read_stream, write_stream = await asyncio.open_connection(sock=sock.get_socket())\n        except asyncio.CancelledError:\n            raise\n        except:\n            self._logger.exception(\"Exception occurred while creating read/write stream to container\")\n            return None\n\n        # Send hello msg\n        await self._write_to_container_stdin(write_stream, {\"type\": \"start\", \"input\": inputdata, \"debug\": debug})\n        result = None\n\n        buffer = bytearray()\n        try:\n            while not read_stream.at_eof():\n                msg_header = await read_stream.readexactly(8)\n                outtype, length = struct.unpack_from('>BxxxL', msg_header)  # format imposed by docker in the attach endpoint\n                if length != 0:\n                    content = await read_stream.readexactly(length)\n                    if outtype == 1:  # stdout\n                        buffer += content\n\n                    if outtype == 2:  # stderr\n                        self._logger.debug(\"Received stderr from containers:\\n%s\", content)\n\n                    # 4 first bytes are the lenght of the message. If we have a complete message...\n                    while len(buffer) > 4 and len(buffer) >= 4+struct.unpack('I',buffer[0:4])[0]:\n                        msg_encoded = buffer[4:4 + struct.unpack('I', buffer[0:4])[0]]  # ... get it\n                        buffer = buffer[4 + struct.unpack('I', buffer[0:4])[0]:]  # ... withdraw it from the buffer\n                        try:\n                            msg = msgpack.unpackb(msg_encoded, encoding=\"utf8\", use_list=False)\n                            self._logger.debug(\"Received msg %s from container %s\", msg[\"type\"], container_id)\n                            if msg[\"type\"] == \"run_student\":\n                                # start a new student container\n                                environment = msg[\"environment\"] or orig_env\n                                memory_limit = min(msg[\"memory_limit\"] or orig_memory_limit, orig_memory_limit)\n                                time_limit = min(msg[\"time_limit\"] or orig_time_limit, orig_time_limit)\n                                hard_time_limit = min(msg[\"hard_time_limit\"] or orig_hard_time_limit, orig_hard_time_limit)\n                                share_network = msg[\"share_network\"]\n                                socket_id = msg[\"socket_id\"]\n                                assert \"/\" not in socket_id  # ensure task creator do not try to break the agent :-(\n                                self._create_safe_task(self.create_student_container(job_id, container_id, sockets_path, student_path,\n                                                                                     systemfiles_path, course_common_student_path,\n                                                                                     socket_id,  environment, memory_limit, time_limit,\n                                                                                     hard_time_limit, share_network, write_stream))\n                            elif msg[\"type\"] == \"ssh_key\":\n                                # send the data to the backend (and client)\n                                self._logger.info(\"%s %s\", container_id, str(msg))\n                                await self.send_ssh_job_info(job_id, self._address_host, ports[22], msg[\"ssh_key\"])\n                            elif msg[\"type\"] == \"result\":\n                                # last message containing the results of the container\n                                result = msg[\"result\"]\n                        except:\n                            self._logger.exception(\"Received incorrect message from container %s (job id %s)\", container_id, job_id)\n        except asyncio.IncompleteReadError:\n            self._logger.debug(\"Container output ended with an IncompleteReadError; It was probably killed.\")\n        except asyncio.CancelledError:\n            write_stream.close()\n            sock.close_socket()\n            future_results.set_result(result)\n            raise\n        except:\n            self._logger.exception(\"Exception while reading container %s output\", container_id)\n\n        write_stream.close()\n        sock.close_socket()\n        future_results.set_result(result)\n\n        if not result:\n            self._logger.warning(\"Container %s has not given any result\", container_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def handle_student_job_closing(self, container_id, retval):\n        try:\n            self._logger.debug(\"Closing student %s\", container_id)\n            try:\n                job_id, parent_container_id, socket_id, write_stream = self._student_containers_running[container_id]\n                del self._student_containers_running[container_id]\n            except asyncio.CancelledError:\n                raise\n            except:\n                self._logger.warning(\"Student container %s that has finished(p1) was not launched by this agent\", str(container_id), exc_info=True)\n                return\n\n            # Delete remaining student containers\n            if job_id in self._student_containers_for_job:  # if it does not exists, then the parent container has closed\n                self._student_containers_for_job[job_id].remove(container_id)\n\n            killed = await self._timeout_watcher.was_killed(container_id)\n            if container_id in self._containers_killed:\n                killed = self._containers_killed[container_id]\n                del self._containers_killed[container_id]\n\n            if killed == \"timeout\":\n                retval = 253\n            elif killed == \"overflow\":\n                retval = 252\n\n            try:\n                await self._write_to_container_stdin(write_stream, {\"type\": \"run_student_retval\", \"retval\": retval, \"socket_id\": socket_id})\n            except asyncio.CancelledError:\n                raise\n            except:\n                pass  # parent container closed\n\n            # Do not forget to remove the container\n            try:\n                await self._docker.remove_container(container_id)\n            except asyncio.CancelledError:\n                raise\n            except:\n                pass  # ignore\n        except asyncio.CancelledError:\n            raise\n        except:\n            self._logger.exception(\"Exception in handle_student_job_closing\")", "response": "Handle a student container closing."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling a closing student container.", "response": "async def handle_job_closing(self, container_id, retval):\n        \"\"\"\n        Handle a closing student container. Do some cleaning, verify memory limits, timeouts, ... and returns data to the backend\n        \"\"\"\n        try:\n            self._logger.debug(\"Closing %s\", container_id)\n            try:\n                message, container_path, future_results = self._containers_running[container_id]\n                del self._containers_running[container_id]\n            except asyncio.CancelledError:\n                raise\n            except:\n                self._logger.warning(\"Container %s that has finished(p1) was not launched by this agent\", str(container_id), exc_info=True)\n                return\n\n            # Close sub containers\n            for student_container_id_loop in self._student_containers_for_job[message.job_id]:\n                # little hack to ensure the value of student_container_id_loop is copied into the closure\n                async def close_and_delete(student_container_id=student_container_id_loop):\n                    try:\n                        await self._docker.kill_container(student_container_id)\n                        await self._docker.remove_container(student_container_id)\n                    except asyncio.CancelledError:\n                        raise\n                    except:\n                        pass  # ignore\n                self._create_safe_task(close_and_delete(student_container_id_loop))\n            del self._student_containers_for_job[message.job_id]\n\n            # Allow other container to reuse the external ports this container has finished to use\n            if container_id in self._assigned_external_ports:\n                for p in self._assigned_external_ports[container_id]:\n                    self._external_ports.add(p)\n                del self._assigned_external_ports[container_id]\n\n            # Verify if the container was killed, either by the client, by an OOM or by a timeout\n            killed = await self._timeout_watcher.was_killed(container_id)\n            if container_id in self._containers_killed:\n                killed = self._containers_killed[container_id]\n                del self._containers_killed[container_id]\n\n            stdout = \"\"\n            stderr = \"\"\n            result = \"crash\" if retval == -1 else None\n            error_msg = None\n            grade = None\n            problems = {}\n            custom = {}\n            tests = {}\n            archive = None\n            state = \"\"\n\n            if killed is not None:\n                result = killed\n\n            # If everything did well, continue to retrieve the status from the container\n            if result is None:\n                # Get logs back\n                try:\n                    return_value = await future_results\n\n                    # Accepted types for return dict\n                    accepted_types = {\"stdout\": str, \"stderr\": str, \"result\": str, \"text\": str, \"grade\": float,\n                                      \"problems\": dict, \"custom\": dict, \"tests\": dict, \"state\": str, \"archive\": str}\n\n                    keys_fct = {\"problems\": id_checker, \"custom\": id_checker, \"tests\": id_checker_tests}\n\n                    # Check dict content\n                    for key, item in return_value.items():\n                        if not isinstance(item, accepted_types[key]):\n                            raise Exception(\"Feedback file is badly formatted.\")\n                        elif accepted_types[key] == dict and key != \"custom\": #custom can contain anything:\n                            for sub_key, sub_item in item.items():\n                                if not keys_fct[key](sub_key) or isinstance(sub_item, dict):\n                                    raise Exception(\"Feedback file is badly formatted.\")\n\n                    # Set output fields\n                    stdout = return_value.get(\"stdout\", \"\")\n                    stderr = return_value.get(\"stderr\", \"\")\n                    result = return_value.get(\"result\", \"error\")\n                    error_msg = return_value.get(\"text\", \"\")\n                    grade = return_value.get(\"grade\", None)\n                    problems = return_value.get(\"problems\", {})\n                    custom = return_value.get(\"custom\", {})\n                    tests = return_value.get(\"tests\", {})\n                    state = return_value.get(\"state\", \"\")\n                    archive = return_value.get(\"archive\", None)\n                    if archive is not None:\n                        archive = base64.b64decode(archive)\n                except Exception as e:\n                    self._logger.exception(\"Cannot get back output of container %s! (%s)\", container_id, str(e))\n                    result = \"crash\"\n                    error_msg = 'The grader did not return a readable output : {}'.format(str(e))\n\n            # Default values\n            if error_msg is None:\n                error_msg = \"\"\n            if grade is None:\n                if result == \"success\":\n                    grade = 100.0\n                else:\n                    grade = 0.0\n\n            # Remove container\n            try:\n                await self._docker.remove_container(container_id)\n            except asyncio.CancelledError:\n                raise\n            except:\n                pass\n\n            # Delete folders\n            try:\n                await self._ashutil.rmtree(container_path)\n            except PermissionError:\n                self._logger.debug(\"Cannot remove old container path!\")\n                pass  # todo: run a docker container to force removal\n\n            # Return!\n            await self.send_job_result(message.job_id, result, error_msg, grade, problems, tests, custom, state, archive, stdout, stderr)\n\n            # Do not forget to remove data from internal state\n            del self._container_for_job[message.job_id]\n        except asyncio.CancelledError:\n            raise\n        except:\n            self._logger.exception(\"Exception in handle_job_closing\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def kill_job(self, message: BackendKillJob):\n        try:\n            if message.job_id in self._container_for_job:\n                self._containers_killed[self._container_for_job[message.job_id]] = \"killed\"\n                await self._docker.kill_container(self._container_for_job[message.job_id])\n            else:\n                self._logger.warning(\"Cannot kill container for job %s because it is not running\", str(message.job_id))\n        except asyncio.CancelledError:\n            raise\n        except:\n            self._logger.exception(\"Exception in handle_kill_job\")", "response": "Handles kill messages. Kill things."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_user_lists(self, course, aggregationid=''):\n        tutor_list = course.get_staff()\n\n        # Determine student list and if they are grouped\n        student_list = list(self.database.aggregations.aggregate([\n            {\"$match\": {\"courseid\": course.get_id()}},\n            {\"$unwind\": \"$students\"},\n            {\"$project\": {\n                \"classroom\": \"$_id\",\n                \"students\": 1,\n                \"grouped\": {\n                    \"$anyElementTrue\": {\n                        \"$map\": {\n                            \"input\": \"$groups.students\",\n                            \"as\": \"group\",\n                            \"in\": {\n                                \"$anyElementTrue\": {\n                                    \"$map\": {\n                                        \"input\": \"$$group\",\n                                        \"as\": \"groupmember\",\n                                        \"in\": {\"$eq\": [\"$$groupmember\", \"$students\"]}\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }}\n        ]))\n\n        student_list = dict([(student[\"students\"], student) for student in student_list])\n        users_info = self.user_manager.get_users_info(list(student_list.keys()) + tutor_list)\n\n        if aggregationid:\n            # Order the non-registered students\n            other_students = [student_list[entry]['students'] for entry in student_list.keys() if\n                              not student_list[entry]['classroom'] == ObjectId(aggregationid)]\n            other_students = sorted(other_students, key=lambda val: ((\"0\"+users_info[val][0]) if users_info[val] else (\"1\"+val)))\n\n            return student_list, tutor_list, other_students, users_info\n        else:\n            return student_list, tutor_list, users_info", "response": "Get the available student and tutor lists for aggregation edition"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_aggregation(self, course, aggregationid, new_data):\n\n        student_list = self.user_manager.get_course_registered_users(course, False)\n\n        # If aggregation is new\n        if aggregationid == 'None':\n            # Remove _id for correct insertion\n            del new_data['_id']\n            new_data[\"courseid\"] = course.get_id()\n\n            # Insert the new aggregation\n            result = self.database.aggregations.insert_one(new_data)\n\n            # Retrieve new aggregation id\n            aggregationid = result.inserted_id\n            new_data['_id'] = result.inserted_id\n            aggregation = new_data\n        else:\n            aggregation = self.database.aggregations.find_one({\"_id\": ObjectId(aggregationid), \"courseid\": course.get_id()})\n\n        # Check tutors\n        new_data[\"tutors\"] = [tutor for tutor in new_data[\"tutors\"] if tutor in course.get_staff()]\n\n        students, groups, errored_students = [], [], []\n\n        # Check the students\n        for student in new_data[\"students\"]:\n            if student in student_list:\n                # Remove user from the other aggregation\n                self.database.aggregations.find_one_and_update({\"courseid\": course.get_id(), \"groups.students\": student},\n                                                             {\"$pull\": {\"groups.$.students\": student, \"students\": student}})\n                self.database.aggregations.find_one_and_update({\"courseid\": course.get_id(), \"students\": student}, {\"$pull\": {\"students\": student}})\n                students.append(student)\n            else:\n                # Check if user can be registered\n                user_info = self.user_manager.get_user_info(student)\n                if user_info is None or student in aggregation[\"tutors\"]:\n                    errored_students.append(student)\n                else:\n                    students.append(student)\n\n        removed_students = [student for student in aggregation[\"students\"] if student not in new_data[\"students\"]]\n        self.database.aggregations.find_one_and_update({\"courseid\": course.get_id(), \"default\": True},\n                                                     {\"$push\": {\"students\": {\"$each\": removed_students}}})\n\n        new_data[\"students\"] = students\n\n        # Check the groups\n        for group in new_data[\"groups\"]:\n            group[\"students\"] = [student for student in group[\"students\"] if student in new_data[\"students\"]]\n            if len(group[\"students\"]) <= group[\"size\"]:\n                groups.append(group)\n\n        new_data[\"groups\"] = groups\n\n        # Check for default aggregation\n        if new_data['default']:\n            self.database.aggregations.find_one_and_update({\"courseid\": course.get_id(), \"default\": True},\n                                                         {\"$set\": {\"default\": False}})\n\n        aggregation = self.database.aggregations.find_one_and_update(\n            {\"_id\": ObjectId(aggregationid)},\n            {\"$set\": {\"description\": new_data[\"description\"],\n                      \"students\": students, \"tutors\": new_data[\"tutors\"],\n                      \"groups\": groups, \"default\": new_data['default']}}, return_document=ReturnDocument.AFTER)\n\n        return aggregation, errored_students", "response": "Update aggregation and returns a list of errored students"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef POST_AUTH(self, courseid, aggregationid=''):  # pylint: disable=arguments-differ\n        course, __ = self.get_course_and_check_rights(courseid, allow_all_staff=True)\n\n        if course.is_lti():\n            raise web.notfound()\n\n        msg=''\n        error = False\n        errored_students = []\n        data = web.input(delete=[], tutors=[], groups=[], aggregationfile={})\n        if len(data[\"delete\"]):\n\n            for classid in data[\"delete\"]:\n                # Get the aggregation\n                aggregation = self.database.aggregations.find_one({\"_id\": ObjectId(classid), \"courseid\": courseid}) if ObjectId.is_valid(classid) else None\n\n                if aggregation is None:\n                    msg = _(\"Classroom with id {} not found.\").format(classid) if course.use_classrooms() else _(\"Team with id {} not found.\").format(classid)\n                    error = True\n                elif aggregation['default'] and aggregationid:\n                    msg = _(\"You can't remove your default classroom.\")\n                    error = True\n                else:\n                    self.database.aggregations.find_one_and_update({\"courseid\": courseid, \"default\": True},\n                                                                 {\"$push\": {\n                                                                     \"students\": {\"$each\": aggregation[\"students\"]}\n                                                                 }})\n\n                    self.database.aggregations.delete_one({\"_id\": ObjectId(classid)})\n                    msg = _(\"Classroom updated.\")\n\n            if aggregationid and aggregationid in data[\"delete\"]:\n                raise web.seeother(self.app.get_homepath() + \"/admin/\" + courseid + \"/aggregations\")\n\n        try:\n            if \"upload\" in data:\n                self.database.aggregations.delete_many({\"courseid\": course.get_id()})\n                aggregations = custom_yaml.load(data[\"aggregationfile\"].file)\n            else:\n                aggregations = json.loads(data[\"aggregations\"])\n\n            for index, new_aggregation in enumerate(aggregations):\n                # In case of file upload, no id specified\n                new_aggregation['_id'] = new_aggregation['_id'] if '_id' in new_aggregation else 'None'\n\n                # In case of no aggregation usage, set the first entry default\n                new_aggregation[\"default\"] = not aggregationid and index == 0\n\n                # If no groups field set, create group from class students if in groups only mode\n                if \"groups\" not in new_aggregation:\n                    new_aggregation[\"groups\"] = [] if aggregationid else [{'size': len(new_aggregation['students']),\n                                                                       'students': new_aggregation['students']}]\n\n                # Update the aggregation\n                aggregation, errors = self.update_aggregation(course, new_aggregation['_id'], new_aggregation)\n\n                # If file upload was done, get the default aggregation id\n                if course.use_classrooms() and aggregation['default']:\n                    aggregationid = aggregation['_id']\n                errored_students += errors\n\n            if len(errored_students) > 0:\n                msg = _(\"Changes couldn't be applied for following students :\") + \"<ul>\"\n                for student in errored_students:\n                    msg += \"<li>\" + student + \"</li>\"\n                msg += \"</ul>\"\n                error = True\n            elif not error:\n                msg = _(\"Classroom updated.\") if course.use_classrooms() else _(\"Teams updated.\")\n        except:\n            msg = _('An error occurred while parsing the data.')\n            error = True\n\n        # Display the page\n        return self.display_page(course, aggregationid, msg, error)", "response": "Edit a course s aggregation"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle the POST request for the course list page", "response": "def POST_AUTH(self):  # pylint: disable=arguments-differ\n        \"\"\" Parse course registration or course creation and display the course list page \"\"\"\n\n        username = self.user_manager.session_username()\n        user_info = self.database.users.find_one({\"username\": username})\n        user_input = web.input()\n        success = None\n\n        # Handle registration to a course\n        if \"register_courseid\" in user_input and user_input[\"register_courseid\"] != \"\":\n            try:\n                course = self.course_factory.get_course(user_input[\"register_courseid\"])\n                if not course.is_registration_possible(user_info):\n                    success = False\n                else:\n                    success = self.user_manager.course_register_user(course, username, user_input.get(\"register_password\", None))\n            except:\n                success = False\n        elif \"new_courseid\" in user_input and self.user_manager.user_is_superadmin():\n            try:\n                courseid = user_input[\"new_courseid\"]\n                self.course_factory.create_course(courseid, {\"name\": courseid, \"accessible\": False})\n                success = True\n            except:\n                success = False\n\n        return self.show_page(success)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_page(self, success):\n        username = self.user_manager.session_username()\n        user_info = self.database.users.find_one({\"username\": username})\n\n        all_courses = self.course_factory.get_all_courses()\n\n        # Display\n        open_courses = {courseid: course for courseid, course in all_courses.items()\n                        if self.user_manager.course_is_open_to_user(course, username, False) and\n                        self.user_manager.course_is_user_registered(course, username)}\n        open_courses = OrderedDict(sorted(iter(open_courses.items()), key=lambda x: x[1].get_name(self.user_manager.session_language())))\n\n        last_submissions = self.submission_manager.get_user_last_submissions(5, {\"courseid\": {\"$in\": list(open_courses.keys())}})\n        except_free_last_submissions = []\n        for submission in last_submissions:\n            try:\n                submission[\"task\"] = open_courses[submission['courseid']].get_task(submission['taskid'])\n                except_free_last_submissions.append(submission)\n            except:\n                pass\n\n        registerable_courses = {courseid: course for courseid, course in all_courses.items() if\n                                not self.user_manager.course_is_user_registered(course, username) and\n                                course.is_registration_possible(user_info)}\n\n        registerable_courses = OrderedDict(sorted(iter(registerable_courses.items()), key=lambda x: x[1].get_name(self.user_manager.session_language())))\n\n        return self.template_helper.get_renderer().mycourses(open_courses, registerable_courses, except_free_last_submissions, success)", "response": "Display main course list page"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _run_asyncio(loop, zmq_context):\n    try:\n        asyncio.set_event_loop(loop)\n        loop.run_forever()\n    except:\n        pass\n    finally:\n        loop.close()\n        zmq_context.destroy(1000)", "response": "Run asyncio in a thread and close the zmq context when the thread ends"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrestart an agent when it is cancelled", "response": "async def _restart_on_cancel(logger, agent):\n    \"\"\" Restarts an agent when it is cancelled \"\"\"\n    while True:\n        try:\n            await agent.run()\n        except asyncio.CancelledError:\n            logger.exception(\"Restarting agent\")\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef GET(self, *args, **kwargs):\n        if self.user_manager.session_logged_in():\n            if not self.user_manager.session_username() and not self.__class__.__name__ == \"ProfilePage\":\n                raise web.seeother(\"/preferences/profile\")\n\n            if not self.is_lti_page and self.user_manager.session_lti_info() is not None: #lti session\n                self.user_manager.disconnect_user()\n                return self.template_helper.get_renderer().auth(self.user_manager.get_auth_methods(), False)\n\n            return self.GET_AUTH(*args, **kwargs)\n        else:\n            return self.template_helper.get_renderer().auth(self.user_manager.get_auth_methods(), False)", "response": "Method for GET method."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef POST(self, *args, **kwargs):\n        if self.user_manager.session_logged_in():\n            if not self.user_manager.session_username() and not self.__class__.__name__ == \"ProfilePage\":\n                raise web.seeother(\"/preferences/profile\")\n\n            if not self.is_lti_page and self.user_manager.session_lti_info() is not None:  # lti session\n                self.user_manager.disconnect_user()\n                return self.template_helper.get_renderer().auth(self.user_manager.get_auth_methods_fields(), False)\n\n            return self.POST_AUTH(*args, **kwargs)\n        else:\n            user_input = web.input()\n            if \"login\" in user_input and \"password\" in user_input:\n                if self.user_manager.auth_user(user_input[\"login\"].strip(), user_input[\"password\"]) is not None:\n                    return self.GET_AUTH(*args, **kwargs)\n                else:\n                    return self.template_helper.get_renderer().auth(self.user_manager.get_auth_methods(), True)\n            else:\n                return self.template_helper.get_renderer().auth(self.user_manager.get_auth_methods(), False)", "response": "Checks if user is authenticated and performs login and calls GET_AUTH. Otherwise returns the login template."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntranslate a / - separated PATH to the local filename syntax.", "response": "def translate_path(self, path):\n        \"\"\"Translate a /-separated PATH to the local filename syntax.\n\n        Components that mean special things to the local file system\n        (e.g. drive or directory names) are ignored.  (XXX They should\n        probably be diagnosed.)\n\n        \"\"\"\n        # abandon query parameters\n        path = path.split('?', 1)[0]\n        path = path.split('#', 1)[0]\n        # Don't forget explicit trailing slash when normalizing. Issue17324\n        trailing_slash = path.rstrip().endswith('/')\n        path = posixpath.normpath(urllib.parse.unquote(path))\n        words = path.split('/')\n        words = [_f for _f in words if _f]\n        path = self.base_path\n        for word in words:\n            _, word = os.path.splitdrive(word)\n            _, word = os.path.split(word)\n            if word in (os.curdir, os.pardir):\n                continue\n            path = os.path.join(path, word)\n        if trailing_slash:\n            path += '/'\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_submissions(course_factory, submission_manager, user_manager, translations, courseid, taskid, with_input, submissionid=None):\n\n    try:\n        course = course_factory.get_course(courseid)\n    except:\n        raise APINotFound(\"Course not found\")\n\n    if not user_manager.course_is_open_to_user(course, lti=False):\n        raise APIForbidden(\"You are not registered to this course\")\n\n    try:\n        task = course.get_task(taskid)\n    except:\n        raise APINotFound(\"Task not found\")\n\n    if submissionid is None:\n        submissions = submission_manager.get_user_submissions(task)\n    else:\n        try:\n            submissions = [submission_manager.get_submission(submissionid)]\n        except:\n            raise APINotFound(\"Submission not found\")\n        if submissions[0][\"taskid\"] != task.get_id() or submissions[0][\"courseid\"] != course.get_id():\n            raise APINotFound(\"Submission not found\")\n\n    output = []\n\n    for submission in submissions:\n        submission = submission_manager.get_feedback_from_submission(\n            submission,\n            show_everything=user_manager.has_staff_rights_on_course(course, user_manager.session_username()),\n            translation=translations.get(user_manager.session_language(), gettext.NullTranslations())\n        )\n        data = {\n            \"id\": str(submission[\"_id\"]),\n            \"submitted_on\": str(submission[\"submitted_on\"]),\n            \"status\": submission[\"status\"]\n        }\n\n        if with_input:\n            data[\"input\"] = submission_manager.get_input_from_submission(submission, True)\n\n            # base64 encode file to allow JSON encoding\n            for d in data[\"input\"]:\n                if isinstance(d, dict) and d.keys() == {\"filename\", \"value\"}:\n                    d[\"value\"] = base64.b64encode(d[\"value\"]).decode(\"utf8\")\n\n        if submission[\"status\"] == \"done\":\n            data[\"grade\"] = submission.get(\"grade\", 0)\n            data[\"result\"] = submission.get(\"result\", \"crash\")\n            data[\"feedback\"] = submission.get(\"text\", \"\")\n            data[\"problems_feedback\"] = submission.get(\"problems\", {})\n\n        output.append(data)\n\n    return 200, output", "response": "Get the list of submissions for a given task."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all the submissions that the connected user made.", "response": "def API_GET(self, courseid, taskid, submissionid):  # pylint: disable=arguments-differ\n        \"\"\"\n            List all the submissions that the connected user made. Returns list of the form\n\n            ::\n\n                [\n                    {\n                        \"id\": \"submission_id1\",\n                        \"submitted_on\": \"date\",\n                        \"status\" : \"done\",          #can be \"done\", \"waiting\", \"error\" (execution status of the task).\n                        \"grade\": 0.0,\n                        \"input\": {},                #the input data. File are base64 encoded.\n                        \"result\" : \"success\"        #only if status=done. Result of the execution.\n                        \"feedback\": \"\"              #only if status=done. the HTML global feedback for the task\n                        \"problems_feedback\":        #only if status=done. HTML feedback per problem. Some pid may be absent.\n                        {\n                            \"pid1\": \"feedback1\",\n                            #...\n                        }\n                    }\n                    #...\n                ]\n\n            If you use the endpoint /api/v0/courses/the_course_id/tasks/the_task_id/submissions/submissionid,\n            this dict will contain one entry or the page will return 404 Not Found.\n        \"\"\"\n        with_input = \"input\" in web.input()\n\n        return _get_submissions(self.course_factory, self.submission_manager, self.user_manager, self.app._translations, courseid, taskid, with_input, submissionid)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new submission for a task.", "response": "def API_POST(self, courseid, taskid):  # pylint: disable=arguments-differ\n        \"\"\"\n            Creates a new submissions. Takes as (POST) input the key of the subproblems, with the value assigned each time.\n\n            Returns\n\n            - an error 400 Bad Request if all the input is not (correctly) given,\n            - an error 403 Forbidden if you are not allowed to create a new submission for this task\n            - an error 404 Not found if the course/task id not found\n            - an error 500 Internal server error if the grader is not available,\n            - 200 Ok, with {\"submissionid\": \"the submission id\"} as output.\n        \"\"\"\n\n        try:\n            course = self.course_factory.get_course(courseid)\n        except:\n            raise APINotFound(\"Course not found\")\n\n        username = self.user_manager.session_username()\n\n        if not self.user_manager.course_is_open_to_user(course, username, False):\n            raise APIForbidden(\"You are not registered to this course\")\n\n        try:\n            task = course.get_task(taskid)\n        except:\n            raise APINotFound(\"Task not found\")\n\n        self.user_manager.user_saw_task(username, courseid, taskid)\n\n        # Verify rights\n        if not self.user_manager.task_can_user_submit(task, username, False):\n            raise APIForbidden(\"You are not allowed to submit for this task\")\n\n        init_var = {\n            problem.get_id(): problem.input_type()()\n            for problem in task.get_problems() if problem.input_type() in [dict, list]\n        }\n        user_input = task.adapt_input_for_backend(web.input(**init_var))\n\n        if not task.input_is_consistent(user_input, self.default_allowed_file_extensions, self.default_max_file_size):\n            raise APIInvalidArguments()\n\n        # Get debug info if the current user is an admin\n        debug = self.user_manager.has_admin_rights_on_course(course, username)\n\n\n        # Start the submission\n        try:\n            submissionid, _ = self.submission_manager.add_job(task, user_input, debug)\n            return 200, {\"submissionid\": str(submissionid)}\n        except Exception as ex:\n            raise APIError(500, str(ex))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef GET_AUTH(self, courseid, taskid):  # pylint: disable=arguments-differ\n        course, task = self.get_course_and_check_rights(courseid, taskid)\n        return self.page(course, task)", "response": "GET request handler for the AUTH header."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all data and display the page", "response": "def page(self, course, task):\n        \"\"\" Get all data and display the page \"\"\"\n        user_list = self.user_manager.get_course_registered_users(course, False)\n        users = OrderedDict(sorted(list(self.user_manager.get_users_info(user_list).items()),\n                                   key=lambda k: k[1][0] if k[1] is not None else \"\"))\n\n        individual_results = list(self.database.user_tasks.find({\"courseid\": course.get_id(), \"taskid\": task.get_id(),\n                                                                 \"username\": {\"$in\": user_list}}))\n\n        individual_data = OrderedDict([(username, {\"username\": username, \"realname\": user[0] if user is not None else \"\",\n                                                   \"email\": user[1] if user is not None else \"\",\n                                                   \"url\": self.individual_submission_url_generator(task, username),\n                                                   \"tried\": 0, \"grade\": 0, \"status\": \"notviewed\"})\n                                       for username, user in users.items()])\n\n        for user in individual_results:\n            individual_data[user[\"username\"]][\"tried\"] = user[\"tried\"]\n            if user[\"tried\"] == 0:\n                individual_data[user[\"username\"]][\"status\"] = \"notattempted\"\n            elif user[\"succeeded\"]:\n                individual_data[user[\"username\"]][\"status\"] = \"succeeded\"\n            else:\n                individual_data[user[\"username\"]][\"status\"] = \"failed\"\n            individual_data[user[\"username\"]][\"grade\"] = user[\"grade\"]\n\n        aggregation_data = OrderedDict()\n        for aggregation in self.user_manager.get_course_aggregations(course):\n            aggregation_data[aggregation['_id']] = {\"_id\": aggregation['_id'], \"description\": aggregation['description'],\n                                                \"url\": self.aggregation_submission_url_generator(task, aggregation),\n                                                \"tried\": 0, \"grade\": 0, \"status\": \"notviewed\",\n                                                \"tutors\": aggregation[\"tutors\"], \"groups\": aggregation[\"groups\"]}\n\n            aggregation_results = list(self.database.submissions.aggregate(\n                [\n                    {\n                        \"$match\":\n                            {\n                                \"courseid\": course.get_id(),\n                                \"taskid\": task.get_id(),\n                                \"username\": {\"$in\": aggregation[\"students\"]}\n                            }\n                    },\n                    {\n                        \"$group\":\n                            {\n                                \"_id\": \"$taskid\",\n                                \"tried\": {\"$sum\": 1},\n                                \"succeeded\": {\"$sum\": {\"$cond\": [{\"$eq\": [\"$result\", \"success\"]}, 1, 0]}},\n                                \"grade\": {\"$max\": \"$grade\"}\n                            }\n                    }\n                ]))\n\n            for g in aggregation_results:\n                aggregation_data[aggregation['_id']][\"tried\"] = g[\"tried\"]\n                if g[\"tried\"] == 0:\n                    aggregation_data[aggregation['_id']][\"status\"] = \"notattempted\"\n                elif g[\"succeeded\"]:\n                    aggregation_data[aggregation['_id']][\"status\"] = \"succeeded\"\n                else:\n                    aggregation_data[aggregation['_id']][\"status\"] = \"failed\"\n                aggregation_data[aggregation['_id']][\"grade\"] = g[\"grade\"]\n\n        my_aggregations, other_aggregations = [], []\n        for aggregation in aggregation_data.values():\n            if self.user_manager.session_username() in aggregation[\"tutors\"]:\n                my_aggregations.append(aggregation)\n            else:\n                other_aggregations.append(aggregation)\n\n        if \"csv\" in web.input() and web.input()[\"csv\"] == \"students\":\n            return make_csv(list(individual_data.values()))\n        elif \"csv\" in web.input() and web.input()[\"csv\"] == \"aggregations\":\n            return make_csv(list(aggregation_data.values()))\n\n        return self.template_helper.get_renderer().course_admin.task_info(course, task, individual_data.values(), [my_aggregations, other_aggregations])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns true if users can register for this course", "response": "def is_registration_possible(self, user_info):\n        \"\"\" Returns true if users can register for this course \"\"\"\n        return self.get_accessibility().is_open() and self._registration.is_open() and self.is_user_accepted_by_access_control(user_info)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the AccessibleTime object associated with this course", "response": "def get_accessibility(self, plugin_override=True):\n        \"\"\" Return the AccessibleTime object associated with the accessibility of this course \"\"\"\n        vals = self._hook_manager.call_hook('course_accessibility', course=self, default=self._accessible)\n        return vals[0] if len(vals) and plugin_override else self._accessible"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_user_accepted_by_access_control(self, user_info):\n        if self.get_access_control_method() is None:\n            return True\n        elif not user_info:\n            return False\n        elif self.get_access_control_method() == \"username\":\n            return user_info[\"username\"] in self.get_access_control_list()\n        elif self.get_access_control_method() == \"email\":\n            return user_info[\"email\"] in self.get_access_control_list()\n        elif self.get_access_control_method() == \"binding\":\n            return set(user_info[\"bindings\"].keys()).intersection(set(self.get_access_control_list()))\n        return False", "response": "Returns True if the user is allowed by the ACL"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if students can unregister from course False otherwise.", "response": "def allow_unregister(self, plugin_override=True):\n        \"\"\" Returns True if students can unregister from course \"\"\"\n        vals = self._hook_manager.call_hook('course_allow_unregister', course=self, default=self._allow_unregister)\n        return vals[0] if len(vals) and plugin_override else self._allow_unregister"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the name of this course", "response": "def get_name(self, language):\n        \"\"\" Return the name of this course \"\"\"\n        return self.gettext(language, self._name) if self._name else \"\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_description(self, language):\n        description = self.gettext(language, self._description) if self._description else ''\n        return ParsableText(description, \"rst\", self._translations.get(language, gettext.NullTranslations()))", "response": "Returns the course description"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a tuple of lists of common and anti tags of all tasks of this course", "response": "def get_all_tags(self):\n        \"\"\" \n        Return a tuple of lists ([common_tags], [anti_tags], [organisational_tags]) all tags of all tasks of this course \n        Since this is an heavy procedure, we use a cache to cache results. Cache should be updated when a task is modified.\n        \"\"\"\n        \n        if self._all_tags_cache != None:\n            return self._all_tags_cache\n    \n        tag_list_common = set()\n        tag_list_misconception = set()\n        tag_list_org = set()\n\n        tasks = self.get_tasks()\n        for id, task in tasks.items():\n            for tag in task.get_tags()[0]:\n                tag_list_common.add(tag)\n            for tag in task.get_tags()[1]:\n                tag_list_misconception.add(tag)\n            for tag in task.get_tags()[2]:\n                tag_list_org.add(tag)\n        \n        tag_list_common = natsorted(tag_list_common, key=lambda y: y.get_name().lower())\n        tag_list_misconception = natsorted(tag_list_misconception, key=lambda y: y.get_name().lower())\n        tag_list_org = natsorted(tag_list_org, key=lambda y: y.get_name().lower())\n             \n        self._all_tags_cache = (list(tag_list_common), list(tag_list_misconception), list(tag_list_org))\n        return self._all_tags_cache"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_all_tags_names_as_list(self, admin=False, language=\"en\"):\n\n        if admin:\n            if self._all_tags_cache_list_admin != {} and language in self._all_tags_cache_list_admin:\n                return self._all_tags_cache_list_admin[language] #Cache hit\n        else:\n            if self._all_tags_cache_list != {} and language in self._all_tags_cache_list:\n                return self._all_tags_cache_list[language] #Cache hit\n                        \n        #Cache miss, computes everything\n        s_stud = set()\n        s_admin = set()\n        (common, _, org) = self.get_all_tags()\n        for tag in common + org:\n            # Is tag_name_with_translation correct by doing that like that ?\n            tag_name_with_translation = self.gettext(language, tag.get_name()) if tag.get_name() else \"\"\n            s_admin.add(tag_name_with_translation) \n            if tag.is_visible_for_student():\n                s_stud.add(tag_name_with_translation) \n        self._all_tags_cache_list_admin[language] = natsorted(s_admin, key=lambda y: y.lower())\n        self._all_tags_cache_list[language] = natsorted(s_stud, key=lambda y: y.lower())\n        \n        if admin:\n            return self._all_tags_cache_list_admin[language]\n        return self._all_tags_cache_list[language]", "response": "Computes and caches two list containing all tags names sorted by natural order on name"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_all_tags_cache(self):\n        \n        self._all_tags_cache = None\n        self._all_tags_cache_list = {}\n        self._all_tags_cache_list_admin = {}\n        self._organisational_tags_to_task = {}\n            \n        self.get_all_tags()\n        self.get_all_tags_names_as_list()\n        self.get_organisational_tags_to_task()", "response": "Update the all tags cache"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_app(config):\n    mongo_client = MongoClient(host=config.get('mongo_opt', {}).get('host', 'localhost'))\n    database = mongo_client[config.get('mongo_opt', {}).get('database', 'INGInious')]\n\n    # Create the FS provider\n    if \"tasks_directory\" not in config:\n        raise RuntimeError(\"WebDav access is only supported if INGInious is using a local filesystem to access tasks\")\n\n    fs_provider = LocalFSProvider(config[\"tasks_directory\"])\n    course_factory, task_factory = create_factories(fs_provider, {}, None, WebAppCourse, WebAppTask)\n    user_manager = UserManager(MongoStore(database, 'sessions'), database, config.get('superadmins', []))\n\n    config = dict(wsgidav_app.DEFAULT_CONFIG)\n    config[\"provider_mapping\"] = {\"/\": INGIniousFilesystemProvider(course_factory, task_factory)}\n    config[\"domaincontroller\"] = INGIniousDAVDomainController(user_manager, course_factory)\n    config[\"verbose\"] = 0\n\n    app = wsgidav_app.WsgiDAVApp(config)\n\n    return app", "response": "Init the webdav app"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresolve a relative url to the appropriate realm name.", "response": "def getDomainRealm(self, inputURL, environ):\n        \"\"\"Resolve a relative url to the  appropriate realm name.\"\"\"\n        # we don't get the realm here, its already been resolved in\n        # request_resolver\n        if inputURL.startswith(\"/\"):\n            inputURL = inputURL[1:]\n        parts = inputURL.split(\"/\")\n        return parts[0]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef isRealmUser(self, realmname, username, environ):\n        try:\n            course = self.course_factory.get_course(realmname)\n            ok = self.user_manager.has_admin_rights_on_course(course, username=username)\n            return ok\n        except:\n            return False", "response": "Returns True if this username is valid for the realm False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the password for the given username for the given realm.", "response": "def getRealmUserPassword(self, realmname, username, environ):\n        \"\"\"Return the password for the given username for the realm.\n\n        Used for digest authentication.\n        \"\"\"\n        return self.user_manager.get_user_api_key(username, create=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if this username and password pair is valid for the realm False otherwise. Used for basic authentication.", "response": "def authDomainUser(self, realmname, username, password, environ):\n        \"\"\"Returns True if this username/password pair is valid for the realm,\n        False otherwise. Used for basic authentication.\"\"\"\n        try:\n            apikey = self.user_manager.get_user_api_key(username, create=None)\n            return apikey is not None and password == apikey\n        except:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getResourceInst(self, path, environ):\n        self._count_getResourceInst += 1\n        fp = self._locToFilePath(path)\n        if not os.path.exists(fp):\n            return None\n\n        if os.path.isdir(fp):\n            return FolderResource(path, environ, fp)\n        return FileResource(path, environ, fp)", "response": "Return info dictionary for path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget request handler for GET_AUTH", "response": "def GET_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        \"\"\" GET request \"\"\"\n        course, __ = self.get_course_and_check_rights(courseid)\n        return self.page(course)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nposting request for the course", "response": "def POST_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        \"\"\" POST request \"\"\"\n        course, __ = self.get_course_and_check_rights(courseid, None, False)\n        data = web.input()\n        if \"remove\" in data:\n            try:\n                if data[\"type\"] == \"all\":\n                    aggregations = list(self.database.aggregations.find({\"courseid\": courseid}))\n                    for aggregation in aggregations:\n                        aggregation[\"students\"] = []\n                        for group in aggregation[\"groups\"]:\n                            group[\"students\"] = []\n                        self.database.aggregations.replace_one({\"_id\": aggregation[\"_id\"]}, aggregation)\n                else:\n                    self.user_manager.course_unregister_user(course, data[\"username\"])\n            except:\n                pass\n        elif \"register\" in data:\n            try:\n                self.user_manager.course_register_user(course, data[\"username\"].strip(), '', True)\n            except:\n                pass\n        return self.page(course)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all data and display the page", "response": "def page(self, course, error=\"\", post=False):\n        \"\"\" Get all data and display the page \"\"\"\n        users = sorted(list(self.user_manager.get_users_info(self.user_manager.get_course_registered_users(course, False)).items()),\n                       key=lambda k: k[1][0] if k[1] is not None else \"\")\n\n        users = OrderedDict(sorted(list(self.user_manager.get_users_info(course.get_staff()).items()),\n                                   key=lambda k: k[1][0] if k[1] is not None else \"\") + users)\n\n        user_data = OrderedDict([(username, {\n            \"username\": username, \"realname\": user[0] if user is not None else \"\",\n            \"email\": user[1] if user is not None else \"\", \"total_tasks\": 0,\n            \"task_grades\": {\"answer\": 0, \"match\": 0}, \"task_succeeded\": 0, \"task_tried\": 0, \"total_tries\": 0,\n            \"grade\": 0, \"url\": self.submission_url_generator(username)}) for username, user in users.items()])\n\n        for username, data in self.user_manager.get_course_caches(list(users.keys()), course).items():\n            user_data[username].update(data if data is not None else {})\n\n        if \"csv\" in web.input():\n            return make_csv(user_data)\n\n        return self.template_helper.get_renderer().course_admin.student_list(course, list(user_data.values()), error, post)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget request for the AUTH section of the submission", "response": "def GET_AUTH(self, submissionid):  # pylint: disable=arguments-differ\n        \"\"\" GET request \"\"\"\n        course, task, submission = self.fetch_submission(submissionid)\n        return self.page(course, task, submission)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all data and display the page", "response": "def page(self, course, task, submission):\n        \"\"\" Get all data and display the page \"\"\"\n        submission = self.submission_manager.get_input_from_submission(submission)\n        submission = self.submission_manager.get_feedback_from_submission(\n            submission,\n            show_everything=True,\n            translation=self.app._translations.get(self.user_manager.session_language(), gettext.NullTranslations())\n        )\n\n        to_display = {\n            problem.get_id(): {\n                \"id\": problem.get_id(),\n                \"name\": problem.get_name(self.user_manager.session_language()),\n                \"defined\": True\n            } for problem in task.get_problems()\n        }\n\n        to_display.update({\n            pid: {\n                \"id\": pid,\n                \"name\": pid,\n                \"defined\": False\n            } for pid in (set(submission[\"input\"]) - set(to_display))\n        })\n\n        return self.template_helper.get_renderer().course_admin.submission(course, task, submission, to_display.values())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef GET_AUTH(self, courseid, taskid):  # pylint: disable=arguments-differ\n        if not id_checker(taskid):\n            raise Exception(\"Invalid task id\")\n\n        course, __ = self.get_course_and_check_rights(courseid, allow_all_staff=False)\n\n        try:\n            task_data = self.task_factory.get_task_descriptor_content(courseid, taskid)\n        except:\n            task_data = None\n        if task_data is None:\n            task_data = {}\n\n        environments = self.containers\n\n        current_filetype = None\n        try:\n            current_filetype = self.task_factory.get_task_descriptor_extension(courseid, taskid)\n        except:\n            pass\n        available_filetypes = self.task_factory.get_available_task_file_extensions()\n\n        additional_tabs = self.plugin_manager.call_hook('task_editor_tab', course=course, taskid=taskid,\n                                                        task_data=task_data, template_helper=self.template_helper)\n\n        return self.template_helper.get_renderer().course_admin.task_edit(\n            course,\n            taskid,\n            self.task_factory.get_problem_types(),\n            task_data,\n            environments,\n            task_data.get('problems',{}),\n            self.contains_is_html(task_data),\n            current_filetype,\n            available_filetypes,\n            AccessibleTime,\n            CourseTaskFiles.get_task_filelist(self.task_factory, courseid, taskid),\n            additional_tabs\n        )", "response": "Get the AUTH information for a task"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef contains_is_html(cls, data):\n        for key, val in data.items():\n            if isinstance(key, str) and key.endswith(\"IsHTML\"):\n                return True\n            if isinstance(val, (OrderedDict, dict)) and cls.contains_is_html(val):\n                return True\n        return False", "response": "Detect if the problem contains at least one xyzIsHTML key"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary of all the items with the given prefix.", "response": "def dict_from_prefix(cls, prefix, dictionary):\n        \"\"\"\n            >>> from collections import OrderedDict\n            >>> od = OrderedDict()\n            >>> od[\"problem[q0][a]\"]=1\n            >>> od[\"problem[q0][b][c]\"]=2\n            >>> od[\"problem[q1][first]\"]=1\n            >>> od[\"problem[q1][second]\"]=2\n            >>> AdminCourseEditTask.dict_from_prefix(\"problem\",od)\n            OrderedDict([('q0', OrderedDict([('a', 1), ('b', OrderedDict([('c', 2)]))])), ('q1', OrderedDict([('first', 1), ('second', 2)]))])\n        \"\"\"\n        o_dictionary = OrderedDict()\n        for key, val in dictionary.items():\n            if key.startswith(prefix):\n                o_dictionary[key[len(prefix):].strip()] = val\n        dictionary = o_dictionary\n\n        if len(dictionary) == 0:\n            return None\n        elif len(dictionary) == 1 and \"\" in dictionary:\n            return dictionary[\"\"]\n        else:\n            return_dict = OrderedDict()\n            for key, val in dictionary.items():\n                ret = re.search(r\"^\\[([^\\]]+)\\](.*)$\", key)\n                if ret is None:\n                    continue\n                return_dict[ret.group(1)] = cls.dict_from_prefix(\"[{}]\".format(ret.group(1)), dictionary)\n            return return_dict"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a problem and returns a dictionary of the problem data.", "response": "def parse_problem(self, problem_content):\n        \"\"\" Parses a problem, modifying some data \"\"\"\n        del problem_content[\"@order\"]\n        return self.task_factory.get_problem_types().get(problem_content[\"type\"]).parse_problem(problem_content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wipe_task(self, courseid, taskid):\n        submissions = self.database.submissions.find({\"courseid\": courseid, \"taskid\": taskid})\n        for submission in submissions:\n            for key in [\"input\", \"archive\"]:\n                if key in submission and type(submission[key]) == bson.objectid.ObjectId:\n                    self.submission_manager.get_gridfs().delete(submission[key])\n\n        self.database.aggregations.remove({\"courseid\": courseid, \"taskid\": taskid})\n        self.database.user_tasks.remove({\"courseid\": courseid, \"taskid\": taskid})\n        self.database.submissions.remove({\"courseid\": courseid, \"taskid\": taskid})\n\n        self._logger.info(\"Task %s/%s wiped.\", courseid, taskid)", "response": "Wipe the data associated to the taskid from DB"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef GET(self):  # pylint: disable=arguments-differ\n        if not self.app.welcome_page:\n            raise web.seeother(\"/courselist\")\n        return self.show_page(self.app.welcome_page)", "response": "Display main course list page"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndisplay main course list page", "response": "def POST(self):  # pylint: disable=arguments-differ\n        \"\"\" Display main course list page \"\"\"\n        if not self.app.welcome_page:\n            raise web.seeother(\"/courselist\")\n        return self.show_page(self.app.welcome_page)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets request for a course", "response": "def GET_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        \"\"\" GET request \"\"\"\n\n        course = self.course_factory.get_course(courseid)\n        username = self.user_manager.session_username()\n\n        error = False\n        change = False\n        msg = \"\"\n        data = web.input()\n        if self.user_manager.has_staff_rights_on_course(course):\n            raise web.notfound()\n        elif not self.user_manager.course_is_open_to_user(course, lti=False):\n            return self.template_helper.get_renderer().course_unavailable()\n        elif \"register_group\" in data:\n            change = True\n            if course.can_students_choose_group() and course.use_classrooms():\n                aggregation = self.database.aggregations.find_one({\"courseid\": course.get_id(), \"students\": username})\n\n                if int(data[\"register_group\"]) >= 0 and (len(aggregation[\"groups\"]) > int(data[\"register_group\"])):\n                    group = aggregation[\"groups\"][int(data[\"register_group\"])]\n                    if group[\"size\"] > len(group[\"students\"]):\n                        for index, group in enumerate(aggregation[\"groups\"]):\n                            if username in group[\"students\"]:\n                                aggregation[\"groups\"][index][\"students\"].remove(username)\n                        aggregation[\"groups\"][int(data[\"register_group\"])][\"students\"].append(username)\n                    self.database.aggregations.replace_one({\"courseid\": course.get_id(), \"students\": username}, aggregation)\n                    self._logger.info(\"User %s registered to group %s/%s/%s\", username, courseid, aggregation[\"description\"], data[\"register_group\"])\n                else:\n                    error = True\n                    msg = _(\"Couldn't register to the specified group.\")\n            elif course.can_students_choose_group():\n\n                aggregation = self.database.aggregations.find_one(\n                    {\"courseid\": course.get_id(), \"students\": username})\n\n                if aggregation is not None:\n                    aggregation[\"students\"].remove(username)\n                    for index, group in enumerate(aggregation[\"groups\"]):\n                        if username in group[\"students\"]:\n                            aggregation[\"groups\"][index][\"students\"].remove(username)\n                    self.database.aggregations.replace_one({\"courseid\": course.get_id(), \"students\": username}, aggregation)\n\n                # Add student in the classroom and unique group\n                self.database.aggregations.find_one_and_update({\"_id\": ObjectId(data[\"register_group\"])},\n                                                             {\"$push\": {\"students\": username}})\n                new_aggregation = self.database.aggregations.find_one_and_update({\"_id\": ObjectId(data[\"register_group\"])},\n                                                                             {\"$push\": {\"groups.0.students\": username}})\n\n                if new_aggregation is None:\n                    error = True\n                    msg = _(\"Couldn't register to the specified group.\")\n                else:\n                    self._logger.info(\"User %s registered to team %s/%s\", username, courseid, aggregation[\"description\"])\n            else:\n                error = True\n                msg = _(\"You are not allowed to change group.\")\n        elif \"unregister_group\" in data:\n            change = True\n            if course.can_students_choose_group():\n                aggregation = self.database.aggregations.find_one({\"courseid\": course.get_id(), \"students\": username, \"groups.students\": username})\n                if aggregation is not None:\n                    for index, group in enumerate(aggregation[\"groups\"]):\n                        if username in group[\"students\"]:\n                            aggregation[\"groups\"][index][\"students\"].remove(username)\n                    self.database.aggregations.replace_one({\"courseid\": course.get_id(), \"students\": username}, aggregation)\n                    self._logger.info(\"User %s unregistered from group/team %s/%s\", username, courseid, aggregation[\"description\"])\n                else:\n                    error = True\n                    msg = _(\"You're not registered in a group.\")\n            else:\n                error = True\n                msg = _(\"You are not allowed to change group.\")\n\n        tasks = course.get_tasks()\n        last_submissions = self.submission_manager.get_user_last_submissions(5, {\"courseid\": courseid, \"taskid\": {\"$in\": list(tasks.keys())}})\n        for submission in last_submissions:\n            submission[\"taskname\"] = tasks[submission['taskid']].get_name(self.user_manager.session_language())\n\n        aggregation = self.user_manager.get_course_user_aggregation(course)\n        aggregations = self.user_manager.get_course_aggregations(course)\n        users = self.user_manager.get_users_info(self.user_manager.get_course_registered_users(course))\n\n        if course.use_classrooms():\n            mygroup = None\n            for index, group in enumerate(aggregation[\"groups\"]):\n                if self.user_manager.session_username() in group[\"students\"]:\n                    mygroup = group\n                    mygroup[\"index\"] = index + 1\n\n            return self.template_helper.get_renderer().classroom(course, last_submissions, aggregation, users,\n                                                                 mygroup, msg, error, change)\n        else:\n            return self.template_helper.get_renderer().team(course, last_submissions, aggregations, users,\n                                                            aggregation, msg, error)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a new hook that can be called with the call_hook function.", "response": "def add_hook(self, name, callback, prio=0):\n        \"\"\" Add a new hook that can be called with the call_hook function.\n            `prio` is the priority. Higher priority hooks are called before lower priority ones.\n            This function does not enforce a particular order between hooks with the same priorities.\n        \"\"\"\n        hook_list = self._hooks.get(name, [])\n\n        add = (lambda *args, **kwargs: self._exception_free_callback(callback, *args, **kwargs)), -prio\n        pos = bisect.bisect_right(list(x[1] for x in hook_list), -prio)\n        hook_list[pos:pos] = [add]\n\n        self._hooks[name] = hook_list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef call_hook(self, name, **kwargs):\n        return [y for y in [x(**kwargs) for x, _ in self._hooks.get(name, [])] if y is not None]", "response": "Call all hooks registered with this name. Returns a list of the returns values of the hooks registered with this name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef call_hook_recursive(self, name, **kwargs):\n        for x, _ in self._hooks.get(name, []):\n            out = x(**kwargs)\n            if out is not None: #ignore already reported failure\n                kwargs = out\n        return kwargs", "response": "Call all hooks registered with this name and return the kwargs that were passed to the hook."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if an input for a task is consistent. Return True if this is case False otherwise.", "response": "def input_is_consistent(self, task_input, default_allowed_extension, default_max_size):\n        \"\"\" Check if an input for a task is consistent. Return true if this is case, false else \"\"\"\n        for problem in self._problems:\n            if not problem.input_is_consistent(task_input, default_allowed_extension, default_max_size):\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_limits(self):\n        vals = self._hook_manager.call_hook('task_limits', course=self.get_course(), task=self, default=self._limits)\n        return vals[0] if len(vals) else self._limits", "response": "Return the limits of this task"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef allow_network_access_grading(self):\n        vals = self._hook_manager.call_hook('task_network_grading', course=self.get_course(), task=self, default=self._network_grading)\n        return vals[0] if len(vals) else self._network_grading", "response": "Return True if the grading container should have access to the network"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_answer(self, task_input, language):\n        valid = True\n        need_launch = False\n        main_message = []\n        problem_messages = {}\n        error_count = 0\n        multiple_choice_error_count = 0\n        for problem in self._problems:\n            problem_is_valid, problem_main_message, problem_s_messages, problem_mc_error_count = problem.check_answer(task_input, language)\n            if problem_is_valid is None:\n                need_launch = True\n            elif problem_is_valid == False:\n                error_count += 1\n                valid = False\n            if problem_main_message is not None:\n                main_message.append(problem_main_message)\n            if problem_s_messages is not None:\n                problem_messages[problem.get_id()] = ((\"success\" if problem_is_valid else \"failed\"), problem_s_messages)\n            multiple_choice_error_count += problem_mc_error_count\n        return valid, need_launch, main_message, problem_messages, error_count, multiple_choice_error_count", "response": "Verify the answers in task_input."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new instance of the right class for a given problem.", "response": "def _create_task_problem(self, problemid, problem_content, task_problem_types):\n        \"\"\"Creates a new instance of the right class for a given problem.\"\"\"\n        # Basic checks\n        if not id_checker(problemid):\n            raise Exception(\"Invalid problem _id: \" + problemid)\n        if problem_content.get('type', \"\") not in task_problem_types:\n            raise Exception(\"Invalid type for problem \" + problemid)\n\n        return task_problem_types.get(problem_content.get('type', \"\"))(self, problemid, problem_content, self._translations)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_logging(log_level=logging.DEBUG):\n    logging.root.handlers = []  # remove possible side-effects from other libs\n    logger = logging.getLogger(\"inginious\")\n    logger.setLevel(log_level)\n    ch = logging.StreamHandler()\n    ch.setLevel(log_level)\n    formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n    ch.setFormatter(formatter)\n    logger.addHandler(ch)", "response": "Init logging\n    :param log_level: An integer representing the log level or a string representing one"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef course_menu(course, template_helper):\n    scoreboards = course.get_descriptor().get('scoreboard', [])\n\n    if scoreboards != []:\n        return str(template_helper.get_custom_renderer('frontend/plugins/scoreboard', layout=False).course_menu(course))\n    else:\n        return None", "response": "Displays the link to the scoreboards on the course page if the plugin is activated for this course"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef task_menu(course, task, template_helper):\n    scoreboards = course.get_descriptor().get('scoreboard', [])\n    try:\n        tolink = []\n        for sid, scoreboard in enumerate(scoreboards):\n            if task.get_id() in scoreboard[\"content\"]:\n                tolink.append((sid, scoreboard[\"name\"]))\n\n        if tolink:\n            return str(template_helper.get_custom_renderer('frontend/plugins/scoreboard', layout=False).task_menu(course, tolink))\n        return None\n    except:\n        return None", "response": "Displays the link to the scoreboards on the task page if the plugin is activated for this course and the task is used in scoreboards"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef GET_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        course = self.course_factory.get_course(courseid)\n        scoreboards = course.get_descriptor().get('scoreboard', [])\n\n        try:\n            names = {i: val[\"name\"] for i, val in enumerate(scoreboards)}\n        except:\n            raise web.notfound(\"Invalid configuration\")\n\n        if len(names) == 0:\n            raise web.notfound()\n\n        return self.template_helper.get_custom_renderer('frontend/plugins/scoreboard').main(course, names)", "response": "GET request handler for GET_AUTH"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the authentication information for a scoreboard.", "response": "def GET_AUTH(self, courseid, scoreboardid):  # pylint: disable=arguments-differ\n        \"\"\" GET request \"\"\"\n        course = self.course_factory.get_course(courseid)\n        scoreboards = course.get_descriptor().get('scoreboard', [])\n\n        try:\n            scoreboardid = int(scoreboardid)\n            scoreboard_name = scoreboards[scoreboardid][\"name\"]\n            scoreboard_content = scoreboards[scoreboardid][\"content\"]\n            scoreboard_reverse = bool(scoreboards[scoreboardid].get('reverse', False))\n        except:\n            raise web.notfound()\n\n        # Convert scoreboard_content\n        if isinstance(scoreboard_content, str):\n            scoreboard_content = OrderedDict([(scoreboard_content, 1)])\n        if isinstance(scoreboard_content, list):\n            scoreboard_content = OrderedDict([(entry, 1) for entry in scoreboard_content])\n        if not isinstance(scoreboard_content, OrderedDict):\n            scoreboard_content = OrderedDict(iter(scoreboard_content.items()))\n\n        # Get task names\n        task_names = {}\n        for taskid in scoreboard_content:\n            try:\n                task_names[taskid] = course.get_task(taskid).get_name(self.user_manager.session_language())\n            except:\n                raise web.notfound(\"Unknown task id \"+taskid)\n\n        # Get all submissions\n        results = self.database.submissions.find({\n            \"courseid\": courseid,\n            \"taskid\": {\"$in\": list(scoreboard_content.keys())},\n            \"custom.score\": {\"$exists\": True},\n            \"result\": \"success\"\n        }, [\"taskid\", \"username\", \"custom.score\"])\n\n        # Get best results per users(/group)\n        result_per_user = {}\n        users = set()\n        for submission in results:\n            # Be sure we have a list\n            if not isinstance(submission[\"username\"], list):\n                submission[\"username\"] = [submission[\"username\"]]\n            submission[\"username\"] = tuple(submission[\"username\"])\n\n            if submission[\"username\"] not in result_per_user:\n                result_per_user[submission[\"username\"]] = {}\n\n\n            if submission[\"taskid\"] not in result_per_user[submission[\"username\"]]:\n                result_per_user[submission[\"username\"]][submission[\"taskid\"]] = submission[\"custom\"][\"score\"]\n            else:\n                # keep best score\n                current_score = result_per_user[submission[\"username\"]][submission[\"taskid\"]]\n                new_score = submission[\"custom\"][\"score\"]\n                task_reversed = scoreboard_reverse != (scoreboard_content[submission[\"taskid\"]] < 0)\n                if task_reversed and current_score > new_score:\n                    result_per_user[submission[\"username\"]][submission[\"taskid\"]] = new_score\n                elif not task_reversed and current_score < new_score:\n                    result_per_user[submission[\"username\"]][submission[\"taskid\"]] = new_score\n\n\n            for user in submission[\"username\"]:\n                users.add(user)\n\n        # Get user names\n        users_realname = {}\n        for username, userinfo in self.user_manager.get_users_info(list(users)).items():\n            users_realname[username] = userinfo[0] if userinfo else username\n\n        # Compute overall result per user, and sort them\n        overall_result_per_user = {}\n        for key, val in result_per_user.items():\n            total = 0\n            solved = 0\n            for taskid, coef in scoreboard_content.items():\n                if taskid in val:\n                    total += val[taskid]*coef\n                    solved += 1\n            overall_result_per_user[key] = {\"total\": total, \"solved\": solved}\n        sorted_users = list(overall_result_per_user.keys())\n        sorted_users = sorted(sorted_users, key=sort_func(overall_result_per_user, scoreboard_reverse))\n\n        # Compute table\n        table = []\n\n        # Header\n        if len(scoreboard_content) == 1:\n            header = [\"\", \"Student(s)\", \"Score\"]\n            emphasized_columns = [2]\n        else:\n            header = [\"\", \"Student(s)\", \"Solved\", \"Total score\"] + [task_names[taskid] for taskid in list(scoreboard_content.keys())]\n            emphasized_columns = [2, 3]\n\n        # Lines\n        old_score = ()\n        rank = 0\n        for user in sorted_users:\n            # Increment rank if needed, and display it\n            line = []\n            if old_score != (overall_result_per_user[user][\"solved\"], overall_result_per_user[user][\"total\"]):\n                rank += 1\n                old_score = (overall_result_per_user[user][\"solved\"], overall_result_per_user[user][\"total\"])\n                line.append(rank)\n            else:\n                line.append(\"\")\n\n            # Users\n            line.append(\",\".join(sorted([users_realname[u] for u in user])))\n\n            if len(scoreboard_content) == 1:\n                line.append(overall_result_per_user[user][\"total\"])\n            else:\n                line.append(overall_result_per_user[user][\"solved\"])\n                line.append(overall_result_per_user[user][\"total\"])\n                for taskid in scoreboard_content:\n                    line.append(result_per_user[user].get(taskid, \"\"))\n\n            table.append(line)\n\n        renderer = self.template_helper.get_custom_renderer('frontend/plugins/scoreboard')\n        return renderer.scoreboard(course, scoreboardid, scoreboard_name, header, table, emphasized_columns)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfixing a bug in web. py.", "response": "def fix_webpy_cookies():\n    \"\"\"\n    Fixes a bug in web.py. See #208. PR is waiting to be merged upstream at https://github.com/webpy/webpy/pull/419\n    TODO: remove me once PR is merged upstream.\n    \"\"\"\n\n    try:\n        web.webapi.parse_cookies('a=\"test\"')  # make the bug occur\n    except NameError:\n        # monkeypatch web.py\n        SimpleCookie.iteritems = SimpleCookie.items\n        web.webapi.Cookie = namedtuple('Cookie', ['SimpleCookie', 'CookieError'])(SimpleCookie, CookieError)\n\n    web.webapi.parse_cookies('a=\"test\"')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_user_lists(self, course, classroomid):\n        tutor_list = course.get_staff()\n\n        # Determine if user is grouped or not in the classroom\n        student_list = list(self.database.classrooms.aggregate([\n            {\"$match\": {\"_id\": ObjectId(classroomid)}},\n            {\"$unwind\": \"$students\"},\n            {\"$project\": {\n                \"students\": 1,\n                \"grouped\": {\n                    \"$anyElementTrue\": {\n                        \"$map\": {\n                            \"input\": \"$groups.students\",\n                            \"as\": \"group\",\n                            \"in\": {\n                                \"$anyElementTrue\": {\n                                    \"$map\": {\n                                        \"input\": \"$$group\",\n                                        \"as\": \"groupmember\",\n                                        \"in\": {\"$eq\": [\"$$groupmember\", \"$students\"]}\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }}\n        ]))\n\n        student_list = dict([(student[\"students\"], student) for student in student_list])\n\n        other_students = [entry['students'] for entry in list(self.database.classrooms.aggregate([\n            {\"$match\": {\"courseid\": course.get_id(), \"_id\": {\"$ne\": ObjectId(classroomid)}}},\n            {\"$unwind\": \"$students\"},\n            {\"$project\": {\"_id\": 0, \"students\": 1}}\n        ]))]\n\n        users_info = self.user_manager.get_users_info(other_students + list(student_list.keys()) + tutor_list)\n\n        # Order the non-registered students\n        other_students = sorted(other_students, key=lambda val: ((\"0\"+users_info[val][0]) if users_info[val] else (\"1\"+val)))\n\n        return student_list, tutor_list, other_students, users_info", "response": "Get the available student and tutor lists for the classroom edition"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the classroom and returns a list of errored students", "response": "def update_classroom(self, course, classroomid, new_data):\n        \"\"\" Update classroom and returns a list of errored students\"\"\"\n        student_list, tutor_list, other_students, _ = self.get_user_lists(course, classroomid)\n\n        # Check tutors\n        new_data[\"tutors\"] = [tutor for tutor in map(str.strip, new_data[\"tutors\"]) if tutor in tutor_list]\n\n        students, groups, errored_students = [], [], []\n\n        new_data[\"students\"] = map(str.strip, new_data[\"students\"])\n\n        # Check the students\n        for student in new_data[\"students\"]:\n            if student in student_list:\n                students.append(student)\n            else:\n                if student in other_students:\n                    # Remove user from the other classroom\n                    self.database.classrooms.find_one_and_update({\"courseid\": course.get_id(), \"groups.students\": student},\n                                                                 {\"$pull\": {\"groups.$.students\": student, \"students\": student}})\n                    self.database.classrooms.find_one_and_update({\"courseid\": course.get_id(), \"students\": student}, {\"$pull\": {\"students\": student}})\n                    students.append(student)\n                else:\n                    # Check if user can be registered\n                    user_info = self.user_manager.get_user_info(student)\n                    if user_info is None or student in tutor_list:\n                        errored_students.append(student)\n                    else:\n                        students.append(student)\n\n        removed_students = [student for student in student_list if student not in new_data[\"students\"]]\n        self.database.classrooms.find_one_and_update({\"courseid\": course.get_id(), \"default\": True},\n                                                     {\"$push\": {\"students\": {\"$each\": removed_students}}})\n\n        new_data[\"students\"] = students\n\n        # Check the groups\n        for group in new_data[\"groups\"]:\n            group[\"students\"] = [student for student in map(str.strip, group[\"students\"]) if student in new_data[\"students\"]]\n            if len(group[\"students\"]) <= group[\"size\"]:\n                groups.append(group)\n\n        new_data[\"groups\"] = groups\n\n        classroom = self.database.classrooms.find_one_and_update(\n            {\"_id\": ObjectId(classroomid)},\n            {\"$set\": {\"description\": new_data[\"description\"],\n                      \"students\": students, \"tutors\": new_data[\"tutors\"],\n                      \"groups\": groups}}, return_document=ReturnDocument.AFTER)\n\n        return classroom, errored_students"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse HTML string and returns a string with the HTML translations.", "response": "def html(cls, string, show_everything=False, translation=gettext.NullTranslations()):  # pylint: disable=unused-argument\n        \"\"\"Parses HTML\"\"\"\n        out, _ = tidylib.tidy_fragment(string)\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a reStructuredText string and returns a string with the HTML.", "response": "def rst(cls, string, show_everything=False, translation=gettext.NullTranslations(), initial_header_level=3, debug=False):\n        \"\"\"Parses reStructuredText\"\"\"\n        overrides = {\n            'initial_header_level': initial_header_level,\n            'doctitle_xform': False,\n            'syntax_highlight': 'none',\n            'force_show_hidden_until': show_everything,\n            'translation': translation,\n            'math_output': 'MathJax'\n        }\n        if debug:\n            overrides['halt_level'] = 2\n            overrides['traceback'] = True\n        parts = core.publish_parts(source=string, writer=_CustomHTMLWriter(), settings_overrides=overrides)\n        return parts['body_pre_docinfo'] + parts['fragment']"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nposts request for the course", "response": "def POST_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        \"\"\" POST request \"\"\"\n        course, __ = self.get_course_and_check_rights(courseid)\n        data = web.input(task=[])\n\n        if \"task\" in data:\n            # Change tasks order\n            for index, taskid in enumerate(data[\"task\"]):\n                try:\n                    task = self.task_factory.get_task_descriptor_content(courseid, taskid)\n                    task[\"order\"] = index\n                    self.task_factory.update_task_descriptor_content(courseid, taskid, task)\n                except:\n                    pass\n\n        return self.page(course)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all data and display the page", "response": "def page(self, course):\n        \"\"\" Get all data and display the page \"\"\"\n        data = list(self.database.user_tasks.aggregate(\n            [\n                {\n                    \"$match\":\n                        {\n                            \"courseid\": course.get_id(),\n                            \"username\": {\"$in\": self.user_manager.get_course_registered_users(course, False)}\n                        }\n                },\n                {\n                    \"$group\":\n                        {\n                            \"_id\": \"$taskid\",\n                            \"viewed\": {\"$sum\": 1},\n                            \"attempted\": {\"$sum\": {\"$cond\": [{\"$ne\": [\"$tried\", 0]}, 1, 0]}},\n                            \"attempts\": {\"$sum\": \"$tried\"},\n                            \"succeeded\": {\"$sum\": {\"$cond\": [\"$succeeded\", 1, 0]}}\n                        }\n                }\n            ]))\n\n        # Load tasks and verify exceptions\n        files = self.task_factory.get_readable_tasks(course)\n        output = {}\n        errors = []\n        for task in files:\n            try:\n                output[task] = course.get_task(task)\n            except Exception as inst:\n                errors.append({\"taskid\": task, \"error\": str(inst)})\n        tasks = OrderedDict(sorted(list(output.items()), key=lambda t: (t[1].get_order(), t[1].get_id())))\n\n        # Now load additional informations\n        result = OrderedDict()\n        for taskid in tasks:\n            result[taskid] = {\"name\": tasks[taskid].get_name(self.user_manager.session_language()), \"viewed\": 0, \"attempted\": 0, \"attempts\": 0, \"succeeded\": 0,\n                              \"url\": self.submission_url_generator(taskid)}\n        for entry in data:\n            if entry[\"_id\"] in result:\n                result[entry[\"_id\"]][\"viewed\"] = entry[\"viewed\"]\n                result[entry[\"_id\"]][\"attempted\"] = entry[\"attempted\"]\n                result[entry[\"_id\"]][\"attempts\"] = entry[\"attempts\"]\n                result[entry[\"_id\"]][\"succeeded\"] = entry[\"succeeded\"]\n        if \"csv\" in web.input():\n            return make_csv(result)\n        return self.template_helper.get_renderer().course_admin.task_list(course, result, errors)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef GET_AUTH(self, courseid, taskid):  # pylint: disable=arguments-differ\n        if not id_checker(taskid):\n            raise Exception(\"Invalid task id\")\n\n        self.get_course_and_check_rights(courseid, allow_all_staff=False)\n\n        request = web.input()\n        if request.get(\"action\") == \"download\" and request.get('path') is not None:\n            return self.action_download(courseid, taskid, request.get('path'))\n        elif request.get(\"action\") == \"delete\" and request.get('path') is not None:\n            return self.action_delete(courseid, taskid, request.get('path'))\n        elif request.get(\"action\") == \"rename\" and request.get('path') is not None and request.get('new_path') is not None:\n            return self.action_rename(courseid, taskid, request.get('path'), request.get('new_path'))\n        elif request.get(\"action\") == \"create\" and request.get('path') is not None:\n            return self.action_create(courseid, taskid, request.get('path'))\n        elif request.get(\"action\") == \"edit\" and request.get('path') is not None:\n            return self.action_edit(courseid, taskid, request.get('path'))\n        else:\n            return self.show_tab_file(courseid, taskid)", "response": "Get a task s author information."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nuploading or modify a file", "response": "def POST_AUTH(self, courseid, taskid):  # pylint: disable=arguments-differ\n        \"\"\" Upload or modify a file \"\"\"\n        if not id_checker(taskid):\n            raise Exception(\"Invalid task id\")\n\n        self.get_course_and_check_rights(courseid, allow_all_staff=False)\n\n        request = web.input(file={})\n        if request.get(\"action\") == \"upload\" and request.get('path') is not None and request.get('file') is not None:\n            return self.action_upload(courseid, taskid, request.get('path'), request.get('file'))\n        elif request.get(\"action\") == \"edit_save\" and request.get('path') is not None and request.get('content') is not None:\n            return self.action_edit_save(courseid, taskid, request.get('path'), request.get('content'))\n        else:\n            return self.show_tab_file(courseid, taskid)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_tab_file(self, courseid, taskid, error=None):\n        return self.template_helper.get_renderer(False).course_admin.edit_tabs.files(\n            self.course_factory.get_course(courseid), taskid, self.get_task_filelist(self.task_factory, courseid, taskid), error)", "response": "Show the file tab"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_task_filelist(cls, task_factory, courseid, taskid):\n        task_fs = task_factory.get_task_fs(courseid, taskid)\n        if not task_fs.exists():\n            return []\n\n        tmp_out = {}\n        entries = task_fs.list(True, True, True)\n        for entry in entries:\n            if os.path.splitext(entry)[0] == \"task\" and os.path.splitext(entry)[1][1:] in task_factory.get_available_task_file_extensions():\n                continue\n\n            data = entry.split(\"/\")\n            is_directory = False\n            if data[-1] == \"\":\n                is_directory = True\n                data = data[0:len(data)-1]\n            cur_pos = 0\n            tree_pos = tmp_out\n            while cur_pos != len(data):\n                if data[cur_pos] not in tree_pos:\n                    tree_pos[data[cur_pos]] = {} if is_directory or cur_pos != len(data) - 1 else None\n                tree_pos = tree_pos[data[cur_pos]]\n                cur_pos += 1\n\n        def recur_print(current, level, current_name):\n            iteritems = sorted(current.items())\n            # First, the files\n            recur_print.flattened += [(level, False, f, current_name+\"/\"+f) for f, t in iteritems if t is None]\n            # Then, the dirs\n            for name, sub in iteritems:\n                if sub is not None:\n                    recur_print.flattened.append((level, True, name, current_name+\"/\"+name+\"/\"))\n                    recur_print(sub, level + 1, current_name + \"/\" + name)\n        recur_print.flattened = []\n        recur_print(tmp_out, 0, '')\n        return recur_print.flattened", "response": "Returns a flattened version of all the files inside the task directory excluding the files task."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef verify_path(self, courseid, taskid, path, new_path=False):\n        task_fs = self.task_factory.get_task_fs(courseid, taskid)\n        # verify that the dir exists\n        if not task_fs.exists():\n            return None\n\n        # all path given to this part of the application must start with a \"/\", let's remove it\n        if not path.startswith(\"/\"):\n            return None\n        path = path[1:len(path)]\n\n        if \"..\" in path:\n            return None\n\n        if task_fs.exists(path) == new_path:\n            return None\n\n        # do not allow touching the task.* file\n        if os.path.splitext(path)[0] == \"task\" and os.path.splitext(path)[1][1:] in \\\n                self.task_factory.get_available_task_file_extensions():\n            return None\n\n        # do not allow hidden dir/files\n        if path != \".\":\n            for i in path.split(os.path.sep):\n                if i.startswith(\".\"):\n                    return None\n        return path", "response": "Verify that the path is valid and return the real wanted path or None if the path is not valid or not allowed"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves an edited file", "response": "def action_edit_save(self, courseid, taskid, path, content):\n        \"\"\" Save an edited file \"\"\"\n        wanted_path = self.verify_path(courseid, taskid, path)\n        if wanted_path is None:\n            return json.dumps({\"error\": True})\n        try:\n            self.task_factory.get_task_fs(courseid, taskid).put(wanted_path, content.encode(\"utf-8\"))\n            return json.dumps({\"ok\": True})\n        except:\n            return json.dumps({\"error\": True})"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nuploads a file to the task store", "response": "def action_upload(self, courseid, taskid, path, fileobj):\n        \"\"\" Upload a file \"\"\"\n        # the path is given by the user. Let's normalize it\n        path = path.strip()\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n        wanted_path = self.verify_path(courseid, taskid, path, True)\n        if wanted_path is None:\n            return self.show_tab_file(courseid, taskid, _(\"Invalid new path\"))\n\n        task_fs = self.task_factory.get_task_fs(courseid, taskid)\n        try:\n            task_fs.put(wanted_path, fileobj.file.read())\n        except:\n            return self.show_tab_file(courseid, taskid, _(\"An error occurred while writing the file\"))\n        return self.show_tab_file(courseid, taskid)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a file or a directory", "response": "def action_create(self, courseid, taskid, path):\n        \"\"\" Delete a file or a directory \"\"\"\n        # the path is given by the user. Let's normalize it\n        path = path.strip()\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n\n        want_directory = path.endswith(\"/\")\n\n        wanted_path = self.verify_path(courseid, taskid, path, True)\n        if wanted_path is None:\n            return self.show_tab_file(courseid, taskid, _(\"Invalid new path\"))\n\n        task_fs = self.task_factory.get_task_fs(courseid, taskid)\n        if want_directory:\n            task_fs.from_subfolder(wanted_path).ensure_exists()\n        else:\n            task_fs.put(wanted_path, b\"\")\n        return self.show_tab_file(courseid, taskid)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrename a file or a directory", "response": "def action_rename(self, courseid, taskid, path, new_path):\n        \"\"\" Delete a file or a directory \"\"\"\n        # normalize\n        path = path.strip()\n        new_path = new_path.strip()\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n        if not new_path.startswith(\"/\"):\n            new_path = \"/\" + new_path\n\n        old_path = self.verify_path(courseid, taskid, path)\n        if old_path is None:\n            return self.show_tab_file(courseid, taskid, _(\"Internal error\"))\n\n        wanted_path = self.verify_path(courseid, taskid, new_path, True)\n        if wanted_path is None:\n            return self.show_tab_file(courseid, taskid, _(\"Invalid new path\"))\n\n        try:\n            self.task_factory.get_task_fs(courseid, taskid).move(old_path, wanted_path)\n            return self.show_tab_file(courseid, taskid)\n        except:\n            return self.show_tab_file(courseid, taskid, _(\"An error occurred while moving the files\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes a file or a directory", "response": "def action_delete(self, courseid, taskid, path):\n        \"\"\" Delete a file or a directory \"\"\"\n        # normalize\n        path = path.strip()\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n\n        wanted_path = self.verify_path(courseid, taskid, path)\n        if wanted_path is None:\n            return self.show_tab_file(courseid, taskid, _(\"Internal error\"))\n\n        # special case: cannot delete current directory of the task\n        if \"/\" == wanted_path:\n            return self.show_tab_file(courseid, taskid, _(\"Internal error\"))\n\n        try:\n            self.task_factory.get_task_fs(courseid, taskid).delete(wanted_path)\n            return self.show_tab_file(courseid, taskid)\n        except:\n            return self.show_tab_file(courseid, taskid, _(\"An error occurred while deleting the files\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads a file or a directory", "response": "def action_download(self, courseid, taskid, path):\n        \"\"\" Download a file or a directory \"\"\"\n\n        wanted_path = self.verify_path(courseid, taskid, path)\n        if wanted_path is None:\n            raise web.notfound()\n\n        task_fs = self.task_factory.get_task_fs(courseid, taskid)\n        (method, mimetype_or_none, file_or_url) = task_fs.distribute(wanted_path)\n\n        if method == \"local\":\n            web.header('Content-Type', mimetype_or_none)\n            return file_or_url\n        elif method == \"url\":\n            raise web.redirect(file_or_url)\n        else:\n            raise web.notfound()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a JSON or YAML file.", "response": "def load_json_or_yaml(file_path):\n    \"\"\" Load JSON or YAML depending on the file extension. Returns a dict \"\"\"\n    with open(file_path, \"r\") as f:\n        if os.path.splitext(file_path)[1] == \".json\":\n            return json.load(f)\n        else:\n            return inginious.common.custom_yaml.load(f)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload JSON or YAML depending on the file extension. Returns a dict.", "response": "def loads_json_or_yaml(file_path, content):\n    \"\"\" Load JSON or YAML depending on the file extension. Returns a dict \"\"\"\n    if os.path.splitext(file_path)[1] == \".json\":\n        return json.loads(content)\n    else:\n        return inginious.common.custom_yaml.load(content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites JSON or YAML depending on the file extension.", "response": "def write_json_or_yaml(file_path, content):\n    \"\"\" Write JSON or YAML depending on the file extension. \"\"\"\n    with codecs.open(file_path, \"w\", \"utf-8\") as f:\n        f.write(get_json_or_yaml(file_path, content))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating JSON or YAML depending on the file extension.", "response": "def get_json_or_yaml(file_path, content):\n    \"\"\" Generate JSON or YAML depending on the file extension. \"\"\"\n    if os.path.splitext(file_path)[1] == \".json\":\n        return json.dumps(content, sort_keys=False, indent=4, separators=(',', ': '))\n    else:\n        return inginious.common.custom_yaml.dump(content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a hash of the file content", "response": "def hash_file(fileobj):\n    \"\"\"\n    :param fileobj: a file object\n    :return: a hash of the file content\n    \"\"\"\n    hasher = hashlib.md5()\n    buf = fileobj.read(65536)\n    while len(buf) > 0:\n        hasher.update(buf)\n        buf = fileobj.read(65536)\n    return hasher.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef directory_content_with_hash(directory):\n    output = {}\n    for root, _, filenames in os.walk(directory):\n        for filename in filenames:\n            p = os.path.join(root, filename)\n            file_stat = os.stat(p)\n            with open(p, 'rb') as f:\n                output[os.path.relpath(p, directory)] = (hash_file(f), file_stat.st_mode)\n    return output", "response": "returns a dict of the files in the directory with the hash of the file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the session variables.", "response": "def _set_session(self, username, realname, email, language):\n        \"\"\" Init the session. Preserves potential LTI information. \"\"\"\n        self._session.loggedin = True\n        self._session.email = email\n        self._session.username = username\n        self._session.realname = realname\n        self._session.language = language\n        self._session.token = None\n        if \"lti\" not in self._session:\n            self._session.lti = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_lti_session(self, user_id, roles, realname, email, course_id, task_id, consumer_key, outcome_service_url,\n                           outcome_result_id, tool_name, tool_desc, tool_url, context_title, context_label):\n        \"\"\" Creates an LTI cookieless session. Returns the new session id\"\"\"\n\n        self._destroy_session()  # don't forget to destroy the current session (cleans the threaded dict from web.py)\n        self._session.load('')  # creates a new cookieless session\n        session_id = self._session.session_id\n\n        self._session.lti = {\n            \"email\": email,\n            \"username\": user_id,\n            \"realname\": realname,\n            \"roles\": roles,\n            \"task\": (course_id, task_id),\n            \"outcome_service_url\": outcome_service_url,\n            \"outcome_result_id\": outcome_result_id,\n            \"consumer_key\": consumer_key,\n            \"context_title\": context_title,\n            \"context_label\": context_label,\n            \"tool_description\": tool_desc,\n            \"tool_name\": tool_name,\n            \"tool_url\": tool_url\n        }\n\n        return session_id", "response": "Creates a LTI cookieless session. Returns the new session id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nauthenticate the user in database", "response": "def auth_user(self, username, password):\n        \"\"\"\n        Authenticate the user in database\n        :param username: Username/Login\n        :param password: User password\n        :return: Returns a dict represrnting the user\n        \"\"\"\n        password_hash = hashlib.sha512(password.encode(\"utf-8\")).hexdigest()\n\n        user = self._database.users.find_one(\n            {\"username\": username, \"password\": password_hash, \"activate\": {\"$exists\": False}})\n\n        return user if user is not None and self.connect_user(username, user[\"realname\"], user[\"email\"], user[\"language\"]) else None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_user(self, username, realname, email, language):\n\n        self._database.users.update_one({\"email\": email}, {\"$set\": {\"realname\": realname, \"username\": username, \"language\": language}},\n                                        upsert=True)\n        self._logger.info(\"User %s connected - %s - %s - %s\", username, realname, email, web.ctx.ip)\n        self._set_session(username, realname, email, language)\n        return True", "response": "Connects a user to the database"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef disconnect_user(self):\n        if self.session_logged_in():\n            self._logger.info(\"User %s disconnected - %s - %s - %s\", self.session_username(), self.session_realname(), self.session_email(), web.ctx.ip)\n        self._destroy_session()", "response": "Disconnects the user from the session"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a dict of user info for a list of usernames", "response": "def get_users_info(self, usernames):\n        \"\"\"\n        :param usernames: a list of usernames\n        :return: a dict, in the form {username: val}, where val is either None if the user cannot be found, or a tuple (realname, email)\n        \"\"\"\n        retval = {username: None for username in usernames}\n        remaining_users = usernames\n\n        infos = self._database.users.find({\"username\": {\"$in\": remaining_users}})\n        for info in infos:\n            retval[info[\"username\"]] = (info[\"realname\"], info[\"email\"])\n\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_user_info(self, username):\n        info = self.get_users_info([username])\n        return info[username] if info is not None else None", "response": "returns a tuple of realname email if the user can be found None otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the API key assigned to a given user.", "response": "def get_user_api_key(self, username, create=True):\n        \"\"\"\n        Get the API key of a given user.\n        API keys are generated on demand.\n        :param username:\n        :param create: Create the API key if none exists yet\n        :return: the API key assigned to the user, or None if none exists and create is False.\n        \"\"\"\n        retval = self._database.users.find_one({\"username\": username}, {\"apikey\": 1})\n        if \"apikey\" not in retval and create:\n            apikey = self.generate_api_key()\n            self._database.users.update_one({\"username\": username}, {\"$set\": {\"apikey\": apikey}})\n        elif \"apikey\" not in retval:\n            apikey = None\n        else:\n            apikey = retval[\"apikey\"]\n        return apikey"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the data for the specified users for a specific course.", "response": "def get_course_caches(self, usernames, course):\n        \"\"\"\n        :param username: List of username for which we want info. If usernames is None, data from all users will be returned.\n        :param course: A Course object\n        :return:\n            Returns data of the specified users for a specific course. users is a list of username.\n\n            The returned value is a dict:\n\n            ::\n\n                {\"username\": {\"task_tried\": 0, \"total_tries\": 0, \"task_succeeded\": 0, \"task_grades\":{\"task_1\": 100.0, \"task_2\": 0.0, ...}}}\n\n            Note that only the task already seen at least one time will be present in the dict task_grades.\n        \"\"\"\n\n        match = {\"courseid\": course.get_id()}\n        if usernames is not None:\n            match[\"username\"] = {\"$in\": usernames}\n\n        tasks = course.get_tasks()\n        taskids = tasks.keys()\n        match[\"taskid\"] = {\"$in\": list(taskids)}\n\n        data = list(self._database.user_tasks.aggregate(\n            [\n                {\"$match\": match},\n                {\"$group\": {\n                    \"_id\": \"$username\",\n                    \"task_tried\": {\"$sum\": {\"$cond\": [{\"$ne\": [\"$tried\", 0]}, 1, 0]}},\n                    \"total_tries\": {\"$sum\": \"$tried\"},\n                    \"task_succeeded\": {\"$addToSet\": {\"$cond\": [\"$succeeded\", \"$taskid\", False]}},\n                    \"task_grades\": {\"$addToSet\": {\"taskid\": \"$taskid\", \"grade\": \"$grade\"}}\n                }}\n            ]))\n\n        student_visible_taskids = [taskid for taskid, task in tasks.items() if task.get_accessible_time().after_start()]\n        course_staff = course.get_staff()\n        retval = {username: {\"task_succeeded\": 0, \"task_grades\": [], \"grade\": 0} for username in usernames}\n\n        for result in data:\n            username = result[\"_id\"]\n            visible_tasks = student_visible_taskids if username not in course_staff else taskids\n            result[\"task_succeeded\"] = len(set(result[\"task_succeeded\"]).intersection(visible_tasks))\n            result[\"task_grades\"] = {dg[\"taskid\"]: dg[\"grade\"] for dg in result[\"task_grades\"] if dg[\"taskid\"] in visible_tasks}\n\n            total_weight = 0\n            grade = 0\n            for task_id in visible_tasks:\n                total_weight += tasks[task_id].get_grading_weight()\n                grade += result[\"task_grades\"].get(task_id, 0.0) * tasks[task_id].get_grading_weight()\n\n            result[\"grade\"] = round(grade / total_weight) if total_weight > 0 else 0\n            retval[username] = result\n\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the cache for the given username courseid taskid", "response": "def get_task_cache(self, username, courseid, taskid):\n        \"\"\"\n        Shorthand for get_task_caches([username], courseid, taskid)[username]\n        \"\"\"\n        return self.get_task_caches([username], courseid, taskid)[username]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the cache for a list of usernames.", "response": "def get_task_caches(self, usernames, courseid, taskid):\n        \"\"\"\n        :param usernames: List of username for which we want info. If usernames is None, data from all users will be returned.\n        :param courseid: the course id\n        :param taskid: the task id\n        :return: A dict in the form:\n\n            ::\n\n                {\n                    \"username\": {\n                        \"courseid\": courseid,\n                        \"taskid\": taskid,\n                        \"tried\": 0,\n                        \"succeeded\": False,\n                        \"grade\": 0.0\n                    }\n                }\n        \"\"\"\n        match = {\"courseid\": courseid, \"taskid\": taskid}\n        if usernames is not None:\n            match[\"username\"] = {\"$in\": usernames}\n\n        data = self._database.user_tasks.find(match)\n        retval = {username: None for username in usernames}\n        for result in data:\n            username = result[\"username\"]\n            del result[\"username\"]\n            del result[\"_id\"]\n            retval[username] = result\n\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets in the database that the user has viewed this task", "response": "def user_saw_task(self, username, courseid, taskid):\n        \"\"\" Set in the database that the user has viewed this task \"\"\"\n        self._database.user_tasks.update({\"username\": username, \"courseid\": courseid, \"taskid\": taskid},\n                                         {\"$setOnInsert\": {\"username\": username, \"courseid\": courseid, \"taskid\": taskid,\n                                                           \"tried\": 0, \"succeeded\": False, \"grade\": 0.0, \"submissionid\": None, \"state\": \"\"}},\n                                         upsert=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates user stats with a new submission", "response": "def update_user_stats(self, username, task, submission, result_str, grade, state, newsub):\n        \"\"\" Update stats with a new submission \"\"\"\n        self.user_saw_task(username, submission[\"courseid\"], submission[\"taskid\"])\n\n        if newsub:\n            old_submission = self._database.user_tasks.find_one_and_update(\n                {\"username\": username, \"courseid\": submission[\"courseid\"], \"taskid\": submission[\"taskid\"]}, {\"$inc\": {\"tried\": 1, \"tokens.amount\": 1}})\n\n            # Check if the submission is the default download\n            set_default = task.get_evaluate() == 'last' or \\\n                          (task.get_evaluate() == 'student' and old_submission is None) or \\\n                          (task.get_evaluate() == 'best' and old_submission.get('grade', 0.0) <= grade)\n\n            if set_default:\n                self._database.user_tasks.find_one_and_update(\n                    {\"username\": username, \"courseid\": submission[\"courseid\"], \"taskid\": submission[\"taskid\"]},\n                    {\"$set\": {\"succeeded\": result_str == \"success\", \"grade\": grade, \"state\": state, \"submissionid\": submission['_id']}})\n        else:\n            old_submission = self._database.user_tasks.find_one(\n                {\"username\": username, \"courseid\": submission[\"courseid\"], \"taskid\": submission[\"taskid\"]})\n\n            if task.get_evaluate() == 'best':  # if best, update cache consequently (with best submission)\n                def_sub = list(self._database.submissions.find({\n                    \"username\": username, \"courseid\": task.get_course_id(),\n                    \"taskid\": task.get_id(), \"status\": \"done\"}\n                ).sort([(\"grade\", pymongo.DESCENDING), (\"submitted_on\", pymongo.DESCENDING)]).limit(1))\n\n                if len(def_sub) > 0:\n                    self._database.user_tasks.find_one_and_update(\n                        {\"username\": username, \"courseid\": submission[\"courseid\"], \"taskid\": submission[\"taskid\"]},\n                        {\"$set\": {\n                            \"succeeded\": def_sub[0][\"result\"] == \"success\",\n                            \"grade\": def_sub[0][\"grade\"],\n                            \"state\": def_sub[0][\"state\"],\n                            \"submissionid\": def_sub[0]['_id']\n                        }})\n            elif old_submission[\"submissionid\"] == submission[\"_id\"]:  # otherwise, update cache if needed\n                self._database.user_tasks.find_one_and_update(\n                    {\"username\": username, \"courseid\": submission[\"courseid\"], \"taskid\": submission[\"taskid\"]},\n                    {\"$set\": {\n                        \"succeeded\": submission[\"result\"] == \"success\",\n                        \"grade\": submission[\"grade\"],\n                        \"state\": submission[\"state\"]\n                    }})"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef task_is_visible_by_user(self, task, username=None, lti=None):\n        if username is None:\n            username = self.session_username()\n\n        return (self.course_is_open_to_user(task.get_course(), username, lti) and task.get_accessible_time().after_start()) or \\\n               self.has_staff_rights_on_course(task.get_course(), username)", "response": "Returns True if the task is visible by the user."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the user can submit his work for this task", "response": "def task_can_user_submit(self, task, username=None, only_check=None, lti=None):\n        \"\"\" returns true if the user can submit his work for this task\n            :param only_check : only checks for 'groups', 'tokens', or None if all checks\n            :param lti: indicates if the user is currently in a LTI session or not.\n            - None to ignore the check\n            - True to indicate the user is in a LTI session\n            - False to indicate the user is not in a LTI session\n            - \"auto\" to enable the check and take the information from the current session\n        \"\"\"\n        if username is None:\n            username = self.session_username()\n\n        # Check if course access is ok\n        course_registered = self.course_is_open_to_user(task.get_course(), username, lti)\n        # Check if task accessible to user\n        task_accessible = task.get_accessible_time().is_open()\n        # User has staff rights ?\n        staff_right = self.has_staff_rights_on_course(task.get_course(), username)\n\n        # Check for group\n        aggregation = self._database.aggregations.find_one(\n            {\"courseid\": task.get_course_id(), \"groups.students\": self.session_username()},\n            {\"groups\": {\"$elemMatch\": {\"students\": self.session_username()}}})\n\n        if not only_check or only_check == 'groups':\n            group_filter = (aggregation is not None and task.is_group_task()) or not task.is_group_task()\n        else:\n            group_filter = True\n\n        students = aggregation[\"groups\"][0][\"students\"] if (aggregation is not None and task.is_group_task()) else [self.session_username()]\n\n\n        # Check for token availability\n        enough_tokens = True\n        timenow = datetime.now()\n        submission_limit = task.get_submission_limit()\n        if not only_check or only_check == 'tokens':\n            if submission_limit == {\"amount\": -1, \"period\": -1}:\n                # no token limits\n                enough_tokens = True\n            else:\n                # select users with a cache for this particular task\n                user_tasks = list(self._database.user_tasks.find({\"courseid\": task.get_course_id(),\n                                                                  \"taskid\": task.get_id(),\n                                                                  \"username\": {\"$in\": students}}))\n\n                # verify that they all can submit\n                def check_tokens_for_user_task(user_task):\n                    token_dict = user_task.get(\"tokens\", {\"amount\": 0, \"date\": datetime.fromtimestamp(0)})\n                    tokens_ok = token_dict.get(\"amount\", 0) < submission_limit[\"amount\"]\n                    date_limited = submission_limit[\"period\"] > 0\n                    need_reset = token_dict.get(\"date\", datetime.fromtimestamp(0)) < timenow - timedelta(hours=submission_limit[\"period\"])\n\n                    if date_limited and need_reset:\n                        # time limit for the tokens is reached; reset the tokens\n                        self._database.user_tasks.find_one_and_update(user_task, {\"$set\": {\"tokens\": {\"amount\": 0, \"date\": datetime.now()}}})\n                        return True\n                    elif tokens_ok:\n                        return True\n                    else:\n                        return False\n\n                enough_tokens = reduce(lambda old,user_task: old and check_tokens_for_user_task(user_task), user_tasks, True)\n\n        return (course_registered and task_accessible and group_filter and enough_tokens) or staff_right"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_course_aggregations(self, course):\n        return natsorted(list(self._database.aggregations.find({\"courseid\": course.get_id()})), key=lambda x: x[\"description\"])", "response": "Returns a list of the course aggregations"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the classroom whose username belongs to", "response": "def get_course_user_aggregation(self, course, username=None):\n        \"\"\" Returns the classroom whose username belongs to\n        :param course: a Course object\n        :param username: The username of the user that we want to register. If None, uses self.session_username()\n        :return: the classroom description\n        \"\"\"\n        if username is None:\n            username = self.session_username()\n\n        return self._database.aggregations.find_one({\"courseid\": course.get_id(), \"students\": username})"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters a user to the course :param course: a Course object :param username: The username of the user that we want to register. If None, uses self.session_username() :param password: Password for the course. Needed if course.is_password_needed_for_registration() and force != True :param force: Force registration :return: True if the registration succeeded, False else", "response": "def course_register_user(self, course, username=None, password=None, force=False):\n        \"\"\"\n        Register a user to the course\n        :param course: a Course object\n        :param username: The username of the user that we want to register. If None, uses self.session_username()\n        :param password: Password for the course. Needed if course.is_password_needed_for_registration() and force != True\n        :param force: Force registration\n        :return: True if the registration succeeded, False else\n        \"\"\"\n        if username is None:\n            username = self.session_username()\n\n        user_info = self._database.users.find_one({\"username\":username})\n\n        # Do not continue registering the user in the course if username is empty.\n        if not username:\n            return False\n\n        if not force:\n            if not course.is_registration_possible(user_info):\n                return False\n            if course.is_password_needed_for_registration() and course.get_registration_password() != password:\n                return False\n        if self.course_is_user_registered(course, username):\n            return False  # already registered?\n\n        aggregation = self._database.aggregations.find_one({\"courseid\": course.get_id(), \"default\": True})\n        if aggregation is None:\n            self._database.aggregations.insert({\"courseid\": course.get_id(), \"description\": \"Default classroom\",\n                                              \"students\": [username], \"tutors\": [], \"groups\": [], \"default\": True})\n        else:\n            self._database.aggregations.find_one_and_update({\"courseid\": course.get_id(), \"default\": True},\n                                                          {\"$push\": {\"students\": username}})\n\n        self._logger.info(\"User %s registered to course %s\", username, course.get_id())\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef course_unregister_user(self, course, username=None):\n        if username is None:\n            username = self.session_username()\n\n        # Needed if user belongs to a group\n        self._database.aggregations.find_one_and_update(\n            {\"courseid\": course.get_id(), \"groups.students\": username},\n            {\"$pull\": {\"groups.$.students\": username, \"students\": username}})\n\n        # If user doesn't belong to a group, will ensure correct deletion\n        self._database.aggregations.find_one_and_update(\n            {\"courseid\": course.get_id(), \"students\": username},\n            {\"$pull\": {\"students\": username}})\n\n        self._logger.info(\"User %s unregistered from course %s\", username, course.get_id())", "response": "Unregisters a user from the course"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef course_is_open_to_user(self, course, username=None, lti=None):\n        if username is None:\n            username = self.session_username()\n        if lti == \"auto\":\n            lti = self.session_lti_info() is not None\n\n        if self.has_staff_rights_on_course(course, username):\n            return True\n\n        if not course.get_accessibility().is_open() or (not self.course_is_user_registered(course, username) and not course.allow_preview()):\n            return False\n\n        if lti and course.is_lti() != lti:\n            return False\n\n        if lti is False and course.is_lti():\n            return not course.lti_send_back_grade()\n\n        return True", "response": "Checks if a user is open to a course."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef course_is_user_registered(self, course, username=None):\n        if username is None:\n            username = self.session_username()\n\n        if self.has_staff_rights_on_course(course, username):\n            return True\n\n        return self._database.aggregations.find_one({\"students\": username, \"courseid\": course.get_id()}) is not None", "response": "Checks if a user is registered"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_course_registered_users(self, course, with_admins=True):\n\n        l = [entry['students'] for entry in list(self._database.aggregations.aggregate([\n            {\"$match\": {\"courseid\": course.get_id()}},\n            {\"$unwind\": \"$students\"},\n            {\"$project\": {\"_id\": 0, \"students\": 1}}\n        ]))]\n        if with_admins:\n            return list(set(l + course.get_staff()))\n        else:\n            return l", "response": "Get all the users that are registered to a course"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef user_is_superadmin(self, username=None):\n        if username is None:\n            username = self.session_username()\n\n        return username in self._superadmins", "response": "check if the user is superadmin"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_admin_rights_on_course(self, course, username=None, include_superadmins=True):\n        if username is None:\n            username = self.session_username()\n\n        return (username in course.get_admins()) or (include_superadmins and self.user_is_superadmin(username))", "response": "Checks if a user can be considered as having admin rights on a course"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if a user can be considered as having staff rights on a course.", "response": "def has_staff_rights_on_course(self, course, username=None, include_superadmins=True):\n        \"\"\"\n        Check if a user can be considered as having staff rights for a course\n        :type course: webapp.custom.courses.WebAppCourse\n        :param username: the username. If None, the username of the currently logged in user is taken\n        :param include_superadmins: Boolean indicating if superadmins should be taken into account\n        :return: True if the user has staff rights, False else\n        \"\"\"\n        if username is None:\n            username = self.session_username()\n\n        return (username in course.get_staff()) or (include_superadmins and self.user_is_superadmin(username))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the accessible time of this task", "response": "def get_accessible_time(self, plugin_override=True):\n        \"\"\"  Get the accessible time of this task \"\"\"\n        vals = self._hook_manager.call_hook('task_accessibility', course=self.get_course(), task=self, default=self._accessible)\n        return vals[0] if len(vals) and plugin_override else self._accessible"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a string containing the deadline for this task", "response": "def get_deadline(self):\n        \"\"\" Returns a string containing the deadline for this task \"\"\"\n        if self.get_accessible_time().is_always_accessible():\n            return _(\"No deadline\")\n        elif self.get_accessible_time().is_never_accessible():\n            return _(\"It's too late\")\n        else:\n            # Prefer to show the soft deadline rather than the hard one\n            return self.get_accessible_time().get_soft_end_date().strftime(\"%d/%m/%Y %H:%M:%S\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the context of this task", "response": "def get_context(self, language):\n        \"\"\" Get the context(description) of this task \"\"\"\n        context = self.gettext(language, self._context) if self._context else \"\"\n        vals = self._hook_manager.call_hook('task_context', course=self.get_course(), task=self, default=context)\n        return ParsableText(vals[0], \"rst\", self._translations.get(language, gettext.NullTranslations())) if len(vals) \\\n            else ParsableText(context, \"rst\", self._translations.get(language, gettext.NullTranslations()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the list of this task s authors in the given language", "response": "def get_authors(self, language):\n        \"\"\" Return the list of this task's authors \"\"\"\n        return self.gettext(language, self._author) if self._author else \"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadapting the input from web. py for the inginious. backend", "response": "def adapt_input_for_backend(self, input_data):\n        \"\"\" Adapt the input from web.py for the inginious.backend \"\"\"\n        for problem in self._problems:\n            input_data = problem.adapt_input_for_backend(input_data)\n        return input_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef page(self, course, username):\n        data = list(self.database.user_tasks.find({\"username\": username, \"courseid\": course.get_id()}))\n\n        tasks = course.get_tasks()\n        result = dict([(taskid, {\"taskid\": taskid, \"name\": tasks[taskid].get_name(self.user_manager.session_language()),\n                                 \"tried\": 0, \"status\": \"notviewed\", \"grade\": 0,\n                                 \"url\": self.submission_url_generator(username, taskid)}) for taskid in tasks])\n\n        for taskdata in data:\n            if taskdata[\"taskid\"] in result:\n                result[taskdata[\"taskid\"]][\"tried\"] = taskdata[\"tried\"]\n                if taskdata[\"tried\"] == 0:\n                    result[taskdata[\"taskid\"]][\"status\"] = \"notattempted\"\n                elif taskdata[\"succeeded\"]:\n                    result[taskdata[\"taskid\"]][\"status\"] = \"succeeded\"\n                else:\n                    result[taskdata[\"taskid\"]][\"status\"] = \"failed\"\n                result[taskdata[\"taskid\"]][\"grade\"] = taskdata[\"grade\"]\n                result[taskdata[\"taskid\"]][\"submissionid\"] = str(taskdata[\"submissionid\"])\n\n        if \"csv\" in web.input():\n            return make_csv(result)\n\n        results = sorted(list(result.values()), key=lambda result: (tasks[result[\"taskid\"]].get_order(), result[\"taskid\"]))\n        return self.template_helper.get_renderer().course_admin.student_info(course, username, results)", "response": "Get all data and display the page"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npost request for the submission manager", "response": "def POST_AUTH(self, courseid):  # pylint: disable=arguments-differ\n        \"\"\" POST request \"\"\"\n        course, __ = self.get_course_and_check_rights(courseid)\n        msgs = []\n\n        if \"replay\" in web.input():\n            if not self.user_manager.has_admin_rights_on_course(course):\n                raise web.notfound()\n            \n            input = self.get_input()\n            tasks = course.get_tasks()\n            data, __ = self.get_submissions(course, input)\n            for submission in data:\n                self.submission_manager.replay_job(tasks[submission[\"taskid\"]], submission)\n            msgs.append(_(\"{0} selected submissions were set for replay.\").format(str(len(data))))\n            \n        return self.page(course, msgs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all data and display the page", "response": "def page(self, course, msgs=None):\n        \"\"\" Get all data and display the page \"\"\"\n        msgs = msgs if msgs else []\n        \n        user_input = self.get_input()\n        data, classroom = self.get_submissions(course, user_input)  # ONLY classrooms user wants to query\n        if len(data) == 0 and not self.show_collapse(user_input):\n            msgs.append(_(\"No submissions found\"))\n\n        classrooms = self.user_manager.get_course_aggregations(course)  # ALL classrooms of the course\n        users = self.get_users(course)  # All users of the course\n        tasks = course.get_tasks()  # All tasks of the course\n\n        statistics = None\n        if user_input.stat != \"no_stat\":\n            statistics = compute_statistics(tasks, data, True if \"with_pond_stat\" == user_input.stat else False)\n\n        if \"csv\" in web.input():\n            return make_csv(data)\n                        \n        if \"download\" in web.input():\n            # self._logger.info(\"Downloading %d submissions from course %s\", len(data), course.get_id())\n            web.header('Content-Type', 'application/x-gzip', unique=True)\n            web.header('Content-Disposition', 'attachment; filename=\"submissions.tgz\"', unique=True)\n\n            # Tweak if not using classrooms : classroom['students'] may content ungrouped users\n            aggregations = dict([(username,\n                                  aggregation if course.use_classrooms() or (\n                                  username in aggregation['groups'][0][\"students\"]) else None\n                                  ) for aggregation in classroom for username in aggregation[\"students\"]])\n\n            download_type = web.input(download_type=self._valid_formats[0]).download_type\n            if download_type not in self._valid_formats:\n                download_type = self._valid_formats[0]\n            return self.submission_manager.get_submission_archive(data, list(reversed(download_type.split('/'))), aggregations)\n\n        if user_input.limit != '' and user_input.limit.isdigit():\n            data = data[:int(user_input.limit)]\n            \n        if len(data) > self._trunc_limit:\n            msgs.append(_(\"The result contains more than {0} submissions. The displayed submissions are truncated.\\n\").format(self._trunc_limit))\n            data = data[:self._trunc_limit]\n        return self.template_helper.get_renderer().course_admin.submissions(course, tasks, users, classrooms, data, statistics, user_input, self._allowed_sort, self._allowed_sort_name, self._valid_formats, msgs, self.show_collapse(user_input))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a sorted list of users", "response": "def get_users(self, course):\n        \"\"\" Returns a sorted list of users \"\"\"\n        users = OrderedDict(sorted(list(self.user_manager.get_users_info(self.user_manager.get_course_registered_users(course)).items()),\n            key=lambda k: k[1][0] if k[1] is not None else \"\"))\n        return users"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_submissions(self, course, user_input):\n\n        # Build lists of wanted users based on classrooms and specific users\n        list_classroom_id = [ObjectId(o) for o in user_input.aggregation]\n        classroom = list(self.database.aggregations.find({\"_id\": {\"$in\": list_classroom_id}}))\n        more_username = [s[\"students\"] for s in classroom]  # Extract usernames of students\n        more_username = [y for x in more_username for y in x]  # Flatten lists\n        \n        # Get tasks based on organisational tags\n        more_tasks = []\n        for org_tag in user_input.org_tags:\n            if org_tag in course.get_organisational_tags_to_task():\n                more_tasks += course.get_organisational_tags_to_task()[org_tag]\n\n        #Base query\n        query_base = {\n                \"username\": {\"$in\": user_input.user + more_username},\n                \"courseid\": course.get_id(),\n                \"taskid\": {\"$in\": user_input.task + more_tasks}\n                }\n\n        # Additional query field\n        query_advanced = {}\n        if user_input.grade_min and not user_input.grade_max:\n            query_advanced[\"grade\"] = {\"$gte\": float(user_input.grade_min)}\n        elif not user_input.grade_min and user_input.grade_max:\n            query_advanced[\"grade\"] = {\"$lte\": float(user_input.grade_max)}\n        elif user_input.grade_min and user_input.grade_max:\n            query_advanced[\"grade\"] = {\"$gte\": float(user_input.grade_min), \"$lte\": float(user_input.grade_max)}\n\n        try:\n            date_before = datetime.strptime(user_input.date_before, \"%Y-%m-%d %H:%M:%S\") if user_input.date_before else ''\n            date_after = datetime.strptime(user_input.date_after, \"%Y-%m-%d %H:%M:%S\") if user_input.date_after else ''\n\n            if date_before and not date_after:\n                query_advanced[\"submitted_on\"] = {\"$lte\": date_before}\n            elif not date_before and date_after:\n                query_advanced[\"submitted_on\"] = {\"$gte\": date_after}\n            elif date_before and date_after:\n                query_advanced[\"submitted_on\"] = {\"$gte\": date_after, \"$lte\": date_before}\n        except ValueError:  # If match of datetime.strptime() fails\n            pass\n        \n        # Query with tags\n        if len(user_input.filter_tags) == len(user_input.filter_tags_presence):\n            for i in range(0, len(user_input.filter_tags)):\n                if id_checker(user_input.filter_tags[i]):\n                    state = (user_input.filter_tags_presence[i] in [\"True\", \"true\"])\n                    query_advanced[\"tests.\" + user_input.filter_tags[i]] = {\"$in\": [None, False]} if not state else True\n            \n        # Mongo operations\n        data = list(self.database.submissions.find({**query_base, **query_advanced}).sort([(user_input.sort_by, \n            pymongo.DESCENDING if user_input.order == \"0\" else pymongo.ASCENDING)]))\n        data = [dict(list(f.items()) + [(\"url\", self.submission_url_generator(str(f[\"_id\"])))]) for f in data]\n\n        # Get best submissions from database\n        user_tasks = list(self.database.user_tasks.find(query_base, {\"submissionid\": 1, \"_id\": 0}))\n        best_submissions_list = [u[\"submissionid\"] for u in user_tasks]  # list containing ids of best submissions\n        for d in data:\n            d[\"best\"] = d[\"_id\"] in best_submissions_list  # mark best submissions\n\n        # Keep best submissions\n        if \"eval\" in user_input or (\"eval_dl\" in user_input and \"download\" in web.input()):\n            data = [d for d in data if d[\"best\"]]\n        return data, classroom", "response": "Returns the list of submissions and corresponding aggragations based on inputs"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the user input and check if it is valid", "response": "def get_input(self):\n        \"\"\" Loads web input, initialise default values and check/sanitise some inputs from users \"\"\"\n        user_input = web.input(\n            user=[],\n            task=[],\n            aggregation=[],\n            org_tags=[],\n            grade_min='',\n            grade_max='',\n            sort_by=\"submitted_on\",\n            order='0',  # \"0\" for pymongo.DESCENDING, anything else for pymongo.ASCENDING\n            limit='',\n            filter_tags=[],\n            filter_tags_presence=[],\n            date_after='',\n            date_before='',\n            stat='with_stat',\n        )\n\n        # Sanitise inputs\n        for item in itertools.chain(user_input.task, user_input.aggregation):\n            if not id_checker(item):\n                raise web.notfound()\n\n        if user_input.sort_by not in self._allowed_sort:\n            raise web.notfound()\n\n        digits = [user_input.grade_min, user_input.grade_max, user_input.order, user_input.limit]\n        for d in digits:\n            if d != '' and not d.isdigit():\n                raise web.notfound()\n\n        return user_input"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_factories(fs_provider, task_problem_types, hook_manager=None, course_class=Course, task_class=Task):\n    if hook_manager is None:\n        hook_manager = HookManager()\n\n    task_factory = TaskFactory(fs_provider, hook_manager, task_problem_types, task_class)\n    return CourseFactory(fs_provider, task_factory, hook_manager, course_class), task_factory", "response": "Shorthand for creating Factories\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_course(self, courseid):\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n        if self._cache_update_needed(courseid):\n            self._update_cache(courseid)\n\n        return self._cache[courseid][0]", "response": "returns the object representing the course"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_course_descriptor_content(self, courseid):\n        path = self._get_course_descriptor_path(courseid)\n        return loads_json_or_yaml(path, self._filesystem.get(path).decode(\"utf-8\"))", "response": "returns the content of the course s metadata"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the content of the dict that describes the course", "response": "def update_course_descriptor_content(self, courseid, content):\n        \"\"\"\n        Updates the content of the dict that describes the course\n        :param courseid: the course id of the course\n        :param content: the new dict that replaces the old content\n        :raise InvalidNameException, CourseNotFoundException\n        \"\"\"\n        path = self._get_course_descriptor_path(courseid)\n        self._filesystem.put(path, get_json_or_yaml(path, content))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a FileSystemProvider pointing to the directory of the course", "response": "def get_course_fs(self, courseid):\n        \"\"\"\n        :param courseid: \n        :return: a FileSystemProvider pointing to the directory of the course \n        \"\"\"\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n        return self._filesystem.from_subfolder(courseid)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a table containing courseid = > Course pairs", "response": "def get_all_courses(self):\n        \"\"\"\n        :return: a table containing courseid=>Course pairs\n        \"\"\"\n        course_ids = [f[0:len(f)-1] for f in self._filesystem.list(folders=True, files=False, recursive=False)]  # remove trailing \"/\"\n        output = {}\n        for courseid in course_ids:\n            try:\n                output[courseid] = self.get_course(courseid)\n            except Exception:\n                get_course_logger(courseid).warning(\"Cannot open course\", exc_info=True)\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the path to the course. yaml and course. json", "response": "def _get_course_descriptor_path(self, courseid):\n        \"\"\"\n        :param courseid: the course id of the course\n        :raise InvalidNameException, CourseNotFoundException\n        :return: the path to the descriptor of the course\n        \"\"\"\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n        course_fs = self.get_course_fs(courseid)\n        if course_fs.exists(\"course.yaml\"):\n            return courseid+\"/course.yaml\"\n        if course_fs.exists(\"course.json\"):\n            return courseid+\"/course.json\"\n        raise CourseNotFoundException()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_course(self, courseid, init_content):\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n\n        course_fs = self.get_course_fs(courseid)\n        course_fs.ensure_exists()\n\n        if course_fs.exists(\"course.yaml\") or course_fs.exists(\"course.json\"):\n            raise CourseAlreadyExistsException(\"Course with id \" + courseid + \" already exists.\")\n        else:\n            course_fs.put(\"course.yaml\", get_json_or_yaml(\"course.yaml\", init_content))\n\n        get_course_logger(courseid).info(\"Course %s created in the factory.\", courseid)", "response": "Create a new course in the factory."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_course(self, courseid):\n        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n\n        course_fs = self.get_course_fs(courseid)\n\n        if not course_fs.exists():\n            raise CourseNotFoundException()\n\n        course_fs.delete()\n\n        get_course_logger(courseid).info(\"Course %s erased from the factory.\", courseid)", "response": "Delete the course from the factory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _cache_update_needed(self, courseid):\n        if courseid not in self._cache:\n            return True\n\n        try:\n            descriptor_name = self._get_course_descriptor_path(courseid)\n            last_update = {descriptor_name: self._filesystem.get_last_modification_time(descriptor_name)}\n            translations_fs = self._filesystem.from_subfolder(\"$i18n\")\n            if translations_fs.exists():\n                for f in translations_fs.list(folders=False, files=True, recursive=False):\n                    lang = f[0:len(f) - 3]\n                    if translations_fs.exists(lang + \".mo\"):\n                        last_update[\"$i18n/\" + lang + \".mo\"] = translations_fs.get_last_modification_time(lang + \".mo\")\n        except:\n            raise CourseNotFoundException()\n\n        last_modif = self._cache[courseid][1]\n        for filename, mftime in last_update.items():\n            if filename not in last_modif or last_modif[filename] < mftime:\n                return True\n\n        return False", "response": "Returns True if an update of the cache is needed."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the cache for the course", "response": "def _update_cache(self, courseid):\n        \"\"\"\n        Updates the cache\n        :param courseid: the (valid) course id of the course\n        :raise InvalidNameException, CourseNotFoundException, CourseUnreadableException\n        \"\"\"\n        path_to_descriptor = self._get_course_descriptor_path(courseid)\n        try:\n            course_descriptor = loads_json_or_yaml(path_to_descriptor, self._filesystem.get(path_to_descriptor).decode(\"utf8\"))\n        except Exception as e:\n            raise CourseUnreadableException(str(e))\n\n        last_modif = {path_to_descriptor: self._filesystem.get_last_modification_time(path_to_descriptor)}\n        translations_fs = self._filesystem.from_subfolder(\"$i18n\")\n        if translations_fs.exists():\n            for f in translations_fs.list(folders=False, files=True, recursive=False):\n                lang = f[0:len(f) - 3]\n                if translations_fs.exists(lang + \".mo\"):\n                    last_modif[\"$i18n/\" + lang + \".mo\"] = translations_fs.get_last_modification_time(lang + \".mo\")\n\n        self._cache[courseid] = (\n            self._course_class(courseid, course_descriptor, self.get_course_fs(courseid), self._task_factory, self._hook_manager),\n            last_modif\n        )\n\n        self._task_factory.update_cache_for_course(courseid)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the course object", "response": "def get_course(self, courseid):\n        \"\"\" Return the course \"\"\"\n        try:\n            course = self.course_factory.get_course(courseid)\n        except:\n            raise web.notfound()\n\n        return course"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef GET(self, courseid):  # pylint: disable=arguments-differ\n        course = self.get_course(courseid)\n        return self.show_page(course)", "response": "GET request handler for GET requests"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprepares and shows the course page", "response": "def show_page(self, course):\n        \"\"\" Prepares and shows the course page \"\"\"\n        username = self.user_manager.session_username()\n        if not self.user_manager.course_is_open_to_user(course, lti=False):\n            return self.template_helper.get_renderer().course_unavailable()\n        else:\n            tasks = course.get_tasks()\n            last_submissions = self.submission_manager.get_user_last_submissions(5, {\"courseid\": course.get_id(), \"taskid\": {\"$in\": list(tasks.keys())}})\n\n            for submission in last_submissions:\n                    submission[\"taskname\"] = tasks[submission['taskid']].get_name(self.user_manager.session_language())\n\n            tasks_data = {}\n            user_tasks = self.database.user_tasks.find({\"username\": username, \"courseid\": course.get_id(), \"taskid\": {\"$in\": list(tasks.keys())}})\n            is_admin = self.user_manager.has_staff_rights_on_course(course, username)\n\n            tasks_score = [0.0, 0.0]\n\n            for taskid, task in tasks.items():\n                tasks_data[taskid] = {\"visible\": task.get_accessible_time().after_start() or is_admin, \"succeeded\": False,\n                                      \"grade\": 0.0}\n                tasks_score[1] += task.get_grading_weight() if tasks_data[taskid][\"visible\"] else 0\n\n            for user_task in user_tasks:\n                tasks_data[user_task[\"taskid\"]][\"succeeded\"] = user_task[\"succeeded\"]\n                tasks_data[user_task[\"taskid\"]][\"grade\"] = user_task[\"grade\"]\n\n                weighted_score = user_task[\"grade\"]*tasks[user_task[\"taskid\"]].get_grading_weight()\n                tasks_score[0] += weighted_score if tasks_data[user_task[\"taskid\"]][\"visible\"] else 0\n\n            course_grade = round(tasks_score[0]/tasks_score[1]) if tasks_score[1] > 0 else 0\n            tag_list = course.get_all_tags_names_as_list(is_admin, self.user_manager.session_language())\n            user_info = self.database.users.find_one({\"username\": username})\n\n            return self.template_helper.get_renderer().course(user_info, course, last_submissions, tasks, tasks_data, course_grade, tag_list)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mavparms(logfile):\n    '''extract mavlink parameters'''\n    mlog = mavutil.mavlink_connection(filename)\n\n    while True:\n        try:\n            m = mlog.recv_match(type=['PARAM_VALUE', 'PARM'])\n            if m is None:\n                return\n        except Exception:\n            return\n        if m.get_type() == 'PARAM_VALUE':\n            pname = str(m.param_id).strip()\n            value = m.param_value\n        else:\n            pname = m.Name\n            value = m.Value\n        if len(pname) > 0:\n            if args.changesOnly is True and pname in parms and parms[pname] != value:\n                print(\"%s %-15s %.6f -> %.6f\" % (time.asctime(time.localtime(m._timestamp)), pname, parms[pname], value))\n\n            parms[pname] = value", "response": "extract mavlink parameters from a log file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a MAVLink message", "response": "def send(self, mavmsg, force_mavlink1=False):\n                '''send a MAVLink message'''\n                buf = mavmsg.pack(self, force_mavlink1=force_mavlink1)\n                self.file.write(buf)\n                self.seq = (self.seq + 1) % 256\n                self.total_packets_sent += 1\n                self.total_bytes_sent += len(buf)\n                if self.send_callback:\n                    self.send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bytes_needed(self):\n            '''return number of bytes needed for next parsing stage'''\n            if self.native:\n                ret = self.native.expected_length - self.buf_len()\n            else:\n                ret = self.expected_length - self.buf_len()\n            \n            if ret <= 0:\n                return 1\n            return ret", "response": "return number of bytes needed for next parsing stage"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninputs some data bytes possibly returning a new message", "response": "def parse_char(self, c):\n            '''input some data bytes, possibly returning a new message'''\n            self.buf.extend(c)\n\n            self.total_bytes_received += len(c)\n\n            if self.native:\n                if native_testing:\n                    self.test_buf.extend(c)\n                    m = self.__parse_char_native(self.test_buf)\n                    m2 = self.__parse_char_legacy()\n                    if m2 != m:\n                        print(\"Native: %s\\nLegacy: %s\\n\" % (m, m2))\n                        raise Exception('Native vs. Legacy mismatch')\n                else:\n                    m = self.__parse_char_native(self.buf)\n            else:\n                m = self.__parse_char_legacy()\n\n            if m != None:\n                self.total_packets_received += 1\n                self.__callbacks(m)\n            else:\n                # XXX The idea here is if we've read something and there's nothing left in\n                # the buffer, reset it to 0 which frees the memory\n                if self.buf_len() == 0 and self.buf_index != 0:\n                    self.buf = bytearray()\n                    self.buf_index = 0\n\n            return m"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninputs some data bytes possibly returning a new message ( uses no native code )", "response": "def __parse_char_legacy(self):\n            '''input some data bytes, possibly returning a new message (uses no native code)'''\n            header_len = HEADER_LEN_V1\n            if self.buf_len() >= 1 and self.buf[self.buf_index] == PROTOCOL_MARKER_V2:\n                header_len = HEADER_LEN_V2\n                \n            if self.buf_len() >= 1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V2:\n                magic = self.buf[self.buf_index]\n                self.buf_index += 1\n                if self.robust_parsing:\n                    m = MAVLink_bad_data(chr(magic), 'Bad prefix')\n                    self.expected_length = header_len+2\n                    self.total_receive_errors += 1\n                    return m\n                if self.have_prefix_error:\n                    return None\n                self.have_prefix_error = True\n                self.total_receive_errors += 1\n                raise MAVError(\"invalid MAVLink prefix '%s'\" % magic)\n            self.have_prefix_error = False\n            if self.buf_len() >= 3:\n                sbuf = self.buf[self.buf_index:3+self.buf_index]\n                if sys.version_info[0] < 3:\n                    sbuf = str(sbuf)\n                (magic, self.expected_length, incompat_flags) = struct.unpack('BBB', sbuf)\n                if magic == PROTOCOL_MARKER_V2 and (incompat_flags & MAVLINK_IFLAG_SIGNED):\n                        self.expected_length += MAVLINK_SIGNATURE_BLOCK_LEN\n                self.expected_length += header_len + 2\n            if self.expected_length >= (header_len+2) and self.buf_len() >= self.expected_length:\n                mbuf = array.array('B', self.buf[self.buf_index:self.buf_index+self.expected_length])\n                self.buf_index += self.expected_length\n                self.expected_length = header_len+2\n                if self.robust_parsing:\n                    try:\n                        if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:\n                            raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))\n                        m = self.decode(mbuf)\n                    except MAVError as reason:\n                        m = MAVLink_bad_data(mbuf, reason.message)\n                        self.total_receive_errors += 1\n                else:\n                    if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:\n                        raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))\n                    m = self.decode(mbuf)\n                return m\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_buffer(self, s):\n            '''input some data bytes, possibly returning a list of new messages'''\n            m = self.parse_char(s)\n            if m is None:\n                return None\n            ret = [m]\n            while True:\n                m = self.parse_char(\"\")\n                if m is None:\n                    return ret\n                ret.append(m)\n            return ret", "response": "input some data bytes possibly returning a list of new messages"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_signature(self, msgbuf, srcSystem, srcComponent):\n            '''check signature on incoming message'''\n            if isinstance(msgbuf, array.array):\n                msgbuf = msgbuf.tostring()\n            timestamp_buf = msgbuf[-12:-6]\n            link_id = msgbuf[-13]\n            (tlow, thigh) = struct.unpack('<IH', timestamp_buf)\n            timestamp = tlow + (thigh<<32)\n\n            # see if the timestamp is acceptable\n            stream_key = (link_id,srcSystem,srcComponent)\n            if stream_key in self.signing.stream_timestamps:\n                if timestamp <= self.signing.stream_timestamps[stream_key]:\n                    # reject old timestamp\n                    # print('old timestamp')\n                    return False\n            else:\n                # a new stream has appeared. Accept the timestamp if it is at most\n                # one minute behind our current timestamp\n                if timestamp + 6000*1000 < self.signing.timestamp:\n                    # print('bad new stream ', timestamp/(100.0*1000*60*60*24*365), self.signing.timestamp/(100.0*1000*60*60*24*365))\n                    return False\n                self.signing.stream_timestamps[stream_key] = timestamp\n                # print('new stream')\n\n            h = hashlib.new('sha256')\n            h.update(self.signing.secret_key)\n            h.update(msgbuf[:-6])\n            sig1 = str(h.digest())[:6]\n            sig2 = str(msgbuf)[-6:]\n            if sig1 != sig2:\n                # print('sig mismatch')\n                return False\n\n            # the timestamp we next send with is the max of the received timestamp and\n            # our current timestamp\n            self.signing.timestamp = max(self.signing.timestamp, timestamp)\n            return True", "response": "check signature on incoming message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndecoding a buffer as a MAVLink message", "response": "def decode(self, msgbuf):\n                '''decode a buffer as a MAVLink message'''\n                # decode the header\n                if msgbuf[0] != PROTOCOL_MARKER_V1:\n                    headerlen = 10\n                    try:\n                        magic, mlen, incompat_flags, compat_flags, seq, srcSystem, srcComponent, msgIdlow, msgIdhigh = struct.unpack('<cBBBBBBHB', msgbuf[:headerlen])\n                    except struct.error as emsg:\n                        raise MAVError('Unable to unpack MAVLink header: %s' % emsg)\n                    msgId = msgIdlow | (msgIdhigh<<16)\n                    mapkey = msgId\n                else:\n                    headerlen = 6\n                    try:\n                        magic, mlen, seq, srcSystem, srcComponent, msgId = struct.unpack('<cBBBBB', msgbuf[:headerlen])\n                        incompat_flags = 0\n                        compat_flags = 0\n                    except struct.error as emsg:\n                        raise MAVError('Unable to unpack MAVLink header: %s' % emsg)\n                    mapkey = msgId\n                if (incompat_flags & MAVLINK_IFLAG_SIGNED) != 0:\n                    signature_len = MAVLINK_SIGNATURE_BLOCK_LEN\n                else:\n                    signature_len = 0\n\n                if ord(magic) != PROTOCOL_MARKER_V1 and ord(magic) != PROTOCOL_MARKER_V2:\n                    raise MAVError(\"invalid MAVLink prefix '%s'\" % magic)\n                if mlen != len(msgbuf)-(headerlen+2+signature_len):\n                    raise MAVError('invalid MAVLink message length. Got %u expected %u, msgId=%u headerlen=%u' % (len(msgbuf)-(headerlen+2+signature_len), mlen, msgId, headerlen))\n\n                if not mapkey in mavlink_map:\n                    raise MAVError('unknown MAVLink message ID %s' % str(mapkey))\n\n                # decode the payload\n                type = mavlink_map[mapkey]\n                fmt = type.format\n                order_map = type.orders\n                len_map = type.lengths\n                crc_extra = type.crc_extra\n\n                # decode the checksum\n                try:\n                    crc, = struct.unpack('<H', msgbuf[-(2+signature_len):][:2])\n                except struct.error as emsg:\n                    raise MAVError('Unable to unpack MAVLink CRC: %s' % emsg)\n                crcbuf = msgbuf[1:-(2+signature_len)]\n                if True: # using CRC extra\n                    crcbuf.append(crc_extra)\n                crc2 = x25crc(crcbuf)\n                if crc != crc2.crc:\n                    raise MAVError('invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x' % (msgId, crc, crc2.crc))\n\n                sig_ok = False\n                if self.signing.secret_key is not None:\n                    accept_signature = False\n                    if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:\n                        sig_ok = self.check_signature(msgbuf, srcSystem, srcComponent)\n                        accept_signature = sig_ok\n                        if sig_ok:\n                            self.signing.goodsig_count += 1\n                        else:\n                            self.signing.badsig_count += 1\n                        if not accept_signature and self.signing.allow_unsigned_callback is not None:\n                            accept_signature = self.signing.allow_unsigned_callback(self, msgId)\n                            if accept_signature:\n                                self.signing.unsigned_count += 1\n                            else:\n                                self.signing.reject_count += 1\n                    elif self.signing.allow_unsigned_callback is not None:\n                        accept_signature = self.signing.allow_unsigned_callback(self, msgId)\n                        if accept_signature:\n                            self.signing.unsigned_count += 1\n                        else:\n                            self.signing.reject_count += 1\n                    if not accept_signature:\n                        raise MAVError('Invalid signature')\n\n                csize = struct.calcsize(fmt)\n                mbuf = msgbuf[headerlen:-(2+signature_len)]\n                if len(mbuf) < csize:\n                    # zero pad to give right size\n                    mbuf.extend([0]*(csize - len(mbuf)))\n                if len(mbuf) < csize:\n                    raise MAVError('Bad message of type %s length %u needs %s' % (\n                        type, len(mbuf), csize))\n                mbuf = mbuf[:csize]\n                try:\n                    t = struct.unpack(fmt, mbuf)\n                except struct.error as emsg:\n                    raise MAVError('Unable to unpack MAVLink payload type=%s fmt=%s payloadLength=%u: %s' % (\n                        type, fmt, len(mbuf), emsg))\n\n                tlist = list(t)\n                # handle sorted fields\n                if True:\n                    t = tlist[:]\n                    if sum(len_map) == len(len_map):\n                        # message has no arrays in it\n                        for i in range(0, len(tlist)):\n                            tlist[i] = t[order_map[i]]\n                    else:\n                        # message has some arrays\n                        tlist = []\n                        for i in range(0, len(order_map)):\n                            order = order_map[i]\n                            L = len_map[order]\n                            tip = sum(len_map[:order])\n                            field = t[tip]\n                            if L == 1 or isinstance(field, str):\n                                tlist.append(field)\n                            else:\n                                tlist.append(t[tip:(tip + L)])\n\n                # terminate any strings\n                for i in range(0, len(tlist)):\n                    if isinstance(tlist[i], str):\n                        tlist[i] = str(MAVString(tlist[i]))\n                t = tuple(tlist)\n                # construct the message object\n                try:\n                    m = type(*t)\n                except Exception as emsg:\n                    raise MAVError('Unable to instantiate MAVLink message of type %s : %s' % (type, emsg))\n                m._signed = sig_ok\n                if m._signed:\n                    m._link_id = msgbuf[-13]\n                m._msgbuf = msgbuf\n                m._payload = msgbuf[6:-(2+signature_len)]\n                m._crc = crc\n                m._header = MAVLink_header(msgId, incompat_flags, compat_flags, mlen, seq, srcSystem, srcComponent)\n                return m"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flexifunction_set_send(self, target_system, target_component, force_mavlink1=False):\n                '''\n                Depreciated but used as a compiler flag.  Do not remove\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n\n                '''\n                return self.send(self.flexifunction_set_encode(target_system, target_component), force_mavlink1=force_mavlink1)", "response": "Set the flexifunction of the system and component."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flexifunction_read_req_encode(self, target_system, target_component, read_req_type, data_index):\n                '''\n                Reqest reading of flexifunction data\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                read_req_type             : Type of flexifunction data requested (int16_t)\n                data_index                : index into data where needed (int16_t)\n\n                '''\n                return MAVLink_flexifunction_read_req_message(target_system, target_component, read_req_type, data_index)", "response": "Request a read of flexifunction data from the system"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrequest data from the flexifunction.", "response": "def flexifunction_read_req_send(self, target_system, target_component, read_req_type, data_index, force_mavlink1=False):\n                '''\n                Reqest reading of flexifunction data\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                read_req_type             : Type of flexifunction data requested (int16_t)\n                data_index                : index into data where needed (int16_t)\n\n                '''\n                return self.send(self.flexifunction_read_req_encode(target_system, target_component, read_req_type, data_index), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flexifunction_buffer_function_send(self, target_system, target_component, func_index, func_count, data_address, data_size, data, force_mavlink1=False):\n                '''\n                Flexifunction type and parameters for component at function index from\n                buffer\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                func_index                : Function index (uint16_t)\n                func_count                : Total count of functions (uint16_t)\n                data_address              : Address in the flexifunction data, Set to 0xFFFF to use address in target memory (uint16_t)\n                data_size                 : Size of the (uint16_t)\n                data                      : Settings data (int8_t)\n\n                '''\n                return self.send(self.flexifunction_buffer_function_encode(target_system, target_component, func_index, func_count, data_address, data_size, data), force_mavlink1=force_mavlink1)", "response": "Flexifunction data buffer function"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flexifunction_buffer_function_ack_send(self, target_system, target_component, func_index, result, force_mavlink1=False):\n                '''\n                Flexifunction type and parameters for component at function index from\n                buffer\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                func_index                : Function index (uint16_t)\n                result                    : result of acknowledge, 0=fail, 1=good (uint16_t)\n\n                '''\n                return self.send(self.flexifunction_buffer_function_ack_encode(target_system, target_component, func_index, result), force_mavlink1=force_mavlink1)", "response": "Acknowledge the result of a flexifunction buffer function."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef flexifunction_directory_encode(self, target_system, target_component, directory_type, start_index, count, directory_data):\n                '''\n                Acknowldge sucess or failure of a flexifunction command\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                directory_type            : 0=inputs, 1=outputs (uint8_t)\n                start_index               : index of first directory entry to write (uint8_t)\n                count                     : count of directory entries to write (uint8_t)\n                directory_data            : Settings data (int8_t)\n\n                '''\n                return MAVLink_flexifunction_directory_message(target_system, target_component, directory_type, start_index, count, directory_data)", "response": "Acknowldge sucess or failure of a flexifunction command\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                directory_type            : 0=inputs, 1=outputs (uint8_t)\n                start_index               : index of first directory entry to write (uint8_t)\n                count                     : count of directory entries to write (uint8_t)\n                directory_data            : Settings data (int8_t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef flexifunction_directory_ack_send(self, target_system, target_component, directory_type, start_index, count, result, force_mavlink1=False):\n                '''\n                Acknowldge sucess or failure of a flexifunction command\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                directory_type            : 0=inputs, 1=outputs (uint8_t)\n                start_index               : index of first directory entry to write (uint8_t)\n                count                     : count of directory entries to write (uint8_t)\n                result                    : result of acknowledge, 0=fail, 1=good (uint16_t)\n\n                '''\n                return self.send(self.flexifunction_directory_ack_encode(target_system, target_component, directory_type, start_index, count, result), force_mavlink1=force_mavlink1)", "response": "Acknowldge sucess or failure of a flexifunction command"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flexifunction_command_ack_send(self, command_type, result, force_mavlink1=False):\n                '''\n                Acknowldge sucess or failure of a flexifunction command\n\n                command_type              : Command acknowledged (uint16_t)\n                result                    : result of acknowledge (uint16_t)\n\n                '''\n                return self.send(self.flexifunction_command_ack_encode(command_type, result), force_mavlink1=force_mavlink1)", "response": "This message is used to acknowledge a command from the flexifunction."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef serial_udb_extra_f4_encode(self, sue_ROLL_STABILIZATION_AILERONS, sue_ROLL_STABILIZATION_RUDDER, sue_PITCH_STABILIZATION, sue_YAW_STABILIZATION_RUDDER, sue_YAW_STABILIZATION_AILERON, sue_AILERON_NAVIGATION, sue_RUDDER_NAVIGATION, sue_ALTITUDEHOLD_STABILIZED, sue_ALTITUDEHOLD_WAYPOINT, sue_RACING_MODE):\n                '''\n                Backwards compatible version of SERIAL_UDB_EXTRA F4: format\n\n                sue_ROLL_STABILIZATION_AILERONS        : Serial UDB Extra Roll Stabilization with Ailerons Enabled (uint8_t)\n                sue_ROLL_STABILIZATION_RUDDER        : Serial UDB Extra Roll Stabilization with Rudder Enabled (uint8_t)\n                sue_PITCH_STABILIZATION        : Serial UDB Extra Pitch Stabilization Enabled (uint8_t)\n                sue_YAW_STABILIZATION_RUDDER        : Serial UDB Extra Yaw Stabilization using Rudder Enabled (uint8_t)\n                sue_YAW_STABILIZATION_AILERON        : Serial UDB Extra Yaw Stabilization using Ailerons Enabled (uint8_t)\n                sue_AILERON_NAVIGATION        : Serial UDB Extra Navigation with Ailerons Enabled (uint8_t)\n                sue_RUDDER_NAVIGATION        : Serial UDB Extra Navigation with Rudder Enabled (uint8_t)\n                sue_ALTITUDEHOLD_STABILIZED        : Serial UDB Extra Type of Alitude Hold when in Stabilized Mode (uint8_t)\n                sue_ALTITUDEHOLD_WAYPOINT        : Serial UDB Extra Type of Alitude Hold when in Waypoint Mode (uint8_t)\n                sue_RACING_MODE           : Serial UDB Extra Firmware racing mode enabled (uint8_t)\n\n                '''\n                return MAVLink_serial_udb_extra_f4_message(sue_ROLL_STABILIZATION_AILERONS, sue_ROLL_STABILIZATION_RUDDER, sue_PITCH_STABILIZATION, sue_YAW_STABILIZATION_RUDDER, sue_YAW_STABILIZATION_AILERON, sue_AILERON_NAVIGATION, sue_RUDDER_NAVIGATION, sue_ALTITUDEHOLD_STABILIZED, sue_ALTITUDEHOLD_WAYPOINT, sue_RACING_MODE)", "response": "This function encodes the serial UDB_EXTRA F4 data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef serial_udb_extra_f5_encode(self, sue_YAWKP_AILERON, sue_YAWKD_AILERON, sue_ROLLKP, sue_ROLLKD, sue_YAW_STABILIZATION_AILERON, sue_AILERON_BOOST):\n                '''\n                Backwards compatible version of SERIAL_UDB_EXTRA F5: format\n\n                sue_YAWKP_AILERON         : Serial UDB YAWKP_AILERON Gain for Proporional control of navigation (float)\n                sue_YAWKD_AILERON         : Serial UDB YAWKD_AILERON Gain for Rate control of navigation (float)\n                sue_ROLLKP                : Serial UDB Extra ROLLKP Gain for Proportional control of roll stabilization (float)\n                sue_ROLLKD                : Serial UDB Extra ROLLKD Gain for Rate control of roll stabilization (float)\n                sue_YAW_STABILIZATION_AILERON        : YAW_STABILIZATION_AILERON Proportional control (float)\n                sue_AILERON_BOOST         : Gain For Boosting Manual Aileron control When Plane Stabilized (float)\n\n                '''\n                return MAVLink_serial_udb_extra_f5_message(sue_YAWKP_AILERON, sue_YAWKD_AILERON, sue_ROLLKP, sue_ROLLKD, sue_YAW_STABILIZATION_AILERON, sue_AILERON_BOOST)", "response": "This function is used to encode the values for the serial_udb_extra_f5_t message"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serial_udb_extra_f6_send(self, sue_PITCHGAIN, sue_PITCHKD, sue_RUDDER_ELEV_MIX, sue_ROLL_ELEV_MIX, sue_ELEVATOR_BOOST, force_mavlink1=False):\n                '''\n                Backwards compatible version of SERIAL_UDB_EXTRA F6: format\n\n                sue_PITCHGAIN             : Serial UDB Extra PITCHGAIN Proportional Control (float)\n                sue_PITCHKD               : Serial UDB Extra Pitch Rate Control (float)\n                sue_RUDDER_ELEV_MIX        : Serial UDB Extra Rudder to Elevator Mix (float)\n                sue_ROLL_ELEV_MIX         : Serial UDB Extra Roll to Elevator Mix (float)\n                sue_ELEVATOR_BOOST        : Gain For Boosting Manual Elevator control When Plane Stabilized (float)\n\n                '''\n                return self.send(self.serial_udb_extra_f6_encode(sue_PITCHGAIN, sue_PITCHKD, sue_RUDDER_ELEV_MIX, sue_ROLL_ELEV_MIX, sue_ELEVATOR_BOOST), force_mavlink1=force_mavlink1)", "response": "This function is used to set the serial UDB extra control parameters for the serial UDB."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef serial_udb_extra_f7_send(self, sue_YAWKP_RUDDER, sue_YAWKD_RUDDER, sue_ROLLKP_RUDDER, sue_ROLLKD_RUDDER, sue_RUDDER_BOOST, sue_RTL_PITCH_DOWN, force_mavlink1=False):\n                '''\n                Backwards compatible version of SERIAL_UDB_EXTRA F7: format\n\n                sue_YAWKP_RUDDER          : Serial UDB YAWKP_RUDDER Gain for Proporional control of navigation (float)\n                sue_YAWKD_RUDDER          : Serial UDB YAWKD_RUDDER Gain for Rate control of navigation (float)\n                sue_ROLLKP_RUDDER         : Serial UDB Extra ROLLKP_RUDDER Gain for Proportional control of roll stabilization (float)\n                sue_ROLLKD_RUDDER         : Serial UDB Extra ROLLKD_RUDDER Gain for Rate control of roll stabilization (float)\n                sue_RUDDER_BOOST          : SERIAL UDB EXTRA Rudder Boost Gain to Manual Control when stabilized (float)\n                sue_RTL_PITCH_DOWN        : Serial UDB Extra Return To Landing - Angle to Pitch Plane Down (float)\n\n                '''\n                return self.send(self.serial_udb_extra_f7_encode(sue_YAWKP_RUDDER, sue_YAWKD_RUDDER, sue_ROLLKP_RUDDER, sue_ROLLKD_RUDDER, sue_RUDDER_BOOST, sue_RTL_PITCH_DOWN), force_mavlink1=force_mavlink1)", "response": "This function is used to send the serial UDB extra F7 message."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serial_udb_extra_f8_send(self, sue_HEIGHT_TARGET_MAX, sue_HEIGHT_TARGET_MIN, sue_ALT_HOLD_THROTTLE_MIN, sue_ALT_HOLD_THROTTLE_MAX, sue_ALT_HOLD_PITCH_MIN, sue_ALT_HOLD_PITCH_MAX, sue_ALT_HOLD_PITCH_HIGH, force_mavlink1=False):\n                '''\n                Backwards compatible version of SERIAL_UDB_EXTRA F8: format\n\n                sue_HEIGHT_TARGET_MAX        : Serial UDB Extra HEIGHT_TARGET_MAX (float)\n                sue_HEIGHT_TARGET_MIN        : Serial UDB Extra HEIGHT_TARGET_MIN (float)\n                sue_ALT_HOLD_THROTTLE_MIN        : Serial UDB Extra ALT_HOLD_THROTTLE_MIN (float)\n                sue_ALT_HOLD_THROTTLE_MAX        : Serial UDB Extra ALT_HOLD_THROTTLE_MAX (float)\n                sue_ALT_HOLD_PITCH_MIN        : Serial UDB Extra ALT_HOLD_PITCH_MIN (float)\n                sue_ALT_HOLD_PITCH_MAX        : Serial UDB Extra ALT_HOLD_PITCH_MAX (float)\n                sue_ALT_HOLD_PITCH_HIGH        : Serial UDB Extra ALT_HOLD_PITCH_HIGH (float)\n\n                '''\n                return self.send(self.serial_udb_extra_f8_encode(sue_HEIGHT_TARGET_MAX, sue_HEIGHT_TARGET_MIN, sue_ALT_HOLD_THROTTLE_MIN, sue_ALT_HOLD_THROTTLE_MAX, sue_ALT_HOLD_PITCH_MIN, sue_ALT_HOLD_PITCH_MAX, sue_ALT_HOLD_PITCH_HIGH), force_mavlink1=force_mavlink1)", "response": "This function is used to set the serial UDB extra values for the UDB."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef serial_udb_extra_f13_send(self, sue_week_no, sue_lat_origin, sue_lon_origin, sue_alt_origin, force_mavlink1=False):\n                '''\n                Backwards compatible version of SERIAL_UDB_EXTRA F13: format\n\n                sue_week_no               : Serial UDB Extra GPS Week Number (int16_t)\n                sue_lat_origin            : Serial UDB Extra MP Origin Latitude (int32_t)\n                sue_lon_origin            : Serial UDB Extra MP Origin Longitude (int32_t)\n                sue_alt_origin            : Serial UDB Extra MP Origin Altitude Above Sea Level (int32_t)\n\n                '''\n                return self.send(self.serial_udb_extra_f13_encode(sue_week_no, sue_lat_origin, sue_lon_origin, sue_alt_origin), force_mavlink1=force_mavlink1)", "response": "Backwards compatible version of SERIAL_UDB_EXTRA F13: format\n\n                sue_week_no               : Serial UDB Extra GPS Week Number (int16_t)\n                sue_lat_origin            : Serial UDB Extra MP Origin Latitude (int32_t)\n                sue_lon_origin            : Serial UDB Extra MP Origin Longitude (int32_t)\n                sue_alt_origin            : Serial UDB Extra MP Origin Altitude Above Sea Level (int32_t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef serial_udb_extra_f14_encode(self, sue_WIND_ESTIMATION, sue_GPS_TYPE, sue_DR, sue_BOARD_TYPE, sue_AIRFRAME, sue_RCON, sue_TRAP_FLAGS, sue_TRAP_SOURCE, sue_osc_fail_count, sue_CLOCK_CONFIG, sue_FLIGHT_PLAN_TYPE):\n                '''\n                Backwards compatible version of SERIAL_UDB_EXTRA F14: format\n\n                sue_WIND_ESTIMATION        : Serial UDB Extra Wind Estimation Enabled (uint8_t)\n                sue_GPS_TYPE              : Serial UDB Extra Type of GPS Unit (uint8_t)\n                sue_DR                    : Serial UDB Extra Dead Reckoning Enabled (uint8_t)\n                sue_BOARD_TYPE            : Serial UDB Extra Type of UDB Hardware (uint8_t)\n                sue_AIRFRAME              : Serial UDB Extra Type of Airframe (uint8_t)\n                sue_RCON                  : Serial UDB Extra Reboot Regitster of DSPIC (int16_t)\n                sue_TRAP_FLAGS            : Serial UDB Extra  Last dspic Trap Flags (int16_t)\n                sue_TRAP_SOURCE           : Serial UDB Extra Type Program Address of Last Trap (uint32_t)\n                sue_osc_fail_count        : Serial UDB Extra Number of Ocillator Failures (int16_t)\n                sue_CLOCK_CONFIG          : Serial UDB Extra UDB Internal Clock Configuration (uint8_t)\n                sue_FLIGHT_PLAN_TYPE        : Serial UDB Extra Type of Flight Plan (uint8_t)\n\n                '''\n                return MAVLink_serial_udb_extra_f14_message(sue_WIND_ESTIMATION, sue_GPS_TYPE, sue_DR, sue_BOARD_TYPE, sue_AIRFRAME, sue_RCON, sue_TRAP_FLAGS, sue_TRAP_SOURCE, sue_osc_fail_count, sue_CLOCK_CONFIG, sue_FLIGHT_PLAN_TYPE)", "response": "This function encodes the values for the serial_udb_extra_f14_t field of the udb extra"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef serial_udb_extra_f14_send(self, sue_WIND_ESTIMATION, sue_GPS_TYPE, sue_DR, sue_BOARD_TYPE, sue_AIRFRAME, sue_RCON, sue_TRAP_FLAGS, sue_TRAP_SOURCE, sue_osc_fail_count, sue_CLOCK_CONFIG, sue_FLIGHT_PLAN_TYPE, force_mavlink1=False):\n                '''\n                Backwards compatible version of SERIAL_UDB_EXTRA F14: format\n\n                sue_WIND_ESTIMATION        : Serial UDB Extra Wind Estimation Enabled (uint8_t)\n                sue_GPS_TYPE              : Serial UDB Extra Type of GPS Unit (uint8_t)\n                sue_DR                    : Serial UDB Extra Dead Reckoning Enabled (uint8_t)\n                sue_BOARD_TYPE            : Serial UDB Extra Type of UDB Hardware (uint8_t)\n                sue_AIRFRAME              : Serial UDB Extra Type of Airframe (uint8_t)\n                sue_RCON                  : Serial UDB Extra Reboot Regitster of DSPIC (int16_t)\n                sue_TRAP_FLAGS            : Serial UDB Extra  Last dspic Trap Flags (int16_t)\n                sue_TRAP_SOURCE           : Serial UDB Extra Type Program Address of Last Trap (uint32_t)\n                sue_osc_fail_count        : Serial UDB Extra Number of Ocillator Failures (int16_t)\n                sue_CLOCK_CONFIG          : Serial UDB Extra UDB Internal Clock Configuration (uint8_t)\n                sue_FLIGHT_PLAN_TYPE        : Serial UDB Extra Type of Flight Plan (uint8_t)\n\n                '''\n                return self.send(self.serial_udb_extra_f14_encode(sue_WIND_ESTIMATION, sue_GPS_TYPE, sue_DR, sue_BOARD_TYPE, sue_AIRFRAME, sue_RCON, sue_TRAP_FLAGS, sue_TRAP_SOURCE, sue_osc_fail_count, sue_CLOCK_CONFIG, sue_FLIGHT_PLAN_TYPE), force_mavlink1=force_mavlink1)", "response": "Backwards compatible version of SERIAL_UDB_EXTRA F14: format\n\n                sue_WIND_ESTIMATION        : Serial UDB Extra Wind Estimation Enabled (uint8_t)\n                sue_GPS_TYPE              : Serial UDB Extra Type of GPS Unit (uint8_t)\n                sue_DR                    : Serial UDB Extra Dead Reckoning Enabled (uint8_t)\n                sue_BOARD_TYPE            : Serial UDB Extra Type of UDB Hardware (uint8_t)\n                sue_AIRFRAME              : Serial UDB Extra Type of Airframe (uint8_t)\n                sue_RCON                  : Serial UDB Extra Reboot Regitster of DSPIC (int16_t)\n                sue_TRAP_FLAGS            : Serial UDB Extra  Last dspic Trap Flags (int16_t)\n                sue_TRAP_SOURCE           : Serial UDB Extra Type Program Address of Last Trap (uint32_t)\n                sue_osc_fail_count        : Serial UDB Extra Number of Ocillator Failures (int16_t)\n                sue_CLOCK_CONFIG          : Serial UDB Extra UDB Internal Clock Configuration (uint8_t)\n                sue_FLIGHT_PLAN_TYPE        : Serial UDB Extra Type of Flight Plan (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef serial_udb_extra_f15_send(self, sue_ID_VEHICLE_MODEL_NAME, sue_ID_VEHICLE_REGISTRATION, force_mavlink1=False):\n                '''\n                Backwards compatible version of SERIAL_UDB_EXTRA F15 and F16: format\n\n                sue_ID_VEHICLE_MODEL_NAME        : Serial UDB Extra Model Name Of Vehicle (uint8_t)\n                sue_ID_VEHICLE_REGISTRATION        : Serial UDB Extra Registraton Number of Vehicle (uint8_t)\n\n                '''\n                return self.send(self.serial_udb_extra_f15_encode(sue_ID_VEHICLE_MODEL_NAME, sue_ID_VEHICLE_REGISTRATION), force_mavlink1=force_mavlink1)", "response": "Serial UDB Extra Model Name and Registraton Number of Vehicle"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef altitudes_encode(self, time_boot_ms, alt_gps, alt_imu, alt_barometric, alt_optical_flow, alt_range_finder, alt_extra):\n                '''\n                The altitude measured by sensors and IMU\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                alt_gps                   : GPS altitude in meters, expressed as * 1000 (millimeters), above MSL (int32_t)\n                alt_imu                   : IMU altitude above ground in meters, expressed as * 1000 (millimeters) (int32_t)\n                alt_barometric            : barometeric altitude above ground in meters, expressed as * 1000 (millimeters) (int32_t)\n                alt_optical_flow          : Optical flow altitude above ground in meters, expressed as * 1000 (millimeters) (int32_t)\n                alt_range_finder          : Rangefinder Altitude above ground in meters, expressed as * 1000 (millimeters) (int32_t)\n                alt_extra                 : Extra altitude above ground in meters, expressed as * 1000 (millimeters) (int32_t)\n\n                '''\n                return MAVLink_altitudes_message(time_boot_ms, alt_gps, alt_imu, alt_barometric, alt_optical_flow, alt_range_finder, alt_extra)", "response": "This function returns the altitude of the system"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef airspeeds_encode(self, time_boot_ms, airspeed_imu, airspeed_pitot, airspeed_hot_wire, airspeed_ultrasonic, aoa, aoy):\n                '''\n                The airspeed measured by sensors and IMU\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                airspeed_imu              : Airspeed estimate from IMU, cm/s (int16_t)\n                airspeed_pitot            : Pitot measured forward airpseed, cm/s (int16_t)\n                airspeed_hot_wire         : Hot wire anenometer measured airspeed, cm/s (int16_t)\n                airspeed_ultrasonic        : Ultrasonic measured airspeed, cm/s (int16_t)\n                aoa                       : Angle of attack sensor, degrees * 10 (int16_t)\n                aoy                       : Yaw angle sensor, degrees * 10 (int16_t)\n\n                '''\n                return MAVLink_airspeeds_message(time_boot_ms, airspeed_imu, airspeed_pitot, airspeed_hot_wire, airspeed_ultrasonic, aoa, aoy)", "response": "This function is called when the MAVLink is about to set the airspeed of the system."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef airspeeds_send(self, time_boot_ms, airspeed_imu, airspeed_pitot, airspeed_hot_wire, airspeed_ultrasonic, aoa, aoy, force_mavlink1=False):\n                '''\n                The airspeed measured by sensors and IMU\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                airspeed_imu              : Airspeed estimate from IMU, cm/s (int16_t)\n                airspeed_pitot            : Pitot measured forward airpseed, cm/s (int16_t)\n                airspeed_hot_wire         : Hot wire anenometer measured airspeed, cm/s (int16_t)\n                airspeed_ultrasonic        : Ultrasonic measured airspeed, cm/s (int16_t)\n                aoa                       : Angle of attack sensor, degrees * 10 (int16_t)\n                aoy                       : Yaw angle sensor, degrees * 10 (int16_t)\n\n                '''\n                return self.send(self.airspeeds_encode(time_boot_ms, airspeed_imu, airspeed_pitot, airspeed_hot_wire, airspeed_ultrasonic, aoa, aoy), force_mavlink1=force_mavlink1)", "response": "The airspeed measured by sensors and IMU\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                airspeed_imu              : Airspeed estimate from IMU, cm/s (int16_t)\n                airspeed_pitot            : Pitot measured forward airpseed, cm/s (int16_t)\n                airspeed_hot_wire         : Hot wire anenometer measured airspeed, cm/s (int16_t)\n                airspeed_ultrasonic        : Ultrasonic measured airspeed, cm/s (int16_t)\n                aoa                       : Angle of attack sensor, degrees * 10 (int16_t)\n                aoy                       : Yaw angle sensor, degrees * 10 (int16_t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sys_status_send(self, onboard_control_sensors_present, onboard_control_sensors_enabled, onboard_control_sensors_health, load, voltage_battery, current_battery, battery_remaining, drop_rate_comm, errors_comm, errors_count1, errors_count2, errors_count3, errors_count4, force_mavlink1=False):\n                '''\n                The general system state. If the system is following the MAVLink\n                standard, the system state is mainly defined by three\n                orthogonal states/modes: The system mode, which is\n                either LOCKED (motors shut down and locked), MANUAL\n                (system under RC control), GUIDED (system with\n                autonomous position control, position setpoint\n                controlled manually) or AUTO (system guided by\n                path/waypoint planner). The NAV_MODE defined the\n                current flight state: LIFTOFF (often an open-loop\n                maneuver), LANDING, WAYPOINTS or VECTOR. This\n                represents the internal navigation state machine. The\n                system status shows wether the system is currently\n                active or not and if an emergency occured. During the\n                CRITICAL and EMERGENCY states the MAV is still\n                considered to be active, but should start emergency\n                procedures autonomously. After a failure occured it\n                should first move from active to critical to allow\n                manual intervention and then move to emergency after a\n                certain timeout.\n\n                onboard_control_sensors_present        : Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR (uint32_t)\n                onboard_control_sensors_enabled        : Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR (uint32_t)\n                onboard_control_sensors_health        : Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR (uint32_t)\n                load                      : Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000 (uint16_t)\n                voltage_battery           : Battery voltage, in millivolts (1 = 1 millivolt) (uint16_t)\n                current_battery           : Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current (int16_t)\n                battery_remaining         : Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot estimate the remaining battery (int8_t)\n                drop_rate_comm            : Communication drops in percent, (0%: 0, 100%: 10'000), (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV) (uint16_t)\n                errors_comm               : Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV) (uint16_t)\n                errors_count1             : Autopilot-specific errors (uint16_t)\n                errors_count2             : Autopilot-specific errors (uint16_t)\n                errors_count3             : Autopilot-specific errors (uint16_t)\n                errors_count4             : Autopilot-specific errors (uint16_t)\n\n                '''\n                return self.send(self.sys_status_encode(onboard_control_sensors_present, onboard_control_sensors_enabled, onboard_control_sensors_health, load, voltage_battery, current_battery, battery_remaining, drop_rate_comm, errors_comm, errors_count1, errors_count2, errors_count3, errors_count4), force_mavlink1=force_mavlink1)", "response": "The general system state. If the system is following the MAVLink\n                standard, the system state is mainly defined by three\n                orthogonal states/modes: The system mode, which is\n                either LOCKED (motors shut down and locked), MANUAL\n                (system under RC control), GUIDED (system with\n                autonomous position control, position setpoint\n                controlled manually) or AUTO (system guided by\n                path/waypoint planner). The NAV_MODE defined the\n                current flight state: LIFTOFF (often an open-loop\n                maneuver), LANDING, WAYPOINTS or VECTOR. This\n                represents the internal navigation state machine. The\n                system status shows wether the system is currently\n                active or not and if an emergency occured. During the\n                CRITICAL and EMERGENCY states the MAV is still\n                considered to be active, but should start emergency\n                procedures autonomously. After a failure occured it\n                should first move from active to critical to allow\n                manual intervention and then move to emergency after a\n                certain timeout.\n\n                onboard_control_sensors_present        : Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR (uint32_t)\n                onboard_control_sensors_enabled        : Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR (uint32_t)\n                onboard_control_sensors_health        : Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR (uint32_t)\n                load                      : Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000 (uint16_t)\n                voltage_battery           : Battery voltage, in millivolts (1 = 1 millivolt) (uint16_t)\n                current_battery           : Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current (int16_t)\n                battery_remaining         : Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot estimate the remaining battery (int8_t)\n                drop_rate_comm            : Communication drops in percent, (0%: 0, 100%: 10'000), (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV) (uint16_t)\n                errors_comm               : Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV) (uint16_t)\n                errors_count1             : Autopilot-specific errors (uint16_t)\n                errors_count2             : Autopilot-specific errors (uint16_t)\n                errors_count3             : Autopilot-specific errors (uint16_t)\n                errors_count4             : Autopilot-specific errors (uint16_t)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef system_time_send(self, time_unix_usec, time_boot_ms, force_mavlink1=False):\n                '''\n                The system time is the time of the master clock, typically the\n                computer clock of the main onboard computer.\n\n                time_unix_usec            : Timestamp of the master clock in microseconds since UNIX epoch. (uint64_t)\n                time_boot_ms              : Timestamp of the component clock since boot time in milliseconds. (uint32_t)\n\n                '''\n                return self.send(self.system_time_encode(time_unix_usec, time_boot_ms), force_mavlink1=force_mavlink1)", "response": "The system time is the time of the master clock, typically the\n                computer clock of the main onboard computer.\n\n                time_unix_usec            : Timestamp of the master clock in microseconds since UNIX epoch. (uint64_t)\n                time_boot_ms              : Timestamp of the component clock since boot time in milliseconds. (uint32_t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ping_send(self, time_usec, seq, target_system, target_component, force_mavlink1=False):\n                '''\n                A ping message either requesting or responding to a ping. This allows\n                to measure the system latencies, including serial\n                port, radio modem and UDP connections.\n\n                time_usec                 : Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009) (uint64_t)\n                seq                       : PING sequence (uint32_t)\n                target_system             : 0: request ping from all receiving systems, if greater than 0: message is a ping response and number is the system id of the requesting system (uint8_t)\n                target_component          : 0: request ping from all receiving components, if greater than 0: message is a ping response and number is the system id of the requesting system (uint8_t)\n\n                '''\n                return self.send(self.ping_encode(time_usec, seq, target_system, target_component), force_mavlink1=force_mavlink1)", "response": "A ping message either requesting or responding to a ping. This allows\n                to measure the system latencies, including serial\n                port, radio modem and UDP connections.\n\n                time_usec                 : Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009) (uint64_t)\n                seq                       : PING sequence (uint32_t)\n                target_system             : 0: request ping from all receiving systems, if greater than 0: message is a ping response and number is the system id of the requesting system (uint8_t)\n                target_component          : 0: request ping from all receiving components, if greater than 0: message is a ping response and number is the system id of the requesting system (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef change_operator_control_encode(self, target_system, control_request, version, passkey):\n                '''\n                Request to control this MAV\n\n                target_system             : System the GCS requests control for (uint8_t)\n                control_request           : 0: request control of this MAV, 1: Release control of this MAV (uint8_t)\n                version                   : 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch. (uint8_t)\n                passkey                   : Password / Key, depending on version plaintext or encrypted. 25 or less characters, NULL terminated. The characters may involve A-Z, a-z, 0-9, and \"!?,.-\" (char)\n\n                '''\n                return MAVLink_change_operator_control_message(target_system, control_request, version, passkey)", "response": "This function is called when the MAVLink_change_operator_control_message is called from MAVLink to send a message to the other MAVLink clients to control the current state of the current state of the current state of the current state of the current state of the GCS."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange the state of the operator control message.", "response": "def change_operator_control_send(self, target_system, control_request, version, passkey, force_mavlink1=False):\n                '''\n                Request to control this MAV\n\n                target_system             : System the GCS requests control for (uint8_t)\n                control_request           : 0: request control of this MAV, 1: Release control of this MAV (uint8_t)\n                version                   : 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch. (uint8_t)\n                passkey                   : Password / Key, depending on version plaintext or encrypted. 25 or less characters, NULL terminated. The characters may involve A-Z, a-z, 0-9, and \"!?,.-\" (char)\n\n                '''\n                return self.send(self.change_operator_control_encode(target_system, control_request, version, passkey), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef change_operator_control_ack_send(self, gcs_system_id, control_request, ack, force_mavlink1=False):\n                '''\n                Accept / deny control of this MAV\n\n                gcs_system_id             : ID of the GCS this message (uint8_t)\n                control_request           : 0: request control of this MAV, 1: Release control of this MAV (uint8_t)\n                ack                       : 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control (uint8_t)\n\n                '''\n                return self.send(self.change_operator_control_ack_encode(gcs_system_id, control_request, ack), force_mavlink1=force_mavlink1)", "response": "Acknowledge that a change of the control request was received from the GCS."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef auth_key_send(self, key, force_mavlink1=False):\n                '''\n                Emit an encrypted signature / key identifying this system. PLEASE\n                NOTE: This protocol has been kept simple, so\n                transmitting the key requires an encrypted channel for\n                true safety.\n\n                key                       : key (char)\n\n                '''\n                return self.send(self.auth_key_encode(key), force_mavlink1=force_mavlink1)", "response": "This message is used to send an encrypted signature or key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_mode_send(self, target_system, base_mode, custom_mode, force_mavlink1=False):\n                '''\n                THIS INTERFACE IS DEPRECATED. USE COMMAND_LONG with\n                MAV_CMD_DO_SET_MODE INSTEAD. Set the system mode, as\n                defined by enum MAV_MODE. There is no target component\n                id as the mode is by definition for the overall\n                aircraft, not only for one component.\n\n                target_system             : The system setting the mode (uint8_t)\n                base_mode                 : The new base mode (uint8_t)\n                custom_mode               : The new autopilot-specific mode. This field can be ignored by an autopilot. (uint32_t)\n\n                '''\n                return self.send(self.set_mode_encode(target_system, base_mode, custom_mode), force_mavlink1=force_mavlink1)", "response": "Set the mode of the overall CAN AIL file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef param_request_read_encode(self, target_system, target_component, param_id, param_index):\n                '''\n                Request to read the onboard parameter with the param_id string id.\n                Onboard parameters are stored as key[const char*] ->\n                value[float]. This allows to send a parameter to any\n                other component (such as the GCS) without the need of\n                previous knowledge of possible parameter names. Thus\n                the same GCS can store different parameters for\n                different autopilots. See also\n                http://qgroundcontrol.org/parameter_interface for a\n                full documentation of QGroundControl and IMU code.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                param_id                  : Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string (char)\n                param_index               : Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored) (int16_t)\n\n                '''\n                return MAVLink_param_request_read_message(target_system, target_component, param_id, param_index)", "response": "Request to read a onboard parameter from the GCS."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrequesting to read the onboard parameter with the given id.", "response": "def param_request_read_send(self, target_system, target_component, param_id, param_index, force_mavlink1=False):\n                '''\n                Request to read the onboard parameter with the param_id string id.\n                Onboard parameters are stored as key[const char*] ->\n                value[float]. This allows to send a parameter to any\n                other component (such as the GCS) without the need of\n                previous knowledge of possible parameter names. Thus\n                the same GCS can store different parameters for\n                different autopilots. See also\n                http://qgroundcontrol.org/parameter_interface for a\n                full documentation of QGroundControl and IMU code.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                param_id                  : Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string (char)\n                param_index               : Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored) (int16_t)\n\n                '''\n                return self.send(self.param_request_read_encode(target_system, target_component, param_id, param_index), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrequests all parameters of this component.", "response": "def param_request_list_send(self, target_system, target_component, force_mavlink1=False):\n                '''\n                Request all parameters of this component. After this request, all\n                parameters are emitted.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n\n                '''\n                return self.send(self.param_request_list_encode(target_system, target_component), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nemitting the value of a onboard parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows him to re-request missing parameters after a loss or timeout. param_id : Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string (char) param_value : Onboard parameter value (float) param_type : Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types. (uint8_t) param_count : Total number of onboard parameters (uint16_t) param_index : Index of this onboard parameter (uint16_t)", "response": "def param_value_encode(self, param_id, param_value, param_type, param_count, param_index):\n                '''\n                Emit the value of a onboard parameter. The inclusion of param_count\n                and param_index in the message allows the recipient to\n                keep track of received parameters and allows him to\n                re-request missing parameters after a loss or timeout.\n\n                param_id                  : Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string (char)\n                param_value               : Onboard parameter value (float)\n                param_type                : Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types. (uint8_t)\n                param_count               : Total number of onboard parameters (uint16_t)\n                param_index               : Index of this onboard parameter (uint16_t)\n\n                '''\n                return MAVLink_param_value_message(param_id, param_value, param_type, param_count, param_index)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef param_value_send(self, param_id, param_value, param_type, param_count, param_index, force_mavlink1=False):\n                '''\n                Emit the value of a onboard parameter. The inclusion of param_count\n                and param_index in the message allows the recipient to\n                keep track of received parameters and allows him to\n                re-request missing parameters after a loss or timeout.\n\n                param_id                  : Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string (char)\n                param_value               : Onboard parameter value (float)\n                param_type                : Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types. (uint8_t)\n                param_count               : Total number of onboard parameters (uint16_t)\n                param_index               : Index of this onboard parameter (uint16_t)\n\n                '''\n                return self.send(self.param_value_encode(param_id, param_value, param_type, param_count, param_index), force_mavlink1=force_mavlink1)", "response": "This message is sent to the Him to get the value of a onboard parameter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef param_set_encode(self, target_system, target_component, param_id, param_value, param_type):\n                '''\n                Set a parameter value TEMPORARILY to RAM. It will be reset to default\n                on system reboot. Send the ACTION\n                MAV_ACTION_STORAGE_WRITE to PERMANENTLY write the RAM\n                contents to EEPROM. IMPORTANT: The receiving component\n                should acknowledge the new parameter value by sending\n                a param_value message to all communication partners.\n                This will also ensure that multiple GCS all have an\n                up-to-date list of all parameters. If the sending GCS\n                did not receive a PARAM_VALUE message within its\n                timeout time, it should re-send the PARAM_SET message.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                param_id                  : Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string (char)\n                param_value               : Onboard parameter value (float)\n                param_type                : Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types. (uint8_t)\n\n                '''\n                return MAVLink_param_set_message(target_system, target_component, param_id, param_value, param_type)", "response": "This function is called by the component to set a parameter value in the component and the parameter type. It is used to set the value of the parameter in the component to RAM."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef param_set_send(self, target_system, target_component, param_id, param_value, param_type, force_mavlink1=False):\n                '''\n                Set a parameter value TEMPORARILY to RAM. It will be reset to default\n                on system reboot. Send the ACTION\n                MAV_ACTION_STORAGE_WRITE to PERMANENTLY write the RAM\n                contents to EEPROM. IMPORTANT: The receiving component\n                should acknowledge the new parameter value by sending\n                a param_value message to all communication partners.\n                This will also ensure that multiple GCS all have an\n                up-to-date list of all parameters. If the sending GCS\n                did not receive a PARAM_VALUE message within its\n                timeout time, it should re-send the PARAM_SET message.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                param_id                  : Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string (char)\n                param_value               : Onboard parameter value (float)\n                param_type                : Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types. (uint8_t)\n\n                '''\n                return self.send(self.param_set_encode(target_system, target_component, param_id, param_value, param_type), force_mavlink1=force_mavlink1)", "response": "This message is sent to the component to set a parameter value. It will reset the RAM to default."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef scaled_imu_send(self, time_boot_ms, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag, force_mavlink1=False):\n                '''\n                The RAW IMU readings for the usual 9DOF sensor setup. This message\n                should contain the scaled values to the described\n                units\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                xacc                      : X acceleration (mg) (int16_t)\n                yacc                      : Y acceleration (mg) (int16_t)\n                zacc                      : Z acceleration (mg) (int16_t)\n                xgyro                     : Angular speed around X axis (millirad /sec) (int16_t)\n                ygyro                     : Angular speed around Y axis (millirad /sec) (int16_t)\n                zgyro                     : Angular speed around Z axis (millirad /sec) (int16_t)\n                xmag                      : X Magnetic field (milli tesla) (int16_t)\n                ymag                      : Y Magnetic field (milli tesla) (int16_t)\n                zmag                      : Z Magnetic field (milli tesla) (int16_t)\n\n                '''\n                return self.send(self.scaled_imu_encode(time_boot_ms, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag), force_mavlink1=force_mavlink1)", "response": "This message is used to set the IMU readings to the specified values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef raw_imu_send(self, time_usec, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag, force_mavlink1=False):\n                '''\n                The RAW IMU readings for the usual 9DOF sensor setup. This message\n                should always contain the true raw values without any\n                scaling to allow data capture and system debugging.\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                xacc                      : X acceleration (raw) (int16_t)\n                yacc                      : Y acceleration (raw) (int16_t)\n                zacc                      : Z acceleration (raw) (int16_t)\n                xgyro                     : Angular speed around X axis (raw) (int16_t)\n                ygyro                     : Angular speed around Y axis (raw) (int16_t)\n                zgyro                     : Angular speed around Z axis (raw) (int16_t)\n                xmag                      : X Magnetic field (raw) (int16_t)\n                ymag                      : Y Magnetic field (raw) (int16_t)\n                zmag                      : Z Magnetic field (raw) (int16_t)\n\n                '''\n                return self.send(self.raw_imu_encode(time_usec, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag), force_mavlink1=force_mavlink1)", "response": "The RAW IMU readings for the usual 9DOF sensor setup. This message\n                should always contain the true raw values without any\n                scaling to allow data capture and system debugging.\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                xacc                      : X acceleration (raw) (int16_t)\n                yacc                      : Y acceleration (raw) (int16_t)\n                zacc                      : Z acceleration (raw) (int16_t)\n                xgyro                     : Angular speed around X axis (raw) (int16_t)\n                ygyro                     : Angular speed around Y axis (raw) (int16_t)\n                zgyro                     : Angular speed around Z axis (raw) (int16_t)\n                xmag                      : X Magnetic field (raw) (int16_t)\n                ymag                      : Y Magnetic field (raw) (int16_t)\n                zmag                      : Z Magnetic field (raw) (int16_t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef raw_pressure_encode(self, time_usec, press_abs, press_diff1, press_diff2, temperature):\n                '''\n                The RAW pressure readings for the typical setup of one absolute\n                pressure and one differential pressure sensor. The\n                sensor values should be the raw, UNSCALED ADC values.\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                press_abs                 : Absolute pressure (raw) (int16_t)\n                press_diff1               : Differential pressure 1 (raw, 0 if nonexistant) (int16_t)\n                press_diff2               : Differential pressure 2 (raw, 0 if nonexistant) (int16_t)\n                temperature               : Raw Temperature measurement (raw) (int16_t)\n\n                '''\n                return MAVLink_raw_pressure_message(time_usec, press_abs, press_diff1, press_diff2, temperature)", "response": "This function is called when the MAVLink module is loaded and is ready to read the raw pressure values."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef raw_pressure_send(self, time_usec, press_abs, press_diff1, press_diff2, temperature, force_mavlink1=False):\n                '''\n                The RAW pressure readings for the typical setup of one absolute\n                pressure and one differential pressure sensor. The\n                sensor values should be the raw, UNSCALED ADC values.\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                press_abs                 : Absolute pressure (raw) (int16_t)\n                press_diff1               : Differential pressure 1 (raw, 0 if nonexistant) (int16_t)\n                press_diff2               : Differential pressure 2 (raw, 0 if nonexistant) (int16_t)\n                temperature               : Raw Temperature measurement (raw) (int16_t)\n\n                '''\n                return self.send(self.raw_pressure_encode(time_usec, press_abs, press_diff1, press_diff2, temperature), force_mavlink1=force_mavlink1)", "response": "Raw pressure readings for the absolute and differential pressure sensor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scaled_pressure_encode(self, time_boot_ms, press_abs, press_diff, temperature):\n                '''\n                The pressure readings for the typical setup of one absolute and\n                differential pressure sensor. The units are as\n                specified in each field.\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                press_abs                 : Absolute pressure (hectopascal) (float)\n                press_diff                : Differential pressure 1 (hectopascal) (float)\n                temperature               : Temperature measurement (0.01 degrees celsius) (int16_t)\n\n                '''\n                return MAVLink_scaled_pressure_message(time_boot_ms, press_abs, press_diff, temperature)", "response": "This function is called when the system is booted and the pressure readings are scaled."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef attitude_encode(self, time_boot_ms, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed):\n                '''\n                The attitude in the aeronautical frame (right-handed, Z-down, X-front,\n                Y-right).\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                roll                      : Roll angle (rad, -pi..+pi) (float)\n                pitch                     : Pitch angle (rad, -pi..+pi) (float)\n                yaw                       : Yaw angle (rad, -pi..+pi) (float)\n                rollspeed                 : Roll angular speed (rad/s) (float)\n                pitchspeed                : Pitch angular speed (rad/s) (float)\n                yawspeed                  : Yaw angular speed (rad/s) (float)\n\n                '''\n                return MAVLink_attitude_message(time_boot_ms, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed)", "response": "This function is called when the system is booted and the attitude is set to right - handed Z - down X - front Y - right."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef attitude_send(self, time_boot_ms, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed, force_mavlink1=False):\n                '''\n                The attitude in the aeronautical frame (right-handed, Z-down, X-front,\n                Y-right).\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                roll                      : Roll angle (rad, -pi..+pi) (float)\n                pitch                     : Pitch angle (rad, -pi..+pi) (float)\n                yaw                       : Yaw angle (rad, -pi..+pi) (float)\n                rollspeed                 : Roll angular speed (rad/s) (float)\n                pitchspeed                : Pitch angular speed (rad/s) (float)\n                yawspeed                  : Yaw angular speed (rad/s) (float)\n\n                '''\n                return self.send(self.attitude_encode(time_boot_ms, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed), force_mavlink1=force_mavlink1)", "response": "Attitude in the aeronautical frame."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef global_position_int_send(self, time_boot_ms, lat, lon, alt, relative_alt, vx, vy, vz, hdg, force_mavlink1=False):\n                '''\n                The filtered global position (e.g. fused GPS and accelerometers). The\n                position is in GPS-frame (right-handed, Z-up). It\n                is designed as scaled integer message since the\n                resolution of float is not sufficient.\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                lat                       : Latitude, expressed as degrees * 1E7 (int32_t)\n                lon                       : Longitude, expressed as degrees * 1E7 (int32_t)\n                alt                       : Altitude in meters, expressed as * 1000 (millimeters), AMSL (not WGS84 - note that virtually all GPS modules provide the AMSL as well) (int32_t)\n                relative_alt              : Altitude above ground in meters, expressed as * 1000 (millimeters) (int32_t)\n                vx                        : Ground X Speed (Latitude, positive north), expressed as m/s * 100 (int16_t)\n                vy                        : Ground Y Speed (Longitude, positive east), expressed as m/s * 100 (int16_t)\n                vz                        : Ground Z Speed (Altitude, positive down), expressed as m/s * 100 (int16_t)\n                hdg                       : Vehicle heading (yaw angle) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX (uint16_t)\n\n                '''\n                return self.send(self.global_position_int_encode(time_boot_ms, lat, lon, alt, relative_alt, vx, vy, vz, hdg), force_mavlink1=force_mavlink1)", "response": "The filtered global position (e.g. fused GPS and accelerometers). The\n                position is in GPS-frame (right-handed, Z-up). It\n                is designed as scaled integer message since the\n                resolution of float is not sufficient.\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                lat                       : Latitude, expressed as degrees * 1E7 (int32_t)\n                lon                       : Longitude, expressed as degrees * 1E7 (int32_t)\n                alt                       : Altitude in meters, expressed as * 1000 (millimeters), AMSL (not WGS84 - note that virtually all GPS modules provide the AMSL as well) (int32_t)\n                relative_alt              : Altitude above ground in meters, expressed as * 1000 (millimeters) (int32_t)\n                vx                        : Ground X Speed (Latitude, positive north), expressed as m/s * 100 (int16_t)\n                vy                        : Ground Y Speed (Longitude, positive east), expressed as m/s * 100 (int16_t)\n                vz                        : Ground Z Speed (Altitude, positive down), expressed as m/s * 100 (int16_t)\n                hdg                       : Vehicle heading (yaw angle) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX (uint16_t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nencodes the scaled values of the RC channels received.", "response": "def rc_channels_scaled_encode(self, time_boot_ms, port, chan1_scaled, chan2_scaled, chan3_scaled, chan4_scaled, chan5_scaled, chan6_scaled, chan7_scaled, chan8_scaled, rssi):\n                '''\n                The scaled values of the RC channels received. (-100%) -10000, (0%) 0,\n                (100%) 10000. Channels that are inactive should be set\n                to UINT16_MAX.\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                port                      : Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos. (uint8_t)\n                chan1_scaled              : RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX. (int16_t)\n                chan2_scaled              : RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX. (int16_t)\n                chan3_scaled              : RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX. (int16_t)\n                chan4_scaled              : RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX. (int16_t)\n                chan5_scaled              : RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX. (int16_t)\n                chan6_scaled              : RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX. (int16_t)\n                chan7_scaled              : RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX. (int16_t)\n                chan8_scaled              : RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX. (int16_t)\n                rssi                      : Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown. (uint8_t)\n\n                '''\n                return MAVLink_rc_channels_scaled_message(time_boot_ms, port, chan1_scaled, chan2_scaled, chan3_scaled, chan4_scaled, chan5_scaled, chan6_scaled, chan7_scaled, chan8_scaled, rssi)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rc_channels_raw_encode(self, time_boot_ms, port, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, rssi):\n                '''\n                The RAW values of the RC channels received. The standard PPM\n                modulation is as follows: 1000 microseconds: 0%, 2000\n                microseconds: 100%. Individual receivers/transmitters\n                might violate this specification.\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                port                      : Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos. (uint8_t)\n                chan1_raw                 : RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan2_raw                 : RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan3_raw                 : RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan4_raw                 : RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan5_raw                 : RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan6_raw                 : RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan7_raw                 : RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan8_raw                 : RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                rssi                      : Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown. (uint8_t)\n\n                '''\n                return MAVLink_rc_channels_raw_message(time_boot_ms, port, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, rssi)", "response": "This function encodes the raw values of the RC channels received from the system."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencoding the servo output", "response": "def servo_output_raw_encode(self, time_usec, port, servo1_raw, servo2_raw, servo3_raw, servo4_raw, servo5_raw, servo6_raw, servo7_raw, servo8_raw):\n                '''\n                The RAW values of the servo outputs (for RC input from the remote, use\n                the RC_CHANNELS messages). The standard PPM modulation\n                is as follows: 1000 microseconds: 0%, 2000\n                microseconds: 100%.\n\n                time_usec                 : Timestamp (microseconds since system boot) (uint32_t)\n                port                      : Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos. (uint8_t)\n                servo1_raw                : Servo output 1 value, in microseconds (uint16_t)\n                servo2_raw                : Servo output 2 value, in microseconds (uint16_t)\n                servo3_raw                : Servo output 3 value, in microseconds (uint16_t)\n                servo4_raw                : Servo output 4 value, in microseconds (uint16_t)\n                servo5_raw                : Servo output 5 value, in microseconds (uint16_t)\n                servo6_raw                : Servo output 6 value, in microseconds (uint16_t)\n                servo7_raw                : Servo output 7 value, in microseconds (uint16_t)\n                servo8_raw                : Servo output 8 value, in microseconds (uint16_t)\n\n                '''\n                return MAVLink_servo_output_raw_message(time_usec, port, servo1_raw, servo2_raw, servo3_raw, servo4_raw, servo5_raw, servo6_raw, servo7_raw, servo8_raw)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef servo_output_raw_send(self, time_usec, port, servo1_raw, servo2_raw, servo3_raw, servo4_raw, servo5_raw, servo6_raw, servo7_raw, servo8_raw, force_mavlink1=False):\n                '''\n                The RAW values of the servo outputs (for RC input from the remote, use\n                the RC_CHANNELS messages). The standard PPM modulation\n                is as follows: 1000 microseconds: 0%, 2000\n                microseconds: 100%.\n\n                time_usec                 : Timestamp (microseconds since system boot) (uint32_t)\n                port                      : Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos. (uint8_t)\n                servo1_raw                : Servo output 1 value, in microseconds (uint16_t)\n                servo2_raw                : Servo output 2 value, in microseconds (uint16_t)\n                servo3_raw                : Servo output 3 value, in microseconds (uint16_t)\n                servo4_raw                : Servo output 4 value, in microseconds (uint16_t)\n                servo5_raw                : Servo output 5 value, in microseconds (uint16_t)\n                servo6_raw                : Servo output 6 value, in microseconds (uint16_t)\n                servo7_raw                : Servo output 7 value, in microseconds (uint16_t)\n                servo8_raw                : Servo output 8 value, in microseconds (uint16_t)\n\n                '''\n                return self.send(self.servo_output_raw_encode(time_usec, port, servo1_raw, servo2_raw, servo3_raw, servo4_raw, servo5_raw, servo6_raw, servo7_raw, servo8_raw), force_mavlink1=force_mavlink1)", "response": "Servo output raw data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mission_request_partial_list_encode(self, target_system, target_component, start_index, end_index):\n                '''\n                Request a partial list of mission items from the system/component.\n                http://qgroundcontrol.org/mavlink/waypoint_protocol.\n                If start and end index are the same, just send one\n                waypoint.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                start_index               : Start index, 0 by default (int16_t)\n                end_index                 : End index, -1 by default (-1: send list to end). Else a valid index of the list (int16_t)\n\n                '''\n                return MAVLink_mission_request_partial_list_message(target_system, target_component, start_index, end_index)", "response": "Request a list of mission items from the system and component."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrequesting a partial list of mission items from the system or component.", "response": "def mission_request_partial_list_send(self, target_system, target_component, start_index, end_index, force_mavlink1=False):\n                '''\n                Request a partial list of mission items from the system/component.\n                http://qgroundcontrol.org/mavlink/waypoint_protocol.\n                If start and end index are the same, just send one\n                waypoint.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                start_index               : Start index, 0 by default (int16_t)\n                end_index                 : End index, -1 by default (-1: send list to end). Else a valid index of the list (int16_t)\n\n                '''\n                return self.send(self.mission_request_partial_list_encode(target_system, target_component, start_index, end_index), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mission_write_partial_list_encode(self, target_system, target_component, start_index, end_index):\n                '''\n                This message is sent to the MAV to write a partial list. If start\n                index == end index, only one item will be transmitted\n                / updated. If the start index is NOT 0 and above the\n                current list size, this request should be REJECTED!\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                start_index               : Start index, 0 by default and smaller / equal to the largest index of the current onboard list. (int16_t)\n                end_index                 : End index, equal or greater than start index. (int16_t)\n\n                '''\n                return MAVLink_mission_write_partial_list_message(target_system, target_component, start_index, end_index)", "response": "This function is called when a mission is written to a list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nencoding a mission item", "response": "def mission_item_encode(self, target_system, target_component, seq, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z):\n                '''\n                Message encoding a mission item. This message is emitted to announce\n                the presence of a mission item and to set a mission\n                item on the system. The mission item can be either in\n                x, y, z meters (type: LOCAL) or x:lat, y:lon,\n                z:altitude. Local frame is Z-down, right handed (NED),\n                global frame is Z-up, right handed (ENU). See also\n                http://qgroundcontrol.org/mavlink/waypoint_protocol.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seq                       : Sequence (uint16_t)\n                frame                     : The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h (uint8_t)\n                command                   : The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs (uint16_t)\n                current                   : false:0, true:1 (uint8_t)\n                autocontinue              : autocontinue to next wp (uint8_t)\n                param1                    : PARAM1, see MAV_CMD enum (float)\n                param2                    : PARAM2, see MAV_CMD enum (float)\n                param3                    : PARAM3, see MAV_CMD enum (float)\n                param4                    : PARAM4, see MAV_CMD enum (float)\n                x                         : PARAM5 / local: x position, global: latitude (float)\n                y                         : PARAM6 / y position: global: longitude (float)\n                z                         : PARAM7 / z position: global: altitude (relative or absolute, depending on frame. (float)\n\n                '''\n                return MAVLink_mission_item_message(target_system, target_component, seq, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrequest information of the mission item with the sequence number seq.", "response": "def mission_request_send(self, target_system, target_component, seq, force_mavlink1=False):\n                '''\n                Request the information of the mission item with the sequence number\n                seq. The response of the system to this message should\n                be a MISSION_ITEM message.\n                http://qgroundcontrol.org/mavlink/waypoint_protocol\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seq                       : Sequence (uint16_t)\n\n                '''\n                return self.send(self.mission_request_encode(target_system, target_component, seq), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mission_set_current_send(self, target_system, target_component, seq, force_mavlink1=False):\n                '''\n                Set the mission item with sequence number seq as current item. This\n                means that the MAV will continue to this mission item\n                on the shortest path (not following the mission items\n                in-between).\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seq                       : Sequence (uint16_t)\n\n                '''\n                return self.send(self.mission_set_current_encode(target_system, target_component, seq), force_mavlink1=force_mavlink1)", "response": "Set the current item of the mission item with sequence number seq."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmessage that announces the sequence number of the current active mission item. The MAV will fly towards this mission item. seq : Sequence (uint16_t)", "response": "def mission_current_send(self, seq, force_mavlink1=False):\n                '''\n                Message that announces the sequence number of the current active\n                mission item. The MAV will fly towards this mission\n                item.\n\n                seq                       : Sequence (uint16_t)\n\n                '''\n                return self.send(self.mission_current_encode(seq), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mission_request_list_send(self, target_system, target_component, force_mavlink1=False):\n                '''\n                Request the overall list of mission items from the system/component.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n\n                '''\n                return self.send(self.mission_request_list_encode(target_system, target_component), force_mavlink1=force_mavlink1)", "response": "Request the overall list of mission items from the system and component."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mission_count_send(self, target_system, target_component, count, force_mavlink1=False):\n                '''\n                This message is emitted as response to MISSION_REQUEST_LIST by the MAV\n                and to initiate a write transaction. The GCS can then\n                request the individual mission item based on the\n                knowledge of the total number of MISSIONs.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                count                     : Number of mission items in the sequence (uint16_t)\n\n                '''\n                return self.send(self.mission_count_encode(target_system, target_component, count), force_mavlink1=force_mavlink1)", "response": "This message is emitted as response to MISSION_REQUEST_LIST by the GCS. It is used to initiate a write transaction."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete all mission items at once.", "response": "def mission_clear_all_send(self, target_system, target_component, force_mavlink1=False):\n                '''\n                Delete all mission items at once.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n\n                '''\n                return self.send(self.mission_clear_all_encode(target_system, target_component), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mission_item_reached_send(self, seq, force_mavlink1=False):\n                '''\n                A certain mission item has been reached. The system will either hold\n                this position (or circle on the orbit) or (if the\n                autocontinue on the WP was set) continue to the next\n                MISSION.\n\n                seq                       : Sequence (uint16_t)\n\n                '''\n                return self.send(self.mission_item_reached_encode(seq), force_mavlink1=force_mavlink1)", "response": "This message is sent when a mission item is reached."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mission_ack_send(self, target_system, target_component, type, force_mavlink1=False):\n                '''\n                Ack message during MISSION handling. The type field states if this\n                message is a positive ack (type=0) or if an error\n                happened (type=non-zero).\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                type                      : See MAV_MISSION_RESULT enum (uint8_t)\n\n                '''\n                return self.send(self.mission_ack_encode(target_system, target_component, type), force_mavlink1=force_mavlink1)", "response": "This message is an ack from the mission."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset global waypoint origin", "response": "def set_gps_global_origin_send(self, target_system, latitude, longitude, altitude, force_mavlink1=False):\n                '''\n                As local waypoints exist, the global MISSION reference allows to\n                transform between the local coordinate frame and the\n                global (GPS) coordinate frame. This can be necessary\n                when e.g. in- and outdoor settings are connected and\n                the MAV should move from in- to outdoor.\n\n                target_system             : System ID (uint8_t)\n                latitude                  : Latitude (WGS84), in degrees * 1E7 (int32_t)\n                longitude                 : Longitude (WGS84, in degrees * 1E7 (int32_t)\n                altitude                  : Altitude (AMSL), in meters * 1000 (positive for up) (int32_t)\n\n                '''\n                return self.send(self.set_gps_global_origin_encode(target_system, latitude, longitude, altitude), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef param_map_rc_encode(self, target_system, target_component, param_id, param_index, parameter_rc_channel_index, param_value0, scale, param_value_min, param_value_max):\n                '''\n                Bind a RC channel to a parameter. The parameter should change accoding\n                to the RC channel value.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                param_id                  : Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string (char)\n                param_index               : Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index. (int16_t)\n                parameter_rc_channel_index        : Index of parameter RC channel. Not equal to the RC channel id. Typically correpsonds to a potentiometer-knob on the RC. (uint8_t)\n                param_value0              : Initial parameter value (float)\n                scale                     : Scale, maps the RC range [-1, 1] to a parameter value (float)\n                param_value_min           : Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation) (float)\n                param_value_max           : Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation) (float)\n\n                '''\n                return MAVLink_param_map_rc_message(target_system, target_component, param_id, param_index, parameter_rc_channel_index, param_value0, scale, param_value_min, param_value_max)", "response": "This function maps the onboard parameter values to the onboard parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef param_map_rc_send(self, target_system, target_component, param_id, param_index, parameter_rc_channel_index, param_value0, scale, param_value_min, param_value_max, force_mavlink1=False):\n                '''\n                Bind a RC channel to a parameter. The parameter should change accoding\n                to the RC channel value.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                param_id                  : Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string (char)\n                param_index               : Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index. (int16_t)\n                parameter_rc_channel_index        : Index of parameter RC channel. Not equal to the RC channel id. Typically correpsonds to a potentiometer-knob on the RC. (uint8_t)\n                param_value0              : Initial parameter value (float)\n                scale                     : Scale, maps the RC range [-1, 1] to a parameter value (float)\n                param_value_min           : Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation) (float)\n                param_value_max           : Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation) (float)\n\n                '''\n                return self.send(self.param_map_rc_encode(target_system, target_component, param_id, param_index, parameter_rc_channel_index, param_value0, scale, param_value_min, param_value_max), force_mavlink1=force_mavlink1)", "response": "This function maps the onboard parameter values to the onboard parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrequests the information of the mission item with the sequence number seq.", "response": "def mission_request_int_send(self, target_system, target_component, seq, force_mavlink1=False):\n                '''\n                Request the information of the mission item with the sequence number\n                seq. The response of the system to this message should\n                be a MISSION_ITEM_INT message.\n                http://qgroundcontrol.org/mavlink/waypoint_protocol\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seq                       : Sequence (uint16_t)\n\n                '''\n                return self.send(self.mission_request_int_encode(target_system, target_component, seq), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef safety_set_allowed_area_encode(self, target_system, target_component, frame, p1x, p1y, p1z, p2x, p2y, p2z):\n                '''\n                Set a safety zone (volume), which is defined by two corners of a cube.\n                This message can be used to tell the MAV which\n                setpoints/MISSIONs to accept and which to reject.\n                Safety areas are often enforced by national or\n                competition regulations.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                frame                     : Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down. (uint8_t)\n                p1x                       : x position 1 / Latitude 1 (float)\n                p1y                       : y position 1 / Longitude 1 (float)\n                p1z                       : z position 1 / Altitude 1 (float)\n                p2x                       : x position 2 / Latitude 2 (float)\n                p2y                       : y position 2 / Longitude 2 (float)\n                p2z                       : z position 2 / Altitude 2 (float)\n\n                '''\n                return MAVLink_safety_set_allowed_area_message(target_system, target_component, frame, p1x, p1y, p1z, p2x, p2y, p2z)", "response": "This function is used to set a safety zone for all the components in the system."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset a safety zone for all possible setpoints.", "response": "def safety_set_allowed_area_send(self, target_system, target_component, frame, p1x, p1y, p1z, p2x, p2y, p2z, force_mavlink1=False):\n                '''\n                Set a safety zone (volume), which is defined by two corners of a cube.\n                This message can be used to tell the MAV which\n                setpoints/MISSIONs to accept and which to reject.\n                Safety areas are often enforced by national or\n                competition regulations.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                frame                     : Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down. (uint8_t)\n                p1x                       : x position 1 / Latitude 1 (float)\n                p1y                       : y position 1 / Longitude 1 (float)\n                p1z                       : z position 1 / Altitude 1 (float)\n                p2x                       : x position 2 / Latitude 2 (float)\n                p2y                       : y position 2 / Longitude 2 (float)\n                p2z                       : z position 2 / Altitude 2 (float)\n\n                '''\n                return self.send(self.safety_set_allowed_area_encode(target_system, target_component, frame, p1x, p1y, p1z, p2x, p2y, p2z), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef safety_allowed_area_encode(self, frame, p1x, p1y, p1z, p2x, p2y, p2z):\n                '''\n                Read out the safety zone the MAV currently assumes.\n\n                frame                     : Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down. (uint8_t)\n                p1x                       : x position 1 / Latitude 1 (float)\n                p1y                       : y position 1 / Longitude 1 (float)\n                p1z                       : z position 1 / Altitude 1 (float)\n                p2x                       : x position 2 / Latitude 2 (float)\n                p2y                       : y position 2 / Longitude 2 (float)\n                p2z                       : z position 2 / Altitude 2 (float)\n\n                '''\n                return MAVLink_safety_allowed_area_message(frame, p1x, p1y, p1z, p2x, p2y, p2z)", "response": "This function is used to encode the safety zone of a frame."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading out the safety zone the MAV currently assumes. frame : Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down. (uint8_t) p1x : x position 1 / Latitude 1 (float) p1y : y position 1 / Longitude 1 (float) p1z : z position 1 / Altitude 1 (float) p2x : x position 2 / Latitude 2 (float) p2y : y position 2 / Longitude 2 (float) p2z : z position 2 / Altitude 2 (float)", "response": "def safety_allowed_area_send(self, frame, p1x, p1y, p1z, p2x, p2y, p2z, force_mavlink1=False):\n                '''\n                Read out the safety zone the MAV currently assumes.\n\n                frame                     : Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down. (uint8_t)\n                p1x                       : x position 1 / Latitude 1 (float)\n                p1y                       : y position 1 / Longitude 1 (float)\n                p1z                       : z position 1 / Altitude 1 (float)\n                p2x                       : x position 2 / Latitude 2 (float)\n                p2y                       : y position 2 / Longitude 2 (float)\n                p2z                       : z position 2 / Altitude 2 (float)\n\n                '''\n                return self.send(self.safety_allowed_area_encode(frame, p1x, p1y, p1z, p2x, p2y, p2z), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nav_controller_output_encode(self, nav_roll, nav_pitch, nav_bearing, target_bearing, wp_dist, alt_error, aspd_error, xtrack_error):\n                '''\n                The state of the fixed wing navigation and position controller.\n\n                nav_roll                  : Current desired roll in degrees (float)\n                nav_pitch                 : Current desired pitch in degrees (float)\n                nav_bearing               : Current desired heading in degrees (int16_t)\n                target_bearing            : Bearing to current MISSION/target in degrees (int16_t)\n                wp_dist                   : Distance to active MISSION in meters (uint16_t)\n                alt_error                 : Current altitude error in meters (float)\n                aspd_error                : Current airspeed error in meters/second (float)\n                xtrack_error              : Current crosstrack error on x-y plane in meters (float)\n\n                '''\n                return MAVLink_nav_controller_output_message(nav_roll, nav_pitch, nav_bearing, target_bearing, wp_dist, alt_error, aspd_error, xtrack_error)", "response": "This function is called when the fixed wing navigation and position controller is in progress and is in progress."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rc_channels_encode(self, time_boot_ms, chancount, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, chan9_raw, chan10_raw, chan11_raw, chan12_raw, chan13_raw, chan14_raw, chan15_raw, chan16_raw, chan17_raw, chan18_raw, rssi):\n                '''\n                The PPM values of the RC channels received. The standard PPM\n                modulation is as follows: 1000 microseconds: 0%, 2000\n                microseconds: 100%. Individual receivers/transmitters\n                might violate this specification.\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                chancount                 : Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available. (uint8_t)\n                chan1_raw                 : RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan2_raw                 : RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan3_raw                 : RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan4_raw                 : RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan5_raw                 : RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan6_raw                 : RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan7_raw                 : RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan8_raw                 : RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan9_raw                 : RC channel 9 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan10_raw                : RC channel 10 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan11_raw                : RC channel 11 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan12_raw                : RC channel 12 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan13_raw                : RC channel 13 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan14_raw                : RC channel 14 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan15_raw                : RC channel 15 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan16_raw                : RC channel 16 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan17_raw                : RC channel 17 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                chan18_raw                : RC channel 18 value, in microseconds. A value of UINT16_MAX implies the channel is unused. (uint16_t)\n                rssi                      : Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown. (uint8_t)\n\n                '''\n                return MAVLink_rc_channels_message(time_boot_ms, chancount, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, chan9_raw, chan10_raw, chan11_raw, chan12_raw, chan13_raw, chan14_raw, chan15_raw, chan16_raw, chan17_raw, chan18_raw, rssi)", "response": "This method encodes the RC channels received from the PPM."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrequest a message from the device", "response": "def request_data_stream_encode(self, target_system, target_component, req_stream_id, req_message_rate, start_stop):\n                '''\n                THIS INTERFACE IS DEPRECATED. USE SET_MESSAGE_INTERVAL INSTEAD.\n\n                target_system             : The target requested to send the message stream. (uint8_t)\n                target_component          : The target requested to send the message stream. (uint8_t)\n                req_stream_id             : The ID of the requested data stream (uint8_t)\n                req_message_rate          : The requested message rate (uint16_t)\n                start_stop                : 1 to start sending, 0 to stop sending. (uint8_t)\n\n                '''\n                return MAVLink_request_data_stream_message(target_system, target_component, req_stream_id, req_message_rate, start_stop)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef request_data_stream_send(self, target_system, target_component, req_stream_id, req_message_rate, start_stop, force_mavlink1=False):\n                '''\n                THIS INTERFACE IS DEPRECATED. USE SET_MESSAGE_INTERVAL INSTEAD.\n\n                target_system             : The target requested to send the message stream. (uint8_t)\n                target_component          : The target requested to send the message stream. (uint8_t)\n                req_stream_id             : The ID of the requested data stream (uint8_t)\n                req_message_rate          : The requested message rate (uint16_t)\n                start_stop                : 1 to start sending, 0 to stop sending. (uint8_t)\n\n                '''\n                return self.send(self.request_data_stream_encode(target_system, target_component, req_stream_id, req_message_rate, start_stop), force_mavlink1=force_mavlink1)", "response": "Request a new message from the system to the system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef data_stream_send(self, stream_id, message_rate, on_off, force_mavlink1=False):\n                '''\n                THIS INTERFACE IS DEPRECATED. USE MESSAGE_INTERVAL INSTEAD.\n\n                stream_id                 : The ID of the requested data stream (uint8_t)\n                message_rate              : The message rate (uint16_t)\n                on_off                    : 1 stream is enabled, 0 stream is stopped. (uint8_t)\n\n                '''\n                return self.send(self.data_stream_encode(stream_id, message_rate, on_off), force_mavlink1=force_mavlink1)", "response": "This interface is deprecated. Use message_interval INSTEAD."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef manual_control_send(self, target, x, y, z, r, buttons, force_mavlink1=False):\n                '''\n                This message provides an API for manually controlling the vehicle\n                using standard joystick axes nomenclature, along with\n                a joystick-like input device. Unused axes can be\n                disabled an buttons are also transmit as boolean\n                values of their\n\n                target                    : The system to be controlled. (uint8_t)\n                x                         : X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle. (int16_t)\n                y                         : Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle. (int16_t)\n                z                         : Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle. Positive values are positive thrust, negative values are negative thrust. (int16_t)\n                r                         : R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle. (int16_t)\n                buttons                   : A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1. (uint16_t)\n\n                '''\n                return self.send(self.manual_control_encode(target, x, y, z, r, buttons), force_mavlink1=force_mavlink1)", "response": "This message is used to control the system of a joystick."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rc_channels_override_encode(self, target_system, target_component, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw):\n                '''\n                The RAW values of the RC channels sent to the MAV to override info\n                received from the RC radio. A value of UINT16_MAX\n                means no change to that channel. A value of 0 means\n                control of that channel should be released back to the\n                RC radio. The standard PPM modulation is as follows:\n                1000 microseconds: 0%, 2000 microseconds: 100%.\n                Individual receivers/transmitters might violate this\n                specification.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                chan1_raw                 : RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan2_raw                 : RC channel 2 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan3_raw                 : RC channel 3 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan4_raw                 : RC channel 4 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan5_raw                 : RC channel 5 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan6_raw                 : RC channel 6 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan7_raw                 : RC channel 7 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan8_raw                 : RC channel 8 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n\n                '''\n                return MAVLink_rc_channels_override_message(target_system, target_component, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw)", "response": "This function is used to override the values of the RC channels sent to the RC radio."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rc_channels_override_send(self, target_system, target_component, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, force_mavlink1=False):\n                '''\n                The RAW values of the RC channels sent to the MAV to override info\n                received from the RC radio. A value of UINT16_MAX\n                means no change to that channel. A value of 0 means\n                control of that channel should be released back to the\n                RC radio. The standard PPM modulation is as follows:\n                1000 microseconds: 0%, 2000 microseconds: 100%.\n                Individual receivers/transmitters might violate this\n                specification.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                chan1_raw                 : RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan2_raw                 : RC channel 2 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan3_raw                 : RC channel 3 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan4_raw                 : RC channel 4 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan5_raw                 : RC channel 5 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan6_raw                 : RC channel 6 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan7_raw                 : RC channel 7 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n                chan8_raw                 : RC channel 8 value, in microseconds. A value of UINT16_MAX means to ignore this field. (uint16_t)\n\n                '''\n                return self.send(self.rc_channels_override_encode(target_system, target_component, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw), force_mavlink1=force_mavlink1)", "response": "Override the values of the RC channels received from the RC radio."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nencode a mission item", "response": "def mission_item_int_encode(self, target_system, target_component, seq, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z):\n                '''\n                Message encoding a mission item. This message is emitted to announce\n                the presence of a mission item and to set a mission\n                item on the system. The mission item can be either in\n                x, y, z meters (type: LOCAL) or x:lat, y:lon,\n                z:altitude. Local frame is Z-down, right handed (NED),\n                global frame is Z-up, right handed (ENU). See alsohttp\n                ://qgroundcontrol.org/mavlink/waypoint_protocol.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seq                       : Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4). (uint16_t)\n                frame                     : The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h (uint8_t)\n                command                   : The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs (uint16_t)\n                current                   : false:0, true:1 (uint8_t)\n                autocontinue              : autocontinue to next wp (uint8_t)\n                param1                    : PARAM1, see MAV_CMD enum (float)\n                param2                    : PARAM2, see MAV_CMD enum (float)\n                param3                    : PARAM3, see MAV_CMD enum (float)\n                param4                    : PARAM4, see MAV_CMD enum (float)\n                x                         : PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7 (int32_t)\n                y                         : PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7 (int32_t)\n                z                         : PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame. (float)\n\n                '''\n                return MAVLink_mission_item_int_message(target_system, target_component, seq, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmessage encoding a mission item. This message is emitted to announce the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See alsohttp ://qgroundcontrol.org/mavlink/waypoint_protocol. target_system : System ID (uint8_t) target_component : Component ID (uint8_t) seq : Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4). (uint16_t) frame : The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h (uint8_t) command : The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs (uint16_t) current : false:0, true:1 (uint8_t) autocontinue : autocontinue to next wp (uint8_t) param1 : PARAM1, see MAV_CMD enum (float) param2 : PARAM2, see MAV_CMD enum (float) param3 : PARAM3, see MAV_CMD enum (float) param4 : PARAM4, see MAV_CMD enum (float) x : PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7 (int32_t) y : PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7 (int32_t) z : PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame. (float)", "response": "def mission_item_int_send(self, target_system, target_component, seq, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z, force_mavlink1=False):\n                '''\n                Message encoding a mission item. This message is emitted to announce\n                the presence of a mission item and to set a mission\n                item on the system. The mission item can be either in\n                x, y, z meters (type: LOCAL) or x:lat, y:lon,\n                z:altitude. Local frame is Z-down, right handed (NED),\n                global frame is Z-up, right handed (ENU). See alsohttp\n                ://qgroundcontrol.org/mavlink/waypoint_protocol.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seq                       : Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4). (uint16_t)\n                frame                     : The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h (uint8_t)\n                command                   : The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs (uint16_t)\n                current                   : false:0, true:1 (uint8_t)\n                autocontinue              : autocontinue to next wp (uint8_t)\n                param1                    : PARAM1, see MAV_CMD enum (float)\n                param2                    : PARAM2, see MAV_CMD enum (float)\n                param3                    : PARAM3, see MAV_CMD enum (float)\n                param4                    : PARAM4, see MAV_CMD enum (float)\n                x                         : PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7 (int32_t)\n                y                         : PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7 (int32_t)\n                z                         : PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame. (float)\n\n                '''\n                return self.send(self.mission_item_int_encode(target_system, target_component, seq, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef command_int_encode(self, target_system, target_component, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z):\n                '''\n                Message encoding a command with parameters as scaled integers. Scaling\n                depends on the actual command value.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                frame                     : The coordinate system of the COMMAND. see MAV_FRAME in mavlink_types.h (uint8_t)\n                command                   : The scheduled action for the mission item. see MAV_CMD in common.xml MAVLink specs (uint16_t)\n                current                   : false:0, true:1 (uint8_t)\n                autocontinue              : autocontinue to next wp (uint8_t)\n                param1                    : PARAM1, see MAV_CMD enum (float)\n                param2                    : PARAM2, see MAV_CMD enum (float)\n                param3                    : PARAM3, see MAV_CMD enum (float)\n                param4                    : PARAM4, see MAV_CMD enum (float)\n                x                         : PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7 (int32_t)\n                y                         : PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7 (int32_t)\n                z                         : PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame. (float)\n\n                '''\n                return MAVLink_command_int_message(target_system, target_component, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z)", "response": "Encode a command with parameters as scaled integers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef command_int_send(self, target_system, target_component, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z, force_mavlink1=False):\n                '''\n                Message encoding a command with parameters as scaled integers. Scaling\n                depends on the actual command value.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                frame                     : The coordinate system of the COMMAND. see MAV_FRAME in mavlink_types.h (uint8_t)\n                command                   : The scheduled action for the mission item. see MAV_CMD in common.xml MAVLink specs (uint16_t)\n                current                   : false:0, true:1 (uint8_t)\n                autocontinue              : autocontinue to next wp (uint8_t)\n                param1                    : PARAM1, see MAV_CMD enum (float)\n                param2                    : PARAM2, see MAV_CMD enum (float)\n                param3                    : PARAM3, see MAV_CMD enum (float)\n                param4                    : PARAM4, see MAV_CMD enum (float)\n                x                         : PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7 (int32_t)\n                y                         : PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7 (int32_t)\n                z                         : PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame. (float)\n\n                '''\n                return self.send(self.command_int_encode(target_system, target_component, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z), force_mavlink1=force_mavlink1)", "response": "This function is used to send a command to the mission item. It is used to set the current value of the mission item."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef command_long_encode(self, target_system, target_component, command, confirmation, param1, param2, param3, param4, param5, param6, param7):\n                '''\n                Send a command with up to seven parameters to the MAV\n\n                target_system             : System which should execute the command (uint8_t)\n                target_component          : Component which should execute the command, 0 for all components (uint8_t)\n                command                   : Command ID, as defined by MAV_CMD enum. (uint16_t)\n                confirmation              : 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command) (uint8_t)\n                param1                    : Parameter 1, as defined by MAV_CMD enum. (float)\n                param2                    : Parameter 2, as defined by MAV_CMD enum. (float)\n                param3                    : Parameter 3, as defined by MAV_CMD enum. (float)\n                param4                    : Parameter 4, as defined by MAV_CMD enum. (float)\n                param5                    : Parameter 5, as defined by MAV_CMD enum. (float)\n                param6                    : Parameter 6, as defined by MAV_CMD enum. (float)\n                param7                    : Parameter 7, as defined by MAV_CMD enum. (float)\n\n                '''\n                return MAVLink_command_long_message(target_system, target_component, command, confirmation, param1, param2, param3, param4, param5, param6, param7)", "response": "This function is used to send a command to the system and component which are not part of the command list."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends a command with up to seven parameters to the MAV target_system : System which should execute the command (uint8_t) target_component : Component which should execute the command, 0 for all components (uint8_t) command : Command ID, as defined by MAV_CMD enum. (uint16_t) confirmation : 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command) (uint8_t) param1 : Parameter 1, as defined by MAV_CMD enum. (float) param2 : Parameter 2, as defined by MAV_CMD enum. (float) param3 : Parameter 3, as defined by MAV_CMD enum. (float) param4 : Parameter 4, as defined by MAV_CMD enum. (float) param5 : Parameter 5, as defined by MAV_CMD enum. (float) param6 : Parameter 6, as defined by MAV_CMD enum. (float) param7 : Parameter 7, as defined by MAV_CMD enum. (float)", "response": "def command_long_send(self, target_system, target_component, command, confirmation, param1, param2, param3, param4, param5, param6, param7, force_mavlink1=False):\n                '''\n                Send a command with up to seven parameters to the MAV\n\n                target_system             : System which should execute the command (uint8_t)\n                target_component          : Component which should execute the command, 0 for all components (uint8_t)\n                command                   : Command ID, as defined by MAV_CMD enum. (uint16_t)\n                confirmation              : 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command) (uint8_t)\n                param1                    : Parameter 1, as defined by MAV_CMD enum. (float)\n                param2                    : Parameter 2, as defined by MAV_CMD enum. (float)\n                param3                    : Parameter 3, as defined by MAV_CMD enum. (float)\n                param4                    : Parameter 4, as defined by MAV_CMD enum. (float)\n                param5                    : Parameter 5, as defined by MAV_CMD enum. (float)\n                param6                    : Parameter 6, as defined by MAV_CMD enum. (float)\n                param7                    : Parameter 7, as defined by MAV_CMD enum. (float)\n\n                '''\n                return self.send(self.command_long_encode(target_system, target_component, command, confirmation, param1, param2, param3, param4, param5, param6, param7), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef command_ack_send(self, command, result, force_mavlink1=False):\n                '''\n                Report status of a command. Includes feedback wether the command was\n                executed.\n\n                command                   : Command ID, as defined by MAV_CMD enum. (uint16_t)\n                result                    : See MAV_RESULT enum (uint8_t)\n\n                '''\n                return self.send(self.command_ack_encode(command, result), force_mavlink1=force_mavlink1)", "response": "Acknowledge status of a command."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef manual_setpoint_send(self, time_boot_ms, roll, pitch, yaw, thrust, mode_switch, manual_override_switch, force_mavlink1=False):\n                '''\n                Setpoint in roll, pitch, yaw and thrust from the operator\n\n                time_boot_ms              : Timestamp in milliseconds since system boot (uint32_t)\n                roll                      : Desired roll rate in radians per second (float)\n                pitch                     : Desired pitch rate in radians per second (float)\n                yaw                       : Desired yaw rate in radians per second (float)\n                thrust                    : Collective thrust, normalized to 0 .. 1 (float)\n                mode_switch               : Flight mode switch position, 0.. 255 (uint8_t)\n                manual_override_switch        : Override mode switch position, 0.. 255 (uint8_t)\n\n                '''\n                return self.send(self.manual_setpoint_encode(time_boot_ms, roll, pitch, yaw, thrust, mode_switch, manual_override_switch), force_mavlink1=force_mavlink1)", "response": "Setpoint in roll pitch yaw and thrust from the operator\n               "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_attitude_target_encode(self, time_boot_ms, target_system, target_component, type_mask, q, body_roll_rate, body_pitch_rate, body_yaw_rate, thrust):\n                '''\n                Sets a desired vehicle attitude. Used by an external controller to\n                command the vehicle (manual controller or other\n                system).\n\n                time_boot_ms              : Timestamp in milliseconds since system boot (uint32_t)\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                type_mask                 : Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude (uint8_t)\n                q                         : Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) (float)\n                body_roll_rate            : Body roll rate in radians per second (float)\n                body_pitch_rate           : Body roll rate in radians per second (float)\n                body_yaw_rate             : Body roll rate in radians per second (float)\n                thrust                    : Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust) (float)\n\n                '''\n                return MAVLink_set_attitude_target_message(time_boot_ms, target_system, target_component, type_mask, q, body_roll_rate, body_pitch_rate, body_yaw_rate, thrust)", "response": "This function is called when vehicle is set to target."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the desired vehicle attitude.", "response": "def set_attitude_target_send(self, time_boot_ms, target_system, target_component, type_mask, q, body_roll_rate, body_pitch_rate, body_yaw_rate, thrust, force_mavlink1=False):\n                '''\n                Sets a desired vehicle attitude. Used by an external controller to\n                command the vehicle (manual controller or other\n                system).\n\n                time_boot_ms              : Timestamp in milliseconds since system boot (uint32_t)\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                type_mask                 : Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude (uint8_t)\n                q                         : Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) (float)\n                body_roll_rate            : Body roll rate in radians per second (float)\n                body_pitch_rate           : Body roll rate in radians per second (float)\n                body_yaw_rate             : Body roll rate in radians per second (float)\n                thrust                    : Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust) (float)\n\n                '''\n                return self.send(self.set_attitude_target_encode(time_boot_ms, target_system, target_component, type_mask, q, body_roll_rate, body_pitch_rate, body_yaw_rate, thrust), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreporting the current commanded attitude of the vehicle as specified by the autopilot. This should match the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way. time_boot_ms : Timestamp in milliseconds since system boot (uint32_t) type_mask : Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude (uint8_t) q : Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) (float) body_roll_rate : Body roll rate in radians per second (float) body_pitch_rate : Body roll rate in radians per second (float) body_yaw_rate : Body roll rate in radians per second (float) thrust : Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust) (float)", "response": "def attitude_target_encode(self, time_boot_ms, type_mask, q, body_roll_rate, body_pitch_rate, body_yaw_rate, thrust):\n                '''\n                Reports the current commanded attitude of the vehicle as specified by\n                the autopilot. This should match the commands sent in\n                a SET_ATTITUDE_TARGET message if the vehicle is being\n                controlled this way.\n\n                time_boot_ms              : Timestamp in milliseconds since system boot (uint32_t)\n                type_mask                 : Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude (uint8_t)\n                q                         : Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) (float)\n                body_roll_rate            : Body roll rate in radians per second (float)\n                body_pitch_rate           : Body roll rate in radians per second (float)\n                body_yaw_rate             : Body roll rate in radians per second (float)\n                thrust                    : Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust) (float)\n\n                '''\n                return MAVLink_attitude_target_message(time_boot_ms, type_mask, q, body_roll_rate, body_pitch_rate, body_yaw_rate, thrust)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreports the current commanded attitude of the vehicle as specified by the autopilot. This should match the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way. time_boot_ms : Timestamp in milliseconds since system boot (uint32_t) type_mask : Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude (uint8_t) q : Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) (float) body_roll_rate : Body roll rate in radians per second (float) body_pitch_rate : Body roll rate in radians per second (float) body_yaw_rate : Body roll rate in radians per second (float) thrust : Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust) (float)", "response": "def attitude_target_send(self, time_boot_ms, type_mask, q, body_roll_rate, body_pitch_rate, body_yaw_rate, thrust, force_mavlink1=False):\n                '''\n                Reports the current commanded attitude of the vehicle as specified by\n                the autopilot. This should match the commands sent in\n                a SET_ATTITUDE_TARGET message if the vehicle is being\n                controlled this way.\n\n                time_boot_ms              : Timestamp in milliseconds since system boot (uint32_t)\n                type_mask                 : Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude (uint8_t)\n                q                         : Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) (float)\n                body_roll_rate            : Body roll rate in radians per second (float)\n                body_pitch_rate           : Body roll rate in radians per second (float)\n                body_yaw_rate             : Body roll rate in radians per second (float)\n                thrust                    : Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust) (float)\n\n                '''\n                return self.send(self.attitude_target_encode(time_boot_ms, type_mask, q, body_roll_rate, body_pitch_rate, body_yaw_rate, thrust), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_position_target_local_ned_encode(self, time_boot_ms, target_system, target_component, coordinate_frame, type_mask, x, y, z, vx, vy, vz, afx, afy, afz, yaw, yaw_rate):\n                '''\n                Sets a desired vehicle position in a local north-east-down coordinate\n                frame. Used by an external controller to command the\n                vehicle (manual controller or other system).\n\n                time_boot_ms              : Timestamp in milliseconds since system boot (uint32_t)\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                coordinate_frame          : Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9 (uint8_t)\n                type_mask                 : Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate (uint16_t)\n                x                         : X Position in NED frame in meters (float)\n                y                         : Y Position in NED frame in meters (float)\n                z                         : Z Position in NED frame in meters (note, altitude is negative in NED) (float)\n                vx                        : X velocity in NED frame in meter / s (float)\n                vy                        : Y velocity in NED frame in meter / s (float)\n                vz                        : Z velocity in NED frame in meter / s (float)\n                afx                       : X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afy                       : Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afz                       : Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                yaw                       : yaw setpoint in rad (float)\n                yaw_rate                  : yaw rate setpoint in rad/s (float)\n\n                '''\n                return MAVLink_set_position_target_local_ned_message(time_boot_ms, target_system, target_component, coordinate_frame, type_mask, x, y, z, vx, vy, vz, afx, afy, afz, yaw, yaw_rate)", "response": "Set the desired vehicle position in a local north - east - down coordinate frame."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the desired vehicle position in a local north - east - down coordinate frame.", "response": "def set_position_target_local_ned_send(self, time_boot_ms, target_system, target_component, coordinate_frame, type_mask, x, y, z, vx, vy, vz, afx, afy, afz, yaw, yaw_rate, force_mavlink1=False):\n                '''\n                Sets a desired vehicle position in a local north-east-down coordinate\n                frame. Used by an external controller to command the\n                vehicle (manual controller or other system).\n\n                time_boot_ms              : Timestamp in milliseconds since system boot (uint32_t)\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                coordinate_frame          : Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9 (uint8_t)\n                type_mask                 : Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate (uint16_t)\n                x                         : X Position in NED frame in meters (float)\n                y                         : Y Position in NED frame in meters (float)\n                z                         : Z Position in NED frame in meters (note, altitude is negative in NED) (float)\n                vx                        : X velocity in NED frame in meter / s (float)\n                vy                        : Y velocity in NED frame in meter / s (float)\n                vz                        : Z velocity in NED frame in meter / s (float)\n                afx                       : X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afy                       : Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afz                       : Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                yaw                       : yaw setpoint in rad (float)\n                yaw_rate                  : yaw rate setpoint in rad/s (float)\n\n                '''\n                return self.send(self.set_position_target_local_ned_encode(time_boot_ms, target_system, target_component, coordinate_frame, type_mask, x, y, z, vx, vy, vz, afx, afy, afz, yaw, yaw_rate), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nencode the position target local NED frame", "response": "def position_target_local_ned_encode(self, time_boot_ms, coordinate_frame, type_mask, x, y, z, vx, vy, vz, afx, afy, afz, yaw, yaw_rate):\n                '''\n                Reports the current commanded vehicle position, velocity, and\n                acceleration as specified by the autopilot. This\n                should match the commands sent in\n                SET_POSITION_TARGET_LOCAL_NED if the vehicle is being\n                controlled this way.\n\n                time_boot_ms              : Timestamp in milliseconds since system boot (uint32_t)\n                coordinate_frame          : Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9 (uint8_t)\n                type_mask                 : Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate (uint16_t)\n                x                         : X Position in NED frame in meters (float)\n                y                         : Y Position in NED frame in meters (float)\n                z                         : Z Position in NED frame in meters (note, altitude is negative in NED) (float)\n                vx                        : X velocity in NED frame in meter / s (float)\n                vy                        : Y velocity in NED frame in meter / s (float)\n                vz                        : Z velocity in NED frame in meter / s (float)\n                afx                       : X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afy                       : Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afz                       : Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                yaw                       : yaw setpoint in rad (float)\n                yaw_rate                  : yaw rate setpoint in rad/s (float)\n\n                '''\n                return MAVLink_position_target_local_ned_message(time_boot_ms, coordinate_frame, type_mask, x, y, z, vx, vy, vz, afx, afy, afz, yaw, yaw_rate)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npositioning target local NED command.", "response": "def position_target_local_ned_send(self, time_boot_ms, coordinate_frame, type_mask, x, y, z, vx, vy, vz, afx, afy, afz, yaw, yaw_rate, force_mavlink1=False):\n                '''\n                Reports the current commanded vehicle position, velocity, and\n                acceleration as specified by the autopilot. This\n                should match the commands sent in\n                SET_POSITION_TARGET_LOCAL_NED if the vehicle is being\n                controlled this way.\n\n                time_boot_ms              : Timestamp in milliseconds since system boot (uint32_t)\n                coordinate_frame          : Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9 (uint8_t)\n                type_mask                 : Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate (uint16_t)\n                x                         : X Position in NED frame in meters (float)\n                y                         : Y Position in NED frame in meters (float)\n                z                         : Z Position in NED frame in meters (note, altitude is negative in NED) (float)\n                vx                        : X velocity in NED frame in meter / s (float)\n                vy                        : Y velocity in NED frame in meter / s (float)\n                vz                        : Z velocity in NED frame in meter / s (float)\n                afx                       : X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afy                       : Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afz                       : Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                yaw                       : yaw setpoint in rad (float)\n                yaw_rate                  : yaw rate setpoint in rad/s (float)\n\n                '''\n                return self.send(self.position_target_local_ned_encode(time_boot_ms, coordinate_frame, type_mask, x, y, z, vx, vy, vz, afx, afy, afz, yaw, yaw_rate), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_position_target_global_int_encode(self, time_boot_ms, target_system, target_component, coordinate_frame, type_mask, lat_int, lon_int, alt, vx, vy, vz, afx, afy, afz, yaw, yaw_rate):\n                '''\n                Sets a desired vehicle position, velocity, and/or acceleration in a\n                global coordinate system (WGS84). Used by an external\n                controller to command the vehicle (manual controller\n                or other system).\n\n                time_boot_ms              : Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency. (uint32_t)\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                coordinate_frame          : Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11 (uint8_t)\n                type_mask                 : Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate (uint16_t)\n                lat_int                   : X Position in WGS84 frame in 1e7 * meters (int32_t)\n                lon_int                   : Y Position in WGS84 frame in 1e7 * meters (int32_t)\n                alt                       : Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT (float)\n                vx                        : X velocity in NED frame in meter / s (float)\n                vy                        : Y velocity in NED frame in meter / s (float)\n                vz                        : Z velocity in NED frame in meter / s (float)\n                afx                       : X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afy                       : Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afz                       : Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                yaw                       : yaw setpoint in rad (float)\n                yaw_rate                  : yaw rate setpoint in rad/s (float)\n\n                '''\n                return MAVLink_set_position_target_global_int_message(time_boot_ms, target_system, target_component, coordinate_frame, type_mask, lat_int, lon_int, alt, vx, vy, vz, afx, afy, afz, yaw, yaw_rate)", "response": "Set the position target global int in the external vehicle system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset a desired vehicle position velocity and acceleration in a global coordinate system.", "response": "def set_position_target_global_int_send(self, time_boot_ms, target_system, target_component, coordinate_frame, type_mask, lat_int, lon_int, alt, vx, vy, vz, afx, afy, afz, yaw, yaw_rate, force_mavlink1=False):\n                '''\n                Sets a desired vehicle position, velocity, and/or acceleration in a\n                global coordinate system (WGS84). Used by an external\n                controller to command the vehicle (manual controller\n                or other system).\n\n                time_boot_ms              : Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency. (uint32_t)\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                coordinate_frame          : Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11 (uint8_t)\n                type_mask                 : Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate (uint16_t)\n                lat_int                   : X Position in WGS84 frame in 1e7 * meters (int32_t)\n                lon_int                   : Y Position in WGS84 frame in 1e7 * meters (int32_t)\n                alt                       : Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT (float)\n                vx                        : X velocity in NED frame in meter / s (float)\n                vy                        : Y velocity in NED frame in meter / s (float)\n                vz                        : Z velocity in NED frame in meter / s (float)\n                afx                       : X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afy                       : Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afz                       : Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                yaw                       : yaw setpoint in rad (float)\n                yaw_rate                  : yaw rate setpoint in rad/s (float)\n\n                '''\n                return self.send(self.set_position_target_global_int_encode(time_boot_ms, target_system, target_component, coordinate_frame, type_mask, lat_int, lon_int, alt, vx, vy, vz, afx, afy, afz, yaw, yaw_rate), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreport the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being controlled this way. time_boot_ms : Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency. (uint32_t) coordinate_frame : Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11 (uint8_t) type_mask : Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate (uint16_t) lat_int : X Position in WGS84 frame in 1e7 * meters (int32_t) lon_int : Y Position in WGS84 frame in 1e7 * meters (int32_t) alt : Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT (float) vx : X velocity in NED frame in meter / s (float) vy : Y velocity in NED frame in meter / s (float) vz : Z velocity in NED frame in meter / s (float) afx : X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float) afy : Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float) afz : Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float) yaw : yaw setpoint in rad (float) yaw_rate : yaw rate setpoint in rad/s (float)", "response": "def position_target_global_int_encode(self, time_boot_ms, coordinate_frame, type_mask, lat_int, lon_int, alt, vx, vy, vz, afx, afy, afz, yaw, yaw_rate):\n                '''\n                Reports the current commanded vehicle position, velocity, and\n                acceleration as specified by the autopilot. This\n                should match the commands sent in\n                SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being\n                controlled this way.\n\n                time_boot_ms              : Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency. (uint32_t)\n                coordinate_frame          : Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11 (uint8_t)\n                type_mask                 : Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate (uint16_t)\n                lat_int                   : X Position in WGS84 frame in 1e7 * meters (int32_t)\n                lon_int                   : Y Position in WGS84 frame in 1e7 * meters (int32_t)\n                alt                       : Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT (float)\n                vx                        : X velocity in NED frame in meter / s (float)\n                vy                        : Y velocity in NED frame in meter / s (float)\n                vz                        : Z velocity in NED frame in meter / s (float)\n                afx                       : X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afy                       : Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afz                       : Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                yaw                       : yaw setpoint in rad (float)\n                yaw_rate                  : yaw rate setpoint in rad/s (float)\n\n                '''\n                return MAVLink_position_target_global_int_message(time_boot_ms, coordinate_frame, type_mask, lat_int, lon_int, alt, vx, vy, vz, afx, afy, afz, yaw, yaw_rate)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nposition target global int command.", "response": "def position_target_global_int_send(self, time_boot_ms, coordinate_frame, type_mask, lat_int, lon_int, alt, vx, vy, vz, afx, afy, afz, yaw, yaw_rate, force_mavlink1=False):\n                '''\n                Reports the current commanded vehicle position, velocity, and\n                acceleration as specified by the autopilot. This\n                should match the commands sent in\n                SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being\n                controlled this way.\n\n                time_boot_ms              : Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency. (uint32_t)\n                coordinate_frame          : Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11 (uint8_t)\n                type_mask                 : Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate (uint16_t)\n                lat_int                   : X Position in WGS84 frame in 1e7 * meters (int32_t)\n                lon_int                   : Y Position in WGS84 frame in 1e7 * meters (int32_t)\n                alt                       : Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT (float)\n                vx                        : X velocity in NED frame in meter / s (float)\n                vy                        : Y velocity in NED frame in meter / s (float)\n                vz                        : Z velocity in NED frame in meter / s (float)\n                afx                       : X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afy                       : Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                afz                       : Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N (float)\n                yaw                       : yaw setpoint in rad (float)\n                yaw_rate                  : yaw rate setpoint in rad/s (float)\n\n                '''\n                return self.send(self.position_target_global_int_encode(time_boot_ms, coordinate_frame, type_mask, lat_int, lon_int, alt, vx, vy, vz, afx, afy, afz, yaw, yaw_rate), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef local_position_ned_system_global_offset_encode(self, time_boot_ms, x, y, z, roll, pitch, yaw):\n                '''\n                The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages\n                of MAV X and the global coordinate frame in NED\n                coordinates. Coordinate frame is right-handed, Z-axis\n                down (aeronautical frame, NED / north-east-down\n                convention)\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                x                         : X Position (float)\n                y                         : Y Position (float)\n                z                         : Z Position (float)\n                roll                      : Roll (float)\n                pitch                     : Pitch (float)\n                yaw                       : Yaw (float)\n\n                '''\n                return MAVLink_local_position_ned_system_global_offset_message(time_boot_ms, x, y, z, roll, pitch, yaw)", "response": "This function is called when the local position of the system is not defined in the NED file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndeprecate PACKET! Suffers from missing airspeed fields and singularities due to Euler angles. Please use HIL_STATE_QUATERNION instead. Sent from simulation to autopilot. This packet is useful for high throughput applications such as hardware in the loop simulations. time_usec : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t) roll : Roll angle (rad) (float) pitch : Pitch angle (rad) (float) yaw : Yaw angle (rad) (float) rollspeed : Body frame roll / phi angular speed (rad/s) (float) pitchspeed : Body frame pitch / theta angular speed (rad/s) (float) yawspeed : Body frame yaw / psi angular speed (rad/s) (float) lat : Latitude, expressed as * 1E7 (int32_t) lon : Longitude, expressed as * 1E7 (int32_t) alt : Altitude in meters, expressed as * 1000 (millimeters) (int32_t) vx : Ground X Speed (Latitude), expressed as m/s * 100 (int16_t) vy : Ground Y Speed (Longitude), expressed as m/s * 100 (int16_t) vz : Ground Z Speed (Altitude), expressed as m/s * 100 (int16_t) xacc : X acceleration (mg) (int16_t) yacc : Y acceleration (mg) (int16_t) zacc : Z acceleration (mg) (int16_t)", "response": "def hil_state_encode(self, time_usec, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed, lat, lon, alt, vx, vy, vz, xacc, yacc, zacc):\n                '''\n                DEPRECATED PACKET! Suffers from missing airspeed fields and\n                singularities due to Euler angles. Please use\n                HIL_STATE_QUATERNION instead. Sent from simulation to\n                autopilot. This packet is useful for high throughput\n                applications such as hardware in the loop simulations.\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                roll                      : Roll angle (rad) (float)\n                pitch                     : Pitch angle (rad) (float)\n                yaw                       : Yaw angle (rad) (float)\n                rollspeed                 : Body frame roll / phi angular speed (rad/s) (float)\n                pitchspeed                : Body frame pitch / theta angular speed (rad/s) (float)\n                yawspeed                  : Body frame yaw / psi angular speed (rad/s) (float)\n                lat                       : Latitude, expressed as * 1E7 (int32_t)\n                lon                       : Longitude, expressed as * 1E7 (int32_t)\n                alt                       : Altitude in meters, expressed as * 1000 (millimeters) (int32_t)\n                vx                        : Ground X Speed (Latitude), expressed as m/s * 100 (int16_t)\n                vy                        : Ground Y Speed (Longitude), expressed as m/s * 100 (int16_t)\n                vz                        : Ground Z Speed (Altitude), expressed as m/s * 100 (int16_t)\n                xacc                      : X acceleration (mg) (int16_t)\n                yacc                      : Y acceleration (mg) (int16_t)\n                zacc                      : Z acceleration (mg) (int16_t)\n\n                '''\n                return MAVLink_hil_state_message(time_usec, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed, lat, lon, alt, vx, vy, vz, xacc, yacc, zacc)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndeprecate PACKET! Suffers from missing airspeed fields and singularities due to Euler angles. Please use HIL_STATE_QUATERNION instead. Sent from simulation to autopilot. This packet is useful for high throughput applications such as hardware in the loop simulations. time_usec : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t) roll : Roll angle (rad) (float) pitch : Pitch angle (rad) (float) yaw : Yaw angle (rad) (float) rollspeed : Body frame roll / phi angular speed (rad/s) (float) pitchspeed : Body frame pitch / theta angular speed (rad/s) (float) yawspeed : Body frame yaw / psi angular speed (rad/s) (float) lat : Latitude, expressed as * 1E7 (int32_t) lon : Longitude, expressed as * 1E7 (int32_t) alt : Altitude in meters, expressed as * 1000 (millimeters) (int32_t) vx : Ground X Speed (Latitude), expressed as m/s * 100 (int16_t) vy : Ground Y Speed (Longitude), expressed as m/s * 100 (int16_t) vz : Ground Z Speed (Altitude), expressed as m/s * 100 (int16_t) xacc : X acceleration (mg) (int16_t) yacc : Y acceleration (mg) (int16_t) zacc : Z acceleration (mg) (int16_t)", "response": "def hil_state_send(self, time_usec, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed, lat, lon, alt, vx, vy, vz, xacc, yacc, zacc, force_mavlink1=False):\n                '''\n                DEPRECATED PACKET! Suffers from missing airspeed fields and\n                singularities due to Euler angles. Please use\n                HIL_STATE_QUATERNION instead. Sent from simulation to\n                autopilot. This packet is useful for high throughput\n                applications such as hardware in the loop simulations.\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                roll                      : Roll angle (rad) (float)\n                pitch                     : Pitch angle (rad) (float)\n                yaw                       : Yaw angle (rad) (float)\n                rollspeed                 : Body frame roll / phi angular speed (rad/s) (float)\n                pitchspeed                : Body frame pitch / theta angular speed (rad/s) (float)\n                yawspeed                  : Body frame yaw / psi angular speed (rad/s) (float)\n                lat                       : Latitude, expressed as * 1E7 (int32_t)\n                lon                       : Longitude, expressed as * 1E7 (int32_t)\n                alt                       : Altitude in meters, expressed as * 1000 (millimeters) (int32_t)\n                vx                        : Ground X Speed (Latitude), expressed as m/s * 100 (int16_t)\n                vy                        : Ground Y Speed (Longitude), expressed as m/s * 100 (int16_t)\n                vz                        : Ground Z Speed (Altitude), expressed as m/s * 100 (int16_t)\n                xacc                      : X acceleration (mg) (int16_t)\n                yacc                      : Y acceleration (mg) (int16_t)\n                zacc                      : Z acceleration (mg) (int16_t)\n\n                '''\n                return self.send(self.hil_state_encode(time_usec, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed, lat, lon, alt, vx, vy, vz, xacc, yacc, zacc), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hil_controls_encode(self, time_usec, roll_ailerons, pitch_elevator, yaw_rudder, throttle, aux1, aux2, aux3, aux4, mode, nav_mode):\n                '''\n                Sent from autopilot to simulation. Hardware in the loop control\n                outputs\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                roll_ailerons             : Control output -1 .. 1 (float)\n                pitch_elevator            : Control output -1 .. 1 (float)\n                yaw_rudder                : Control output -1 .. 1 (float)\n                throttle                  : Throttle 0 .. 1 (float)\n                aux1                      : Aux 1, -1 .. 1 (float)\n                aux2                      : Aux 2, -1 .. 1 (float)\n                aux3                      : Aux 3, -1 .. 1 (float)\n                aux4                      : Aux 4, -1 .. 1 (float)\n                mode                      : System mode (MAV_MODE) (uint8_t)\n                nav_mode                  : Navigation mode (MAV_NAV_MODE) (uint8_t)\n\n                '''\n                return MAVLink_hil_controls_message(time_usec, roll_ailerons, pitch_elevator, yaw_rudder, throttle, aux1, aux2, aux3, aux4, mode, nav_mode)", "response": "Sent from autopilot to simulation. Hardware in the loop control\n                outputs\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                roll_ailerons             : Control output -1 .. 1 (float)\n                pitch_elevator            : Control output -1 .. 1 (float)\n                yaw_rudder                : Control output -1 .. 1 (float)\n                throttle                  : Throttle 0 .. 1 (float)\n                aux1                      : Aux 1, -1 .. 1 (float)\n                aux2                      : Aux 2, -1 .. 1 (float)\n                aux3                      : Aux 3, -1 .. 1 (float)\n                aux4                      : Aux 4, -1 .. 1 (float)\n                mode                      : System mode (MAV_MODE) (uint8_t)\n                nav_mode                  : Navigation mode (MAV_NAV_MODE) (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hil_controls_send(self, time_usec, roll_ailerons, pitch_elevator, yaw_rudder, throttle, aux1, aux2, aux3, aux4, mode, nav_mode, force_mavlink1=False):\n                '''\n                Sent from autopilot to simulation. Hardware in the loop control\n                outputs\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                roll_ailerons             : Control output -1 .. 1 (float)\n                pitch_elevator            : Control output -1 .. 1 (float)\n                yaw_rudder                : Control output -1 .. 1 (float)\n                throttle                  : Throttle 0 .. 1 (float)\n                aux1                      : Aux 1, -1 .. 1 (float)\n                aux2                      : Aux 2, -1 .. 1 (float)\n                aux3                      : Aux 3, -1 .. 1 (float)\n                aux4                      : Aux 4, -1 .. 1 (float)\n                mode                      : System mode (MAV_MODE) (uint8_t)\n                nav_mode                  : Navigation mode (MAV_NAV_MODE) (uint8_t)\n\n                '''\n                return self.send(self.hil_controls_encode(time_usec, roll_ailerons, pitch_elevator, yaw_rudder, throttle, aux1, aux2, aux3, aux4, mode, nav_mode), force_mavlink1=force_mavlink1)", "response": "Sent from autopilot to simulation. Hardware in the loop control\n                outputs\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                roll_ailerons             : Control output -1 .. 1 (float)\n                pitch_elevator            : Control output -1 .. 1 (float)\n                yaw_rudder                : Control output -1 .. 1 (float)\n                throttle                  : Throttle 0 .. 1 (float)\n                aux1                      : Aux 1, -1 .. 1 (float)\n                aux2                      : Aux 2, -1 .. 1 (float)\n                aux3                      : Aux 3, -1 .. 1 (float)\n                aux4                      : Aux 4, -1 .. 1 (float)\n                mode                      : System mode (MAV_MODE) (uint8_t)\n                nav_mode                  : Navigation mode (MAV_NAV_MODE) (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hil_rc_inputs_raw_encode(self, time_usec, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, chan9_raw, chan10_raw, chan11_raw, chan12_raw, rssi):\n                '''\n                Sent from simulation to autopilot. The RAW values of the RC channels\n                received. The standard PPM modulation is as follows:\n                1000 microseconds: 0%, 2000 microseconds: 100%.\n                Individual receivers/transmitters might violate this\n                specification.\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                chan1_raw                 : RC channel 1 value, in microseconds (uint16_t)\n                chan2_raw                 : RC channel 2 value, in microseconds (uint16_t)\n                chan3_raw                 : RC channel 3 value, in microseconds (uint16_t)\n                chan4_raw                 : RC channel 4 value, in microseconds (uint16_t)\n                chan5_raw                 : RC channel 5 value, in microseconds (uint16_t)\n                chan6_raw                 : RC channel 6 value, in microseconds (uint16_t)\n                chan7_raw                 : RC channel 7 value, in microseconds (uint16_t)\n                chan8_raw                 : RC channel 8 value, in microseconds (uint16_t)\n                chan9_raw                 : RC channel 9 value, in microseconds (uint16_t)\n                chan10_raw                : RC channel 10 value, in microseconds (uint16_t)\n                chan11_raw                : RC channel 11 value, in microseconds (uint16_t)\n                chan12_raw                : RC channel 12 value, in microseconds (uint16_t)\n                rssi                      : Receive signal strength indicator, 0: 0%, 255: 100% (uint8_t)\n\n                '''\n                return MAVLink_hil_rc_inputs_raw_message(time_usec, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, chan9_raw, chan10_raw, chan11_raw, chan12_raw, rssi)", "response": "Hil RC inputs raw"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification. time_usec : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t) chan1_raw : RC channel 1 value, in microseconds (uint16_t) chan2_raw : RC channel 2 value, in microseconds (uint16_t) chan3_raw : RC channel 3 value, in microseconds (uint16_t) chan4_raw : RC channel 4 value, in microseconds (uint16_t) chan5_raw : RC channel 5 value, in microseconds (uint16_t) chan6_raw : RC channel 6 value, in microseconds (uint16_t) chan7_raw : RC channel 7 value, in microseconds (uint16_t) chan8_raw : RC channel 8 value, in microseconds (uint16_t) chan9_raw : RC channel 9 value, in microseconds (uint16_t) chan10_raw : RC channel 10 value, in microseconds (uint16_t) chan11_raw : RC channel 11 value, in microseconds (uint16_t) chan12_raw : RC channel 12 value, in microseconds (uint16_t) rssi : Receive signal strength indicator, 0: 0%, 255: 100% (uint8_t)", "response": "def hil_rc_inputs_raw_send(self, time_usec, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, chan9_raw, chan10_raw, chan11_raw, chan12_raw, rssi, force_mavlink1=False):\n                '''\n                Sent from simulation to autopilot. The RAW values of the RC channels\n                received. The standard PPM modulation is as follows:\n                1000 microseconds: 0%, 2000 microseconds: 100%.\n                Individual receivers/transmitters might violate this\n                specification.\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                chan1_raw                 : RC channel 1 value, in microseconds (uint16_t)\n                chan2_raw                 : RC channel 2 value, in microseconds (uint16_t)\n                chan3_raw                 : RC channel 3 value, in microseconds (uint16_t)\n                chan4_raw                 : RC channel 4 value, in microseconds (uint16_t)\n                chan5_raw                 : RC channel 5 value, in microseconds (uint16_t)\n                chan6_raw                 : RC channel 6 value, in microseconds (uint16_t)\n                chan7_raw                 : RC channel 7 value, in microseconds (uint16_t)\n                chan8_raw                 : RC channel 8 value, in microseconds (uint16_t)\n                chan9_raw                 : RC channel 9 value, in microseconds (uint16_t)\n                chan10_raw                : RC channel 10 value, in microseconds (uint16_t)\n                chan11_raw                : RC channel 11 value, in microseconds (uint16_t)\n                chan12_raw                : RC channel 12 value, in microseconds (uint16_t)\n                rssi                      : Receive signal strength indicator, 0: 0%, 255: 100% (uint8_t)\n\n                '''\n                return self.send(self.hil_rc_inputs_raw_encode(time_usec, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, chan9_raw, chan10_raw, chan11_raw, chan12_raw, rssi), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hil_actuator_controls_encode(self, time_usec, controls, mode, flags):\n                '''\n                Sent from autopilot to simulation. Hardware in the loop control\n                outputs (replacement for HIL_CONTROLS)\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                controls                  : Control outputs -1 .. 1. Channel assignment depends on the simulated hardware. (float)\n                mode                      : System mode (MAV_MODE), includes arming state. (uint8_t)\n                flags                     : Flags as bitfield, reserved for future use. (uint64_t)\n\n                '''\n                return MAVLink_hil_actuator_controls_message(time_usec, controls, mode, flags)", "response": "Sent from autopilot to simulation. Hardware in the loop control\n                outputs (replacement for HIL_CONTROLS)\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                controls                  : Control outputs -1 .. 1. Channel assignment depends on the simulated hardware. (float)\n                mode                      : System mode (MAV_MODE), includes arming state. (uint8_t)\n                flags                     : Flags as bitfield, reserved for future use. (uint64_t)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending from autopilot to simulation. Hardware in the loop control outputs (replacement for HIL_CONTROLS) time_usec : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t) controls : Control outputs -1 .. 1. Channel assignment depends on the simulated hardware. (float) mode : System mode (MAV_MODE), includes arming state. (uint8_t) flags : Flags as bitfield, reserved for future use. (uint64_t)", "response": "def hil_actuator_controls_send(self, time_usec, controls, mode, flags, force_mavlink1=False):\n                '''\n                Sent from autopilot to simulation. Hardware in the loop control\n                outputs (replacement for HIL_CONTROLS)\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                controls                  : Control outputs -1 .. 1. Channel assignment depends on the simulated hardware. (float)\n                mode                      : System mode (MAV_MODE), includes arming state. (uint8_t)\n                flags                     : Flags as bitfield, reserved for future use. (uint64_t)\n\n                '''\n                return self.send(self.hil_actuator_controls_encode(time_usec, controls, mode, flags), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef optical_flow_send(self, time_usec, sensor_id, flow_x, flow_y, flow_comp_m_x, flow_comp_m_y, quality, ground_distance, force_mavlink1=False):\n                '''\n                Optical flow from a flow sensor (e.g. optical mouse sensor)\n\n                time_usec                 : Timestamp (UNIX) (uint64_t)\n                sensor_id                 : Sensor ID (uint8_t)\n                flow_x                    : Flow in pixels * 10 in x-sensor direction (dezi-pixels) (int16_t)\n                flow_y                    : Flow in pixels * 10 in y-sensor direction (dezi-pixels) (int16_t)\n                flow_comp_m_x             : Flow in meters in x-sensor direction, angular-speed compensated (float)\n                flow_comp_m_y             : Flow in meters in y-sensor direction, angular-speed compensated (float)\n                quality                   : Optical flow quality / confidence. 0: bad, 255: maximum quality (uint8_t)\n                ground_distance           : Ground distance in meters. Positive value: distance known. Negative value: Unknown distance (float)\n\n                '''\n                return self.send(self.optical_flow_encode(time_usec, sensor_id, flow_x, flow_y, flow_comp_m_x, flow_comp_m_y, quality, ground_distance), force_mavlink1=force_mavlink1)", "response": "Optical flow from a sensor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef highres_imu_encode(self, time_usec, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag, abs_pressure, diff_pressure, pressure_alt, temperature, fields_updated):\n                '''\n                The IMU readings in SI units in NED body frame\n\n                time_usec                 : Timestamp (microseconds, synced to UNIX time or since system boot) (uint64_t)\n                xacc                      : X acceleration (m/s^2) (float)\n                yacc                      : Y acceleration (m/s^2) (float)\n                zacc                      : Z acceleration (m/s^2) (float)\n                xgyro                     : Angular speed around X axis (rad / sec) (float)\n                ygyro                     : Angular speed around Y axis (rad / sec) (float)\n                zgyro                     : Angular speed around Z axis (rad / sec) (float)\n                xmag                      : X Magnetic field (Gauss) (float)\n                ymag                      : Y Magnetic field (Gauss) (float)\n                zmag                      : Z Magnetic field (Gauss) (float)\n                abs_pressure              : Absolute pressure in millibar (float)\n                diff_pressure             : Differential pressure in millibar (float)\n                pressure_alt              : Altitude calculated from pressure (float)\n                temperature               : Temperature in degrees celsius (float)\n                fields_updated            : Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature (uint16_t)\n\n                '''\n                return MAVLink_highres_imu_message(time_usec, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag, abs_pressure, diff_pressure, pressure_alt, temperature, fields_updated)", "response": "Highres IMU readings in SI units in NED body frame"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nencoding the state of the simulation environment.", "response": "def sim_state_encode(self, q1, q2, q3, q4, roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lon, alt, std_dev_horz, std_dev_vert, vn, ve, vd):\n                '''\n                Status of simulation environment, if used\n\n                q1                        : True attitude quaternion component 1, w (1 in null-rotation) (float)\n                q2                        : True attitude quaternion component 2, x (0 in null-rotation) (float)\n                q3                        : True attitude quaternion component 3, y (0 in null-rotation) (float)\n                q4                        : True attitude quaternion component 4, z (0 in null-rotation) (float)\n                roll                      : Attitude roll expressed as Euler angles, not recommended except for human-readable outputs (float)\n                pitch                     : Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs (float)\n                yaw                       : Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs (float)\n                xacc                      : X acceleration m/s/s (float)\n                yacc                      : Y acceleration m/s/s (float)\n                zacc                      : Z acceleration m/s/s (float)\n                xgyro                     : Angular speed around X axis rad/s (float)\n                ygyro                     : Angular speed around Y axis rad/s (float)\n                zgyro                     : Angular speed around Z axis rad/s (float)\n                lat                       : Latitude in degrees (float)\n                lon                       : Longitude in degrees (float)\n                alt                       : Altitude in meters (float)\n                std_dev_horz              : Horizontal position standard deviation (float)\n                std_dev_vert              : Vertical position standard deviation (float)\n                vn                        : True velocity in m/s in NORTH direction in earth-fixed NED frame (float)\n                ve                        : True velocity in m/s in EAST direction in earth-fixed NED frame (float)\n                vd                        : True velocity in m/s in DOWN direction in earth-fixed NED frame (float)\n\n                '''\n                return MAVLink_sim_state_message(q1, q2, q3, q4, roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lon, alt, std_dev_horz, std_dev_vert, vn, ve, vd)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef radio_status_send(self, rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed, force_mavlink1=False):\n                '''\n                Status generated by radio and injected into MAVLink stream.\n\n                rssi                      : Local signal strength (uint8_t)\n                remrssi                   : Remote signal strength (uint8_t)\n                txbuf                     : Remaining free buffer space in percent. (uint8_t)\n                noise                     : Background noise level (uint8_t)\n                remnoise                  : Remote background noise level (uint8_t)\n                rxerrors                  : Receive errors (uint16_t)\n                fixed                     : Count of error corrected packets (uint16_t)\n\n                '''\n                return self.send(self.radio_status_encode(rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed), force_mavlink1=force_mavlink1)", "response": "Status generated by radio and injected into MAVLink stream."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef file_transfer_protocol_encode(self, target_network, target_system, target_component, payload):\n                '''\n                File transfer message\n\n                target_network            : Network ID (0 for broadcast) (uint8_t)\n                target_system             : System ID (0 for broadcast) (uint8_t)\n                target_component          : Component ID (0 for broadcast) (uint8_t)\n                payload                   : Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification. (uint8_t)\n\n                '''\n                return MAVLink_file_transfer_protocol_message(target_network, target_system, target_component, payload)", "response": "This function encodes the file transfer protocol data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef file_transfer_protocol_send(self, target_network, target_system, target_component, payload, force_mavlink1=False):\n                '''\n                File transfer message\n\n                target_network            : Network ID (0 for broadcast) (uint8_t)\n                target_system             : System ID (0 for broadcast) (uint8_t)\n                target_component          : Component ID (0 for broadcast) (uint8_t)\n                payload                   : Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification. (uint8_t)\n\n                '''\n                return self.send(self.file_transfer_protocol_encode(target_network, target_system, target_component, payload), force_mavlink1=force_mavlink1)", "response": "File transfer message\n\n                target_network            : Network ID (0 for broadcast) (uint8_t)\n                target_system             : System ID (0 for broadcast) (uint8_t)\n                target_component          : Component ID (0 for broadcast) (uint8_t)\n                payload                   : Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification. (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef timesync_send(self, tc1, ts1, force_mavlink1=False):\n                '''\n                Time synchronization message.\n\n                tc1                       : Time sync timestamp 1 (int64_t)\n                ts1                       : Time sync timestamp 2 (int64_t)\n\n                '''\n                return self.send(self.timesync_encode(tc1, ts1), force_mavlink1=force_mavlink1)", "response": "Time synchronization message.\n\n                tc1                       : Time sync timestamp 1 (int64_t)\n                ts1                       : Time sync timestamp 2 (int64_t)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hil_gps_send(self, time_usec, fix_type, lat, lon, alt, eph, epv, vel, vn, ve, vd, cog, satellites_visible, force_mavlink1=False):\n                '''\n                The global position, as returned by the Global Positioning System\n                (GPS). This is                  NOT the global\n                position estimate of the sytem, but rather a RAW\n                sensor value. See message GLOBAL_POSITION for the\n                global position estimate. Coordinate frame is right-\n                handed, Z-axis up (GPS frame).\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                fix_type                  : 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix. (uint8_t)\n                lat                       : Latitude (WGS84), in degrees * 1E7 (int32_t)\n                lon                       : Longitude (WGS84), in degrees * 1E7 (int32_t)\n                alt                       : Altitude (AMSL, not WGS84), in meters * 1000 (positive for up) (int32_t)\n                eph                       : GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535 (uint16_t)\n                epv                       : GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: 65535 (uint16_t)\n                vel                       : GPS ground speed (m/s * 100). If unknown, set to: 65535 (uint16_t)\n                vn                        : GPS velocity in cm/s in NORTH direction in earth-fixed NED frame (int16_t)\n                ve                        : GPS velocity in cm/s in EAST direction in earth-fixed NED frame (int16_t)\n                vd                        : GPS velocity in cm/s in DOWN direction in earth-fixed NED frame (int16_t)\n                cog                       : Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535 (uint16_t)\n                satellites_visible        : Number of satellites visible. If unknown, set to 255 (uint8_t)\n\n                '''\n                return self.send(self.hil_gps_encode(time_usec, fix_type, lat, lon, alt, eph, epv, vel, vn, ve, vd, cog, satellites_visible), force_mavlink1=force_mavlink1)", "response": "Hil - GPS message."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hil_optical_flow_encode(self, time_usec, sensor_id, integration_time_us, integrated_x, integrated_y, integrated_xgyro, integrated_ygyro, integrated_zgyro, temperature, quality, time_delta_distance_us, distance):\n                '''\n                Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical\n                mouse sensor)\n\n                time_usec                 : Timestamp (microseconds, synced to UNIX time or since system boot) (uint64_t)\n                sensor_id                 : Sensor ID (uint8_t)\n                integration_time_us        : Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the. (uint32_t)\n                integrated_x              : Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.) (float)\n                integrated_y              : Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.) (float)\n                integrated_xgyro          : RH rotation around X axis (rad) (float)\n                integrated_ygyro          : RH rotation around Y axis (rad) (float)\n                integrated_zgyro          : RH rotation around Z axis (rad) (float)\n                temperature               : Temperature * 100 in centi-degrees Celsius (int16_t)\n                quality                   : Optical flow quality / confidence. 0: no valid flow, 255: maximum quality (uint8_t)\n                time_delta_distance_us        : Time in microseconds since the distance was sampled. (uint32_t)\n                distance                  : Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance. (float)\n\n                '''\n                return MAVLink_hil_optical_flow_message(time_usec, sensor_id, integration_time_us, integrated_x, integrated_y, integrated_xgyro, integrated_ygyro, integrated_zgyro, temperature, quality, time_delta_distance_us, distance)", "response": "This function is called when the Hil sensor is sampled from a optical flow sensor."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nencodes the HIL_STATE_QUATTERY packet", "response": "def hil_state_quaternion_encode(self, time_usec, attitude_quaternion, rollspeed, pitchspeed, yawspeed, lat, lon, alt, vx, vy, vz, ind_airspeed, true_airspeed, xacc, yacc, zacc):\n                '''\n                Sent from simulation to autopilot, avoids in contrast to HIL_STATE\n                singularities. This packet is useful for high\n                throughput applications such as hardware in the loop\n                simulations.\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                attitude_quaternion        : Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation) (float)\n                rollspeed                 : Body frame roll / phi angular speed (rad/s) (float)\n                pitchspeed                : Body frame pitch / theta angular speed (rad/s) (float)\n                yawspeed                  : Body frame yaw / psi angular speed (rad/s) (float)\n                lat                       : Latitude, expressed as * 1E7 (int32_t)\n                lon                       : Longitude, expressed as * 1E7 (int32_t)\n                alt                       : Altitude in meters, expressed as * 1000 (millimeters) (int32_t)\n                vx                        : Ground X Speed (Latitude), expressed as m/s * 100 (int16_t)\n                vy                        : Ground Y Speed (Longitude), expressed as m/s * 100 (int16_t)\n                vz                        : Ground Z Speed (Altitude), expressed as m/s * 100 (int16_t)\n                ind_airspeed              : Indicated airspeed, expressed as m/s * 100 (uint16_t)\n                true_airspeed             : True airspeed, expressed as m/s * 100 (uint16_t)\n                xacc                      : X acceleration (mg) (int16_t)\n                yacc                      : Y acceleration (mg) (int16_t)\n                zacc                      : Z acceleration (mg) (int16_t)\n\n                '''\n                return MAVLink_hil_state_quaternion_message(time_usec, attitude_quaternion, rollspeed, pitchspeed, yawspeed, lat, lon, alt, vx, vy, vz, ind_airspeed, true_airspeed, xacc, yacc, zacc)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful for high throughput applications such as hardware in the loop simulations. time_usec : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t) attitude_quaternion : Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation) (float) rollspeed : Body frame roll / phi angular speed (rad/s) (float) pitchspeed : Body frame pitch / theta angular speed (rad/s) (float) yawspeed : Body frame yaw / psi angular speed (rad/s) (float) lat : Latitude, expressed as * 1E7 (int32_t) lon : Longitude, expressed as * 1E7 (int32_t) alt : Altitude in meters, expressed as * 1000 (millimeters) (int32_t) vx : Ground X Speed (Latitude), expressed as m/s * 100 (int16_t) vy : Ground Y Speed (Longitude), expressed as m/s * 100 (int16_t) vz : Ground Z Speed (Altitude), expressed as m/s * 100 (int16_t) ind_airspeed : Indicated airspeed, expressed as m/s * 100 (uint16_t) true_airspeed : True airspeed, expressed as m/s * 100 (uint16_t) xacc : X acceleration (mg) (int16_t) yacc : Y acceleration (mg) (int16_t) zacc : Z acceleration (mg) (int16_t)", "response": "def hil_state_quaternion_send(self, time_usec, attitude_quaternion, rollspeed, pitchspeed, yawspeed, lat, lon, alt, vx, vy, vz, ind_airspeed, true_airspeed, xacc, yacc, zacc, force_mavlink1=False):\n                '''\n                Sent from simulation to autopilot, avoids in contrast to HIL_STATE\n                singularities. This packet is useful for high\n                throughput applications such as hardware in the loop\n                simulations.\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                attitude_quaternion        : Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation) (float)\n                rollspeed                 : Body frame roll / phi angular speed (rad/s) (float)\n                pitchspeed                : Body frame pitch / theta angular speed (rad/s) (float)\n                yawspeed                  : Body frame yaw / psi angular speed (rad/s) (float)\n                lat                       : Latitude, expressed as * 1E7 (int32_t)\n                lon                       : Longitude, expressed as * 1E7 (int32_t)\n                alt                       : Altitude in meters, expressed as * 1000 (millimeters) (int32_t)\n                vx                        : Ground X Speed (Latitude), expressed as m/s * 100 (int16_t)\n                vy                        : Ground Y Speed (Longitude), expressed as m/s * 100 (int16_t)\n                vz                        : Ground Z Speed (Altitude), expressed as m/s * 100 (int16_t)\n                ind_airspeed              : Indicated airspeed, expressed as m/s * 100 (uint16_t)\n                true_airspeed             : True airspeed, expressed as m/s * 100 (uint16_t)\n                xacc                      : X acceleration (mg) (int16_t)\n                yacc                      : Y acceleration (mg) (int16_t)\n                zacc                      : Z acceleration (mg) (int16_t)\n\n                '''\n                return self.send(self.hil_state_quaternion_encode(time_usec, attitude_quaternion, rollspeed, pitchspeed, yawspeed, lat, lon, alt, vx, vy, vz, ind_airspeed, true_airspeed, xacc, yacc, zacc), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef scaled_imu2_encode(self, time_boot_ms, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag):\n                '''\n                The RAW IMU readings for secondary 9DOF sensor setup. This message\n                should contain the scaled values to the described\n                units\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                xacc                      : X acceleration (mg) (int16_t)\n                yacc                      : Y acceleration (mg) (int16_t)\n                zacc                      : Z acceleration (mg) (int16_t)\n                xgyro                     : Angular speed around X axis (millirad /sec) (int16_t)\n                ygyro                     : Angular speed around Y axis (millirad /sec) (int16_t)\n                zgyro                     : Angular speed around Z axis (millirad /sec) (int16_t)\n                xmag                      : X Magnetic field (milli tesla) (int16_t)\n                ymag                      : Y Magnetic field (milli tesla) (int16_t)\n                zmag                      : Z Magnetic field (milli tesla) (int16_t)\n\n                '''\n                return MAVLink_scaled_imu2_message(time_boot_ms, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag)", "response": "This function is called when the MAVLink is used to set the current IMU values to the specified values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef scaled_imu2_send(self, time_boot_ms, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag, force_mavlink1=False):\n                '''\n                The RAW IMU readings for secondary 9DOF sensor setup. This message\n                should contain the scaled values to the described\n                units\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                xacc                      : X acceleration (mg) (int16_t)\n                yacc                      : Y acceleration (mg) (int16_t)\n                zacc                      : Z acceleration (mg) (int16_t)\n                xgyro                     : Angular speed around X axis (millirad /sec) (int16_t)\n                ygyro                     : Angular speed around Y axis (millirad /sec) (int16_t)\n                zgyro                     : Angular speed around Z axis (millirad /sec) (int16_t)\n                xmag                      : X Magnetic field (milli tesla) (int16_t)\n                ymag                      : Y Magnetic field (milli tesla) (int16_t)\n                zmag                      : Z Magnetic field (milli tesla) (int16_t)\n\n                '''\n                return self.send(self.scaled_imu2_encode(time_boot_ms, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag), force_mavlink1=force_mavlink1)", "response": "This message is used to set the IMU readings to the specified values."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log_request_list_encode(self, target_system, target_component, start, end):\n                '''\n                Request a list of available logs. On some systems calling this may\n                stop on-board logging until LOG_REQUEST_END is called.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                start                     : First log id (0 for first available) (uint16_t)\n                end                       : Last log id (0xffff for last available) (uint16_t)\n\n                '''\n                return MAVLink_log_request_list_message(target_system, target_component, start, end)", "response": "Request a list of available logs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log_request_list_send(self, target_system, target_component, start, end, force_mavlink1=False):\n                '''\n                Request a list of available logs. On some systems calling this may\n                stop on-board logging until LOG_REQUEST_END is called.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                start                     : First log id (0 for first available) (uint16_t)\n                end                       : Last log id (0xffff for last available) (uint16_t)\n\n                '''\n                return self.send(self.log_request_list_encode(target_system, target_component, start, end), force_mavlink1=force_mavlink1)", "response": "Request a list of available logs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreply to LOG_REQUEST_LIST id : Log id (uint16_t) num_logs : Total number of logs (uint16_t) last_log_num : High log number (uint16_t) time_utc : UTC timestamp of log in seconds since 1970, or 0 if not available (uint32_t) size : Size of the log (may be approximate) in bytes (uint32_t)", "response": "def log_entry_encode(self, id, num_logs, last_log_num, time_utc, size):\n                '''\n                Reply to LOG_REQUEST_LIST\n\n                id                        : Log id (uint16_t)\n                num_logs                  : Total number of logs (uint16_t)\n                last_log_num              : High log number (uint16_t)\n                time_utc                  : UTC timestamp of log in seconds since 1970, or 0 if not available (uint32_t)\n                size                      : Size of the log (may be approximate) in bytes (uint32_t)\n\n                '''\n                return MAVLink_log_entry_message(id, num_logs, last_log_num, time_utc, size)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreplies to LOG_REQUEST_LIST id : Log id (uint16_t) num_logs : Total number of logs (uint16_t) last_log_num : High log number (uint16_t) time_utc : UTC timestamp of log in seconds since 1970, or 0 if not available (uint32_t) size : Size of the log (may be approximate) in bytes (uint32_t)", "response": "def log_entry_send(self, id, num_logs, last_log_num, time_utc, size, force_mavlink1=False):\n                '''\n                Reply to LOG_REQUEST_LIST\n\n                id                        : Log id (uint16_t)\n                num_logs                  : Total number of logs (uint16_t)\n                last_log_num              : High log number (uint16_t)\n                time_utc                  : UTC timestamp of log in seconds since 1970, or 0 if not available (uint32_t)\n                size                      : Size of the log (may be approximate) in bytes (uint32_t)\n\n                '''\n                return self.send(self.log_entry_encode(id, num_logs, last_log_num, time_utc, size), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrequesting a chunk of a log target_system : System ID (uint8_t) target_component : Component ID (uint8_t) id : Log id (from LOG_ENTRY reply) (uint16_t) ofs : Offset into the log (uint32_t) count : Number of bytes (uint32_t)", "response": "def log_request_data_encode(self, target_system, target_component, id, ofs, count):\n                '''\n                Request a chunk of a log\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                id                        : Log id (from LOG_ENTRY reply) (uint16_t)\n                ofs                       : Offset into the log (uint32_t)\n                count                     : Number of bytes (uint32_t)\n\n                '''\n                return MAVLink_log_request_data_message(target_system, target_component, id, ofs, count)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log_request_data_send(self, target_system, target_component, id, ofs, count, force_mavlink1=False):\n                '''\n                Request a chunk of a log\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                id                        : Log id (from LOG_ENTRY reply) (uint16_t)\n                ofs                       : Offset into the log (uint32_t)\n                count                     : Number of bytes (uint32_t)\n\n                '''\n                return self.send(self.log_request_data_encode(target_system, target_component, id, ofs, count), force_mavlink1=force_mavlink1)", "response": "Request a chunk of data from the log."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log_data_encode(self, id, ofs, count, data):\n                '''\n                Reply to LOG_REQUEST_DATA\n\n                id                        : Log id (from LOG_ENTRY reply) (uint16_t)\n                ofs                       : Offset into the log (uint32_t)\n                count                     : Number of bytes (zero for end of log) (uint8_t)\n                data                      : log data (uint8_t)\n\n                '''\n                return MAVLink_log_data_message(id, ofs, count, data)", "response": "This function is called when the MAVLink_log_data_read function is called"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log_data_send(self, id, ofs, count, data, force_mavlink1=False):\n                '''\n                Reply to LOG_REQUEST_DATA\n\n                id                        : Log id (from LOG_ENTRY reply) (uint16_t)\n                ofs                       : Offset into the log (uint32_t)\n                count                     : Number of bytes (zero for end of log) (uint8_t)\n                data                      : log data (uint8_t)\n\n                '''\n                return self.send(self.log_data_encode(id, ofs, count, data), force_mavlink1=force_mavlink1)", "response": "This function is used to send data to the log."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nerase all logs target_system : System ID (uint8_t) target_component : Component ID (uint8_t)", "response": "def log_erase_send(self, target_system, target_component, force_mavlink1=False):\n                '''\n                Erase all logs\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n\n                '''\n                return self.send(self.log_erase_encode(target_system, target_component), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstopping log transfer and resume normal logging", "response": "def log_request_end_send(self, target_system, target_component, force_mavlink1=False):\n                '''\n                Stop log transfer and resume normal logging\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n\n                '''\n                return self.send(self.log_request_end_encode(target_system, target_component), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef gps_inject_data_encode(self, target_system, target_component, len, data):\n                '''\n                data for injecting into the onboard GPS (used for DGPS)\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                len                       : data length (uint8_t)\n                data                      : raw data (110 is enough for 12 satellites of RTCMv2) (uint8_t)\n\n                '''\n                return MAVLink_gps_inject_data_message(target_system, target_component, len, data)", "response": "This function is called when data is injected into the GPS system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninject data into GPS", "response": "def gps_inject_data_send(self, target_system, target_component, len, data, force_mavlink1=False):\n                '''\n                data for injecting into the onboard GPS (used for DGPS)\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                len                       : data length (uint8_t)\n                data                      : raw data (110 is enough for 12 satellites of RTCMv2) (uint8_t)\n\n                '''\n                return self.send(self.gps_inject_data_encode(target_system, target_component, len, data), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nseconds GPS data. Coordinate frame is right-handed, Z-axis up (GPS frame). time_usec : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t) fix_type : See the GPS_FIX_TYPE enum. (uint8_t) lat : Latitude (WGS84), in degrees * 1E7 (int32_t) lon : Longitude (WGS84), in degrees * 1E7 (int32_t) alt : Altitude (AMSL, not WGS84), in meters * 1000 (positive for up) (int32_t) eph : GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX (uint16_t) epv : GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX (uint16_t) vel : GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX (uint16_t) cog : Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX (uint16_t) satellites_visible : Number of satellites visible. If unknown, set to 255 (uint8_t) dgps_numch : Number of DGPS satellites (uint8_t) dgps_age : Age of DGPS info (uint32_t)", "response": "def gps2_raw_encode(self, time_usec, fix_type, lat, lon, alt, eph, epv, vel, cog, satellites_visible, dgps_numch, dgps_age):\n                '''\n                Second GPS data. Coordinate frame is right-handed, Z-axis up (GPS\n                frame).\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                fix_type                  : See the GPS_FIX_TYPE enum. (uint8_t)\n                lat                       : Latitude (WGS84), in degrees * 1E7 (int32_t)\n                lon                       : Longitude (WGS84), in degrees * 1E7 (int32_t)\n                alt                       : Altitude (AMSL, not WGS84), in meters * 1000 (positive for up) (int32_t)\n                eph                       : GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX (uint16_t)\n                epv                       : GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX (uint16_t)\n                vel                       : GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX (uint16_t)\n                cog                       : Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX (uint16_t)\n                satellites_visible        : Number of satellites visible. If unknown, set to 255 (uint8_t)\n                dgps_numch                : Number of DGPS satellites (uint8_t)\n                dgps_age                  : Age of DGPS info (uint32_t)\n\n                '''\n                return MAVLink_gps2_raw_message(time_usec, fix_type, lat, lon, alt, eph, epv, vel, cog, satellites_visible, dgps_numch, dgps_age)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nseconding GPS data. Coordinate frame is right-handed, Z-axis up (GPS frame). time_usec : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t) fix_type : See the GPS_FIX_TYPE enum. (uint8_t) lat : Latitude (WGS84), in degrees * 1E7 (int32_t) lon : Longitude (WGS84), in degrees * 1E7 (int32_t) alt : Altitude (AMSL, not WGS84), in meters * 1000 (positive for up) (int32_t) eph : GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX (uint16_t) epv : GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX (uint16_t) vel : GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX (uint16_t) cog : Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX (uint16_t) satellites_visible : Number of satellites visible. If unknown, set to 255 (uint8_t) dgps_numch : Number of DGPS satellites (uint8_t) dgps_age : Age of DGPS info (uint32_t)", "response": "def gps2_raw_send(self, time_usec, fix_type, lat, lon, alt, eph, epv, vel, cog, satellites_visible, dgps_numch, dgps_age, force_mavlink1=False):\n                '''\n                Second GPS data. Coordinate frame is right-handed, Z-axis up (GPS\n                frame).\n\n                time_usec                 : Timestamp (microseconds since UNIX epoch or microseconds since system boot) (uint64_t)\n                fix_type                  : See the GPS_FIX_TYPE enum. (uint8_t)\n                lat                       : Latitude (WGS84), in degrees * 1E7 (int32_t)\n                lon                       : Longitude (WGS84), in degrees * 1E7 (int32_t)\n                alt                       : Altitude (AMSL, not WGS84), in meters * 1000 (positive for up) (int32_t)\n                eph                       : GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX (uint16_t)\n                epv                       : GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX (uint16_t)\n                vel                       : GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX (uint16_t)\n                cog                       : Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX (uint16_t)\n                satellites_visible        : Number of satellites visible. If unknown, set to 255 (uint8_t)\n                dgps_numch                : Number of DGPS satellites (uint8_t)\n                dgps_age                  : Age of DGPS info (uint32_t)\n\n                '''\n                return self.send(self.gps2_raw_encode(time_usec, fix_type, lat, lon, alt, eph, epv, vel, cog, satellites_visible, dgps_numch, dgps_age), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npowering supply status Vcc : 5V rail voltage in millivolts (uint16_t) Vservo : servo rail voltage in millivolts (uint16_t) flags : power supply status flags (see MAV_POWER_STATUS enum) (uint16_t)", "response": "def power_status_send(self, Vcc, Vservo, flags, force_mavlink1=False):\n                '''\n                Power supply status\n\n                Vcc                       : 5V rail voltage in millivolts (uint16_t)\n                Vservo                    : servo rail voltage in millivolts (uint16_t)\n                flags                     : power supply status flags (see MAV_POWER_STATUS enum) (uint16_t)\n\n                '''\n                return self.send(self.power_status_encode(Vcc, Vservo, flags), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef serial_control_encode(self, device, flags, timeout, baudrate, count, data):\n                '''\n                Control a serial port. This can be used for raw access to an onboard\n                serial peripheral such as a GPS or telemetry radio. It\n                is designed to make it possible to update the devices\n                firmware via MAVLink messages or change the devices\n                settings. A message with zero bytes can be used to\n                change just the baudrate.\n\n                device                    : See SERIAL_CONTROL_DEV enum (uint8_t)\n                flags                     : See SERIAL_CONTROL_FLAG enum (uint8_t)\n                timeout                   : Timeout for reply data in milliseconds (uint16_t)\n                baudrate                  : Baudrate of transfer. Zero means no change. (uint32_t)\n                count                     : how many bytes in this transfer (uint8_t)\n                data                      : serial data (uint8_t)\n\n                '''\n                return MAVLink_serial_control_message(device, flags, timeout, baudrate, count, data)", "response": "This function is used to send a serial control message to the APKs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serial_control_send(self, device, flags, timeout, baudrate, count, data, force_mavlink1=False):\n                '''\n                Control a serial port. This can be used for raw access to an onboard\n                serial peripheral such as a GPS or telemetry radio. It\n                is designed to make it possible to update the devices\n                firmware via MAVLink messages or change the devices\n                settings. A message with zero bytes can be used to\n                change just the baudrate.\n\n                device                    : See SERIAL_CONTROL_DEV enum (uint8_t)\n                flags                     : See SERIAL_CONTROL_FLAG enum (uint8_t)\n                timeout                   : Timeout for reply data in milliseconds (uint16_t)\n                baudrate                  : Baudrate of transfer. Zero means no change. (uint32_t)\n                count                     : how many bytes in this transfer (uint8_t)\n                data                      : serial data (uint8_t)\n\n                '''\n                return self.send(self.serial_control_encode(device, flags, timeout, baudrate, count, data), force_mavlink1=force_mavlink1)", "response": "Control a serial port."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gps_rtk_send(self, time_last_baseline_ms, rtk_receiver_id, wn, tow, rtk_health, rtk_rate, nsats, baseline_coords_type, baseline_a_mm, baseline_b_mm, baseline_c_mm, accuracy, iar_num_hypotheses, force_mavlink1=False):\n                '''\n                RTK GPS data. Gives information on the relative baseline calculation\n                the GPS is reporting\n\n                time_last_baseline_ms        : Time since boot of last baseline message received in ms. (uint32_t)\n                rtk_receiver_id           : Identification of connected RTK receiver. (uint8_t)\n                wn                        : GPS Week Number of last baseline (uint16_t)\n                tow                       : GPS Time of Week of last baseline (uint32_t)\n                rtk_health                : GPS-specific health report for RTK data. (uint8_t)\n                rtk_rate                  : Rate of baseline messages being received by GPS, in HZ (uint8_t)\n                nsats                     : Current number of sats used for RTK calculation. (uint8_t)\n                baseline_coords_type        : Coordinate system of baseline. 0 == ECEF, 1 == NED (uint8_t)\n                baseline_a_mm             : Current baseline in ECEF x or NED north component in mm. (int32_t)\n                baseline_b_mm             : Current baseline in ECEF y or NED east component in mm. (int32_t)\n                baseline_c_mm             : Current baseline in ECEF z or NED down component in mm. (int32_t)\n                accuracy                  : Current estimate of baseline accuracy. (uint32_t)\n                iar_num_hypotheses        : Current number of integer ambiguity hypotheses. (int32_t)\n\n                '''\n                return self.send(self.gps_rtk_encode(time_last_baseline_ms, rtk_receiver_id, wn, tow, rtk_health, rtk_rate, nsats, baseline_coords_type, baseline_a_mm, baseline_b_mm, baseline_c_mm, accuracy, iar_num_hypotheses), force_mavlink1=force_mavlink1)", "response": "RTK GPS data. Gives information on the relative baseline calculation\n                the GPS is reporting\n\n                time_last_baseline_ms        : Time since boot of last baseline message received in ms. (uint32_t)\n                rtk_receiver_id           : Identification of connected RTK receiver. (uint8_t)\n                wn                        : GPS Week Number of last baseline (uint16_t)\n                tow                       : GPS Time of Week of last baseline (uint32_t)\n                rtk_health                : GPS-specific health report for RTK data. (uint8_t)\n                rtk_rate                  : Rate of baseline messages being received by GPS, in HZ (uint8_t)\n                nsats                     : Current number of sats used for RTK calculation. (uint8_t)\n                baseline_coords_type        : Coordinate system of baseline. 0 == ECEF, 1 == NED (uint8_t)\n                baseline_a_mm             : Current baseline in ECEF x or NED north component in mm. (int32_t)\n                baseline_b_mm             : Current baseline in ECEF y or NED east component in mm. (int32_t)\n                baseline_c_mm             : Current baseline in ECEF z or NED down component in mm. (int32_t)\n                accuracy                  : Current estimate of baseline accuracy. (uint32_t)\n                iar_num_hypotheses        : Current number of integer ambiguity hypotheses. (int32_t)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef scaled_imu3_encode(self, time_boot_ms, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag):\n                '''\n                The RAW IMU readings for 3rd 9DOF sensor setup. This message should\n                contain the scaled values to the described units\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                xacc                      : X acceleration (mg) (int16_t)\n                yacc                      : Y acceleration (mg) (int16_t)\n                zacc                      : Z acceleration (mg) (int16_t)\n                xgyro                     : Angular speed around X axis (millirad /sec) (int16_t)\n                ygyro                     : Angular speed around Y axis (millirad /sec) (int16_t)\n                zgyro                     : Angular speed around Z axis (millirad /sec) (int16_t)\n                xmag                      : X Magnetic field (milli tesla) (int16_t)\n                ymag                      : Y Magnetic field (milli tesla) (int16_t)\n                zmag                      : Z Magnetic field (milli tesla) (int16_t)\n\n                '''\n                return MAVLink_scaled_imu3_message(time_boot_ms, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag)", "response": "This function is called when the MAVLink_readings_3rd9DOF_sensor_setup is called to generate a scaled IMU 3. 0. 0."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef terrain_request_encode(self, lat, lon, grid_spacing, mask):\n                '''\n                Request for terrain data and terrain status\n\n                lat                       : Latitude of SW corner of first grid (degrees *10^7) (int32_t)\n                lon                       : Longitude of SW corner of first grid (in degrees *10^7) (int32_t)\n                grid_spacing              : Grid spacing in meters (uint16_t)\n                mask                      : Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits) (uint64_t)\n\n                '''\n                return MAVLink_terrain_request_message(lat, lon, grid_spacing, mask)", "response": "Request for terrain data and terrain status"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrequesting terrain data and terrain status", "response": "def terrain_request_send(self, lat, lon, grid_spacing, mask, force_mavlink1=False):\n                '''\n                Request for terrain data and terrain status\n\n                lat                       : Latitude of SW corner of first grid (degrees *10^7) (int32_t)\n                lon                       : Longitude of SW corner of first grid (in degrees *10^7) (int32_t)\n                grid_spacing              : Grid spacing in meters (uint16_t)\n                mask                      : Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits) (uint64_t)\n\n                '''\n                return self.send(self.terrain_request_encode(lat, lon, grid_spacing, mask), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef terrain_check_send(self, lat, lon, force_mavlink1=False):\n                '''\n                Request that the vehicle report terrain height at the given location.\n                Used by GCS to check if vehicle has all terrain data\n                needed for a mission.\n\n                lat                       : Latitude (degrees *10^7) (int32_t)\n                lon                       : Longitude (degrees *10^7) (int32_t)\n\n                '''\n                return self.send(self.terrain_check_encode(lat, lon), force_mavlink1=force_mavlink1)", "response": "Tell vehicle that terrain height at the given location is in the desired state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef terrain_report_send(self, lat, lon, spacing, terrain_height, current_height, pending, loaded, force_mavlink1=False):\n                '''\n                Response from a TERRAIN_CHECK request\n\n                lat                       : Latitude (degrees *10^7) (int32_t)\n                lon                       : Longitude (degrees *10^7) (int32_t)\n                spacing                   : grid spacing (zero if terrain at this location unavailable) (uint16_t)\n                terrain_height            : Terrain height in meters AMSL (float)\n                current_height            : Current vehicle height above lat/lon terrain height (meters) (float)\n                pending                   : Number of 4x4 terrain blocks waiting to be received or read from disk (uint16_t)\n                loaded                    : Number of 4x4 terrain blocks in memory (uint16_t)\n\n                '''\n                return self.send(self.terrain_report_encode(lat, lon, spacing, terrain_height, current_height, pending, loaded), force_mavlink1=force_mavlink1)", "response": "Terrain report from a TERRAIN_CHECK request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef scaled_pressure2_send(self, time_boot_ms, press_abs, press_diff, temperature, force_mavlink1=False):\n                '''\n                Barometer readings for 2nd barometer\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                press_abs                 : Absolute pressure (hectopascal) (float)\n                press_diff                : Differential pressure 1 (hectopascal) (float)\n                temperature               : Temperature measurement (0.01 degrees celsius) (int16_t)\n\n                '''\n                return self.send(self.scaled_pressure2_encode(time_boot_ms, press_abs, press_diff, temperature), force_mavlink1=force_mavlink1)", "response": "Barometer readings for 2nd barometer\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                press_abs                 : Absolute pressure (hectopascal) (float)\n                press_diff                : Differential pressure 1 (hectopascal) (float)\n                temperature               : Temperature measurement (0.01 degrees celsius) (int16_t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmotions capture attitude and position time_usec : Timestamp (micros since boot or Unix epoch) (uint64_t) q : Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) (float) x : X position in meters (NED) (float) y : Y position in meters (NED) (float) z : Z position in meters (NED) (float)", "response": "def att_pos_mocap_encode(self, time_usec, q, x, y, z):\n                '''\n                Motion capture attitude and position\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                q                         : Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) (float)\n                x                         : X position in meters (NED) (float)\n                y                         : Y position in meters (NED) (float)\n                z                         : Z position in meters (NED) (float)\n\n                '''\n                return MAVLink_att_pos_mocap_message(time_usec, q, x, y, z)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef att_pos_mocap_send(self, time_usec, q, x, y, z, force_mavlink1=False):\n                '''\n                Motion capture attitude and position\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                q                         : Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) (float)\n                x                         : X position in meters (NED) (float)\n                y                         : Y position in meters (NED) (float)\n                z                         : Z position in meters (NED) (float)\n\n                '''\n                return self.send(self.att_pos_mocap_encode(time_usec, q, x, y, z), force_mavlink1=force_mavlink1)", "response": "Motion capture attitude and position"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the vehicle attitude and body angular rates. time_usec : Timestamp (micros since boot or Unix epoch) (uint64_t) group_mlx : Actuator group. The \"_mlx\" indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances. (uint8_t) target_system : System ID (uint8_t) target_component : Component ID (uint8_t) controls : Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs. (float)", "response": "def set_actuator_control_target_encode(self, time_usec, group_mlx, target_system, target_component, controls):\n                '''\n                Set the vehicle attitude and body angular rates.\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                group_mlx                 : Actuator group. The \"_mlx\" indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances. (uint8_t)\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                controls                  : Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs. (float)\n\n                '''\n                return MAVLink_set_actuator_control_target_message(time_usec, group_mlx, target_system, target_component, controls)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the vehicle attitude and body angular rates.", "response": "def set_actuator_control_target_send(self, time_usec, group_mlx, target_system, target_component, controls, force_mavlink1=False):\n                '''\n                Set the vehicle attitude and body angular rates.\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                group_mlx                 : Actuator group. The \"_mlx\" indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances. (uint8_t)\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                controls                  : Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs. (float)\n\n                '''\n                return self.send(self.set_actuator_control_target_encode(time_usec, group_mlx, target_system, target_component, controls), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef actuator_control_target_send(self, time_usec, group_mlx, controls, force_mavlink1=False):\n                '''\n                Set the vehicle attitude and body angular rates.\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                group_mlx                 : Actuator group. The \"_mlx\" indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances. (uint8_t)\n                controls                  : Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs. (float)\n\n                '''\n                return self.send(self.actuator_control_target_encode(time_usec, group_mlx, controls), force_mavlink1=force_mavlink1)", "response": "Set the vehicle attitude and body angular rates.\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                group_mlx                 : Actuator group. The \"_mlx\" indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances. (uint8_t)\n                controls                  : Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs. (float)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef altitude_encode(self, time_usec, altitude_monotonic, altitude_amsl, altitude_local, altitude_relative, altitude_terrain, bottom_clearance):\n                '''\n                The current system altitude.\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                altitude_monotonic        : This altitude measure is initialized on system boot and monotonic (it is never reset, but represents the local altitude change). The only guarantee on this field is that it will never be reset and is consistent within a flight. The recommended value for this field is the uncorrected barometric altitude at boot time. This altitude will also drift and vary between flights. (float)\n                altitude_amsl             : This altitude measure is strictly above mean sea level and might be non-monotonic (it might reset on events like GPS lock or when a new QNH value is set). It should be the altitude to which global altitude waypoints are compared to. Note that it is *not* the GPS altitude, however, most GPS modules already output AMSL by default and not the WGS84 altitude. (float)\n                altitude_local            : This is the local altitude in the local coordinate frame. It is not the altitude above home, but in reference to the coordinate origin (0, 0, 0). It is up-positive. (float)\n                altitude_relative         : This is the altitude above the home position. It resets on each change of the current home position. (float)\n                altitude_terrain          : This is the altitude above terrain. It might be fed by a terrain database or an altimeter. Values smaller than -1000 should be interpreted as unknown. (float)\n                bottom_clearance          : This is not the altitude, but the clear space below the system according to the fused clearance estimate. It generally should max out at the maximum range of e.g. the laser altimeter. It is generally a moving target. A negative value indicates no measurement available. (float)\n\n                '''\n                return MAVLink_altitude_message(time_usec, altitude_monotonic, altitude_amsl, altitude_local, altitude_relative, altitude_terrain, bottom_clearance)", "response": "This function is used to encode the altitude of the current system."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrequesting a resource from the autopilot.", "response": "def resource_request_send(self, request_id, uri_type, uri, transfer_type, storage, force_mavlink1=False):\n                '''\n                The autopilot is requesting a resource (file, binary, other type of\n                data)\n\n                request_id                : Request ID. This ID should be re-used when sending back URI contents (uint8_t)\n                uri_type                  : The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary (uint8_t)\n                uri                       : The requested unique resource identifier (URI). It is not necessarily a straight domain name (depends on the URI type enum) (uint8_t)\n                transfer_type             : The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream. (uint8_t)\n                storage                   : The storage path the autopilot wants the URI to be stored in. Will only be valid if the transfer_type has a storage associated (e.g. MAVLink FTP). (uint8_t)\n\n                '''\n                return self.send(self.resource_request_encode(request_id, uri_type, uri, transfer_type, storage), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef follow_target_encode(self, timestamp, est_capabilities, lat, lon, alt, vel, acc, attitude_q, rates, position_cov, custom_state):\n                '''\n                current motion information from a designated system\n\n                timestamp                 : Timestamp in milliseconds since system boot (uint64_t)\n                est_capabilities          : bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3) (uint8_t)\n                lat                       : Latitude (WGS84), in degrees * 1E7 (int32_t)\n                lon                       : Longitude (WGS84), in degrees * 1E7 (int32_t)\n                alt                       : AMSL, in meters (float)\n                vel                       : target velocity (0,0,0) for unknown (float)\n                acc                       : linear target acceleration (0,0,0) for unknown (float)\n                attitude_q                : (1 0 0 0 for unknown) (float)\n                rates                     : (0 0 0 for unknown) (float)\n                position_cov              : eph epv (float)\n                custom_state              : button states or switches of a tracker device (uint64_t)\n\n                '''\n                return MAVLink_follow_target_message(timestamp, est_capabilities, lat, lon, alt, vel, acc, attitude_q, rates, position_cov, custom_state)", "response": "Follow target from a designated system"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef follow_target_send(self, timestamp, est_capabilities, lat, lon, alt, vel, acc, attitude_q, rates, position_cov, custom_state, force_mavlink1=False):\n                '''\n                current motion information from a designated system\n\n                timestamp                 : Timestamp in milliseconds since system boot (uint64_t)\n                est_capabilities          : bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3) (uint8_t)\n                lat                       : Latitude (WGS84), in degrees * 1E7 (int32_t)\n                lon                       : Longitude (WGS84), in degrees * 1E7 (int32_t)\n                alt                       : AMSL, in meters (float)\n                vel                       : target velocity (0,0,0) for unknown (float)\n                acc                       : linear target acceleration (0,0,0) for unknown (float)\n                attitude_q                : (1 0 0 0 for unknown) (float)\n                rates                     : (0 0 0 for unknown) (float)\n                position_cov              : eph epv (float)\n                custom_state              : button states or switches of a tracker device (uint64_t)\n\n                '''\n                return self.send(self.follow_target_encode(timestamp, est_capabilities, lat, lon, alt, vel, acc, attitude_q, rates, position_cov, custom_state), force_mavlink1=force_mavlink1)", "response": "Follow target information from a designated system"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef control_system_state_send(self, time_usec, x_acc, y_acc, z_acc, x_vel, y_vel, z_vel, x_pos, y_pos, z_pos, airspeed, vel_variance, pos_variance, q, roll_rate, pitch_rate, yaw_rate, force_mavlink1=False):\n                '''\n                The smoothed, monotonic system state used to feed the control loops of\n                the system.\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                x_acc                     : X acceleration in body frame (float)\n                y_acc                     : Y acceleration in body frame (float)\n                z_acc                     : Z acceleration in body frame (float)\n                x_vel                     : X velocity in body frame (float)\n                y_vel                     : Y velocity in body frame (float)\n                z_vel                     : Z velocity in body frame (float)\n                x_pos                     : X position in local frame (float)\n                y_pos                     : Y position in local frame (float)\n                z_pos                     : Z position in local frame (float)\n                airspeed                  : Airspeed, set to -1 if unknown (float)\n                vel_variance              : Variance of body velocity estimate (float)\n                pos_variance              : Variance in local position (float)\n                q                         : The attitude, represented as Quaternion (float)\n                roll_rate                 : Angular rate in roll axis (float)\n                pitch_rate                : Angular rate in pitch axis (float)\n                yaw_rate                  : Angular rate in yaw axis (float)\n\n                '''\n                return self.send(self.control_system_state_encode(time_usec, x_acc, y_acc, z_acc, x_vel, y_vel, z_vel, x_pos, y_pos, z_pos, airspeed, vel_variance, pos_variance, q, roll_rate, pitch_rate, yaw_rate), force_mavlink1=force_mavlink1)", "response": "The smoothed, monotonic system state used to feed the control loops of\n                the system.\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                x_acc                     : X acceleration in body frame (float)\n                y_acc                     : Y acceleration in body frame (float)\n                z_acc                     : Z acceleration in body frame (float)\n                x_vel                     : X velocity in body frame (float)\n                y_vel                     : Y velocity in body frame (float)\n                z_vel                     : Z velocity in body frame (float)\n                x_pos                     : X position in local frame (float)\n                y_pos                     : Y position in local frame (float)\n                z_pos                     : Z position in local frame (float)\n                airspeed                  : Airspeed, set to -1 if unknown (float)\n                vel_variance              : Variance of body velocity estimate (float)\n                pos_variance              : Variance in local position (float)\n                q                         : The attitude, represented as Quaternion (float)\n                roll_rate                 : Angular rate in roll axis (float)\n                pitch_rate                : Angular rate in pitch axis (float)\n                yaw_rate                  : Angular rate in yaw axis (float)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nversioning and capability of autopilot software capabilities : bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum) (uint64_t) flight_sw_version : Firmware version number (uint32_t) middleware_sw_version : Middleware version number (uint32_t) os_sw_version : Operating system version number (uint32_t) board_version : HW / board version (last 8 bytes should be silicon ID, if any) (uint32_t) flight_custom_version : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t) middleware_custom_version : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t) os_custom_version : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t) vendor_id : ID of the board vendor (uint16_t) product_id : ID of the product (uint16_t) uid : UID if provided by hardware (uint64_t)", "response": "def autopilot_version_encode(self, capabilities, flight_sw_version, middleware_sw_version, os_sw_version, board_version, flight_custom_version, middleware_custom_version, os_custom_version, vendor_id, product_id, uid):\n                '''\n                Version and capability of autopilot software\n\n                capabilities              : bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum) (uint64_t)\n                flight_sw_version         : Firmware version number (uint32_t)\n                middleware_sw_version        : Middleware version number (uint32_t)\n                os_sw_version             : Operating system version number (uint32_t)\n                board_version             : HW / board version (last 8 bytes should be silicon ID, if any) (uint32_t)\n                flight_custom_version        : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t)\n                middleware_custom_version        : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t)\n                os_custom_version         : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t)\n                vendor_id                 : ID of the board vendor (uint16_t)\n                product_id                : ID of the product (uint16_t)\n                uid                       : UID if provided by hardware (uint64_t)\n\n                '''\n                return MAVLink_autopilot_version_message(capabilities, flight_sw_version, middleware_sw_version, os_sw_version, board_version, flight_custom_version, middleware_custom_version, os_custom_version, vendor_id, product_id, uid)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef autopilot_version_send(self, capabilities, flight_sw_version, middleware_sw_version, os_sw_version, board_version, flight_custom_version, middleware_custom_version, os_custom_version, vendor_id, product_id, uid, force_mavlink1=False):\n                '''\n                Version and capability of autopilot software\n\n                capabilities              : bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum) (uint64_t)\n                flight_sw_version         : Firmware version number (uint32_t)\n                middleware_sw_version        : Middleware version number (uint32_t)\n                os_sw_version             : Operating system version number (uint32_t)\n                board_version             : HW / board version (last 8 bytes should be silicon ID, if any) (uint32_t)\n                flight_custom_version        : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t)\n                middleware_custom_version        : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t)\n                os_custom_version         : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t)\n                vendor_id                 : ID of the board vendor (uint16_t)\n                product_id                : ID of the product (uint16_t)\n                uid                       : UID if provided by hardware (uint64_t)\n\n                '''\n                return self.send(self.autopilot_version_encode(capabilities, flight_sw_version, middleware_sw_version, os_sw_version, board_version, flight_custom_version, middleware_custom_version, os_custom_version, vendor_id, product_id, uid), force_mavlink1=force_mavlink1)", "response": "Version and capability of autopilot software\n\n                capabilities              : bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum) (uint64_t)\n                flight_sw_version         : Firmware version number (uint32_t)\n                middleware_sw_version        : Middleware version number (uint32_t)\n                os_sw_version             : Operating system version number (uint32_t)\n                board_version             : HW / board version (last 8 bytes should be silicon ID, if any) (uint32_t)\n                flight_custom_version        : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t)\n                middleware_custom_version        : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t)\n                os_custom_version         : Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. (uint8_t)\n                vendor_id                 : ID of the board vendor (uint16_t)\n                product_id                : ID of the product (uint16_t)\n                uid                       : UID if provided by hardware (uint64_t)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencoding the estimator status message.", "response": "def estimator_status_encode(self, time_usec, flags, vel_ratio, pos_horiz_ratio, pos_vert_ratio, mag_ratio, hagl_ratio, tas_ratio, pos_horiz_accuracy, pos_vert_accuracy):\n                '''\n                Estimator status message including flags, innovation test ratios and\n                estimated accuracies. The flags message is an integer\n                bitmask containing information on which EKF outputs\n                are valid. See the ESTIMATOR_STATUS_FLAGS enum\n                definition for further information. The innovaton test\n                ratios show the magnitude of the sensor innovation\n                divided by the innovation check threshold. Under\n                normal operation the innovaton test ratios should be\n                below 0.5 with occasional values up to 1.0. Values\n                greater than 1.0 should be rare under normal operation\n                and indicate that a measurement has been rejected by\n                the filter. The user should be notified if an\n                innovation test ratio greater than 1.0 is recorded.\n                Notifications for values in the range between 0.5 and\n                1.0 should be optional and controllable by the user.\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                flags                     : Integer bitmask indicating which EKF outputs are valid. See definition for ESTIMATOR_STATUS_FLAGS. (uint16_t)\n                vel_ratio                 : Velocity innovation test ratio (float)\n                pos_horiz_ratio           : Horizontal position innovation test ratio (float)\n                pos_vert_ratio            : Vertical position innovation test ratio (float)\n                mag_ratio                 : Magnetometer innovation test ratio (float)\n                hagl_ratio                : Height above terrain innovation test ratio (float)\n                tas_ratio                 : True airspeed innovation test ratio (float)\n                pos_horiz_accuracy        : Horizontal position 1-STD accuracy relative to the EKF local origin (m) (float)\n                pos_vert_accuracy         : Vertical position 1-STD accuracy relative to the EKF local origin (m) (float)\n\n                '''\n                return MAVLink_estimator_status_message(time_usec, flags, vel_ratio, pos_horiz_ratio, pos_vert_ratio, mag_ratio, hagl_ratio, tas_ratio, pos_horiz_accuracy, pos_vert_accuracy)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef estimator_status_send(self, time_usec, flags, vel_ratio, pos_horiz_ratio, pos_vert_ratio, mag_ratio, hagl_ratio, tas_ratio, pos_horiz_accuracy, pos_vert_accuracy, force_mavlink1=False):\n                '''\n                Estimator status message including flags, innovation test ratios and\n                estimated accuracies. The flags message is an integer\n                bitmask containing information on which EKF outputs\n                are valid. See the ESTIMATOR_STATUS_FLAGS enum\n                definition for further information. The innovaton test\n                ratios show the magnitude of the sensor innovation\n                divided by the innovation check threshold. Under\n                normal operation the innovaton test ratios should be\n                below 0.5 with occasional values up to 1.0. Values\n                greater than 1.0 should be rare under normal operation\n                and indicate that a measurement has been rejected by\n                the filter. The user should be notified if an\n                innovation test ratio greater than 1.0 is recorded.\n                Notifications for values in the range between 0.5 and\n                1.0 should be optional and controllable by the user.\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                flags                     : Integer bitmask indicating which EKF outputs are valid. See definition for ESTIMATOR_STATUS_FLAGS. (uint16_t)\n                vel_ratio                 : Velocity innovation test ratio (float)\n                pos_horiz_ratio           : Horizontal position innovation test ratio (float)\n                pos_vert_ratio            : Vertical position innovation test ratio (float)\n                mag_ratio                 : Magnetometer innovation test ratio (float)\n                hagl_ratio                : Height above terrain innovation test ratio (float)\n                tas_ratio                 : True airspeed innovation test ratio (float)\n                pos_horiz_accuracy        : Horizontal position 1-STD accuracy relative to the EKF local origin (m) (float)\n                pos_vert_accuracy         : Vertical position 1-STD accuracy relative to the EKF local origin (m) (float)\n\n                '''\n                return self.send(self.estimator_status_encode(time_usec, flags, vel_ratio, pos_horiz_ratio, pos_vert_ratio, mag_ratio, hagl_ratio, tas_ratio, pos_horiz_accuracy, pos_vert_accuracy), force_mavlink1=force_mavlink1)", "response": "This method is used to send the status of the EKF estimator."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef gps_input_encode(self, time_usec, gps_id, ignore_flags, time_week_ms, time_week, fix_type, lat, lon, alt, hdop, vdop, vn, ve, vd, speed_accuracy, horiz_accuracy, vert_accuracy, satellites_visible):\n                '''\n                GPS sensor input message.  This is a raw sensor value sent by the GPS.\n                This is NOT the global position estimate of the sytem.\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                gps_id                    : ID of the GPS for multiple GPS inputs (uint8_t)\n                ignore_flags              : Flags indicating which fields to ignore (see GPS_INPUT_IGNORE_FLAGS enum).  All other fields must be provided. (uint16_t)\n                time_week_ms              : GPS time (milliseconds from start of GPS week) (uint32_t)\n                time_week                 : GPS week number (uint16_t)\n                fix_type                  : 0-1: no fix, 2: 2D fix, 3: 3D fix. 4: 3D with DGPS. 5: 3D with RTK (uint8_t)\n                lat                       : Latitude (WGS84), in degrees * 1E7 (int32_t)\n                lon                       : Longitude (WGS84), in degrees * 1E7 (int32_t)\n                alt                       : Altitude (AMSL, not WGS84), in m (positive for up) (float)\n                hdop                      : GPS HDOP horizontal dilution of position in m (float)\n                vdop                      : GPS VDOP vertical dilution of position in m (float)\n                vn                        : GPS velocity in m/s in NORTH direction in earth-fixed NED frame (float)\n                ve                        : GPS velocity in m/s in EAST direction in earth-fixed NED frame (float)\n                vd                        : GPS velocity in m/s in DOWN direction in earth-fixed NED frame (float)\n                speed_accuracy            : GPS speed accuracy in m/s (float)\n                horiz_accuracy            : GPS horizontal accuracy in m (float)\n                vert_accuracy             : GPS vertical accuracy in m (float)\n                satellites_visible        : Number of satellites visible. (uint8_t)\n\n                '''\n                return MAVLink_gps_input_message(time_usec, gps_id, ignore_flags, time_week_ms, time_week, fix_type, lat, lon, alt, hdop, vdop, vn, ve, vd, speed_accuracy, horiz_accuracy, vert_accuracy, satellites_visible)", "response": "This method encodes the GPS sensor input message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nworking IN PROGRESS! RTCM message for injecting into the onboard GPS (used for DGPS) flags : LSB: 1 means message is fragmented (uint8_t) len : data length (uint8_t) data : RTCM message (may be fragmented) (uint8_t)", "response": "def gps_rtcm_data_send(self, flags, len, data, force_mavlink1=False):\n                '''\n                WORK IN PROGRESS! RTCM message for injecting into the onboard GPS\n                (used for DGPS)\n\n                flags                     : LSB: 1 means message is fragmented (uint8_t)\n                len                       : data length (uint8_t)\n                data                      : RTCM message (may be fragmented) (uint8_t)\n\n                '''\n                return self.send(self.gps_rtcm_data_encode(flags, len, data), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vibration_encode(self, time_usec, vibration_x, vibration_y, vibration_z, clipping_0, clipping_1, clipping_2):\n                '''\n                Vibration levels and accelerometer clipping\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                vibration_x               : Vibration levels on X-axis (float)\n                vibration_y               : Vibration levels on Y-axis (float)\n                vibration_z               : Vibration levels on Z-axis (float)\n                clipping_0                : first accelerometer clipping count (uint32_t)\n                clipping_1                : second accelerometer clipping count (uint32_t)\n                clipping_2                : third accelerometer clipping count (uint32_t)\n\n                '''\n                return MAVLink_vibration_message(time_usec, vibration_x, vibration_y, vibration_z, clipping_0, clipping_1, clipping_2)", "response": "Vibration data for the current accelerometer"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef vibration_send(self, time_usec, vibration_x, vibration_y, vibration_z, clipping_0, clipping_1, clipping_2, force_mavlink1=False):\n                '''\n                Vibration levels and accelerometer clipping\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                vibration_x               : Vibration levels on X-axis (float)\n                vibration_y               : Vibration levels on Y-axis (float)\n                vibration_z               : Vibration levels on Z-axis (float)\n                clipping_0                : first accelerometer clipping count (uint32_t)\n                clipping_1                : second accelerometer clipping count (uint32_t)\n                clipping_2                : third accelerometer clipping count (uint32_t)\n\n                '''\n                return self.send(self.vibration_encode(time_usec, vibration_x, vibration_y, vibration_z, clipping_0, clipping_1, clipping_2), force_mavlink1=force_mavlink1)", "response": "Vibration levels and accelerometer clipping\n\n                time_usec                 : Timestamp (micros since boot or Unix epoch) (uint64_t)\n                vibration_x               : Vibration levels on X-axis (float)\n                vibration_y               : Vibration levels on Y-axis (float)\n                vibration_z               : Vibration levels on Z-axis (float)\n                clipping_0                : first accelerometer clipping count (uint32_t)\n                clipping_1                : second accelerometer clipping count (uint32_t)\n                clipping_2                : third accelerometer clipping count (uint32_t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef home_position_send(self, latitude, longitude, altitude, x, y, z, q, approach_x, approach_y, approach_z, force_mavlink1=False):\n                '''\n                This message can be requested by sending the MAV_CMD_GET_HOME_POSITION\n                command. The position the system will return to and\n                land on. The position is set automatically by the\n                system during the takeoff in case it was not\n                explicitely set by the operator before or after. The\n                position the system will return to and land on. The\n                global and local positions encode the position in the\n                respective coordinate frames, while the q parameter\n                encodes the orientation of the surface. Under normal\n                conditions it describes the heading and terrain slope,\n                which can be used by the aircraft to adjust the\n                approach. The approach 3D vector describes the point\n                to which the system should fly in normal flight mode\n                and then perform a landing sequence along the vector.\n\n                latitude                  : Latitude (WGS84), in degrees * 1E7 (int32_t)\n                longitude                 : Longitude (WGS84, in degrees * 1E7 (int32_t)\n                altitude                  : Altitude (AMSL), in meters * 1000 (positive for up) (int32_t)\n                x                         : Local X position of this position in the local coordinate frame (float)\n                y                         : Local Y position of this position in the local coordinate frame (float)\n                z                         : Local Z position of this position in the local coordinate frame (float)\n                q                         : World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground (float)\n                approach_x                : Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. (float)\n                approach_y                : Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. (float)\n                approach_z                : Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. (float)\n\n                '''\n                return self.send(self.home_position_encode(latitude, longitude, altitude, x, y, z, q, approach_x, approach_y, approach_z), force_mavlink1=force_mavlink1)", "response": "home position request by the user"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_home_position_encode(self, target_system, latitude, longitude, altitude, x, y, z, q, approach_x, approach_y, approach_z):\n                '''\n                The position the system will return to and land on. The position is\n                set automatically by the system during the takeoff in\n                case it was not explicitely set by the operator before\n                or after. The global and local positions encode the\n                position in the respective coordinate frames, while\n                the q parameter encodes the orientation of the\n                surface. Under normal conditions it describes the\n                heading and terrain slope, which can be used by the\n                aircraft to adjust the approach. The approach 3D\n                vector describes the point to which the system should\n                fly in normal flight mode and then perform a landing\n                sequence along the vector.\n\n                target_system             : System ID. (uint8_t)\n                latitude                  : Latitude (WGS84), in degrees * 1E7 (int32_t)\n                longitude                 : Longitude (WGS84, in degrees * 1E7 (int32_t)\n                altitude                  : Altitude (AMSL), in meters * 1000 (positive for up) (int32_t)\n                x                         : Local X position of this position in the local coordinate frame (float)\n                y                         : Local Y position of this position in the local coordinate frame (float)\n                z                         : Local Z position of this position in the local coordinate frame (float)\n                q                         : World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground (float)\n                approach_x                : Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. (float)\n                approach_y                : Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. (float)\n                approach_z                : Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. (float)\n\n                '''\n                return MAVLink_set_home_position_message(target_system, latitude, longitude, altitude, x, y, z, q, approach_x, approach_y, approach_z)", "response": "This method sets the home position of the system to and land on."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the home position of the system.", "response": "def set_home_position_send(self, target_system, latitude, longitude, altitude, x, y, z, q, approach_x, approach_y, approach_z, force_mavlink1=False):\n                '''\n                The position the system will return to and land on. The position is\n                set automatically by the system during the takeoff in\n                case it was not explicitely set by the operator before\n                or after. The global and local positions encode the\n                position in the respective coordinate frames, while\n                the q parameter encodes the orientation of the\n                surface. Under normal conditions it describes the\n                heading and terrain slope, which can be used by the\n                aircraft to adjust the approach. The approach 3D\n                vector describes the point to which the system should\n                fly in normal flight mode and then perform a landing\n                sequence along the vector.\n\n                target_system             : System ID. (uint8_t)\n                latitude                  : Latitude (WGS84), in degrees * 1E7 (int32_t)\n                longitude                 : Longitude (WGS84, in degrees * 1E7 (int32_t)\n                altitude                  : Altitude (AMSL), in meters * 1000 (positive for up) (int32_t)\n                x                         : Local X position of this position in the local coordinate frame (float)\n                y                         : Local Y position of this position in the local coordinate frame (float)\n                z                         : Local Z position of this position in the local coordinate frame (float)\n                q                         : World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground (float)\n                approach_x                : Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. (float)\n                approach_y                : Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. (float)\n                approach_z                : Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. (float)\n\n                '''\n                return self.send(self.set_home_position_encode(target_system, latitude, longitude, altitude, x, y, z, q, approach_x, approach_y, approach_z), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef extended_sys_state_send(self, vtol_state, landed_state, force_mavlink1=False):\n                '''\n                Provides state for additional features\n\n                vtol_state                : The VTOL state if applicable. Is set to MAV_VTOL_STATE_UNDEFINED if UAV is not in VTOL configuration. (uint8_t)\n                landed_state              : The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown. (uint8_t)\n\n                '''\n                return self.send(self.extended_sys_state_encode(vtol_state, landed_state), force_mavlink1=force_mavlink1)", "response": "Provides state for additional features\n\n                vtol_state                : The VTOL state if applicable. Is set to MAV_VTOL_STATE_UNDEFINED if UAV is not in VTOL configuration. (uint8_t)\n                landed_state              : The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown. (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef adsb_vehicle_send(self, ICAO_address, lat, lon, altitude_type, altitude, heading, hor_velocity, ver_velocity, callsign, emitter_type, tslc, flags, squawk, force_mavlink1=False):\n                '''\n                The location and information of an ADSB vehicle\n\n                ICAO_address              : ICAO address (uint32_t)\n                lat                       : Latitude, expressed as degrees * 1E7 (int32_t)\n                lon                       : Longitude, expressed as degrees * 1E7 (int32_t)\n                altitude_type             : Type from ADSB_ALTITUDE_TYPE enum (uint8_t)\n                altitude                  : Altitude(ASL) in millimeters (int32_t)\n                heading                   : Course over ground in centidegrees (uint16_t)\n                hor_velocity              : The horizontal velocity in centimeters/second (uint16_t)\n                ver_velocity              : The vertical velocity in centimeters/second, positive is up (int16_t)\n                callsign                  : The callsign, 8+null (char)\n                emitter_type              : Type from ADSB_EMITTER_TYPE enum (uint8_t)\n                tslc                      : Time since last communication in seconds (uint8_t)\n                flags                     : Flags to indicate various statuses including valid data fields (uint16_t)\n                squawk                    : Squawk code (uint16_t)\n\n                '''\n                return self.send(self.adsb_vehicle_encode(ICAO_address, lat, lon, altitude_type, altitude, heading, hor_velocity, ver_velocity, callsign, emitter_type, tslc, flags, squawk), force_mavlink1=force_mavlink1)", "response": "This function sends the location and information of an ADSB vehicle."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef collision_send(self, src, id, action, threat_level, time_to_minimum_delta, altitude_minimum_delta, horizontal_minimum_delta, force_mavlink1=False):\n                '''\n                Information about a potential collision\n\n                src                       : Collision data source (uint8_t)\n                id                        : Unique identifier, domain based on src field (uint32_t)\n                action                    : Action that is being taken to avoid this collision (uint8_t)\n                threat_level              : How concerned the aircraft is about this collision (uint8_t)\n                time_to_minimum_delta        : Estimated time until collision occurs (seconds) (float)\n                altitude_minimum_delta        : Closest vertical distance in meters between vehicle and object (float)\n                horizontal_minimum_delta        : Closest horizontal distance in meteres between vehicle and object (float)\n\n                '''\n                return self.send(self.collision_encode(src, id, action, threat_level, time_to_minimum_delta, altitude_minimum_delta, horizontal_minimum_delta), force_mavlink1=force_mavlink1)", "response": "This message is used to indicate that a potential collision occurs."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nencode a V2 extension message.", "response": "def v2_extension_encode(self, target_network, target_system, target_component, message_type, payload):\n                '''\n                Message implementing parts of the V2 payload specs in V1 frames for\n                transitional support.\n\n                target_network            : Network ID (0 for broadcast) (uint8_t)\n                target_system             : System ID (0 for broadcast) (uint8_t)\n                target_component          : Component ID (0 for broadcast) (uint8_t)\n                message_type              : A code that identifies the software component that understands this message (analogous to usb device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase. (uint16_t)\n                payload                   : Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification. (uint8_t)\n\n                '''\n                return MAVLink_v2_extension_message(target_network, target_system, target_component, message_type, payload)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef v2_extension_send(self, target_network, target_system, target_component, message_type, payload, force_mavlink1=False):\n                '''\n                Message implementing parts of the V2 payload specs in V1 frames for\n                transitional support.\n\n                target_network            : Network ID (0 for broadcast) (uint8_t)\n                target_system             : System ID (0 for broadcast) (uint8_t)\n                target_component          : Component ID (0 for broadcast) (uint8_t)\n                message_type              : A code that identifies the software component that understands this message (analogous to usb device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase. (uint16_t)\n                payload                   : Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification. (uint8_t)\n\n                '''\n                return self.send(self.v2_extension_encode(target_network, target_system, target_component, message_type, payload), force_mavlink1=force_mavlink1)", "response": "Message implementing parts of the V2 payload specs in V1 frames for\n                transitional support.\n\n                target_network            : Network ID (0 for broadcast) (uint8_t)\n                target_system             : System ID (0 for broadcast) (uint8_t)\n                target_component          : Component ID (0 for broadcast) (uint8_t)\n                message_type              : A code that identifies the software component that understands this message (analogous to usb device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase. (uint16_t)\n                payload                   : Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification. (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output. address : Starting address of the debug variables (uint16_t) ver : Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below (uint8_t) type : Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14 (uint8_t) value : Memory contents at specified address (int8_t)", "response": "def memory_vect_encode(self, address, ver, type, value):\n                '''\n                Send raw controller memory. The use of this message is discouraged for\n                normal packets, but a quite efficient way for testing\n                new messages and getting experimental debug output.\n\n                address                   : Starting address of the debug variables (uint16_t)\n                ver                       : Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below (uint8_t)\n                type                      : Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14 (uint8_t)\n                value                     : Memory contents at specified address (int8_t)\n\n                '''\n                return MAVLink_memory_vect_message(address, ver, type, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output. address : Starting address of the debug variables (uint16_t) ver : Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below (uint8_t) type : Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14 (uint8_t) value : Memory contents at specified address (int8_t)", "response": "def memory_vect_send(self, address, ver, type, value, force_mavlink1=False):\n                '''\n                Send raw controller memory. The use of this message is discouraged for\n                normal packets, but a quite efficient way for testing\n                new messages and getting experimental debug output.\n\n                address                   : Starting address of the debug variables (uint16_t)\n                ver                       : Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below (uint8_t)\n                type                      : Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14 (uint8_t)\n                value                     : Memory contents at specified address (int8_t)\n\n                '''\n                return self.send(self.memory_vect_encode(address, ver, type, value), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a key-value pair as float. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output. time_boot_ms : Timestamp (milliseconds since system boot) (uint32_t) name : Name of the debug variable (char) value : Floating point value (float)", "response": "def named_value_float_send(self, time_boot_ms, name, value, force_mavlink1=False):\n                '''\n                Send a key-value pair as float. The use of this message is discouraged\n                for normal packets, but a quite efficient way for\n                testing new messages and getting experimental debug\n                output.\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                name                      : Name of the debug variable (char)\n                value                     : Floating point value (float)\n\n                '''\n                return self.send(self.named_value_float_encode(time_boot_ms, name, value), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef named_value_int_send(self, time_boot_ms, name, value, force_mavlink1=False):\n                '''\n                Send a key-value pair as integer. The use of this message is\n                discouraged for normal packets, but a quite efficient\n                way for testing new messages and getting experimental\n                debug output.\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                name                      : Name of the debug variable (char)\n                value                     : Signed integer value (int32_t)\n\n                '''\n                return self.send(self.named_value_int_encode(time_boot_ms, name, value), force_mavlink1=force_mavlink1)", "response": "This message is used to send a key - value pair as integer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef statustext_send(self, severity, text, force_mavlink1=False):\n                '''\n                Status text message. These messages are printed in yellow in the COMM\n                console of QGroundControl. WARNING: They consume quite\n                some bandwidth, so use only for important status and\n                error messages. If implemented wisely, these messages\n                are buffered on the MCU and sent only at a limited\n                rate (e.g. 10 Hz).\n\n                severity                  : Severity of status. Relies on the definitions within RFC-5424. See enum MAV_SEVERITY. (uint8_t)\n                text                      : Status text message, without null termination character (char)\n\n                '''\n                return self.send(self.statustext_encode(severity, text), force_mavlink1=force_mavlink1)", "response": "Status text message. These messages are printed in yellow in the COMM\n                console of QGroundControl. WARNING: They consume quite\n                some bandwidth, so use only for important status and\n                error messages. If implemented wisely, these messages\n                are buffered on the MCU and sent only at a limited\n                rate (e.g. 10 Hz).\n\n                severity                  : Severity of status. Relies on the definitions within RFC-5424. See enum MAV_SEVERITY. (uint8_t)\n                text                      : Status text message, without null termination character (char)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef debug_send(self, time_boot_ms, ind, value, force_mavlink1=False):\n                '''\n                Send a debug value. The index is used to discriminate between values.\n                These values show up in the plot of QGroundControl as\n                DEBUG N.\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                ind                       : index of debug variable (uint8_t)\n                value                     : DEBUG value (float)\n\n                '''\n                return self.send(self.debug_encode(time_boot_ms, ind, value), force_mavlink1=force_mavlink1)", "response": "Send a debug value. The index is used to discriminate between values.\n                These values show up in the plot of QGroundControl as\n                DEBUG N.\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                ind                       : index of debug variable (uint8_t)\n                value                     : DEBUG value (float)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef accumulate(self, buf):\n        '''add in some more bytes'''\n        accum = self.crc\n        for b in buf:\n            tmp = b ^ (accum & 0xff)\n            tmp = (tmp ^ (tmp<<4)) & 0xFF\n            accum = (accum>>8) ^ (tmp<<8) ^ (tmp<<3) ^ (tmp>>4)\n        self.crc = accum", "response": "add in some more bytes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef accumulate_str(self, buf):\n        '''add in some more bytes'''\n        accum = self.crc\n        import array\n        bytes = array.array('B')\n        bytes.fromstring(buf)\n        self.accumulate(bytes)", "response": "add in some more bytes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the internal state of the LaserData.", "response": "def update(self):\n        '''\n        Updates LaserData.\n        '''\n        if self.hasproxy():\n            irD = IRData()\n            received = 0\n            data = self.proxy.getIRData()\n\n            irD.received = data.received\n\n            self.lock.acquire()\n            self.ir = irD\n            self.lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning last LaserData. Returns last LaserData. Returns last LaserData. Returns last LaserData. Returns last LaserData. Returns last LaserData. Returns None", "response": "def getIRData(self):\n        '''\n        Returns last LaserData. \n\n        @return last JdeRobotTypes LaserData saved\n\n        '''     \n        if self.hasproxy():\n            self.lock.acquire()\n            ir = self.ir\n            self.lock.release()\n            return ir\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction to publish cmdvel.", "response": "def publish (self):\n        '''\n        Function to publish cmdvel. \n        '''\n        self.lock.acquire()\n        tw = cmdvel2Twist(self.data)\n        self.lock.release()\n        self.pub.publish(tw)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sendVelocities(self, vel):\n        '''\n        Sends CMDVel.\n\n        @param vel: CMDVel to publish\n        \n        @type vel: CMDVel\n\n        '''\n        self.lock.acquire()\n        self.data = vel\n        self.lock.release()", "response": "Sends a set of velocities to the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sendVX(self, vx):\n        '''\n        Sends VX velocity.\n\n        @param vx: VX velocity\n        \n        @type vx: float\n\n        '''\n        self.lock.acquire()\n        self.data.vx = vx\n        self.lock.release()", "response": "Sends the specified VX velocity to the current thread."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend VY velocity. @param vy: VY velocity @type vy: float", "response": "def sendVY(self, vy):\n        '''\n        Sends VY velocity.\n\n        @param vy: VY velocity\n        \n        @type vy: float\n\n        '''\n        self.lock.acquire()\n        self.data.vy = vy\n        self.lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend the AZ velocity.", "response": "def sendAZ(self, az):\n        '''\n        Sends AZ velocity.\n\n        @param az: AZ velocity\n        \n        @type az: float\n\n        '''\n        self.lock.acquire()\n        self.data.az = az\n        self.lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bumperEvent2BumperData(event):\n    '''\n    Translates from ROS BumperScan to JderobotTypes BumperData. \n\n    @param event: ROS BumperScan to translate\n\n    @type event: BumperScan\n\n    @return a BumperData translated from event\n\n    # bumper\n    LEFT   = 0\n    CENTER = 1\n    RIGHT  = 2\n\n    #  state\n    RELEASED = 0\n    PRESSED  = 1\n\n    '''\n    bump = BumperData()\n    bump.state = event.state\n    bump.bumper = event.bumper\n    \n    #bump.timeStamp = event.header.stamp.secs + (event.header.stamp.nsecs *1e-9)\n    return bump", "response": "Translate a ROS BumperScan to JderobotTypes BumperData. \n"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __callback (self, event):\n        '''\n        Callback function to receive and save Bumper Scans. \n\n        @param event: ROS BumperScan received\n        \n        @type event: BumperScan\n\n        '''\n        bump = bumperEvent2BumperData(event)\n\n        if bump.state == 1:\n            self.lock.acquire()\n            self.time = current_milli_time()\n            self.data = bump\n            self.lock.release()", "response": "Callback function to receive and save Bumper Scans. \n\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting (Subscribes) the client.", "response": "def start (self):\n        '''\n        Starts (Subscribes) the client.\n\n        '''\n        self.sub = rospy.Subscriber(self.topic, BumperEvent, self.__callback)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getBumperData(self):\n        '''\n        Returns last BumperData. \n\n        @return last JdeRobotTypes BumperData saved\n\n        '''\n        self.lock.acquire()\n        t = current_milli_time()\n        if (t - self.time) > 500:\n            self.data.state = 0\n        bump = self.data\n        self.lock.release()\n        \n        return bump", "response": "Returns last BumperData. \n\n        Returns last BumperData. \n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles a mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle a mavlink packet'''\n        mtype = m.get_type()\n        if mtype == \"SYS_STATUS\":\n            self.battery_update(m)\n        if mtype == \"BATTERY2\":\n            self.battery2_voltage = m.voltage * 0.001\n        if mtype == \"POWER_STATUS\":\n            self.power_status_update(m)\n        if self.battery_period.trigger():\n            self.battery_report()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getImage(self):\n        '''\n        Returns last Image. \n\n        @return last JdeRobotTypes Image saved\n\n        '''\n        img = Image()      \n        if self.hasproxy():\n            self.lock.acquire()\n            img = self.image\n            self.lock.release()\n        return img", "response": "Returns last JdeRobotTypes Image. \n\n        Returns last JdeRobotTypes Image. \n\n        Returns last JdeRobotTypes Image. \n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndoes a full 3D accel calibration", "response": "def cmd_accelcal(self, args):\n        '''do a full 3D accel calibration'''\n        mav = self.master\n        # ack the APM to begin 3D calibration of accelerometers\n        mav.mav.command_long_send(mav.target_system, mav.target_component,\n                                  mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION, 0,\n                                  0, 0, 0, 0, 1, 0, 0)\n        self.accelcal_count = 0\n        self.accelcal_wait_enter = False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_gyrocal(self, args):\n        '''do a full gyro calibration'''\n        mav = self.master\n        mav.mav.command_long_send(mav.target_system, mav.target_component,\n                                  mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION, 0,\n                                  1, 0, 0, 0, 0, 0, 0)", "response": "do a full gyro calibration"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_compassmot(self, args):\n        '''do a compass/motor interference calibration'''\n        mav = self.master\n        print(\"compassmot starting\")\n        mav.mav.command_long_send(mav.target_system, mav.target_component,\n                                  mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION, 0,\n                                  0, 0, 0, 0, 0, 1, 0)\n        self.compassmot_running = True\n        self.empty_input_count = self.mpstate.empty_input_count", "response": "do a compass interference calibration"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nenables or disable fence", "response": "def set_fence_enabled(self, do_enable):\n        '''Enable or disable fence'''\n        self.master.mav.command_long_send(\n            self.target_system,\n            self.target_component,\n            mavutil.mavlink.MAV_CMD_DO_FENCE_ENABLE, 0,\n            do_enable, 0, 0, 0, 0, 0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_fence(self):\n        '''send fence points from fenceloader'''\n        # must disable geo-fencing when loading\n        self.fenceloader.target_system = self.target_system\n        self.fenceloader.target_component = self.target_component\n        self.fenceloader.reindex()\n        action = self.get_mav_param('FENCE_ACTION', mavutil.mavlink.FENCE_ACTION_NONE)\n        self.param_set('FENCE_ACTION', mavutil.mavlink.FENCE_ACTION_NONE, 3)\n        self.param_set('FENCE_TOTAL', self.fenceloader.count(), 3)\n        for i in range(self.fenceloader.count()):\n            p = self.fenceloader.point(i)\n            self.master.mav.send(p)\n            p2 = self.fetch_fence_point(i)\n            if p2 is None:\n                self.param_set('FENCE_ACTION', action, 3)\n                return False\n            if (p.idx != p2.idx or\n                abs(p.lat - p2.lat) >= 0.00003 or\n                abs(p.lng - p2.lng) >= 0.00003):\n                print(\"Failed to send fence point %u\" % i)\n                self.param_set('FENCE_ACTION', action, 3)\n                return False\n        self.param_set('FENCE_ACTION', action, 3)\n        return True", "response": "send fence points from fenceloader"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch_fence_point(self ,i):\n        '''fetch one fence point'''\n        self.master.mav.fence_fetch_point_send(self.target_system,\n                                                    self.target_component, i)\n        tstart = time.time()\n        p = None\n        while time.time() - tstart < 3:\n            p = self.master.recv_match(type='FENCE_POINT', blocking=False)\n            if p is not None:\n                break\n            time.sleep(0.1)\n            continue\n        if p is None:\n            self.console.error(\"Failed to fetch point %u\" % i)\n            return None\n        return p", "response": "fetch one fence point"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_menu(self, menu):\n        '''add a new menu'''\n        self.menu.add(menu)\n        self.mpstate.console.set_menu(self.menu, self.menu_callback)", "response": "add a new menu"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef menu_callback(self, m):\n        '''called on menu selection'''\n        if m.returnkey.startswith('# '):\n            cmd = m.returnkey[2:]\n            if m.handler is not None:\n                if m.handler_result is None:\n                    return\n                cmd += m.handler_result\n            self.mpstate.functions.process_stdin(cmd)\n        if m.returnkey == 'menuSettings':\n            wxsettings.WXSettings(self.settings)", "response": "called on menu selection"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef estimated_time_remaining(self, lat, lon, wpnum, speed):\n        '''estimate time remaining in mission in seconds'''\n        idx = wpnum\n        if wpnum >= self.module('wp').wploader.count():\n            return 0\n        distance = 0\n        done = set()\n        while idx < self.module('wp').wploader.count():\n            if idx in done:\n                break\n            done.add(idx)\n            w = self.module('wp').wploader.wp(idx)\n            if w.command == mavutil.mavlink.MAV_CMD_DO_JUMP:\n                idx = int(w.param1)\n                continue\n            idx += 1\n            if (w.x != 0 or w.y != 0) and w.command in [mavutil.mavlink.MAV_CMD_NAV_WAYPOINT,\n                                                        mavutil.mavlink.MAV_CMD_NAV_LOITER_UNLIM,\n                                                        mavutil.mavlink.MAV_CMD_NAV_LOITER_TURNS,\n                                                        mavutil.mavlink.MAV_CMD_NAV_LOITER_TIME,\n                                                        mavutil.mavlink.MAV_CMD_NAV_LAND,\n                                                        mavutil.mavlink.MAV_CMD_NAV_TAKEOFF]:\n                distance += mp_util.gps_distance(lat, lon, w.x, w.y)\n                lat = w.x\n                lon = w.y\n                if w.command == mavutil.mavlink.MAV_CMD_NAV_LAND:\n                    break\n        return distance / speed", "response": "estimate time remaining in mission in seconds"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mavlink_packet(self, msg):\n        '''handle an incoming mavlink packet'''\n        if not isinstance(self.console, wxconsole.MessageConsole):\n            return\n        if not self.console.is_alive():\n            self.mpstate.console = textconsole.SimpleConsole()\n            return\n        type = msg.get_type()\n\n        master = self.master\n        # add some status fields\n        if type in [ 'GPS_RAW', 'GPS_RAW_INT' ]:\n            if type == \"GPS_RAW\":\n                num_sats1 = master.field('GPS_STATUS', 'satellites_visible', 0)\n            else:\n                num_sats1 = msg.satellites_visible\n            num_sats2 = master.field('GPS2_RAW', 'satellites_visible', -1)\n            if num_sats2 == -1:\n                sats_string = \"%u\" % num_sats1\n            else:\n                sats_string = \"%u/%u\" % (num_sats1, num_sats2)\n            if ((msg.fix_type == 3 and master.mavlink10()) or\n                (msg.fix_type == 2 and not master.mavlink10())):\n                self.console.set_status('GPS', 'GPS: OK (%s)' % sats_string, fg='green')\n            else:\n                self.console.set_status('GPS', 'GPS: %u (%s)' % (msg.fix_type, sats_string), fg='red')\n            if master.mavlink10():\n                gps_heading = int(self.mpstate.status.msgs['GPS_RAW_INT'].cog * 0.01)\n            else:\n                gps_heading = self.mpstate.status.msgs['GPS_RAW'].hdg\n            self.console.set_status('Heading', 'Hdg %s/%u' % (master.field('VFR_HUD', 'heading', '-'), gps_heading))\n        elif type == 'VFR_HUD':\n            if master.mavlink10():\n                alt = master.field('GPS_RAW_INT', 'alt', 0) / 1.0e3\n            else:\n                alt = master.field('GPS_RAW', 'alt', 0)\n            if self.module('wp').wploader.count() > 0:\n                wp = self.module('wp').wploader.wp(0)\n                home_lat = wp.x\n                home_lng = wp.y\n            else:\n                home_lat = master.field('HOME', 'lat') * 1.0e-7\n                home_lng = master.field('HOME', 'lon') * 1.0e-7\n            lat = master.field('GLOBAL_POSITION_INT', 'lat', 0) * 1.0e-7\n            lng = master.field('GLOBAL_POSITION_INT', 'lon', 0) * 1.0e-7\n            rel_alt = master.field('GLOBAL_POSITION_INT', 'relative_alt', 0) * 1.0e-3\n            agl_alt = None\n            if self.settings.basealt != 0:\n                agl_alt = self.console.ElevationMap.GetElevation(lat, lng)\n                if agl_alt is not None:\n                    agl_alt = self.settings.basealt - agl_alt\n            else:\n                try:\n                    agl_alt_home = self.console.ElevationMap.GetElevation(home_lat, home_lng)\n                except Exception as ex:\n                    print(ex)\n                    agl_alt_home = None\n                if agl_alt_home is not None:\n                    agl_alt = self.console.ElevationMap.GetElevation(lat, lng)\n                if agl_alt is not None:\n                    agl_alt = agl_alt_home - agl_alt\n            if agl_alt is not None:\n                agl_alt += rel_alt\n                vehicle_agl = master.field('TERRAIN_REPORT', 'current_height', None)\n                if vehicle_agl is None:\n                    vehicle_agl = '---'\n                else:\n                    vehicle_agl = int(vehicle_agl)\n                self.console.set_status('AGL', 'AGL %u/%s' % (agl_alt, vehicle_agl))\n            self.console.set_status('Alt', 'Alt %u' % rel_alt)\n            self.console.set_status('AirSpeed', 'AirSpeed %u' % msg.airspeed)\n            self.console.set_status('GPSSpeed', 'GPSSpeed %u' % msg.groundspeed)\n            self.console.set_status('Thr', 'Thr %u' % msg.throttle)\n            t = time.localtime(msg._timestamp)\n            flying = False\n            if self.mpstate.vehicle_type == 'copter':\n                flying = self.master.motors_armed()\n            else:\n                flying = msg.groundspeed > 3\n            if flying and not self.in_air:\n                self.in_air = True\n                self.start_time = time.mktime(t)\n            elif flying and self.in_air:\n                self.total_time = time.mktime(t) - self.start_time\n                self.console.set_status('FlightTime', 'FlightTime %u:%02u' % (int(self.total_time)/60, int(self.total_time)%60))\n            elif not flying and self.in_air:\n                self.in_air = False\n                self.total_time = time.mktime(t) - self.start_time\n                self.console.set_status('FlightTime', 'FlightTime %u:%02u' % (int(self.total_time)/60, int(self.total_time)%60))\n        elif type == 'ATTITUDE':\n            self.console.set_status('Roll', 'Roll %u' % math.degrees(msg.roll))\n            self.console.set_status('Pitch', 'Pitch %u' % math.degrees(msg.pitch))\n        elif type in ['SYS_STATUS']:\n            sensors = { 'AS'   : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE,\n                        'MAG'  : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_3D_MAG,\n                        'INS'  : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_3D_ACCEL | mavutil.mavlink.MAV_SYS_STATUS_SENSOR_3D_GYRO,\n                        'AHRS' : mavutil.mavlink.MAV_SYS_STATUS_AHRS,\n                        'RC'   : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_RC_RECEIVER,\n                        'TERR' : mavutil.mavlink.MAV_SYS_STATUS_TERRAIN,\n                        'RNG'  : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_LASER_POSITION}\n            announce = [ 'RC' ]\n            for s in sensors.keys():\n                bits = sensors[s]\n                present = ((msg.onboard_control_sensors_enabled & bits) == bits)\n                healthy = ((msg.onboard_control_sensors_health & bits) == bits)\n                if not present:\n                    fg = 'grey'\n                elif not healthy:\n                    fg = 'red'\n                else:\n                    fg = 'green'\n                # for terrain show yellow if still loading\n                if s == 'TERR' and fg == 'green' and master.field('TERRAIN_REPORT', 'pending', 0) != 0:\n                    fg = 'yellow'\n                self.console.set_status(s, s, fg=fg)\n            for s in announce:\n                bits = sensors[s]\n                present = ((msg.onboard_control_sensors_enabled & bits) == bits)\n                healthy = ((msg.onboard_control_sensors_health & bits) == bits)\n                was_healthy = ((self.last_sys_status_health & bits) == bits)\n                if present and not healthy and was_healthy:\n                    self.say(\"%s fail\" % s)\n            self.last_sys_status_health = msg.onboard_control_sensors_health\n\n        elif type == 'WIND':\n            self.console.set_status('Wind', 'Wind %u/%.2f' % (msg.direction, msg.speed))\n\n        elif type == 'EKF_STATUS_REPORT':\n            highest = 0.0\n            vars = ['velocity_variance',\n                    'pos_horiz_variance',\n                    'pos_vert_variance',\n                    'compass_variance',\n                    'terrain_alt_variance']\n            for var in vars:\n                v = getattr(msg, var, 0)\n                highest = max(v, highest)\n            if highest >= 1.0:\n                fg = 'red'\n            elif highest >= 0.5:\n                fg = 'orange'\n            else:\n                fg = 'green'\n            self.console.set_status('EKF', 'EKF', fg=fg)\n\n        elif type == 'HWSTATUS':\n            if msg.Vcc >= 4600 and msg.Vcc <= 5300:\n                fg = 'green'\n            else:\n                fg = 'red'\n            self.console.set_status('Vcc', 'Vcc %.2f' % (msg.Vcc * 0.001), fg=fg)\n        elif type == 'POWER_STATUS':\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_CHANGED:\n                fg = 'red'\n            else:\n                fg = 'green'\n            status = 'PWR:'\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_USB_CONNECTED:\n                status += 'U'\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_BRICK_VALID:\n                status += 'B'\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_SERVO_VALID:\n                status += 'S'\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_PERIPH_OVERCURRENT:\n                status += 'O1'\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT:\n                status += 'O2'\n            self.console.set_status('PWR', status, fg=fg)\n            self.console.set_status('Srv', 'Srv %.2f' % (msg.Vservo*0.001), fg='green')\n        elif type in ['RADIO', 'RADIO_STATUS']:\n            if msg.rssi < msg.noise+10 or msg.remrssi < msg.remnoise+10:\n                fg = 'red'\n            else:\n                fg = 'black'\n            self.console.set_status('Radio', 'Radio %u/%u %u/%u' % (msg.rssi, msg.noise, msg.remrssi, msg.remnoise), fg=fg)\n        elif type == 'HEARTBEAT':\n            self.console.set_status('Mode', '%s' % master.flightmode, fg='blue')\n            if self.master.motors_armed():\n                arm_colour = 'green'\n            else:\n                arm_colour = 'red'\n            self.console.set_status('ARM', 'ARM', fg=arm_colour)\n            if self.max_link_num != len(self.mpstate.mav_master):\n                for i in range(self.max_link_num):\n                    self.console.set_status('Link%u'%(i+1), '', row=1)\n                self.max_link_num = len(self.mpstate.mav_master)\n            for m in self.mpstate.mav_master:\n                linkdelay = (self.mpstate.status.highest_msec - m.highest_msec)*1.0e-3\n                linkline = \"Link %u \" % (m.linknum+1)\n                if m.linkerror:\n                    linkline += \"down\"\n                    fg = 'red'\n                else:\n                    packets_rcvd_percentage = 100\n                    if (m.mav_loss != 0): #avoid divide-by-zero\n                        packets_rcvd_percentage = (1.0 - (float(m.mav_loss) / float(m.mav_count))) * 100.0\n\n                    linkline += \"OK (%u pkts, %.2fs delay, %u lost) %u%%\" % (m.mav_count, linkdelay, m.mav_loss, packets_rcvd_percentage)\n                    if linkdelay > 1:\n                        fg = 'orange'\n                    else:\n                        fg = 'dark green'\n                self.console.set_status('Link%u'%m.linknum, linkline, row=1, fg=fg)\n        elif type in ['WAYPOINT_CURRENT', 'MISSION_CURRENT']:\n            self.console.set_status('WP', 'WP %u' % msg.seq)\n            lat = master.field('GLOBAL_POSITION_INT', 'lat', 0) * 1.0e-7\n            lng = master.field('GLOBAL_POSITION_INT', 'lon', 0) * 1.0e-7\n            if lat != 0 and lng != 0:\n                airspeed = master.field('VFR_HUD', 'airspeed', 30)\n                if abs(airspeed - self.speed) > 5:\n                    self.speed = airspeed\n                else:\n                    self.speed = 0.98*self.speed + 0.02*airspeed\n                self.speed = max(1, self.speed)\n                time_remaining = int(self.estimated_time_remaining(lat, lng, msg.seq, self.speed))\n                self.console.set_status('ETR', 'ETR %u:%02u' % (time_remaining/60, time_remaining%60))\n\n        elif type == 'NAV_CONTROLLER_OUTPUT':\n            self.console.set_status('WPDist', 'Distance %u' % msg.wp_dist)\n            self.console.set_status('WPBearing', 'Bearing %u' % msg.target_bearing)\n            if msg.alt_error > 0:\n                alt_error_sign = \"L\"\n            else:\n                alt_error_sign = \"H\"\n            if msg.aspd_error > 0:\n                aspd_error_sign = \"L\"\n            else:\n                aspd_error_sign = \"H\"\n            self.console.set_status('AltError', 'AltError %d%s' % (msg.alt_error, alt_error_sign))\n            self.console.set_status('AspdError', 'AspdError %.1f%s' % (msg.aspd_error*0.01, aspd_error_sign))", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef angle(self, v):\n        '''return the angle between this vector and another vector'''\n        return acos((self * v) / (self.length() * v.length()))", "response": "return the angle between this vector and another vector"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfill the matrix from Euler angles in radians", "response": "def from_euler(self, roll, pitch, yaw):\n        '''fill the matrix from Euler angles in radians'''\n        cp = cos(pitch)\n        sp = sin(pitch)\n        sr = sin(roll)\n        cr = cos(roll)\n        sy = sin(yaw)\n        cy = cos(yaw)\n\n        self.a.x = cp * cy\n        self.a.y = (sr * sp * cy) - (cr * sy)\n        self.a.z = (cr * sp * cy) + (sr * sy)\n        self.b.x = cp * sy\n        self.b.y = (sr * sp * sy) + (cr * cy)\n        self.b.z = (cr * sp * sy) - (sr * cy)\n        self.c.x = -sp\n        self.c.y = sr * cp\n        self.c.z = cr * cp"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_euler(self):\n        '''find Euler angles (321 convention) for the matrix'''\n        if self.c.x >= 1.0:\n            pitch = pi\n        elif self.c.x <= -1.0:\n            pitch = -pi\n        else:\n            pitch = -asin(self.c.x)\n        roll = atan2(self.c.y, self.c.z)\n        yaw  = atan2(self.b.x, self.a.x)\n        return (roll, pitch, yaw)", "response": "find Euler angles for the matrix"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_euler312(self):\n        '''find Euler angles (312 convention) for the matrix.\n        See http://www.atacolorado.com/eulersequences.doc\n        '''\n        T21 = self.a.y\n        T22 = self.b.y\n        T23 = self.c.y\n        T13 = self.c.x\n        T33 = self.c.z\n        yaw = atan2(-T21, T22)\n        roll = asin(T23)\n        pitch = atan2(-T13, T33)\n        return (roll, pitch, yaw)", "response": "convert the matrix to Euler angles"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_euler312(self, roll, pitch, yaw):\n        '''fill the matrix from Euler angles in radians in 312 convention'''\n        c3 = cos(pitch)\n        s3 = sin(pitch)\n        s2 = sin(roll)\n        c2 = cos(roll)\n        s1 = sin(yaw)\n        c1 = cos(yaw)\n\n        self.a.x = c1 * c3 - s1 * s2 * s3\n        self.b.y = c1 * c2\n        self.c.z = c3 * c2\n        self.a.y = -c2*s1\n        self.a.z = s3*c1 + c3*s2*s1\n        self.b.x = c3*s1 + s3*s2*c1\n        self.b.z = s1*s3 - s2*c1*c3\n        self.c.x = -s3*c2\n        self.c.y = s2", "response": "fill the matrix from Euler angles in radians in 312 convention"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrotate the matrix by a given amount on 3 axes", "response": "def rotate(self, g):\n        '''rotate the matrix by a given amount on 3 axes'''\n        temp_matrix = Matrix3()\n        a = self.a\n        b = self.b\n        c = self.c\n        temp_matrix.a.x = a.y * g.z - a.z * g.y\n        temp_matrix.a.y = a.z * g.x - a.x * g.z\n        temp_matrix.a.z = a.x * g.y - a.y * g.x\n        temp_matrix.b.x = b.y * g.z - b.z * g.y\n        temp_matrix.b.y = b.z * g.x - b.x * g.z\n        temp_matrix.b.z = b.x * g.y - b.y * g.x\n        temp_matrix.c.x = c.y * g.z - c.z * g.y\n        temp_matrix.c.y = c.z * g.x - c.x * g.z\n        temp_matrix.c.z = c.x * g.y - c.y * g.x\n        self.a += temp_matrix.a\n        self.b += temp_matrix.b\n        self.c += temp_matrix.c"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef trace(self):\n        '''the trace of the matrix'''\n        return self.a.x + self.b.y + self.c.z", "response": "the trace of the matrix"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_axis_angle(self, axis, angle):\n        '''create a rotation matrix from axis and angle'''\n        ux = axis.x\n        uy = axis.y\n        uz = axis.z\n        ct = cos(angle)\n        st = sin(angle)\n        self.a.x = ct + (1-ct) * ux**2\n        self.a.y = ux*uy*(1-ct) - uz*st\n        self.a.z = ux*uz*(1-ct) + uy*st\n        self.b.x = uy*ux*(1-ct) + uz*st\n        self.b.y = ct + (1-ct) * uy**2\n        self.b.z = uy*uz*(1-ct) - ux*st\n        self.c.x = uz*ux*(1-ct) - uy*st\n        self.c.y = uz*uy*(1-ct) + ux*st\n        self.c.z = ct + (1-ct) * uz**2", "response": "create a rotation matrix from axis and angle"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a rotation matrix from two vectors. vec1 and vec2 This returns a rotation matrix which when applied to vec1 and vec2 will produce a vector pointing in the same direction as vec2", "response": "def from_two_vectors(self, vec1, vec2):\n        '''get a rotation matrix from two vectors.\n           This returns a rotation matrix which when applied to vec1\n           will produce a vector pointing in the same direction as vec2'''\n        angle = vec1.angle(vec2)\n        cross = vec1 % vec2\n        if cross.length() == 0:\n            # the two vectors are colinear\n            return self.from_euler(0,0,angle)\n        cross.normalize()\n        return self.from_axis_angle(cross, angle)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef plane_intersection(self, plane, forward_only=False):\n        '''return point where line intersects with a plane'''\n        l_dot_n = self.vector * plane.normal\n        if l_dot_n == 0.0:\n            # line is parallel to the plane\n            return None\n        d = ((plane.point - self.point) * plane.normal) / l_dot_n\n        if forward_only and d < 0:\n            return None\n        return (self.vector * d) + self.point", "response": "return point where line intersects with a plane"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getRgbd(self):\n        '''\n        Returns last Rgbd. \n\n        @return last JdeRobotTypes Rgbd saved\n\n        '''\n        img = Rgb()      \n        if self.hasproxy():\n            self.lock.acquire()\n            img = self.image\n            self.lock.release()\n        return img", "response": "Returns last Rgbd. \n\n        Returns last Rgbd. \n\n        Returns last Rgbd. \n\n        Returns last Rgbd. \n\n        Returns last Rgbd. \n\n        Returns last Rgbd. \n\n        Returns last Rgbd. \n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef idle_task(self):\n        '''called in idle time'''\n        try:\n            data = self.port.recv(200)\n        except socket.error as e:\n            if e.errno in [ errno.EAGAIN, errno.EWOULDBLOCK ]:\n                return\n            raise\n        if len(data) > 110:\n            print(\"DGPS data too large: %u bytes\" % len(data))\n            return\n        try:\n\n            self.master.mav.gps_inject_data_send(\n                self.target_system,\n                self.target_component,\n                len(data),\n                bytearray(data.ljust(110, '\\0')))\n\n        except Exception(e):\n            print (\"DGPS Failed:\", e)", "response": "called in idle time"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling an incoming mavlink packet", "response": "def mavlink_packet(self, msg):\n        '''handle an incoming mavlink packet'''\n\n        # check for any closed graphs\n        for i in range(len(self.graphs) - 1, -1, -1):\n            if not self.graphs[i].is_alive():\n                self.graphs[i].close()\n                self.graphs.pop(i)\n\n        # add data to the rest\n        for g in self.graphs:\n            g.add_mavlink_packet(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding data to the graph", "response": "def add_mavlink_packet(self, msg):\n        '''add data to the graph'''\n        mtype = msg.get_type()\n        if mtype not in self.msg_types:\n            return\n        for i in range(len(self.fields)):\n            if mtype not in self.field_types[i]:\n                continue\n            f = self.fields[i]\n            self.values[i] = mavutil.evaluate_expression(f, self.state.master.messages)\n        if self.livegraph is not None:\n            self.livegraph.add_values(self.values)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates the implementations of the classes representing the MAVLink messages.", "response": "def generate_classes(outf, msgs):\n    \"\"\"\n    Generate the implementations of the classes representing MAVLink messages.\n\n    \"\"\"\n    print(\"Generating class definitions\")\n    wrapper = textwrap.TextWrapper(initial_indent=\"\", subsequent_indent=\"\")\n    outf.write(\"\\nmavlink.messages = {};\\n\\n\");\n\n    def field_descriptions(fields):\n        ret = \"\"\n        for f in fields:\n            ret += \"                %-18s        : %s (%s)\\n\" % (f.name, f.description.strip(), f.type)\n        return ret\n\n    for m in msgs:\n\n        comment = \"%s\\n\\n%s\" % (wrapper.fill(m.description.strip()), field_descriptions(m.fields))\n\n        selffieldnames = 'self, '\n        for f in m.fields:\n            # if f.omit_arg:\n            #    selffieldnames += '%s=%s, ' % (f.name, f.const_value)\n            #else:\n            # -- Omitting the code above because it is rarely used (only once?) and would need some special handling\n            # in javascript.  Specifically, inside the method definition, it needs to check for a value then assign\n            # a default.\n            selffieldnames += '%s, ' % f.name\n        selffieldnames = selffieldnames[:-2]\n\n        sub = {'NAMELOWER'      : m.name.lower(),\n               'SELFFIELDNAMES' : selffieldnames,\n               'COMMENT'        : comment,\n               'FIELDNAMES'     : \", \".join(m.fieldnames)}\n\n        t.write(outf, \"\"\"\n/* \n${COMMENT}\n*/\n\"\"\", sub)\n\n        # function signature + declaration\n        outf.write(\"mavlink.messages.%s = function(\" % (m.name.lower()))\n        if len(m.fields) != 0:\n                outf.write(\", \".join(m.fieldnames))\n        outf.write(\") {\")\n\n        # body: set message type properties    \n        outf.write(\"\"\"\n\n    this.format = '%s';\n    this.id = mavlink.MAVLINK_MSG_ID_%s;\n    this.order_map = %s;\n    this.crc_extra = %u;\n    this.name = '%s';\n\n\"\"\" % (m.fmtstr, m.name.upper(), m.order_map, m.crc_extra, m.name.upper()))\n        \n        # body: set own properties\n        if len(m.fieldnames) != 0:\n                outf.write(\"    this.fieldnames = ['%s'];\\n\" % \"', '\".join(m.fieldnames))\n        outf.write(\"\"\"\n\n    this.set(arguments);\n\n}\n        \"\"\")\n\n        # inherit methods from the base message class\n        outf.write(\"\"\"\nmavlink.messages.%s.prototype = new mavlink.message;\n\"\"\" % m.name.lower())\n\n        # Implement the pack() function for this message\n        outf.write(\"\"\"\nmavlink.messages.%s.prototype.pack = function(mav) {\n    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format\"\"\" % m.name.lower())\n        if len(m.fields) != 0:\n                outf.write(\", [ this.\" + \", this.\".join(m.ordered_fieldnames) + ']')\n        outf.write(\"));\\n}\\n\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mavfmt(field):\n    '''work out the struct format for a type'''\n    map = {\n        'float'    : 'f',\n        'double'   : 'd',\n        'char'     : 'c',\n        'int8_t'   : 'b',\n        'uint8_t'  : 'B',\n        'uint8_t_mavlink_version'  : 'B',\n        'int16_t'  : 'h',\n        'uint16_t' : 'H',\n        'int32_t'  : 'i',\n        'uint32_t' : 'I',\n        'int64_t'  : 'q',\n        'uint64_t' : 'Q',\n        }\n\n    if field.array_length:\n        if field.type in ['char', 'int8_t', 'uint8_t']:\n            return str(field.array_length)+'s'\n        return str(field.array_length)+map[field.type]\n    return map[field.type]", "response": "work out the struct format for a type"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate(basename, xml):\n    '''generate complete javascript implementation'''\n\n    if basename.endswith('.js'):\n        filename = basename\n    else:\n        filename = basename + '.js'\n\n    msgs = []\n    enums = []\n    filelist = []\n    for x in xml:\n        msgs.extend(x.message)\n        enums.extend(x.enum)\n        filelist.append(os.path.basename(x.filename))\n\n    for m in msgs:\n        if xml[0].little_endian:\n            m.fmtstr = '<'\n        else:\n            m.fmtstr = '>'\n        for f in m.ordered_fields:\n            m.fmtstr += mavfmt(f)\n        m.order_map = [ 0 ] * len(m.fieldnames)\n        for i in range(0, len(m.fieldnames)):\n            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])\n\n    print(\"Generating %s\" % filename)\n    outf = open(filename, \"w\")\n    generate_preamble(outf, msgs, filelist, xml[0])\n    generate_enums(outf, enums)\n    generate_message_ids(outf, msgs)\n    generate_classes(outf, msgs)\n    generate_mavlink_class(outf, msgs, xml[0])\n    generate_footer(outf)\n    outf.close()\n    print(\"Generated %s OK\" % filename)", "response": "generate complete javascript implementation"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef child_task(self, q, l, gq, gl):\n        '''child process - this holds GUI elements'''\n        mp_util.child_close_fds()\n\n        from ..lib import wx_processguard\n        from ..lib.wx_loader import wx\n        from MAVProxy.modules.mavproxy_misseditor import missionEditorFrame\n        \n        self.app = wx.App(False)\n        self.app.frame = missionEditorFrame.MissionEditorFrame(parent=None,id=wx.ID_ANY)\n\n        self.app.frame.set_event_queue(q)\n        self.app.frame.set_event_queue_lock(l)\n        self.app.frame.set_gui_event_queue(gq)\n        self.app.frame.set_gui_event_queue_lock(gl)\n\n        self.app.frame.Show()\n        self.app.MainLoop()", "response": "child process - this holds GUI elements"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose the Mission Editor window", "response": "def close(self):\n        '''close the Mission Editor window'''\n        self.close_window.set()\n        if self.child.is_alive():\n            self.child.join(1)\n\n        self.child.terminate()\n\n        self.event_queue_lock.acquire()\n        self.event_queue.put(MissionEditorEvent(me_event.MEE_TIME_TO_QUIT));\n        self.event_queue_lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __vCmdConnectCameras(self, args):\n        '''ToDo: Validate the argument as a valid port'''\n        if len(args) >= 1:\n            self.WirelessPort = args[0]\n        print (\"Connecting to Cameras on %s\" % self.WirelessPort)\n        self.__vRegisterCameras()", "response": "ToDo: Validate the argument as a valid port and connect to the Cameras"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __vCmdSetCamExposureMode(self, args):\n        '''ToDo: Validate CAM number and Valid Mode Values'''\n        if len(args) == 1:\n            for cam in self.camera_list:\n                cam.boSetExposureMode(args[0])\n        elif len(args) == 2:\n            cam = self.camera_list[int(args[1])]\n            cam.boSetExposureMode(args[0])\n        else:\n            print (\"Usage: setCamExposureMode MODE [CAMNUMBER], Valid values for MODE: Program Auto, Aperture, Shutter, Manual, Intelligent Auto, Superior Auto\")", "response": "ToDo : Validate CAM number and Valid Mode Values"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __vCmdSetCamAperture(self, args):\n        '''ToDo: Validate CAM number and Valid Aperture Value'''\n        if len(args) == 1:\n            for cam in self.camera_list:\n                cam.boSetAperture(int(args[0]))\n        elif len(args) == 2:\n            cam = self.camera_list[int(args[1])]\n            cam.boSetAperture(int(args[0]))\n        else:\n            print (\"Usage: setCamAperture APERTURE [CAMNUMBER], APERTURE is value x10\")", "response": "ToDo : Validate CAM number and Valid Aperture Value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __vCmdSetCamISO(self, args):\n        '''ToDo: Validate CAM number and Valid ISO Value'''\n        if len(args) == 1:\n            for cam in self.camera_list:\n                cam.boSetISO(int(args[0]))\n        elif len(args) == 2:\n            cam = self.camera_list[int(args[1])]\n            cam.boSetISO(int(args[0]))\n        else:\n            print (\"Usage: setCamISO ISOVALUE [CAMNUMBER]\")", "response": "ToDo : Validate CAM number and Valid ISO Value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __vDecodeDIGICAMConfigure(self, mCommand_Long):\n        if mCommand_Long.param1 != 0:\n            print (\"Exposure Mode = %d\" % mCommand_Long.param1)\n            \n            if mCommand_Long.param1 == self.ProgramAuto:\n                self.__vCmdSetCamExposureMode([\"Program Auto\"])\n            \n            elif mCommand_Long.param1 == self.Aperture:\n                self.__vCmdSetCamExposureMode([\"Aperture\"])\n            \n            elif mCommand_Long.param1 == self.Shutter:\n                self.__vCmdSetCamExposureMode([\"Shutter\"])\n\n        '''Shutter Speed'''\n        if mCommand_Long.param2 != 0:\n            print (\"Shutter Speed= %d\" % mCommand_Long.param2)\n            self.__vCmdSetCamShutterSpeed([mCommand_Long.param2])\n        \n        '''Aperture'''\n        if mCommand_Long.param3 != 0:\n            print (\"Aperture = %d\" % mCommand_Long.param3)\n            self.__vCmdSetCamAperture([mCommand_Long.param3])\n\n        '''ISO'''\n        if mCommand_Long.param4 != 0:\n            print (\"ISO = %d\" % mCommand_Long.param4)\n            self.__vCmdSetCamISO([mCommand_Long.param4])\n\n        '''Exposure Type'''\n        if mCommand_Long.param5 != 0:\n            print (\"Exposure type= %d\" % mCommand_Long.param5)", "response": "This function handles the digital am configure command."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling a mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle a mavlink packet'''\n        mtype = m.get_type()\n        if mtype == \"CAMERA_STATUS\":\n            print (\"Got Message camera_status\")\n        if mtype == \"CAMERA_FEEDBACK\":\n            print (\"Got Message camera_feedback\")\n            '''self.__vCmdCamTrigger(m)'''\n        if mtype == \"COMMAND_LONG\":\n            if m.command == mavutil.mavlink.MAV_CMD_DO_DIGICAM_CONFIGURE:\n                print (\"Got Message Digicam_configure\")\n                self.__vDecodeDIGICAMConfigure(m)\n            elif m.command == mavutil.mavlink.MAV_CMD_DO_DIGICAM_CONTROL:\n                print (\"Got Message Digicam_control\")\n                self.__vDecodeDIGICAMControl(m)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing flight modes for a log file", "response": "def flight_modes(logfile):\n    '''show flight modes for a log file'''\n    print(\"Processing log %s\" % filename)\n    mlog = mavutil.mavlink_connection(filename)\n\n    mode = \"\"\n    previous_mode = \"\"\n    mode_start_timestamp = -1\n    time_in_mode = {}\n    previous_percent = -1\n    seconds_per_percent = -1\n\n    filesize = os.path.getsize(filename)\n\n    while True:\n        m = mlog.recv_match(type=['SYS_STATUS','HEARTBEAT','MODE'],\n                            condition='MAV.flightmode!=\"%s\"' % mlog.flightmode)\n        if m is None:\n            break\n        print('%s MAV.flightmode=%-12s (MAV.timestamp=%u %u%%)' % (\n            time.asctime(time.localtime(m._timestamp)),\n            mlog.flightmode,\n            m._timestamp, mlog.percent))\n\n        mode = mlog.flightmode\n        if (mode not in time_in_mode):\n            time_in_mode[mode] = 0\n\n        if (mode_start_timestamp == -1):\n            mode_start_timestamp = m._timestamp\n        elif (previous_mode != \"\" and previous_mode != mode):\n            time_in_mode[previous_mode] = time_in_mode[previous_mode] + (m._timestamp - mode_start_timestamp)\n\n            #figure out how many seconds per percentage point so I can\n            #caculate how many seconds for the final mode\n            if (seconds_per_percent == -1 and previous_percent != -1\n                    and previous_percent != mlog.percent):\n                seconds_per_percent = (m._timestamp - mode_start_timestamp) / (mlog.percent - previous_percent)\n\n            mode_start_timestamp = m._timestamp\n\n        previous_mode = mode\n        previous_percent = mlog.percent\n\n    #put a whitespace line before the per-mode report\n    print()\n    print(\"Time per mode:\")\n\n    #need to get the time in the final mode\n    if (seconds_per_percent != -1):\n        seconds_remaining = (100.0 - previous_percent) * seconds_per_percent\n\n        time_in_mode[previous_mode] = time_in_mode[previous_mode] + seconds_remaining\n\n        total_flight_time = 0\n        for key, value in time_in_mode.iteritems():\n            total_flight_time = total_flight_time + value\n\n        for key, value in time_in_mode.iteritems():\n            print('%-12s %s %.2f%%' % (key, str(datetime.timedelta(seconds=int(value))), (value / total_flight_time) * 100.0))\n    else:\n        #can't print time in mode if only one mode during flight\n        print(previous_mode, \" 100% of flight time\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns true if we have a graph of the given name", "response": "def have_graph(name):\n    '''return true if we have a graph of the given name'''\n    for g in mestate.graphs:\n        if g.name == name:\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef menu_callback(m):\n    '''called on menu selection'''\n    if m.returnkey.startswith('# '):\n        cmd = m.returnkey[2:]\n        if m.handler is not None:\n            if m.handler_result is None:\n                return\n            cmd += m.handler_result\n        process_stdin(cmd)\n    elif m.returnkey == 'menuSettings':\n        wxsettings.WXSettings(mestate.settings)\n    elif m.returnkey.startswith(\"mode-\"):\n        idx = int(m.returnkey[5:])\n        mestate.flightmode_selections[idx] = m.IsChecked()\n    else:\n        print('Unknown menu selection: %s' % m.returnkey)", "response": "called on menu selection"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef graph_menus():\n    '''return menu tree for graphs (recursive)'''\n    ret = MPMenuSubMenu('Graphs', [])\n    for i in range(len(mestate.graphs)):\n        g = mestate.graphs[i]\n        path = g.name.split('/')\n        name = path[-1]\n        path = path[:-1]\n        ret.add_to_submenu(path, MPMenuItem(name, name, '# graph :%u' % i))\n    return ret", "response": "return tree for graphs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if an expression is OK with current messages", "response": "def expression_ok(expression):\n    '''return True if an expression is OK with current messages'''\n    expression_ok = True\n    fields = expression.split()\n    for f in fields:\n        try:\n            if f.endswith(':2'):\n                f = f[:-2]\n            if mavutil.evaluate_expression(f, mestate.status.msgs) is None:\n                expression_ok = False                        \n        except Exception:\n            expression_ok = False\n            break\n    return expression_ok"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_graph_xml(xml, filename, load_all=False):\n    '''load a graph from one xml string'''\n    ret = []\n    try:\n        root = objectify.fromstring(xml)\n    except Exception:\n        return []\n    if root.tag != 'graphs':\n        return []\n    if not hasattr(root, 'graph'):\n        return []\n    for g in root.graph:\n        name = g.attrib['name']\n        expressions = [e.text for e in g.expression]\n        if load_all:\n            ret.append(GraphDefinition(name, e, g.description.text, expressions, filename))\n            continue\n        if have_graph(name):\n            continue\n        for e in expressions:\n            if expression_ok(e):\n                ret.append(GraphDefinition(name, e, g.description.text, expressions, filename))\n                break\n    return ret", "response": "load a graph from one xml string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload graphs from mavgraphs. xml", "response": "def load_graphs():\n    '''load graphs from mavgraphs.xml'''\n    mestate.graphs = []\n    gfiles = ['mavgraphs.xml']\n    if 'HOME' in os.environ:\n        for dirname, dirnames, filenames in os.walk(os.path.join(os.environ['HOME'], \".mavproxy\")):\n            for filename in filenames:\n                \n                if filename.lower().endswith('.xml'):\n                    gfiles.append(os.path.join(dirname, filename))\n    for file in gfiles:\n        if not os.path.exists(file):\n            continue\n        graphs = load_graph_xml(open(file).read(), file)\n        if graphs:\n            mestate.graphs.extend(graphs)\n            mestate.console.writeln(\"Loaded %s\" % file)\n    # also load the built in graphs\n    dlist = pkg_resources.resource_listdir(\"MAVProxy\", \"tools/graphs\")\n    for f in dlist:\n        raw = pkg_resources.resource_stream(\"MAVProxy\", \"tools/graphs/%s\" % f).read()\n        graphs = load_graph_xml(raw, None)\n        if graphs:\n            mestate.graphs.extend(graphs)\n            mestate.console.writeln(\"Loaded %s\" % f)\n    mestate.graphs = sorted(mestate.graphs, key=lambda g: g.name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing for a graph", "response": "def graph_process(fields):\n    '''process for a graph'''\n    mestate.mlog.reduce_by_flightmodes(mestate.flightmode_selections)\n    \n    mg = grapher.MavGraph()\n    mg.set_marker(mestate.settings.marker)\n    mg.set_condition(mestate.settings.condition)\n    mg.set_xaxis(mestate.settings.xaxis)\n    mg.set_linestyle(mestate.settings.linestyle)\n    mg.set_flightmode(mestate.settings.flightmode)\n    mg.set_legend(mestate.settings.legend)\n    mg.add_mav(mestate.mlog)\n    for f in fields:\n        mg.add_field(f)\n    mg.process()\n    mg.show()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef map_process(args):\n    '''process for a graph'''\n    from mavflightview import mavflightview_mav, mavflightview_options\n    mestate.mlog.reduce_by_flightmodes(mestate.flightmode_selections)\n    \n    options = mavflightview_options()\n    options.condition = mestate.settings.condition\n    if len(args) > 0:\n        options.types = ','.join(args)\n    mavflightview_mav(mestate.mlog, options)", "response": "process for a graph"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_graph(graphdef):\n    '''save a graph as XML'''\n    if graphdef.filename is None:\n        if 'HOME' in os.environ:\n            dname = os.path.join(os.environ['HOME'], '.mavproxy')\n            mp_util.mkdir_p(dname)\n            graphdef.filename = os.path.join(dname, 'mavgraphs.xml')\n        else:\n            graphdef.filename = 'mavgraphs.xml'\n    if graphdef.filename is None:\n        mestate.console.writeln(\"No file to save graph to\", fg='red')\n        return\n    graphs = load_graph_xml(open(graphdef.filename).read(), graphdef.filename, load_all=True)\n    found_name = False\n    for i in range(len(graphs)):\n        if graphs[i].name == graphdef.name:\n            graphs[i] = graphdef\n            found_name = True\n            break\n    if not found_name:\n        graphs.append(graphdef)\n    mestate.console.writeln(\"Saving %u graphs to %s\" % (len(graphs), graphdef.filename))\n    f = open(graphdef.filename, \"w\")\n    f.write(\"<graphs>\\n\\n\")\n    for g in graphs:\n        f.write(\" <graph name='%s'>\\n\" % g.name.strip())\n        if g.description is None:\n            g.description = ''\n        f.write(\"  <description>%s</description>\\n\" % g.description.strip())\n        for e in g.expressions:\n            f.write(\"  <expression>%s</expression>\\n\" % e.strip())\n        f.write(\" </graph>\\n\\n\")\n    f.write(\"</graphs>\\n\")\n    f.close()", "response": "save a graph as XML"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_process():\n    '''process for saving a graph'''\n    from MAVProxy.modules.lib import wx_processguard\n    from MAVProxy.modules.lib.wx_loader import wx\n    from MAVProxy.modules.lib.wxgrapheditor import GraphDialog\n    app = wx.App(False)\n    frame = GraphDialog('Graph Editor',\n                        mestate.last_graph,\n                        save_callback)\n    frame.ShowModal()\n    frame.Destroy()", "response": "process for saving a graph"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef nav_filter_bias_encode(self, usec, accel_0, accel_1, accel_2, gyro_0, gyro_1, gyro_2):\n                '''\n                Accelerometer and Gyro biases from the navigation filter\n\n                usec                      : Timestamp (microseconds) (uint64_t)\n                accel_0                   : b_f[0] (float)\n                accel_1                   : b_f[1] (float)\n                accel_2                   : b_f[2] (float)\n                gyro_0                    : b_f[0] (float)\n                gyro_1                    : b_f[1] (float)\n                gyro_2                    : b_f[2] (float)\n\n                '''\n                return MAVLink_nav_filter_bias_message(usec, accel_0, accel_1, accel_2, gyro_0, gyro_1, gyro_2)", "response": "This function is called when the user wants to set the biases of the accelerometer and gyro biases from the navigation filter."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncompletes set of calibration parameters for the radio aileron : Aileron setpoints: left, center, right (uint16_t) elevator : Elevator setpoints: nose down, center, nose up (uint16_t) rudder : Rudder setpoints: nose left, center, nose right (uint16_t) gyro : Tail gyro mode/gain setpoints: heading hold, rate mode (uint16_t) pitch : Pitch curve setpoints (every 25%) (uint16_t) throttle : Throttle curve setpoints (every 25%) (uint16_t)", "response": "def radio_calibration_encode(self, aileron, elevator, rudder, gyro, pitch, throttle):\n                '''\n                Complete set of calibration parameters for the radio\n\n                aileron                   : Aileron setpoints: left, center, right (uint16_t)\n                elevator                  : Elevator setpoints: nose down, center, nose up (uint16_t)\n                rudder                    : Rudder setpoints: nose left, center, nose right (uint16_t)\n                gyro                      : Tail gyro mode/gain setpoints: heading hold, rate mode (uint16_t)\n                pitch                     : Pitch curve setpoints (every 25%) (uint16_t)\n                throttle                  : Throttle curve setpoints (every 25%) (uint16_t)\n\n                '''\n                return MAVLink_radio_calibration_message(aileron, elevator, rudder, gyro, pitch, throttle)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef radio_calibration_send(self, aileron, elevator, rudder, gyro, pitch, throttle, force_mavlink1=False):\n                '''\n                Complete set of calibration parameters for the radio\n\n                aileron                   : Aileron setpoints: left, center, right (uint16_t)\n                elevator                  : Elevator setpoints: nose down, center, nose up (uint16_t)\n                rudder                    : Rudder setpoints: nose left, center, nose right (uint16_t)\n                gyro                      : Tail gyro mode/gain setpoints: heading hold, rate mode (uint16_t)\n                pitch                     : Pitch curve setpoints (every 25%) (uint16_t)\n                throttle                  : Throttle curve setpoints (every 25%) (uint16_t)\n\n                '''\n                return self.send(self.radio_calibration_encode(aileron, elevator, rudder, gyro, pitch, throttle), force_mavlink1=force_mavlink1)", "response": "Set the calibration parameters for the radio."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef servo_output_raw_encode(self, time_usec, port, servo1_raw, servo2_raw, servo3_raw, servo4_raw, servo5_raw, servo6_raw, servo7_raw, servo8_raw, servo9_raw, servo10_raw, servo11_raw, servo12_raw, servo13_raw, servo14_raw, servo15_raw, servo16_raw):\n                '''\n                The RAW values of the servo outputs (for RC input from the remote, use\n                the RC_CHANNELS messages). The standard PPM modulation\n                is as follows: 1000 microseconds: 0%, 2000\n                microseconds: 100%.\n\n                time_usec                 : Timestamp (microseconds since system boot) (uint32_t)\n                port                      : Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos. (uint8_t)\n                servo1_raw                : Servo output 1 value, in microseconds (uint16_t)\n                servo2_raw                : Servo output 2 value, in microseconds (uint16_t)\n                servo3_raw                : Servo output 3 value, in microseconds (uint16_t)\n                servo4_raw                : Servo output 4 value, in microseconds (uint16_t)\n                servo5_raw                : Servo output 5 value, in microseconds (uint16_t)\n                servo6_raw                : Servo output 6 value, in microseconds (uint16_t)\n                servo7_raw                : Servo output 7 value, in microseconds (uint16_t)\n                servo8_raw                : Servo output 8 value, in microseconds (uint16_t)\n                servo9_raw                : Servo output 9 value, in microseconds (uint16_t)\n                servo10_raw               : Servo output 10 value, in microseconds (uint16_t)\n                servo11_raw               : Servo output 11 value, in microseconds (uint16_t)\n                servo12_raw               : Servo output 12 value, in microseconds (uint16_t)\n                servo13_raw               : Servo output 13 value, in microseconds (uint16_t)\n                servo14_raw               : Servo output 14 value, in microseconds (uint16_t)\n                servo15_raw               : Servo output 15 value, in microseconds (uint16_t)\n                servo16_raw               : Servo output 16 value, in microseconds (uint16_t)\n\n                '''\n                return MAVLink_servo_output_raw_message(time_usec, port, servo1_raw, servo2_raw, servo3_raw, servo4_raw, servo5_raw, servo6_raw, servo7_raw, servo8_raw, servo9_raw, servo10_raw, servo11_raw, servo12_raw, servo13_raw, servo14_raw, servo15_raw, servo16_raw)", "response": "Encode the raw values of the servo outputs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setup_signing_encode(self, target_system, target_component, secret_key, initial_timestamp):\n                '''\n                Setup a MAVLink2 signing key. If called with secret_key of all zero\n                and zero initial_timestamp will disable signing\n\n                target_system             : system id of the target (uint8_t)\n                target_component          : component ID of the target (uint8_t)\n                secret_key                : signing key (uint8_t)\n                initial_timestamp         : initial timestamp (uint64_t)\n\n                '''\n                return MAVLink_setup_signing_message(target_system, target_component, secret_key, initial_timestamp)", "response": "Setup a signing key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setup_signing_send(self, target_system, target_component, secret_key, initial_timestamp, force_mavlink1=False):\n                '''\n                Setup a MAVLink2 signing key. If called with secret_key of all zero\n                and zero initial_timestamp will disable signing\n\n                target_system             : system id of the target (uint8_t)\n                target_component          : component ID of the target (uint8_t)\n                secret_key                : signing key (uint8_t)\n                initial_timestamp         : initial timestamp (uint64_t)\n\n                '''\n                return self.send(self.setup_signing_encode(target_system, target_component, secret_key, initial_timestamp), force_mavlink1=force_mavlink1)", "response": "Setup a MAVLink2 signing key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef button_change_send(self, time_boot_ms, last_change_ms, state, force_mavlink1=False):\n                '''\n                Report button state change\n\n                time_boot_ms              : Timestamp (milliseconds since system boot) (uint32_t)\n                last_change_ms            : Time of last change of button state (uint32_t)\n                state                     : Bitmap state of buttons (uint8_t)\n\n                '''\n                return self.send(self.button_change_encode(time_boot_ms, last_change_ms, state), force_mavlink1=force_mavlink1)", "response": "Report button state change"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef play_tune_send(self, target_system, target_component, tune, force_mavlink1=False):\n                '''\n                Control vehicle tone generation (buzzer)\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                tune                      : tune in board specific format (char)\n\n                '''\n                return self.send(self.play_tune_encode(target_system, target_component, tune), force_mavlink1=force_mavlink1)", "response": "Control vehicle tone generation (buzzer)\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                tune                      : tune in board specific format (char)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_from_latlon_to_utm(points=None,\n                               latitudes=None,\n                               longitudes=None,\n                               false_easting=None,\n                               false_northing=None):\n    \"\"\"Convert latitude and longitude data to UTM as a list of coordinates.\n\n\n    Input\n\n    points: list of points given in decimal degrees (latitude, longitude) or\n    latitudes: list of latitudes   and\n    longitudes: list of longitudes\n    false_easting (optional)\n    false_northing (optional)\n\n    Output\n\n    points: List of converted points\n    zone:   Common UTM zone for converted points\n\n\n    Notes\n\n    Assume the false_easting and false_northing are the same for each list.\n    If points end up in different UTM zones, an ANUGAerror is thrown.\n    \"\"\"\n\n    old_geo = Geo_reference()\n    utm_points = []\n    if points == None:\n        assert len(latitudes) == len(longitudes)\n        points =  map(None, latitudes, longitudes)\n\n    for point in points:\n\n        zone, easting, northing = redfearn(float(point[0]),\n                                           float(point[1]),\n                                           false_easting=false_easting,\n                                           false_northing=false_northing)\n        new_geo = Geo_reference(zone)\n        old_geo.reconcile_zones(new_geo)\n        utm_points.append([easting, northing])\n\n    return utm_points, old_geo.get_zone()", "response": "Convert latitude and longitude data to UTM."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a mavlink log file to a GPX file", "response": "def mav_to_gpx(infilename, outfilename):\n    '''convert a mavlink log file to a GPX file'''\n\n    mlog = mavutil.mavlink_connection(infilename)\n    outf = open(outfilename, mode='w')\n\n    def process_packet(timestamp, lat, lon, alt, hdg, v):\n        t = time.localtime(timestamp)\n        outf.write('''<trkpt lat=\"%s\" lon=\"%s\">\n  <ele>%s</ele>\n  <time>%s</time>\n  <course>%s</course>\n  <speed>%s</speed>\n  <fix>3d</fix>\n</trkpt>\n''' % (lat, lon, alt,\n       time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", t),\n       hdg, v))\n\n    def add_header():\n        outf.write('''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<gpx\n  version=\"1.0\"\n  creator=\"pymavlink\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xmlns=\"http://www.topografix.com/GPX/1/0\"\n  xsi:schemaLocation=\"http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd\">\n<trk>\n<trkseg>\n''')\n\n    def add_footer():\n        outf.write('''</trkseg>\n</trk>\n</gpx>\n''')\n\n    add_header()\n\n    count=0\n    lat=0\n    lon=0\n    fix=0\n    while True:\n        m = mlog.recv_match(type=['GPS_RAW', 'GPS_RAW_INT', 'GPS', 'GPS2'], condition=args.condition)\n        if m is None:\n            break\n        if m.get_type() == 'GPS_RAW_INT':\n            lat = m.lat/1.0e7\n            lon = m.lon/1.0e7\n            alt = m.alt/1.0e3\n            v = m.vel/100.0\n            hdg = m.cog/100.0\n            timestamp = m._timestamp\n            fix = m.fix_type\n        elif m.get_type() == 'GPS_RAW':\n            lat = m.lat\n            lon = m.lon\n            alt = m.alt\n            v = m.v\n            hdg = m.hdg\n            timestamp = m._timestamp\n            fix = m.fix_type\n        elif m.get_type() == 'GPS' or m.get_type() == 'GPS2':\n            lat = m.Lat\n            lon = m.Lng\n            alt = m.Alt\n            v = m.Spd\n            hdg = m.GCrs\n            timestamp = m._timestamp\n            fix = m.Status\n        else:\n\t    pass\n\n        if fix < 2 and not args.nofixcheck:\n            continue\n        if lat == 0.0 or lon == 0.0:\n            continue\n        process_packet(timestamp, lat, lon, alt, hdg, v)\n        count += 1\n    add_footer()\n    print(\"Created %s with %u points\" % (outfilename, count))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef q(self):\n        if self._q is None:\n            if self._euler is not None:\n                # get q from euler\n                self._q = self._euler_to_q(self.euler)\n            elif self._dcm is not None:\n                # get q from DCM\n                self._q = self._dcm_to_q(self.dcm)\n        return self._q", "response": "Get the quaternion elements of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef q(self, q):\n        self._q = np.array(q)\n\n        # mark other representations as outdated, will get generated on next\n        # read\n        self._euler = None\n        self._dcm = None", "response": "Set the quaternion of the current set of items in the set."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef euler(self):\n        if self._euler is None:\n            if self._q is not None:\n                # try to get euler angles from q via DCM\n                self._dcm = self._q_to_dcm(self.q)\n                self._euler = self._dcm_to_euler(self.dcm)\n            elif self._dcm is not None:\n                # get euler angles from DCM\n                self._euler = self._dcm_to_euler(self.dcm)\n        return self._euler", "response": "Get the euler angles."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the euler angles for this object", "response": "def euler(self, euler):\n        \"\"\"\n        Set the euler angles\n        :param euler: list or array of the euler angles [roll, pitch, yaw]\n\n        \"\"\"\n        assert(len(euler) == 3)\n        self._euler = np.array(euler)\n\n        # mark other representations as outdated, will get generated on next\n        # read\n        self._q = None\n        self._dcm = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dcm(self):\n        if self._dcm is None:\n            if self._q is not None:\n                # try to get dcm from q\n                self._dcm = self._q_to_dcm(self.q)\n            elif self._euler is not None:\n                # try to get get dcm from euler\n                self._dcm = self._euler_to_dcm(self._euler)\n        return self._dcm", "response": "Get the DCM from the list of available local tables."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dcm(self, dcm):\n        assert(len(dcm) == 3)\n        for sub in dcm:\n            assert(len(sub) == 3)\n\n        self._dcm = np.array(dcm)\n\n        # mark other representations as outdated, will get generated on next\n        # read\n        self._q = None\n        self._euler = None", "response": "Set the DCM as a new array of DCMs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef transform(self, v):\n        assert(len(v) == 3)\n        assert(np.allclose(self.norm, 1))\n        # perform transformation t = q * [0, v] * q^-1 but avoid multiplication\n        # because terms cancel out\n        q0 = self.q[0]\n        qi = self.q[1:4]\n        ui = np.array(v)\n        a = q0 * ui + np.cross(qi, ui)\n        t = np.dot(qi, ui) * qi + q0 * a - np.cross(a, qi)\n        return t", "response": "Calculates the vector transformed by this quaternion\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nnormalizes the list with len 4 so that it can be used as quaternion", "response": "def normalize_array(q):\n        \"\"\"\n        Normalizes the list with len 4 so that it can be used as quaternion\n        :param q: array of len 4\n        :returns: normalized array\n        \"\"\"\n        assert(len(q) == 4)\n        q = np.array(q)\n        n = QuaternionBase.norm_array(q)\n        return q / n"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef norm_array(q):\n        assert(len(q) == 4)\n        return np.sqrt(np.dot(q, q))", "response": "Calculate quaternion norm on array q\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _mul_array(self, p, q):\n        assert(len(q) == len(p) == 4)\n        p0 = p[0]\n        pi = p[1:4]\n        q0 = q[0]\n        qi = q[1:4]\n\n        res = np.zeros(4)\n        res[0] = p0 * q0 - np.dot(pi, qi)\n        res[1:4] = p0 * qi + q0 * pi + np.cross(pi, qi)\n\n        return res", "response": "Performs multiplication of the 2 quaterniona arrays p and q\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _euler_to_q(self, euler):\n        assert(len(euler) == 3)\n        phi = euler[0]\n        theta = euler[1]\n        psi = euler[2]\n        c_phi_2 = np.cos(phi / 2)\n        s_phi_2 = np.sin(phi / 2)\n        c_theta_2 = np.cos(theta / 2)\n        s_theta_2 = np.sin(theta / 2)\n        c_psi_2 = np.cos(psi / 2)\n        s_psi_2 = np.sin(psi / 2)\n        q = np.zeros(4)\n        q[0] = (c_phi_2 * c_theta_2 * c_psi_2 +\n                s_phi_2 * s_theta_2 * s_psi_2)\n        q[1] = (s_phi_2 * c_theta_2 * c_psi_2 -\n                c_phi_2 * s_theta_2 * s_psi_2)\n        q[2] = (c_phi_2 * s_theta_2 * c_psi_2 +\n                s_phi_2 * c_theta_2 * s_psi_2)\n        q[3] = (c_phi_2 * c_theta_2 * s_psi_2 -\n                s_phi_2 * s_theta_2 * c_psi_2)\n        return q", "response": "Convert euler angles to q array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _q_to_dcm(self, q):\n        assert(len(q) == 4)\n        assert(np.allclose(QuaternionBase.norm_array(q), 1))\n        dcm = np.zeros([3, 3])\n        a = q[0]\n        b = q[1]\n        c = q[2]\n        d = q[3]\n        a_sq = a * a\n        b_sq = b * b\n        c_sq = c * c\n        d_sq = d * d\n        dcm[0][0] = a_sq + b_sq - c_sq - d_sq\n        dcm[0][1] = 2 * (b * c - a * d)\n        dcm[0][2] = 2 * (a * c + b * d)\n        dcm[1][0] = 2 * (b * c + a * d)\n        dcm[1][1] = a_sq - b_sq + c_sq - d_sq\n        dcm[1][2] = 2 * (c * d - a * b)\n        dcm[2][0] = 2 * (b * d - a * c)\n        dcm[2][1] = 2 * (a * b + c * d)\n        dcm[2][2] = a_sq - b_sq - c_sq + d_sq\n        return dcm", "response": "Convert a quaternion array q to a DCM array"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert DCM to Quaternion array.", "response": "def _dcm_to_q(self, dcm):\n        \"\"\"\n        Create q from dcm\n        Reference:\n            - Shoemake, Quaternions,\n            http://www.cs.ucr.edu/~vbz/resources/quatut.pdf\n\n        :param dcm: 3x3 dcm array\n        returns: quaternion array\n        \"\"\"\n        assert(dcm.shape == (3, 3))\n        q = np.zeros(4)\n\n        tr = np.trace(dcm)\n        if tr > 0:\n            s = np.sqrt(tr + 1.0)\n            q[0] = s * 0.5\n            s = 0.5 / s\n            q[1] = (dcm[2][1] - dcm[1][2]) * s\n            q[2] = (dcm[0][2] - dcm[2][0]) * s\n            q[3] = (dcm[1][0] - dcm[0][1]) * s\n        else:\n            dcm_i = np.argmax(np.diag(dcm))\n            dcm_j = (dcm_i + 1) % 3\n            dcm_k = (dcm_i + 2) % 3\n\n            s = np.sqrt((dcm[dcm_i][dcm_i] - dcm[dcm_j][dcm_j] -\n                         dcm[dcm_k][dcm_k]) + 1.0)\n            q[dcm_i + 1] = s * 0.5\n            s = 0.5 / s\n            q[dcm_j + 1] = (dcm[dcm_i][dcm_j] + dcm[dcm_j][dcm_i]) * s\n            q[dcm_k + 1] = (dcm[dcm_k][dcm_i] + dcm[dcm_i][dcm_k]) * s\n            q[0] = (dcm[dcm_k][dcm_j] - dcm[dcm_j][dcm_k]) * s\n\n        return q"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _euler_to_dcm(self, euler):\n        assert(len(euler) == 3)\n        phi = euler[0]\n        theta = euler[1]\n        psi = euler[2]\n        dcm = np.zeros([3, 3])\n        c_phi = np.cos(phi)\n        s_phi = np.sin(phi)\n        c_theta = np.cos(theta)\n        s_theta = np.sin(theta)\n        c_psi = np.cos(psi)\n        s_psi = np.sin(psi)\n\n        dcm[0][0] = c_theta * c_psi\n        dcm[0][1] = -c_phi * s_psi + s_phi * s_theta * c_psi\n        dcm[0][2] = s_phi * s_psi + c_phi * s_theta * c_psi\n\n        dcm[1][0] = c_theta * s_psi\n        dcm[1][1] = c_phi * c_psi + s_phi * s_theta * s_psi\n        dcm[1][2] = -s_phi * c_psi + c_phi * s_theta * s_psi\n\n        dcm[2][0] = -s_theta\n        dcm[2][1] = s_phi * c_theta\n        dcm[2][2] = c_phi * c_theta\n        return dcm", "response": "Convert euler angles to DCM array."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting DCM to euler angles.", "response": "def _dcm_to_euler(self, dcm):\n        \"\"\"\n        Create DCM from euler angles\n        :param dcm: 3x3 dcm array\n        :returns: array [roll, pitch, yaw] in rad\n        \"\"\"\n        assert(dcm.shape == (3, 3))\n        theta = np.arcsin(min(1, max(-1, -dcm[2][0])))\n\n        if abs(theta - np.pi/2) < 1.0e-3:\n            phi = 0.0\n            psi = (np.arctan2(dcm[1][2] - dcm[0][1],\n                              dcm[0][2] + dcm[1][1]) + phi)\n        elif abs(theta + np.pi/2) < 1.0e-3:\n            phi = 0.0\n            psi = np.arctan2(dcm[1][2] - dcm[0][1],\n                             dcm[0][2] + dcm[1][1] - phi)\n        else:\n            phi = np.arctan2(dcm[2][1], dcm[2][2])\n            psi = np.arctan2(dcm[1][0], dcm[0][0])\n\n        return np.array([phi, theta, psi])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the DCM to be used for reading.", "response": "def dcm(self, dcm):\n        \"\"\"\n        Set the DCM\n        :param dcm: Matrix3\n\n        \"\"\"\n        assert(isinstance(dcm, Matrix3))\n        self._dcm = dcm.copy()\n\n        # mark other representations as outdated, will get generated on next\n        # read\n        self._q = None\n        self._euler = None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the vector transformed by this quaternion and returns the transformed vector", "response": "def transform(self, v3):\n        \"\"\"\n        Calculates the vector transformed by this quaternion\n        :param v3: Vector3 to be transformed\n        :returns: transformed vector\n        \"\"\"\n        if isinstance(v3, Vector3):\n            t = super(Quaternion, self).transform([v3.x, v3.y, v3.z])\n            return Vector3(t[0], t[1], t[2])\n        elif len(v3) == 3:\n            return super(Quaternion, self).transform(v3)\n        else:\n            raise TypeError(\"param v3 is not a vector type\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _dcm_array_to_matrix3(self, dcm):\n        assert(dcm.shape == (3, 3))\n        a = Vector3(dcm[0][0], dcm[0][1], dcm[0][2])\n        b = Vector3(dcm[1][0], dcm[1][1], dcm[1][2])\n        c = Vector3(dcm[2][0], dcm[2][1], dcm[2][2])\n        return Matrix3(a, b, c)", "response": "Converts a 3x3 dcm array into a Matrix3 object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _matrix3_to_dcm_array(self, m):\n        assert(isinstance(m, Matrix3))\n        return np.array([[m.a.x, m.a.y, m.a.z],\n                         [m.b.x, m.b.y, m.b.z],\n                         [m.c.x, m.c.y, m.c.z]])", "response": "Converts Matrix3 to 3x3 array"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating DCM from Quaternion array q", "response": "def _q_to_dcm(self, q):\n        \"\"\"\n        Create DCM (Matrix3) from q\n        :param q: array q which represents a quaternion [w, x, y, z]\n        :returns: Matrix3\n        \"\"\"\n        assert(len(q) == 4)\n        arr = super(Quaternion, self)._q_to_dcm(q)\n        return self._dcm_array_to_matrix3(arr)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _dcm_to_q(self, dcm):\n        assert(isinstance(dcm, Matrix3))\n        arr = self._matrix3_to_dcm_array(dcm)\n        return super(Quaternion, self)._dcm_to_q(arr)", "response": "Create q from dcm"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate DCM from euler angles in rad", "response": "def _euler_to_dcm(self, euler):\n        \"\"\"\n        Create DCM (Matrix3) from euler angles\n        :param euler: array [roll, pitch, yaw] in rad\n        :returns: Matrix3\n        \"\"\"\n        assert(len(euler) == 3)\n        m = Matrix3()\n        m.from_euler(*euler)\n        return m"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates DCM from euler angles.", "response": "def _dcm_to_euler(self, dcm):\n        \"\"\"\n        Create DCM from euler angles\n        :param dcm: Matrix3\n        :returns: array [roll, pitch, yaw] in rad\n        \"\"\"\n        assert(isinstance(dcm, Matrix3))\n        return np.array(dcm.to_euler())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lock_time(logfile):\n    '''work out gps lock times for a log file'''\n    print(\"Processing log %s\" % filename)\n    mlog = mavutil.mavlink_connection(filename)\n\n    locked = False\n    start_time = 0.0\n    total_time = 0.0\n    t = None\n    m = mlog.recv_match(type=['GPS_RAW_INT','GPS_RAW'], condition=args.condition)\n    if m is None:\n        return 0\n\n    unlock_time = time.mktime(time.localtime(m._timestamp))\n\n    while True:\n        m = mlog.recv_match(type=['GPS_RAW_INT','GPS_RAW'], condition=args.condition)\n        if m is None:\n            if locked:\n                total_time += time.mktime(t) - start_time\n            if total_time > 0:\n                print(\"Lock time : %u:%02u\" % (int(total_time)/60, int(total_time)%60))\n            return total_time\n        t = time.localtime(m._timestamp)\n        if m.fix_type >= 2 and not locked:\n            print(\"Locked at %s after %u seconds\" % (time.asctime(t),\n                                                     time.mktime(t) - unlock_time))\n            locked = True\n            start_time = time.mktime(t)\n        elif m.fix_type == 1 and locked:\n            print(\"Lost GPS lock at %s\" % time.asctime(t))\n            locked = False\n            total_time += time.mktime(t) - start_time\n            unlock_time = time.mktime(t)\n        elif m.fix_type == 0 and locked:\n            print(\"Lost protocol lock at %s\" % time.asctime(t))\n            locked = False\n            total_time += time.mktime(t) - start_time\n            unlock_time = time.mktime(t)\n    return total_time", "response": "work out gps lock times for a log file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_menu(self, event):\n        '''handle menu selection'''\n        state = self.state\n        # see if it is a popup menu\n        if state.popup_object is not None:\n            obj = state.popup_object\n            ret = obj.popup_menu.find_selected(event)\n            if ret is not None:\n                ret.call_handler()\n                state.event_queue.put(SlipMenuEvent(state.popup_latlon, event,\n                                                    [SlipObjectSelection(obj.key, 0, obj.layer, obj.selection_info())],\n                                                    ret))\n                state.popup_object = None\n                state.popup_latlon = None\n        if state.default_popup is not None:\n            ret = state.default_popup.popup.find_selected(event)\n            if ret is not None:\n                ret.call_handler()\n                state.event_queue.put(SlipMenuEvent(state.popup_latlon, event, [], ret))\n            \n        # otherwise a normal menu\n        ret = self.menu.find_selected(event)\n        if ret is None:\n            return\n        ret.call_handler()\n        if ret.returnkey == 'toggleGrid':\n            state.grid = ret.IsChecked()\n        elif ret.returnkey == 'toggleFollow':\n            state.follow = ret.IsChecked()\n        elif ret.returnkey == 'toggleDownload':\n            state.download = ret.IsChecked()\n        elif ret.returnkey == 'setService':\n            state.mt.set_service(ret.get_choice())\n        elif ret.returnkey == 'gotoPosition':\n            state.panel.enter_position()\n        elif ret.returnkey == 'increaseBrightness':\n            state.brightness *= 1.25\n        elif ret.returnkey == 'decreaseBrightness':\n            state.brightness /= 1.25\n        state.need_redraw = True", "response": "handle menu selection event"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef follow(self, object):\n        '''follow an object on the map'''\n        state = self.state\n        (px,py) = state.panel.pixmapper(object.latlon)\n        ratio = 0.25\n        if (px > ratio*state.width and\n            px < (1.0-ratio)*state.width and\n            py > ratio*state.height and\n            py < (1.0-ratio)*state.height):\n            # we're in the mid part of the map already, don't move\n            return\n\n        if not state.follow:\n            # the user has disabled following\n            return\n\n        (lat, lon) = object.latlon\n        state.panel.re_center(state.width/2, state.height/2, lat, lon)", "response": "follow an object on the map"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an object to a later layer", "response": "def add_object(self, obj):\n        '''add an object to a later'''\n        state = self.state\n        if not obj.layer in state.layers:\n            # its a new layer\n            state.layers[obj.layer] = {}\n        state.layers[obj.layer][obj.key] = obj\n        state.need_redraw = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_object(self, key):\n        '''remove an object by key from all layers'''\n        state = self.state\n        for layer in state.layers:\n            state.layers[layer].pop(key, None)\n        state.need_redraw = True", "response": "remove an object by key from all layers"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef on_idle(self, event):\n        '''prevent the main loop spinning too fast'''\n        state = self.state\n\n        if state.close_window.acquire(False):\n            self.state.app.ExitMainLoop()\n\n        # receive any display objects from the parent\n        obj = None\n\n        while not state.object_queue.empty():\n            obj = state.object_queue.get()\n\n            if isinstance(obj, SlipObject):\n                self.add_object(obj)\n\n            if isinstance(obj, SlipPosition):\n                # move an object\n                object = self.find_object(obj.key, obj.layer)\n                if object is not None:\n                    object.update_position(obj)\n                    if getattr(object, 'follow', False):\n                        self.follow(object)\n                    state.need_redraw = True\n\n            if isinstance(obj, SlipDefaultPopup):\n                state.default_popup = obj\n\n            if isinstance(obj, SlipInformation):\n                # see if its a existing one or a new one\n                if obj.key in state.info:\n#                    print('update %s' % str(obj.key))\n                    state.info[obj.key].update(obj)\n                else:\n#                    print('add %s' % str(obj.key))\n                    state.info[obj.key] = obj\n                state.need_redraw = True\n\n            if isinstance(obj, SlipCenter):\n                # move center\n                (lat,lon) = obj.latlon\n                state.panel.re_center(state.width/2, state.height/2, lat, lon)\n                state.need_redraw = True\n\n            if isinstance(obj, SlipBrightness):\n                # set map brightness\n                state.brightness = obj.brightness\n                state.need_redraw = True\n\n            if isinstance(obj, SlipClearLayer):\n                # remove all objects from a layer\n                if obj.layer in state.layers:\n                    state.layers.pop(obj.layer)\n                state.need_redraw = True\n\n            if isinstance(obj, SlipRemoveObject):\n                # remove an object by key\n                for layer in state.layers:\n                    if obj.key in state.layers[layer]:\n                        state.layers[layer].pop(obj.key)\n                state.need_redraw = True\n\n            if isinstance(obj, SlipHideObject):\n                # hide an object by key\n                for layer in state.layers:\n                    if obj.key in state.layers[layer]:\n                        state.layers[layer][obj.key].set_hidden(obj.hide)\n                state.need_redraw = True\n        \n        if obj is None:\n            time.sleep(0.05)", "response": "prevent the main loop spinning too fast"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a tuple representing the current view", "response": "def current_view(self):\n        '''return a tuple representing the current view'''\n        state = self.state\n        return (state.lat, state.lon, state.width, state.height,\n                state.ground_width, state.mt.tiles_pending())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning coordinates of a pixel in the map", "response": "def coordinates(self, x, y):\n        '''return coordinates of a pixel in the map'''\n        state = self.state\n        return state.mt.coord_from_area(x, y, state.lat, state.lon, state.width, state.ground_width)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef re_center(self, x, y, lat, lon):\n        '''re-center view for pixel x,y'''\n        state = self.state\n        if lat is None or lon is None:\n            return\n        (lat2,lon2) = self.coordinates(x, y)\n        distance = mp_util.gps_distance(lat2, lon2, lat, lon)\n        bearing  = mp_util.gps_bearing(lat2, lon2, lat, lon)\n        (state.lat, state.lon) = mp_util.gps_newpos(state.lat, state.lon, bearing, distance)", "response": "re - center view for pixel x y"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef change_zoom(self, zoom):\n        '''zoom in or out by zoom factor, keeping centered'''\n        state = self.state\n        if self.mouse_pos:\n            (x,y) = (self.mouse_pos.x, self.mouse_pos.y)\n        else:\n            (x,y) = (state.width/2, state.height/2)\n        (lat,lon) = self.coordinates(x, y)\n        state.ground_width *= zoom\n        # limit ground_width to sane values\n        state.ground_width = max(state.ground_width, 20)\n        state.ground_width = min(state.ground_width, 20000000)\n        self.re_center(x,y, lat, lon)", "response": "zoom in or out by zoom factor keeping centered"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pixel_coords(self, latlon, reverse=False):\n        '''return pixel coordinates in the map image for a (lat,lon)\n        if reverse is set, then return lat/lon for a pixel coordinate\n        '''\n        state = self.state\n        if reverse:\n            (x,y) = latlon\n            return self.coordinates(x,y)\n        (lat,lon) = (latlon[0], latlon[1])\n        return state.mt.coord_to_pixel(state.lat, state.lon, state.width, state.ground_width, lat, lon)", "response": "return the pixel coordinates in the map image for a ( lat lon )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndrawing objects on the image", "response": "def draw_objects(self, objects, bounds, img):\n        '''draw objects on the image'''\n        keys = objects.keys()\n        keys.sort()\n        for k in keys:\n            obj = objects[k]\n            bounds2 = obj.bounds()\n            if bounds2 is None or mp_util.bounds_overlap(bounds, bounds2):\n                obj.draw(img, self.pixmapper, bounds)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef redraw_map(self):\n        '''redraw the map with current settings'''\n        state = self.state\n\n        view_same = (self.last_view and self.map_img and self.last_view == self.current_view())\n\n        if view_same and not state.need_redraw:\n            return\n\n        # get the new map\n        self.map_img = state.mt.area_to_image(state.lat, state.lon,\n                                              state.width, state.height, state.ground_width)\n        if state.brightness != 1.0:\n            cv.ConvertScale(self.map_img, self.map_img, scale=state.brightness)\n\n\n        # find display bounding box\n        (lat2,lon2) = self.coordinates(state.width-1, state.height-1)\n        bounds = (lat2, state.lon, state.lat-lat2, lon2-state.lon)\n\n        # get the image\n        img = cv.CloneImage(self.map_img)\n\n        # possibly draw a grid\n        if state.grid:\n            SlipGrid('grid', layer=3, linewidth=1, colour=(255,255,0)).draw(img, self.pixmapper, bounds)\n\n        # draw layer objects\n        keys = state.layers.keys()\n        keys.sort()\n        for k in keys:\n            self.draw_objects(state.layers[k], bounds, img)\n\n        # draw information objects\n        for key in state.info:\n            state.info[key].draw(state.panel, state.panel.information)\n\n        # display the image\n        self.img = wx.EmptyImage(state.width,state.height)\n        self.img.SetData(img.tostring())\n        self.imagePanel.set_image(self.img)\n\n        self.update_position()\n\n        self.mainSizer.Fit(self)\n        self.Refresh()\n        self.last_view = self.current_view()\n        self.SetFocus()\n        state.need_redraw = False", "response": "redraw the map with current settings"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles window size changes", "response": "def on_size(self, event):\n        '''handle window size changes'''\n        state = self.state\n        size = event.GetSize()\n        state.width = size.width\n        state.height = size.height\n        self.redraw_map()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef selected_objects(self, pos):\n        '''return a list of matching objects for a position'''\n        state = self.state\n        selected = []\n        (px, py) = pos\n        for layer in state.layers:\n            for key in state.layers[layer]:\n                obj = state.layers[layer][key]\n                distance = obj.clicked(px, py)\n                if distance is not None:\n                    selected.append(SlipObjectSelection(key, distance, layer, extra_info=obj.selection_info()))\n        selected.sort(key=lambda c: c.distance)\n        return selected", "response": "return a list of matching objects for a position"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshowing default popup menu", "response": "def show_default_popup(self, pos):\n        '''show default popup menu'''\n        state = self.state\n        if state.default_popup.popup is not None:\n            wx_menu = state.default_popup.popup.wx_menu()\n            state.frame.PopupMenu(wx_menu, pos)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_thumbnails(self):\n        '''clear all thumbnails from the map'''\n        state = self.state\n        for l in state.layers:\n            keys = state.layers[l].keys()[:]\n            for key in keys:\n                if (isinstance(state.layers[l][key], SlipThumbnail)\n                    and not isinstance(state.layers[l][key], SlipIcon)):\n                    state.layers[l].pop(key)", "response": "clear all thumbnails from the map"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compile_all():\n    # print(\"Compiling for Qt: style.qrc -> style.rcc\")\n    # os.system(\"rcc style.qrc -o style.rcc\")\n    print(\"Compiling for PyQt4: style.qrc -> pyqt_style_rc.py\")\n    os.system(\"pyrcc4 -py3 style.qrc -o pyqt_style_rc.py\")\n    print(\"Compiling for PyQt5: style.qrc -> pyqt5_style_rc.py\")\n    os.system(\"pyrcc5 style.qrc -o pyqt5_style_rc.py\")\n    print(\"Compiling for PySide: style.qrc -> pyside_style_rc.py\")\n    os.system(\"pyside-rcc -py3 style.qrc -o pyside_style_rc.py\")", "response": "Compile style. qrc using rcc pyside - rcc and pyrcc4"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plotit(self, x, y, fields, colors=[]):\n        '''plot a set of graphs using date for x axis'''\n        pylab.ion()\n        fig = pylab.figure(num=1, figsize=(12,6))\n        ax1 = fig.gca()\n        ax2 = None\n        xrange = 0.0\n        for i in range(0, len(fields)):\n            if len(x[i]) == 0: continue\n            if self.lowest_x is None or x[i][0] < self.lowest_x:\n                self.lowest_x = x[i][0]\n            if self.highest_x is None or x[i][-1] > self.highest_x:\n                self.highest_x = x[i][-1]\n        if self.highest_x is None or self.lowest_x is None:\n            return\n        xrange = self.highest_x - self.lowest_x\n        xrange *= 24 * 60 * 60\n        self.formatter = matplotlib.dates.DateFormatter('%H:%M:%S')\n        interval = 1\n        intervals = [ 1, 2, 5, 10, 15, 30, 60, 120, 240, 300, 600,\n                      900, 1800, 3600, 7200, 5*3600, 10*3600, 24*3600 ]\n        for interval in intervals:\n            if xrange / interval < 15:\n                break\n        locator = matplotlib.dates.SecondLocator(interval=interval)\n        if not self.xaxis:\n            ax1.xaxis.set_major_locator(locator)\n            ax1.xaxis.set_major_formatter(self.formatter)\n        empty = True\n        ax1_labels = []\n        ax2_labels = []\n\n        for i in range(0, len(fields)):\n            if len(x[i]) == 0:\n                print(\"Failed to find any values for field %s\" % fields[i])\n                continue\n            if i < len(colors):\n                color = colors[i]\n            else:\n                color = 'red'\n                (tz, tzdst) = time.tzname\n\n            if self.axes[i] == 2:\n                if ax2 == None:\n                    ax2 = ax1.twinx()\n                    ax2.format_coord = self.make_format(ax2, ax1)\n                ax = ax2\n                if not self.xaxis:\n                    ax2.xaxis.set_major_locator(locator)\n                    ax2.xaxis.set_major_formatter(self.formatter)\n                label = fields[i]\n                if label.endswith(\":2\"):\n                    label = label[:-2]\n                ax2_labels.append(label)\n            else:\n                ax1_labels.append(fields[i])\n                ax = ax1\n            \n            if self.xaxis:\n                if self.marker is not None:\n                    marker = self.marker\n                else:\n                    marker = '+'\n                if self.linestyle is not None:\n                    linestyle = self.linestyle\n                else:\n                    linestyle = 'None'\n                ax.plot(x[i], y[i], color=color, label=fields[i],\n                        linestyle=linestyle, marker=marker)\n            else:\n                if self.marker is not None:\n                    marker = self.marker\n                else:\n                    marker = 'None'\n                if self.linestyle is not None:\n                    linestyle = self.linestyle\n                else:\n                    linestyle = '-'\n                ax.plot_date(x[i], y[i], color=color, label=fields[i],\n                             linestyle=linestyle, marker=marker, tz=None)\n\n            empty = False\n            if self.flightmode is not None:\n                for i in range(len(self.modes)-1):\n                    c = colourmap[self.flightmode].get(self.modes[i][1], edge_colour)\n                    ax1.axvspan(self.modes[i][0], self.modes[i+1][0], fc=c, ec=edge_colour, alpha=0.1)\n                c = colourmap[self.flightmode].get(self.modes[-1][1], edge_colour)\n                ax1.axvspan(self.modes[-1][0], ax1.get_xlim()[1], fc=c, ec=edge_colour, alpha=0.1)\n\n            if ax1_labels != []:\n                ax1.legend(ax1_labels,loc=self.legend)\n            if ax2_labels != []:\n                ax2.legend(ax2_labels,loc=self.legend2)\n            if empty:\n                print(\"No data to graph\")\n                return", "response": "plot a set of graphs using date for x axis"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding some data to the internal list", "response": "def add_data(self, t, msg, vars, flightmode):\n        '''add some data'''\n        mtype = msg.get_type()\n        if self.flightmode is not None and (len(self.modes) == 0 or self.modes[-1][1] != flightmode):\n            self.modes.append((t, flightmode))\n        for i in range(0, len(self.fields)):\n            if mtype not in self.field_types[i]:\n                continue\n            f = self.fields[i]\n            if f.endswith(\":2\"):\n                self.axes[i] = 2\n                f = f[:-2]\n            if f.endswith(\":1\"):\n                self.first_only[i] = True\n                f = f[:-2]\n            v = mavutil.evaluate_expression(f, vars)\n            if v is None:\n                continue\n            if self.xaxis is None:\n                xv = t\n            else:\n                xv = mavutil.evaluate_expression(self.xaxis, vars)\n                if xv is None:\n                    continue\n            self.y[i].append(v)\n            self.x[i].append(xv)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprocess and display the related information", "response": "def process(self, block=True):\n        '''process and display graph'''\n        self.msg_types = set()\n        self.multiplier = []\n        self.field_types = []\n\n        # work out msg types we are interested in\n        self.x = []\n        self.y = []\n        self.modes = []\n        self.axes = []\n        self.first_only = []\n        re_caps = re.compile('[A-Z_][A-Z0-9_]+')\n        for f in self.fields:\n            caps = set(re.findall(re_caps, f))\n            self.msg_types = self.msg_types.union(caps)\n            self.field_types.append(caps)\n            self.y.append([])\n            self.x.append([])\n            self.axes.append(1)\n            self.first_only.append(False)\n\n        if self.labels is not None:\n            labels = self.labels.split(',')\n            if len(labels) != len(fields)*len(self.mav_list):\n                print(\"Number of labels (%u) must match number of fields (%u)\" % (\n                    len(labels), len(fields)*len(self.mav_list)))\n                return\n        else:\n            labels = None\n            \n        timeshift = self.timeshift\n\n        for fi in range(0, len(self.mav_list)):\n            mlog = self.mav_list[fi]\n            self.process_mav(mlog, timeshift)\n            timeshift = 0\n            for i in range(0, len(self.x)):\n                if self.first_only[i] and fi != 0:\n                    self.x[i] = []\n                    self.y[i] = []\n            if labels:\n                lab = labels[fi*len(self.fields):(fi+1)*len(self.fields)]\n            else:\n                lab = self.fields[:]\n            if self.multi:\n                col = colors[:]\n            else:\n                col = colors[fi*len(self.fields):]\n            self.plotit(self.x, self.y, lab, colors=col)\n            for i in range(0, len(self.x)):\n                self.x[i] = []\n                self.y[i] = []\n        pylab.draw()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nnull terminate a string", "response": "def null_term(str):\n    '''null terminate a string'''\n    idx = str.find(\"\\0\")\n    if idx != -1:\n        str = str[:idx]\n    return str"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef DFReader_is_text_log(filename):\n    '''return True if a file appears to be a valid text log'''\n    f = open(filename)\n    ret = (f.read(8000).find('FMT, ') != -1)\n    f.close()\n    return ret", "response": "return True if a file appears to be a valid text log"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_msgbuf(self):\n        '''create a binary message buffer for a message'''\n        values = []\n        for i in range(len(self.fmt.columns)):\n            if i >= len(self.fmt.msg_mults):\n                continue\n            mul = self.fmt.msg_mults[i]\n            name = self.fmt.columns[i]\n            if name == 'Mode' and 'ModeNum' in self.fmt.columns:\n                name = 'ModeNum'\n            v = self.__getattr__(name)\n            if mul is not None:\n                v /= mul\n            values.append(v)\n        return struct.pack(\"BBB\", 0xA3, 0x95, self.fmt.type) + struct.pack(self.fmt.msg_struct, *values)", "response": "create a binary message buffer for a message"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nworks out time basis for the log - even newer style", "response": "def find_time_base(self, gps, first_us_stamp):\n        '''work out time basis for the log - even newer style'''\n        t = self._gpsTimeToTime(gps.GWk, gps.GMS)\n        self.set_timebase(t - gps.TimeUS*0.000001)\n        # this ensures FMT messages get appropriate timestamp:\n        self.timestamp = self.timebase + first_us_stamp*0.000001"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef type_has_good_TimeMS(self, type):\n        '''The TimeMS in some messages is not from *our* clock!'''\n        if type.startswith('ACC'):\n            return False;\n        if type.startswith('GYR'):\n            return False;\n        return True", "response": "Check if a type is good for our timeMS"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nworking out time basis for the log - new style", "response": "def find_time_base(self, gps, first_ms_stamp):\n        '''work out time basis for the log - new style'''\n        t = self._gpsTimeToTime(gps.Week, gps.TimeMS)\n        self.set_timebase(t - gps.T*0.001)\n        self.timestamp = self.timebase + first_ms_stamp*0.001"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nworking out time basis for the log - PX4 native", "response": "def find_time_base(self, gps):\n        '''work out time basis for the log - PX4 native'''\n        t = gps.GPSTime * 1.0e-6\n        self.timebase = t - self.px4_timebase"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadjust time base from GPS message", "response": "def gps_message_arrived(self, m):\n        '''adjust time base from GPS message'''\n        # msec-style GPS message?\n        gps_week = getattr(m, 'Week', None)\n        gps_timems = getattr(m, 'TimeMS', None)\n        if gps_week is None:\n            # usec-style GPS message?\n            gps_week = getattr(m, 'GWk', None)\n            gps_timems = getattr(m, 'GMS', None)\n            if gps_week is None:\n                if getattr(m, 'GPSTime', None) is not None:\n                    # PX4-style timestamp; we've only been called\n                    # because we were speculatively created in case no\n                    # better clock was found.\n                    return;\n\n        t = self._gpsTimeToTime(gps_week, gps_timems) \n\n        deltat = t - self.timebase\n        if deltat <= 0:\n            return\n\n        for type in self.counts_since_gps:\n            rate = self.counts_since_gps[type] / deltat\n            if rate > self.msg_rate.get(type, 0):\n                self.msg_rate[type] = rate\n        self.msg_rate['IMU'] = 50.0\n        self.timebase = t\n        self.counts_since_gps = {}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nresetting state on rewind", "response": "def _rewind(self):\n        '''reset state on rewind'''\n        self.messages = { 'MAV' : self }\n        self.flightmode = \"UNKNOWN\"\n        self.percent = 0\n        if self.clock:\n            self.clock.rewind_event()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init_clock(self):\n        '''work out time basis for the log'''\n\n        self._rewind()\n\n        # speculatively create a gps clock in case we don't find anything\n        # better\n        gps_clock = DFReaderClock_gps_interpolated()\n        self.clock = gps_clock\n\n        px4_msg_time = None\n        px4_msg_gps = None\n        gps_interp_msg_gps1 = None\n        gps_interp_msg_gps2 = None\n        first_us_stamp = None\n        first_ms_stamp = None\n\n        have_good_clock = False\n        while True:\n            m = self.recv_msg()\n            if m is None:\n                break;\n\n            type = m.get_type()\n\n            if first_us_stamp is None:\n                first_us_stamp = getattr(m, \"TimeUS\", None);\n\n            if first_ms_stamp is None and (type != 'GPS' and type != 'GPS2'):\n                # Older GPS messages use TimeMS for msecs past start\n                # of gps week\n                first_ms_stamp = getattr(m, \"TimeMS\", None);\n\n            if type == 'GPS' or type == 'GPS2':\n                if getattr(m, \"TimeUS\", 0) != 0 and \\\n                   getattr(m, \"GWk\", 0) != 0: # everything-usec-timestamped\n                    self.init_clock_usec()\n                    if not self._zero_time_base:\n                        self.clock.find_time_base(m, first_us_stamp)\n                    have_good_clock = True\n                    break\n                if getattr(m, \"T\", 0) != 0 and \\\n                   getattr(m, \"Week\", 0) != 0: # GPS is msec-timestamped\n                    if first_ms_stamp is None:\n                        first_ms_stamp = m.T\n                    self.init_clock_msec()\n                    if not self._zero_time_base:\n                        self.clock.find_time_base(m, first_ms_stamp)\n                    have_good_clock = True\n                    break\n                if getattr(m, \"GPSTime\", 0) != 0: # px4-style-only\n                    px4_msg_gps = m\n                if getattr(m, \"Week\", 0) != 0:\n                    if gps_interp_msg_gps1 is not None and \\\n                       (gps_interp_msg_gps1.TimeMS != m.TimeMS or \\\n                        gps_interp_msg_gps1.Week != m.Week):\n                        # we've received two distinct, non-zero GPS\n                        # packets without finding a decent clock to\n                        # use; fall back to interpolation. Q: should\n                        # we wait a few more messages befoe doing\n                        # this?\n                        self.init_clock_gps_interpolated(gps_clock)\n                        have_good_clock = True\n                        break\n                    gps_interp_msg_gps1 = m\n\n            elif type == 'TIME':\n                '''only px4-style logs use TIME'''\n                if getattr(m, \"StartTime\", None) != None:\n                    px4_msg_time = m;\n\n            if px4_msg_time is not None and px4_msg_gps is not None:\n                self.init_clock_px4(px4_msg_time, px4_msg_gps)\n                have_good_clock = True\n                break\n\n#        print(\"clock is \" + str(self.clock))\n        if not have_good_clock:\n            # we failed to find any GPS messages to set a time\n            # base for usec and msec clocks.  Also, not a\n            # PX4-style log\n            if first_us_stamp is not None:\n                self.init_clock_usec()\n            elif first_ms_stamp is not None:\n                self.init_clock_msec()\n\n        self._rewind()\n\n        return", "response": "work out time basis for the log"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _set_time(self, m):\n        '''set time for a message'''\n        # really just left here for profiling\n        m._timestamp = self.timestamp\n        if len(m._fieldnames) > 0 and self.clock is not None:\n            self.clock.set_message_timestamp(m)", "response": "set time for a message"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new message to the internal list", "response": "def _add_msg(self, m):\n        '''add a new message'''\n        type = m.get_type()\n        self.messages[type] = m\n\n        if self.clock:\n            self.clock.message_arrived(m)\n\n        if type == 'MSG':\n            if m.Message.find(\"Rover\") != -1:\n                self.mav_type = mavutil.mavlink.MAV_TYPE_GROUND_ROVER\n            elif m.Message.find(\"Plane\") != -1:\n                self.mav_type = mavutil.mavlink.MAV_TYPE_FIXED_WING\n            elif m.Message.find(\"Copter\") != -1:\n                self.mav_type = mavutil.mavlink.MAV_TYPE_QUADROTOR\n            elif m.Message.startswith(\"Antenna\"):\n                self.mav_type = mavutil.mavlink.MAV_TYPE_ANTENNA_TRACKER\n        if type == 'MODE':\n            if isinstance(m.Mode, str):\n                self.flightmode = m.Mode.upper()\n            elif 'ModeNum' in m._fieldnames:\n                mapping = mavutil.mode_mapping_bynumber(self.mav_type)\n                if mapping is not None and m.ModeNum in mapping:\n                    self.flightmode = mapping[m.ModeNum]\n            else:\n                self.flightmode = mavutil.mode_string_acm(m.Mode)\n        if type == 'STAT' and 'MainState' in m._fieldnames:\n            self.flightmode = mavutil.mode_string_px4(m.MainState)\n        if type == 'PARM' and getattr(m, 'Name', None) is not None:\n            self.params[m.Name] = m.Value\n        self._set_time(m)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef param(self, name, default=None):\n        '''convenient function for returning an arbitrary MAVLink\n           parameter with a default'''\n        if not name in self.params:\n            return default\n        return self.params[name]", "response": "convenient function for returning an arbitrary MAVLink\n           parameter with a default"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrewinds to start of log", "response": "def _rewind(self):\n        '''rewind to start of log'''\n        DFReader._rewind(self)\n        self.offset = 0\n        self.remaining = self.data_len"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_next(self):\n        '''read one message, returning it as an object'''\n        if self.data_len - self.offset < 3:\n            return None\n            \n        hdr = self.data[self.offset:self.offset+3]\n        skip_bytes = 0\n        skip_type = None\n        # skip over bad messages\n        while (ord(hdr[0]) != self.HEAD1 or ord(hdr[1]) != self.HEAD2 or ord(hdr[2]) not in self.formats):\n            if skip_type is None:\n                skip_type = (ord(hdr[0]), ord(hdr[1]), ord(hdr[2]))\n                skip_start = self.offset\n            skip_bytes += 1\n            self.offset += 1\n            if self.data_len - self.offset < 3:\n                return None\n            hdr = self.data[self.offset:self.offset+3]\n        msg_type = ord(hdr[2])\n        if skip_bytes != 0:\n            if self.remaining < 528:\n                return None\n            print(\"Skipped %u bad bytes in log at offset %u, type=%s\" % (skip_bytes, skip_start, skip_type))\n            self.remaining -= skip_bytes\n\n        self.offset += 3\n        self.remaining -= 3\n\n        if not msg_type in self.formats:\n            if self.verbose:\n                print(\"unknown message type %02x\" % msg_type)\n            raise Exception(\"Unknown message type %02x\" % msg_type)\n        fmt = self.formats[msg_type]\n        if self.remaining < fmt.len-3:\n            # out of data - can often happen half way through a message\n            if self.verbose:\n                print(\"out of data\")\n            return None\n        body = self.data[self.offset:self.offset+(fmt.len-3)]\n        elements = None\n        try:\n            elements = list(struct.unpack(fmt.msg_struct, body))\n        except Exception:\n            if self.remaining < 528:\n                # we can have garbage at the end of an APM2 log\n                return None\n            # we should also cope with other corruption; logs\n            # transfered via DataFlash_MAVLink may have blocks of 0s\n            # in them, for example\n            print(\"Failed to parse %s/%s with len %u (remaining %u)\" % (fmt.name, fmt.msg_struct, len(body), self.remaining))\n        if elements is None:\n            return self._parse_next()\n        name = null_term(fmt.name)\n        if name == 'FMT':\n            # add to formats\n            # name, len, format, headings\n            self.formats[elements[0]] = DFFormat(elements[0],\n                                                 null_term(elements[2]), elements[1],\n                                                 null_term(elements[3]), null_term(elements[4]))\n\n        self.offset += fmt.len-3\n        self.remaining -= fmt.len-3\n        m = DFMessage(fmt, elements, True)\n        self._add_msg(m)\n\n        self.percent = 100.0 * (self.offset / float(self.data_len))\n        \n        return m", "response": "read one message returning it as an object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrewinding to start of log", "response": "def _rewind(self):\n        '''rewind to start of log'''\n        DFReader._rewind(self)\n        self.line = 0\n        # find the first valid line\n        while self.line < len(self.lines):\n            if self.lines[self.line].startswith(\"FMT, \"):\n                break\n            self.line += 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading one message returning it as an object", "response": "def _parse_next(self):\n        '''read one message, returning it as an object'''\n\n        this_line = self.line\n        while self.line < len(self.lines):\n            s = self.lines[self.line].rstrip()\n            elements = s.split(\", \")\n            this_line = self.line\n            # move to next line\n            self.line += 1\n            if len(elements) >= 2:\n                # this_line is good\n                break\n\n        if this_line >= len(self.lines):\n            return None\n\n        # cope with empty structures\n        if len(elements) == 5 and elements[-1] == ',':\n            elements[-1] = ''\n            elements.append('')\n\n        self.percent = 100.0 * (this_line / float(len(self.lines)))\n\n        msg_type = elements[0]\n\n        if not msg_type in self.formats:\n            return self._parse_next()\n        \n        fmt = self.formats[msg_type]\n\n        if len(elements) < len(fmt.format)+1:\n            # not enough columns\n            return self._parse_next()\n\n        elements = elements[1:]\n        \n        name = fmt.name.rstrip('\\0')\n        if name == 'FMT':\n            # add to formats\n            # name, len, format, headings\n            self.formats[elements[2]] = DFFormat(int(elements[0]), elements[2], int(elements[1]), elements[3], elements[4])\n\n        try:\n            m = DFMessage(fmt, elements, False)\n        except ValueError:\n            return self._parse_next()\n\n        self._add_msg(m)\n\n        return m"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmdvel2PosTarget(vel):\n    '''\n    Translates from JderobotTypes CMDVel to ROS Twist.\n\n    @param vel: JderobotTypes CMDVel to translate\n\n    @type img: JdeRobotTypes.CMDVel\n\n    @return a Twist translated from vel\n\n    '''\n    msg=PositionTarget(\n        header=Header(\n            stamp=rospy.Time.now(),\n            frame_id=''),\n    )\n    msg.coordinate_frame = 8\n    msg.type_mask = 1475\n    msg.position.x = vel.px\n    msg.position.y = vel.py\n    msg.position.z = vel.pz\n    msg.velocity.x = vel.vx\n    msg.velocity.y = vel.vy\n    msg.velocity.z = vel.vz\n    msg.acceleration_or_force.x = vel.ax\n    msg.acceleration_or_force.y = vel.ay\n    msg.acceleration_or_force.z = vel.az\n    msg.yaw = vel.yaw\n    msg.yaw_rate = vel.yaw_rate\n    return msg", "response": "Translate a CMDVel to a ROS Twist."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef publish (self):\n        '''\n        Function to publish cmdvel.\n        '''\n        #print(self)\n        #self.using_event.wait()\n\n        self.lock.acquire()\n        msg = cmdvel2PosTarget(self.vel)\n        self.lock.release()\n        self.pub.publish(msg)", "response": "Function to publish cmdvel.\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sendCMD (self, vel):\n        '''\n        Sends CMDVel.\n\n        @param vel: CMDVel to publish\n\n        @type vel: CMDVel\n\n        '''\n        self.lock.acquire()\n        self.vel = vel\n        self.lock.release()", "response": "Sends a new CMDVel to the current set of available entries."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mavloss(logfile):\n    '''work out signal loss times for a log file'''\n    print(\"Processing log %s\" % filename)\n    mlog = mavutil.mavlink_connection(filename,\n                                      planner_format=args.planner,\n                                      notimestamps=args.notimestamps,\n                                      dialect=args.dialect,\n                                      robust_parsing=args.robust)\n\n    # Track the reasons for MAVLink parsing errors and print them all out at the end.\n    reason_ids = set()\n    reasons = []\n\n    while True:\n        m = mlog.recv_match(condition=args.condition)\n\n        # Stop parsing the file once we've reached the end\n        if m is None:\n            break\n\n        # Save the parsing failure reason for this message if it's a new one\n        if m.get_type() == 'BAD_DATA':\n            reason_id = ''.join(m.reason.split(' ')[0:3])\n            if reason_id not in reason_ids:\n                reason_ids.add(reason_id)\n                reasons.append(m.reason)\n\n    # Print out the final packet loss results\n    print(\"%u packets, %u lost %.1f%%\" % (\n            mlog.mav_count, mlog.mav_loss, mlog.packet_loss()))\n\n    # Also print out the reasons why losses occurred\n    if len(reasons) > 0:\n        print(\"Packet loss at least partially attributed to the following:\")\n        for r in reasons:\n            print(\"  * \" + r)", "response": "work out signal loss times for a log file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef diagnostic_encode(self, diagFl1, diagFl2, diagFl3, diagSh1, diagSh2, diagSh3):\n                '''\n                Configurable diagnostic messages.\n\n                diagFl1                   : Diagnostic float 1 (float)\n                diagFl2                   : Diagnostic float 2 (float)\n                diagFl3                   : Diagnostic float 3 (float)\n                diagSh1                   : Diagnostic short 1 (int16_t)\n                diagSh2                   : Diagnostic short 2 (int16_t)\n                diagSh3                   : Diagnostic short 3 (int16_t)\n\n                '''\n                return MAVLink_diagnostic_message(diagFl1, diagFl2, diagFl3, diagSh1, diagSh2, diagSh3)", "response": "This function encodes the diagnostic messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef diagnostic_send(self, diagFl1, diagFl2, diagFl3, diagSh1, diagSh2, diagSh3, force_mavlink1=False):\n                '''\n                Configurable diagnostic messages.\n\n                diagFl1                   : Diagnostic float 1 (float)\n                diagFl2                   : Diagnostic float 2 (float)\n                diagFl3                   : Diagnostic float 3 (float)\n                diagSh1                   : Diagnostic short 1 (int16_t)\n                diagSh2                   : Diagnostic short 2 (int16_t)\n                diagSh3                   : Diagnostic short 3 (int16_t)\n\n                '''\n                return self.send(self.diagnostic_encode(diagFl1, diagFl2, diagFl3, diagSh1, diagSh2, diagSh3), force_mavlink1=force_mavlink1)", "response": "Diagnostics are supported by all modules."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef slugs_navigation_encode(self, u_m, phi_c, theta_c, psiDot_c, ay_body, totalDist, dist2Go, fromWP, toWP, h_c):\n                '''\n                Data used in the navigation algorithm.\n\n                u_m                       : Measured Airspeed prior to the nav filter in m/s (float)\n                phi_c                     : Commanded Roll (float)\n                theta_c                   : Commanded Pitch (float)\n                psiDot_c                  : Commanded Turn rate (float)\n                ay_body                   : Y component of the body acceleration (float)\n                totalDist                 : Total Distance to Run on this leg of Navigation (float)\n                dist2Go                   : Remaining distance to Run on this leg of Navigation (float)\n                fromWP                    : Origin WP (uint8_t)\n                toWP                      : Destination WP (uint8_t)\n                h_c                       : Commanded altitude in 0.1 m (uint16_t)\n\n                '''\n                return MAVLink_slugs_navigation_message(u_m, phi_c, theta_c, psiDot_c, ay_body, totalDist, dist2Go, fromWP, toWP, h_c)", "response": "This function is called when the user wants to update the list of slugs in the GUI."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef slugs_navigation_send(self, u_m, phi_c, theta_c, psiDot_c, ay_body, totalDist, dist2Go, fromWP, toWP, h_c, force_mavlink1=False):\n                '''\n                Data used in the navigation algorithm.\n\n                u_m                       : Measured Airspeed prior to the nav filter in m/s (float)\n                phi_c                     : Commanded Roll (float)\n                theta_c                   : Commanded Pitch (float)\n                psiDot_c                  : Commanded Turn rate (float)\n                ay_body                   : Y component of the body acceleration (float)\n                totalDist                 : Total Distance to Run on this leg of Navigation (float)\n                dist2Go                   : Remaining distance to Run on this leg of Navigation (float)\n                fromWP                    : Origin WP (uint8_t)\n                toWP                      : Destination WP (uint8_t)\n                h_c                       : Commanded altitude in 0.1 m (uint16_t)\n\n                '''\n                return self.send(self.slugs_navigation_encode(u_m, phi_c, theta_c, psiDot_c, ay_body, totalDist, dist2Go, fromWP, toWP, h_c), force_mavlink1=force_mavlink1)", "response": "This message is used to perform the navigation algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef data_log_encode(self, fl_1, fl_2, fl_3, fl_4, fl_5, fl_6):\n                '''\n                Configurable data log probes to be used inside Simulink\n\n                fl_1                      : Log value 1 (float)\n                fl_2                      : Log value 2 (float)\n                fl_3                      : Log value 3 (float)\n                fl_4                      : Log value 4 (float)\n                fl_5                      : Log value 5 (float)\n                fl_6                      : Log value 6 (float)\n\n                '''\n                return MAVLink_data_log_message(fl_1, fl_2, fl_3, fl_4, fl_5, fl_6)", "response": "Configurable data log probes to be used inside Simulink\n\n                fl_1                      : Log value 1 (float)\n                fl_2                      : Log value 2 (float)\n                fl_3                      : Log value 3 (float)\n                fl_4                      : Log value 4 (float)\n                fl_5                      : Log value 5 (float)\n                fl_6                      : Log value 6 (float)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gps_date_time_encode(self, year, month, day, hour, min, sec, clockStat, visSat, useSat, GppGl, sigUsedMask, percentUsed):\n                '''\n                Pilot console PWM messges.\n\n                year                      : Year reported by Gps (uint8_t)\n                month                     : Month reported by Gps (uint8_t)\n                day                       : Day reported by Gps (uint8_t)\n                hour                      : Hour reported by Gps (uint8_t)\n                min                       : Min reported by Gps (uint8_t)\n                sec                       : Sec reported by Gps (uint8_t)\n                clockStat                 : Clock Status. See table 47 page 211 OEMStar Manual (uint8_t)\n                visSat                    : Visible satellites reported by Gps (uint8_t)\n                useSat                    : Used satellites in Solution (uint8_t)\n                GppGl                     : GPS+GLONASS satellites in Solution (uint8_t)\n                sigUsedMask               : GPS and GLONASS usage mask (bit 0 GPS_used? bit_4 GLONASS_used?) (uint8_t)\n                percentUsed               : Percent used GPS (uint8_t)\n\n                '''\n                return MAVLink_gps_date_time_message(year, month, day, hour, min, sec, clockStat, visSat, useSat, GppGl, sigUsedMask, percentUsed)", "response": "Pilot console PWM messges.\n\n                year                      : Year reported by Gps (uint8_t)\n                month                     : Month reported by Gps (uint8_t)\n                day                       : Day reported by Gps (uint8_t)\n                hour                      : Hour reported by Gps (uint8_t)\n                min                       : Min reported by Gps (uint8_t)\n                sec                       : Sec reported by Gps (uint8_t)\n                clockStat                 : Clock Status. See table 47 page 211 OEMStar Manual (uint8_t)\n                visSat                    : Visible satellites reported by Gps (uint8_t)\n                useSat                    : Used satellites in Solution (uint8_t)\n                GppGl                     : GPS+GLONASS satellites in Solution (uint8_t)\n                sigUsedMask               : GPS and GLONASS usage mask (bit 0 GPS_used? bit_4 GLONASS_used?) (uint8_t)\n                percentUsed               : Percent used GPS (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npiloting console PWM messges. year : Year reported by Gps (uint8_t) month : Month reported by Gps (uint8_t) day : Day reported by Gps (uint8_t) hour : Hour reported by Gps (uint8_t) min : Min reported by Gps (uint8_t) sec : Sec reported by Gps (uint8_t) clockStat : Clock Status. See table 47 page 211 OEMStar Manual (uint8_t) visSat : Visible satellites reported by Gps (uint8_t) useSat : Used satellites in Solution (uint8_t) GppGl : GPS+GLONASS satellites in Solution (uint8_t) sigUsedMask : GPS and GLONASS usage mask (bit 0 GPS_used? bit_4 GLONASS_used?) (uint8_t) percentUsed : Percent used GPS (uint8_t)", "response": "def gps_date_time_send(self, year, month, day, hour, min, sec, clockStat, visSat, useSat, GppGl, sigUsedMask, percentUsed, force_mavlink1=False):\n                '''\n                Pilot console PWM messges.\n\n                year                      : Year reported by Gps (uint8_t)\n                month                     : Month reported by Gps (uint8_t)\n                day                       : Day reported by Gps (uint8_t)\n                hour                      : Hour reported by Gps (uint8_t)\n                min                       : Min reported by Gps (uint8_t)\n                sec                       : Sec reported by Gps (uint8_t)\n                clockStat                 : Clock Status. See table 47 page 211 OEMStar Manual (uint8_t)\n                visSat                    : Visible satellites reported by Gps (uint8_t)\n                useSat                    : Used satellites in Solution (uint8_t)\n                GppGl                     : GPS+GLONASS satellites in Solution (uint8_t)\n                sigUsedMask               : GPS and GLONASS usage mask (bit 0 GPS_used? bit_4 GLONASS_used?) (uint8_t)\n                percentUsed               : Percent used GPS (uint8_t)\n\n                '''\n                return self.send(self.gps_date_time_encode(year, month, day, hour, min, sec, clockStat, visSat, useSat, GppGl, sigUsedMask, percentUsed), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mid_lvl_cmds_send(self, target, hCommand, uCommand, rCommand, force_mavlink1=False):\n                '''\n                Mid Level commands sent from the GS to the autopilot. These are only\n                sent when being operated in mid-level commands mode\n                from the ground.\n\n                target                    : The system setting the commands (uint8_t)\n                hCommand                  : Commanded Altitude in meters (float)\n                uCommand                  : Commanded Airspeed in m/s (float)\n                rCommand                  : Commanded Turnrate in rad/s (float)\n\n                '''\n                return self.send(self.mid_lvl_cmds_encode(target, hCommand, uCommand, rCommand), force_mavlink1=force_mavlink1)", "response": "Mid Level commands sent from the GS to the autopilot."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nordering generated to the SLUGS camera mount. target : The system reporting the action (uint8_t) pan : Order the mount to pan: -1 left, 0 No pan motion, +1 right (int8_t) tilt : Order the mount to tilt: -1 down, 0 No tilt motion, +1 up (int8_t) zoom : Order the zoom values 0 to 10 (int8_t) moveHome : Orders the camera mount to move home. The other fields are ignored when this field is set. 1: move home, 0 ignored (int8_t)", "response": "def slugs_camera_order_encode(self, target, pan, tilt, zoom, moveHome):\n                '''\n                Orders generated to the SLUGS camera mount.\n\n                target                    : The system reporting the action (uint8_t)\n                pan                       : Order the mount to pan: -1 left, 0 No pan motion, +1 right (int8_t)\n                tilt                      : Order the mount to tilt: -1 down, 0 No tilt motion, +1 up (int8_t)\n                zoom                      : Order the zoom values 0 to 10 (int8_t)\n                moveHome                  : Orders the camera mount to move home. The other fields are ignored when this field is set. 1: move home, 0 ignored (int8_t)\n\n                '''\n                return MAVLink_slugs_camera_order_message(target, pan, tilt, zoom, moveHome)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nordering generated to the SLUGS camera mount. target : The system reporting the action (uint8_t) pan : Order the mount to pan: -1 left, 0 No pan motion, +1 right (int8_t) tilt : Order the mount to tilt: -1 down, 0 No tilt motion, +1 up (int8_t) zoom : Order the zoom values 0 to 10 (int8_t) moveHome : Orders the camera mount to move home. The other fields are ignored when this field is set. 1: move home, 0 ignored (int8_t)", "response": "def slugs_camera_order_send(self, target, pan, tilt, zoom, moveHome, force_mavlink1=False):\n                '''\n                Orders generated to the SLUGS camera mount.\n\n                target                    : The system reporting the action (uint8_t)\n                pan                       : Order the mount to pan: -1 left, 0 No pan motion, +1 right (int8_t)\n                tilt                      : Order the mount to tilt: -1 down, 0 No tilt motion, +1 up (int8_t)\n                zoom                      : Order the zoom values 0 to 10 (int8_t)\n                moveHome                  : Orders the camera mount to move home. The other fields are ignored when this field is set. 1: move home, 0 ignored (int8_t)\n\n                '''\n                return self.send(self.slugs_camera_order_encode(target, pan, tilt, zoom, moveHome), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncontrols for surface ; pending and order to origin.", "response": "def control_surface_encode(self, target, idSurface, mControl, bControl):\n                '''\n                Control for surface; pending and order to origin.\n\n                target                    : The system setting the commands (uint8_t)\n                idSurface                 : ID control surface send 0: throttle 1: aileron 2: elevator 3: rudder (uint8_t)\n                mControl                  : Pending (float)\n                bControl                  : Order to origin (float)\n\n                '''\n                return MAVLink_control_surface_message(target, idSurface, mControl, bControl)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncontrolling for surface ; pending and order to origin.", "response": "def control_surface_send(self, target, idSurface, mControl, bControl, force_mavlink1=False):\n                '''\n                Control for surface; pending and order to origin.\n\n                target                    : The system setting the commands (uint8_t)\n                idSurface                 : ID control surface send 0: throttle 1: aileron 2: elevator 3: rudder (uint8_t)\n                mControl                  : Pending (float)\n                bControl                  : Order to origin (float)\n\n                '''\n                return self.send(self.control_surface_encode(target, idSurface, mControl, bControl), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntransmits the last known position of the mobile GS to the UAV. Very relevant when Track Mobile is enabled target : The system reporting the action (uint8_t) latitude : Mobile Latitude (float) longitude : Mobile Longitude (float)", "response": "def slugs_mobile_location_send(self, target, latitude, longitude, force_mavlink1=False):\n                '''\n                Transmits the last known position of the mobile GS to the UAV. Very\n                relevant when Track Mobile is enabled\n\n                target                    : The system reporting the action (uint8_t)\n                latitude                  : Mobile Latitude (float)\n                longitude                 : Mobile Longitude (float)\n\n                '''\n                return self.send(self.slugs_mobile_location_encode(target, latitude, longitude), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncontrol for camara. target : The system setting the commands (uint8_t) idOrder : ID 0: brightness 1: aperture 2: iris 3: ICR 4: backlight (uint8_t) order : 1: up/on 2: down/off 3: auto/reset/no action (uint8_t)", "response": "def slugs_configuration_camera_send(self, target, idOrder, order, force_mavlink1=False):\n                '''\n                Control for camara.\n\n                target                    : The system setting the commands (uint8_t)\n                idOrder                   : ID 0: brightness 1: aperture 2: iris 3: ICR 4: backlight (uint8_t)\n                order                     : 1: up/on 2: down/off 3: auto/reset/no action (uint8_t)\n\n                '''\n                return self.send(self.slugs_configuration_camera_encode(target, idOrder, order), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntransmitting the position of watch target : The system reporting the action (uint8_t) latitude : ISR Latitude (float) longitude : ISR Longitude (float) height : ISR Height (float) option1 : Option 1 (uint8_t) option2 : Option 2 (uint8_t) option3 : Option 3 (uint8_t)", "response": "def isr_location_encode(self, target, latitude, longitude, height, option1, option2, option3):\n                '''\n                Transmits the position of watch\n\n                target                    : The system reporting the action (uint8_t)\n                latitude                  : ISR Latitude (float)\n                longitude                 : ISR Longitude (float)\n                height                    : ISR Height (float)\n                option1                   : Option 1 (uint8_t)\n                option2                   : Option 2 (uint8_t)\n                option3                   : Option 3 (uint8_t)\n\n                '''\n                return MAVLink_isr_location_message(target, latitude, longitude, height, option1, option2, option3)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntransmit the position of watch target : The system reporting the action (uint8_t) latitude : ISR Latitude (float) longitude : ISR Longitude (float) height : ISR Height (float) option1 : Option 1 (uint8_t) option2 : Option 2 (uint8_t) option3 : Option 3 (uint8_t)", "response": "def isr_location_send(self, target, latitude, longitude, height, option1, option2, option3, force_mavlink1=False):\n                '''\n                Transmits the position of watch\n\n                target                    : The system reporting the action (uint8_t)\n                latitude                  : ISR Latitude (float)\n                longitude                 : ISR Longitude (float)\n                height                    : ISR Height (float)\n                option1                   : Option 1 (uint8_t)\n                option2                   : Option 2 (uint8_t)\n                option3                   : Option 3 (uint8_t)\n\n                '''\n                return self.send(self.isr_location_encode(target, latitude, longitude, height, option1, option2, option3), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef volt_sensor_send(self, r2Type, voltage, reading2, force_mavlink1=False):\n                '''\n                Transmits the readings from the voltage and current sensors\n\n                r2Type                    : It is the value of reading 2: 0 - Current, 1 - Foreward Sonar, 2 - Back Sonar, 3 - RPM (uint8_t)\n                voltage                   : Voltage in uS of PWM. 0 uS = 0V, 20 uS = 21.5V (uint16_t)\n                reading2                  : Depends on the value of r2Type (0) Current consumption in uS of PWM, 20 uS = 90Amp (1) Distance in cm (2) Distance in cm (3) Absolute value (uint16_t)\n\n                '''\n                return self.send(self.volt_sensor_encode(r2Type, voltage, reading2), force_mavlink1=force_mavlink1)", "response": "This message is used to send the voltage and current sensors."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntransmitting the actual Pan, Tilt and Zoom values of the camera unit zoom : The actual Zoom Value (uint8_t) pan : The Pan value in 10ths of degree (int16_t) tilt : The Tilt value in 10ths of degree (int16_t)", "response": "def ptz_status_send(self, zoom, pan, tilt, force_mavlink1=False):\n                '''\n                Transmits the actual Pan, Tilt and Zoom values of the camera unit\n\n                zoom                      : The actual Zoom Value (uint8_t)\n                pan                       : The Pan value in 10ths of degree (int16_t)\n                tilt                      : The Tilt value in 10ths of degree (int16_t)\n\n                '''\n                return self.send(self.ptz_status_encode(zoom, pan, tilt), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef uav_status_encode(self, target, latitude, longitude, altitude, speed, course):\n                '''\n                Transmits the actual status values UAV in flight\n\n                target                    : The ID system reporting the action (uint8_t)\n                latitude                  : Latitude UAV (float)\n                longitude                 : Longitude UAV (float)\n                altitude                  : Altitude UAV (float)\n                speed                     : Speed UAV (float)\n                course                    : Course UAV (float)\n\n                '''\n                return MAVLink_uav_status_message(target, latitude, longitude, altitude, speed, course)", "response": "This function is called when the MAVLink is about to update the status of the UAV in flight."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef uav_status_send(self, target, latitude, longitude, altitude, speed, course, force_mavlink1=False):\n                '''\n                Transmits the actual status values UAV in flight\n\n                target                    : The ID system reporting the action (uint8_t)\n                latitude                  : Latitude UAV (float)\n                longitude                 : Longitude UAV (float)\n                altitude                  : Altitude UAV (float)\n                speed                     : Speed UAV (float)\n                course                    : Course UAV (float)\n\n                '''\n                return self.send(self.uav_status_encode(target, latitude, longitude, altitude, speed, course), force_mavlink1=force_mavlink1)", "response": "Status of UAV in flight"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef status_gps_encode(self, csFails, gpsQuality, msgsType, posStatus, magVar, magDir, modeInd):\n                '''\n                This contains the status of the GPS readings\n\n                csFails                   : Number of times checksum has failed (uint16_t)\n                gpsQuality                : The quality indicator, 0=fix not available or invalid, 1=GPS fix, 2=C/A differential GPS, 6=Dead reckoning mode, 7=Manual input mode (fixed position), 8=Simulator mode, 9= WAAS a (uint8_t)\n                msgsType                  : Indicates if GN, GL or GP messages are being received (uint8_t)\n                posStatus                 : A = data valid, V = data invalid (uint8_t)\n                magVar                    : Magnetic variation, degrees (float)\n                magDir                    : Magnetic variation direction E/W. Easterly variation (E) subtracts from True course and Westerly variation (W) adds to True course (int8_t)\n                modeInd                   : Positioning system mode indicator. A - Autonomous;D-Differential; E-Estimated (dead reckoning) mode;M-Manual input; N-Data not valid (uint8_t)\n\n                '''\n                return MAVLink_status_gps_message(csFails, gpsQuality, msgsType, posStatus, magVar, magDir, modeInd)", "response": "Status of GPS readings"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntransmit the diagnostics data from the Novatel OEMStar GPS timeStatus : The Time Status. See Table 8 page 27 Novatel OEMStar Manual (uint8_t) receiverStatus : Status Bitfield. See table 69 page 350 Novatel OEMstar Manual (uint32_t) solStatus : solution Status. See table 44 page 197 (uint8_t) posType : position type. See table 43 page 196 (uint8_t) velType : velocity type. See table 43 page 196 (uint8_t) posSolAge : Age of the position solution in seconds (float) csFails : Times the CRC has failed since boot (uint16_t)", "response": "def novatel_diag_encode(self, timeStatus, receiverStatus, solStatus, posType, velType, posSolAge, csFails):\n                '''\n                Transmits the diagnostics data from the Novatel OEMStar GPS\n\n                timeStatus                : The Time Status. See Table 8 page 27 Novatel OEMStar Manual (uint8_t)\n                receiverStatus            : Status Bitfield. See table 69 page 350 Novatel OEMstar Manual (uint32_t)\n                solStatus                 : solution Status. See table 44 page 197 (uint8_t)\n                posType                   : position type. See table 43 page 196 (uint8_t)\n                velType                   : velocity type. See table 43 page 196 (uint8_t)\n                posSolAge                 : Age of the position solution in seconds (float)\n                csFails                   : Times the CRC has failed since boot (uint16_t)\n\n                '''\n                return MAVLink_novatel_diag_message(timeStatus, receiverStatus, solStatus, posType, velType, posSolAge, csFails)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef novatel_diag_send(self, timeStatus, receiverStatus, solStatus, posType, velType, posSolAge, csFails, force_mavlink1=False):\n                '''\n                Transmits the diagnostics data from the Novatel OEMStar GPS\n\n                timeStatus                : The Time Status. See Table 8 page 27 Novatel OEMStar Manual (uint8_t)\n                receiverStatus            : Status Bitfield. See table 69 page 350 Novatel OEMstar Manual (uint32_t)\n                solStatus                 : solution Status. See table 44 page 197 (uint8_t)\n                posType                   : position type. See table 43 page 196 (uint8_t)\n                velType                   : velocity type. See table 43 page 196 (uint8_t)\n                posSolAge                 : Age of the position solution in seconds (float)\n                csFails                   : Times the CRC has failed since boot (uint16_t)\n\n                '''\n                return self.send(self.novatel_diag_encode(timeStatus, receiverStatus, solStatus, posType, velType, posSolAge, csFails), force_mavlink1=force_mavlink1)", "response": "Diagnostics data from the Novatel OEMStar."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sensor_diag_encode(self, float1, float2, int1, char1):\n                '''\n                Diagnostic data Sensor MCU\n\n                float1                    : Float field 1 (float)\n                float2                    : Float field 2 (float)\n                int1                      : Int 16 field 1 (int16_t)\n                char1                     : Int 8 field 1 (int8_t)\n\n                '''\n                return MAVLink_sensor_diag_message(float1, float2, int1, char1)", "response": "This function encodes the diagnostic data of a sensor"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef script_item_encode(self, target_system, target_component, seq, name):\n                '''\n                Message encoding a mission script item. This message is emitted upon a\n                request for the next script item.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seq                       : Sequence (uint16_t)\n                name                      : The name of the mission script, NULL terminated. (char)\n\n                '''\n                return MAVLink_script_item_message(target_system, target_component, seq, name)", "response": "Encode a mission script item"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef script_item_send(self, target_system, target_component, seq, name, force_mavlink1=False):\n                '''\n                Message encoding a mission script item. This message is emitted upon a\n                request for the next script item.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seq                       : Sequence (uint16_t)\n                name                      : The name of the mission script, NULL terminated. (char)\n\n                '''\n                return self.send(self.script_item_encode(target_system, target_component, seq, name), force_mavlink1=force_mavlink1)", "response": "This message is emitted upon the next mission script item. It is used to send a mission script item."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef script_request_send(self, target_system, target_component, seq, force_mavlink1=False):\n                '''\n                Request script item with the sequence number seq. The response of the\n                system to this message should be a SCRIPT_ITEM\n                message.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seq                       : Sequence (uint16_t)\n\n                '''\n                return self.send(self.script_request_encode(target_system, target_component, seq), force_mavlink1=force_mavlink1)", "response": "Request the next script item with the given sequence number."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef script_request_list_send(self, target_system, target_component, force_mavlink1=False):\n                '''\n                Request the overall list of mission items from the system/component.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n\n                '''\n                return self.send(self.script_request_list_encode(target_system, target_component), force_mavlink1=force_mavlink1)", "response": "Request the overall list of mission items from the system and component."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef script_count_send(self, target_system, target_component, count, force_mavlink1=False):\n                '''\n                This message is emitted as response to SCRIPT_REQUEST_LIST by the MAV\n                to get the number of mission scripts.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                count                     : Number of script items in the sequence (uint16_t)\n\n                '''\n                return self.send(self.script_count_encode(target_system, target_component, count), force_mavlink1=force_mavlink1)", "response": "This message is emitted as response to SCRIPT_REQUEST_LIST by the MAV\n                protocol."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating main header per XML file", "response": "def generate_main_h(directory, xml):\n    '''generate main header per XML file'''\n    f = open(os.path.join(directory, xml.basename + \".h\"), mode='w')\n    t.write(f, '''\n/** @file\n *\t@brief MAVLink comm protocol generated from ${basename}.xml\n *\t@see http://mavlink.org\n */\n#pragma once\n#ifndef MAVLINK_${basename_upper}_H\n#define MAVLINK_${basename_upper}_H\n\n#ifndef MAVLINK_H\n    #error Wrong include order: MAVLINK_${basename_upper}.H MUST NOT BE DIRECTLY USED. Include mavlink.h from the same directory instead or set ALL AND EVERY defines from MAVLINK.H manually accordingly, including the #define MAVLINK_H call.\n#endif\n\n#undef MAVLINK_THIS_XML_IDX\n#define MAVLINK_THIS_XML_IDX ${xml_idx}\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// MESSAGE LENGTHS AND CRCS\n\n#ifndef MAVLINK_MESSAGE_LENGTHS\n#define MAVLINK_MESSAGE_LENGTHS {${message_lengths_array}}\n#endif\n\n#ifndef MAVLINK_MESSAGE_CRCS\n#define MAVLINK_MESSAGE_CRCS {${message_crcs_array}}\n#endif\n\n#include \"../protocol.h\"\n\n#define MAVLINK_ENABLED_${basename_upper}\n\n// ENUM DEFINITIONS\n\n${{enum:\n/** @brief ${description} */\n#ifndef HAVE_ENUM_${name}\n#define HAVE_ENUM_${name}\ntypedef enum ${name}\n{\n${{entry:\t${name}=${value}, /* ${description} |${{param:${description}| }} */\n}}\n} ${name};\n#endif\n}}\n\n// MAVLINK VERSION\n\n#ifndef MAVLINK_VERSION\n#define MAVLINK_VERSION ${version}\n#endif\n\n#if (MAVLINK_VERSION == 0)\n#undef MAVLINK_VERSION\n#define MAVLINK_VERSION ${version}\n#endif\n\n// MESSAGE DEFINITIONS\n${{message:#include \"./mavlink_msg_${name_lower}.h\"\n}}\n\n// base include\n${{include_list:#include \"../${base}/${base}.h\"\n}}\n\n#undef MAVLINK_THIS_XML_IDX\n#define MAVLINK_THIS_XML_IDX ${xml_idx}\n\n#if MAVLINK_THIS_XML_IDX == MAVLINK_PRIMARY_XML_IDX\n# define MAVLINK_MESSAGE_INFO {${message_info_array}}\n# if MAVLINK_COMMAND_24BIT\n#  include \"../mavlink_get_info.h\"\n# endif\n#endif\n\n#ifdef __cplusplus\n}\n#endif // __cplusplus\n#endif // MAVLINK_${basename_upper}_H\n''', xml)\n\n    f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_message_h(directory, m):\n    '''generate per-message header for a XML file'''\n    f = open(os.path.join(directory, 'mavlink_msg_%s.h' % m.name_lower), mode='w')\n    t.write(f, '''\n#pragma once\n// MESSAGE ${name} PACKING\n\n#define MAVLINK_MSG_ID_${name} ${id}\n\nMAVPACKED(\ntypedef struct __mavlink_${name_lower}_t {\n${{ordered_fields: ${type} ${name}${array_suffix}; /*< ${description}*/\n}}\n}) mavlink_${name_lower}_t;\n\n#define MAVLINK_MSG_ID_${name}_LEN ${wire_length}\n#define MAVLINK_MSG_ID_${name}_MIN_LEN ${wire_min_length}\n#define MAVLINK_MSG_ID_${id}_LEN ${wire_length}\n#define MAVLINK_MSG_ID_${id}_MIN_LEN ${wire_min_length}\n\n#define MAVLINK_MSG_ID_${name}_CRC ${crc_extra}\n#define MAVLINK_MSG_ID_${id}_CRC ${crc_extra}\n\n${{array_fields:#define MAVLINK_MSG_${msg_name}_FIELD_${name_upper}_LEN ${array_length}\n}}\n\n#if MAVLINK_COMMAND_24BIT\n#define MAVLINK_MESSAGE_INFO_${name} { \\\\\n\t${id}, \\\\\n\t\"${name}\", \\\\\n\t${num_fields}, \\\\\n\t{ ${{ordered_fields: { \"${name}\", ${c_print_format}, MAVLINK_TYPE_${type_upper}, ${array_length}, ${wire_offset}, offsetof(mavlink_${name_lower}_t, ${name}) }, \\\\\n        }} } \\\\\n}\n#else\n#define MAVLINK_MESSAGE_INFO_${name} { \\\\\n\t\"${name}\", \\\\\n\t${num_fields}, \\\\\n\t{ ${{ordered_fields: { \"${name}\", ${c_print_format}, MAVLINK_TYPE_${type_upper}, ${array_length}, ${wire_offset}, offsetof(mavlink_${name_lower}_t, ${name}) }, \\\\\n        }} } \\\\\n}\n#endif\n\n/**\n * @brief Pack a ${name_lower} message\n * @param system_id ID of this system\n * @param component_id ID of this component (e.g. 200 for IMU)\n * @param msg The MAVLink message to compress the data into\n *\n${{arg_fields: * @param ${name} ${description}\n}}\n * @return length of the message in bytes (excluding serial stream start sign)\n */\nstatic inline uint16_t mavlink_msg_${name_lower}_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,\n\t\t\t\t\t\t      ${{arg_fields: ${array_const}${type} ${array_prefix}${name},}})\n{\n#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS\n\tchar buf[MAVLINK_MSG_ID_${name}_LEN];\n${{scalar_fields:\t_mav_put_${type}(buf, ${wire_offset}, ${putname});\n}}\n${{array_fields:\t_mav_put_${type}_array(buf, ${wire_offset}, ${name}, ${array_length});\n}}\n        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_${name}_LEN);\n#else\n\tmavlink_${name_lower}_t packet;\n${{scalar_fields:\tpacket.${name} = ${putname};\n}}\n${{array_fields:\tmav_array_memcpy(packet.${name}, ${name}, sizeof(${type})*${array_length});\n}}\n        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_${name}_LEN);\n#endif\n\n\tmsg->msgid = MAVLINK_MSG_ID_${name};\n    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_${name}_MIN_LEN, MAVLINK_MSG_ID_${name}_LEN, MAVLINK_MSG_ID_${name}_CRC);\n}\n\n/**\n * @brief Pack a ${name_lower} message on a channel\n * @param system_id ID of this system\n * @param component_id ID of this component (e.g. 200 for IMU)\n * @param chan The MAVLink channel this message will be sent over\n * @param msg The MAVLink message to compress the data into\n${{arg_fields: * @param ${name} ${description}\n}}\n * @return length of the message in bytes (excluding serial stream start sign)\n */\nstatic inline uint16_t mavlink_msg_${name_lower}_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,\n\t\t\t\t\t\t\t   mavlink_message_t* msg,\n\t\t\t\t\t\t           ${{arg_fields:${array_const}${type} ${array_prefix}${name},}})\n{\n#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS\n\tchar buf[MAVLINK_MSG_ID_${name}_LEN];\n${{scalar_fields:\t_mav_put_${type}(buf, ${wire_offset}, ${putname});\n}}\n${{array_fields:\t_mav_put_${type}_array(buf, ${wire_offset}, ${name}, ${array_length});\n}}\n        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_${name}_LEN);\n#else\n\tmavlink_${name_lower}_t packet;\n${{scalar_fields:\tpacket.${name} = ${putname};\n}}\n${{array_fields:\tmav_array_memcpy(packet.${name}, ${name}, sizeof(${type})*${array_length});\n}}\n        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_${name}_LEN);\n#endif\n\n\tmsg->msgid = MAVLINK_MSG_ID_${name};\n    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_${name}_MIN_LEN, MAVLINK_MSG_ID_${name}_LEN, MAVLINK_MSG_ID_${name}_CRC);\n}\n\n/**\n * @brief Encode a ${name_lower} struct\n *\n * @param system_id ID of this system\n * @param component_id ID of this component (e.g. 200 for IMU)\n * @param msg The MAVLink message to compress the data into\n * @param ${name_lower} C-struct to read the message contents from\n */\nstatic inline uint16_t mavlink_msg_${name_lower}_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_${name_lower}_t* ${name_lower})\n{\n\treturn mavlink_msg_${name_lower}_pack(system_id, component_id, msg,${{arg_fields: ${name_lower}->${name},}});\n}\n\n/**\n * @brief Encode a ${name_lower} struct on a channel\n *\n * @param system_id ID of this system\n * @param component_id ID of this component (e.g. 200 for IMU)\n * @param chan The MAVLink channel this message will be sent over\n * @param msg The MAVLink message to compress the data into\n * @param ${name_lower} C-struct to read the message contents from\n */\nstatic inline uint16_t mavlink_msg_${name_lower}_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_${name_lower}_t* ${name_lower})\n{\n\treturn mavlink_msg_${name_lower}_pack_chan(system_id, component_id, chan, msg,${{arg_fields: ${name_lower}->${name},}});\n}\n\n/**\n * @brief Send a ${name_lower} message\n * @param chan MAVLink channel to send the message\n *\n${{arg_fields: * @param ${name} ${description}\n}}\n */\n#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS\n\nstatic inline void mavlink_msg_${name_lower}_send(mavlink_channel_t chan,${{arg_fields: ${array_const}${type} ${array_prefix}${name},}})\n{\n#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS\n\tchar buf[MAVLINK_MSG_ID_${name}_LEN];\n${{scalar_fields:\t_mav_put_${type}(buf, ${wire_offset}, ${putname});\n}}\n${{array_fields:\t_mav_put_${type}_array(buf, ${wire_offset}, ${name}, ${array_length});\n}}\n    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_${name}, buf, MAVLINK_MSG_ID_${name}_MIN_LEN, MAVLINK_MSG_ID_${name}_LEN, MAVLINK_MSG_ID_${name}_CRC);\n#else\n\tmavlink_${name_lower}_t packet;\n${{scalar_fields:\tpacket.${name} = ${putname};\n}}\n${{array_fields:\tmav_array_memcpy(packet.${name}, ${name}, sizeof(${type})*${array_length});\n}}\n    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_${name}, (const char *)&packet, MAVLINK_MSG_ID_${name}_MIN_LEN, MAVLINK_MSG_ID_${name}_LEN, MAVLINK_MSG_ID_${name}_CRC);\n#endif\n}\n\n/**\n * @brief Send a ${name_lower} message\n * @param chan MAVLink channel to send the message\n * @param struct The MAVLink struct to serialize\n */\nstatic inline void mavlink_msg_${name_lower}_send_struct(mavlink_channel_t chan, const mavlink_${name_lower}_t* ${name_lower})\n{\n#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS\n    mavlink_msg_${name_lower}_send(chan,${{arg_fields: ${name_lower}->${name},}});\n#else\n    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_${name}, (const char *)${name_lower}, MAVLINK_MSG_ID_${name}_MIN_LEN, MAVLINK_MSG_ID_${name}_LEN, MAVLINK_MSG_ID_${name}_CRC);\n#endif\n}\n\n#if MAVLINK_MSG_ID_${name}_LEN <= MAVLINK_MAX_PAYLOAD_LEN\n/*\n  This varient of _send() can be used to save stack space by re-using\n  memory from the receive buffer.  The caller provides a\n  mavlink_message_t which is the size of a full mavlink message. This\n  is usually the receive buffer for the channel, and allows a reply to an\n  incoming message with minimum stack space usage.\n */\nstatic inline void mavlink_msg_${name_lower}_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan, ${{arg_fields: ${array_const}${type} ${array_prefix}${name},}})\n{\n#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS\n\tchar *buf = (char *)msgbuf;\n${{scalar_fields:\t_mav_put_${type}(buf, ${wire_offset}, ${putname});\n}}\n${{array_fields:\t_mav_put_${type}_array(buf, ${wire_offset}, ${name}, ${array_length});\n}}\n    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_${name}, buf, MAVLINK_MSG_ID_${name}_MIN_LEN, MAVLINK_MSG_ID_${name}_LEN, MAVLINK_MSG_ID_${name}_CRC);\n#else\n\tmavlink_${name_lower}_t *packet = (mavlink_${name_lower}_t *)msgbuf;\n${{scalar_fields:\tpacket->${name} = ${putname};\n}}\n${{array_fields:\tmav_array_memcpy(packet->${name}, ${name}, sizeof(${type})*${array_length});\n}}\n    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_${name}, (const char *)packet, MAVLINK_MSG_ID_${name}_MIN_LEN, MAVLINK_MSG_ID_${name}_LEN, MAVLINK_MSG_ID_${name}_CRC);\n#endif\n}\n#endif\n\n#endif\n\n// MESSAGE ${name} UNPACKING\n\n${{fields:\n/**\n * @brief Get field ${name} from ${name_lower} message\n *\n * @return ${description}\n */\nstatic inline ${return_type} mavlink_msg_${name_lower}_get_${name}(const mavlink_message_t* msg${get_arg})\n{\n\treturn _MAV_RETURN_${type}${array_tag}(msg, ${array_return_arg} ${wire_offset});\n}\n}}\n\n/**\n * @brief Decode a ${name_lower} message into a struct\n *\n * @param msg The message to decode\n * @param ${name_lower} C-struct to decode the message contents into\n */\nstatic inline void mavlink_msg_${name_lower}_decode(const mavlink_message_t* msg, mavlink_${name_lower}_t* ${name_lower})\n{\n#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS\n${{ordered_fields:\t${decode_left}mavlink_msg_${name_lower}_get_${name}(msg${decode_right});\n}}\n#else\n        uint8_t len = msg->len < MAVLINK_MSG_ID_${name}_LEN? msg->len : MAVLINK_MSG_ID_${name}_LEN;\n        memset(${name_lower}, 0, MAVLINK_MSG_ID_${name}_LEN);\n\tmemcpy(${name_lower}, _MAV_PAYLOAD(msg), len);\n#endif\n}\n''', m)\n    f.close()", "response": "generate per - message header for a MAVLink message"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy_fixed_headers(directory, xml):\n    '''copy the fixed protocol headers to the target directory'''\n    import shutil, filecmp\n    hlist = {\n        \"0.9\": [ 'protocol.h', 'mavlink_helpers.h', 'mavlink_types.h', 'checksum.h' ],\n        \"1.0\": [ 'protocol.h', 'mavlink_helpers.h', 'mavlink_types.h', 'checksum.h', 'mavlink_conversions.h' ],\n        \"2.0\": [ 'protocol.h', 'mavlink_helpers.h', 'mavlink_types.h', 'checksum.h', 'mavlink_conversions.h',\n                 'mavlink_get_info.h', 'mavlink_sha256.h' ]\n        }\n    basepath = os.path.dirname(os.path.realpath(__file__))\n    srcpath = os.path.join(basepath, 'C/include_v%s' % xml.wire_protocol_version)\n    print(\"Copying fixed headers for protocol %s to %s\" % (xml.wire_protocol_version, directory))\n    for h in hlist[xml.wire_protocol_version]:\n        src = os.path.realpath(os.path.join(srcpath, h))\n        dest = os.path.realpath(os.path.join(directory, h))\n        if src == dest or (os.path.exists(dest) and filecmp.cmp(src, dest)):\n            continue\n        shutil.copy(src, dest)", "response": "copy the fixed protocol headers to the target directory"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates one XML file", "response": "def generate_one(basename, xml):\n    '''generate headers for one XML file'''\n\n    directory = os.path.join(basename, xml.basename)\n\n    print(\"Generating C implementation in directory %s\" % directory)\n    mavparse.mkdir_p(directory)\n\n    if xml.little_endian:\n        xml.mavlink_endian = \"MAVLINK_LITTLE_ENDIAN\"\n    else:\n        xml.mavlink_endian = \"MAVLINK_BIG_ENDIAN\"\n\n    if xml.crc_extra:\n        xml.crc_extra_define = \"1\"\n    else:\n        xml.crc_extra_define = \"0\"\n\n    if xml.command_24bit:\n        xml.command_24bit_define = \"1\"\n    else:\n        xml.command_24bit_define = \"0\"\n\n    if xml.sort_fields:\n        xml.aligned_fields_define = \"1\"\n    else:\n        xml.aligned_fields_define = \"0\"\n\n    # work out the included headers\n    xml.include_list = []\n    for i in xml.include:\n        base = i[:-4]\n        xml.include_list.append(mav_include(base))\n\n    # form message lengths array\n    xml.message_lengths_array = ''\n    if not xml.command_24bit:\n        for msgid in range(256):\n            mlen = xml.message_min_lengths.get(msgid, 0)\n            xml.message_lengths_array += '%u, ' % mlen\n        xml.message_lengths_array = xml.message_lengths_array[:-2]\n\n    # and message CRCs array\n    xml.message_crcs_array = ''\n    if xml.command_24bit:\n        # we sort with primary key msgid\n        for msgid in sorted(xml.message_crcs.keys()):\n            xml.message_crcs_array += '{%u, %u, %u, %u, %u, %u}, ' % (msgid,\n                                                                      xml.message_crcs[msgid],\n                                                                      xml.message_min_lengths[msgid],\n                                                                      xml.message_flags[msgid],\n                                                                      xml.message_target_system_ofs[msgid],\n                                                                      xml.message_target_component_ofs[msgid])\n    else:\n        for msgid in range(256):\n            crc = xml.message_crcs.get(msgid, 0)\n            xml.message_crcs_array += '%u, ' % crc\n    xml.message_crcs_array = xml.message_crcs_array[:-2]\n\n    # form message info array\n    xml.message_info_array = ''\n    if xml.command_24bit:\n        # we sort with primary key msgid\n        for msgid in sorted(xml.message_names.keys()):\n            name = xml.message_names[msgid]\n            xml.message_info_array += 'MAVLINK_MESSAGE_INFO_%s, ' % name\n    else:\n        for msgid in range(256):\n            name = xml.message_names.get(msgid, None)\n            if name is not None:\n                xml.message_info_array += 'MAVLINK_MESSAGE_INFO_%s, ' % name\n            else:\n                # Several C compilers don't accept {NULL} for\n                # multi-dimensional arrays and structs\n                # feed the compiler a \"filled\" empty message\n                xml.message_info_array += '{\"EMPTY\",0,{{\"\",\"\",MAVLINK_TYPE_CHAR,0,0,0}}}, '\n    xml.message_info_array = xml.message_info_array[:-2]\n\n    # add some extra field attributes for convenience with arrays\n    for m in xml.message:\n        m.msg_name = m.name\n        if xml.crc_extra:\n            m.crc_extra_arg = \", %s\" % m.crc_extra\n        else:\n            m.crc_extra_arg = \"\"\n        for f in m.fields:\n            if f.print_format is None:\n                f.c_print_format = 'NULL'\n            else:\n                f.c_print_format = '\"%s\"' % f.print_format\n            if f.array_length != 0:\n                f.array_suffix = '[%u]' % f.array_length\n                f.array_prefix = '*'\n                f.array_tag = '_array'\n                f.array_arg = ', %u' % f.array_length\n                f.array_return_arg = '%s, %u, ' % (f.name, f.array_length)\n                f.array_const = 'const '\n                f.decode_left = ''\n                f.decode_right = ', %s->%s' % (m.name_lower, f.name)\n                f.return_type = 'uint16_t'\n                f.get_arg = ', %s *%s' % (f.type, f.name)\n                if f.type == 'char':\n                    f.c_test_value = '\"%s\"' % f.test_value\n                else:\n                    test_strings = []\n                    for v in f.test_value:\n                        test_strings.append(str(v))\n                    f.c_test_value = '{ %s }' % ', '.join(test_strings)\n            else:\n                f.array_suffix = ''\n                f.array_prefix = ''\n                f.array_tag = ''\n                f.array_arg = ''\n                f.array_return_arg = ''\n                f.array_const = ''\n                f.decode_left = \"%s->%s = \" % (m.name_lower, f.name)\n                f.decode_right = ''\n                f.get_arg = ''\n                f.return_type = f.type\n                if f.type == 'char':\n                    f.c_test_value = \"'%s'\" % f.test_value\n                elif f.type == 'uint64_t':\n                    f.c_test_value = \"%sULL\" % f.test_value                    \n                elif f.type == 'int64_t':\n                    f.c_test_value = \"%sLL\" % f.test_value                    \n                else:\n                    f.c_test_value = f.test_value\n\n    # cope with uint8_t_mavlink_version\n    for m in xml.message:\n        m.arg_fields = []\n        m.array_fields = []\n        m.scalar_fields = []\n        for f in m.ordered_fields:\n            if f.array_length != 0:\n                m.array_fields.append(f)\n            else:\n                m.scalar_fields.append(f)\n        for f in m.fields:\n            if not f.omit_arg:\n                m.arg_fields.append(f)\n                f.putname = f.name\n            else:\n                f.putname = f.const_value\n\n    generate_mavlink_h(directory, xml)\n    generate_version_h(directory, xml)\n    generate_main_h(directory, xml)\n    for m in xml.message:\n        generate_message_h(directory, m)\n    generate_testsuite_h(directory, xml)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate(basename, xml_list):\n    '''generate complete MAVLink C implemenation'''\n\n    for idx in range(len(xml_list)):\n        xml = xml_list[idx]\n        xml.xml_idx = idx\n        generate_one(basename, xml)\n    copy_fixed_headers(basename, xml_list[0])", "response": "generate complete MAVLink C implemenation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the current Pose3d object with the current Pose3d data.", "response": "def update(self):\n        '''\n        Updates Pose3d.\n        '''\n        pos = Pose3d()\n        if self.hasproxy():\n            pose = self.proxy.getPose3DData()\n            pos.yaw = self.quat2Yaw(pose.q0, pose.q1, pose.q2, pose.q3)\n            pos.pitch = self.quat2Pitch(pose.q0, pose.q1, pose.q2, pose.q3)\n            pos.roll = self.quat2Roll(pose.q0, pose.q1, pose.q2, pose.q3)\n            pos.x = pose.x\n            pos.y = pose.y\n            pos.z = pose.z \n            pos.h = pose.h\n            pos.q = [pose.q0, pose.q1, pose.q2, pose.q3]\n\n        self.lock.acquire()\n        self.pose = pos\n        self.lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getPose3d(self):\n        '''\n        Returns last Pose3d. \n\n        @return last JdeRobotTypes Pose3d saved\n\n        '''\t   \n        self.lock.acquire()\n        pose = self.pose\n        self.lock.release()\n        return pose", "response": "Returns last Pose3d. \n\n        Returns last Pose3d. \n\n        Returns last Pose3d. \n\n        Returns last Pose3d. \n\n        Returns last Pose3d. \n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef quat2Roll (self, qw, qx, qy, qz):\n        '''\n        Translates from Quaternion to Roll. \n\n        @param qw,qx,qy,qz: Quaternion values\n\n        @type qw,qx,qy,qz: float\n\n        @return Roll value translated from Quaternion\n\n        '''\n        rotateXa0=2.0*(qy*qz + qw*qx)\n        rotateXa1=qw*qw - qx*qx - qy*qy + qz*qz\n        rotateX=0.0\n\n        if(rotateXa0 != 0.0 and rotateXa1 != 0.0):\n            rotateX=atan2(rotateXa0, rotateXa1)\n        return rotateX", "response": "Translates from Quaternion to Roll. \n"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nkilling speech dispatcher processes", "response": "def kill_speech_dispatcher(self):\n        '''kill speech dispatcher processs'''\n        if not 'HOME' in os.environ:\n            return\n        pidpath = os.path.join(os.environ['HOME'], '.speech-dispatcher',\n                               'pid', 'speech-dispatcher.pid')\n        if os.path.exists(pidpath):\n            try:\n                import signal\n                pid = int(open(pidpath).read())\n                if pid > 1 and os.kill(pid, 0) is None:\n                    print(\"Killing speech dispatcher pid %u\" % pid)\n                    os.kill(pid, signal.SIGINT)\n                    time.sleep(1)\n            except Exception as e:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nspeaks some text using the SpeechD library", "response": "def say_speechd(self, text, priority='important'):\n        '''speak some text'''\n        ''' http://cvs.freebsoft.org/doc/speechd/ssip.html see 4.3.1 for priorities'''\n        import speechd\n        self.speech = speechd.SSIPClient('MAVProxy%u' % os.getpid())\n        self.speech.set_output_module('festival')\n        self.speech.set_language('en')\n        self.speech.set_priority(priority)\n        self.speech.set_punctuation(speechd.PunctuationMode.SOME)\n        self.speech.speak(text)\n        self.speech.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loadFileList(self):\n        try:\n            data = open(self.filelist_file, 'rb')\n        except IOError:\n            '''print \"No SRTM cached file list. Creating new one!\"'''\n            if self.offline == 0:\n                self.createFileList()\n            return\n        try:\n            self.filelist = pickle.load(data)\n            data.close()\n            if len(self.filelist) < self.min_filelist_len:\n                self.filelist = {}\n                if self.offline == 0:\n                    self.createFileList()\n        except:\n            '''print \"Unknown error loading cached SRTM file list. Creating new one!\"'''\n            if self.offline == 0:\n                self.createFileList()", "response": "Load a previously created file list or create a new one if none is\n            available."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a SRTM tile object. This function can return either an SRTM1 or SRTM3 object depending on what is available, however currently it only returns SRTM3 objects.", "response": "def getTile(self, lat, lon):\n        \"\"\"Get a SRTM tile object. This function can return either an SRTM1 or\n            SRTM3 object depending on what is available, however currently it\n            only returns SRTM3 objects.\"\"\"\n        global childFileListDownload\n        if childFileListDownload is not None and childFileListDownload.is_alive():\n            '''print \"Getting file list\"'''\n            return 0\n        elif not self.filelist:\n            '''print \"Filelist download complete, loading data\"'''\n            data = open(self.filelist_file, 'rb')\n            self.filelist = pickle.load(data)\n            data.close()\n\n        try:\n            continent, filename = self.filelist[(int(lat), int(lon))]\n        except KeyError:\n            '''print \"here??\"'''\n            if len(self.filelist) > self.min_filelist_len:\n                # we appear to have a full filelist - this must be ocean\n                return SRTMOceanTile(int(lat), int(lon))\n            return 0\n\n        global childTileDownload\n        if not os.path.exists(os.path.join(self.cachedir, filename)):\n            if childTileDownload is None or not childTileDownload.is_alive():\n                try:\n                    childTileDownload = multiprocessing.Process(target=self.downloadTile, args=(str(continent), str(filename)))\n                    childTileDownload.start()\n                except Exception as ex:\n                    childTileDownload = None\n                    return 0\n                '''print \"Getting Tile\"'''\n            return 0\n        elif childTileDownload is not None and childTileDownload.is_alive():\n            '''print \"Still Getting Tile\"'''\n            return 0\n        # TODO: Currently we create a new tile object each time.\n        # Caching is required for improved performance.\n        try:\n            return SRTMTile(os.path.join(self.cachedir, filename), int(lat), int(lon))\n        except InvalidTileError:\n            return 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _avg(value1, value2, weight):\n        if value1 is None:\n            return value2\n        if value2 is None:\n            return value1\n        return value2 * weight + value1 * (1 - weight)", "response": "Returns the weighted average of two values and handles the case where\n            one value is None."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating offset into data array. Only uses to test correctness of the formula.", "response": "def calcOffset(self, x, y):\n        \"\"\"Calculate offset into data array. Only uses to test correctness\n            of the formula.\"\"\"\n        # Datalayout\n        # X = longitude\n        # Y = latitude\n        # Sample for size 1201x1201\n        #  (   0/1200)     (   1/1200)  ...    (1199/1200)    (1200/1200)\n        #  (   0/1199)     (   1/1199)  ...    (1199/1199)    (1200/1199)\n        #       ...            ...                 ...             ...\n        #  (   0/   1)     (   1/   1)  ...    (1199/   1)    (1200/   1)\n        #  (   0/   0)     (   1/   0)  ...    (1199/   0)    (1200/   0)\n        #  Some offsets:\n        #  (0/1200)     0\n        #  (1200/1200)  1200\n        #  (0/1199)     1201\n        #  (1200/1199)  2401\n        #  (0/0)        1201*1200\n        #  (1200/0)     1201*1201-1\n        return x + self.size * (self.size - y - 1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the value of a pixel from the data handling voids in the SRTM data.", "response": "def getPixelValue(self, x, y):\n        \"\"\"Get the value of a pixel from the data, handling voids in the\n            SRTM data.\"\"\"\n        assert x < self.size, \"x: %d<%d\" % (x, self.size)\n        assert y < self.size, \"y: %d<%d\" % (y, self.size)\n        # Same as calcOffset, inlined for performance reasons\n        offset = x + self.size * (self.size - y - 1)\n        #print offset\n        value = self.data[offset]\n        if value == -32768:\n            return -1 # -32768 is a special value for areas with no data\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the altitude of a given latitude and longitude pair.", "response": "def getAltitudeFromLatLon(self, lat, lon):\n        \"\"\"Get the altitude of a lat lon pair, using the four neighbouring\n            pixels for interpolation.\n        \"\"\"\n        # print \"-----\\nFromLatLon\", lon, lat\n        lat -= self.lat\n        lon -= self.lon\n        # print \"lon, lat\", lon, lat\n        if lat < 0.0 or lat >= 1.0 or lon < 0.0 or lon >= 1.0:\n            raise WrongTileError(self.lat, self.lon, self.lat+lat, self.lon+lon)\n        x = lon * (self.size - 1)\n        y = lat * (self.size - 1)\n        # print \"x,y\", x, y\n        x_int = int(x)\n        x_frac = x - int(x)\n        y_int = int(y)\n        y_frac = y - int(y)\n        # print \"frac\", x_int, x_frac, y_int, y_frac\n        value00 = self.getPixelValue(x_int, y_int)\n        value10 = self.getPixelValue(x_int+1, y_int)\n        value01 = self.getPixelValue(x_int, y_int+1)\n        value11 = self.getPixelValue(x_int+1, y_int+1)\n        value1 = self._avg(value00, value10, x_frac)\n        value2 = self._avg(value01, value11, x_frac)\n        value  = self._avg(value1,  value2, y_frac)\n        # print \"%4d %4d | %4d\\n%4d %4d | %4d\\n-------------\\n%4d\" % (\n        #        value00, value10, value1, value01, value11, value2, value)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreceive message from the queue", "response": "def recv_msg(self):\n        '''message receive routine'''\n        if self._index >= self._count:\n            return None\n        m = self._msgs[self._index]\n        type = m.get_type()\n        self._index += 1\n        self.percent = (100.0 * self._index) / self._count\n        self.messages[type] = m\n        self._timestamp = m._timestamp\n\n        if self._flightmode_index < len(self._flightmodes):\n            (mode, tstamp, t2) = self._flightmodes[self._flightmode_index]\n            if m._timestamp >= tstamp:\n                self.flightmode = mode\n                self._flightmode_index += 1\n\n        self.check_param(m)\n        return m"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreducing data using flightmode selections", "response": "def reduce_by_flightmodes(self, flightmode_selections):\n        '''reduce data using flightmode selections'''\n        if len(flightmode_selections) == 0:\n            return\n        all_false = True\n        for s in flightmode_selections:\n            if s:\n                all_false = False\n        if all_false:\n            # treat all false as all modes wanted'''\n            return\n        new_msgs = []\n        idx = 0\n        for m in self._msgs:\n            while idx < len(self._flightmodes) and m._timestamp >= self._flightmodes[idx][2]:\n                idx += 1\n            if idx < len(flightmode_selections) and flightmode_selections[idx]:\n                new_msgs.append(m)\n        self._msgs = new_msgs\n        self._count = len(new_msgs)\n        self.rewind()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets a parameter on a mavlink connection", "response": "def mavset(self, mav, name, value, retries=3):\n        '''set a parameter on a mavlink connection'''\n        got_ack = False\n        while retries > 0 and not got_ack:\n            retries -= 1\n            mav.param_set_send(name.upper(), float(value))\n            tstart = time.time()\n            while time.time() - tstart < 1:\n                ack = mav.recv_match(type='PARAM_VALUE', blocking=False)\n                if ack == None:\n                    time.sleep(0.1)\n                    continue\n                if str(name).upper() == str(ack.param_id).upper():\n                    got_ack = True\n                    self.__setitem__(name, float(value))\n                    break\n        if not got_ack:\n            print(\"timeout setting %s to %f\" % (name, float(value)))\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving parameters to a file", "response": "def save(self, filename, wildcard='*', verbose=False):\n        '''save parameters to a file'''\n        f = open(filename, mode='w')\n        k = list(self.keys())\n        k.sort()\n        count = 0\n        for p in k:\n            if p and fnmatch.fnmatch(str(p).upper(), wildcard.upper()):\n                f.write(\"%-16.16s %f\\n\" % (p, self.__getitem__(p)))\n                count += 1\n        f.close()\n        if verbose:\n            print(\"Saved %u parameters to %s\" % (count, filename))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads parameters from a file", "response": "def load(self, filename, wildcard='*', mav=None, check=True):\n        '''load parameters from a file'''\n        try:\n            f = open(filename, mode='r')\n        except:\n            print(\"Failed to open file '%s'\" % filename)\n            return False\n        count = 0\n        changed = 0\n        for line in f:\n            line = line.strip()\n            if not line or line[0] == \"#\":\n                continue\n            line = line.replace(',',' ')\n            a = line.split()\n            if len(a) != 2:\n                print(\"Invalid line: %s\" % line)\n                continue\n            # some parameters should not be loaded from files\n            if a[0] in self.exclude_load:\n                continue\n            if not fnmatch.fnmatch(a[0].upper(), wildcard.upper()):\n                continue\n            if mav is not None:\n                if check:\n                    if a[0] not in self.keys():\n                        print(\"Unknown parameter %s\" % a[0])\n                        continue\n                    old_value = self.__getitem__(a[0])\n                    if math.fabs(old_value - float(a[1])) <= self.mindelta:\n                        count += 1\n                        continue\n                    if self.mavset(mav, a[0], a[1]):\n                        print(\"changed %s from %f to %f\" % (a[0], old_value, float(a[1])))\n                else:\n                    print(\"set %s to %f\" % (a[0], float(a[1])))\n                    self.mavset(mav, a[0], a[1])\n                changed += 1\n            else:\n                self.__setitem__(a[0], float(a[1]))\n            count += 1\n        f.close()\n        if mav is not None:\n            print(\"Loaded %u parameters from %s (changed %u)\" % (count, filename, changed))\n        else:\n            print(\"Loaded %u parameters from %s\" % (count, filename))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef diff(self, filename, wildcard='*'):\n        '''show differences with another parameter file'''\n        other = MAVParmDict()\n        if not other.load(filename):\n            return\n        keys = sorted(list(set(self.keys()).union(set(other.keys()))))\n        for k in keys:\n            if not fnmatch.fnmatch(str(k).upper(), wildcard.upper()):\n                continue\n            if not k in other:\n                print(\"%-16.16s              %12.4f\" % (k, self[k]))\n            elif not k in self:\n                print(\"%-16.16s %12.4f\" % (k, other[k]))\n            elif abs(self[k] - other[k]) > self.mindelta:\n                print(\"%-16.16s %12.4f %12.4f\" % (k, other[k], self[k]))", "response": "show differences with another parameter file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_enums(basename, xml):\n    '''generate main header per XML file'''\n    directory = os.path.join(basename, '''enums''')\n    mavparse.mkdir_p(directory)\n    for en in xml.enum:\n        f = open(os.path.join(directory, en.name+\".java\"), mode='w')\n        t.write(f, '''\n/* AUTO-GENERATED FILE.  DO NOT MODIFY.\n *\n * This class was automatically generated by the\n * java mavlink generator tool. It should not be modified by hand.\n */\n\npackage com.MAVLink.enums;\n\n/** \n* ${description}\n*/\npublic class ${name} {\n${{entry:   public static final int ${name} = ${value}; /* ${description} |${{param:${description}| }} */\n}}\n}\n            ''', en)\n        f.close()", "response": "generate main header per XML file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef copy_fixed_headers(directory, xml):\n    '''copy the fixed protocol headers to the target directory'''\n    import shutil\n    hlist = [ 'Parser.java', 'Messages/MAVLinkMessage.java', 'Messages/MAVLinkPayload.java', 'Messages/MAVLinkStats.java' ]\n    basepath = os.path.dirname(os.path.realpath(__file__))\n    srcpath = os.path.join(basepath, 'java/lib')\n    print(\"Copying fixed headers\")\n    for h in hlist:\n        src = os.path.realpath(os.path.join(srcpath, h))\n        dest = os.path.realpath(os.path.join(directory, h))\n        if src == dest:\n            continue\n        destdir = os.path.realpath(os.path.join(directory, 'Messages'))\n        try:\n            os.makedirs(destdir)\n        except:\n            print(\"Not re-creating Messages directory\")\n        shutil.copy(src, dest)", "response": "copy the fixed protocol headers to the target directory"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwork out the struct format for a type", "response": "def mavfmt(field, typeInfo=False):\n    '''work out the struct format for a type'''\n    map = {\n        'float'    : ('float', 'Float'),\n        'double'   : ('double', 'Double'),\n        'char'     : ('byte', 'Byte'),\n        'int8_t'   : ('byte', 'Byte'),\n        'uint8_t'  : ('short', 'UnsignedByte'),\n        'uint8_t_mavlink_version'  : ('short', 'UnsignedByte'),\n        'int16_t'  : ('short', 'Short'),\n        'uint16_t' : ('int', 'UnsignedShort'),\n        'int32_t'  : ('int', 'Int'),\n        'uint32_t' : ('long', 'UnsignedInt'),\n        'int64_t'  : ('long', 'Long'),\n        'uint64_t' : ('long', 'UnsignedLong'),\n    }\n    \n    if typeInfo:\n        return map[field.type][1]\n    else:\n        return map[field.type][0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_one(basename, xml):\n    '''generate headers for one XML file'''\n    \n    directory = os.path.join(basename, xml.basename)\n    \n    print(\"Generating Java implementation in directory %s\" % directory)\n    mavparse.mkdir_p(directory)\n    \n    if xml.little_endian:\n        xml.mavlink_endian = \"MAVLINK_LITTLE_ENDIAN\"\n    else:\n        xml.mavlink_endian = \"MAVLINK_BIG_ENDIAN\"\n    \n    if xml.crc_extra:\n        xml.crc_extra_define = \"1\"\n    else:\n        xml.crc_extra_define = \"0\"\n    \n    if xml.sort_fields:\n        xml.aligned_fields_define = \"1\"\n    else:\n        xml.aligned_fields_define = \"0\"\n    \n    # work out the included headers\n    xml.include_list = []\n    for i in xml.include:\n        base = i[:-4]\n        xml.include_list.append(mav_include(base))\n    \n    # form message lengths array\n    xml.message_lengths_array = ''\n    for mlen in xml.message_lengths:\n        xml.message_lengths_array += '%u, ' % mlen\n    xml.message_lengths_array = xml.message_lengths_array[:-2]\n    \n    \n    \n    # form message info array\n    xml.message_info_array = ''\n    for name in xml.message_names:\n        if name is not None:\n            xml.message_info_array += 'MAVLINK_MESSAGE_INFO_%s, ' % name\n        else:\n            # Several C compilers don't accept {NULL} for\n            # multi-dimensional arrays and structs\n            # feed the compiler a \"filled\" empty message\n            xml.message_info_array += '{\"EMPTY\",0,{{\"\",\"\",MAVLINK_TYPE_CHAR,0,0,0}}}, '\n    xml.message_info_array = xml.message_info_array[:-2]\n    \n    # add some extra field attributes for convenience with arrays\n    for m in xml.message:\n        m.msg_name = m.name\n        if xml.crc_extra:\n            m.crc_extra_arg = \", %s\" % m.crc_extra\n        else:\n            m.crc_extra_arg = \"\"\n        for f in m.fields:\n            if f.print_format is None:\n                f.c_print_format = 'NULL'\n            else:\n                f.c_print_format = '\"%s\"' % f.print_format\n            f.getText = ''\n            if f.array_length != 0:\n                f.array_suffix = '[] = new %s[%u]' % (mavfmt(f),f.array_length)\n                f.array_prefix = '*'\n                f.array_tag = '_array'\n                f.array_arg = ', %u' % f.array_length\n                f.array_return_arg = '%s, %u, ' % (f.name, f.array_length)\n                f.array_const = 'const '\n                f.decode_left = ''\n                f.decode_right = 'm.%s' % (f.name)\n                \n                f.unpackField = ''' \n        for (int i = 0; i < this.%s.length; i++) {\n            this.%s[i] = payload.get%s();\n        }\n                ''' % (f.name, f.name, mavfmt(f, True) )\n                f.packField = '''\n        for (int i = 0; i < %s.length; i++) {\n            packet.payload.put%s(%s[i]);\n        }\n                    ''' % (f.name, mavfmt(f, True),f.name)\n                f.return_type = 'uint16_t'\n                f.get_arg = ', %s *%s' % (f.type, f.name)\n                if f.type == 'char':\n                    f.c_test_value = '\"%s\"' % f.test_value\n                    f.getText = '''\n    /**\n    * Sets the buffer of this message with a string, adds the necessary padding\n    */\n    public void set%s(String str) {\n        int len = Math.min(str.length(), %d);\n        for (int i=0; i<len; i++) {\n            %s[i] = (byte) str.charAt(i);\n        }\n\n        for (int i=len; i<%d; i++) {            // padding for the rest of the buffer\n            %s[i] = 0;\n        }\n    }\n\n    /**\n    * Gets the message, formated as a string\n    */\n    public String get%s() {\n        String result = \"\";\n        for (int i = 0; i < %d; i++) {\n            if (%s[i] != 0)\n                result = result + (char) %s[i];\n            else\n                break;\n        }\n        return result;\n\n    }\n                        ''' % (f.name.title(),f.array_length,f.name,f.array_length,f.name,f.name.title(),f.array_length,f.name,f.name)\n                else:\n                    test_strings = []\n                    for v in f.test_value:\n                        test_strings.append(str(v))\n                    f.c_test_value = '{ %s }' % ', '.join(test_strings)\n            else:\n                f.array_suffix = ''\n                f.array_prefix = ''\n                f.array_tag = ''\n                f.array_arg = ''\n                f.array_return_arg = ''\n                f.array_const = ''\n                f.decode_left =  '%s' % (f.name)\n                f.decode_right = ''\n                f.unpackField = 'this.%s = payload.get%s();' % (f.name, mavfmt(f, True))\n                f.packField = 'packet.payload.put%s(%s);' % (mavfmt(f, True),f.name)                   \n                \n                \n                f.get_arg = ''\n                f.return_type = f.type\n                if f.type == 'char':\n                    f.c_test_value = \"'%s'\" % f.test_value\n                elif f.type == 'uint64_t':\n                    f.c_test_value = \"%sULL\" % f.test_value                    \n                elif f.type == 'int64_t':\n                    f.c_test_value = \"%sLL\" % f.test_value                    \n                else:\n                    f.c_test_value = f.test_value\n    \n    # cope with uint8_t_mavlink_version\n    for m in xml.message:\n        m.arg_fields = []\n        m.array_fields = []\n        m.scalar_fields = []\n        for f in m.ordered_fields:\n            if f.array_length != 0:\n                m.array_fields.append(f)\n            else:\n                m.scalar_fields.append(f)\n        for f in m.fields:\n            if not f.omit_arg:\n                m.arg_fields.append(f)\n                f.putname = f.name\n            else:\n                f.putname = f.const_value\n    \n    # fix types to java\n    for m in xml.message:\n        for f in m.ordered_fields:\n            f.type = mavfmt(f)\n    \n    generate_CRC(directory, xml)\n    \n    for m in xml.message:\n        generate_message_h(directory, m)", "response": "generate one XML file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate(basename, xml_list):\n    '''generate complete MAVLink Java implemenation'''\n    for xml in xml_list:\n        generate_one(basename, xml)\n        generate_enums(basename, xml)\n        generate_MAVLinkMessage(basename, xml_list)\n    copy_fixed_headers(basename, xml_list[0])", "response": "generate complete MAVLink Java implemenation"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef heartbeat_send(self, type, autopilot, base_mode, custom_mode, system_status, mavlink_version=2, force_mavlink1=False):\n                '''\n                The heartbeat message shows that a system is present and responding.\n                The type of the MAV and Autopilot hardware allow the\n                receiving system to treat further messages from this\n                system appropriate (e.g. by laying out the user\n                interface based on the autopilot).\n\n                type                      : Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM) (uint8_t)\n                autopilot                 : Autopilot type / class. defined in MAV_AUTOPILOT ENUM (uint8_t)\n                base_mode                 : System mode bitfield, see MAV_MODE_FLAGS ENUM in mavlink/include/mavlink_types.h (uint8_t)\n                custom_mode               : A bitfield for use for autopilot-specific flags. (uint32_t)\n                system_status             : System status flag, see MAV_STATE ENUM (uint8_t)\n                mavlink_version           : MAVLink version (uint8_t)\n\n                '''\n                return self.send(self.heartbeat_encode(type, autopilot, base_mode, custom_mode, system_status, mavlink_version), force_mavlink1=force_mavlink1)", "response": "The heartbeat message shows that a system is present and responding.\n                The type of the MAV and Autopilot hardware allow the\n                receiving system to treat further messages from this\n                system appropriate (e.g. by laying out the user\n                interface based on the autopilot).\n\n                type                      : Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM) (uint8_t)\n                autopilot                 : Autopilot type / class. defined in MAV_AUTOPILOT ENUM (uint8_t)\n                base_mode                 : System mode bitfield, see MAV_MODE_FLAGS ENUM in mavlink/include/mavlink_types.h (uint8_t)\n                custom_mode               : A bitfield for use for autopilot-specific flags. (uint32_t)\n                system_status             : System status flag, see MAV_STATE ENUM (uint8_t)\n                mavlink_version           : MAVLink version (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending up to 20 raw float values. Index : Index of message (uint16_t) value1 : value1 (float) value2 : value2 (float) value3 : value3 (float) value4 : value4 (float) value5 : value5 (float) value6 : value6 (float) value7 : value7 (float) value8 : value8 (float) value9 : value9 (float) value10 : value10 (float) value11 : value11 (float) value12 : value12 (float) value13 : value13 (float) value14 : value14 (float) value15 : value15 (float) value16 : value16 (float) value17 : value17 (float) value18 : value18 (float) value19 : value19 (float) value20 : value20 (float)", "response": "def aq_telemetry_f_encode(self, Index, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14, value15, value16, value17, value18, value19, value20):\n                '''\n                Sends up to 20 raw float values.\n\n                Index                     : Index of message (uint16_t)\n                value1                    : value1 (float)\n                value2                    : value2 (float)\n                value3                    : value3 (float)\n                value4                    : value4 (float)\n                value5                    : value5 (float)\n                value6                    : value6 (float)\n                value7                    : value7 (float)\n                value8                    : value8 (float)\n                value9                    : value9 (float)\n                value10                   : value10 (float)\n                value11                   : value11 (float)\n                value12                   : value12 (float)\n                value13                   : value13 (float)\n                value14                   : value14 (float)\n                value15                   : value15 (float)\n                value16                   : value16 (float)\n                value17                   : value17 (float)\n                value18                   : value18 (float)\n                value19                   : value19 (float)\n                value20                   : value20 (float)\n\n                '''\n                return MAVLink_aq_telemetry_f_message(Index, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14, value15, value16, value17, value18, value19, value20)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends ESC32 telemetry data for up to 4 motors. Multiple messages may be sent in sequence when system has > 4 motors. Data is described as follows: // unsigned int state : 3; // unsigned int vin : 12; // x 100 // unsigned int amps : 14; // x 100 // unsigned int rpm : 15; // unsigned int duty : 8; // x (255/100) // - Data Version 2 - // unsigned int errors : 9; // Bad detects error count // - Data Version 3 - // unsigned int temp : 9; // (Deg C + 32) * 4 // unsigned int errCode : 3; time_boot_ms : Timestamp of the component clock since boot time in ms. (uint32_t) seq : Sequence number of message (first set of 4 motors is #1, next 4 is #2, etc). (uint8_t) num_motors : Total number of active ESCs/motors on the system. (uint8_t) num_in_seq : Number of active ESCs in this sequence (1 through this many array members will be populated with data) (uint8_t) escid : ESC/Motor ID (uint8_t) status_age : Age of each ESC telemetry reading in ms compared to boot time. A value of 0xFFFF means timeout/no data. (uint16_t) data_version : Version of data structure (determines contents). (uint8_t) data0 : Data bits 1-32 for each ESC. (uint32_t) data1 : Data bits 33-64 for each ESC. (uint32_t)", "response": "def aq_esc_telemetry_encode(self, time_boot_ms, seq, num_motors, num_in_seq, escid, status_age, data_version, data0, data1):\n                '''\n                Sends ESC32 telemetry data for up to 4 motors. Multiple messages may\n                be sent in sequence when system has > 4 motors. Data\n                is described as follows:\n                // unsigned int state :   3;\n                // unsigned int vin :         12;  // x 100\n                // unsigned int amps :        14;  // x 100\n                // unsigned int rpm :         15;\n                // unsigned int duty :        8;   // x (255/100)\n                // - Data Version 2 -                             //\n                unsigned int errors :    9;   // Bad detects error\n                count                             // - Data Version 3\n                -                             //     unsigned int temp\n                :    9;   // (Deg C + 32) * 4\n                // unsigned int errCode : 3;\n\n                time_boot_ms              : Timestamp of the component clock since boot time in ms. (uint32_t)\n                seq                       : Sequence number of message (first set of 4 motors is #1, next 4 is #2, etc). (uint8_t)\n                num_motors                : Total number of active ESCs/motors on the system. (uint8_t)\n                num_in_seq                : Number of active ESCs in this sequence (1 through this many array members will be populated with data) (uint8_t)\n                escid                     : ESC/Motor ID (uint8_t)\n                status_age                : Age of each ESC telemetry reading in ms compared to boot time. A value of 0xFFFF means timeout/no data. (uint16_t)\n                data_version              : Version of data structure (determines contents). (uint8_t)\n                data0                     : Data bits 1-32 for each ESC. (uint32_t)\n                data1                     : Data bits 33-64 for each ESC. (uint32_t)\n\n                '''\n                return MAVLink_aq_esc_telemetry_message(time_boot_ms, seq, num_motors, num_in_seq, escid, status_age, data_version, data0, data1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef aq_esc_telemetry_send(self, time_boot_ms, seq, num_motors, num_in_seq, escid, status_age, data_version, data0, data1, force_mavlink1=False):\n                '''\n                Sends ESC32 telemetry data for up to 4 motors. Multiple messages may\n                be sent in sequence when system has > 4 motors. Data\n                is described as follows:\n                // unsigned int state :   3;\n                // unsigned int vin :         12;  // x 100\n                // unsigned int amps :        14;  // x 100\n                // unsigned int rpm :         15;\n                // unsigned int duty :        8;   // x (255/100)\n                // - Data Version 2 -                             //\n                unsigned int errors :    9;   // Bad detects error\n                count                             // - Data Version 3\n                -                             //     unsigned int temp\n                :    9;   // (Deg C + 32) * 4\n                // unsigned int errCode : 3;\n\n                time_boot_ms              : Timestamp of the component clock since boot time in ms. (uint32_t)\n                seq                       : Sequence number of message (first set of 4 motors is #1, next 4 is #2, etc). (uint8_t)\n                num_motors                : Total number of active ESCs/motors on the system. (uint8_t)\n                num_in_seq                : Number of active ESCs in this sequence (1 through this many array members will be populated with data) (uint8_t)\n                escid                     : ESC/Motor ID (uint8_t)\n                status_age                : Age of each ESC telemetry reading in ms compared to boot time. A value of 0xFFFF means timeout/no data. (uint16_t)\n                data_version              : Version of data structure (determines contents). (uint8_t)\n                data0                     : Data bits 1-32 for each ESC. (uint32_t)\n                data1                     : Data bits 33-64 for each ESC. (uint32_t)\n\n                '''\n                return self.send(self.aq_esc_telemetry_encode(time_boot_ms, seq, num_motors, num_in_seq, escid, status_age, data_version, data0, data1), force_mavlink1=force_mavlink1)", "response": "AQ ESC32 telemetry data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef watch_thread(self):\n        '''watch for menu events from child'''\n        from mp_settings import MPSetting\n        try:\n            while True:\n                msg = self.parent_pipe_recv.recv()\n                if self.menu_callback is not None:\n                    self.menu_callback(msg)\n                time.sleep(0.1)\n        except EOFError:\n            pass", "response": "watch for menu events from child"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write(self, text, fg='black', bg='white'):\n        '''write to the console'''\n        try:\n            self.parent_pipe_send.send(Text(text, fg, bg))\n        except Exception:\n            pass", "response": "write to the console"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_status(self, name, text='', row=0, fg='black', bg='white'):\n        '''set a status value'''\n        if self.is_alive():\n            self.parent_pipe_send.send(Value(name, text, row, fg, bg))", "response": "set a status value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef initUI(self):\n\n        #self.setMinimumSize(WIDTH,HEIGTH)\n        #self.setMaximumSize(WIDTH,HEIGTH)\n\n        '''Radio buttons for Original/RGB/HSV/YUV images'''\n        self.origButton = QRadioButton(\"Original\")\n        self.rgbButton = QRadioButton(\"RGB\")\n        self.hsvButton = QRadioButton(\"HSV\")\n        self.yuvButton = QRadioButton(\"YUV\")\n        '''HSV status scheck'''\n        self.hsvCheck = QCheckBox('HSV Color Disc')\n        self.hsvCheck.setObjectName(\"hsvCheck\")\n        self.hsvCheck.stateChanged.connect(self.showHSVWidget)\n\n        '''Signals for toggled radio buttons'''\n        self.origButton.toggled.connect(lambda:self.origButtonState())       \n        self.rgbButton.toggled.connect(lambda:self.rgbButtonState())\n        self.hsvButton.toggled.connect(lambda:self.hsvButtonState())\n        self.yuvButton.toggled.connect(lambda:self.yuvButtonState())\n\n        self.origButton.setChecked(True)\n\n        '''Main layout of the widget will contain several vertical layouts'''\n        self.gLayout = QGridLayout(self)\n        self.gLayout.setObjectName(\"gLayout\")\n\n        ''' Vertical Layout for radio buttons '''\n        self.radio1Layout = QHBoxLayout()\n        self.radio2Layout = QVBoxLayout()\n        self.radio3Layout = QVBoxLayout()\n        self.radioLayout = QVBoxLayout()\n        self.radioLayout.setObjectName(\"radioLayout\")\n        self.radio1Layout.addWidget(self.origButton)\n        self.radio1Layout.addWidget(self.rgbButton)\n        self.radio1Layout.addWidget(self.hsvButton)\n        self.radio1Layout.addWidget(self.yuvButton)\n        self.radio1Layout.addWidget(self.hsvCheck)\n        #self.radio1Layout.addLayout(self.radio2Layout)\n        #self.radio1Layout.addLayout(self.radio3Layout)\n        self.radioLayout.addLayout(self.radio1Layout)\n        self.vSpacer = QSpacerItem(10, 10, QSizePolicy.Ignored, QSizePolicy.Ignored);\n        self.radioLayout.addItem(self.vSpacer)\n        \n        hmin,smin,vmin = HSVMIN\n        hmax,smax,vmax = HSVMAX\n        ''' Vertical Layout for HMIN Slider''' \n        self.hminLayout = QVBoxLayout()\n        self.hminLayout.setObjectName(\"hminLayout\")\n        self.hminLabel = QLabel(\"HMin\")\n        self.hminValue = QLineEdit(str(hmin),self)\n        self.hminValue.setValidator(QIntValidator(hmin, hmax, self));\n        self.hminValue.setFixedWidth(40)\n        self.hminValue.setFixedHeight(27)\n        self.hminValue.setAlignment(Qt.AlignCenter);\n        self.hminSlider = QSlider(Qt.Vertical)\n        self.hminSlider.setMinimum(hmin)\n        self.hminSlider.setMaximum(hmax)\n        self.hminSlider.setValue(hmin)\n        self.hminLayout.addWidget(self.hminLabel, Qt.AlignCenter)\n        self.hminLayout.addWidget(self.hminValue,Qt.AlignCenter)\n        self.hminLayout.addWidget(self.hminSlider)\n        \n\n        ''' Vertical Layout for HMAX Slider''' \n        self.hmaxLayout = QVBoxLayout()\n        self.hmaxLayout.setObjectName(\"hmaxLayout\")\n        self.hmaxLabel = QLabel(\"HMax\")\n        self.hmaxValue = QLineEdit(str(hmax),self)\n        self.hmaxValue.setValidator(QIntValidator(hmin, hmax, self));\n        self.hmaxValue.setFixedWidth(40)\n        self.hmaxValue.setFixedHeight(27)\n        self.hmaxValue.setAlignment(Qt.AlignCenter);\n        self.hmaxSlider = QSlider(Qt.Vertical)\n        self.hmaxSlider.setMinimum(hmin)\n        self.hmaxSlider.setMaximum(hmax)\n        self.hmaxSlider.setValue(hmax)\n        self.hmaxLayout.addWidget(self.hmaxLabel)\n        self.hmaxLayout.addWidget(self.hmaxValue)\n        self.hmaxLayout.addWidget(self.hmaxSlider)\n\n        ''' Vertical Layout for SMIN Slider'''\n        self.sminLayout = QVBoxLayout()\n        self.sminLayout.setObjectName(\"sminLayout\")\n        self.sminLabel = QLabel(\"SMin\")\n        self.sminValue = QLineEdit(str(smin),self)\n        self.sminValue.setValidator(QIntValidator(smin, smax, self));\n        self.sminValue.setFixedWidth(40)\n        self.sminValue.setFixedHeight(27)\n        self.sminValue.setAlignment(Qt.AlignCenter);\n        self.sminSlider = QSlider(Qt.Vertical)\n        self.sminSlider.setMinimum(smin)\n        self.sminSlider.setMaximum(smax)\n        self.sminSlider.setValue(smin)\n        self.sminLayout.addWidget(self.sminLabel)\n        self.sminLayout.addWidget(self.sminValue)\n        self.sminLayout.addWidget(self.sminSlider)\n\n        ''' Vertical Layout for SMAX Slider'''\n        self.smaxLayout = QVBoxLayout()\n        self.smaxLayout.setObjectName(\"smaxLayout\")\n        self.smaxLabel = QLabel(\"SMax\")\n        self.smaxValue = QLineEdit(str(smax),self)\n        self.smaxValue.setValidator(QIntValidator(smin, smax, self));\n        self.smaxValue.setFixedWidth(40)\n        self.smaxValue.setFixedHeight(27)\n        self.smaxValue.setAlignment(Qt.AlignCenter);\n        self.smaxSlider = QSlider(Qt.Vertical)\n        self.smaxSlider.setMinimum(smin)\n        self.smaxSlider.setMaximum(smax)\n        self.smaxSlider.setValue(smax)\n        self.smaxLayout.addWidget(self.smaxLabel)\n        self.smaxLayout.addWidget(self.smaxValue)\n        self.smaxLayout.addWidget(self.smaxSlider)\n\n        ''' Vertical Layout for VMIN Slider'''\n        self.vminLayout = QVBoxLayout()\n        self.vminLayout.setObjectName(\"vminLayout\")\n        self.vminLabel = QLabel(\"VMin\")\n        self.vminValue = QLineEdit(str(vmin),self)\n        self.vminValue.setValidator(QIntValidator(vmin, vmax, self));\n        self.vminValue.setFixedWidth(40)\n        self.vminValue.setFixedHeight(27)\n        self.vminValue.setAlignment(Qt.AlignCenter);\n        self.vminSlider = QSlider(Qt.Vertical)\n        self.vminSlider.setMinimum(vmin)\n        self.vminSlider.setMaximum(vmax)\n        self.vminSlider.setValue(vmin)\n        self.vminLayout.addWidget(self.vminLabel)\n        self.vminLayout.addWidget(self.vminValue)\n        self.vminLayout.addWidget(self.vminSlider)\n\n        ''' Vertical Layout for VMAX Slider'''\n        self.vmaxLayout = QVBoxLayout()\n        self.vmaxLayout.setObjectName(\"vmaxLayout\")\n        self.vmaxLabel = QLabel(\"VMax\")\n        self.vmaxValue = QLineEdit(str(vmax),self)\n        self.vmaxValue.setValidator(QIntValidator(vmin, vmax, self));\n        self.vmaxValue.setFixedWidth(40)\n        self.vmaxValue.setFixedHeight(27)\n        self.vmaxValue.setAlignment(Qt.AlignCenter);\n        self.vmaxSlider = QSlider(Qt.Vertical)\n        self.vmaxSlider.setMinimum(vmin)\n        self.vmaxSlider.setMaximum(vmax)\n        self.vmaxSlider.setValue(vmax)\n        self.vmaxLayout.addWidget(self.vmaxLabel)\n        self.vmaxLayout.addWidget(self.vmaxValue)\n        self.vmaxLayout.addWidget(self.vmaxSlider)\n    \n        '''Adding all the vertical layouts to the main horizontal layout'''\n        self.gLayout.addLayout(self.radioLayout,1,0,1,6,Qt.AlignCenter)\n        self.gLayout.addLayout(self.hminLayout,2,0,Qt.AlignCenter)\n        self.gLayout.addLayout(self.hmaxLayout,2,1,Qt.AlignCenter)\n        self.gLayout.addLayout(self.sminLayout,2,2,Qt.AlignCenter)\n        self.gLayout.addLayout(self.smaxLayout,2,3,Qt.AlignCenter)\n        self.gLayout.addLayout(self.vminLayout,2,4,Qt.AlignCenter)\n        self.gLayout.addLayout(self.vmaxLayout,2,5,Qt.AlignCenter)\n        self.setLayout(self.gLayout)\n\n\n        '''Signals for sliders value changes'''\n        self.hminSlider.valueChanged.connect(self.changeHmin)     \n        self.hmaxSlider.valueChanged.connect(self.changeHmax)\n        self.sminSlider.valueChanged.connect(self.changeSmin)     \n        self.smaxSlider.valueChanged.connect(self.changeSmax)\n        self.vminSlider.valueChanged.connect(self.changeVmin)     \n        self.vmaxSlider.valueChanged.connect(self.changeVmax)\n\n        self.hminValue.textChanged.connect(self.changeHmin2)\n        self.hmaxValue.textChanged.connect(self.changeHmax2)\n        self.sminValue.textChanged.connect(self.changeSmin2)\n        self.smaxValue.textChanged.connect(self.changeSmax2)\n        self.vminValue.textChanged.connect(self.changeVmin2)\n        self.vmaxValue.textChanged.connect(self.changeVmax2)", "response": "Initializes the UI for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_rally_alt(self, args):\n        '''handle rally alt change'''\n        if (len(args) < 2):\n            print(\"Usage: rally alt RALLYNUM newAlt <newBreakAlt>\")\n            return\n        if not self.have_list:\n            print(\"Please list rally points first\")\n            return\n\n        idx = int(args[0])\n        if idx <= 0 or idx > self.rallyloader.rally_count():\n            print(\"Invalid rally point number %u\" % idx)\n            return\n\n        new_alt = int(args[1])\n        new_break_alt = None\n        if (len(args) > 2):\n            new_break_alt = int(args[2])\n\n        self.rallyloader.set_alt(idx, new_alt, new_break_alt)\n        self.send_rally_point(idx-1)\n        self.fetch_rally_point(idx-1)\n        self.rallyloader.reindex()", "response": "handle rally alt change"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mavlink_packet(self, m):\n        '''handle incoming mavlink packet'''\n        type = m.get_type()\n        if type in ['COMMAND_ACK']:\n            if m.command == mavutil.mavlink.MAV_CMD_DO_GO_AROUND:\n                if (m.result == 0 and self.abort_ack_received == False):\n                    self.say(\"Landing Abort Command Successfully Sent.\")\n                    self.abort_ack_received = True\n                elif (m.result != 0 and self.abort_ack_received == False):\n                    self.say(\"Landing Abort Command Unsuccessful.\")\n\n            elif m.command == mavutil.mavlink.MAV_CMD_DO_RALLY_LAND:\n                if (m.result == 0):\n                    self.say(\"Landing.\")", "response": "handle incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_rally_point(self, i):\n        '''send rally points from fenceloader'''\n        p = self.rallyloader.rally_point(i)\n        p.target_system = self.target_system\n        p.target_component = self.target_component\n        self.master.mav.send(p)", "response": "send rally points from fenceloader"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_rally_points(self):\n        '''send rally points from rallyloader'''\n        self.mav_param.mavset(self.master,'RALLY_TOTAL',self.rallyloader.rally_count(),3)\n\n        for i in range(self.rallyloader.rally_count()):\n            self.send_rally_point(i)", "response": "send rally points from rallyloader"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getBumper(self):\n        '''\n        Returns last Bumper. \n\n        @return last JdeRobotTypes Bumper saved\n\n        '''\n        if self.hasproxy():\n            self.lock.acquire()\n            bumper = self.bumper\n            self.lock.release()\n            return bumper\n\n        return None", "response": "Returns last Bumper. \n\n        Returns None if no bumper was set."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef imageMsg2Image(img, bridge):\n    '''\n    Translates from ROS Image to JderobotTypes Image. \n\n    @param img: ROS Image to translate\n    @param bridge: bridge to do translation\n\n    @type img: sensor_msgs.msg.Image\n    @type brige: CvBridge\n\n    @return a JderobotTypes.Image translated from img\n\n    '''\n    image = Image()\n\n    image.width = img.width\n    image.height = img.height\n    image.format = \"RGB8\"\n    image.timeStamp = img.header.stamp.secs + (img.header.stamp.nsecs *1e-9)\n    cv_image=0\n    if (img.encoding == \"32FC1\"):\n        gray_img_buff = bridge.imgmsg_to_cv2(img, \"32FC1\")\n        cv_image  = depthToRGB8(gray_img_buff)\n    else:\n        cv_image = bridge.imgmsg_to_cv2(img, \"rgb8\")\n    image.data = cv_image\n    return image", "response": "Translate from ROS Image to JderobotTypes Image. \n"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntranslating from ROS Images to JderobotTypes Rgbd.", "response": "def Images2Rgbd(rgb, d):\n    '''\n    Translates from ROS Images to JderobotTypes Rgbd. \n\n    @param rgb: ROS color Image to translate\n\n    @param d: ROS depth image to translate\n\n    @type rgb: ImageROS\n\n    @type d: ImageROS\n\n    @return a Rgbd translated from Images\n\n    '''\n    data = Rgbd()\n    data.color=imageMsg2Image(rgb)\n    data.depth=imageMsg2Image(d)\n    data.timeStamp = rgb.header.stamp.secs + (rgb.header.stamp.nsecs *1e-9)\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __callback (self, rgb, d):\n        '''\n        Callback function to receive and save Rgbd Scans. \n\n        @param rgb: ROS color Image to translate\n\n        @param d: ROS depth image to translate\n\n        @type rgb: ImageROS\n\n        @type d: ImageROS\n\n        '''\n        data = Images2Rgbd(rgb, d)\n\n        self.lock.acquire()\n        self.data = data\n        self.lock.release()", "response": "This function is called by the ROS daemon when the image is saved."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart (Subscribes) the client.", "response": "def start (self):\n        '''\n        Starts (Subscribes) the client.\n\n        '''\n        self.subrgb = rospy.Subscriber(self.topicrgb, ImageROS)\n        self.subd = rospy.Subscriber(self.topicd, ImageROS)\n        self.ts = message_filters.ApproximateTimeSynchronizer([subrgb, subd], 1, 0.1, allow_headerless=True)\n        self.ts.registerCallback(self.__callback)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getRgbdData(self):\n        '''\n        Returns last RgbdData. \n\n        @return last JdeRobotTypes Rgbd saved\n\n        '''\n        self.lock.acquire()\n        data = self.data\n        self.lock.release()\n        \n        return data", "response": "Returns last RgbdData. \n\n        Returns last RgbdData. \n\n        Returns last RgbdData. \n\n        Returns last RgbdData. \n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sensor_offsets_encode(self, mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z):\n                '''\n                Offsets and calibrations values for hardware sensors. This makes it\n                easier to debug the calibration process.\n\n                mag_ofs_x                 : magnetometer X offset (int16_t)\n                mag_ofs_y                 : magnetometer Y offset (int16_t)\n                mag_ofs_z                 : magnetometer Z offset (int16_t)\n                mag_declination           : magnetic declination (radians) (float)\n                raw_press                 : raw pressure from barometer (int32_t)\n                raw_temp                  : raw temperature from barometer (int32_t)\n                gyro_cal_x                : gyro X calibration (float)\n                gyro_cal_y                : gyro Y calibration (float)\n                gyro_cal_z                : gyro Z calibration (float)\n                accel_cal_x               : accel X calibration (float)\n                accel_cal_y               : accel Y calibration (float)\n                accel_cal_z               : accel Z calibration (float)\n\n                '''\n                return MAVLink_sensor_offsets_message(mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z)", "response": "This function is used to set the offset values for hardware sensors."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\noffset and calibrations values for hardware sensors. This makes it easier to debug the calibration process. mag_ofs_x : magnetometer X offset (int16_t) mag_ofs_y : magnetometer Y offset (int16_t) mag_ofs_z : magnetometer Z offset (int16_t) mag_declination : magnetic declination (radians) (float) raw_press : raw pressure from barometer (int32_t) raw_temp : raw temperature from barometer (int32_t) gyro_cal_x : gyro X calibration (float) gyro_cal_y : gyro Y calibration (float) gyro_cal_z : gyro Z calibration (float) accel_cal_x : accel X calibration (float) accel_cal_y : accel Y calibration (float) accel_cal_z : accel Z calibration (float)", "response": "def sensor_offsets_send(self, mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z, force_mavlink1=False):\n                '''\n                Offsets and calibrations values for hardware sensors. This makes it\n                easier to debug the calibration process.\n\n                mag_ofs_x                 : magnetometer X offset (int16_t)\n                mag_ofs_y                 : magnetometer Y offset (int16_t)\n                mag_ofs_z                 : magnetometer Z offset (int16_t)\n                mag_declination           : magnetic declination (radians) (float)\n                raw_press                 : raw pressure from barometer (int32_t)\n                raw_temp                  : raw temperature from barometer (int32_t)\n                gyro_cal_x                : gyro X calibration (float)\n                gyro_cal_y                : gyro Y calibration (float)\n                gyro_cal_z                : gyro Z calibration (float)\n                accel_cal_x               : accel X calibration (float)\n                accel_cal_y               : accel Y calibration (float)\n                accel_cal_z               : accel Z calibration (float)\n\n                '''\n                return self.send(self.sensor_offsets_encode(mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the magnetometer offsets", "response": "def set_mag_offsets_encode(self, target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z):\n                '''\n                Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the\n                magnetometer offsets\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                mag_ofs_x                 : magnetometer X offset (int16_t)\n                mag_ofs_y                 : magnetometer Y offset (int16_t)\n                mag_ofs_z                 : magnetometer Z offset (int16_t)\n\n                '''\n                return MAVLink_set_mag_offsets_message(target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_mag_offsets_send(self, target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z, force_mavlink1=False):\n                '''\n                Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the\n                magnetometer offsets\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                mag_ofs_x                 : magnetometer X offset (int16_t)\n                mag_ofs_y                 : magnetometer Y offset (int16_t)\n                mag_ofs_z                 : magnetometer Z offset (int16_t)\n\n                '''\n                return self.send(self.set_mag_offsets_encode(target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z), force_mavlink1=force_mavlink1)", "response": "Set the magnetometer offsets."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ap_adc_send(self, adc1, adc2, adc3, adc4, adc5, adc6, force_mavlink1=False):\n                '''\n                raw ADC output\n\n                adc1                      : ADC output 1 (uint16_t)\n                adc2                      : ADC output 2 (uint16_t)\n                adc3                      : ADC output 3 (uint16_t)\n                adc4                      : ADC output 4 (uint16_t)\n                adc5                      : ADC output 5 (uint16_t)\n                adc6                      : ADC output 6 (uint16_t)\n\n                '''\n                return self.send(self.ap_adc_encode(adc1, adc2, adc3, adc4, adc5, adc6), force_mavlink1=force_mavlink1)", "response": "raw ADC output\n\n                adc1                      : ADC output 1 (uint16_t)\n                adc2                      : ADC output 2 (uint16_t)\n                adc3                      : ADC output 3 (uint16_t)\n                adc4                      : ADC output 4 (uint16_t)\n                adc5                      : ADC output 5 (uint16_t)\n                adc6                      : ADC output 6 (uint16_t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef digicam_configure_encode(self, target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value):\n                '''\n                Configure on-board Camera Control System.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                mode                      : Mode enumeration from 1 to N //P, TV, AV, M, Etc (0 means ignore) (uint8_t)\n                shutter_speed             : Divisor number //e.g. 1000 means 1/1000 (0 means ignore) (uint16_t)\n                aperture                  : F stop number x 10 //e.g. 28 means 2.8 (0 means ignore) (uint8_t)\n                iso                       : ISO enumeration from 1 to N //e.g. 80, 100, 200, Etc (0 means ignore) (uint8_t)\n                exposure_type             : Exposure type enumeration from 1 to N (0 means ignore) (uint8_t)\n                command_id                : Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once (uint8_t)\n                engine_cut_off            : Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off) (uint8_t)\n                extra_param               : Extra parameters enumeration (0 means ignore) (uint8_t)\n                extra_value               : Correspondent value to given extra_param (float)\n\n                '''\n                return MAVLink_digicam_configure_message(target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value)", "response": "Configure on - board Camera Control System."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef digicam_configure_send(self, target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value, force_mavlink1=False):\n                '''\n                Configure on-board Camera Control System.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                mode                      : Mode enumeration from 1 to N //P, TV, AV, M, Etc (0 means ignore) (uint8_t)\n                shutter_speed             : Divisor number //e.g. 1000 means 1/1000 (0 means ignore) (uint16_t)\n                aperture                  : F stop number x 10 //e.g. 28 means 2.8 (0 means ignore) (uint8_t)\n                iso                       : ISO enumeration from 1 to N //e.g. 80, 100, 200, Etc (0 means ignore) (uint8_t)\n                exposure_type             : Exposure type enumeration from 1 to N (0 means ignore) (uint8_t)\n                command_id                : Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once (uint8_t)\n                engine_cut_off            : Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off) (uint8_t)\n                extra_param               : Extra parameters enumeration (0 means ignore) (uint8_t)\n                extra_value               : Correspondent value to given extra_param (float)\n\n                '''\n                return self.send(self.digicam_configure_encode(target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value), force_mavlink1=force_mavlink1)", "response": "Configure on - board camera control system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncontrol on - board Camera Control System to take shots.", "response": "def digicam_control_encode(self, target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value):\n                '''\n                Control on-board Camera Control System to take shots.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                session                   : 0: stop, 1: start or keep it up //Session control e.g. show/hide lens (uint8_t)\n                zoom_pos                  : 1 to N //Zoom's absolute position (0 means ignore) (uint8_t)\n                zoom_step                 : -100 to 100 //Zooming step value to offset zoom from the current position (int8_t)\n                focus_lock                : 0: unlock focus or keep unlocked, 1: lock focus or keep locked, 3: re-lock focus (uint8_t)\n                shot                      : 0: ignore, 1: shot or start filming (uint8_t)\n                command_id                : Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once (uint8_t)\n                extra_param               : Extra parameters enumeration (0 means ignore) (uint8_t)\n                extra_value               : Correspondent value to given extra_param (float)\n\n                '''\n                return MAVLink_digicam_control_message(target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef digicam_control_send(self, target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value, force_mavlink1=False):\n                '''\n                Control on-board Camera Control System to take shots.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                session                   : 0: stop, 1: start or keep it up //Session control e.g. show/hide lens (uint8_t)\n                zoom_pos                  : 1 to N //Zoom's absolute position (0 means ignore) (uint8_t)\n                zoom_step                 : -100 to 100 //Zooming step value to offset zoom from the current position (int8_t)\n                focus_lock                : 0: unlock focus or keep unlocked, 1: lock focus or keep locked, 3: re-lock focus (uint8_t)\n                shot                      : 0: ignore, 1: shot or start filming (uint8_t)\n                command_id                : Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once (uint8_t)\n                extra_param               : Extra parameters enumeration (0 means ignore) (uint8_t)\n                extra_value               : Correspondent value to given extra_param (float)\n\n                '''\n                return self.send(self.digicam_control_encode(target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value), force_mavlink1=force_mavlink1)", "response": "Control on - board Camera Control System."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconfiguring a camera mount", "response": "def mount_configure_encode(self, target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw):\n                '''\n                Message to configure a camera mount, directional antenna, etc.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                mount_mode                : mount operating mode (see MAV_MOUNT_MODE enum) (uint8_t)\n                stab_roll                 : (1 = yes, 0 = no) (uint8_t)\n                stab_pitch                : (1 = yes, 0 = no) (uint8_t)\n                stab_yaw                  : (1 = yes, 0 = no) (uint8_t)\n\n                '''\n                return MAVLink_mount_configure_message(target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconfigure a camera mount", "response": "def mount_configure_send(self, target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw, force_mavlink1=False):\n                '''\n                Message to configure a camera mount, directional antenna, etc.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                mount_mode                : mount operating mode (see MAV_MOUNT_MODE enum) (uint8_t)\n                stab_roll                 : (1 = yes, 0 = no) (uint8_t)\n                stab_pitch                : (1 = yes, 0 = no) (uint8_t)\n                stab_yaw                  : (1 = yes, 0 = no) (uint8_t)\n\n                '''\n                return self.send(self.mount_configure_encode(target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmessages to control a camera mount, directional antenna, etc. target_system : System ID (uint8_t) target_component : Component ID (uint8_t) input_a : pitch(deg*100) or lat, depending on mount mode (int32_t) input_b : roll(deg*100) or lon depending on mount mode (int32_t) input_c : yaw(deg*100) or alt (in cm) depending on mount mode (int32_t) save_position : if \"1\" it will save current trimmed position on EEPROM (just valid for NEUTRAL and LANDING) (uint8_t)", "response": "def mount_control_encode(self, target_system, target_component, input_a, input_b, input_c, save_position):\n                '''\n                Message to control a camera mount, directional antenna, etc.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                input_a                   : pitch(deg*100) or lat, depending on mount mode (int32_t)\n                input_b                   : roll(deg*100) or lon depending on mount mode (int32_t)\n                input_c                   : yaw(deg*100) or alt (in cm) depending on mount mode (int32_t)\n                save_position             : if \"1\" it will save current trimmed position on EEPROM (just valid for NEUTRAL and LANDING) (uint8_t)\n\n                '''\n                return MAVLink_mount_control_message(target_system, target_component, input_a, input_b, input_c, save_position)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncontrols a camera mount.", "response": "def mount_control_send(self, target_system, target_component, input_a, input_b, input_c, save_position, force_mavlink1=False):\n                '''\n                Message to control a camera mount, directional antenna, etc.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                input_a                   : pitch(deg*100) or lat, depending on mount mode (int32_t)\n                input_b                   : roll(deg*100) or lon depending on mount mode (int32_t)\n                input_c                   : yaw(deg*100) or alt (in cm) depending on mount mode (int32_t)\n                save_position             : if \"1\" it will save current trimmed position on EEPROM (just valid for NEUTRAL and LANDING) (uint8_t)\n\n                '''\n                return self.send(self.mount_control_encode(target_system, target_component, input_a, input_b, input_c, save_position), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mount_status_encode(self, target_system, target_component, pointing_a, pointing_b, pointing_c):\n                '''\n                Message with some status from APM to GCS about camera or antenna mount\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                pointing_a                : pitch(deg*100) (int32_t)\n                pointing_b                : roll(deg*100) (int32_t)\n                pointing_c                : yaw(deg*100) (int32_t)\n\n                '''\n                return MAVLink_mount_status_message(target_system, target_component, pointing_a, pointing_b, pointing_c)", "response": "Mount status from APM to GCS about camera or antenna"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmount status from GCS to camera or antenna.", "response": "def mount_status_send(self, target_system, target_component, pointing_a, pointing_b, pointing_c, force_mavlink1=False):\n                '''\n                Message with some status from APM to GCS about camera or antenna mount\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                pointing_a                : pitch(deg*100) (int32_t)\n                pointing_b                : roll(deg*100) (int32_t)\n                pointing_c                : yaw(deg*100) (int32_t)\n\n                '''\n                return self.send(self.mount_status_encode(target_system, target_component, pointing_a, pointing_b, pointing_c), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrequesting a fence point from the system.", "response": "def fence_fetch_point_send(self, target_system, target_component, idx, force_mavlink1=False):\n                '''\n                Request a current fence point from MAV\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                idx                       : point index (first point is 1, 0 is for return point) (uint8_t)\n\n                '''\n                return self.send(self.fence_fetch_point_encode(target_system, target_component, idx), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ahrs_send(self, omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw, force_mavlink1=False):\n                '''\n                Status of DCM attitude estimator\n\n                omegaIx                   : X gyro drift estimate rad/s (float)\n                omegaIy                   : Y gyro drift estimate rad/s (float)\n                omegaIz                   : Z gyro drift estimate rad/s (float)\n                accel_weight              : average accel_weight (float)\n                renorm_val                : average renormalisation value (float)\n                error_rp                  : average error_roll_pitch value (float)\n                error_yaw                 : average error_yaw value (float)\n\n                '''\n                return self.send(self.ahrs_encode(omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw), force_mavlink1=force_mavlink1)", "response": "This function is used to update the accelerometer and error roll pitch and yaw of the current attitude estimator."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef simstate_send(self, roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng, force_mavlink1=False):\n                '''\n                Status of simulation environment, if used\n\n                roll                      : Roll angle (rad) (float)\n                pitch                     : Pitch angle (rad) (float)\n                yaw                       : Yaw angle (rad) (float)\n                xacc                      : X acceleration m/s/s (float)\n                yacc                      : Y acceleration m/s/s (float)\n                zacc                      : Z acceleration m/s/s (float)\n                xgyro                     : Angular speed around X axis rad/s (float)\n                ygyro                     : Angular speed around Y axis rad/s (float)\n                zgyro                     : Angular speed around Z axis rad/s (float)\n                lat                       : Latitude in degrees * 1E7 (int32_t)\n                lng                       : Longitude in degrees * 1E7 (int32_t)\n\n                '''\n                return self.send(self.simstate_encode(roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng), force_mavlink1=force_mavlink1)", "response": "Simulate state of the current simulation environment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hwstatus_send(self, Vcc, I2Cerr, force_mavlink1=False):\n                '''\n                Status of key hardware\n\n                Vcc                       : board voltage (mV) (uint16_t)\n                I2Cerr                    : I2C error count (uint8_t)\n\n                '''\n                return self.send(self.hwstatus_encode(Vcc, I2Cerr), force_mavlink1=force_mavlink1)", "response": "Status of key hardware\n\n                Vcc                       : board voltage (mV) (uint16_t)\n                I2Cerr                    : I2C error count (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef limits_status_encode(self, limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered):\n                '''\n                Status of AP_Limits. Sent in extended status stream when AP_Limits is\n                enabled\n\n                limits_state              : state of AP_Limits, (see enum LimitState, LIMITS_STATE) (uint8_t)\n                last_trigger              : time of last breach in milliseconds since boot (uint32_t)\n                last_action               : time of last recovery action in milliseconds since boot (uint32_t)\n                last_recovery             : time of last successful recovery in milliseconds since boot (uint32_t)\n                last_clear                : time of last all-clear in milliseconds since boot (uint32_t)\n                breach_count              : number of fence breaches (uint16_t)\n                mods_enabled              : AP_Limit_Module bitfield of enabled modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)\n                mods_required             : AP_Limit_Module bitfield of required modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)\n                mods_triggered            : AP_Limit_Module bitfield of triggered modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)\n\n                '''\n                return MAVLink_limits_status_message(limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered)", "response": "Status of AP_Limits. Sent in extended status stream when AP_Limits is enabled."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef limits_status_send(self, limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered, force_mavlink1=False):\n                '''\n                Status of AP_Limits. Sent in extended status stream when AP_Limits is\n                enabled\n\n                limits_state              : state of AP_Limits, (see enum LimitState, LIMITS_STATE) (uint8_t)\n                last_trigger              : time of last breach in milliseconds since boot (uint32_t)\n                last_action               : time of last recovery action in milliseconds since boot (uint32_t)\n                last_recovery             : time of last successful recovery in milliseconds since boot (uint32_t)\n                last_clear                : time of last all-clear in milliseconds since boot (uint32_t)\n                breach_count              : number of fence breaches (uint16_t)\n                mods_enabled              : AP_Limit_Module bitfield of enabled modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)\n                mods_required             : AP_Limit_Module bitfield of required modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)\n                mods_triggered            : AP_Limit_Module bitfield of triggered modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)\n\n                '''\n                return self.send(self.limits_status_encode(limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered), force_mavlink1=force_mavlink1)", "response": "Status of AP_Limits. Sent in extended status stream when AP_Limits is enabled."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwinds estimation direction : wind direction that wind is coming from (degrees) (float) speed : wind speed in ground plane (m/s) (float) speed_z : vertical wind speed (m/s) (float)", "response": "def wind_send(self, direction, speed, speed_z, force_mavlink1=False):\n                '''\n                Wind estimation\n\n                direction                 : wind direction that wind is coming from (degrees) (float)\n                speed                     : wind speed in ground plane (m/s) (float)\n                speed_z                   : vertical wind speed (m/s) (float)\n\n                '''\n                return self.send(self.wind_encode(direction, speed, speed_z), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef data32_send(self, type, len, data, force_mavlink1=False):\n                '''\n                Data packet, size 32\n\n                type                      : data type (uint8_t)\n                len                       : data length (uint8_t)\n                data                      : raw data (uint8_t)\n\n                '''\n                return self.send(self.data32_encode(type, len, data), force_mavlink1=force_mavlink1)", "response": "Data packet size 32"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef data64_send(self, type, len, data, force_mavlink1=False):\n                '''\n                Data packet, size 64\n\n                type                      : data type (uint8_t)\n                len                       : data length (uint8_t)\n                data                      : raw data (uint8_t)\n\n                '''\n                return self.send(self.data64_encode(type, len, data), force_mavlink1=force_mavlink1)", "response": "Data packet size 64"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef data96_send(self, type, len, data, force_mavlink1=False):\n                '''\n                Data packet, size 96\n\n                type                      : data type (uint8_t)\n                len                       : data length (uint8_t)\n                data                      : raw data (uint8_t)\n\n                '''\n                return self.send(self.data96_encode(type, len, data), force_mavlink1=force_mavlink1)", "response": "Data packet size 96"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef airspeed_autocal_send(self, vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz, force_mavlink1=False):\n                '''\n                Airspeed auto-calibration\n\n                vx                        : GPS velocity north m/s (float)\n                vy                        : GPS velocity east m/s (float)\n                vz                        : GPS velocity down m/s (float)\n                diff_pressure             : Differential pressure pascals (float)\n                EAS2TAS                   : Estimated to true airspeed ratio (float)\n                ratio                     : Airspeed ratio (float)\n                state_x                   : EKF state x (float)\n                state_y                   : EKF state y (float)\n                state_z                   : EKF state z (float)\n                Pax                       : EKF Pax (float)\n                Pby                       : EKF Pby (float)\n                Pcz                       : EKF Pcz (float)\n\n                '''\n                return self.send(self.airspeed_autocal_encode(vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz), force_mavlink1=force_mavlink1)", "response": "Airspeed auto - calibration for all GPS systems."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rally_point_send(self, target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags, force_mavlink1=False):\n                '''\n                A rally point. Used to set a point when from GCS -> MAV. Also used to\n                return a point from MAV -> GCS\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                idx                       : point index (first point is 0) (uint8_t)\n                count                     : total number of points (for sanity checking) (uint8_t)\n                lat                       : Latitude of point in degrees * 1E7 (int32_t)\n                lng                       : Longitude of point in degrees * 1E7 (int32_t)\n                alt                       : Transit / loiter altitude in meters relative to home (int16_t)\n                break_alt                 : Break altitude in meters relative to home (int16_t)\n                land_dir                  : Heading to aim for when landing. In centi-degrees. (uint16_t)\n                flags                     : See RALLY_FLAGS enum for definition of the bitmask. (uint8_t)\n\n                '''\n                return self.send(self.rally_point_encode(target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags), force_mavlink1=force_mavlink1)", "response": "RALLY point. Used to set a point when from GCS -> GCS"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrequests a current rally point from the system.", "response": "def rally_fetch_point_send(self, target_system, target_component, idx, force_mavlink1=False):\n                '''\n                Request a current rally point from MAV. MAV should respond with a\n                RALLY_POINT message. MAV should not respond if the\n                request is invalid.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                idx                       : point index (first point is 0) (uint8_t)\n\n                '''\n                return self.send(self.rally_fetch_point_encode(target_system, target_component, idx), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compassmot_status_send(self, throttle, current, interference, CompensationX, CompensationY, CompensationZ, force_mavlink1=False):\n                '''\n                Status of compassmot calibration\n\n                throttle                  : throttle (percent*10) (uint16_t)\n                current                   : current (amps) (float)\n                interference              : interference (percent) (uint16_t)\n                CompensationX             : Motor Compensation X (float)\n                CompensationY             : Motor Compensation Y (float)\n                CompensationZ             : Motor Compensation Z (float)\n\n                '''\n                return self.send(self.compassmot_status_encode(throttle, current, interference, CompensationX, CompensationY, CompensationZ), force_mavlink1=force_mavlink1)", "response": "Status of compassmot calibration"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ahrs2_encode(self, roll, pitch, yaw, altitude, lat, lng):\n                '''\n                Status of secondary AHRS filter if available\n\n                roll                      : Roll angle (rad) (float)\n                pitch                     : Pitch angle (rad) (float)\n                yaw                       : Yaw angle (rad) (float)\n                altitude                  : Altitude (MSL) (float)\n                lat                       : Latitude in degrees * 1E7 (int32_t)\n                lng                       : Longitude in degrees * 1E7 (int32_t)\n\n                '''\n                return MAVLink_ahrs2_message(roll, pitch, yaw, altitude, lat, lng)", "response": "This function is called when the MAVLink module is loaded and is ready to send to AHRS2"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef camera_status_encode(self, time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4):\n                '''\n                Camera Event\n\n                time_usec                 : Image timestamp (microseconds since UNIX epoch, according to camera clock) (uint64_t)\n                target_system             : System ID (uint8_t)\n                cam_idx                   : Camera ID (uint8_t)\n                img_idx                   : Image index (uint16_t)\n                event_id                  : See CAMERA_STATUS_TYPES enum for definition of the bitmask (uint8_t)\n                p1                        : Parameter 1 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)\n                p2                        : Parameter 2 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)\n                p3                        : Parameter 3 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)\n                p4                        : Parameter 4 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)\n\n                '''\n                return MAVLink_camera_status_message(time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4)", "response": "Camera Event\n\n                time_usec                 : Image timestamp (microseconds since UNIX epoch, according to camera clock) (uint64_t)\n                target_system             : System ID (uint8_t)\n                cam_idx                   : Camera ID (uint8_t)\n                img_idx                   : Image index (uint16_t)\n                event_id                  : See CAMERA_STATUS_TYPES enum for definition of the bitmask (uint8_t)\n                p1                        : Parameter 1 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)\n                p2                        : Parameter 2 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)\n                p3                        : Parameter 3 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)\n                p4                        : Parameter 4 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef camera_feedback_encode(self, time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags):\n                '''\n                Camera Capture Feedback\n\n                time_usec                 : Image timestamp (microseconds since UNIX epoch), as passed in by CAMERA_STATUS message (or autopilot if no CCB) (uint64_t)\n                target_system             : System ID (uint8_t)\n                cam_idx                   : Camera ID (uint8_t)\n                img_idx                   : Image index (uint16_t)\n                lat                       : Latitude in (deg * 1E7) (int32_t)\n                lng                       : Longitude in (deg * 1E7) (int32_t)\n                alt_msl                   : Altitude Absolute (meters AMSL) (float)\n                alt_rel                   : Altitude Relative (meters above HOME location) (float)\n                roll                      : Camera Roll angle (earth frame, degrees, +-180) (float)\n                pitch                     : Camera Pitch angle (earth frame, degrees, +-180) (float)\n                yaw                       : Camera Yaw (earth frame, degrees, 0-360, true) (float)\n                foc_len                   : Focal Length (mm) (float)\n                flags                     : See CAMERA_FEEDBACK_FLAGS enum for definition of the bitmask (uint8_t)\n\n                '''\n                return MAVLink_camera_feedback_message(time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags)", "response": "Camera Capture Feedback Message"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef battery2_send(self, voltage, current_battery, force_mavlink1=False):\n                '''\n                2nd Battery status\n\n                voltage                   : voltage in millivolts (uint16_t)\n                current_battery           : Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current (int16_t)\n\n                '''\n                return self.send(self.battery2_encode(voltage, current_battery), force_mavlink1=force_mavlink1)", "response": "Battery 2. 0. 1. 0. 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrequests the autopilot version from the system and component.", "response": "def autopilot_version_request_send(self, target_system, target_component, force_mavlink1=False):\n                '''\n                Request the autopilot version from the system/component.\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n\n                '''\n                return self.send(self.autopilot_version_request_encode(target_system, target_component), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a block of log data to remote location target_system : System ID (uint8_t) target_component : Component ID (uint8_t) seqno : log data block sequence number (uint32_t) data : log data block (uint8_t)", "response": "def remote_log_data_block_encode(self, target_system, target_component, seqno, data):\n                '''\n                Send a block of log data to remote location\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seqno                     : log data block sequence number (uint32_t)\n                data                      : log data block (uint8_t)\n\n                '''\n                return MAVLink_remote_log_data_block_message(target_system, target_component, seqno, data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remote_log_data_block_send(self, target_system, target_component, seqno, data, force_mavlink1=False):\n                '''\n                Send a block of log data to remote location\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seqno                     : log data block sequence number (uint32_t)\n                data                      : log data block (uint8_t)\n\n                '''\n                return self.send(self.remote_log_data_block_encode(target_system, target_component, seqno, data), force_mavlink1=force_mavlink1)", "response": "This message is sent to the remote location of the log data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending Status of each log block that autopilot board might have sent target_system : System ID (uint8_t) target_component : Component ID (uint8_t) seqno : log data block sequence number (uint32_t) status : log data block status (uint8_t)", "response": "def remote_log_block_status_encode(self, target_system, target_component, seqno, status):\n                '''\n                Send Status of each log block that autopilot board might have sent\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seqno                     : log data block sequence number (uint32_t)\n                status                    : log data block status (uint8_t)\n\n                '''\n                return MAVLink_remote_log_block_status_message(target_system, target_component, seqno, status)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend Status of each log block that autopilot board might have sent target_system : System ID (uint8_t) target_component : Component ID (uint8_t) seqno : log data block sequence number (uint32_t) status : log data block status (uint8_t)", "response": "def remote_log_block_status_send(self, target_system, target_component, seqno, status, force_mavlink1=False):\n                '''\n                Send Status of each log block that autopilot board might have sent\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                seqno                     : log data block sequence number (uint32_t)\n                status                    : log data block status (uint8_t)\n\n                '''\n                return self.send(self.remote_log_block_status_encode(target_system, target_component, seqno, status), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef led_control_encode(self, target_system, target_component, instance, pattern, custom_len, custom_bytes):\n                '''\n                Control vehicle LEDs\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                instance                  : Instance (LED instance to control or 255 for all LEDs) (uint8_t)\n                pattern                   : Pattern (see LED_PATTERN_ENUM) (uint8_t)\n                custom_len                : Custom Byte Length (uint8_t)\n                custom_bytes              : Custom Bytes (uint8_t)\n\n                '''\n                return MAVLink_led_control_message(target_system, target_component, instance, pattern, custom_len, custom_bytes)", "response": "This function encodes the message used to control the LEDs in the control vehicle."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef led_control_send(self, target_system, target_component, instance, pattern, custom_len, custom_bytes, force_mavlink1=False):\n                '''\n                Control vehicle LEDs\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                instance                  : Instance (LED instance to control or 255 for all LEDs) (uint8_t)\n                pattern                   : Pattern (see LED_PATTERN_ENUM) (uint8_t)\n                custom_len                : Custom Byte Length (uint8_t)\n                custom_bytes              : Custom Bytes (uint8_t)\n\n                '''\n                return self.send(self.led_control_encode(target_system, target_component, instance, pattern, custom_len, custom_bytes), force_mavlink1=force_mavlink1)", "response": "Control vehicle LEDs\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                instance                  : Instance (LED instance to control or 255 for all LEDs) (uint8_t)\n                pattern                   : Pattern (see LED_PATTERN_ENUM) (uint8_t)\n                custom_len                : Custom Byte Length (uint8_t)\n                custom_bytes              : Custom Bytes (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisplay the current status of calibrated compass calibration.", "response": "def mag_cal_progress_encode(self, compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z):\n                '''\n                Reports progress of compass calibration.\n\n                compass_id                : Compass being calibrated (uint8_t)\n                cal_mask                  : Bitmask of compasses being calibrated (uint8_t)\n                cal_status                : Status (see MAG_CAL_STATUS enum) (uint8_t)\n                attempt                   : Attempt number (uint8_t)\n                completion_pct            : Completion percentage (uint8_t)\n                completion_mask           : Bitmask of sphere sections (see http://en.wikipedia.org/wiki/Geodesic_grid) (uint8_t)\n                direction_x               : Body frame direction vector for display (float)\n                direction_y               : Body frame direction vector for display (float)\n                direction_z               : Body frame direction vector for display (float)\n\n                '''\n                return MAVLink_mag_cal_progress_message(compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mag_cal_progress_send(self, compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z, force_mavlink1=False):\n                '''\n                Reports progress of compass calibration.\n\n                compass_id                : Compass being calibrated (uint8_t)\n                cal_mask                  : Bitmask of compasses being calibrated (uint8_t)\n                cal_status                : Status (see MAG_CAL_STATUS enum) (uint8_t)\n                attempt                   : Attempt number (uint8_t)\n                completion_pct            : Completion percentage (uint8_t)\n                completion_mask           : Bitmask of sphere sections (see http://en.wikipedia.org/wiki/Geodesic_grid) (uint8_t)\n                direction_x               : Body frame direction vector for display (float)\n                direction_y               : Body frame direction vector for display (float)\n                direction_z               : Body frame direction vector for display (float)\n\n                '''\n                return self.send(self.mag_cal_progress_encode(compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z), force_mavlink1=force_mavlink1)", "response": "Progress of calibrating the compass calibration."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mag_cal_report_encode(self, compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z):\n                '''\n                Reports results of completed compass calibration. Sent until\n                MAG_CAL_ACK received.\n\n                compass_id                : Compass being calibrated (uint8_t)\n                cal_mask                  : Bitmask of compasses being calibrated (uint8_t)\n                cal_status                : Status (see MAG_CAL_STATUS enum) (uint8_t)\n                autosaved                 : 0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters (uint8_t)\n                fitness                   : RMS milligauss residuals (float)\n                ofs_x                     : X offset (float)\n                ofs_y                     : Y offset (float)\n                ofs_z                     : Z offset (float)\n                diag_x                    : X diagonal (matrix 11) (float)\n                diag_y                    : Y diagonal (matrix 22) (float)\n                diag_z                    : Z diagonal (matrix 33) (float)\n                offdiag_x                 : X off-diagonal (matrix 12 and 21) (float)\n                offdiag_y                 : Y off-diagonal (matrix 13 and 31) (float)\n                offdiag_z                 : Z off-diagonal (matrix 32 and 23) (float)\n\n                '''\n                return MAVLink_mag_cal_report_message(compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z)", "response": "This function is called when a MAG calibration is completed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreporting results of completed compass calibration. Sent until MAG_CAL_ACK received. compass_id : Compass being calibrated (uint8_t) cal_mask : Bitmask of compasses being calibrated (uint8_t) cal_status : Status (see MAG_CAL_STATUS enum) (uint8_t) autosaved : 0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters (uint8_t) fitness : RMS milligauss residuals (float) ofs_x : X offset (float) ofs_y : Y offset (float) ofs_z : Z offset (float) diag_x : X diagonal (matrix 11) (float) diag_y : Y diagonal (matrix 22) (float) diag_z : Z diagonal (matrix 33) (float) offdiag_x : X off-diagonal (matrix 12 and 21) (float) offdiag_y : Y off-diagonal (matrix 13 and 31) (float) offdiag_z : Z off-diagonal (matrix 32 and 23) (float)", "response": "def mag_cal_report_send(self, compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z, force_mavlink1=False):\n                '''\n                Reports results of completed compass calibration. Sent until\n                MAG_CAL_ACK received.\n\n                compass_id                : Compass being calibrated (uint8_t)\n                cal_mask                  : Bitmask of compasses being calibrated (uint8_t)\n                cal_status                : Status (see MAG_CAL_STATUS enum) (uint8_t)\n                autosaved                 : 0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters (uint8_t)\n                fitness                   : RMS milligauss residuals (float)\n                ofs_x                     : X offset (float)\n                ofs_y                     : Y offset (float)\n                ofs_z                     : Z offset (float)\n                diag_x                    : X diagonal (matrix 11) (float)\n                diag_y                    : Y diagonal (matrix 22) (float)\n                diag_z                    : Z diagonal (matrix 33) (float)\n                offdiag_x                 : X off-diagonal (matrix 12 and 21) (float)\n                offdiag_y                 : Y off-diagonal (matrix 13 and 31) (float)\n                offdiag_z                 : Z off-diagonal (matrix 32 and 23) (float)\n\n                '''\n                return self.send(self.mag_cal_report_encode(compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ekf_status_report_send(self, flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance, force_mavlink1=False):\n                '''\n                EKF Status message including flags and variances\n\n                flags                     : Flags (uint16_t)\n                velocity_variance         : Velocity variance (float)\n                pos_horiz_variance        : Horizontal Position variance (float)\n                pos_vert_variance         : Vertical Position variance (float)\n                compass_variance          : Compass variance (float)\n                terrain_alt_variance        : Terrain Altitude variance (float)\n\n                '''\n                return self.send(self.ekf_status_report_encode(flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance), force_mavlink1=force_mavlink1)", "response": "EKF Status message including flags and variances\n\n                flags                     : Flags (uint16_t)\n                velocity_variance         : Velocity variance (float)\n                pos_horiz_variance        : Horizontal Position variance (float)\n                pos_vert_variance         : Vertical Position variance (float)\n                compass_variance          : Compass variance (float)\n                terrain_alt_variance        : Terrain Altitude variance (float)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pid_tuning_encode(self, axis, desired, achieved, FF, P, I, D):\n                '''\n                PID tuning information\n\n                axis                      : axis (uint8_t)\n                desired                   : desired rate (degrees/s) (float)\n                achieved                  : achieved rate (degrees/s) (float)\n                FF                        : FF component (float)\n                P                         : P component (float)\n                I                         : I component (float)\n                D                         : D component (float)\n\n                '''\n                return MAVLink_pid_tuning_message(axis, desired, achieved, FF, P, I, D)", "response": "This function is called when the PID tuning is done."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gimbal_report_encode(self, target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az):\n                '''\n                3 axis gimbal mesuraments\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                delta_time                : Time since last update (seconds) (float)\n                delta_angle_x             : Delta angle X (radians) (float)\n                delta_angle_y             : Delta angle Y (radians) (float)\n                delta_angle_z             : Delta angle X (radians) (float)\n                delta_velocity_x          : Delta velocity X (m/s) (float)\n                delta_velocity_y          : Delta velocity Y (m/s) (float)\n                delta_velocity_z          : Delta velocity Z (m/s) (float)\n                joint_roll                : Joint ROLL (radians) (float)\n                joint_el                  : Joint EL (radians) (float)\n                joint_az                  : Joint AZ (radians) (float)\n\n                '''\n                return MAVLink_gimbal_report_message(target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az)", "response": "3 axis gimbal mesuraments\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                delta_time                : Time since last update (seconds) (float)\n                delta_angle_x             : Delta angle X (radians) (float)\n                delta_angle_y             : Delta angle Y (radians) (float)\n                delta_angle_z             : Delta angle X (radians) (float)\n                delta_velocity_x          : Delta velocity X (m/s) (float)\n                delta_velocity_y          : Delta velocity Y (m/s) (float)\n                delta_velocity_z          : Delta velocity Z (m/s) (float)\n                joint_roll                : Joint ROLL (radians) (float)\n                joint_el                  : Joint EL (radians) (float)\n                joint_az                  : Joint AZ (radians) (float)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncontrol message for rate gimbal target_system : System ID (uint8_t) target_component : Component ID (uint8_t) demanded_rate_x : Demanded angular rate X (rad/s) (float) demanded_rate_y : Demanded angular rate Y (rad/s) (float) demanded_rate_z : Demanded angular rate Z (rad/s) (float)", "response": "def gimbal_control_encode(self, target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z):\n                '''\n                Control message for rate gimbal\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                demanded_rate_x           : Demanded angular rate X (rad/s) (float)\n                demanded_rate_y           : Demanded angular rate Y (rad/s) (float)\n                demanded_rate_z           : Demanded angular rate Z (rad/s) (float)\n\n                '''\n                return MAVLink_gimbal_control_message(target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gimbal_control_send(self, target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z, force_mavlink1=False):\n                '''\n                Control message for rate gimbal\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                demanded_rate_x           : Demanded angular rate X (rad/s) (float)\n                demanded_rate_y           : Demanded angular rate Y (rad/s) (float)\n                demanded_rate_z           : Demanded angular rate Z (rad/s) (float)\n\n                '''\n                return self.send(self.gimbal_control_encode(target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z), force_mavlink1=force_mavlink1)", "response": "Control message for rate gimbal"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gimbal_torque_cmd_report_encode(self, target_system, target_component, rl_torque_cmd, el_torque_cmd, az_torque_cmd):\n                '''\n                100 Hz gimbal torque command telemetry\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                rl_torque_cmd             : Roll Torque Command (int16_t)\n                el_torque_cmd             : Elevation Torque Command (int16_t)\n                az_torque_cmd             : Azimuth Torque Command (int16_t)\n\n                '''\n                return MAVLink_gimbal_torque_cmd_report_message(target_system, target_component, rl_torque_cmd, el_torque_cmd, az_torque_cmd)", "response": "Gimbal Torque Command Report"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gopro_heartbeat_send(self, status, capture_mode, flags, force_mavlink1=False):\n                '''\n                Heartbeat from a HeroBus attached GoPro\n\n                status                    : Status (uint8_t)\n                capture_mode              : Current capture mode (uint8_t)\n                flags                     : additional status bits (uint8_t)\n\n                '''\n                return self.send(self.gopro_heartbeat_encode(status, capture_mode, flags), force_mavlink1=force_mavlink1)", "response": "Heartbeat from a HeroBus attached GoPro\n               "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrequest a GOPRO_COMMAND response from the GoPro", "response": "def gopro_get_request_send(self, target_system, target_component, cmd_id, force_mavlink1=False):\n                '''\n                Request a GOPRO_COMMAND response from the GoPro\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                cmd_id                    : Command ID (uint8_t)\n\n                '''\n                return self.send(self.gopro_get_request_encode(target_system, target_component, cmd_id), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gopro_get_response_send(self, cmd_id, status, value, force_mavlink1=False):\n                '''\n                Response from a GOPRO_COMMAND get request\n\n                cmd_id                    : Command ID (uint8_t)\n                status                    : Status (uint8_t)\n                value                     : Value (uint8_t)\n\n                '''\n                return self.send(self.gopro_get_response_encode(cmd_id, status, value), force_mavlink1=force_mavlink1)", "response": "This function is used to send the response from a GOPRO_COMMAND get request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gopro_set_request_encode(self, target_system, target_component, cmd_id, value):\n                '''\n                Request to set a GOPRO_COMMAND with a desired\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                cmd_id                    : Command ID (uint8_t)\n                value                     : Value (uint8_t)\n\n                '''\n                return MAVLink_gopro_set_request_message(target_system, target_component, cmd_id, value)", "response": "Set a GOPRO_COMMAND with a desired value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef gopro_set_request_send(self, target_system, target_component, cmd_id, value, force_mavlink1=False):\n                '''\n                Request to set a GOPRO_COMMAND with a desired\n\n                target_system             : System ID (uint8_t)\n                target_component          : Component ID (uint8_t)\n                cmd_id                    : Command ID (uint8_t)\n                value                     : Value (uint8_t)\n\n                '''\n                return self.send(self.gopro_set_request_encode(target_system, target_component, cmd_id, value), force_mavlink1=force_mavlink1)", "response": "Set a GOPRO_COMMAND with a desired value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rpm_send(self, rpm1, rpm2, force_mavlink1=False):\n                '''\n                RPM sensor output\n\n                rpm1                      : RPM Sensor1 (float)\n                rpm2                      : RPM Sensor2 (float)\n\n                '''\n                return self.send(self.rpm_encode(rpm1, rpm2), force_mavlink1=force_mavlink1)", "response": "RPM sensor output\n\n                rpm1                      : RPM Sensor1 (float)\n                rpm2                      : RPM Sensor2 (float)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uavionix_adsb_out_cfg_encode(self, ICAO, callsign, emitterType, aircraftSize, gpsOffsetLat, gpsOffsetLon, stallSpeed, rfSelect):\n                '''\n                Static data to configure the ADS-B transponder (send within 10 sec of\n                a POR and every 10 sec thereafter)\n\n                ICAO                      : Vehicle address (24 bit) (uint32_t)\n                callsign                  : Vehicle identifier (8 characters, null terminated, valid characters are A-Z, 0-9, \" \" only) (char)\n                emitterType               : Transmitting vehicle type. See ADSB_EMITTER_TYPE enum (uint8_t)\n                aircraftSize              : Aircraft length and width encoding (table 2-35 of DO-282B) (uint8_t)\n                gpsOffsetLat              : GPS antenna lateral offset (table 2-36 of DO-282B) (uint8_t)\n                gpsOffsetLon              : GPS antenna longitudinal offset from nose [if non-zero, take position (in meters) divide by 2 and add one] (table 2-37 DO-282B) (uint8_t)\n                stallSpeed                : Aircraft stall speed in cm/s (uint16_t)\n                rfSelect                  : ADS-B transponder reciever and transmit enable flags (uint8_t)\n\n                '''\n                return MAVLink_uavionix_adsb_out_cfg_message(ICAO, callsign, emitterType, aircraftSize, gpsOffsetLat, gpsOffsetLon, stallSpeed, rfSelect)", "response": "UAVIONIX ADS - B OUT configuration message"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef uavionix_adsb_out_cfg_send(self, ICAO, callsign, emitterType, aircraftSize, gpsOffsetLat, gpsOffsetLon, stallSpeed, rfSelect, force_mavlink1=False):\n                '''\n                Static data to configure the ADS-B transponder (send within 10 sec of\n                a POR and every 10 sec thereafter)\n\n                ICAO                      : Vehicle address (24 bit) (uint32_t)\n                callsign                  : Vehicle identifier (8 characters, null terminated, valid characters are A-Z, 0-9, \" \" only) (char)\n                emitterType               : Transmitting vehicle type. See ADSB_EMITTER_TYPE enum (uint8_t)\n                aircraftSize              : Aircraft length and width encoding (table 2-35 of DO-282B) (uint8_t)\n                gpsOffsetLat              : GPS antenna lateral offset (table 2-36 of DO-282B) (uint8_t)\n                gpsOffsetLon              : GPS antenna longitudinal offset from nose [if non-zero, take position (in meters) divide by 2 and add one] (table 2-37 DO-282B) (uint8_t)\n                stallSpeed                : Aircraft stall speed in cm/s (uint16_t)\n                rfSelect                  : ADS-B transponder reciever and transmit enable flags (uint8_t)\n\n                '''\n                return self.send(self.uavionix_adsb_out_cfg_encode(ICAO, callsign, emitterType, aircraftSize, gpsOffsetLat, gpsOffsetLon, stallSpeed, rfSelect), force_mavlink1=force_mavlink1)", "response": "Configure the ADS - B transponder."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef uavionix_adsb_out_dynamic_encode(self, utcTime, gpsLat, gpsLon, gpsAlt, gpsFix, numSats, baroAltMSL, accuracyHor, accuracyVert, accuracyVel, velVert, velNS, VelEW, emergencyStatus, state, squawk):\n                '''\n                Dynamic data used to generate ADS-B out transponder data (send at 5Hz)\n\n                utcTime                   : UTC time in seconds since GPS epoch (Jan 6, 1980). If unknown set to UINT32_MAX (uint32_t)\n                gpsLat                    : Latitude WGS84 (deg * 1E7). If unknown set to INT32_MAX (int32_t)\n                gpsLon                    : Longitude WGS84 (deg * 1E7). If unknown set to INT32_MAX (int32_t)\n                gpsAlt                    : Altitude in mm (m * 1E-3) UP +ve. WGS84 altitude. If unknown set to INT32_MAX (int32_t)\n                gpsFix                    : 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK (uint8_t)\n                numSats                   : Number of satellites visible. If unknown set to UINT8_MAX (uint8_t)\n                baroAltMSL                : Barometric pressure altitude relative to a standard atmosphere of 1013.2 mBar and NOT bar corrected altitude (m * 1E-3). (up +ve). If unknown set to INT32_MAX (int32_t)\n                accuracyHor               : Horizontal accuracy in mm (m * 1E-3). If unknown set to UINT32_MAX (uint32_t)\n                accuracyVert              : Vertical accuracy in cm. If unknown set to UINT16_MAX (uint16_t)\n                accuracyVel               : Velocity accuracy in mm/s (m * 1E-3). If unknown set to UINT16_MAX (uint16_t)\n                velVert                   : GPS vertical speed in cm/s. If unknown set to INT16_MAX (int16_t)\n                velNS                     : North-South velocity over ground in cm/s North +ve. If unknown set to INT16_MAX (int16_t)\n                VelEW                     : East-West velocity over ground in cm/s East +ve. If unknown set to INT16_MAX (int16_t)\n                emergencyStatus           : Emergency status (uint8_t)\n                state                     : ADS-B transponder dynamic input state flags (uint16_t)\n                squawk                    : Mode A code (typically 1200 [0x04B0] for VFR) (uint16_t)\n\n                '''\n                return MAVLink_uavionix_adsb_out_dynamic_message(utcTime, gpsLat, gpsLon, gpsAlt, gpsFix, numSats, baroAltMSL, accuracyHor, accuracyVert, accuracyVel, velVert, velNS, VelEW, emergencyStatus, state, squawk)", "response": "This method encodes the dynamic data used to generate an ADS - B out transponder data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef uavionix_adsb_out_dynamic_send(self, utcTime, gpsLat, gpsLon, gpsAlt, gpsFix, numSats, baroAltMSL, accuracyHor, accuracyVert, accuracyVel, velVert, velNS, VelEW, emergencyStatus, state, squawk, force_mavlink1=False):\n                '''\n                Dynamic data used to generate ADS-B out transponder data (send at 5Hz)\n\n                utcTime                   : UTC time in seconds since GPS epoch (Jan 6, 1980). If unknown set to UINT32_MAX (uint32_t)\n                gpsLat                    : Latitude WGS84 (deg * 1E7). If unknown set to INT32_MAX (int32_t)\n                gpsLon                    : Longitude WGS84 (deg * 1E7). If unknown set to INT32_MAX (int32_t)\n                gpsAlt                    : Altitude in mm (m * 1E-3) UP +ve. WGS84 altitude. If unknown set to INT32_MAX (int32_t)\n                gpsFix                    : 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK (uint8_t)\n                numSats                   : Number of satellites visible. If unknown set to UINT8_MAX (uint8_t)\n                baroAltMSL                : Barometric pressure altitude relative to a standard atmosphere of 1013.2 mBar and NOT bar corrected altitude (m * 1E-3). (up +ve). If unknown set to INT32_MAX (int32_t)\n                accuracyHor               : Horizontal accuracy in mm (m * 1E-3). If unknown set to UINT32_MAX (uint32_t)\n                accuracyVert              : Vertical accuracy in cm. If unknown set to UINT16_MAX (uint16_t)\n                accuracyVel               : Velocity accuracy in mm/s (m * 1E-3). If unknown set to UINT16_MAX (uint16_t)\n                velVert                   : GPS vertical speed in cm/s. If unknown set to INT16_MAX (int16_t)\n                velNS                     : North-South velocity over ground in cm/s North +ve. If unknown set to INT16_MAX (int16_t)\n                VelEW                     : East-West velocity over ground in cm/s East +ve. If unknown set to INT16_MAX (int16_t)\n                emergencyStatus           : Emergency status (uint8_t)\n                state                     : ADS-B transponder dynamic input state flags (uint16_t)\n                squawk                    : Mode A code (typically 1200 [0x04B0] for VFR) (uint16_t)\n\n                '''\n                return self.send(self.uavionix_adsb_out_dynamic_encode(utcTime, gpsLat, gpsLon, gpsAlt, gpsFix, numSats, baroAltMSL, accuracyHor, accuracyVert, accuracyVel, velVert, velNS, VelEW, emergencyStatus, state, squawk), force_mavlink1=force_mavlink1)", "response": "Dynamic data generated by uavionix_adsb_out_dynamic_recv"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert(self, value, fromunits, tounits):\n        '''convert a value from one set of units to another'''\n        if fromunits == tounits:\n            return value\n        if (fromunits,tounits) in self.unitmap:\n            return value * self.unitmap[(fromunits,tounits)]\n        if (tounits,fromunits) in self.unitmap:\n            return value / self.unitmap[(tounits,fromunits)]\n        raise fgFDMError(\"unknown unit mapping (%s,%s)\" % (fromunits, tounits))", "response": "convert a value from one set of units to another"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef units(self, varname):\n        '''return the default units of a variable'''\n        if not varname in self.mapping.vars:\n            raise fgFDMError('Unknown variable %s' % varname)\n        return self.mapping.vars[varname].units", "response": "return the default units of a variable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of available variables", "response": "def variables(self):\n        '''return a list of available variables'''\n        return sorted(list(self.mapping.vars.keys()),\n                      key = lambda v : self.mapping.vars[v].index)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a variable value", "response": "def get(self, varname, idx=0, units=None):\n        '''get a variable value'''\n        if not varname in self.mapping.vars:\n            raise fgFDMError('Unknown variable %s' % varname)\n        if idx >= self.mapping.vars[varname].arraylength:\n            raise fgFDMError('index of %s beyond end of array idx=%u arraylength=%u' % (\n                varname, idx, self.mapping.vars[varname].arraylength))\n        value = self.values[self.mapping.vars[varname].index + idx]\n        if units:\n            value = self.convert(value, self.mapping.vars[varname].units, units)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a variable value", "response": "def set(self, varname, value, idx=0, units=None):\n        '''set a variable value'''\n        if not varname in self.mapping.vars:\n            raise fgFDMError('Unknown variable %s' % varname)\n        if idx >= self.mapping.vars[varname].arraylength:\n            raise fgFDMError('index of %s beyond end of array idx=%u arraylength=%u' % (\n                varname, idx, self.mapping.vars[varname].arraylength))\n        if units:\n            value = self.convert(value, units, self.mapping.vars[varname].units)\n        # avoid range errors when packing into 4 byte floats\n        if math.isinf(value) or math.isnan(value) or math.fabs(value) > 3.4e38:\n            value = 0\n        self.values[self.mapping.vars[varname].index + idx] = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a FD FDM buffer", "response": "def parse(self, buf):\n        '''parse a FD FDM buffer'''\n        try:\n            t = struct.unpack(self.pack_string, buf)\n        except struct.error as msg:\n            raise fgFDMError('unable to parse - %s' % msg)\n        self.values = list(t)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npacking a FD FDM buffer from current values", "response": "def pack(self):\n        '''pack a FD FDM buffer from current values'''\n        for i in range(len(self.values)):\n            if math.isnan(self.values[i]):\n                self.values[i] = 0\n        return struct.pack(self.pack_string, *self.values)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef quat2Yaw(qw, qx, qy, qz):\n    '''\n    Translates from Quaternion to Yaw. \n\n    @param qw,qx,qy,qz: Quaternion values\n\n    @type qw,qx,qy,qz: float\n\n    @return Yaw value translated from Quaternion\n\n    '''\n    rotateZa0=2.0*(qx*qy + qw*qz)\n    rotateZa1=qw*qw + qx*qx - qy*qy - qz*qz\n    rotateZ=0.0\n    if(rotateZa0 != 0.0 and rotateZa1 != 0.0):\n        rotateZ=atan2(rotateZa0,rotateZa1)\n    return rotateZ", "response": "Translate from Quaternion to Yaw."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef quat2Pitch(qw, qx, qy, qz):\n    '''\n    Translates from Quaternion to Pitch. \n\n    @param qw,qx,qy,qz: Quaternion values\n\n    @type qw,qx,qy,qz: float\n\n    @return Pitch value translated from Quaternion\n\n    '''\n\n    rotateYa0=-2.0*(qx*qz - qw*qy)\n    rotateY=0.0\n    if(rotateYa0 >= 1.0):\n        rotateY = pi/2.0\n    elif(rotateYa0 <= -1.0):\n        rotateY = -pi/2.0\n    else:\n        rotateY = asin(rotateYa0)\n\n    return rotateY", "response": "Translate from Quaternion to Pitch. \n"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef odometry2Pose3D(odom):\n    '''\n    Translates from ROS Odometry to JderobotTypes Pose3d. \n\n    @param odom: ROS Odometry to translate\n\n    @type odom: Odometry\n\n    @return a Pose3d translated from odom\n\n    '''\n    pose = Pose3d()\n    ori = odom.pose.pose.orientation\n\n    pose.x = odom.pose.pose.position.x\n    pose.y = odom.pose.pose.position.y\n    pose.z = odom.pose.pose.position.z\n    #pose.h = odom.pose.pose.position.h\n    pose.yaw = quat2Yaw(ori.w, ori.x, ori.y, ori.z)\n    pose.pitch = quat2Pitch(ori.w, ori.x, ori.y, ori.z)\n    pose.roll = quat2Roll(ori.w, ori.x, ori.y, ori.z)\n    pose.q = [ori.w, ori.x, ori.y, ori.z]\n    pose.timeStamp = odom.header.stamp.secs + (odom.header.stamp.nsecs *1e-9)\n\n    return pose", "response": "Translate from ROS Odometry to JderobotTypes Pose3d. \n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __callback (self, odom):\n        '''\n        Callback function to receive and save Pose3d. \n\n        @param odom: ROS Odometry received\n        \n        @type odom: Odometry\n\n        '''\n        pose = odometry2Pose3D(odom)\n\n        self.lock.acquire()\n        self.data = pose\n        self.lock.release()", "response": "Callback function to receive and save Pose3d. \n"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart (Subscribes) the client.", "response": "def start (self):\n        '''\n        Starts (Subscribes) the client.\n\n        '''\n        self.sub = rospy.Subscriber(self.topic, Odometry, self.__callback)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clip(self, px, py, w, h, img):\n        '''clip an area for display on the map'''\n        sx = 0\n        sy = 0\n\n        if px < 0:\n            sx = -px\n            w += px\n            px = 0\n        if py < 0:\n            sy = -py\n            h += py\n            py = 0\n        if px+w > img.width:\n            w = img.width - px\n        if py+h > img.height:\n            h = img.height - py\n        return (px, py, sx, sy, w, h)", "response": "clip an area for display on the map"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndrawing a line on the image", "response": "def draw_line(self, img, pixmapper, pt1, pt2, colour, linewidth):\n        '''draw a line on the image'''\n        pix1 = pixmapper(pt1)\n        pix2 = pixmapper(pt2)\n        clipped = cv.ClipLine((img.width, img.height), pix1, pix2)\n        if clipped is None:\n            if len(self._pix_points) == 0:\n                self._pix_points.append(None)\n            self._pix_points.append(None)\n            return\n        (pix1, pix2) = clipped\n        cv.Line(img, pix1, pix2, colour, linewidth)\n        cv.Circle(img, pix2, linewidth*2, colour)\n        if len(self._pix_points) == 0:\n            self._pix_points.append(pix1)\n        self._pix_points.append(pix2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndrawing a polygon on the image", "response": "def draw(self, img, pixmapper, bounds):\n        '''draw a polygon on the image'''\n        if self.hidden:\n            return\n        self._pix_points = []\n        for i in range(len(self.points)-1):\n            if len(self.points[i]) > 2:\n                colour = self.points[i][2]\n            else:\n                colour = self.colour\n            self.draw_line(img, pixmapper, self.points[i], self.points[i+1],\n                           colour, self.linewidth)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsee if the polygon has been clicked on. Consider it clicked if the pixel is within 6 of the point", "response": "def clicked(self, px, py):\n        '''see if the polygon has been clicked on.\n        Consider it clicked if the pixel is within 6 of the point\n        '''\n        if self.hidden:\n            return None\n        for i in range(len(self._pix_points)):\n            if self._pix_points[i] is None:\n                continue\n            (pixx,pixy) = self._pix_points[i]\n            if abs(px - pixx) < 6 and abs(py - pixy) < 6:\n                self._selected_vertex = i\n                return math.sqrt((px - pixx)**2 + (py - pixy)**2)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef draw_line(self, img, pixmapper, pt1, pt2, colour, linewidth):\n        '''draw a line on the image'''\n        pix1 = pixmapper(pt1)\n        pix2 = pixmapper(pt2)\n        clipped = cv.ClipLine((img.width, img.height), pix1, pix2)\n        if clipped is None:\n            return\n        (pix1, pix2) = clipped\n        cv.Line(img, pix1, pix2, colour, linewidth)\n        cv.Circle(img, pix2, linewidth*2, colour)", "response": "draw a line on the image"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndraws a polygon on the image", "response": "def draw(self, img, pixmapper, bounds):\n        '''draw a polygon on the image'''\n        if self.hidden:\n            return\n        (x,y,w,h) = bounds\n        spacing = 1000\n        while True:\n            start = mp_util.latlon_round((x,y), spacing)\n            dist = mp_util.gps_distance(x,y,x+w,y+h)\n            count = int(dist / spacing)\n            if count < 2:\n                spacing /= 10\n            elif count > 50:\n                spacing *= 10\n            else:\n                break\n\n        for i in range(count*2+2):\n            pos1 = mp_util.gps_newpos(start[0], start[1], 90, i*spacing)\n            pos3 = mp_util.gps_newpos(pos1[0], pos1[1], 0, 3*count*spacing)\n            self.draw_line(img, pixmapper, pos1, pos3, self.colour, self.linewidth)\n\n            pos1 = mp_util.gps_newpos(start[0], start[1], 0, i*spacing)\n            pos3 = mp_util.gps_newpos(pos1[0], pos1[1], 90, 3*count*spacing)\n            self.draw_line(img, pixmapper, pos1, pos3, self.colour, self.linewidth)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef img(self):\n        '''return a cv image for the thumbnail'''\n        if self._img is not None:\n            return self._img\n        self._img = cv.CreateImage((self.width, self.height), 8, 3)\n        cv.SetData(self._img, self.imgstr)\n        cv.CvtColor(self._img, self._img, cv.CV_BGR2RGB)\n        if self.border_width and self.border_colour is not None:\n            cv.Rectangle(self._img, (0, 0), (self.width-1, self.height-1),\n                         self.border_colour, self.border_width)\n        return self._img", "response": "return a cv image for the thumbnail"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsees if the image has been clicked on", "response": "def clicked(self, px, py):\n        '''see if the image has been clicked on'''\n        if self.hidden:\n            return None\n        if (abs(px - self.posx) > self.width/2 or\n            abs(py - self.posy) > self.height/2):\n            return None\n        return math.sqrt((px-self.posx)**2 + (py-self.posy)**2)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_position(self, newpos):\n        '''update trail'''\n        tnow = time.time()\n        if tnow >= self.last_time + self.timestep:\n            self.points.append(newpos.latlon)\n            self.last_time = tnow\n            while len(self.points) > self.count:\n                self.points.pop(0)", "response": "update trail with new position"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a cv image for the icon", "response": "def img(self):\n        '''return a cv image for the icon'''\n        SlipThumbnail.img(self)\n\n        if self.rotation:\n            # rotate the image\n            mat = cv.CreateMat(2, 3, cv.CV_32FC1)\n            cv.GetRotationMatrix2D((self.width/2,self.height/2),\n                                   -self.rotation, 1.0, mat)\n            self._rotated = cv.CloneImage(self._img)\n            cv.WarpAffine(self._img, self._rotated, mat)\n        else:\n            self._rotated = self._img\n        return self._rotated"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef draw(self, img, pixmapper, bounds):\n        '''draw the icon on the image'''\n\n        if self.hidden:\n            return\n\n        if self.trail is not None:\n            self.trail.draw(img, pixmapper, bounds)\n\n        icon = self.img()\n        (px,py) = pixmapper(self.latlon)\n\n        # find top left\n        px -= icon.width/2\n        py -= icon.height/2\n        w = icon.width\n        h = icon.height\n\n        (px, py, sx, sy, w, h) = self.clip(px, py, w, h, img)\n\n        cv.SetImageROI(icon, (sx, sy, w, h))\n        cv.SetImageROI(img, (px, py, w, h))\n        cv.Add(icon, img, img)\n        cv.ResetImageROI(img)\n        cv.ResetImageROI(icon)\n\n        # remember where we placed it for clicked()\n        self.posx = px+w/2\n        self.posy = py+h/2", "response": "draw the icon on the image"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a wx image", "response": "def img(self):\n        '''return a wx image'''\n        import wx\n        img = wx.EmptyImage(self.width, self.height)\n        img.SetData(self.imgstr)\n        return img"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate and set text size handling multi - line", "response": "def _resize(self):\n        '''calculate and set text size, handling multi-line'''\n        lines = self.text.split('\\n')\n        xsize, ysize = 0, 0\n        for line in lines:\n            size = self.textctrl.GetTextExtent(line)\n            xsize = max(xsize, size[0])\n            ysize = ysize + size[1]\n        xsize = int(xsize*1.2)\n        self.textctrl.SetSize((xsize, ysize))\n        self.textctrl.SetMinSize((xsize, ysize))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pixel_coords(latlon, ground_width=0, mt=None, topleft=None, width=None):\n    '''return pixel coordinates in the map image for a (lat,lon)'''\n    (lat,lon) = (latlon[0], latlon[1])\n    return mt.coord_to_pixel(topleft[0], topleft[1], width, ground_width, lat, lon)", "response": "return pixel coordinates in the map image for a ( lat lon )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_imagefile(options, filename, latlon, ground_width, path_objs, mission_obj, fence_obj, width=600, height=600):\n    '''create path and mission as an image file'''\n    mt = mp_tile.MPTile(service=options.service)\n\n    map_img = mt.area_to_image(latlon[0], latlon[1],\n                               width, height, ground_width)\n    while mt.tiles_pending() > 0:\n        print(\"Waiting on %u tiles\" % mt.tiles_pending())\n        time.sleep(1)\n    map_img = mt.area_to_image(latlon[0], latlon[1],\n                               width, height, ground_width)\n    # a function to convert from (lat,lon) to (px,py) on the map\n    pixmapper = functools.partial(pixel_coords, ground_width=ground_width, mt=mt, topleft=latlon, width=width)\n    for path_obj in path_objs:\n        path_obj.draw(map_img, pixmapper, None)\n    if mission_obj is not None:\n        for m in mission_obj:\n            m.draw(map_img, pixmapper, None)\n    if fence_obj is not None:\n        fence_obj.draw(map_img, pixmapper, None)\n    cv.CvtColor(map_img, map_img, cv.CV_BGR2RGB)\n    cv.SaveImage(filename, map_img)", "response": "create path and mission as an image file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mavflightview_mav(mlog, options=None, title=None):\n    '''create a map for a log file'''\n    if not title:\n        title='MAVFlightView'\n    wp = mavwp.MAVWPLoader()\n    if options.mission is not None:\n        wp.load(options.mission)\n    fen = mavwp.MAVFenceLoader()\n    if options.fence is not None:\n        fen.load(options.fence)\n    path = [[]]\n    instances = {}\n    ekf_counter = 0\n    types = ['MISSION_ITEM','CMD']\n    if options.types is not None:\n        types.extend(options.types.split(','))\n    else:\n        types.extend(['GPS','GLOBAL_POSITION_INT'])\n        if options.rawgps or options.dualgps:\n            types.extend(['GPS', 'GPS_RAW_INT'])\n        if options.rawgps2 or options.dualgps:\n            types.extend(['GPS2_RAW','GPS2'])\n        if options.ekf:\n            types.extend(['EKF1', 'GPS'])\n        if options.ahr2:\n            types.extend(['AHR2', 'AHRS2', 'GPS'])\n    print(\"Looking for types %s\" % str(types))\n\n    last_timestamps = {}\n\n    while True:\n        try:\n            m = mlog.recv_match(type=types)\n            if m is None:\n                break\n        except Exception:\n            break\n\n        type = m.get_type()\n        \n        if type == 'MISSION_ITEM':\n            try:\n                while m.seq > wp.count():\n                    print(\"Adding dummy WP %u\" % wp.count())\n                    wp.set(m, wp.count())\n                wp.set(m, m.seq)\n            except Exception:\n                pass\n            continue\n        if type == 'CMD':\n            m = mavutil.mavlink.MAVLink_mission_item_message(0,\n                                                             0,\n                                                             m.CNum,\n                                                             mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT,\n                                                             m.CId,\n                                                             0, 1,\n                                                             m.Prm1, m.Prm2, m.Prm3, m.Prm4,\n                                                             m.Lat, m.Lng, m.Alt)\n            try:\n                while m.seq > wp.count():\n                    print(\"Adding dummy WP %u\" % wp.count())\n                    wp.set(m, wp.count())\n                wp.set(m, m.seq)\n            except Exception:\n                pass\n            continue\n        if not mlog.check_condition(options.condition):\n            continue\n        if options.mode is not None and mlog.flightmode.lower() != options.mode.lower():\n            continue\n        if type in ['GPS','GPS2']:\n            status = getattr(m, 'Status', None)\n            if status is None:\n                status = getattr(m, 'FixType', None)\n                if status is None:\n                    print(\"Can't find status on GPS message\")\n                    print(m)\n                    break\n            if status < 2:\n                continue\n            # flash log\n            lat = m.Lat\n            lng = getattr(m, 'Lng', None)\n            if lng is None:\n                lng = getattr(m, 'Lon', None)\n                if lng is None:\n                    print(\"Can't find longitude on GPS message\")\n                    print(m)\n                    break                    \n        elif type in ['EKF1', 'ANU1']:\n            pos = mavextra.ekf1_pos(m)\n            if pos is None:\n                continue\n            ekf_counter += 1\n            if ekf_counter % options.ekf_sample != 0:\n                continue\n            (lat, lng) = pos            \n        elif type in ['ANU5']:\n            (lat, lng) = (m.Alat*1.0e-7, m.Alng*1.0e-7)\n        elif type in ['AHR2', 'POS', 'CHEK']:\n            (lat, lng) = (m.Lat, m.Lng)\n        elif type == 'AHRS2':\n            (lat, lng) = (m.lat*1.0e-7, m.lng*1.0e-7)\n        else:\n            lat = m.lat * 1.0e-7\n            lng = m.lon * 1.0e-7\n\n        # automatically add new types to instances\n        if type not in instances:\n            instances[type] = len(instances)\n            while len(instances) >= len(path):\n                path.append([])\n        instance = instances[type]\n\n        if abs(lat)>0.01 or abs(lng)>0.01:\n            fmode = getattr(mlog, 'flightmode','')\n            if fmode in colourmap:\n                colour = colourmap[fmode]\n            else:\n                colour = colourmap['UNKNOWN']\n            (r,g,b) = colour\n            (r,g,b) = (r+instance*80,g+instance*50,b+instance*70)\n            if r > 255:\n                r = 205\n            if g > 255:\n                g = 205\n            if g < 0:\n                g = 0\n            if b > 255:\n                b = 205\n            colour = (r,g,b)\n            point = (lat, lng, colour)\n\n            if options.rate == 0 or not type in last_timestamps or m._timestamp - last_timestamps[type] > 1.0/options.rate:\n                last_timestamps[type] = m._timestamp\n                path[instance].append(point)\n    if len(path[0]) == 0:\n        print(\"No points to plot\")\n        return\n    bounds = mp_util.polygon_bounds(path[0])\n    (lat, lon) = (bounds[0]+bounds[2], bounds[1])\n    (lat, lon) = mp_util.gps_newpos(lat, lon, -45, 50)\n    ground_width = mp_util.gps_distance(lat, lon, lat-bounds[2], lon+bounds[3])\n    while (mp_util.gps_distance(lat, lon, bounds[0], bounds[1]) >= ground_width-20 or\n           mp_util.gps_distance(lat, lon, lat, bounds[1]+bounds[3]) >= ground_width-20):\n        ground_width += 10\n\n    path_objs = []\n    for i in range(len(path)):\n        if len(path[i]) != 0:\n            path_objs.append(mp_slipmap.SlipPolygon('FlightPath[%u]-%s' % (i,title), path[i], layer='FlightPath',\n                                                    linewidth=2, colour=(255,0,180)))\n    plist = wp.polygon_list()\n    mission_obj = None\n    if len(plist) > 0:\n        mission_obj = []\n        for i in range(len(plist)):\n            mission_obj.append(mp_slipmap.SlipPolygon('Mission-%s-%u' % (title,i), plist[i], layer='Mission',\n                                                      linewidth=2, colour=(255,255,255)))\n    else:\n        mission_obj = None\n\n    fence = fen.polygon()\n    if len(fence) > 1:\n        fence_obj = mp_slipmap.SlipPolygon('Fence-%s' % title, fen.polygon(), layer='Fence',\n                                           linewidth=2, colour=(0,255,0))\n    else:\n        fence_obj = None\n\n    if options.imagefile:\n        create_imagefile(options, options.imagefile, (lat,lon), ground_width, path_objs, mission_obj, fence_obj)\n    else:\n        global multi_map\n        if options.multi and multi_map is not None:\n            map = multi_map\n        else:\n            map = mp_slipmap.MPSlipMap(title=title,\n                                       service=options.service,\n                                       elevation=True,\n                                       width=600,\n                                       height=600,\n                                       ground_width=ground_width,\n                                       lat=lat, lon=lon,\n                                       debug=options.debug)\n        if options.multi:\n            multi_map = map\n        for path_obj in path_objs:\n            map.add_object(path_obj)\n        if mission_obj is not None:\n            display_waypoints(wp, map)\n        if fence_obj is not None:\n            map.add_object(fence_obj)\n\n        for flag in options.flag:\n            a = flag.split(',')\n            lat = a[0]\n            lon = a[1]\n            icon = 'flag.png'\n            if len(a) > 2:\n                icon = a[2] + '.png'\n            icon = map.icon(icon)\n            map.add_object(mp_slipmap.SlipIcon('icon - %s' % str(flag), (float(lat),float(lon)), icon, layer=3, rotation=0, follow=False))", "response": "create a map for a log file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef LoadImage(filename):\n    '''return an image from the images/ directory'''\n    app_dir = os.path.dirname(os.path.realpath(__file__))\n    path = os.path.join(app_dir, 'images', filename)\n    return Tkinter.PhotoImage(file=path)", "response": "return an image from the images directory"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef status(self):\n        '''show status'''\n        for m in sorted(self.mlog.messages.keys()):\n            print(str(self.mlog.messages[m]))", "response": "show status of all the active user s infrastructure"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_message(self):\n        '''find the next valid message'''\n        while True:\n            self.msg = self.mlog.recv_match(condition=args.condition)\n            if self.msg is not None and self.msg.get_type() != 'BAD_DATA':\n                break\n            if self.mlog.f.tell() > self.filesize - 10:\n                self.paused = True\n                break\n        self.last_timestamp = getattr(self.msg, '_timestamp')", "response": "find the next valid message"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmove to a given position in the file", "response": "def slew(self, value):\n        '''move to a given position in the file'''\n        if float(value) != self.filepos:\n            pos = float(value) * self.filesize\n            self.mlog.f.seek(int(pos))\n            self.find_message()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling as each msg is ready", "response": "def next_message(self):\n        '''called as each msg is ready'''\n\n        msg = self.msg\n        if msg is None:\n            self.paused = True\n\n        if self.paused:\n            self.root.after(100, self.next_message)\n            return\n\n        try:\n            speed = float(self.playback.get())\n        except:\n            speed = 0.0\n        timestamp = getattr(msg, '_timestamp')\n\n        now = time.strftime(\"%H:%M:%S\", time.localtime(timestamp))\n        self.clock.configure(text=now)\n\n        if speed == 0.0:\n            self.root.after(200, self.next_message)\n        else:\n            self.root.after(int(1000*(timestamp - self.last_timestamp) / speed), self.next_message)\n        self.last_timestamp = timestamp\n\n        while True:\n            self.msg = self.mlog.recv_match(condition=args.condition)\n            if self.msg is None and self.mlog.f.tell() > self.filesize - 10:\n                self.paused = True\n                return\n            if self.msg is not None and self.msg.get_type() != \"BAD_DATA\":\n                break\n\n        pos = float(self.mlog.f.tell()) / self.filesize\n        self.slider.set(pos)\n        self.filepos = self.slider.get()\n\n        if msg.get_type() != \"BAD_DATA\":\n            for m in self.mout:\n                m.write(msg.get_msgbuf())\n\n        if msg.get_type() == \"GPS_RAW\":\n            self.fdm.set('latitude', msg.lat, units='degrees')\n            self.fdm.set('longitude', msg.lon, units='degrees')\n            if args.gpsalt:\n                self.fdm.set('altitude', msg.alt, units='meters')\n\n        if msg.get_type() == \"GPS_RAW_INT\":\n            self.fdm.set('latitude', msg.lat/1.0e7, units='degrees')\n            self.fdm.set('longitude', msg.lon/1.0e7, units='degrees')\n            if args.gpsalt:\n                self.fdm.set('altitude', msg.alt/1.0e3, units='meters')\n\n        if msg.get_type() == \"VFR_HUD\":\n            if not args.gpsalt:\n                self.fdm.set('altitude', msg.alt, units='meters')\n            self.fdm.set('num_engines', 1)\n            self.fdm.set('vcas', msg.airspeed, units='mps')\n\n        if msg.get_type() == \"ATTITUDE\":\n            self.fdm.set('phi', msg.roll, units='radians')\n            self.fdm.set('theta', msg.pitch, units='radians')\n            self.fdm.set('psi', msg.yaw, units='radians')\n            self.fdm.set('phidot', msg.rollspeed, units='rps')\n            self.fdm.set('thetadot', msg.pitchspeed, units='rps')\n            self.fdm.set('psidot', msg.yawspeed, units='rps')\n\n        if msg.get_type() == \"RC_CHANNELS_SCALED\":\n            self.fdm.set(\"right_aileron\", msg.chan1_scaled*0.0001)\n            self.fdm.set(\"left_aileron\", -msg.chan1_scaled*0.0001)\n            self.fdm.set(\"rudder\",        msg.chan4_scaled*0.0001)\n            self.fdm.set(\"elevator\",      msg.chan2_scaled*0.0001)\n            self.fdm.set('rpm',           msg.chan3_scaled*0.01)\n\n        if msg.get_type() == 'STATUSTEXT':\n            print(\"APM: %s\" % msg.text)\n\n        if msg.get_type() == 'SYS_STATUS':\n            self.flightmode.configure(text=self.mlog.flightmode)\n\n        if msg.get_type() == \"BAD_DATA\":\n            if mavutil.all_printable(msg.data):\n                sys.stdout.write(msg.data)\n                sys.stdout.flush()\n\n        if self.fdm.get('latitude') != 0:\n            for f in self.fgout:\n                f.write(self.fdm.pack())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef draw_plot(self):\n        import numpy, pylab\n        state = self.state\n\n        if len(self.data[0]) == 0:\n            print(\"no data to plot\")\n            return\n        vhigh = max(self.data[0])\n        vlow  = min(self.data[0])\n\n        for i in range(1,len(self.plot_data)):\n            vhigh = max(vhigh, max(self.data[i]))\n            vlow  = min(vlow,  min(self.data[i]))\n        ymin = vlow  - 0.05*(vhigh-vlow)\n        ymax = vhigh + 0.05*(vhigh-vlow)\n\n        if ymin == ymax:\n            ymax = ymin + 0.1\n            ymin = ymin - 0.1\n        self.axes.set_ybound(lower=ymin, upper=ymax)\n        self.axes.grid(True, color='gray')\n        pylab.setp(self.axes.get_xticklabels(), visible=True)\n        pylab.setp(self.axes.get_legend().get_texts(), fontsize='small')\n\n        for i in range(len(self.plot_data)):\n            ydata = numpy.array(self.data[i])\n            xdata = self.xdata\n            if len(ydata) < len(self.xdata):\n                xdata = xdata[-len(ydata):]\n            self.plot_data[i].set_xdata(xdata)\n            self.plot_data[i].set_ydata(ydata)\n\n        self.canvas.draw()", "response": "Redraws the plot of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_dialect(dialect):\n    '''set the MAVLink dialect to work with.\n    For example, set_dialect(\"ardupilotmega\")\n    '''\n    global mavlink, current_dialect\n    from .generator import mavparse\n    if 'MAVLINK20' in os.environ:\n        wire_protocol = mavparse.PROTOCOL_2_0\n        modname = \"pymavlink.dialects.v20.\" + dialect\n    elif mavlink is None or mavlink.WIRE_PROTOCOL_VERSION == \"1.0\" or not 'MAVLINK09' in os.environ:\n        wire_protocol = mavparse.PROTOCOL_1_0\n        modname = \"pymavlink.dialects.v10.\" + dialect\n    else:\n        wire_protocol = mavparse.PROTOCOL_0_9\n        modname = \"pymavlink.dialects.v09.\" + dialect\n\n    try:\n        mod = __import__(modname)\n    except Exception:\n        # auto-generate the dialect module\n        from .generator.mavgen import mavgen_python_dialect\n        mavgen_python_dialect(dialect, wire_protocol)\n        mod = __import__(modname)\n    components = modname.split('.')\n    for comp in components[1:]:\n        mod = getattr(mod, comp)\n    current_dialect = dialect\n    mavlink = mod", "response": "set the MAVLink dialect to work with.\n    For example set_dialect ( MAVLink. MAVLink_DIALECT_MAVLINK_20."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the clone on exec flag on a file descriptor. Ignore exceptions", "response": "def set_close_on_exec(fd):\n    '''set the clone on exec flag on a file descriptor. Ignore exceptions'''\n    try:\n        import fcntl\n        flags = fcntl.fcntl(fd, fcntl.F_GETFD)\n        flags |= fcntl.FD_CLOEXEC\n        fcntl.fcntl(fd, fcntl.F_SETFD, flags)\n    except Exception:\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nopen a serial UDP TCP or file mavlink connection", "response": "def mavlink_connection(device, baud=115200, source_system=255,\n                       planner_format=None, write=False, append=False,\n                       robust_parsing=True, notimestamps=False, input=True,\n                       dialect=None, autoreconnect=False, zero_time_base=False,\n                       retries=3, use_native=default_native):\n    '''open a serial, UDP, TCP or file mavlink connection'''\n    global mavfile_global\n\n    if dialect is not None:\n        set_dialect(dialect)\n    if device.startswith('tcp:'):\n        return mavtcp(device[4:], source_system=source_system, retries=retries, use_native=use_native)\n    if device.startswith('tcpin:'):\n        return mavtcpin(device[6:], source_system=source_system, retries=retries, use_native=use_native)\n    if device.startswith('udpin:'):\n        return mavudp(device[6:], input=True, source_system=source_system, use_native=use_native)\n    if device.startswith('udpout:'):\n        return mavudp(device[7:], input=False, source_system=source_system, use_native=use_native)\n    if device.startswith('udpbcast:'):\n        return mavudp(device[9:], input=False, source_system=source_system, use_native=use_native, broadcast=True)\n    # For legacy purposes we accept the following syntax and let the caller to specify direction\n    if device.startswith('udp:'):\n        return mavudp(device[4:], input=input, source_system=source_system, use_native=use_native)\n\n    if device.lower().endswith('.bin') or device.lower().endswith('.px4log'):\n        # support dataflash logs\n        from pymavlink import DFReader\n        m = DFReader.DFReader_binary(device, zero_time_base=zero_time_base)\n        mavfile_global = m\n        return m\n\n    if device.endswith('.log'):\n        # support dataflash text logs\n        from pymavlink import DFReader\n        if DFReader.DFReader_is_text_log(device):\n            m = DFReader.DFReader_text(device, zero_time_base=zero_time_base)\n            mavfile_global = m\n            return m    \n\n    # list of suffixes to prevent setting DOS paths as UDP sockets\n    logsuffixes = ['mavlink', 'log', 'raw', 'tlog' ]\n    suffix = device.split('.')[-1].lower()\n    if device.find(':') != -1 and not suffix in logsuffixes:\n        return mavudp(device, source_system=source_system, input=input, use_native=use_native)\n    if os.path.isfile(device):\n        if device.endswith(\".elf\") or device.find(\"/bin/\") != -1:\n            print(\"executing '%s'\" % device)\n            return mavchildexec(device, source_system=source_system, use_native=use_native)\n        else:\n            return mavlogfile(device, planner_format=planner_format, write=write,\n                              append=append, robust_parsing=robust_parsing, notimestamps=notimestamps,\n                              source_system=source_system, use_native=use_native)\n    return mavserial(device, baud=baud, source_system=source_system, autoreconnect=autoreconnect, use_native=use_native)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_printable(c):\n    '''see if a character is printable'''\n    global have_ascii\n    if have_ascii:\n        return ascii.isprint(c)\n    if isinstance(c, int):\n        ic = c\n    else:\n        ic = ord(c)\n    return ic >= 32 and ic <= 126", "response": "see if a character is printable"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef auto_detect_serial_win32(preferred_list=['*']):\n    '''try to auto-detect serial ports on win32'''\n    try:\n        from serial.tools.list_ports_windows import comports\n        list = sorted(comports())\n    except:\n        return []\n    ret = []\n    others = []\n    for port, description, hwid in list:\n        matches = False\n        p = SerialPort(port, description=description, hwid=hwid)\n        for preferred in preferred_list:\n            if fnmatch.fnmatch(description, preferred) or fnmatch.fnmatch(hwid, preferred):\n                matches = True\n        if matches:\n            ret.append(p)\n        else:\n            others.append(p)\n    if len(ret) > 0:\n        return ret\n    # now the rest\n    ret.extend(others)\n    return ret", "response": "try to auto - detect serial ports on win32"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntry to auto - detect serial ports on unix", "response": "def auto_detect_serial_unix(preferred_list=['*']):\n    '''try to auto-detect serial ports on unix'''\n    import glob\n    glist = glob.glob('/dev/ttyS*') + glob.glob('/dev/ttyUSB*') + glob.glob('/dev/ttyACM*') + glob.glob('/dev/serial/by-id/*')\n    ret = []\n    others = []\n    # try preferred ones first\n    for d in glist:\n        matches = False\n        for preferred in preferred_list:\n            if fnmatch.fnmatch(d, preferred):\n                matches = True\n        if matches:\n            ret.append(SerialPort(d))\n        else:\n            others.append(SerialPort(d))\n    if len(ret) > 0:\n        return ret\n    ret.extend(others)\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef auto_detect_serial(preferred_list=['*']):\n    '''try to auto-detect serial port'''\n    # see if \n    if os.name == 'nt':\n        return auto_detect_serial_win32(preferred_list=preferred_list)\n    return auto_detect_serial_unix(preferred_list=preferred_list)", "response": "try to auto - detect serial port"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mode_string_v09(msg):\n    '''mode string for 0.9 protocol'''\n    mode = msg.mode\n    nav_mode = msg.nav_mode\n\n    MAV_MODE_UNINIT = 0\n    MAV_MODE_MANUAL = 2\n    MAV_MODE_GUIDED = 3\n    MAV_MODE_AUTO = 4\n    MAV_MODE_TEST1 = 5\n    MAV_MODE_TEST2 = 6\n    MAV_MODE_TEST3 = 7\n\n    MAV_NAV_GROUNDED = 0\n    MAV_NAV_LIFTOFF = 1\n    MAV_NAV_HOLD = 2\n    MAV_NAV_WAYPOINT = 3\n    MAV_NAV_VECTOR = 4\n    MAV_NAV_RETURNING = 5\n    MAV_NAV_LANDING = 6\n    MAV_NAV_LOST = 7\n    MAV_NAV_LOITER = 8\n    \n    cmode = (mode, nav_mode)\n    mapping = {\n        (MAV_MODE_UNINIT, MAV_NAV_GROUNDED)  : \"INITIALISING\",\n        (MAV_MODE_MANUAL, MAV_NAV_VECTOR)    : \"MANUAL\",\n        (MAV_MODE_TEST3,  MAV_NAV_VECTOR)    : \"CIRCLE\",\n        (MAV_MODE_GUIDED, MAV_NAV_VECTOR)    : \"GUIDED\",\n        (MAV_MODE_TEST1,  MAV_NAV_VECTOR)    : \"STABILIZE\",\n        (MAV_MODE_TEST2,  MAV_NAV_LIFTOFF)   : \"FBWA\",\n        (MAV_MODE_AUTO,   MAV_NAV_WAYPOINT)  : \"AUTO\",\n        (MAV_MODE_AUTO,   MAV_NAV_RETURNING) : \"RTL\",\n        (MAV_MODE_AUTO,   MAV_NAV_LOITER)    : \"LOITER\",\n        (MAV_MODE_AUTO,   MAV_NAV_LIFTOFF)   : \"TAKEOFF\",\n        (MAV_MODE_AUTO,   MAV_NAV_LANDING)   : \"LANDING\",\n        (MAV_MODE_AUTO,   MAV_NAV_HOLD)      : \"LOITER\",\n        (MAV_MODE_GUIDED, MAV_NAV_VECTOR)    : \"GUIDED\",\n        (MAV_MODE_GUIDED, MAV_NAV_WAYPOINT)  : \"GUIDED\",\n        (100,             MAV_NAV_VECTOR)    : \"STABILIZE\",\n        (101,             MAV_NAV_VECTOR)    : \"ACRO\",\n        (102,             MAV_NAV_VECTOR)    : \"ALT_HOLD\",\n        (107,             MAV_NAV_VECTOR)    : \"CIRCLE\",\n        (109,             MAV_NAV_VECTOR)    : \"LAND\",\n        }\n    if cmode in mapping:\n        return mapping[cmode]\n    return \"Mode(%s,%s)\" % cmode", "response": "mode string for 0. 9 protocol"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mode_mapping_byname(mav_type):\n    '''return dictionary mapping mode names to numbers, or None if unknown'''\n    map = None\n    if mav_type in [mavlink.MAV_TYPE_QUADROTOR,\n                    mavlink.MAV_TYPE_HELICOPTER,\n                    mavlink.MAV_TYPE_HEXAROTOR,\n                    mavlink.MAV_TYPE_OCTOROTOR,\n                    mavlink.MAV_TYPE_COAXIAL,\n                    mavlink.MAV_TYPE_TRICOPTER]:\n        map = mode_mapping_acm\n    if mav_type == mavlink.MAV_TYPE_FIXED_WING:\n        map = mode_mapping_apm\n    if mav_type == mavlink.MAV_TYPE_GROUND_ROVER:\n        map = mode_mapping_rover\n    if mav_type == mavlink.MAV_TYPE_ANTENNA_TRACKER:\n        map = mode_mapping_tracker\n    if map is None:\n        return None\n    inv_map = dict((a, b) for (b, a) in map.items())\n    return inv_map", "response": "return dictionary mapping mode names to numbers or None if unknown"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns dictionary mapping mode numbers to name or None if unknown", "response": "def mode_mapping_bynumber(mav_type):\n    '''return dictionary mapping mode numbers to name, or None if unknown'''\n    map = None\n    if mav_type in [mavlink.MAV_TYPE_QUADROTOR,\n                    mavlink.MAV_TYPE_HELICOPTER,\n                    mavlink.MAV_TYPE_HEXAROTOR,\n                    mavlink.MAV_TYPE_OCTOROTOR,\n                    mavlink.MAV_TYPE_COAXIAL,\n                    mavlink.MAV_TYPE_TRICOPTER]:\n        map = mode_mapping_acm\n    if mav_type == mavlink.MAV_TYPE_FIXED_WING:\n        map = mode_mapping_apm\n    if mav_type == mavlink.MAV_TYPE_GROUND_ROVER:\n        map = mode_mapping_rover\n    if mav_type == mavlink.MAV_TYPE_ANTENNA_TRACKER:\n        map = mode_mapping_tracker\n    if map is None:\n        return None\n    return map"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mode_string_v10(msg):\n    '''mode string for 1.0 protocol, from heartbeat'''\n    if msg.autopilot == mavlink.MAV_AUTOPILOT_PX4:\n        return interpret_px4_mode(msg.base_mode, msg.custom_mode)\n    if not msg.base_mode & mavlink.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED:\n        return \"Mode(0x%08x)\" % msg.base_mode\n    if msg.type in [ mavlink.MAV_TYPE_QUADROTOR, mavlink.MAV_TYPE_HEXAROTOR,\n                     mavlink.MAV_TYPE_OCTOROTOR, mavlink.MAV_TYPE_TRICOPTER,\n                     mavlink.MAV_TYPE_COAXIAL,\n                     mavlink.MAV_TYPE_HELICOPTER ]:\n        if msg.custom_mode in mode_mapping_acm:\n            return mode_mapping_acm[msg.custom_mode]\n    if msg.type == mavlink.MAV_TYPE_FIXED_WING:\n        if msg.custom_mode in mode_mapping_apm:\n            return mode_mapping_apm[msg.custom_mode]\n    if msg.type == mavlink.MAV_TYPE_GROUND_ROVER:\n        if msg.custom_mode in mode_mapping_rover:\n            return mode_mapping_rover[msg.custom_mode]\n    if msg.type == mavlink.MAV_TYPE_ANTENNA_TRACKER:\n        if msg.custom_mode in mode_mapping_tracker:\n            return mode_mapping_tracker[msg.custom_mode]\n    return \"Mode(%u)\" % msg.custom_mode", "response": "mode string for 1. 0 protocol from heartbeat"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef auto_mavlink_version(self, buf):\n        '''auto-switch mavlink protocol version'''\n        global mavlink\n        if len(buf) == 0:\n            return\n        try:\n            magic = ord(buf[0])\n        except:\n            magic = buf[0]\n        if not magic in [ 85, 254, 253 ]:\n            return\n        self.first_byte = False\n        if self.WIRE_PROTOCOL_VERSION == \"0.9\" and magic == 254:\n            self.WIRE_PROTOCOL_VERSION = \"1.0\"\n            set_dialect(current_dialect)\n        elif self.WIRE_PROTOCOL_VERSION == \"1.0\" and magic == 85:\n            self.WIRE_PROTOCOL_VERSION = \"0.9\"\n            os.environ['MAVLINK09'] = '1'\n            set_dialect(current_dialect)\n        elif self.WIRE_PROTOCOL_VERSION != \"2.0\" and magic == 253:\n            self.WIRE_PROTOCOL_VERSION = \"2.0\"\n            os.environ['MAVLINK20'] = '1'\n            set_dialect(current_dialect)\n        else:\n            return\n        # switch protocol \n        (callback, callback_args, callback_kwargs) = (self.mav.callback,\n                                                      self.mav.callback_args,\n                                                      self.mav.callback_kwargs)\n        self.mav = mavlink.MAVLink(self, srcSystem=self.source_system)\n        self.mav.robust_parsing = self.robust_parsing\n        self.WIRE_PROTOCOL_VERSION = mavlink.WIRE_PROTOCOL_VERSION\n        (self.mav.callback, self.mav.callback_args, self.mav.callback_kwargs) = (callback,\n                                                                                 callback_args,\n                                                                                 callback_kwargs)", "response": "auto - switch mavlink protocol version"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef select(self, timeout):\n        '''wait for up to timeout seconds for more data'''\n        if self.fd is None:\n            time.sleep(min(timeout,0.5))\n            return True\n        try:\n            (rin, win, xin) = select.select([self.fd], [], [], timeout)\n        except select.error:\n            return False\n        return len(rin) == 1", "response": "wait for up to timeout seconds for more data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef post_message(self, msg):\n        '''default post message call'''\n        if '_posted' in msg.__dict__:\n            return\n        msg._posted = True\n        msg._timestamp = time.time()\n        type = msg.get_type()\n        if type != 'HEARTBEAT' or (msg.type != mavlink.MAV_TYPE_GCS and msg.type != mavlink.MAV_TYPE_GIMBAL):\n            self.messages[type] = msg\n\n        if 'usec' in msg.__dict__:\n            self.uptime = msg.usec * 1.0e-6\n        if 'time_boot_ms' in msg.__dict__:\n            self.uptime = msg.time_boot_ms * 1.0e-3\n\n        if self._timestamp is not None:\n            if self.notimestamps:\n                msg._timestamp = self.uptime\n            else:\n                msg._timestamp = self._timestamp\n\n        src_system = msg.get_srcSystem()\n        src_component = msg.get_srcComponent()\n        src_tuple = (src_system, src_component)\n        radio_tuple = (ord('3'), ord('D'))\n        if not (src_tuple == radio_tuple or msg.get_type() == 'BAD_DATA'):\n            if not src_tuple in self.last_seq:\n                last_seq = -1\n            else:\n                last_seq = self.last_seq[src_tuple]\n            seq = (last_seq+1) % 256\n            seq2 = msg.get_seq()\n            if seq != seq2 and last_seq != -1:\n                diff = (seq2 - seq) % 256\n                self.mav_loss += diff\n                #print(\"lost %u seq=%u seq2=%u last_seq=%u src_system=%u %s\" % (diff, seq, seq2, last_seq, src_system, msg.get_type()))\n            self.last_seq[src_tuple] = seq2\n            self.mav_count += 1\n        \n        self.timestamp = msg._timestamp\n        if type == 'HEARTBEAT' and msg.get_srcComponent() != mavlink.MAV_COMP_ID_GIMBAL:\n            self.target_system = msg.get_srcSystem()\n            self.target_component = msg.get_srcComponent()\n            if float(mavlink.WIRE_PROTOCOL_VERSION) >= 1 and msg.type != mavlink.MAV_TYPE_GCS:\n                self.flightmode = mode_string_v10(msg)\n                self.mav_type = msg.type\n                self.base_mode = msg.base_mode\n        elif type == 'PARAM_VALUE':\n            s = str(msg.param_id)\n            self.params[str(msg.param_id)] = msg.param_value\n            if msg.param_index+1 == msg.param_count:\n                self.param_fetch_in_progress = False\n                self.param_fetch_complete = True\n        elif type == 'SYS_STATUS' and mavlink.WIRE_PROTOCOL_VERSION == '0.9':\n            self.flightmode = mode_string_v09(msg)\n        elif type == 'GPS_RAW':\n            if self.messages['HOME'].fix_type < 2:\n                self.messages['HOME'] = msg\n        elif type == 'GPS_RAW_INT':\n            if self.messages['HOME'].fix_type < 3:\n                self.messages['HOME'] = msg\n        for hook in self.message_hooks:\n            hook(self, msg)\n\n        if (msg.get_signed() and\n            self.mav.signing.link_id == 0 and\n            msg.get_link_id() != 0 and\n            self.target_system == msg.get_srcSystem() and\n            self.target_component == msg.get_srcComponent()):\n            # change to link_id from incoming packet\n            self.mav.signing.link_id = msg.get_link_id()", "response": "post a message to the internal state"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef packet_loss(self):\n        '''packet loss as a percentage'''\n        if self.mav_count == 0:\n            return 0\n        return (100.0*self.mav_loss)/(self.mav_count+self.mav_loss)", "response": "packet loss as a percentage"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef recv_msg(self):\n        '''message receive routine'''\n        self.pre_message()\n        while True:\n            n = self.mav.bytes_needed()\n            s = self.recv(n)\n            numnew = len(s)\n\n            if numnew != 0:\n                if self.logfile_raw:\n                    self.logfile_raw.write(str(s))\n                if self.first_byte:\n                    self.auto_mavlink_version(s)\n\n            # We always call parse_char even if the new string is empty, because the existing message buf might already have some valid packet\n            # we can extract\n            msg = self.mav.parse_char(s)\n            if msg:\n                if self.logfile and  msg.get_type() != 'BAD_DATA' :\n                    usec = int(time.time() * 1.0e6) & ~3\n                    self.logfile.write(str(struct.pack('>Q', usec) + msg.get_msgbuf()))\n                self.post_message(msg)\n                return msg\n            else:\n                # if we failed to parse any messages _and_ no new bytes arrived, return immediately so the client has the option to\n                # timeout\n                if numnew == 0:\n                    return None", "response": "receive a message from the system"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart logging to the given logfile with timestamps", "response": "def setup_logfile(self, logfile, mode='w'):\n        '''start logging to the given logfile, with timestamps'''\n        self.logfile = open(logfile, mode=mode)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_logfile_raw(self, logfile, mode='w'):\n        '''start logging raw bytes to the given logfile, without timestamps'''\n        self.logfile_raw = open(logfile, mode=mode)", "response": "start logging raw bytes to the given logfile without timestamps"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef param_fetch_all(self):\n        '''initiate fetch of all parameters'''\n        if time.time() - getattr(self, 'param_fetch_start', 0) < 2.0:\n            # don't fetch too often\n            return\n        self.param_fetch_start = time.time()\n        self.param_fetch_in_progress = True\n        self.mav.param_request_list_send(self.target_system, self.target_component)", "response": "initiate fetch of all parameters"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitiating fetch of one parameter", "response": "def param_fetch_one(self, name):\n        '''initiate fetch of one parameter'''\n        try:\n            idx = int(name)\n            self.mav.param_request_read_send(self.target_system, self.target_component, \"\", idx)\n        except Exception:\n            self.mav.param_request_read_send(self.target_system, self.target_component, name, -1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef time_since(self, mtype):\n        '''return the time since the last message of type mtype was received'''\n        if not mtype in self.messages:\n            return time.time() - self.start_time\n        return time.time() - self.messages[mtype]._timestamp", "response": "return the time since the last message of type mtype was received"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwrapping for parameter set", "response": "def param_set_send(self, parm_name, parm_value, parm_type=None):\n        '''wrapper for parameter set'''\n        if self.mavlink10():\n            if parm_type == None:\n                parm_type = mavlink.MAVLINK_TYPE_FLOAT\n            self.mav.param_set_send(self.target_system, self.target_component,\n                                    parm_name, parm_value, parm_type)\n        else:\n            self.mav.param_set_send(self.target_system, self.target_component,\n                                    parm_name, parm_value)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the mode of the resource table", "response": "def set_mode_flag(self, flag, enable):\n        '''\n        Enables/ disables MAV_MODE_FLAG\n        @param flag The mode flag, \n          see MAV_MODE_FLAG enum\n        @param enable Enable the flag, (True/False)\n        '''\n        if self.mavlink10():\n            mode = self.base_mode\n            if (enable == True):\n                mode = mode | flag\n            elif (enable == False):\n                mode = mode & ~flag\n            self.mav.command_long_send(self.target_system, self.target_component,\n                                           mavlink.MAV_CMD_DO_SET_MODE, 0,\n                                           mode,\n                                           0, 0, 0, 0, 0, 0)\n        else:\n            print(\"Set mode flag not supported\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn dictionary mapping mode names to numbers or None if unknown", "response": "def mode_mapping(self):\n        '''return dictionary mapping mode names to numbers, or None if unknown'''\n        mav_type = self.field('HEARTBEAT', 'type', self.mav_type)\n        mav_autopilot = self.field('HEARTBEAT', 'autopilot', None)\n        if mav_autopilot == mavlink.MAV_AUTOPILOT_PX4:\n            return px4_map\n        if mav_type is None:\n            return None\n        map = None\n        if mav_type in [mavlink.MAV_TYPE_QUADROTOR,\n                        mavlink.MAV_TYPE_HELICOPTER,\n                        mavlink.MAV_TYPE_HEXAROTOR,\n                        mavlink.MAV_TYPE_OCTOROTOR,\n                        mavlink.MAV_TYPE_COAXIAL,\n                        mavlink.MAV_TYPE_TRICOPTER]:\n            map = mode_mapping_acm\n        if mav_type == mavlink.MAV_TYPE_FIXED_WING:\n            map = mode_mapping_apm\n        if mav_type == mavlink.MAV_TYPE_GROUND_ROVER:\n            map = mode_mapping_rover\n        if mav_type == mavlink.MAV_TYPE_ANTENNA_TRACKER:\n            map = mode_mapping_tracker\n        if map is None:\n            return None\n        inv_map = dict((a, b) for (b, a) in list(map.items()))\n        return inv_map"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset mode in PX4 mode", "response": "def set_mode_px4(self, mode, custom_mode, custom_sub_mode):\n        '''enter arbitrary mode'''\n        if isinstance(mode, str):\n            mode_map = self.mode_mapping()\n            if mode_map is None or mode not in mode_map:\n                print(\"Unknown mode '%s'\" % mode)\n                return\n            # PX4 uses two fields to define modes\n            mode, custom_mode, custom_sub_mode = px4_map[mode]\n        self.mav.command_long_send(self.target_system, self.target_component,\n                                   mavlink.MAV_CMD_DO_SET_MODE, 0, mode, custom_mode, custom_sub_mode, 0, 0, 0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting arbitrary flight mode", "response": "def set_mode(self, mode, custom_mode = 0, custom_sub_mode = 0):\n        '''set arbitrary flight mode'''\n        mav_autopilot = self.field('HEARTBEAT', 'autopilot', None)\n        if mav_autopilot == mavlink.MAV_AUTOPILOT_PX4:\n            self.set_mode_px4(mode, custom_mode, custom_sub_mode)\n        else:\n            self.set_mode_apm(mode)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_servo(self, channel, pwm):\n        '''set a servo value'''\n        self.mav.command_long_send(self.target_system, self.target_component,\n                                   mavlink.MAV_CMD_DO_SET_SERVO, 0,\n                                   channel, pwm,\n                                   0, 0, 0, 0, 0)", "response": "set a servo value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_relay(self, relay_pin=0, state=True):\n        '''Set relay_pin to value of state'''\n        if self.mavlink10():\n            self.mav.command_long_send(\n                self.target_system,  # target_system\n                self.target_component, # target_component\n                mavlink.MAV_CMD_DO_SET_RELAY, # command\n                0, # Confirmation\n                relay_pin, # Relay Number\n                int(state), # state (1 to indicate arm)\n                0, # param3 (all other params meaningless)\n                0, # param4\n                0, # param5\n                0, # param6\n                0) # param7\n        else:\n            print(\"Setting relays not supported.\")", "response": "Set relay pin to value of state"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calibrate_level(self):\n        '''calibrate accels (1D version)'''\n        self.mav.command_long_send(self.target_system, self.target_component,\n                                   mavlink.MAV_CMD_PREFLIGHT_CALIBRATION, 0,\n                                   1, 1, 0, 0, 0, 0, 0)", "response": "calibrate accels ( 1D version"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\narm motors ( arducopter only", "response": "def arducopter_arm(self):\n        '''arm motors (arducopter only)'''\n        if self.mavlink10():\n            self.mav.command_long_send(\n                self.target_system,  # target_system\n                self.target_component,\n                mavlink.MAV_CMD_COMPONENT_ARM_DISARM, # command\n                0, # confirmation\n                1, # param1 (1 to indicate arm)\n                0, # param2 (all other params meaningless)\n                0, # param3\n                0, # param4\n                0, # param5\n                0, # param6\n                0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns true if motors armed", "response": "def motors_armed(self):\n        '''return true if motors armed'''\n        if not 'HEARTBEAT' in self.messages:\n            return False\n        m = self.messages['HEARTBEAT']\n        return (m.base_mode & mavlink.MAV_MODE_FLAG_SAFETY_ARMED) != 0"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef field(self, type, field, default=None):\n        '''convenient function for returning an arbitrary MAVLink\n           field with a default'''\n        if not type in self.messages:\n            return default\n        return getattr(self.messages[type], field, default)", "response": "convenient function for returning an arbitrary MAVLink\n           field with a default"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nenabling or disable RTS / CTS", "response": "def set_rtscts(self, enable):\n        '''enable/disable RTS/CTS if applicable'''\n        try:\n            self.port.setRtsCts(enable)\n        except Exception:\n            self.port.rtscts = enable\n        self.rtscts = enable"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_baudrate(self, baudrate):\n        '''set baudrate'''\n        try:\n            self.port.setBaudrate(baudrate)\n        except Exception:\n            # for pySerial 3.0, which doesn't have setBaudrate()\n            self.port.baudrate = baudrate", "response": "set baudrate of the serial port"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nscan forward looking in a tlog for a timestamp in a reasonable range'''", "response": "def scan_timestamp(self, tbuf):\n        '''scan forward looking in a tlog for a timestamp in a reasonable range'''\n        while True:\n            (tusec,) = struct.unpack('>Q', tbuf)\n            t = tusec * 1.0e-6\n            if abs(t - self._last_timestamp) <= 3*24*60*60:\n                break\n            c = self.f.read(1)\n            if len(c) != 1:\n                break\n            tbuf = tbuf[1:] + c\n        return t"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pre_message(self):\n        '''read timestamp if needed'''\n        # read the timestamp\n        if self.filesize != 0:\n            self.percent = (100.0 * self.f.tell()) / self.filesize\n        if self.notimestamps:\n            return\n        if self.planner_format:\n            tbuf = self.f.read(21)\n            if len(tbuf) != 21 or tbuf[0] != '-' or tbuf[20] != ':':\n                raise RuntimeError('bad planner timestamp %s' % tbuf)\n            hnsec = self._two64 + float(tbuf[0:20])\n            t = hnsec * 1.0e-7         # convert to seconds\n            t -= 719163 * 24 * 60 * 60 # convert to 1970 base\n            self._link = 0\n        else:\n            tbuf = self.f.read(8)\n            if len(tbuf) != 8:\n                return\n            (tusec,) = struct.unpack('>Q', tbuf)\n            t = tusec * 1.0e-6\n            if (self._last_timestamp is not None and\n                self._last_message.get_type() == \"BAD_DATA\" and\n                abs(t - self._last_timestamp) > 3*24*60*60):\n                t = self.scan_timestamp(tbuf)\n            self._link = tusec & 0x3\n        self._timestamp = t", "response": "read the timestamp if needed"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds timestamp to message", "response": "def post_message(self, msg):\n        '''add timestamp to message'''\n        # read the timestamp\n        super(mavlogfile, self).post_message(msg)\n        if self.planner_format:\n            self.f.read(1) # trailing newline\n        self.timestamp = msg._timestamp\n        self._last_message = msg\n        if msg.get_type() != \"BAD_DATA\":\n            self._last_timestamp = msg._timestamp\n        msg._link = self._link"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if we should trigger now", "response": "def trigger(self):\n        '''return True if we should trigger now'''\n        tnow = time.time()\n\n        if tnow < self.last_time:\n            print(\"Warning, time moved backwards. Restarting timer.\")\n            self.last_time = tnow\n\n        if self.last_time + (1.0/self.frequency) <= tnow:\n            self.last_time = tnow\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd in some more bytes", "response": "def accumulate(self, buf):\n        '''add in some more bytes'''\n        bytes = array.array('B')\n        if isinstance(buf, array.array):\n            bytes.extend(buf)\n        else:\n            bytes.fromstring(buf)\n        accum = self.crc\n        for b in bytes:\n            tmp = b ^ (accum & 0xff)\n            tmp = (tmp ^ (tmp<<4)) & 0xFF\n            accum = (accum>>8) ^ (tmp<<8) ^ (tmp<<3) ^ (tmp>>4)\n            accum = accum & 0xFFFF\n        self.crc = accum"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write(self, b):\n                '''write some bytes'''\n                from . import mavutil\n                self.debug(\"sending '%s' (0x%02x) of len %u\\n\" % (b, ord(b[0]), len(b)), 2)\n                while len(b) > 0:\n                        n = len(b)\n                        if n > 70:\n                                n = 70\n                        buf = [ord(x) for x in b[:n]]\n                        buf.extend([0]*(70-len(buf)))\n                        self.mav.mav.serial_control_send(self.port,\n                                                         mavutil.mavlink.SERIAL_CONTROL_FLAG_EXCLUSIVE |\n                                                         mavutil.mavlink.SERIAL_CONTROL_FLAG_RESPOND,\n                                                         0,\n                                                         0,\n                                                         n,\n                                                         buf)\n                        b = b[n:]", "response": "write some bytes to the serial port"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _recv(self):\n                '''read some bytes into self.buf'''\n                from . import mavutil\n                start_time = time.time()\n                while time.time() < start_time + self.timeout:\n                        m = self.mav.recv_match(condition='SERIAL_CONTROL.count!=0',\n                                                type='SERIAL_CONTROL', blocking=False, timeout=0)\n                        if m is not None and m.count != 0:\n                                break\n                        self.mav.mav.serial_control_send(self.port,\n                                                         mavutil.mavlink.SERIAL_CONTROL_FLAG_EXCLUSIVE |\n                                                         mavutil.mavlink.SERIAL_CONTROL_FLAG_RESPOND,\n                                                         0,\n                                                         0,\n                                                         0, [0]*70)\n                        m = self.mav.recv_match(condition='SERIAL_CONTROL.count!=0',\n                                                type='SERIAL_CONTROL', blocking=True, timeout=0.01)\n                        if m is not None and m.count != 0:\n                                break\n                if m is not None:\n                        if self._debug > 2:\n                                print(m)\n                        data = m.data[:m.count]\n                        self.buf += ''.join(str(chr(x)) for x in data)", "response": "read some bytes into self. buf"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading some bytes from the socket", "response": "def read(self, n):\n                '''read some bytes'''\n                if len(self.buf) == 0:\n                        self._recv()\n                if len(self.buf) > 0:\n                        if n > len(self.buf):\n                                n = len(self.buf)\n                        ret = self.buf[:n]\n                        self.buf = self.buf[n:]\n                        if self._debug >= 2:\n                            for b in ret:\n                                self.debug(\"read 0x%x\" % ord(b), 2)\n                        return ret\n                return ''"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flushInput(self):\n                '''flush any pending input'''\n                self.buf = ''\n                saved_timeout = self.timeout\n                self.timeout = 0.5\n                self._recv()\n                self.timeout = saved_timeout\n                self.buf = ''\n                self.debug(\"flushInput\")", "response": "flush any pending input"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        if m.get_type() == 'SERIAL_CONTROL':\n            data = m.data[:m.count]\n            if m.count > 0:\n                s = ''.join(str(chr(x)) for x in data)\n                if self.mpstate.system == 'Windows':\n                    # strip nsh ansi codes\n                    s = s.replace(\"\\033[K\",\"\")\n                sys.stdout.write(s)\n                self.last_packet = time.time()", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        mtype = m.get_type()\n        if mtype in ['WAYPOINT_COUNT','MISSION_COUNT']:\n            if self.wp_op is None:\n                self.console.error(\"No waypoint load started\")\n            else:\n                self.wploader.clear()\n                self.wploader.expected_count = m.count\n                self.console.writeln(\"Requesting %u waypoints t=%s now=%s\" % (m.count,\n                                                                                 time.asctime(time.localtime(m._timestamp)),\n                                                                                 time.asctime()))\n                self.master.waypoint_request_send(0)\n\n        elif mtype in ['WAYPOINT', 'MISSION_ITEM'] and self.wp_op != None:\n            if m.seq > self.wploader.count():\n                self.console.writeln(\"Unexpected waypoint number %u - expected %u\" % (m.seq, self.wploader.count()))\n            elif m.seq < self.wploader.count():\n                # a duplicate\n                pass\n            else:\n                self.wploader.add(m)\n            if m.seq+1 < self.wploader.expected_count:\n                self.master.waypoint_request_send(m.seq+1)\n            else:\n                if self.wp_op == 'list':\n                    for i in range(self.wploader.count()):\n                        w = self.wploader.wp(i)\n                        print(\"%u %u %.10f %.10f %f p1=%.1f p2=%.1f p3=%.1f p4=%.1f cur=%u auto=%u\" % (\n                            w.command, w.frame, w.x, w.y, w.z,\n                            w.param1, w.param2, w.param3, w.param4,\n                            w.current, w.autocontinue))\n                    if self.logdir != None:\n                        waytxt = os.path.join(self.logdir, 'way.txt')\n                        self.save_waypoints(waytxt)\n                        print(\"Saved waypoints to %s\" % waytxt)\n                elif self.wp_op == \"save\":\n                    self.save_waypoints(self.wp_save_filename)\n                self.wp_op = None\n\n        elif mtype in [\"WAYPOINT_REQUEST\", \"MISSION_REQUEST\"]:\n            self.process_waypoint_request(m, self.master)\n\n        elif mtype in [\"WAYPOINT_CURRENT\", \"MISSION_CURRENT\"]:\n            if m.seq != self.last_waypoint:\n                self.last_waypoint = m.seq\n                if self.settings.wpupdates:\n                    self.say(\"waypoint %u\" % m.seq,priority='message')", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses a waypoint request from the master", "response": "def process_waypoint_request(self, m, master):\n        '''process a waypoint request from the master'''\n        if (not self.loading_waypoints or\n            time.time() > self.loading_waypoint_lasttime + 10.0):\n            self.loading_waypoints = False\n            self.console.error(\"not loading waypoints\")\n            return\n        if m.seq >= self.wploader.count():\n            self.console.error(\"Request for bad waypoint %u (max %u)\" % (m.seq, self.wploader.count()))\n            return\n        wp = self.wploader.wp(m.seq)\n        wp.target_system = self.target_system\n        wp.target_component = self.target_component\n        self.master.mav.send(self.wploader.wp(m.seq))\n        self.loading_waypoint_lasttime = time.time()\n        self.console.writeln(\"Sent waypoint %u : %s\" % (m.seq, self.wploader.wp(m.seq)))\n        if m.seq == self.wploader.count() - 1:\n            self.loading_waypoints = False\n            self.console.writeln(\"Sent all %u waypoints\" % self.wploader.count())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_all_waypoints(self):\n        '''send all waypoints to vehicle'''\n        self.master.waypoint_clear_all_send()\n        if self.wploader.count() == 0:\n            return\n        self.loading_waypoints = True\n        self.loading_waypoint_lasttime = time.time()\n        self.master.waypoint_count_send(self.wploader.count())", "response": "send all waypoints to vehicle"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_waypoints(self, filename):\n        '''load waypoints from a file'''\n        self.wploader.target_system = self.target_system\n        self.wploader.target_component = self.target_component\n        try:\n            self.wploader.load(filename)\n        except Exception as msg:\n            print(\"Unable to load %s - %s\" % (filename, msg))\n            return\n        print(\"Loaded %u waypoints from %s\" % (self.wploader.count(), filename))\n        self.send_all_waypoints()", "response": "load waypoints from a file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_waypoints(self, filename, wpnum):\n        '''update waypoints from a file'''\n        self.wploader.target_system = self.target_system\n        self.wploader.target_component = self.target_component\n        try:\n            self.wploader.load(filename)\n        except Exception as msg:\n            print(\"Unable to load %s - %s\" % (filename, msg))\n            return\n        if self.wploader.count() == 0:\n            print(\"No waypoints found in %s\" % filename)\n            return\n        if wpnum == -1:\n            print(\"Loaded %u updated waypoints from %s\" % (self.wploader.count(), filename))\n        elif wpnum >= self.wploader.count():\n            print(\"Invalid waypoint number %u\" % wpnum)\n            return\n        else:\n            print(\"Loaded updated waypoint %u from %s\" % (wpnum, filename))\n\n        self.loading_waypoints = True\n        self.loading_waypoint_lasttime = time.time()\n        if wpnum == -1:\n            start = 0\n            end = self.wploader.count()-1\n        else:\n            start = wpnum\n            end = wpnum\n        self.master.mav.mission_write_partial_list_send(self.target_system,\n                                                             self.target_component,\n                                                             start, end)", "response": "update waypoints from a file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_default_frame(self):\n        '''default frame for waypoints'''\n        if self.settings.terrainalt == 'Auto':\n            if self.get_mav_param('TERRAIN_FOLLOW',0) == 1:\n                return mavutil.mavlink.MAV_FRAME_GLOBAL_TERRAIN_ALT\n            return mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT\n        if self.settings.terrainalt == 'True':\n            return mavutil.mavlink.MAV_FRAME_GLOBAL_TERRAIN_ALT\n        return mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT", "response": "default frame for waypoints"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncloses the loop on a mission", "response": "def wp_loop(self):\n        '''close the loop on a mission'''\n        loader = self.wploader\n        if loader.count() < 2:\n            print(\"Not enough waypoints (%u)\" % loader.count())\n            return\n        wp = loader.wp(loader.count()-2)\n        if wp.command == mavutil.mavlink.MAV_CMD_DO_JUMP:\n            print(\"Mission is already looped\")\n            return\n        wp = mavutil.mavlink.MAVLink_mission_item_message(0, 0, 0, 0, mavutil.mavlink.MAV_CMD_DO_JUMP,\n                                                          0, 1, 1, -1, 0, 0, 0, 0, 0)\n        loader.add(wp)\n        self.loading_waypoints = True\n        self.loading_waypoint_lasttime = time.time()\n        self.master.waypoint_count_send(self.wploader.count())\n        print(\"Closed loop on mission\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting home location from last map click", "response": "def set_home_location(self):\n        '''set home location from last map click'''\n        try:\n            latlon = self.module('map').click_position\n        except Exception:\n            print(\"No map available\")\n            return\n        lat = float(latlon[0])\n        lon = float(latlon[1])\n        if self.wploader.count() == 0:\n            self.wploader.add_latlonalt(lat, lon, 0)\n        w = self.wploader.wp(0)\n        w.x = lat\n        w.y = lon\n        self.wploader.set(w, 0)\n        self.loading_waypoints = True\n        self.loading_waypoint_lasttime = time.time()\n        self.master.mav.mission_write_partial_list_send(self.target_system,\n                                                             self.target_component,\n                                                             0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cmd_wp_movemulti(self, args):\n        '''handle wp move of multiple waypoints'''\n        if len(args) < 3:\n            print(\"usage: wp movemulti WPNUM WPSTART WPEND <rotation>\")\n            return\n        idx = int(args[0])\n        if idx < 1 or idx > self.wploader.count():\n            print(\"Invalid wp number %u\" % idx)\n            return\n        wpstart = int(args[1])\n        if wpstart < 1 or wpstart > self.wploader.count():\n            print(\"Invalid wp number %u\" % wpstart)\n            return\n        wpend = int(args[2])\n        if wpend < 1 or wpend > self.wploader.count():\n            print(\"Invalid wp number %u\" % wpend)\n            return\n        if idx < wpstart or idx > wpend:\n            print(\"WPNUM must be between WPSTART and WPEND\")\n            return\n\n        # optional rotation about center point\n        if len(args) > 3:\n            rotation = float(args[3])\n        else:\n            rotation = 0\n\n        try:\n            latlon = self.module('map').click_position\n        except Exception:\n            print(\"No map available\")\n            return\n        if latlon is None:\n            print(\"No map click position available\")\n            return\n        wp = self.wploader.wp(idx)\n        if not self.wploader.is_location_command(wp.command):\n            print(\"WP must be a location command\")\n            return\n\n        (lat, lon) = latlon\n        distance = mp_util.gps_distance(wp.x, wp.y, lat, lon)\n        bearing  = mp_util.gps_bearing(wp.x, wp.y, lat, lon)\n\n        for wpnum in range(wpstart, wpend+1):\n            wp = self.wploader.wp(wpnum)\n            if not self.wploader.is_location_command(wp.command):\n                continue\n            (newlat, newlon) = mp_util.gps_newpos(wp.x, wp.y, bearing, distance)\n            if wpnum != idx and rotation != 0:\n                # add in rotation\n                d2 = mp_util.gps_distance(lat, lon, newlat, newlon)\n                b2 = mp_util.gps_bearing(lat, lon, newlat, newlon)\n                (newlat, newlon) = mp_util.gps_newpos(lat, lon, b2+rotation, d2)\n                \n            if getattr(self.console, 'ElevationMap', None) is not None and wp.frame != mavutil.mavlink.MAV_FRAME_GLOBAL_TERRAIN_ALT:\n                alt1 = self.console.ElevationMap.GetElevation(newlat, newlon)\n                alt2 = self.console.ElevationMap.GetElevation(wp.x, wp.y)\n                if alt1 is not None and alt2 is not None:\n                    wp.z += alt1 - alt2\n            wp.x = newlat\n            wp.y = newlon\n            wp.target_system    = self.target_system\n            wp.target_component = self.target_component\n            self.wploader.set(wp, wpnum)\n            \n        self.loading_waypoints = True\n        self.loading_waypoint_lasttime = time.time()\n        self.master.mav.mission_write_partial_list_send(self.target_system,\n                                                        self.target_component,\n                                                        wpstart, wpend+1)\n        print(\"Moved WPs %u:%u to %f, %f rotation=%.1f\" % (wpstart, wpend, lat, lon, rotation))", "response": "handle wp movemulti command"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles wp parameter change", "response": "def cmd_wp_param(self, args):\n        '''handle wp parameter change'''\n        if len(args) < 2:\n            print(\"usage: wp param WPNUM PNUM <VALUE>\")\n            return\n        idx = int(args[0])\n        if idx < 1 or idx > self.wploader.count():\n            print(\"Invalid wp number %u\" % idx)\n            return\n        wp = self.wploader.wp(idx)\n        param = [wp.param1, wp.param2, wp.param3, wp.param4]\n        pnum = int(args[1])\n        if pnum < 1 or pnum > 4:\n            print(\"Invalid param number %u\" % pnum)\n            return\n\n        if len(args) == 2:\n            print(\"Param %u: %f\" % (pnum, param[pnum-1]))\n            return\n\n        param[pnum-1] = float(args[2])\n        wp.param1 = param[0]\n        wp.param2 = param[1]\n        wp.param3 = param[2]\n        wp.param4 = param[3]\n        \n        wp.target_system    = self.target_system\n        wp.target_component = self.target_component\n        self.loading_waypoints = True\n        self.loading_waypoint_lasttime = time.time()\n        self.master.mav.mission_write_partial_list_send(self.target_system,\n                                                        self.target_component,\n                                                        idx, idx)\n        self.wploader.set(wp, idx)\n        print(\"Set param %u for %u to %f\" % (pnum, idx, param[pnum-1]))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef depthToRGB8(float_img_buff, encoding):\n    '''\n    Translates from Distance Image format to RGB. Inf values are represented by NaN, when converting to RGB, NaN passed to 0 \n\n    @param float_img_buff: ROS Image to translate\n\n    @type img: ros image\n\n    @return a Opencv RGB image\n\n    '''\n    gray_image = None\n    if (encoding[-3:-2]== \"U\"):\n        gray_image = float_img_buff\n    else:    \n        float_img = np.zeros((float_img_buff.shape[0], float_img_buff.shape[1], 1), dtype = \"float32\")\n        float_img.data = float_img_buff.data\n        gray_image=cv2.convertScaleAbs(float_img, alpha=255/MAXRANGE)\n\n\n    cv_image = cv2.cvtColor(gray_image, cv2.COLOR_GRAY2RGB)\n\n    return cv_image", "response": "Translate from Distance Image format to RGB."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstarting (Subscribes) the client.", "response": "def start (self):\n        '''\n        Starts (Subscribes) the client.\n\n        '''\n        self.sub = rospy.Subscriber(self.topic, ImageROS, self.__callback)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getImage(self):\n        '''\n        Returns last Image. \n\n        @return last JdeRobotTypes Image saved\n\n        '''\n        self.lock.acquire()\n        image = self.data\n        self.lock.release()\n        \n        return image", "response": "Returns last JdeRobotTypes Image. \n\n        Returns last JdeRobotTypes Image. \n\n        Returns last JdeRobotTypes Image. \n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_offsets(data, ofs):\n    '''find mag offsets by applying Bills \"offsets revisited\" algorithm\n       on the data\n\n       This is an implementation of the algorithm from:\n          http://gentlenav.googlecode.com/files/MagnetometerOffsetNullingRevisited.pdf\n       '''\n\n    # a limit on the maximum change in each step\n    max_change = args.max_change\n\n    # the gain factor for the algorithm\n    gain = args.gain\n\n    data2 = []\n    for d in data:\n        d = d.copy() + noise()\n        d.x = float(int(d.x + 0.5))\n        d.y = float(int(d.y + 0.5))\n        d.z = float(int(d.z + 0.5))\n        data2.append(d)\n    data = data2\n\n    history_idx = 0\n    mag_history = data[0:args.history]\n\n    for i in range(args.history, len(data)):\n        B1 = mag_history[history_idx] + ofs\n        B2 = data[i] + ofs\n\n        diff = B2 - B1\n        diff_length = diff.length()\n        if diff_length <= args.min_diff:\n            # the mag vector hasn't changed enough - we don't get any\n            # information from this\n            history_idx = (history_idx+1) % args.history\n            continue\n\n        mag_history[history_idx] = data[i]\n        history_idx = (history_idx+1) % args.history\n\n        # equation 6 of Bills paper\n        delta = diff * (gain * (B2.length() - B1.length()) / diff_length)\n\n        # limit the change from any one reading. This is to prevent\n        # single crazy readings from throwing off the offsets for a long\n        # time\n        delta_length = delta.length()\n        if max_change != 0 and delta_length > max_change:\n            delta *= max_change / delta_length\n\n        # set the new offsets\n        ofs = ofs - delta\n\n        if args.verbose:\n            print(ofs)\n    return ofs", "response": "find the offsets for the current time of the current time"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef magfit(logfile):\n    '''find best magnetometer offset fit to a log file'''\n\n    print(\"Processing log %s\" % filename)\n\n    # open the log file\n    mlog = mavutil.mavlink_connection(filename, notimestamps=args.notimestamps)\n\n    data = []\n    mag = None\n    offsets = Vector3(0,0,0)\n\n    # now gather all the data\n    while True:\n        # get the next MAVLink message in the log\n        m = mlog.recv_match(condition=args.condition)\n        if m is None:\n            break\n        if m.get_type() == \"SENSOR_OFFSETS\":\n            # update offsets that were used during this flight\n            offsets = Vector3(m.mag_ofs_x, m.mag_ofs_y, m.mag_ofs_z)\n        if m.get_type() == \"RAW_IMU\" and offsets != None:\n            # extract one mag vector, removing the offsets that were\n            # used during that flight to get the raw sensor values\n            mag = Vector3(m.xmag, m.ymag, m.zmag) - offsets\n            data.append(mag)\n\n    print(\"Extracted %u data points\" % len(data))\n    print(\"Current offsets: %s\" % offsets)\n\n    # run the fitting algorithm\n    ofs = offsets\n    ofs = Vector3(0,0,0)\n    for r in range(args.repeat):\n        ofs = find_offsets(data, ofs)\n        print('Loop %u offsets %s' % (r, ofs))\n        sys.stdout.flush()\n    print(\"New offsets: %s\" % ofs)", "response": "find best magnetometer offset fit to a log file"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the currently displayed image", "response": "def set_image(self, img, bgr=False):\n        '''set the currently displayed image'''\n        if not self.is_alive():\n            return\n        if bgr:\n            img = cv.CloneImage(img)\n            cv.CvtColor(img, img, cv.CV_BGR2RGB)\n        self.in_queue.put(MPImageData(img))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_menu(self, menu):\n        '''set a MPTopMenu on the frame'''\n        self.menu = menu\n        self.in_queue.put(MPImageMenu(menu))", "response": "set a MPTopMenu on the frame"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a popup menu on the frame", "response": "def set_popup_menu(self, menu):\n        '''set a popup menu on the frame'''\n        self.popup_menu = menu\n        self.in_queue.put(MPImagePopupMenu(menu))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef events(self):\n        '''check for events a list of events'''\n        ret = []\n        while self.out_queue.qsize():\n            ret.append(self.out_queue.get())\n        return ret", "response": "check for events a list of events"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef image_coordinates(self, point):\n        '''given a point in window coordinates, calculate image coordinates'''\n        # the dragpos is the top left position in image coordinates\n        ret = wx.Point(int(self.dragpos.x + point.x/self.zoom),\n                       int(self.dragpos.y + point.y/self.zoom))\n        return ret", "response": "given a point in window coordinates calculate image coordinates"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nredraw the image with current settings", "response": "def redraw(self):\n        '''redraw the image with current settings'''\n        state = self.state\n\n        if self.img is None:\n            self.mainSizer.Fit(self)\n            self.Refresh()\n            state.frame.Refresh()\n            self.SetFocus()\n            return\n\n        # get the current size of the containing window frame\n        size = self.frame.GetSize()\n        (width, height) = (self.img.GetWidth(), self.img.GetHeight())\n\n        rect = wx.Rect(self.dragpos.x, self.dragpos.y, int(size.x/self.zoom), int(size.y/self.zoom))\n\n        #print(\"redraw\", self.zoom, self.dragpos, size, rect);\n\n        if rect.x > width-1:\n            rect.x = width-1\n        if rect.y > height-1:\n            rect.y = height-1\n        if rect.width > width - rect.x:\n            rect.width = width - rect.x\n        if rect.height > height - rect.y:\n            rect.height = height - rect.y\n\n        scaled_image = self.img.Copy()\n        scaled_image = scaled_image.GetSubImage(rect);\n        scaled_image = scaled_image.Rescale(int(rect.width*self.zoom), int(rect.height*self.zoom))\n        if state.brightness != 1.0:\n            try:\n                from PIL import Image\n                pimg = mp_util.wxToPIL(scaled_image)\n                pimg = Image.eval(pimg, lambda x: int(x * state.brightness))\n                scaled_image = mp_util.PILTowx(pimg)\n            except Exception:\n                if not self.done_PIL_warning:\n                    print(\"Please install PIL for brightness control\")\n                    self.done_PIL_warning = True\n                # ignore lack of PIL library\n                pass\n        self.imagePanel.set_image(scaled_image)\n        self.need_redraw = False\n\n        self.mainSizer.Fit(self)\n        self.Refresh()\n        state.frame.Refresh()\n        self.SetFocus()\n        '''\n        from guppy import hpy\n        h = hpy()\n        print h.heap()\n        '''"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_redraw_timer(self, event):\n        '''the redraw timer ensures we show new map tiles as they\n        are downloaded'''\n        state = self.state\n        while state.in_queue.qsize():\n            obj = state.in_queue.get()\n            if isinstance(obj, MPImageData):\n                img = wx.EmptyImage(obj.width, obj.height)\n                img.SetData(obj.data)\n                self.img = img\n                self.need_redraw = True\n                if state.auto_size:\n                    client_area = state.frame.GetClientSize()\n                    total_area = state.frame.GetSize()\n                    bx = max(total_area.x - client_area.x,0)\n                    by = max(total_area.y - client_area.y,0)\n                    state.frame.SetSize(wx.Size(obj.width+bx, obj.height+by))\n            if isinstance(obj, MPImageTitle):\n                state.frame.SetTitle(obj.title)\n            if isinstance(obj, MPImageMenu):\n                self.set_menu(obj.menu)\n            if isinstance(obj, MPImagePopupMenu):\n                self.set_popup_menu(obj.menu)\n            if isinstance(obj, MPImageBrightness):\n                state.brightness = obj.brightness\n                self.need_redraw = True\n            if isinstance(obj, MPImageFullSize):\n                self.full_size()\n            if isinstance(obj, MPImageFitToWindow):\n                self.fit_to_window()\n        if self.need_redraw:\n            self.redraw()", "response": "the redraw timer ensures we show new map tiles as they are downloaded"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles window size changes", "response": "def on_size(self, event):\n        '''handle window size changes'''\n        state = self.state\n        self.need_redraw = True\n        if state.report_size_changes:\n            # tell owner the new size\n            size = self.frame.GetSize()\n            if size != self.last_size:\n                self.last_size = size\n                state.out_queue.put(MPImageNewSize(size))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlimit dragpos to sane values", "response": "def limit_dragpos(self):\n        '''limit dragpos to sane values'''\n        if self.dragpos.x < 0:\n            self.dragpos.x = 0\n        if self.dragpos.y < 0:\n            self.dragpos.y = 0\n        if self.img is None:\n            return\n        if self.dragpos.x >= self.img.GetWidth():\n            self.dragpos.x = self.img.GetWidth()-1\n        if self.dragpos.y >= self.img.GetHeight():\n            self.dragpos.y = self.img.GetHeight()-1"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_mouse_wheel(self, event):\n        '''handle mouse wheel zoom changes'''\n        state = self.state\n        if not state.can_zoom:\n            return\n        mousepos = self.image_coordinates(event.GetPosition())\n        rotation = event.GetWheelRotation() / event.GetWheelDelta()\n        oldzoom = self.zoom\n        if rotation > 0:\n            self.zoom /= 1.0/(1.1 * rotation)\n        elif rotation < 0:\n            self.zoom /= 1.1 * (-rotation)\n        if self.zoom > 10:\n            self.zoom = 10\n        elif self.zoom < 0.1:\n            self.zoom = 0.1\n        if oldzoom < 1 and self.zoom > 1:\n            self.zoom = 1\n        if oldzoom > 1 and self.zoom < 1:\n            self.zoom = 1\n        self.need_redraw = True\n        new = self.image_coordinates(event.GetPosition())\n        # adjust dragpos so the zoom doesn't change what pixel is under the mouse\n        self.dragpos = wx.Point(self.dragpos.x - (new.x-mousepos.x), self.dragpos.y - (new.y-mousepos.y))\n        self.limit_dragpos()", "response": "handle mouse wheel zoom changes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshowing a popup menu", "response": "def show_popup_menu(self, pos):\n        '''show a popup menu'''\n        self.popup_pos = self.image_coordinates(pos)\n        self.frame.PopupMenu(self.wx_popup_menu, pos)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npass events to the parent", "response": "def on_event(self, event):\n        '''pass events to the parent'''\n        state = self.state\n        if isinstance(event, wx.MouseEvent):\n            self.on_mouse_event(event)\n        if isinstance(event, wx.KeyEvent):\n            self.on_key_event(event)\n        if (isinstance(event, wx.MouseEvent) and\n            not event.ButtonIsDown(wx.MOUSE_BTN_ANY) and\n            event.GetWheelRotation() == 0):\n            # don't flood the queue with mouse movement\n            return\n        evt = mp_util.object_container(event)\n        pt = self.image_coordinates(wx.Point(evt.X,evt.Y))\n        evt.X = pt.x\n        evt.Y = pt.y\n        state.out_queue.put(evt)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_menu(self, event):\n        '''called on menu event'''\n        state = self.state\n        if self.popup_menu is not None:\n            ret = self.popup_menu.find_selected(event)\n            if ret is not None:\n                ret.popup_pos = self.popup_pos\n                if ret.returnkey == 'fitWindow':\n                    self.fit_to_window()\n                elif ret.returnkey == 'fullSize':\n                    self.full_size()\n                else:\n                    state.out_queue.put(ret)\n                return\n        if self.menu is not None:\n            ret = self.menu.find_selected(event)\n            if ret is not None:\n                state.out_queue.put(ret)\n                return", "response": "called on menu event"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_menu(self, menu):\n        '''add a menu from the parent'''\n        self.menu = menu\n        wx_menu = menu.wx_menu()\n        self.frame.SetMenuBar(wx_menu)\n        self.frame.Bind(wx.EVT_MENU, self.on_menu)", "response": "add a menu from the parent"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a popup menu from the parent", "response": "def set_popup_menu(self, menu):\n        '''add a popup menu from the parent'''\n        self.popup_menu = menu\n        if menu is None:\n            self.wx_popup_menu = None\n        else:\n            self.wx_popup_menu = menu.wx_menu()\n            self.frame.Bind(wx.EVT_MENU, self.on_menu)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfit image to window", "response": "def fit_to_window(self):\n        '''fit image to window'''\n        state = self.state\n        self.dragpos = wx.Point(0, 0)\n        client_area = state.frame.GetClientSize()\n        self.zoom = min(float(client_area.x) / self.img.GetWidth(),\n                        float(client_area.y) / self.img.GetHeight())\n        self.need_redraw = True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef full_size(self):\n        '''show image at full size'''\n        self.dragpos = wx.Point(0, 0)\n        self.zoom = 1.0\n        self.need_redraw = True", "response": "show image at full size"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef message_checksum(msg):\n    '''calculate a 8-bit checksum of the key fields of a message, so we\n       can detect incompatible XML changes'''\n    from .mavcrc import x25crc\n    crc = x25crc()\n    crc.accumulate_str(msg.name + ' ')\n    # in order to allow for extensions the crc does not include\n    # any field extensions\n    crc_end = msg.base_fields()\n    for i in range(crc_end):\n        f = msg.ordered_fields[i]\n        crc.accumulate_str(f.type + ' ')\n        crc.accumulate_str(f.name + ' ')\n        if f.array_length:\n            crc.accumulate([f.array_length])\n    return (crc.crc&0xFF) ^ (crc.crc>>8)", "response": "calculate a 8 - bit checksum of the key fields of a message"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef merge_enums(xml):\n    '''merge enums between XML files'''\n    emap = {}\n    for x in xml:\n        newenums = []\n        for enum in x.enum:\n            if enum.name in emap:\n                emapitem = emap[enum.name]\n                # check for possible conflicting auto-assigned values after merge\n                if (emapitem.start_value <= enum.highest_value and emapitem.highest_value >= enum.start_value):\n                    for entry in emapitem.entry:\n                        # correct the value if necessary, but only if it was auto-assigned to begin with\n                        if entry.value <= enum.highest_value and entry.autovalue == True:\n                            entry.value = enum.highest_value + 1\n                            enum.highest_value = entry.value\n                # merge the entries\n                emapitem.entry.extend(enum.entry)\n                if not emapitem.description:\n                    emapitem.description = enum.description\n                print(\"Merged enum %s\" % enum.name)\n            else:\n                newenums.append(enum)\n                emap[enum.name] = enum\n        x.enum = newenums\n    for e in emap:\n        # sort by value\n        emap[e].entry = sorted(emap[e].entry,\n                               key=operator.attrgetter('value'),\n                               reverse=False)\n        # add a ENUM_END\n        emap[e].entry.append(MAVEnumEntry(\"%s_ENUM_END\" % emap[e].name,\n                                            emap[e].entry[-1].value+1, end_marker=True))", "response": "merge enums between XML files"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking for duplicate message IDs", "response": "def check_duplicates(xml):\n    '''check for duplicate message IDs'''\n\n    merge_enums(xml)\n\n    msgmap = {}\n    enummap = {}\n    for x in xml:\n        for m in x.message:\n            key = m.id\n            if key in msgmap:\n                print(\"ERROR: Duplicate message id %u for %s (%s:%u) also used by %s\" % (\n                    m.id,\n                    m.name,\n                    x.filename, m.linenumber,\n                    msgmap[key]))\n                return True\n            fieldset = set()\n            for f in m.fields:\n                if f.name in fieldset:\n                    print(\"ERROR: Duplicate field %s in message %s (%s:%u)\" % (\n                        f.name, m.name,\n                        x.filename, m.linenumber))\n                    return True\n                fieldset.add(f.name)\n            msgmap[key] = '%s (%s:%u)' % (m.name, x.filename, m.linenumber)\n        for enum in x.enum:\n            for entry in enum.entry:\n                if entry.autovalue == True and \"common.xml\" not in entry.origin_file:\n                    print(\"Note: An enum value was auto-generated: %s = %u\" % (entry.name, entry.value))\n                s1 = \"%s.%s\" % (enum.name, entry.name)\n                s2 = \"%s.%s\" % (enum.name, entry.value)\n                if s1 in enummap or s2 in enummap:\n                    print(\"ERROR: Duplicate enum %s:\\n\\t%s = %s @ %s:%u\\n\\t%s\" % (\n                        \"names\" if s1 in enummap else \"values\",\n                        s1, entry.value, entry.origin_file, entry.origin_line,\n                        enummap.get(s1) or enummap.get(s2)))\n                    return True\n                enummap[s1] = enummap[s2] = \"%s.%s = %s @ %s:%u\" % (enum.name, entry.name, entry.value, entry.origin_file, entry.origin_line)\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef total_msgs(xml):\n    '''count total number of msgs'''\n    count = 0\n    for x in xml:\n        count += len(x.message)\n    return count", "response": "count total number of msgs in xml"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns number of non - extended fields", "response": "def base_fields(self):\n        '''return number of non-extended fields'''\n        if self.extensions_start is None:\n            return len(self.fields)\n        return len(self.fields[:self.extensions_start])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating some interesting datapoints of the file and print them out.", "response": "def PrintSummary(logfile):\n    '''Calculate some interesting datapoints of the file'''\n    # Open the log file\n    mlog = mavutil.mavlink_connection(filename, notimestamps=args.notimestamps, dialect=args.dialect)\n\n    autonomous_sections = 0 # How many different autonomous sections there are\n    autonomous = False # Whether the vehicle is currently autonomous at this point in the logfile\n    auto_time = 0.0 # The total time the vehicle was autonomous/guided (seconds)\n    start_time = None # The datetime of the first received message (seconds since epoch)\n    total_dist = 0.0 # The total ground distance travelled (meters)\n    last_gps_msg = None # The first GPS message received\n    first_gps_msg = None # The last GPS message received\n    true_time = None # Track the first timestamp found that corresponds to a UNIX timestamp\n\n    while True:\n        m = mlog.recv_match(condition=args.condition)\n\n        # If there's no match, it means we're done processing the log.\n        if m is None:\n            break\n\n        # Ignore any failed messages\n        if m.get_type() == 'BAD_DATA':\n            continue\n\n        # Keep track of the latest timestamp for various calculations\n        timestamp = getattr(m, '_timestamp', 0.0)\n\n        # Log the first message time\n        if start_time is None:\n            start_time = timestamp\n\n        # Log the first timestamp found that is a true timestamp. We first try\n        # to get the groundstation timestamp from the log directly. If that fails\n        # we try to find a message that outputs a Unix time-since-epoch.\n        if true_time is None:\n            if not args.notimestamps and timestamp >= 1230768000:\n                true_time = timestamp\n            elif 'time_unix_usec' in m.__dict__ and m.time_unix_usec >= 1230768000:\n                true_time = m.time_unix_usec * 1.0e-6\n            elif 'time_usec' in m.__dict__ and m.time_usec >= 1230768000:\n                true_time = m.time_usec * 1.0e-6\n\n        # Track the vehicle's speed and status\n        if m.get_type() == 'GPS_RAW_INT':\n\n            # Ignore GPS messages without a proper fix\n            if m.fix_type < 3 or m.lat == 0 or m.lon == 0:\n                continue\n\n            # Log the first GPS location found, being sure to skip GPS fixes\n            # that are bad (at lat/lon of 0,0)\n            if first_gps_msg is None:\n                first_gps_msg = m\n\n            # Track the distance travelled, being sure to skip GPS fixes\n            # that are bad (at lat/lon of 0,0)\n            if last_gps_msg is None or m.time_usec > last_gps_msg.time_usec or m.time_usec+30e6 < last_gps_msg.time_usec:\n                if last_gps_msg is not None:\n                    total_dist += distance_two(last_gps_msg, m)\n\n                # Save this GPS message to do simple distance calculations with\n                last_gps_msg = m\n\n        elif m.get_type() == 'HEARTBEAT':\n            if m.type == mavutil.mavlink.MAV_TYPE_GCS:\n                continue\n            if (m.base_mode & mavutil.mavlink.MAV_MODE_FLAG_GUIDED_ENABLED or\n                m.base_mode & mavutil.mavlink.MAV_MODE_FLAG_AUTO_ENABLED) and autonomous == False:\n                autonomous = True\n                autonomous_sections += 1\n                start_auto_time = timestamp\n            elif (not m.base_mode & mavutil.mavlink.MAV_MODE_FLAG_GUIDED_ENABLED and\n                not m.base_mode & mavutil.mavlink.MAV_MODE_FLAG_AUTO_ENABLED) and autonomous == True:\n                autonomous = False\n                auto_time += timestamp - start_auto_time\n\n    # If there were no messages processed, say so\n    if start_time is None:\n        print(\"ERROR: No messages found.\")\n        return\n\n    # If the vehicle ends in autonomous mode, make sure we log the total time\n    if autonomous == True:\n        auto_time += timestamp - start_auto_time\n\n    # Compute the total logtime, checking that timestamps are 2009 or newer for validity\n    # (MAVLink didn't exist until 2009)\n    if true_time:\n        start_time_str = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(true_time))\n        print(\"Log started at about {}\".format(start_time_str))\n    else:\n        print(\"Warning: No absolute timestamp found in datastream. No starting time can be provided for this log.\")\n\n    # Print location data\n    if last_gps_msg is not None:\n        first_gps_position = (first_gps_msg.lat / 1e7, first_gps_msg.lon / 1e7)\n        last_gps_position = (last_gps_msg.lat / 1e7, last_gps_msg.lon / 1e7)\n        print(\"Travelled from ({0[0]}, {0[1]}) to ({1[0]}, {1[1]})\".format(first_gps_position, last_gps_position))\n        print(\"Total distance : {:0.2f}m\".format(total_dist))\n    else:\n        print(\"Warning: No GPS data found, can't give position summary.\")\n\n    # Print out the rest of the results.\n    total_time = timestamp - start_time\n    print(\"Total time (mm:ss): {:3.0f}:{:02.0f}\".format(total_time / 60, total_time % 60))\n    # The autonomous time should be good, as a steady HEARTBEAT is required for MAVLink operation\n    print(\"Autonomous sections: {}\".format(autonomous_sections))\n    if autonomous_sections > 0:\n        print(\"Autonomous time (mm:ss): {:3.0f}:{:02.0f}\".format(auto_time / 60, auto_time % 60))\n\n    totals.time += total_time\n    totals.distance += total_dist\n    totals.flights += 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncontrol behaviour of the module", "response": "def cmd_dataflash_logger(self, args):\n        '''control behaviour of the module'''\n        if len(args) == 0:\n            print (self.usage())\n        elif args[0] == \"status\":\n            print (self.status())\n        elif args[0] == \"stop\":\n            self.new_log_started = False\n            self.stopped = True\n        elif args[0] == \"start\":\n            self.stopped = False\n        elif args[0] == \"set\":\n            self.log_settings.command(args[1:])\n        else:\n            print (self.usage())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _dataflash_dir(self, mpstate):\n        '''returns directory path to store DF logs in.  May be relative'''\n        if mpstate.settings.state_basedir is None:\n            ret = 'dataflash'\n        else:\n            ret = os.path.join(mpstate.settings.state_basedir,'dataflash')\n\n        try:\n            os.makedirs(ret)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                print(\"DFLogger: OSError making (%s): %s\" % (ret, str(e)))\n        except Exception as e:\n            print(\"DFLogger: Unknown exception making (%s): %s\" % (ret, str(e)))\n\n        return ret", "response": "returns directory path to store DF logs in. May be relative"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef new_log_filepath(self):\n        '''returns a filepath to a log which does not currently exist and is suitable for DF logging'''\n        lastlog_filename = os.path.join(self.dataflash_dir,'LASTLOG.TXT')\n        if os.path.exists(lastlog_filename) and os.stat(lastlog_filename).st_size != 0:\n            fh = open(lastlog_filename,'rb')\n            log_cnt = int(fh.read()) + 1\n            fh.close()\n        else:\n            log_cnt = 1\n\n        self.lastlog_file = open(lastlog_filename,'w+b')\n        self.lastlog_file.write(log_cnt.__str__())\n        self.lastlog_file.close()\n\n        return os.path.join(self.dataflash_dir, '%u.BIN' % (log_cnt,));", "response": "returns a filepath to a log which does not currently exist and is suitable for DF logging"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start_new_log(self):\n        '''open a new dataflash log, reset state'''\n        filename = self.new_log_filepath()\n\n        self.block_cnt = 0\n        self.logfile = open(filename, 'w+b')\n        print(\"DFLogger: logging started (%s)\" % (filename))\n        self.prev_cnt = 0\n        self.download = 0\n        self.prev_download = 0\n        self.last_idle_status_printed_time = time.time()\n        self.last_status_time = time.time()\n        self.missing_blocks = {}\n        self.acking_blocks = {}\n        self.blocks_to_ack_and_nack = []\n        self.missing_found = 0\n        self.abandoned = 0", "response": "open a new dataflash log reset state"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef status(self):\n        '''returns information about module'''\n        transfered = self.download - self.prev_download\n        now = time.time()\n        interval = now - self.last_status_time\n        self.last_status_time = now\n        return(\"DFLogger: %(state)s Rate(%(interval)ds):%(rate).3fkB/s Block:%(block_cnt)d Missing:%(missing)d Fixed:%(fixed)d Abandoned:%(abandoned)d\" %\n              {\"interval\": interval,\n               \"rate\": transfered/(interval*1000),\n               \"block_cnt\": self.block_cnt,\n               \"missing\": len(self.missing_blocks),\n               \"fixed\": self.missing_found,\n               \"abandoned\": self.abandoned,\n               \"state\": \"Inactive\" if self.stopped else \"Active\"\n           })", "response": "returns information about module"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef idle_print_status(self):\n        '''print out statistics every 10 seconds from idle loop'''\n        now = time.time()\n        if (now - self.last_idle_status_printed_time) >= 10:\n            print (self.status())\n            self.last_idle_status_printed_time = now\n            self.prev_download = self.download", "response": "print out statistics every 10 seconds from idle loop"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef idle_send_acks_and_nacks(self):\n        '''Send packets to UAV in idle loop'''\n        max_blocks_to_send = 10\n        blocks_sent = 0\n        i=0\n        now = time.time()\n        while i < len(self.blocks_to_ack_and_nack) and blocks_sent < max_blocks_to_send:\n#            print(\"ACKLIST: %s\" % ([x[1] for x in self.blocks_to_ack_and_nack],))\n            stuff = self.blocks_to_ack_and_nack[i]\n\n            [master, block, status, first_sent, last_sent] = stuff\n            if status == 1:\n#                print(\"DFLogger: ACKing block (%d)\" % (block,))\n                self.master.mav.remote_log_block_status_send(block,status)\n                blocks_sent += 1\n                del self.acking_blocks[block]\n                del self.blocks_to_ack_and_nack[i]\n                continue\n\n            if block not in self.missing_blocks:\n                # we've received this block now\n                del self.blocks_to_ack_and_nack[i]\n                continue\n\n            # give up on packet if we have seen one with a much higher\n            # number:\n            if self.block_cnt - block > 200 or \\\n               now - first_sent > 60:\n                print(\"DFLogger: Abandoning block (%d)\" % (block,))\n                del self.blocks_to_ack_and_nack[i]\n                del self.missing_blocks[block]\n                self.abandoned += 1\n                continue\n\n            i += 1\n            # only send each nack every-so-often:\n            if last_sent is not None:\n                if now - last_sent < 0.1:\n                    continue\n\n            print(\"DFLogger: NACKing block (%d)\" % (block,))\n            self.master.mav.remote_log_block_status_send(block,status)\n            blocks_sent += 1\n            stuff[4] = now", "response": "Send packets to UAV in idle loop"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mavlink_packet(self, m):\n        '''handle REMOTE_LOG_DATA_BLOCK packets'''\n        now = time.time()\n        if m.get_type() == 'REMOTE_LOG_DATA_BLOCK':\n            if self.stopped:\n                # send a stop packet every second until the other end gets the idea:\n                if now - self.time_last_stop_packet_sent > 1:\n                    if self.log_settings.verbose:\n                        print(\"DFLogger: Sending stop packet\")\n                    self.master.mav.remote_log_block_status_send(mavutil.mavlink.MAV_REMOTE_LOG_DATA_BLOCK_STOP,1)\n                return\n\n#            if random.random() < 0.1: # drop 1 packet in 10\n#                return\n\n\n            if not self.new_log_started:\n                if self.log_settings.verbose:\n                    print(\"DFLogger: Received data packet - starting new log\")\n                self.start_new_log()\n                self.new_log_started = True\n            if self.new_log_started == True:\n                size = m.block_size\n                data = ''.join(str(chr(x)) for x in m.data[:size])\n                ofs = size*(m.block_cnt)\n                self.logfile.seek(ofs)\n                self.logfile.write(data)\n\n                if m.block_cnt in self.missing_blocks:\n                    if self.log_settings.verbose:\n                        print(\"DFLogger: Received missing block: %d\" % (m.block_cnt,))\n                    del self.missing_blocks[m.block_cnt]\n                    self.missing_found += 1\n                    self.blocks_to_ack_and_nack.append([self.master,m.block_cnt,1,now,None])\n                    self.acking_blocks[m.block_cnt] = 1\n#                    print(\"DFLogger: missing blocks: %s\" % (str(self.missing_blocks),))\n                else:\n                    # ACK the block we just got:\n                    if m.block_cnt in self.acking_blocks:\n                        # already acking this one; we probably sent\n                        # multiple nacks and received this one\n                        # multiple times\n                        pass\n                    else:\n                        self.blocks_to_ack_and_nack.append([self.master,m.block_cnt,1,now,None])\n                        self.acking_blocks[m.block_cnt] = 1\n                        # NACK any blocks we haven't seen and should have:\n                        if(m.block_cnt - self.block_cnt > 1):\n                            for block in range(self.block_cnt+1, m.block_cnt):\n                                if block not in self.missing_blocks and \\\n                                   block not in self.acking_blocks:\n                                    self.missing_blocks[block] = 1\n                                    if self.log_settings.verbose:\n                                        print (\"DFLogger: setting %d for nacking\" % (block,))\n                                    self.blocks_to_ack_and_nack.append([self.master,block,0,now,None])\n                        #print \"\\nmissed blocks: \",self.missing_blocks\n                    if self.block_cnt < m.block_cnt:\n                        self.block_cnt = m.block_cnt\n                self.download += size\n        elif not self.new_log_started and not self.stopped:\n            # send a start packet every second until the other end gets the idea:\n            if now - self.time_last_start_packet_sent > 1:\n                if self.log_settings.verbose:\n                    print(\"DFLogger: Sending start packet\")\n                self.master.mav.remote_log_block_status_send(mavutil.mavlink.MAV_REMOTE_LOG_DATA_BLOCK_START,1)\n                self.time_last_start_packet_sent = now", "response": "handle incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstates of APM memory brkval : heap top (uint16_t) freemem : free memory (uint16_t)", "response": "def meminfo_send(self, brkval, freemem, force_mavlink1=False):\n                '''\n                state of APM memory\n\n                brkval                    : heap top (uint16_t)\n                freemem                   : free memory (uint16_t)\n\n                '''\n                return self.send(self.meminfo_encode(brkval, freemem), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn true if m is older than lastm by timestamp", "response": "def older_message(m, lastm):\n    '''return true if m is older than lastm by timestamp'''\n    atts = {'time_boot_ms' : 1.0e-3,\n            'time_unix_usec' : 1.0e-6,\n            'time_usec' : 1.0e-6}\n    for a in atts.keys():\n        if hasattr(m, a):\n            mul = atts[a]\n            t1 = m.getattr(a) * mul\n            t2 = lastm.getattr(a) * mul\n            if t2 >= t1 and t2 - t1 < 60:\n                return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles an incoming mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        if m.get_type() == 'LOG_ENTRY':\n            self.handle_log_entry(m)\n        elif m.get_type() == 'LOG_DATA':\n            self.handle_log_data(m)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles incoming log entry", "response": "def handle_log_entry(self, m):\n        '''handling incoming log entry'''\n        if m.time_utc == 0:\n            tstring = ''\n        else:\n            tstring = time.ctime(m.time_utc)\n        self.entries[m.id] = m\n        print(\"Log %u  numLogs %u lastLog %u size %u %s\" % (m.id, m.num_logs, m.last_log_num, m.size, tstring))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle_log_data(self, m):\n        '''handling incoming log data'''\n        if self.download_file is None:\n            return\n        # lose some data\n        # import random\n        # if random.uniform(0,1) < 0.05:\n        #    print('dropping ', str(m))\n        #    return\n        if m.ofs != self.download_ofs:\n            self.download_file.seek(m.ofs)\n            self.download_ofs = m.ofs\n        if m.count != 0:\n            data = m.data[:m.count]\n            s = ''.join(str(chr(x)) for x in data)\n            self.download_file.write(s)\n            self.download_set.add(m.ofs // 90)\n            self.download_ofs += m.count\n        self.download_last_timestamp = time.time()\n        if m.count == 0 or (m.count < 90 and len(self.download_set) == 1 + (m.ofs // 90)):\n            dt = time.time() - self.download_start\n            self.download_file.close()\n            size = os.path.getsize(self.download_filename)\n            speed = size / (1000.0 * dt)\n            print(\"Finished downloading %s (%u bytes %u seconds, %.1f kbyte/sec %u retries)\" % (\n                self.download_filename,\n                size,\n                dt, speed,\n                self.retries))\n            self.download_file = None\n            self.download_filename = None\n            self.download_set = set()", "response": "handling incoming log data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles missing incoming log data", "response": "def handle_log_data_missing(self):\n        '''handling missing incoming log data'''\n        if len(self.download_set) == 0:\n            return\n        highest = max(self.download_set)\n        diff = set(range(highest)).difference(self.download_set)\n        if len(diff) == 0:\n            self.master.mav.log_request_data_send(self.target_system,\n                                                       self.target_component,\n                                                       self.download_lognum, (1 + highest) * 90, 0xffffffff)\n            self.retries += 1\n        else:\n            num_requests = 0\n            while num_requests < 20:\n                start = min(diff)\n                diff.remove(start)\n                end = start\n                while end + 1 in diff:\n                    end += 1\n                    diff.remove(end)\n                self.master.mav.log_request_data_send(self.target_system,\n                                                           self.target_component,\n                                                           self.download_lognum, start * 90, (end + 1 - start) * 90)\n                num_requests += 1\n                self.retries += 1\n                if len(diff) == 0:\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndownload a log file", "response": "def log_download(self, log_num, filename):\n        '''download a log file'''\n        print(\"Downloading log %u as %s\" % (log_num, filename))\n        self.download_lognum = log_num\n        self.download_file = open(filename, \"wb\")\n        self.master.mav.log_request_data_send(self.target_system,\n                                                   self.target_component,\n                                                   log_num, 0, 0xFFFFFFFF)\n        self.download_filename = filename\n        self.download_set = set()\n        self.download_start = time.time()\n        self.download_last_timestamp = time.time()\n        self.download_ofs = 0\n        self.retries = 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles missing log data", "response": "def idle_task(self):\n        '''handle missing log data'''\n        if self.download_last_timestamp is not None and time.time() - self.download_last_timestamp > 0.7:\n            self.download_last_timestamp = time.time()\n            self.handle_log_data_missing()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncomplete mavproxy module names", "response": "def complete_modules(text):\n    '''complete mavproxy module names'''\n    import MAVProxy.modules, pkgutil\n    modlist = [x[1] for x in pkgutil.iter_modules(MAVProxy.modules.__path__)]\n    ret = []\n    loaded = set(complete_loadedmodules(''))\n    for m in modlist:\n        if not m.startswith(\"mavproxy_\"):\n            continue\n        name = m[9:]\n        if not name in loaded:\n            ret.append(name)\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef complete_variable(text):\n    '''complete a MAVLink variable'''\n    if text.find('.') != -1:\n        var = text.split('.')[0]\n        if var in rline_mpstate.status.msgs:\n            ret = []\n            for f in rline_mpstate.status.msgs[var].get_fieldnames():\n                ret.append(var + '.' + f)\n            return ret\n        return []\n    return rline_mpstate.status.msgs.keys()", "response": "complete a MAVLink variable"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexpands one rule component", "response": "def rule_expand(component, text):\n    '''expand one rule component'''\n    global rline_mpstate\n    if component[0] == '<' and component[-1] == '>':\n        return component[1:-1].split('|')\n    if component in rline_mpstate.completion_functions:\n        return rline_mpstate.completion_functions[component](text)\n    return [component]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rule_match(component, cmd):\n    '''see if one rule component matches'''\n    if component == cmd:\n        return True\n    expanded = rule_expand(component, cmd)\n    if cmd in expanded:\n        return True\n    return False", "response": "see if one rule component matches cmd"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef complete_rules(rules, cmd):\n    '''complete using a list of completion rules'''\n    if not isinstance(rules, list):\n        rules = [rules]\n    ret = []\n    for r in rules:\n        ret += complete_rule(r, cmd)\n    return ret", "response": "complete using a list of completion rules"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntranslates from ROS LaserScan to JderobotTypes LaserData.", "response": "def laserScan2LaserData(scan):\n    '''\n    Translates from ROS LaserScan to JderobotTypes LaserData. \n\n    @param scan: ROS LaserScan to translate\n\n    @type scan: LaserScan\n\n    @return a LaserData translated from scan\n\n    '''\n    laser = LaserData()\n    laser.values = scan.ranges\n    ''' \n          ROS Angle Map      JdeRobot Angle Map\n                0                  PI/2\n                |                   |\n                |                   |\n       PI/2 --------- -PI/2  PI --------- 0\n                |                   |\n                |                   |\n    '''\n    laser.minAngle = scan.angle_min  + PI/2\n    laser.maxAngle = scan.angle_max  + PI/2\n    laser.maxRange = scan.range_max\n    laser.minRange = scan.range_min\n    laser.timeStamp = scan.header.stamp.secs + (scan.header.stamp.nsecs *1e-9)\n    return laser"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __callback (self, scan):\n        '''\n        Callback function to receive and save Laser Scans. \n\n        @param scan: ROS LaserScan received\n        \n        @type scan: LaserScan\n\n        '''\n        laser = laserScan2LaserData(scan)\n\n        self.lock.acquire()\n        self.data = laser\n        self.lock.release()", "response": "Callback function to receive and save Laser Scans. \n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstarting (Subscribes) the client.", "response": "def start (self):\n        '''\n        Starts (Subscribes) the client.\n\n        '''\n        self.sub = rospy.Subscriber(self.topic, LaserScan, self.__callback)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning last LaserData. Returns last LaserData. Returns last LaserData. Returns last LaserData. Returns last LaserData.", "response": "def getLaserData(self):\n        '''\n        Returns last LaserData. \n\n        @return last JdeRobotTypes LaserData saved\n\n        '''\n        self.lock.acquire()\n        laser = self.data\n        self.lock.release()\n        \n        return laser"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a point to the kml file", "response": "def add_to_linestring(position_data, kml_linestring):\n    '''add a point to the kml file'''\n    global kml\n\n    # add altitude offset\n    position_data[2] += float(args.aoff)\n    kml_linestring.coords.addcoordinates([position_data])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding some data to the kml_linestrings list", "response": "def add_data(t, msg, msg_types, vars, fields, field_types, position_field_type):\n    '''add some data'''\n\n    mtype = msg.get_type()\n    if mtype not in msg_types:\n        return\n\n    for i in range(0, len(fields)):\n        if mtype not in field_types[i]:\n            continue\n        f = fields[i]\n        v = mavutil.evaluate_expression(f, vars)\n        if v is None:\n            continue\n\n        # Check if we have position or state information\n        if f == mainstate_field:\n            # Handle main state information\n            # add_data.mainstate_current >= 0 : avoid starting a new linestring\n            # when mainstate comes after the first position data in the log\n            if (v != add_data.mainstate_current and\n                    add_data.mainstate_current >= 0):\n                add_data.new_linestring = True\n            add_data.mainstate_current = v\n        else:\n            # Handle position information\n            # make sure lon, lat, alt is saved in the correct order in\n            # position_data (the same as in position_field_types)\n            add_data.position_data[i] = v\n\n    # check if we have a full gps measurement\n    gps_measurement_ready = True\n    for v in add_data.position_data:\n        if v is None:\n            gps_measurement_ready = False\n    if not gps_measurement_ready:\n        return\n\n    # if new line string is needed (because of state change): add previous\n    # linestring to kml_linestrings list, add a new linestring to the kml\n    # multigeometry and append to the new linestring\n    # else: append to current linestring\n    if add_data.new_linestring:\n        if add_data.current_kml_linestring is not None:\n            kml_linestrings.append(add_data.current_kml_linestring)\n\n        name = \"\".join([args.source, \":\", str(add_data.mainstate_current)])\n        add_data.current_kml_linestring = \\\n            kml.newlinestring(name=name, altitudemode='absolute')\n\n        # set rendering options\n        if args.extrude:\n            add_data.current_kml_linestring.extrude = 1\n        add_data.current_kml_linestring.style.linestyle.color = \\\n            colors[max([add_data.mainstate_current, 0])]\n\n        add_data.new_linestring = False\n\n        add_to_linestring(add_data.position_data,\n                      add_data.current_kml_linestring)\n        add_data.last_time = msg._timestamp\n\n    else:\n        if (msg._timestamp - add_data.last_time) > 0.1:\n            add_to_linestring(add_data.position_data,\n                      add_data.current_kml_linestring)\n            add_data.last_time = msg._timestamp\n\n    # reset position_data\n    add_data.position_data = [None for n in position_field_type]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nattempting to detect whether APM or PX4 attributes names are in use'''", "response": "def sniff_field_spelling(mlog, source):\n    '''attempt to detect whether APM or PX4 attributes names are in use'''\n    position_field_type_default = position_field_types[0] # Default to PX4 spelling\n    \n    msg = mlog.recv_match(source)\n    mlog._rewind() # Unfortunately it's either call this or return a mutated object\n    \n    position_field_selection = [spelling for spelling in position_field_types if hasattr(msg, spelling[0])]\n\n    return position_field_selection[0] if position_field_selection else position_field_type_default"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds new link to master", "response": "def link_add(self, device):\n        '''add new link'''\n        try:\n            print(\"Connect %s source_system=%d\" % (device, self.settings.source_system))\n            conn = mavutil.mavlink_connection(device, autoreconnect=True,\n                                              source_system=self.settings.source_system,\n                                              baud=self.settings.baudrate)\n            conn.mav.srcComponent = self.settings.source_component\n        except Exception as msg:\n            print(\"Failed to connect to %s : %s\" % (device, msg))\n            return False\n        if self.settings.rtscts:\n            conn.set_rtscts(True)\n        conn.linknum = len(self.mpstate.mav_master)\n        conn.mav.set_callback(self.master_callback, conn)\n        if hasattr(conn.mav, 'set_send_callback'):\n            conn.mav.set_send_callback(self.master_send_callback, conn)\n        conn.linknum = len(self.mpstate.mav_master)\n        conn.linkerror = False\n        conn.link_delayed = False\n        conn.last_heartbeat = 0\n        conn.last_message = 0\n        conn.highest_msec = 0\n        self.mpstate.mav_master.append(conn)\n        self.status.counters['MasterIn'].append(0)\n        try:\n            mp_util.child_fd_list_add(conn.port.fileno())\n        except Exception:\n            pass\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef master_callback(self, m, master):\n        '''process mavlink message m on master, sending any messages to recipients'''\n\n        # see if it is handled by a specialised sysid connection\n        sysid = m.get_srcSystem()\n        if sysid in self.mpstate.sysid_outputs:\n            self.mpstate.sysid_outputs[sysid].write(m.get_msgbuf())\n            return\n\n        if getattr(m, '_timestamp', None) is None:\n            master.post_message(m)\n        self.status.counters['MasterIn'][master.linknum] += 1\n\n        mtype = m.get_type()\n\n        # and log them\n        if mtype not in dataPackets and self.mpstate.logqueue:\n            # put link number in bottom 2 bits, so we can analyse packet\n            # delay in saved logs\n            usec = self.get_usec()\n            usec = (usec & ~3) | master.linknum\n            self.mpstate.logqueue.put(str(struct.pack('>Q', usec) + m.get_msgbuf()))\n\n        # keep the last message of each type around\n        self.status.msgs[m.get_type()] = m\n        if not m.get_type() in self.status.msg_count:\n            self.status.msg_count[m.get_type()] = 0\n        self.status.msg_count[m.get_type()] += 1\n\n        if m.get_srcComponent() == mavutil.mavlink.MAV_COMP_ID_GIMBAL and m.get_type() == 'HEARTBEAT':\n            # silence gimbal heartbeat packets for now\n            return\n\n        if getattr(m, 'time_boot_ms', None) is not None:\n            # update link_delayed attribute\n            self.handle_msec_timestamp(m, master)\n\n        if mtype in activityPackets:\n            if master.linkerror:\n                master.linkerror = False\n                self.say(\"link %u OK\" % (master.linknum+1))\n            self.status.last_message = time.time()\n            master.last_message = self.status.last_message\n\n        if master.link_delayed:\n            # don't process delayed packets that cause double reporting\n            if mtype in delayedPackets:\n                return\n\n        if mtype == 'HEARTBEAT' and m.get_srcSystem() != 255:\n            if self.settings.target_system == 0 and self.settings.target_system != m.get_srcSystem():\n                self.settings.target_system = m.get_srcSystem()\n                self.say(\"online system %u\" % self.settings.target_system,'message')\n\n            if self.status.heartbeat_error:\n                self.status.heartbeat_error = False\n                self.say(\"heartbeat OK\")\n            if master.linkerror:\n                master.linkerror = False\n                self.say(\"link %u OK\" % (master.linknum+1))\n\n            self.status.last_heartbeat = time.time()\n            master.last_heartbeat = self.status.last_heartbeat\n\n            armed = self.master.motors_armed()\n            if armed != self.status.armed:\n                self.status.armed = armed\n                if armed:\n                    self.say(\"ARMED\")\n                else:\n                    self.say(\"DISARMED\")\n\n            if master.flightmode != self.status.flightmode and time.time() > self.status.last_mode_announce + 2:\n                self.status.flightmode = master.flightmode\n                self.status.last_mode_announce = time.time()\n                if self.mpstate.functions.input_handler is None:\n                    self.mpstate.rl.set_prompt(self.status.flightmode + \"> \")\n                self.say(\"Mode \" + self.status.flightmode)\n\n            if m.type == mavutil.mavlink.MAV_TYPE_FIXED_WING:\n                self.mpstate.vehicle_type = 'plane'\n                self.mpstate.vehicle_name = 'ArduPlane'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_GROUND_ROVER,\n                            mavutil.mavlink.MAV_TYPE_SURFACE_BOAT,\n                            mavutil.mavlink.MAV_TYPE_SUBMARINE]:\n                self.mpstate.vehicle_type = 'rover'\n                self.mpstate.vehicle_name = 'APMrover2'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_QUADROTOR,\n                            mavutil.mavlink.MAV_TYPE_COAXIAL,\n                            mavutil.mavlink.MAV_TYPE_HEXAROTOR,\n                            mavutil.mavlink.MAV_TYPE_OCTOROTOR,\n                            mavutil.mavlink.MAV_TYPE_TRICOPTER,\n                            mavutil.mavlink.MAV_TYPE_HELICOPTER]:\n                self.mpstate.vehicle_type = 'copter'\n                self.mpstate.vehicle_name = 'ArduCopter'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_ANTENNA_TRACKER]:\n                self.mpstate.vehicle_type = 'antenna'\n                self.mpstate.vehicle_name = 'AntennaTracker'\n        \n        elif mtype == 'STATUSTEXT':\n            if m.text != self.status.last_apm_msg or time.time() > self.status.last_apm_msg_time+2:\n                self.mpstate.console.writeln(\"APM: %s\" % m.text, bg='red')\n                self.status.last_apm_msg = m.text\n                self.status.last_apm_msg_time = time.time()\n\n        elif mtype == \"VFR_HUD\":\n            have_gps_lock = False\n            if 'GPS_RAW' in self.status.msgs and self.status.msgs['GPS_RAW'].fix_type == 2:\n                have_gps_lock = True\n            elif 'GPS_RAW_INT' in self.status.msgs and self.status.msgs['GPS_RAW_INT'].fix_type == 3:\n                have_gps_lock = True\n            if have_gps_lock and not self.status.have_gps_lock and m.alt != 0:\n                self.say(\"GPS lock at %u meters\" % m.alt, priority='notification')\n                self.status.have_gps_lock = True\n\n        elif mtype == \"GPS_RAW\":\n            if self.status.have_gps_lock:\n                if m.fix_type != 2 and not self.status.lost_gps_lock and (time.time() - self.status.last_gps_lock) > 3:\n                    self.say(\"GPS fix lost\")\n                    self.status.lost_gps_lock = True\n                if m.fix_type == 2 and self.status.lost_gps_lock:\n                    self.say(\"GPS OK\")\n                    self.status.lost_gps_lock = False\n                if m.fix_type == 2:\n                    self.status.last_gps_lock = time.time()\n\n        elif mtype == \"GPS_RAW_INT\":\n            if self.status.have_gps_lock:\n                if m.fix_type < 3 and not self.status.lost_gps_lock and (time.time() - self.status.last_gps_lock) > 3:\n                    self.say(\"GPS fix lost\")\n                    self.status.lost_gps_lock = True\n                if m.fix_type >= 3 and self.status.lost_gps_lock:\n                    self.say(\"GPS OK\")\n                    self.status.lost_gps_lock = False\n                if m.fix_type >= 3:\n                    self.status.last_gps_lock = time.time()\n\n        elif mtype == \"NAV_CONTROLLER_OUTPUT\" and self.status.flightmode == \"AUTO\" and self.mpstate.settings.distreadout:\n            rounded_dist = int(m.wp_dist/self.mpstate.settings.distreadout)*self.mpstate.settings.distreadout\n            if math.fabs(rounded_dist - self.status.last_distance_announce) >= self.mpstate.settings.distreadout:\n                if rounded_dist != 0:\n                    self.say(\"%u\" % rounded_dist, priority=\"progress\")\n            self.status.last_distance_announce = rounded_dist\n    \n        elif mtype == \"GLOBAL_POSITION_INT\":\n            self.report_altitude(m.relative_alt*0.001)\n\n        elif mtype == \"COMPASSMOT_STATUS\":\n            print(m)\n\n        elif mtype == \"BAD_DATA\":\n            if self.mpstate.settings.shownoise and mavutil.all_printable(m.data):\n                self.mpstate.console.write(str(m.data), bg='red')\n        elif mtype in [ \"COMMAND_ACK\", \"MISSION_ACK\" ]:\n            self.mpstate.console.writeln(\"Got MAVLink msg: %s\" % m)\n\n            if mtype == \"COMMAND_ACK\" and m.command == mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION:\n                if m.result == mavutil.mavlink.MAV_RESULT_ACCEPTED:\n                    self.say(\"Calibrated\")\n        else:\n            #self.mpstate.console.writeln(\"Got MAVLink msg: %s\" % m)\n            pass\n\n        if self.status.watch is not None:\n            if fnmatch.fnmatch(m.get_type().upper(), self.status.watch.upper()):\n                self.mpstate.console.writeln('< '+str(m))\n\n        # don't pass along bad data\n        if mtype != 'BAD_DATA':\n            # pass messages along to listeners, except for REQUEST_DATA_STREAM, which\n            # would lead a conflict in stream rate setting between mavproxy and the other\n            # GCS\n            if self.mpstate.settings.mavfwd_rate or mtype != 'REQUEST_DATA_STREAM':\n                if not mtype in self.no_fwd_types:\n                    for r in self.mpstate.mav_outputs:\n                        r.write(m.get_msgbuf())\n\n            # pass to modules\n            for (mod,pm) in self.mpstate.modules:\n                if not hasattr(mod, 'mavlink_packet'):\n                    continue\n                try:\n                    mod.mavlink_packet(m)\n                except Exception as msg:\n                    if self.mpstate.settings.moddebug == 1:\n                        print(msg)\n                    elif self.mpstate.settings.moddebug > 1:\n                        exc_type, exc_value, exc_traceback = sys.exc_info()\n                        traceback.print_exception(exc_type, exc_value, exc_traceback,\n                                                  limit=2, file=sys.stdout)", "response": "process mavlink message m on master sending any messages to recipients"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write(self, text, fg='black', bg='white'):\n        '''write to the console'''\n        if isinstance(text, str):\n            sys.stdout.write(text)\n        else:\n            sys.stdout.write(str(text))\n        sys.stdout.flush()\n        if self.udp.connected():\n            self.udp.writeln(text)\n        if self.tcp.connected():\n            self.tcp.writeln(text)", "response": "write to the console"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite to the console with linefeed", "response": "def writeln(self, text, fg='black', bg='white'):\n        '''write to the console with linefeed'''\n        if not isinstance(text, str):\n            text = str(text)\n        self.write(text + '\\n', fg=fg, bg=bg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match_extension(f):\n    '''see if the path matches a extension'''\n    (root,ext) = os.path.splitext(f)\n    return ext.lower() in extensions", "response": "see if the path matches a extension"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading an icon from the data directory", "response": "def mp_icon(filename):\n        '''load an icon from the data directory'''\n        # we have to jump through a lot of hoops to get an OpenCV image\n        # when we may be in a package zip file\n        try:\n                import pkg_resources\n                name = __name__\n                if name == \"__main__\":\n                        name = \"MAVProxy.modules.mavproxy_map.mp_tile\"\n                raw = pkg_resources.resource_stream(name, \"data/%s\" % filename).read()\n        except Exception:\n                raw = open(os.path.join(__file__, 'data', filename)).read()\n        imagefiledata = cv.CreateMatHeader(1, len(raw), cv.CV_8UC1)\n        cv.SetData(imagefiledata, raw, len(raw))\n        img = cv.DecodeImage(imagefiledata, cv.CV_LOAD_IMAGE_COLOR)\n        return img"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning lat lon within a tile given offsetx offsety", "response": "def coord(self, offset=(0,0)):\n\t\t'''return lat,lon within a tile given (offsetx,offsety)'''\n\t\t(tilex, tiley) = self.tile\n\t\t(offsetx, offsety) = offset\n\t\tworld_tiles = 1<<self.zoom\n\t\tx = ( tilex + 1.0*offsetx/TILES_WIDTH ) / (world_tiles/2.) - 1\n\t\ty = ( tiley + 1.0*offsety/TILES_HEIGHT) / (world_tiles/2.) - 1\n\t\tlon = x * 180.0\n\t\ty = math.exp(-y*2*math.pi)\n\t\te = (y-1)/(y+1)\n\t\tlat = 180.0/math.pi * math.asin(e)\n\t\treturn (lat, lon)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef size(self):\n\t\t'''return tile size as (width,height) in meters'''\n\t\t(lat1, lon1) = self.coord((0,0))\n\t\t(lat2, lon2) = self.coord((TILES_WIDTH,0))\n\t\twidth = mp_util.gps_distance(lat1, lon1, lat2, lon2)\n\t\t(lat2, lon2) = self.coord((0,TILES_HEIGHT))\n\t\theight = mp_util.gps_distance(lat1, lon1, lat2, lon2)\n\t\treturn (width,height)", "response": "return tile size as ( width height ) in meters"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef distance(self, lat, lon):\n\t\t'''distance of this tile from a given lat/lon'''\n\t\t(tlat, tlon) = self.coord((TILES_WIDTH/2,TILES_HEIGHT/2))\n\t\treturn mp_util.gps_distance(lat, lon, tlat, tlon)", "response": "distance of this tile from a given lat / lon"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn relative path of tile image", "response": "def path(self):\n\t\t'''return relative path of tile image'''\n\t\t(x, y) = self.tile\n\t\treturn os.path.join('%u' % self.zoom,\n\t\t\t\t    '%u' % y,\n\t\t\t\t    '%u.img' % x)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef url(self, service):\n\t\t'''return URL for a tile'''\n\t\tif service not in TILE_SERVICES:\n\t\t\traise TileException('unknown tile service %s' % service)\n\t\turl = string.Template(TILE_SERVICES[service])\n\t\t(x,y) = self.tile\n\t\ttile_info = TileServiceInfo(x, y, self.zoom)\n\t\treturn url.substitute(tile_info)", "response": "return URL for a tile"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting lat lon zoom to TileInfo", "response": "def coord_to_tile(self, lat, lon, zoom):\n\t\t'''convert lat/lon/zoom to a TileInfo'''\n\t\tworld_tiles = 1<<zoom\n\t\tx = world_tiles / 360.0 * (lon + 180.0)\n\t\ttiles_pre_radian = world_tiles / (2 * math.pi)\n\t\te = math.sin(lat * (1/180.*math.pi))\n\t\ty = world_tiles/2 + 0.5*math.log((1+e)/(1-e)) * (-tiles_pre_radian)\n\t\toffsetx = int((x - int(x)) * TILES_WIDTH)\n\t\toffsety = int((y - int(y)) * TILES_HEIGHT)\n\t\treturn TileInfo((int(x) % world_tiles, int(y) % world_tiles), zoom, self.service, offset=(offsetx, offsety))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns full path to a tile", "response": "def tile_to_path(self, tile):\n\t\t'''return full path to a tile'''\n\t\treturn os.path.join(self.cache_path, self.service, tile.path())"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the tile path that covers a latitude and longitude at a specified zoom level", "response": "def coord_to_tilepath(self, lat, lon, zoom):\n\t\t'''return the tile ID that covers a latitude/longitude at\n\t\ta specified zoom level\n\t\t'''\n\t\ttile = self.coord_to_tile(lat, lon, zoom)\n\t\treturn self.tile_to_path(tile)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstarting the downloader thread", "response": "def start_download_thread(self):\n\t\t'''start the downloader'''\n\t\tif self._download_thread:\n\t\t\treturn\n\t\tt = threading.Thread(target=self.downloader)\n\t\tt.daemon = True\n\t\tself._download_thread = t\n\t\tt.start()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload a lower resolution tile from cache to fill in a map while waiting for a higher resolution tile", "response": "def load_tile_lowres(self, tile):\n\t\t'''load a lower resolution tile from cache to fill in a\n\t\tmap while waiting for a higher resolution tile'''\n\t\tif tile.zoom == self.min_zoom:\n\t\t\treturn None\n\n\t\t# find the equivalent lower res tile\n\t\t(lat,lon) = tile.coord()\n\n\t\twidth2 = TILES_WIDTH\n\t\theight2 = TILES_HEIGHT\n\n\t\tfor zoom2 in range(tile.zoom-1, self.min_zoom-1, -1):\n\t\t\twidth2 /= 2\n\t\t\theight2 /= 2\n\n\t\t\tif width2 == 0 or height2 == 0:\n\t\t\t\tbreak\n\n\t\t\ttile_info = self.coord_to_tile(lat, lon, zoom2)\n\n\t\t\t# see if its in the tile cache\n\t\t\tkey = tile_info.key()\n\t\t\tif key in self._tile_cache:\n\t\t\t\timg = self._tile_cache[key]\n\t\t\t\tif img == self._unavailable:\n\t\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tpath = self.tile_to_path(tile_info)\n\t\t\t\ttry:\n\t\t\t\t\timg = cv.LoadImage(path)\n\t\t\t\t\t# add it to the tile cache\n\t\t\t\t\tself._tile_cache[key] = img\n\t\t\t\t\twhile len(self._tile_cache) > self.cache_size:\n\t\t\t\t\t\tself._tile_cache.popitem(0)\n\t\t\t\texcept IOError as e:\n\t\t\t\t\tcontinue\n\n\t\t\t# copy out the quadrant we want\n\t\t\tavailx = min(TILES_WIDTH - tile_info.offsetx, width2)\n\t\t\tavaily = min(TILES_HEIGHT - tile_info.offsety, height2)\n\t\t\tif availx != width2 or availy != height2:\n\t\t\t\tcontinue\n\t\t\tcv.SetImageROI(img, (tile_info.offsetx, tile_info.offsety, width2, height2))\n\t\t\timg2 = cv.CreateImage((width2,height2), 8, 3)\n\t\t\ttry:\n\t\t\t\tcv.Copy(img, img2)\n\t\t\texcept Exception:\n\t\t\t\tcontinue\n\t\t\tcv.ResetImageROI(img)\n\n\t\t\t# and scale it\n\t\t\tscaled = cv.CreateImage((TILES_WIDTH, TILES_HEIGHT), 8, 3)\n\t\t\tcv.Resize(img2, scaled)\n\t\t\t#cv.Rectangle(scaled, (0,0), (255,255), (0,255,0), 1)\n\t\t\treturn scaled\n\t\treturn None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a tile from cache or tile server", "response": "def load_tile(self, tile):\n\t\t'''load a tile from cache or tile server'''\n\n\t\t# see if its in the tile cache\n\t\tkey = tile.key()\n\t\tif key in self._tile_cache:\n\t\t\timg = self._tile_cache[key]\n\t\t\tif img == self._unavailable:\n\t\t\t\timg = self.load_tile_lowres(tile)\n\t\t\t\tif img is None:\n\t\t\t\t\timg = self._unavailable\n\t\t\t\treturn img\n\n\n\t\tpath = self.tile_to_path(tile)\n\t\ttry:\n\t\t\tret = cv.LoadImage(path)\n\t\t\t# if it is an old tile, then try to refresh\n\t\t\tif os.path.getmtime(path) + self.refresh_age < time.time():\n\t\t\t\ttry:\n\t\t\t\t\tself._download_pending[key].refresh_time()\n\t\t\t\texcept Exception:\n\t\t\t\t\tself._download_pending[key] = tile\n\t\t\t\t\tself.start_download_thread()\n\t\t\t# add it to the tile cache\n\t\t\tself._tile_cache[key] = ret\n\t\t\twhile len(self._tile_cache) > self.cache_size:\n\t\t\t\tself._tile_cache.popitem(0)\n\t\t\treturn ret\n\t\texcept IOError as e:\n\t\t\t# windows gives errno 0 for some versions of python, treat that as ENOENT\n\t\t\t# and try a download\n\t\t\tif not e.errno in [errno.ENOENT,0]:\n\t\t\t\traise\n\t\t\tpass\n\t\tif not self.download:\n\t\t\timg = self.load_tile_lowres(tile)\n\t\t\tif img is None:\n\t\t\t\timg = self._unavailable\n\t\t\treturn img\n\n\t\ttry:\n\t\t\tself._download_pending[key].refresh_time()\n\t\texcept Exception:\n\t\t\tself._download_pending[key] = tile\n\t\tself.start_download_thread()\n\n\t\timg = self.load_tile_lowres(tile)\n\t\tif img is None:\n\t\t\timg = self._loading\n\t\treturn img"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a scaled tile", "response": "def scaled_tile(self, tile):\n\t\t'''return a scaled tile'''\n\t\twidth = int(TILES_WIDTH / tile.scale)\n\t\theight = int(TILES_HEIGHT / tile.scale)\n\t\tscaled_tile = cv.CreateImage((width,height), 8, 3)\n\t\tfull_tile = self.load_tile(tile)\n\t\tcv.Resize(full_tile, scaled_tile)\n\t\treturn scaled_tile"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the coordinates of a pixel in an area image", "response": "def coord_from_area(self, x, y, lat, lon, width, ground_width):\n\t\t'''return (lat,lon) for a pixel in an area image'''\n\n\t\tpixel_width = ground_width / float(width)\n\t\tdx = x * pixel_width\n\t\tdy = y * pixel_width\n\n\t\treturn mp_util.gps_offset(lat, lon, dx, -dy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef coord_to_pixel(self, lat, lon, width, ground_width, lat2, lon2):\n\t\t'''return pixel coordinate (px,py) for position (lat2,lon2)\n\t\tin an area image. Note that the results are relative to top,left\n\t\tand may be outside the image'''\n\t\tpixel_width = ground_width / float(width)\n\n\t\tif lat is None or lon is None or lat2 is None or lon2 is None:\n\t\t\treturn (0,0)\n\n\t\tdx = mp_util.gps_distance(lat, lon, lat, lon2)\n\t\tif lon2 < lon:\n\t\t\tdx = -dx\n\t\tdy = mp_util.gps_distance(lat, lon, lat2, lon)\n\t\tif lat2 > lat:\n\t\t\tdy = -dy\n\n\t\tdx /= pixel_width\n\t\tdy /= pixel_width\n\t\treturn (int(dx), int(dy))", "response": "return pixel coordinate for a given latitude and longitude"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef area_to_tile_list(self, lat, lon, width, height, ground_width, zoom=None):\n\t\t'''return a list of TileInfoScaled objects needed for\n\t\tan area of land, with ground_width in meters, and\n\t\twidth/height in pixels.\n\n\t\tlat/lon is the top left corner. If unspecified, the\n\t\tzoom is automatically chosen to avoid having to grow\n\t\tthe tiles\n\t\t'''\n\n\t\tpixel_width = ground_width / float(width)\n\t\tground_height = ground_width * (height/(float(width)))\n\t\ttop_right = mp_util.gps_newpos(lat, lon, 90, ground_width)\n\t\tbottom_left = mp_util.gps_newpos(lat, lon, 180, ground_height)\n\t\tbottom_right = mp_util.gps_newpos(bottom_left[0], bottom_left[1], 90, ground_width)\n\n\t\t# choose a zoom level if not provided\n\t\tif zoom is None:\n\t\t\tzooms = range(self.min_zoom, self.max_zoom+1)\n\t\telse:\n\t\t\tzooms = [zoom]\n\t\tfor zoom in zooms:\n\t\t\ttile_min = self.coord_to_tile(lat, lon, zoom)\n\t\t\t(twidth,theight) = tile_min.size()\n\t\t\ttile_pixel_width = twidth / float(TILES_WIDTH)\n\t\t\tscale = pixel_width / tile_pixel_width\n\t\t\tif scale >= 1.0:\n\t\t\t\tbreak\n\n\t\tscaled_tile_width = int(TILES_WIDTH / scale)\n\t\tscaled_tile_height = int(TILES_HEIGHT / scale)\n\n\t\t# work out the bottom right tile\n\t\ttile_max = self.coord_to_tile(bottom_right[0], bottom_right[1], zoom)\n\n\t\tofsx = int(tile_min.offsetx / scale)\n\t\tofsy = int(tile_min.offsety / scale)\n\t\tsrcy = ofsy\n\t\tdsty = 0\n\n\t\tret = []\n\n\t\t# place the tiles\n\t\tfor y in range(tile_min.y, tile_max.y+1):\n\t\t\tsrcx = ofsx\n\t\t\tdstx = 0\n\t\t\tfor x in range(tile_min.x, tile_max.x+1):\n\t\t\t\tif dstx < width and dsty < height:\n\t\t\t\t\tret.append(TileInfoScaled((x,y), zoom, scale,\n                                                                  (srcx,srcy), (dstx,dsty), self.service))\n\t\t\t\tdstx += scaled_tile_width-srcx\n\t\t\t\tsrcx = 0\n\t\t\tdsty += scaled_tile_height-srcy\n\t\t\tsrcy = 0\n\t\treturn ret", "response": "return a list of TileInfoScaled objects needed for the area of land"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef area_to_image(self, lat, lon, width, height, ground_width, zoom=None, ordered=True):\n\t\t'''return an RGB image for an area of land, with ground_width\n\t\tin meters, and width/height in pixels.\n\n\t\tlat/lon is the top left corner. The zoom is automatically\n\t\tchosen to avoid having to grow the tiles'''\n\n\t\timg = cv.CreateImage((width,height),8,3)\n\n\t\ttlist = self.area_to_tile_list(lat, lon, width, height, ground_width, zoom)\n\n\t\t# order the display by distance from the middle, so the download happens\n\t\t# close to the middle of the image first\n\t\tif ordered:\n\t\t\t(midlat, midlon) = self.coord_from_area(width/2, height/2, lat, lon, width, ground_width)\n\t\t\ttlist.sort(key=lambda d: d.distance(midlat, midlon), reverse=True)\n\n\t\tfor t in tlist:\n\t\t\tscaled_tile = self.scaled_tile(t)\n\n\t\t\tw = min(width - t.dstx, scaled_tile.width - t.srcx)\n\t\t\th = min(height - t.dsty, scaled_tile.height - t.srcy)\n\t\t\tif w > 0 and h > 0:\n\t\t\t\tcv.SetImageROI(scaled_tile, (t.srcx, t.srcy, w, h))\n\t\t\t\tcv.SetImageROI(img, (t.dstx, t.dsty, w, h))\n\t\t\t\tcv.Copy(scaled_tile, img)\n\t\t\t\tcv.ResetImageROI(img)\n\t\t\t\tcv.ResetImageROI(scaled_tile)\n\n\t\t# return as an RGB image\n\t\tcv.CvtColor(img, img, cv.CV_BGR2RGB)\n\t\treturn img", "response": "return an RGB image for an area of land with ground_width in meters and width / height in pixels"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a command with a timeout.", "response": "def run_command(args, cwd = None, shell = False, timeout = None, env = None):\n    '''\n    Run a shell command with a timeout.\n    See http://stackoverflow.com/questions/1191374/subprocess-with-timeout\n    '''\n    from subprocess import PIPE, Popen\n    from StringIO import StringIO\n    import fcntl, os, signal\n    p = Popen(args, shell = shell, cwd = cwd, stdout = PIPE, stderr = PIPE, env = env)\n    tstart = time.time()\n    buf = StringIO()\n\n    # try to make it non-blocking\n    try:\n        fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)\n    except Exception:\n        pass\n\n    while True:\n        time.sleep(0.1)\n        retcode = p.poll()\n        try:\n            buf.write(p.stdout.read())\n        except Exception:\n            pass\n        if retcode is not None:\n            break\n        if timeout is not None and time.time() > tstart + timeout:\n            print(\"timeout in process %u\" % p.pid)\n            try: \n                os.kill(p.pid, signal.SIGKILL)\n            except OSError:\n                pass\n            p.wait()\n    return buf.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nestimating QNH pressure from GPS altitude and scaled pressure", "response": "def qnh_estimate(self):\n        '''estimate QNH pressure from GPS altitude and scaled pressure'''\n        alt_gps = self.master.field('GPS_RAW_INT', 'alt', 0) * 0.001\n        pressure2 = self.master.field('SCALED_PRESSURE', 'press_abs', 0)\n        ground_temp = self.get_mav_param('GND_TEMP', 21)\n        temp = ground_temp + 273.15\n        pressure1 = pressure2 / math.exp(math.log(1.0 - (alt_gps / (153.8462 * temp))) / 0.190259)\n        return pressure1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadjusting TRIM_PITCH_CD up by 5 degrees", "response": "def cmd_up(self, args):\n        '''adjust TRIM_PITCH_CD up by 5 degrees'''\n        if len(args) == 0:\n            adjust = 5.0\n        else:\n            adjust = float(args[0])\n        old_trim = self.get_mav_param('TRIM_PITCH_CD', None)\n        if old_trim is None:\n            print(\"Existing trim value unknown!\")\n            return\n        new_trim = int(old_trim + (adjust*100))\n        if math.fabs(new_trim - old_trim) > 1000:\n            print(\"Adjustment by %d too large (from %d to %d)\" % (adjust*100, old_trim, new_trim))\n            return\n        print(\"Adjusting TRIM_PITCH_CD from %d to %d\" % (old_trim, new_trim))\n        self.param_set('TRIM_PITCH_CD', new_trim)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrepeat a command at regular intervals", "response": "def cmd_repeat(self, args):\n        '''repeat a command at regular intervals'''\n        if len(args) == 0:\n            if len(self.repeats) == 0:\n                print(\"No repeats\")\n                return\n            for i in range(len(self.repeats)):\n                print(\"%u: %s\" % (i, self.repeats[i]))\n            return\n        if args[0] == 'add':\n            if len(args) < 3:\n                print(\"Usage: repeat add PERIOD CMD\")\n                return\n            self.repeats.append(RepeatCommand(float(args[1]), \" \".join(args[2:])))\n        elif args[0] == 'remove':\n            if len(args) < 2:\n                print(\"Usage: repeat remove INDEX\")\n                return\n            i = int(args[1])\n            if i < 0 or i >= len(self.repeats):\n                print(\"Invalid index %d\" % i)\n                return\n            self.repeats.pop(i)\n            return\n        elif args[0] == 'clean':\n            self.repeats = []\n        else:\n            print(\"Usage: repeat <add|remove|clean>\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_position(self):\n        '''show map position click information'''\n        pos = self.click_position\n        dms = (mp_util.degrees_to_dms(pos[0]), mp_util.degrees_to_dms(pos[1]))\n        msg =  \"Coordinates in WGS84\\n\"\n        msg += \"Decimal: %.6f %.6f\\n\" % (pos[0], pos[1])\n        msg += \"DMS:     %s %s\\n\" % (dms[0], dms[1])\n        msg += \"Grid:    %s\\n\" % mp_util.latlon_to_grid(pos)\n        if self.logdir:\n            logf = open(os.path.join(self.logdir, \"positions.txt\"), \"a\")\n            logf.write(\"Position: %.6f %.6f at %s\\n\" % (pos[0], pos[1], time.ctime()))\n            logf.close()\n        posbox = MPMenuChildMessageDialog('Position', msg, font_size=32)\n        posbox.show()", "response": "show map position click information"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_map(self, args):\n        '''map commands'''\n        from MAVProxy.modules.mavproxy_map import mp_slipmap\n        if args[0] == \"icon\":\n            if len(args) < 3:\n                print(\"Usage: map icon <lat> <lon> <icon>\")\n            else:\n                lat = args[1]\n                lon = args[2]\n                flag = 'flag.png'\n                if len(args) > 3:\n                    flag = args[3] + '.png'\n                icon = self.mpstate.map.icon(flag)\n                self.mpstate.map.add_object(mp_slipmap.SlipIcon('icon - %s [%u]' % (str(flag),self.icon_counter),\n                                                           (float(lat),float(lon)),\n                                                   icon, layer=3, rotation=0, follow=False))\n                self.icon_counter += 1\n        elif args[0] == \"set\":\n            self.map_settings.command(args[1:])\n            self.mpstate.map.add_object(mp_slipmap.SlipBrightness(self.map_settings.brightness))\n        elif args[0] == \"sethome\":\n            self.cmd_set_home(args)\n        else:\n            print(\"usage: map <icon|set>\")", "response": "handle command - add or change a single item in the map"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef closest_waypoint(self, latlon):\n        '''find closest waypoint to a position'''\n        (lat, lon) = latlon\n        best_distance = -1\n        closest = -1\n        for i in range(self.module('wp').wploader.count()):\n            w = self.module('wp').wploader.wp(i)\n            distance = mp_util.gps_distance(lat, lon, w.x, w.y)\n            if best_distance == -1 or distance < best_distance:\n                best_distance = distance\n                closest = i\n        if best_distance < 20:\n            return closest\n        else:\n            return -1", "response": "find closest waypoint to a position"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_rally(self, key):\n        '''remove a rally point'''\n        a = key.split(' ')\n        if a[0] != 'Rally' or len(a) != 2:\n            print(\"Bad rally object %s\" % key)\n            return\n        i = int(a[1])\n        self.mpstate.functions.process_stdin('rally remove %u' % i)", "response": "remove a rally point"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef move_rally(self, key):\n        '''move a rally point'''\n        a = key.split(' ')\n        if a[0] != 'Rally' or len(a) != 2:\n            print(\"Bad rally object %s\" % key)\n            return\n        i = int(a[1])\n        self.moving_rally = i", "response": "move a rally point"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a mission idx from a selection_index", "response": "def selection_index_to_idx(self, key, selection_index):\n        '''return a mission idx from a selection_index'''\n        a = key.split(' ')\n        if a[0] != 'mission' or len(a) != 2:\n            print(\"Bad mission object %s\" % key)\n            return None\n        midx = int(a[1])\n        if midx < 0 or midx >= len(self.mission_list):\n            print(\"Bad mission index %s\" % key)\n            return None\n        mlist = self.mission_list[midx]\n        if selection_index < 0 or selection_index >= len(mlist):\n            print(\"Bad mission polygon %s\" % selection_index)\n            return None\n        idx = mlist[selection_index]\n        return idx"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef move_mission(self, key, selection_index):\n        '''move a mission point'''\n        idx = self.selection_index_to_idx(key, selection_index)\n        self.moving_wp = idx\n        print(\"Moving wp %u\" % idx)", "response": "move a mission point"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving a mission point", "response": "def remove_mission(self, key, selection_index):\n        '''remove a mission point'''\n        idx = self.selection_index_to_idx(key, selection_index)\n        self.mpstate.functions.process_stdin('wp remove %u' % idx)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a vehicle to the map", "response": "def create_vehicle_icon(self, name, colour, follow=False, vehicle_type=None):\n        '''add a vehicle to the map'''\n        from MAVProxy.modules.mavproxy_map import mp_slipmap\n        if vehicle_type is None:\n            vehicle_type = self.vehicle_type_name\n        if name in self.have_vehicle and self.have_vehicle[name] == vehicle_type:\n            return\n        self.have_vehicle[name] = vehicle_type\n        icon = self.mpstate.map.icon(colour + vehicle_type + '.png')\n        self.mpstate.map.add_object(mp_slipmap.SlipIcon(name, (0,0), icon, layer=3, rotation=0, follow=follow,\n                                                   trail=mp_slipmap.SlipTrail()))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall when user selects Set Home on map", "response": "def cmd_set_home(self, args):\n        '''called when user selects \"Set Home\" on map'''\n        (lat, lon) = (self.click_position[0], self.click_position[1])\n        alt = self.ElevationMap.GetElevation(lat, lon)\n        print(\"Setting home to: \", lat, lon, alt)\n        self.master.mav.command_long_send(\n            self.settings.target_system, self.settings.target_component,\n            mavutil.mavlink.MAV_CMD_DO_SET_HOME,\n            1, # set position\n            0, # param1\n            0, # param2\n            0, # param3\n            0, # param4\n            lat, # lat\n            lon, # lon\n            alt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads the configuration file as dict with propierties reader from file", "response": "def load(filename):\n    '''\n    Returns the configuration as dict\n\n    @param filename: Name of the file\n\n    @type filename: String\n\n    @return a dict with propierties reader from file\n\n    '''\n    filepath = findConfigFile(filename)\n    prop= None\n    if (filepath):\n        print ('loading Config file %s' %(filepath))\n\n        with open(filepath, 'r') as stream:\n            cfg=yaml.load(stream)\n            prop = Properties(cfg) \n    else:\n        msg = \"Ice.Config file '%s' could not being found\" % (filename)\n        raise ValueError(msg)\n\n    return prop"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handle_mavlink_packet(self, master, m):\n        '''handle an incoming mavlink packet'''\n        if m.get_type() == 'PARAM_VALUE':\n            param_id = \"%.16s\" % m.param_id\n            # Note: the xml specifies param_index is a uint16, so -1 in that field will show as 65535\n            # We accept both -1 and 65535 as 'unknown index' to future proof us against someday having that\n            # xml fixed.\n            if m.param_index != -1 and m.param_index != 65535 and m.param_index not in self.mav_param_set:\n                added_new_parameter = True\n                self.mav_param_set.add(m.param_index)\n            else:\n                added_new_parameter = False\n            if m.param_count != -1:\n                self.mav_param_count = m.param_count\n            self.mav_param[str(param_id)] = m.param_value\n            if self.fetch_one > 0:\n                self.fetch_one -= 1\n                print(\"%s = %f\" % (param_id, m.param_value))\n            if added_new_parameter and len(self.mav_param_set) == m.param_count:\n                print(\"Received %u parameters\" % m.param_count)\n                if self.logdir != None:\n                    self.mav_param.save(os.path.join(self.logdir, self.parm_file), '*', verbose=True)", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking for missing parameters periodically", "response": "def fetch_check(self, master):\n        '''check for missing parameters periodically'''\n        if self.param_period.trigger():\n            if master is None:\n                return\n            if len(self.mav_param_set) == 0:\n                master.param_fetch_all()\n            elif self.mav_param_count != 0 and len(self.mav_param_set) != self.mav_param_count:\n                if master.time_since('PARAM_VALUE') >= 1:\n                    diff = set(range(self.mav_param_count)).difference(self.mav_param_set)\n                    count = 0\n                    while len(diff) > 0 and count < 10:\n                        idx = diff.pop()\n                        master.param_fetch_one(idx)\n                        count += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshows help on a parameter", "response": "def param_help(self, args):\n        '''show help on a parameter'''\n        if len(args) == 0:\n            print(\"Usage: param help PARAMETER_NAME\")\n            return\n        if self.vehicle_name is None:\n            print(\"Unknown vehicle type\")\n            return\n        path = mp_util.dot_mavproxy(\"%s.xml\" % self.vehicle_name)\n        if not os.path.exists(path):\n            print(\"Please run 'param download' first (vehicle_name=%s)\" % self.vehicle_name)\n            return\n        xml = open(path).read()\n        from lxml import objectify\n        objectify.enable_recursive_str()\n        tree = objectify.fromstring(xml)\n        htree = {}\n        for p in tree.vehicles.parameters.param:\n            n = p.get('name').split(':')[1]\n            htree[n] = p\n        for lib in tree.libraries.parameters:\n            for p in lib.param:\n                n = p.get('name')\n                htree[n] = p\n        for h in args:\n            if h in htree:\n                help = htree[h]\n                print(\"%s: %s\\n\" % (h, help.get('humanName')))\n                print(help.get('documentation'))\n                try:\n                    vchild = help.getchildren()[0]\n                    print(\"\\nValues: \")\n                    for v in vchild.value:\n                        print(\"\\t%s : %s\" % (v.get('code'), str(v)))\n                except Exception as e:\n                    pass\n            else:\n                print(\"Parameter '%s' not found in documentation\" % h)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef child_task(self):\n        '''child process - this holds all the GUI elements'''\n        from MAVProxy.modules.lib import mp_util\n        import wx_processguard\n        from wx_loader import wx\n        from wxsettings_ui import SettingsDlg\n        \n        mp_util.child_close_fds()\n        app = wx.App(False)\n        dlg = SettingsDlg(self.settings)\n        dlg.parent_pipe = self.parent_pipe\n        dlg.ShowModal()\n        dlg.Destroy()", "response": "child process - this holds all the GUI elements"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef watch_thread(self):\n        '''watch for settings changes from child'''\n        from mp_settings import MPSetting\n        while True:\n            setting = self.child_pipe.recv()\n            if not isinstance(setting, MPSetting):\n                break\n            try:\n                self.settings.set(setting.name, setting.value)\n            except Exception:\n                print(\"Unable to set %s to %s\" % (setting.name, setting.value))", "response": "watch for settings changes from child"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nenabling or disable speed reporting", "response": "def cmd_speed(self, args):\n        '''enable/disable speed report'''\n        self.settings.set('speedreporting', not self.settings.speedreporting)\n        if self.settings.speedreporting:\n            self.console.writeln(\"Speed reporting enabled\", bg='yellow')\n        else:\n            self.console.writeln(\"Speed reporting disabled\", bg='yellow')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef report(self, name, ok, msg=None, deltat=20):\n        '''report a sensor error'''\n        r = self.reports[name]\n        if time.time() < r.last_report + deltat:\n            r.ok = ok\n            return\n        r.last_report = time.time()\n        if ok and not r.ok:\n            self.say(\"%s OK\" % name)\n        r.ok = ok\n        if not r.ok:\n            self.say(msg)", "response": "report a sensor error"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreports a sensor change", "response": "def report_change(self, name, value, maxdiff=1, deltat=10):\n        '''report a sensor change'''\n        r = self.reports[name]\n        if time.time() < r.last_report + deltat:\n            return\n        r.last_report = time.time()\n        if math.fabs(r.value - value) < maxdiff:\n            return\n        r.value = value\n        self.say(\"%s %u\" % (name, value))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling an incoming mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        if m.get_type() == 'VFR_HUD' and ('GPS_RAW' in self.status.msgs or 'GPS_RAW_INT' in self.status.msgs):\n            self.check_heading(m)\n            if self.settings.speedreporting:\n                if m.airspeed != 0:\n                    speed = m.airspeed\n                else:\n                    speed = m.groundspeed\n                self.report_change('speed', speed, maxdiff=2, deltat=2)\n        if self.status.watch == \"sensors\" and time.time() > self.sensors_state.last_watch + 1:\n            self.sensors_state.last_watch = time.time()\n            self.cmd_sensors([])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate complete python implemenation", "response": "def generate(basename, xml):\n    '''generate complete python implemenation'''\n    if basename.endswith('.py'):\n        filename = basename\n    else:\n        filename = basename + '.py'\n\n    msgs = []\n    enums = []\n    filelist = []\n    for x in xml:\n        msgs.extend(x.message)\n        enums.extend(x.enum)\n        filelist.append(os.path.basename(x.filename))\n\n    for m in msgs:\n        if xml[0].little_endian:\n            m.fmtstr = '<'\n        else:\n            m.fmtstr = '>'\n        m.native_fmtstr = m.fmtstr\n        for f in m.ordered_fields:\n            m.fmtstr += mavfmt(f)\n            m.native_fmtstr += native_mavfmt(f)\n        m.order_map = [ 0 ] * len(m.fieldnames)\n        m.len_map = [ 0 ] * len(m.fieldnames)\n        m.array_len_map = [ 0 ] * len(m.fieldnames)\n        for i in range(0, len(m.fieldnames)):\n            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])\n            m.array_len_map[i] = m.ordered_fields[i].array_length\n        for i in range(0, len(m.fieldnames)):\n            n = m.order_map[i]\n            m.len_map[n] = m.fieldlengths[i]\n\n    print(\"Generating %s\" % filename)\n    outf = open(filename, \"w\")\n    generate_preamble(outf, msgs, basename, filelist, xml[0])\n    generate_enums(outf, enums)\n    generate_message_ids(outf, msgs)\n    generate_classes(outf, msgs)\n    generate_mavlink_class(outf, msgs, xml[0])\n    generate_methods(outf, msgs)\n    outf.close()\n    print(\"Generated %s OK\" % filename)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hide_object(self, key, hide=True):\n        '''hide an object on the map by key'''\n        self.object_queue.put(SlipHideObject(key, hide))", "response": "hide an object on the map by key"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmove an object on the map", "response": "def set_position(self, key, latlon, layer=None, rotation=0):\n        '''move an object on the map'''\n        self.object_queue.put(SlipPosition(key, latlon, layer, rotation))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_events(self):\n        '''check for events, calling registered callbacks as needed'''\n        while self.event_count() > 0:\n            event = self.get_event()\n            for callback in self._callbacks:\n                callback(event)", "response": "check for events calling registered callbacks as needed"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the laser data for a specific resource.", "response": "def update(self):\n        '''\n        Updates LaserData.\n        '''\n        if self.hasproxy():\n            laserD = LaserData()\n            values = []\n            data = self.proxy.getLaserData()\n\n            #laserD.values = laser.distanceData\n            for i in range (data.numLaser):\n                values.append(data.distanceData[i] / 1000.0) \n\n            laserD.maxAngle = data.maxAngle\n            laserD.minAngle = data.minAngle\n            laserD.maxRange = data.maxRange\n            laserD.minRange = data.minRange\n            laserD.values = values\n\n\n            self.lock.acquire()\n            self.laser = laserD\n            self.lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef radius_cmp(a, b, offsets):\n    '''return +1 or -1 for for sorting'''\n    diff = radius(a, offsets) - radius(b, offsets)\n    if diff > 0:\n        return 1\n    if diff < 0:\n        return -1\n    return 0", "response": "return + 1 or - 1 for sorting"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding best magnetometer offset fit to a log file", "response": "def magfit(logfile):\n    '''find best magnetometer offset fit to a log file'''\n\n    print(\"Processing log %s\" % filename)\n    mlog = mavutil.mavlink_connection(filename, notimestamps=args.notimestamps)\n\n    data = []\n\n    last_t = 0\n    offsets = Vector3(0,0,0)\n\n    # now gather all the data\n    while True:\n        m = mlog.recv_match(condition=args.condition)\n        if m is None:\n            break\n        if m.get_type() == \"SENSOR_OFFSETS\":\n            # update current offsets\n            offsets = Vector3(m.mag_ofs_x, m.mag_ofs_y, m.mag_ofs_z)\n        if m.get_type() == \"RAW_IMU\":\n            mag = Vector3(m.xmag, m.ymag, m.zmag)\n            # add data point after subtracting the current offsets\n            data.append(mag - offsets + noise())\n        if m.get_type() == \"MAG\" and not args.mag2:\n            offsets = Vector3(m.OfsX,m.OfsY,m.OfsZ)\n            mag = Vector3(m.MagX,m.MagY,m.MagZ)\n            data.append(mag - offsets + noise())\n        if m.get_type() == \"MAG2\" and args.mag2:\n            offsets = Vector3(m.OfsX,m.OfsY,m.OfsZ)\n            mag = Vector3(m.MagX,m.MagY,m.MagZ)\n            data.append(mag - offsets + noise())\n\n    print(\"Extracted %u data points\" % len(data))\n    print(\"Current offsets: %s\" % offsets)\n\n    orig_data = data\n\n    data = select_data(data)\n\n    # remove initial outliers\n    data.sort(lambda a,b : radius_cmp(a,b,offsets))\n    data = data[len(data)/16:-len(data)/16]\n\n    # do an initial fit\n    (offsets, field_strength) = fit_data(data)\n\n    for count in range(3):\n        # sort the data by the radius\n        data.sort(lambda a,b : radius_cmp(a,b,offsets))\n\n        print(\"Fit %u    : %s  field_strength=%6.1f to %6.1f\" % (\n            count, offsets,\n            radius(data[0], offsets), radius(data[-1], offsets)))\n\n        # discard outliers, keep the middle 3/4\n        data = data[len(data)/8:-len(data)/8]\n\n        # fit again\n        (offsets, field_strength) = fit_data(data)\n\n    print(\"Final    : %s  field_strength=%6.1f to %6.1f\" % (\n        offsets,\n        radius(data[0], offsets), radius(data[-1], offsets)))\n\n    if args.plot:\n        plot_data(orig_data, data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplot data in 3D", "response": "def plot_data(orig_data, data):\n    '''plot data in 3D'''\n    import numpy as np\n    from mpl_toolkits.mplot3d import Axes3D\n    import matplotlib.pyplot as plt\n\n    for dd, c in [(orig_data, 'r'), (data, 'b')]:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n\n        xs = [ d.x for d in dd ]\n        ys = [ d.y for d in dd ]\n        zs = [ d.z for d in dd ]\n        ax.scatter(xs, ys, zs, c=c, marker='o')\n\n        ax.set_xlabel('X Label')\n        ax.set_ylabel('Y Label')\n        ax.set_zlabel('Z Label')\n    plt.show()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_end(self, text, start_token, end_token, ignore_end_token=None):\n        '''find the of a token.\n        Returns the offset in the string immediately after the matching end_token'''\n        if not text.startswith(start_token):\n            raise MAVParseError(\"invalid token start\")\n        offset = len(start_token)\n        nesting = 1\n        while nesting > 0:\n            idx1 = text[offset:].find(start_token)\n            idx2 = text[offset:].find(end_token)\n            # Check for false positives due to another similar token\n            # For example, make sure idx2 points to the second '}' in ${{field: ${name}}}\n            if ignore_end_token:\n                combined_token = ignore_end_token + end_token\n                if text[offset+idx2:offset+idx2+len(combined_token)] == combined_token:\n                    idx2 += len(ignore_end_token)\n            if idx1 == -1 and idx2 == -1:\n                raise MAVParseError(\"token nesting error\")\n            if idx1 == -1 or idx1 > idx2:\n                offset += idx2 + len(end_token)\n                nesting -= 1\n            else:\n                offset += idx1 + len(start_token)\n                nesting += 1\n        return offset", "response": "find the end of a token."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the end of a variable", "response": "def find_var_end(self, text):\n        '''find the of a variable'''\n        return self.find_end(text, self.start_var_token, self.end_var_token)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_rep_end(self, text):\n        '''find the of a repitition'''\n        return self.find_end(text, self.start_rep_token, self.end_rep_token, ignore_end_token=self.end_var_token)", "response": "find the end of a repitition"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsubstitute variables in a string", "response": "def substitute(self, text, subvars={},\n                   trim_leading_lf=None, checkmissing=None):\n        '''substitute variables in a string'''\n\n        if trim_leading_lf is None:\n            trim_leading_lf = self.trim_leading_lf\n        if checkmissing is None:\n            checkmissing = self.checkmissing\n\n        # handle repititions\n        while True:\n            subidx = text.find(self.start_rep_token)\n            if subidx == -1:\n                break\n            endidx = self.find_rep_end(text[subidx:])\n            if endidx == -1:\n                raise MAVParseError(\"missing end macro in %s\" % text[subidx:])\n            part1 = text[0:subidx]\n            part2 = text[subidx+len(self.start_rep_token):subidx+(endidx-len(self.end_rep_token))]\n            part3 = text[subidx+endidx:]\n            a = part2.split(':')\n            field_name = a[0]\n            rest = ':'.join(a[1:])\n            v = None\n            if isinstance(subvars, dict):\n                v = subvars.get(field_name, None)\n            else:\n                v = getattr(subvars, field_name, None)\n            if v is None:\n                raise MAVParseError('unable to find field %s' % field_name)\n            t1 = part1\n            for f in v:\n                t1 += self.substitute(rest, f, trim_leading_lf=False, checkmissing=False)\n            if len(v) != 0 and t1[-1] in [\"\\n\", \",\"]:\n                t1 = t1[:-1]\n            t1 += part3\n            text = t1\n                \n        if trim_leading_lf:\n            if text[0] == '\\n':\n                text = text[1:]\n        while True:\n            idx = text.find(self.start_var_token)\n            if idx == -1:\n                return text\n            endidx = text[idx:].find(self.end_var_token)\n            if endidx == -1:\n                raise MAVParseError('missing end of variable: %s' % text[idx:idx+10])\n            varname = text[idx+2:idx+endidx]\n            if isinstance(subvars, dict):\n                if not varname in subvars:\n                    if checkmissing:\n                        raise MAVParseError(\"unknown variable in '%s%s%s'\" % (\n                            self.start_var_token, varname, self.end_var_token))\n                    return text[0:idx+endidx] + self.substitute(text[idx+endidx:], subvars,\n                                                                trim_leading_lf=False, checkmissing=False)\n                value = subvars[varname]\n            else:\n                value = getattr(subvars, varname, None)\n                if value is None:\n                    if checkmissing:\n                        raise MAVParseError(\"unknown variable in '%s%s%s'\" % (\n                            self.start_var_token, varname, self.end_var_token))\n                    return text[0:idx+endidx] + self.substitute(text[idx+endidx:], subvars,\n                                                                trim_leading_lf=False, checkmissing=False)\n            text = text.replace(\"%s%s%s\" % (self.start_var_token, varname, self.end_var_token), str(value))\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write(self, file, text, subvars={}, trim_leading_lf=True):\n        '''write to a file with variable substitution'''\n        file.write(self.substitute(text, subvars=subvars, trim_leading_lf=trim_leading_lf))", "response": "write to a file with variable substitution"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nworks out flight time for a log file", "response": "def flight_time(logfile):\n    '''work out flight time for a log file'''\n    print(\"Processing log %s\" % filename)\n    mlog = mavutil.mavlink_connection(filename)\n\n    in_air = False\n    start_time = 0.0\n    total_time = 0.0\n    total_dist = 0.0\n    t = None\n    last_msg = None\n    last_time_usec = None\n\n    while True:\n        m = mlog.recv_match(type=['GPS','GPS_RAW_INT'], condition=args.condition)\n        if m is None:\n            if in_air:\n                total_time += time.mktime(t) - start_time\n            if total_time > 0:\n                print(\"Flight time : %u:%02u\" % (int(total_time)/60, int(total_time)%60))\n            return (total_time, total_dist)\n        if m.get_type() == 'GPS_RAW_INT':\n            groundspeed = m.vel*0.01\n            status = m.fix_type\n            time_usec = m.time_usec\n        else:\n            groundspeed = m.Spd\n            status = m.Status\n            time_usec = m.TimeUS\n        if status < 3:\n            continue\n        t = time.localtime(m._timestamp)\n        if groundspeed > args.groundspeed and not in_air:\n            print(\"In air at %s (percent %.0f%% groundspeed %.1f)\" % (time.asctime(t), mlog.percent, groundspeed))\n            in_air = True\n            start_time = time.mktime(t)\n        elif groundspeed < args.groundspeed and in_air:\n            print(\"On ground at %s (percent %.1f%% groundspeed %.1f  time=%.1f seconds)\" % (\n                time.asctime(t), mlog.percent, groundspeed, time.mktime(t) - start_time))\n            in_air = False\n            total_time += time.mktime(t) - start_time\n\n        if last_msg is None or time_usec > last_time_usec or time_usec+30e6 < last_time_usec:\n            if last_msg is not None:\n                total_dist += distance_two(last_msg, m)\n            last_msg = m\n            last_time_usec = time_usec\n    return (total_time, total_dist)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall in idle time", "response": "def idle_task(self):\n        '''called in idle time'''\n        if self.js is None:\n            return\n        for e in pygame.event.get(): # iterate over event stack\n            #the following is somewhat custom for the specific joystick model:\n            override = self.module('rc').override[:]\n            for i in range(len(self.map)):\n                m = self.map[i]\n                if m is None:\n                    continue\n                (axis, mul, add) = m\n                if axis >= self.num_axes:\n                    continue\n                v = int(self.js.get_axis(axis)*mul + add)\n                v = max(min(v, 2000), 1000)\n                override[i] = v\n            if override != self.module('rc').override:\n                self.module('rc').override = override\n                self.module('rc').override_period.force()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if mtype matches one of patterns", "response": "def match_type(mtype, patterns):\n    '''return True if mtype matches pattern'''\n    for p in patterns:\n        if fnmatch.fnmatch(mtype, p):\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\napply the filter to the image.", "response": "def apply (self, img):\n\n        \n        yup,uup,vup = self.getUpLimit()\n        ydwn,udwn,vdwn = self.getDownLimit()\n\n        ''' We convert RGB as BGR because OpenCV \n        with RGB pass to YVU instead of YUV'''\n\n        yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)\n        \n        minValues = np.array([ydwn,udwn,vdwn],dtype=np.uint8)\n        maxValues = np.array([yup,uup,vup], dtype=np.uint8)\n\n        mask = cv2.inRange(yuv, minValues, maxValues)\n\n        res = cv2.bitwise_and(img,img, mask= mask)\n\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate complete python implemenation", "response": "def generate(basename, xml):\n    '''generate complete python implemenation'''\n    if basename.endswith('.lua'):\n        filename = basename\n    else:\n        filename = basename + '.lua'\n\n    msgs = []\n    enums = []\n    filelist = []\n    for x in xml:\n        msgs.extend(x.message)\n        enums.extend(x.enum)\n        filelist.append(os.path.basename(x.filename))\n\n    for m in msgs:\n        if xml[0].little_endian:\n            m.fmtstr = '<'\n        else:\n            m.fmtstr = '>'\n        for f in m.ordered_fields:\n            m.fmtstr += mavfmt(f)\n        m.order_map = [ 0 ] * len(m.fieldnames)\n        for i in range(0, len(m.fieldnames)):\n            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])\n\n    print(\"Generating %s\" % filename)\n    outf = open(filename, \"w\")\n    generate_preamble(outf)\n    generate_msg_table(outf, msgs)\n    generate_body_fields(outf)\n    \n    for m in msgs:\n        generate_msg_fields(outf, m)\n    \n    for m in msgs:\n        generate_payload_dissector(outf, m)\n    \n    generate_packet_dis(outf)\n#    generate_enums(outf, enums)\n#    generate_message_ids(outf, msgs)\n#    generate_classes(outf, msgs)\n#    generate_mavlink_class(outf, msgs, xml[0])\n#    generate_methods(outf, msgs)\n    generate_epilog(outf)\n    outf.close()\n    print(\"Generated %s OK\" % filename)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sens_power_encode(self, adc121_vspb_volt, adc121_cspb_amp, adc121_cs1_amp, adc121_cs2_amp):\n                '''\n                Voltage and current sensor data\n\n                adc121_vspb_volt          : Power board voltage sensor reading in volts (float)\n                adc121_cspb_amp           : Power board current sensor reading in amps (float)\n                adc121_cs1_amp            : Board current sensor 1 reading in amps (float)\n                adc121_cs2_amp            : Board current sensor 2 reading in amps (float)\n\n                '''\n                return MAVLink_sens_power_message(adc121_vspb_volt, adc121_cspb_amp, adc121_cs1_amp, adc121_cs2_amp)", "response": "This function is called when the user wants to change the power of the sensor in the board."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sens_mppt_encode(self, mppt_timestamp, mppt1_volt, mppt1_amp, mppt1_pwm, mppt1_status, mppt2_volt, mppt2_amp, mppt2_pwm, mppt2_status, mppt3_volt, mppt3_amp, mppt3_pwm, mppt3_status):\n                '''\n                Maximum Power Point Tracker (MPPT) sensor data for solar module power\n                performance tracking\n\n                mppt_timestamp            : MPPT last timestamp (uint64_t)\n                mppt1_volt                : MPPT1 voltage (float)\n                mppt1_amp                 : MPPT1 current (float)\n                mppt1_pwm                 : MPPT1 pwm (uint16_t)\n                mppt1_status              : MPPT1 status (uint8_t)\n                mppt2_volt                : MPPT2 voltage (float)\n                mppt2_amp                 : MPPT2 current (float)\n                mppt2_pwm                 : MPPT2 pwm (uint16_t)\n                mppt2_status              : MPPT2 status (uint8_t)\n                mppt3_volt                : MPPT3 voltage (float)\n                mppt3_amp                 : MPPT3 current (float)\n                mppt3_pwm                 : MPPT3 pwm (uint16_t)\n                mppt3_status              : MPPT3 status (uint8_t)\n\n                '''\n                return MAVLink_sens_mppt_message(mppt_timestamp, mppt1_volt, mppt1_amp, mppt1_pwm, mppt1_status, mppt2_volt, mppt2_amp, mppt2_pwm, mppt2_status, mppt3_volt, mppt3_amp, mppt3_pwm, mppt3_status)", "response": "Maximum Power Point Tracker (MPPT) sensor data for solar module power\n                performance tracking\n\n                mppt_timestamp            : MPPT last timestamp (uint64_t)\n                mppt1_volt                : MPPT1 voltage (float)\n                mppt1_amp                 : MPPT1 current (float)\n                mppt1_pwm                 : MPPT1 pwm (uint16_t)\n                mppt1_status              : MPPT1 status (uint8_t)\n                mppt2_volt                : MPPT2 voltage (float)\n                mppt2_amp                 : MPPT2 current (float)\n                mppt2_pwm                 : MPPT2 pwm (uint16_t)\n                mppt2_status              : MPPT2 status (uint8_t)\n                mppt3_volt                : MPPT3 voltage (float)\n                mppt3_amp                 : MPPT3 current (float)\n                mppt3_pwm                 : MPPT3 pwm (uint16_t)\n                mppt3_status              : MPPT3 status (uint8_t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sens_mppt_send(self, mppt_timestamp, mppt1_volt, mppt1_amp, mppt1_pwm, mppt1_status, mppt2_volt, mppt2_amp, mppt2_pwm, mppt2_status, mppt3_volt, mppt3_amp, mppt3_pwm, mppt3_status, force_mavlink1=False):\n                '''\n                Maximum Power Point Tracker (MPPT) sensor data for solar module power\n                performance tracking\n\n                mppt_timestamp            : MPPT last timestamp (uint64_t)\n                mppt1_volt                : MPPT1 voltage (float)\n                mppt1_amp                 : MPPT1 current (float)\n                mppt1_pwm                 : MPPT1 pwm (uint16_t)\n                mppt1_status              : MPPT1 status (uint8_t)\n                mppt2_volt                : MPPT2 voltage (float)\n                mppt2_amp                 : MPPT2 current (float)\n                mppt2_pwm                 : MPPT2 pwm (uint16_t)\n                mppt2_status              : MPPT2 status (uint8_t)\n                mppt3_volt                : MPPT3 voltage (float)\n                mppt3_amp                 : MPPT3 current (float)\n                mppt3_pwm                 : MPPT3 pwm (uint16_t)\n                mppt3_status              : MPPT3 status (uint8_t)\n\n                '''\n                return self.send(self.sens_mppt_encode(mppt_timestamp, mppt1_volt, mppt1_amp, mppt1_pwm, mppt1_status, mppt2_volt, mppt2_amp, mppt2_pwm, mppt2_status, mppt3_volt, mppt3_amp, mppt3_pwm, mppt3_status), force_mavlink1=force_mavlink1)", "response": "Sensitivity sensor data for solar module power tracking."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef aslctrl_debug_encode(self, i32_1, i8_1, i8_2, f_1, f_2, f_3, f_4, f_5, f_6, f_7, f_8):\n                '''\n                ASL-fixed-wing controller debug data\n\n                i32_1                     : Debug data (uint32_t)\n                i8_1                      : Debug data (uint8_t)\n                i8_2                      : Debug data (uint8_t)\n                f_1                       : Debug data (float)\n                f_2                       : Debug data (float)\n                f_3                       : Debug data (float)\n                f_4                       : Debug data (float)\n                f_5                       : Debug data (float)\n                f_6                       : Debug data (float)\n                f_7                       : Debug data (float)\n                f_8                       : Debug data (float)\n\n                '''\n                return MAVLink_aslctrl_debug_message(i32_1, i8_1, i8_2, f_1, f_2, f_3, f_4, f_5, f_6, f_7, f_8)", "response": "ASL - fixed - wing controller debug data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextend state information for ASLUAVs", "response": "def asluav_status_encode(self, LED_status, SATCOM_status, Servo_status, Motor_rpm):\n                '''\n                Extended state information for ASLUAVs\n\n                LED_status                : Status of the position-indicator LEDs (uint8_t)\n                SATCOM_status             : Status of the IRIDIUM satellite communication system (uint8_t)\n                Servo_status              : Status vector for up to 8 servos (uint8_t)\n                Motor_rpm                 : Motor RPM (float)\n\n                '''\n                return MAVLink_asluav_status_message(LED_status, SATCOM_status, Servo_status, Motor_rpm)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextend state information for ASLUAVs", "response": "def asluav_status_send(self, LED_status, SATCOM_status, Servo_status, Motor_rpm, force_mavlink1=False):\n                '''\n                Extended state information for ASLUAVs\n\n                LED_status                : Status of the position-indicator LEDs (uint8_t)\n                SATCOM_status             : Status of the IRIDIUM satellite communication system (uint8_t)\n                Servo_status              : Status vector for up to 8 servos (uint8_t)\n                Motor_rpm                 : Motor RPM (float)\n\n                '''\n                return self.send(self.asluav_status_encode(LED_status, SATCOM_status, Servo_status, Motor_rpm), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextend EKF state estimates for ASLUAVs", "response": "def ekf_ext_encode(self, timestamp, Windspeed, WindDir, WindZ, Airspeed, beta, alpha):\n                '''\n                Extended EKF state estimates for ASLUAVs\n\n                timestamp                 : Time since system start [us] (uint64_t)\n                Windspeed                 : Magnitude of wind velocity (in lateral inertial plane) [m/s] (float)\n                WindDir                   : Wind heading angle from North [rad] (float)\n                WindZ                     : Z (Down) component of inertial wind velocity [m/s] (float)\n                Airspeed                  : Magnitude of air velocity [m/s] (float)\n                beta                      : Sideslip angle [rad] (float)\n                alpha                     : Angle of attack [rad] (float)\n\n                '''\n                return MAVLink_ekf_ext_message(timestamp, Windspeed, WindDir, WindZ, Airspeed, beta, alpha)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextend EKF state estimates for ASLUAVs", "response": "def ekf_ext_send(self, timestamp, Windspeed, WindDir, WindZ, Airspeed, beta, alpha, force_mavlink1=False):\n                '''\n                Extended EKF state estimates for ASLUAVs\n\n                timestamp                 : Time since system start [us] (uint64_t)\n                Windspeed                 : Magnitude of wind velocity (in lateral inertial plane) [m/s] (float)\n                WindDir                   : Wind heading angle from North [rad] (float)\n                WindZ                     : Z (Down) component of inertial wind velocity [m/s] (float)\n                Airspeed                  : Magnitude of air velocity [m/s] (float)\n                beta                      : Sideslip angle [rad] (float)\n                alpha                     : Angle of attack [rad] (float)\n\n                '''\n                return self.send(self.ekf_ext_encode(timestamp, Windspeed, WindDir, WindZ, Airspeed, beta, alpha), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sens_atmos_send(self, TempAmbient, Humidity, force_mavlink1=False):\n                '''\n                Atmospheric sensors (temperature, humidity, ...)\n\n                TempAmbient               : Ambient temperature [degrees Celsius] (float)\n                Humidity                  : Relative humidity [%] (float)\n\n                '''\n                return self.send(self.sens_atmos_encode(TempAmbient, Humidity), force_mavlink1=force_mavlink1)", "response": "This message is used to send the temperature and humidity of the atmospheric sensors."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sens_batmon_encode(self, temperature, voltage, current, SoC, batterystatus, serialnumber, hostfetcontrol, cellvoltage1, cellvoltage2, cellvoltage3, cellvoltage4, cellvoltage5, cellvoltage6):\n                '''\n                Battery pack monitoring data for Li-Ion batteries\n\n                temperature               : Battery pack temperature in [deg C] (float)\n                voltage                   : Battery pack voltage in [mV] (uint16_t)\n                current                   : Battery pack current in [mA] (int16_t)\n                SoC                       : Battery pack state-of-charge (uint8_t)\n                batterystatus             : Battery monitor status report bits in Hex (uint16_t)\n                serialnumber              : Battery monitor serial number in Hex (uint16_t)\n                hostfetcontrol            : Battery monitor sensor host FET control in Hex (uint16_t)\n                cellvoltage1              : Battery pack cell 1 voltage in [mV] (uint16_t)\n                cellvoltage2              : Battery pack cell 2 voltage in [mV] (uint16_t)\n                cellvoltage3              : Battery pack cell 3 voltage in [mV] (uint16_t)\n                cellvoltage4              : Battery pack cell 4 voltage in [mV] (uint16_t)\n                cellvoltage5              : Battery pack cell 5 voltage in [mV] (uint16_t)\n                cellvoltage6              : Battery pack cell 6 voltage in [mV] (uint16_t)\n\n                '''\n                return MAVLink_sens_batmon_message(temperature, voltage, current, SoC, batterystatus, serialnumber, hostfetcontrol, cellvoltage1, cellvoltage2, cellvoltage3, cellvoltage4, cellvoltage5, cellvoltage6)", "response": "This function encodes the sensitivity BATMON data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fw_soaring_data_encode(self, timestamp, timestampModeChanged, xW, xR, xLat, xLon, VarW, VarR, VarLat, VarLon, LoiterRadius, LoiterDirection, DistToSoarPoint, vSinkExp, z1_LocalUpdraftSpeed, z2_DeltaRoll, z1_exp, z2_exp, ThermalGSNorth, ThermalGSEast, TSE_dot, DebugVar1, DebugVar2, ControlMode, valid):\n                '''\n                Fixed-wing soaring (i.e. thermal seeking) data\n\n                timestamp                 : Timestamp [ms] (uint64_t)\n                timestampModeChanged        : Timestamp since last mode change[ms] (uint64_t)\n                xW                        : Thermal core updraft strength [m/s] (float)\n                xR                        : Thermal radius [m] (float)\n                xLat                      : Thermal center latitude [deg] (float)\n                xLon                      : Thermal center longitude [deg] (float)\n                VarW                      : Variance W (float)\n                VarR                      : Variance R (float)\n                VarLat                    : Variance Lat (float)\n                VarLon                    : Variance Lon (float)\n                LoiterRadius              : Suggested loiter radius [m] (float)\n                LoiterDirection           : Suggested loiter direction (float)\n                DistToSoarPoint           : Distance to soar point [m] (float)\n                vSinkExp                  : Expected sink rate at current airspeed, roll and throttle [m/s] (float)\n                z1_LocalUpdraftSpeed        : Measurement / updraft speed at current/local airplane position [m/s] (float)\n                z2_DeltaRoll              : Measurement / roll angle tracking error [deg] (float)\n                z1_exp                    : Expected measurement 1 (float)\n                z2_exp                    : Expected measurement 2 (float)\n                ThermalGSNorth            : Thermal drift (from estimator prediction step only) [m/s] (float)\n                ThermalGSEast             : Thermal drift (from estimator prediction step only) [m/s] (float)\n                TSE_dot                   : Total specific energy change (filtered) [m/s] (float)\n                DebugVar1                 : Debug variable 1 (float)\n                DebugVar2                 : Debug variable 2 (float)\n                ControlMode               : Control Mode [-] (uint8_t)\n                valid                     : Data valid [-] (uint8_t)\n\n                '''\n                return MAVLink_fw_soaring_data_message(timestamp, timestampModeChanged, xW, xR, xLat, xLon, VarW, VarR, VarLat, VarLon, LoiterRadius, LoiterDirection, DistToSoarPoint, vSinkExp, z1_LocalUpdraftSpeed, z2_DeltaRoll, z1_exp, z2_exp, ThermalGSNorth, ThermalGSEast, TSE_dot, DebugVar1, DebugVar2, ControlMode, valid)", "response": "This function encodes the fixed - wing soaring data."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmonitors of sensorpod status timestamp : Timestamp in linuxtime [ms] (since 1.1.1970) (uint64_t) visensor_rate_1 : Rate of ROS topic 1 (uint8_t) visensor_rate_2 : Rate of ROS topic 2 (uint8_t) visensor_rate_3 : Rate of ROS topic 3 (uint8_t) visensor_rate_4 : Rate of ROS topic 4 (uint8_t) recording_nodes_count : Number of recording nodes (uint8_t) cpu_temp : Temperature of sensorpod CPU in [deg C] (uint8_t) free_space : Free space available in recordings directory in [Gb] * 1e2 (uint16_t)", "response": "def sensorpod_status_encode(self, timestamp, visensor_rate_1, visensor_rate_2, visensor_rate_3, visensor_rate_4, recording_nodes_count, cpu_temp, free_space):\n                '''\n                Monitoring of sensorpod status\n\n                timestamp                 : Timestamp in linuxtime [ms] (since 1.1.1970) (uint64_t)\n                visensor_rate_1           : Rate of ROS topic 1 (uint8_t)\n                visensor_rate_2           : Rate of ROS topic 2 (uint8_t)\n                visensor_rate_3           : Rate of ROS topic 3 (uint8_t)\n                visensor_rate_4           : Rate of ROS topic 4 (uint8_t)\n                recording_nodes_count        : Number of recording nodes (uint8_t)\n                cpu_temp                  : Temperature of sensorpod CPU in [deg C] (uint8_t)\n                free_space                : Free space available in recordings directory in [Gb] * 1e2 (uint16_t)\n\n                '''\n                return MAVLink_sensorpod_status_message(timestamp, visensor_rate_1, visensor_rate_2, visensor_rate_3, visensor_rate_4, recording_nodes_count, cpu_temp, free_space)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmonitor of sensorpod status timestamp : Timestamp in linuxtime [ms] (since 1.1.1970) (uint64_t) visensor_rate_1 : Rate of ROS topic 1 (uint8_t) visensor_rate_2 : Rate of ROS topic 2 (uint8_t) visensor_rate_3 : Rate of ROS topic 3 (uint8_t) visensor_rate_4 : Rate of ROS topic 4 (uint8_t) recording_nodes_count : Number of recording nodes (uint8_t) cpu_temp : Temperature of sensorpod CPU in [deg C] (uint8_t) free_space : Free space available in recordings directory in [Gb] * 1e2 (uint16_t)", "response": "def sensorpod_status_send(self, timestamp, visensor_rate_1, visensor_rate_2, visensor_rate_3, visensor_rate_4, recording_nodes_count, cpu_temp, free_space, force_mavlink1=False):\n                '''\n                Monitoring of sensorpod status\n\n                timestamp                 : Timestamp in linuxtime [ms] (since 1.1.1970) (uint64_t)\n                visensor_rate_1           : Rate of ROS topic 1 (uint8_t)\n                visensor_rate_2           : Rate of ROS topic 2 (uint8_t)\n                visensor_rate_3           : Rate of ROS topic 3 (uint8_t)\n                visensor_rate_4           : Rate of ROS topic 4 (uint8_t)\n                recording_nodes_count        : Number of recording nodes (uint8_t)\n                cpu_temp                  : Temperature of sensorpod CPU in [deg C] (uint8_t)\n                free_space                : Free space available in recordings directory in [Gb] * 1e2 (uint16_t)\n\n                '''\n                return self.send(self.sensorpod_status_encode(timestamp, visensor_rate_1, visensor_rate_2, visensor_rate_3, visensor_rate_4, recording_nodes_count, cpu_temp, free_space), force_mavlink1=force_mavlink1)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sens_power_board_encode(self, timestamp, pwr_brd_status, pwr_brd_led_status, pwr_brd_system_volt, pwr_brd_servo_volt, pwr_brd_mot_l_amp, pwr_brd_mot_r_amp, pwr_brd_servo_1_amp, pwr_brd_servo_2_amp, pwr_brd_servo_3_amp, pwr_brd_servo_4_amp, pwr_brd_aux_amp):\n                '''\n                Monitoring of power board status\n\n                timestamp                 : Timestamp (uint64_t)\n                pwr_brd_status            : Power board status register (uint8_t)\n                pwr_brd_led_status        : Power board leds status (uint8_t)\n                pwr_brd_system_volt        : Power board system voltage (float)\n                pwr_brd_servo_volt        : Power board servo voltage (float)\n                pwr_brd_mot_l_amp         : Power board left motor current sensor (float)\n                pwr_brd_mot_r_amp         : Power board right motor current sensor (float)\n                pwr_brd_servo_1_amp        : Power board servo1 current sensor (float)\n                pwr_brd_servo_2_amp        : Power board servo1 current sensor (float)\n                pwr_brd_servo_3_amp        : Power board servo1 current sensor (float)\n                pwr_brd_servo_4_amp        : Power board servo1 current sensor (float)\n                pwr_brd_aux_amp           : Power board aux current sensor (float)\n\n                '''\n                return MAVLink_sens_power_board_message(timestamp, pwr_brd_status, pwr_brd_led_status, pwr_brd_system_volt, pwr_brd_servo_volt, pwr_brd_mot_l_amp, pwr_brd_mot_r_amp, pwr_brd_servo_1_amp, pwr_brd_servo_2_amp, pwr_brd_servo_3_amp, pwr_brd_servo_4_amp, pwr_brd_aux_amp)", "response": "This function is called when the power board is in the power board state."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sens_power_board_send(self, timestamp, pwr_brd_status, pwr_brd_led_status, pwr_brd_system_volt, pwr_brd_servo_volt, pwr_brd_mot_l_amp, pwr_brd_mot_r_amp, pwr_brd_servo_1_amp, pwr_brd_servo_2_amp, pwr_brd_servo_3_amp, pwr_brd_servo_4_amp, pwr_brd_aux_amp, force_mavlink1=False):\n                '''\n                Monitoring of power board status\n\n                timestamp                 : Timestamp (uint64_t)\n                pwr_brd_status            : Power board status register (uint8_t)\n                pwr_brd_led_status        : Power board leds status (uint8_t)\n                pwr_brd_system_volt        : Power board system voltage (float)\n                pwr_brd_servo_volt        : Power board servo voltage (float)\n                pwr_brd_mot_l_amp         : Power board left motor current sensor (float)\n                pwr_brd_mot_r_amp         : Power board right motor current sensor (float)\n                pwr_brd_servo_1_amp        : Power board servo1 current sensor (float)\n                pwr_brd_servo_2_amp        : Power board servo1 current sensor (float)\n                pwr_brd_servo_3_amp        : Power board servo1 current sensor (float)\n                pwr_brd_servo_4_amp        : Power board servo1 current sensor (float)\n                pwr_brd_aux_amp           : Power board aux current sensor (float)\n\n                '''\n                return self.send(self.sens_power_board_encode(timestamp, pwr_brd_status, pwr_brd_led_status, pwr_brd_system_volt, pwr_brd_servo_volt, pwr_brd_mot_l_amp, pwr_brd_mot_r_amp, pwr_brd_servo_1_amp, pwr_brd_servo_2_amp, pwr_brd_servo_3_amp, pwr_brd_servo_4_amp, pwr_brd_aux_amp), force_mavlink1=force_mavlink1)", "response": "Sensitivity power board status"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mag_heading(RAW_IMU, ATTITUDE, declination=None, SENSOR_OFFSETS=None, ofs=None):\n    '''calculate heading from raw magnetometer'''\n    if declination is None:\n        import mavutil\n        declination = degrees(mavutil.mavfile_global.param('COMPASS_DEC', 0))\n    mag_x = RAW_IMU.xmag\n    mag_y = RAW_IMU.ymag\n    mag_z = RAW_IMU.zmag\n    if SENSOR_OFFSETS is not None and ofs is not None:\n        mag_x += ofs[0] - SENSOR_OFFSETS.mag_ofs_x\n        mag_y += ofs[1] - SENSOR_OFFSETS.mag_ofs_y\n        mag_z += ofs[2] - SENSOR_OFFSETS.mag_ofs_z\n\n    # go via a DCM matrix to match the APM calculation\n    dcm_matrix = rotation(ATTITUDE)\n    cos_pitch_sq = 1.0-(dcm_matrix.c.x*dcm_matrix.c.x)\n    headY = mag_y * dcm_matrix.c.z - mag_z * dcm_matrix.c.y\n    headX = mag_x * cos_pitch_sq - dcm_matrix.c.x * (mag_y * dcm_matrix.c.y + mag_z * dcm_matrix.c.z)\n\n    heading = degrees(atan2(-headY,headX)) + declination\n    if heading < 0:\n        heading += 360\n    return heading", "response": "calculate heading from raw magnetometer"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates heading from raw magnetometer", "response": "def mag_heading_motors(RAW_IMU, ATTITUDE, declination, SENSOR_OFFSETS, ofs, SERVO_OUTPUT_RAW, motor_ofs):\n    '''calculate heading from raw magnetometer'''\n    ofs = get_motor_offsets(SERVO_OUTPUT_RAW, ofs, motor_ofs)\n\n    if declination is None:\n        import mavutil\n        declination = degrees(mavutil.mavfile_global.param('COMPASS_DEC', 0))\n    mag_x = RAW_IMU.xmag\n    mag_y = RAW_IMU.ymag\n    mag_z = RAW_IMU.zmag\n    if SENSOR_OFFSETS is not None and ofs is not None:\n        mag_x += ofs[0] - SENSOR_OFFSETS.mag_ofs_x\n        mag_y += ofs[1] - SENSOR_OFFSETS.mag_ofs_y\n        mag_z += ofs[2] - SENSOR_OFFSETS.mag_ofs_z\n\n    headX = mag_x*cos(ATTITUDE.pitch) + mag_y*sin(ATTITUDE.roll)*sin(ATTITUDE.pitch) + mag_z*cos(ATTITUDE.roll)*sin(ATTITUDE.pitch)\n    headY = mag_y*cos(ATTITUDE.roll) - mag_z*sin(ATTITUDE.roll)\n    heading = degrees(atan2(-headY,headX)) + declination\n    if heading < 0:\n        heading += 360\n    return heading"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates magnetic field strength from raw magnetometer", "response": "def mag_field(RAW_IMU, SENSOR_OFFSETS=None, ofs=None):\n    '''calculate magnetic field strength from raw magnetometer'''\n    mag_x = RAW_IMU.xmag\n    mag_y = RAW_IMU.ymag\n    mag_z = RAW_IMU.zmag\n    if SENSOR_OFFSETS is not None and ofs is not None:\n        mag_x += ofs[0] - SENSOR_OFFSETS.mag_ofs_x\n        mag_y += ofs[1] - SENSOR_OFFSETS.mag_ofs_y\n        mag_z += ofs[2] - SENSOR_OFFSETS.mag_ofs_z\n    return sqrt(mag_x**2 + mag_y**2 + mag_z**2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mag_field_df(MAG, ofs=None):\n    '''calculate magnetic field strength from raw magnetometer (dataflash version)'''\n    mag = Vector3(MAG.MagX, MAG.MagY, MAG.MagZ)\n    offsets = Vector3(MAG.OfsX, MAG.OfsY, MAG.OfsZ)\n    if ofs is not None:\n        mag = (mag - offsets) + Vector3(ofs[0], ofs[1], ofs[2])\n    return mag.length()", "response": "calculate magnetic field strength from raw magnetometer"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates magnetic field strength from raw magnetometer", "response": "def get_motor_offsets(SERVO_OUTPUT_RAW, ofs, motor_ofs):\n    '''calculate magnetic field strength from raw magnetometer'''\n    import mavutil\n    self = mavutil.mavfile_global\n\n    m = SERVO_OUTPUT_RAW\n    motor_pwm = m.servo1_raw + m.servo2_raw + m.servo3_raw + m.servo4_raw\n    motor_pwm *= 0.25\n    rc3_min = self.param('RC3_MIN', 1100)\n    rc3_max = self.param('RC3_MAX', 1900)\n    motor = (motor_pwm - rc3_min) / (rc3_max - rc3_min)\n    if motor > 1.0:\n        motor = 1.0\n    if motor < 0.0:\n        motor = 0.0\n\n    motor_offsets0 = motor_ofs[0] * motor\n    motor_offsets1 = motor_ofs[1] * motor\n    motor_offsets2 = motor_ofs[2] * motor\n    ofs = (ofs[0] + motor_offsets0, ofs[1] + motor_offsets1, ofs[2] + motor_offsets2)\n\n    return ofs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate magnetic field strength from raw magnetometer", "response": "def mag_field_motors(RAW_IMU, SENSOR_OFFSETS, ofs, SERVO_OUTPUT_RAW, motor_ofs):\n    '''calculate magnetic field strength from raw magnetometer'''\n    mag_x = RAW_IMU.xmag\n    mag_y = RAW_IMU.ymag\n    mag_z = RAW_IMU.zmag\n\n    ofs = get_motor_offsets(SERVO_OUTPUT_RAW, ofs, motor_ofs)\n\n    if SENSOR_OFFSETS is not None and ofs is not None:\n        mag_x += ofs[0] - SENSOR_OFFSETS.mag_ofs_x\n        mag_y += ofs[1] - SENSOR_OFFSETS.mag_ofs_y\n        mag_z += ofs[2] - SENSOR_OFFSETS.mag_ofs_z\n    return sqrt(mag_x**2 + mag_y**2 + mag_z**2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naverage over N points", "response": "def average(var, key, N):\n    '''average over N points'''\n    global average_data\n    if not key in average_data:\n        average_data[key] = [var]*N\n        return var\n    average_data[key].pop(0)\n    average_data[key].append(var)\n    return sum(average_data[key])/N"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef second_derivative_5(var, key):\n    '''5 point 2nd derivative'''\n    global derivative_data\n    import mavutil\n    tnow = mavutil.mavfile_global.timestamp\n\n    if not key in derivative_data:\n        derivative_data[key] = (tnow, [var]*5)\n        return 0\n    (last_time, data) = derivative_data[key]\n    data.pop(0)\n    data.append(var)\n    derivative_data[key] = (tnow, data)\n    h = (tnow - last_time)\n    # N=5 2nd derivative from\n    # http://www.holoborodko.com/pavel/numerical-methods/numerical-derivative/smooth-low-noise-differentiators/\n    ret = ((data[4] + data[0]) - 2*data[2]) / (4*h**2)\n    return ret", "response": "5 point 2nd derivative"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating differences between values", "response": "def diff(var, key):\n    '''calculate differences between values'''\n    global last_diff\n    ret = 0\n    if not key in last_diff:\n        last_diff[key] = var\n        return 0\n    ret = var - last_diff[key]\n    last_diff[key] = var\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate slope of a node", "response": "def delta(var, key, tusec=None):\n    '''calculate slope'''\n    global last_delta\n    if tusec is not None:\n        tnow = tusec * 1.0e-6\n    else:\n        import mavutil\n        tnow = mavutil.mavfile_global.timestamp\n    dv = 0\n    ret = 0\n    if key in last_delta:\n        (last_v, last_t, last_ret) = last_delta[key]\n        if last_t == tnow:\n            return last_ret\n        if tnow == last_t:\n            ret = 0\n        else:\n            ret = (var - last_v) / (tnow - last_t)\n    last_delta[key] = (var, tnow, ret)\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef roll_estimate(RAW_IMU,GPS_RAW_INT=None,ATTITUDE=None,SENSOR_OFFSETS=None, ofs=None, mul=None,smooth=0.7):\n    '''estimate roll from accelerometer'''\n    rx = RAW_IMU.xacc * 9.81 / 1000.0\n    ry = RAW_IMU.yacc * 9.81 / 1000.0\n    rz = RAW_IMU.zacc * 9.81 / 1000.0\n    if ATTITUDE is not None and GPS_RAW_INT is not None:\n        ry -= ATTITUDE.yawspeed * GPS_RAW_INT.vel*0.01\n        rz += ATTITUDE.pitchspeed * GPS_RAW_INT.vel*0.01\n    if SENSOR_OFFSETS is not None and ofs is not None:\n        rx += SENSOR_OFFSETS.accel_cal_x\n        ry += SENSOR_OFFSETS.accel_cal_y\n        rz += SENSOR_OFFSETS.accel_cal_z\n        rx -= ofs[0]\n        ry -= ofs[1]\n        rz -= ofs[2]\n        if mul is not None:\n            rx *= mul[0]\n            ry *= mul[1]\n            rz *= mul[2]\n    return lowpass(degrees(-asin(ry/sqrt(rx**2+ry**2+rz**2))),'_roll',smooth)", "response": "estimate roll from accelerometer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rotation(ATTITUDE):\n    '''return the current DCM rotation matrix'''\n    r = Matrix3()\n    r.from_euler(ATTITUDE.roll, ATTITUDE.pitch, ATTITUDE.yaw)\n    return r", "response": "return the current DCM rotation matrix"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mag_rotation(RAW_IMU, inclination, declination):\n    '''return an attitude rotation matrix that is consistent with the current mag\n       vector'''\n    m_body = Vector3(RAW_IMU.xmag, RAW_IMU.ymag, RAW_IMU.zmag)\n    m_earth = Vector3(m_body.length(), 0, 0)\n\n    r = Matrix3()\n    r.from_euler(0, -radians(inclination), radians(declination))\n    m_earth = r * m_earth\n\n    r.from_two_vectors(m_earth, m_body)\n    return r", "response": "return an attitude rotation matrix that is consistent with the current mag\n       vector"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nestimate yaw from mag", "response": "def mag_yaw(RAW_IMU, inclination, declination):\n    '''estimate yaw from mag'''\n    m = mag_rotation(RAW_IMU, inclination, declination)\n    (r, p, y) = m.to_euler()\n    y = degrees(y)\n    if y < 0:\n        y += 360\n    return y"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mag_roll(RAW_IMU, inclination, declination):\n    '''estimate roll from mag'''\n    m = mag_rotation(RAW_IMU, inclination, declination)\n    (r, p, y) = m.to_euler()\n    return degrees(r)", "response": "estimate roll from mag"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef expected_mag(RAW_IMU, ATTITUDE, inclination, declination):\n    '''return expected mag vector'''\n    m_body = Vector3(RAW_IMU.xmag, RAW_IMU.ymag, RAW_IMU.zmag)\n    field_strength = m_body.length()\n\n    m = rotation(ATTITUDE)\n\n    r = Matrix3()\n    r.from_euler(0, -radians(inclination), radians(declination))\n    m_earth = r * Vector3(field_strength, 0, 0)\n\n    return m.transposed() * m_earth", "response": "return expected mag vector"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mag_discrepancy(RAW_IMU, ATTITUDE, inclination, declination=None):\n    '''give the magnitude of the discrepancy between observed and expected magnetic field'''\n    if declination is None:\n        import mavutil\n        declination = degrees(mavutil.mavfile_global.param('COMPASS_DEC', 0))\n    expected = expected_mag(RAW_IMU, ATTITUDE, inclination, declination)\n    mag = Vector3(RAW_IMU.xmag, RAW_IMU.ymag, RAW_IMU.zmag)\n    return degrees(expected.angle(mag))", "response": "give the magnitude of the discrepancy between observed and expected magnetic field"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mag_inclination(RAW_IMU, ATTITUDE, declination=None):\n    '''give the magnitude of the discrepancy between observed and expected magnetic field'''\n    if declination is None:\n        import mavutil\n        declination = degrees(mavutil.mavfile_global.param('COMPASS_DEC', 0))\n    r = rotation(ATTITUDE)\n    mag1 = Vector3(RAW_IMU.xmag, RAW_IMU.ymag, RAW_IMU.zmag)\n    mag1 = r * mag1\n    mag2 = Vector3(cos(radians(declination)), sin(radians(declination)), 0)\n    inclination = degrees(mag1.angle(mag2))\n    if RAW_IMU.zmag < 0:\n        inclination = -inclination\n    return inclination", "response": "give the magnitude of the discrepancy between observed and expected magnetic field"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gravity(RAW_IMU, SENSOR_OFFSETS=None, ofs=None, mul=None, smooth=0.7):\n    '''estimate pitch from accelerometer'''\n    if hasattr(RAW_IMU, 'xacc'):\n        rx = RAW_IMU.xacc * 9.81 / 1000.0\n        ry = RAW_IMU.yacc * 9.81 / 1000.0\n        rz = RAW_IMU.zacc * 9.81 / 1000.0\n    else:\n        rx = RAW_IMU.AccX\n        ry = RAW_IMU.AccY\n        rz = RAW_IMU.AccZ\n    if SENSOR_OFFSETS is not None and ofs is not None:\n        rx += SENSOR_OFFSETS.accel_cal_x\n        ry += SENSOR_OFFSETS.accel_cal_y\n        rz += SENSOR_OFFSETS.accel_cal_z\n        rx -= ofs[0]\n        ry -= ofs[1]\n        rz -= ofs[2]\n        if mul is not None:\n            rx *= mul[0]\n            ry *= mul[1]\n            rz *= mul[2]\n    return sqrt(rx**2+ry**2+rz**2)", "response": "estimate pitch from accelerometer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nestimating pitch from SIMSTATE accels", "response": "def pitch_sim(SIMSTATE, GPS_RAW):\n    '''estimate pitch from SIMSTATE accels'''\n    xacc = SIMSTATE.xacc - lowpass(delta(GPS_RAW.v,\"v\")*6.6, \"v\", 0.9)\n    zacc = SIMSTATE.zacc\n    zacc += SIMSTATE.ygyro * GPS_RAW.v;\n    if xacc/zacc >= 1:\n        return 0\n    if xacc/zacc <= -1:\n        return -0\n    return degrees(-asin(xacc/zacc))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef distance_two(GPS_RAW1, GPS_RAW2, horizontal=True):\n    '''distance between two points'''\n    if hasattr(GPS_RAW1, 'Lat'):\n        lat1 = radians(GPS_RAW1.Lat)\n        lat2 = radians(GPS_RAW2.Lat)\n        lon1 = radians(GPS_RAW1.Lng)\n        lon2 = radians(GPS_RAW2.Lng)\n        alt1 = GPS_RAW1.Alt\n        alt2 = GPS_RAW2.Alt\n    elif hasattr(GPS_RAW1, 'cog'):\n        lat1 = radians(GPS_RAW1.lat)*1.0e-7\n        lat2 = radians(GPS_RAW2.lat)*1.0e-7\n        lon1 = radians(GPS_RAW1.lon)*1.0e-7\n        lon2 = radians(GPS_RAW2.lon)*1.0e-7\n        alt1 = GPS_RAW1.alt*0.001\n        alt2 = GPS_RAW2.alt*0.001\n    else:\n        lat1 = radians(GPS_RAW1.lat)\n        lat2 = radians(GPS_RAW2.lat)\n        lon1 = radians(GPS_RAW1.lon)\n        lon2 = radians(GPS_RAW2.lon)\n        alt1 = GPS_RAW1.alt*0.001\n        alt2 = GPS_RAW2.alt*0.001\n    dLat = lat2 - lat1\n    dLon = lon2 - lon1\n\n    a = sin(0.5*dLat)**2 + sin(0.5*dLon)**2 * cos(lat1) * cos(lat2)\n    c = 2.0 * atan2(sqrt(a), sqrt(1.0-a))\n    ground_dist = 6371 * 1000 * c\n    if horizontal:\n        return ground_dist\n    return sqrt(ground_dist**2 + (alt2-alt1)**2)", "response": "distance between two points"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndistance from first fix point", "response": "def distance_home(GPS_RAW):\n    '''distance from first fix point'''\n    global first_fix\n    if (hasattr(GPS_RAW, 'fix_type') and GPS_RAW.fix_type < 2) or \\\n       (hasattr(GPS_RAW, 'Status')   and GPS_RAW.Status   < 2):\n        return 0\n\n    if first_fix == None:\n        first_fix = GPS_RAW\n        return 0\n    return distance_two(GPS_RAW, first_fix)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sawtooth(ATTITUDE, amplitude=2.0, period=5.0):\n    '''sawtooth pattern based on uptime'''\n    mins = (ATTITUDE.usec * 1.0e-6)/60\n    p = fmod(mins, period*2)\n    if p < period:\n        return amplitude * (p/period)\n    return amplitude * (period - (p-period))/period", "response": "sawtooth pattern based on uptime"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rate_of_turn(speed, bank):\n    '''return expected rate of turn in degrees/s for given speed in m/s and\n       bank angle in degrees'''\n    if abs(speed) < 2 or abs(bank) > 80:\n        return 0\n    ret = degrees(9.81*tan(radians(bank))/speed)\n    return ret", "response": "return expected rate of turn in degrees for given speed in m and\nuggage bank angle in degrees"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef airspeed(VFR_HUD, ratio=None, used_ratio=None, offset=None):\n    '''recompute airspeed with a different ARSPD_RATIO'''\n    import mavutil\n    mav = mavutil.mavfile_global\n    if ratio is None:\n        ratio = 1.9936 # APM default\n    if used_ratio is None:\n        if 'ARSPD_RATIO' in mav.params:\n            used_ratio = mav.params['ARSPD_RATIO']\n        else:\n            print(\"no ARSPD_RATIO in mav.params\")\n            used_ratio = ratio\n    if hasattr(VFR_HUD,'airspeed'):\n        airspeed = VFR_HUD.airspeed\n    else:\n        airspeed = VFR_HUD.Airspeed\n    airspeed_pressure = (airspeed**2) / used_ratio\n    if offset is not None:\n        airspeed_pressure += offset\n        if airspeed_pressure < 0:\n            airspeed_pressure = 0\n    airspeed = sqrt(airspeed_pressure * ratio)\n    return airspeed", "response": "recompute airspeed with a different ARSPD_RATIO"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef airspeed_voltage(VFR_HUD, ratio=None):\n    '''back-calculate the voltage the airspeed sensor must have seen'''\n    import mavutil\n    mav = mavutil.mavfile_global\n    if ratio is None:\n        ratio = 1.9936 # APM default\n    if 'ARSPD_RATIO' in mav.params:\n        used_ratio = mav.params['ARSPD_RATIO']\n    else:\n        used_ratio = ratio\n    if 'ARSPD_OFFSET' in mav.params:\n        offset = mav.params['ARSPD_OFFSET']\n    else:\n        return -1\n    airspeed_pressure = (pow(VFR_HUD.airspeed,2)) / used_ratio\n    raw = airspeed_pressure + offset\n    SCALING_OLD_CALIBRATION = 204.8\n    voltage = 5.0 * raw / 4096\n    return voltage", "response": "back - calculate the voltage the airspeed sensor must have seen"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef earth_rates(ATTITUDE):\n    '''return angular velocities in earth frame'''\n    from math import sin, cos, tan, fabs\n\n    p     = ATTITUDE.rollspeed\n    q     = ATTITUDE.pitchspeed\n    r     = ATTITUDE.yawspeed\n    phi   = ATTITUDE.roll\n    theta = ATTITUDE.pitch\n    psi   = ATTITUDE.yaw\n\n    phiDot   = p + tan(theta)*(q*sin(phi) + r*cos(phi))\n    thetaDot = q*cos(phi) - r*sin(phi)\n    if fabs(cos(theta)) < 1.0e-20:\n        theta += 1.0e-10\n    psiDot   = (q*sin(phi) + r*cos(phi))/cos(theta)\n    return (phiDot, thetaDot, psiDot)", "response": "return angular velocities in earth frame"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns GPS velocity vector", "response": "def gps_velocity_old(GPS_RAW_INT):\n    '''return GPS velocity vector'''\n    return Vector3(GPS_RAW_INT.vel*0.01*cos(radians(GPS_RAW_INT.cog*0.01)),\n                   GPS_RAW_INT.vel*0.01*sin(radians(GPS_RAW_INT.cog*0.01)), 0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gps_velocity_body(GPS_RAW_INT, ATTITUDE):\n    '''return GPS velocity vector in body frame'''\n    r = rotation(ATTITUDE)\n    return r.transposed() * Vector3(GPS_RAW_INT.vel*0.01*cos(radians(GPS_RAW_INT.cog*0.01)),\n                                    GPS_RAW_INT.vel*0.01*sin(radians(GPS_RAW_INT.cog*0.01)),\n                                    -tan(ATTITUDE.pitch)*GPS_RAW_INT.vel*0.01)", "response": "return GPS velocity vector in body frame"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef earth_accel(RAW_IMU,ATTITUDE):\n    '''return earth frame acceleration vector'''\n    r = rotation(ATTITUDE)\n    accel = Vector3(RAW_IMU.xacc, RAW_IMU.yacc, RAW_IMU.zacc) * 9.81 * 0.001\n    return r * accel", "response": "return earth frame acceleration vector"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns earth frame gyro vector", "response": "def earth_gyro(RAW_IMU,ATTITUDE):\n    '''return earth frame gyro vector'''\n    r = rotation(ATTITUDE)\n    accel = Vector3(degrees(RAW_IMU.xgyro), degrees(RAW_IMU.ygyro), degrees(RAW_IMU.zgyro)) * 0.001\n    return r * accel"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn airspeed energy error matching APM internals This is positive when we are going too slow", "response": "def airspeed_energy_error(NAV_CONTROLLER_OUTPUT, VFR_HUD):\n    '''return airspeed energy error matching APM internals\n    This is positive when we are going too slow\n    '''\n    aspeed_cm = VFR_HUD.airspeed*100\n    target_airspeed = NAV_CONTROLLER_OUTPUT.aspd_error + aspeed_cm\n    airspeed_energy_error = ((target_airspeed*target_airspeed) - (aspeed_cm*aspeed_cm))*0.00005\n    return airspeed_energy_error"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn energy error matching APM internals This is positive when we are too low or going too slow", "response": "def energy_error(NAV_CONTROLLER_OUTPUT, VFR_HUD):\n    '''return energy error matching APM internals\n    This is positive when we are too low or going too slow\n    '''\n    aspeed_energy_error = airspeed_energy_error(NAV_CONTROLLER_OUTPUT, VFR_HUD)\n    alt_error = NAV_CONTROLLER_OUTPUT.alt_error*100\n    energy_error = aspeed_energy_error + alt_error*0.098\n    return energy_error"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning turning circle in meters for steering_angle in degrees", "response": "def rover_turn_circle(SERVO_OUTPUT_RAW):\n    '''return turning circle (diameter) in meters for steering_angle in degrees\n    '''\n\n    # this matches Toms slash\n    max_wheel_turn = 35\n    wheelbase      = 0.335\n    wheeltrack     = 0.296\n\n    steering_angle = max_wheel_turn * (SERVO_OUTPUT_RAW.servo1_raw - 1500) / 400.0\n    theta = radians(steering_angle)\n    return (wheeltrack/2) + (wheelbase/sin(theta))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns yaw rate in degrees / second given steering_angle and speed", "response": "def rover_yaw_rate(VFR_HUD, SERVO_OUTPUT_RAW):\n    '''return yaw rate in degrees/second given steering_angle and speed'''\n    max_wheel_turn=35\n    speed = VFR_HUD.groundspeed\n    # assume 1100 to 1900 PWM on steering\n    steering_angle = max_wheel_turn * (SERVO_OUTPUT_RAW.servo1_raw - 1500) / 400.0\n    if abs(steering_angle) < 1.0e-6 or abs(speed) < 1.0e-6:\n        return 0\n    d = rover_turn_circle(SERVO_OUTPUT_RAW)\n    c = pi * d\n    t = c / speed\n    rate = 360.0 / t\n    return rate"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rover_lat_accel(VFR_HUD, SERVO_OUTPUT_RAW):\n    '''return lateral acceleration in m/s/s'''\n    speed = VFR_HUD.groundspeed\n    yaw_rate = rover_yaw_rate(VFR_HUD, SERVO_OUTPUT_RAW)\n    accel = radians(yaw_rate) * speed\n    return accel", "response": "return lateral acceleration in m/s/s"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef DCM_update(IMU, ATT, MAG, GPS):\n    '''implement full DCM system'''\n    global dcm_state\n    if dcm_state is None:\n        dcm_state = DCM_State(ATT.Roll, ATT.Pitch, ATT.Yaw)\n\n    mag   = Vector3(MAG.MagX, MAG.MagY, MAG.MagZ)\n    gyro  = Vector3(IMU.GyrX, IMU.GyrY, IMU.GyrZ)\n    accel = Vector3(IMU.AccX, IMU.AccY, IMU.AccZ)\n    accel2 = Vector3(IMU.AccX, IMU.AccY, IMU.AccZ)\n    dcm_state.update(gyro, accel, mag, GPS)\n    return dcm_state", "response": "implement full DCM system"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef PX4_update(IMU, ATT):\n    '''implement full DCM using PX4 native SD log data'''\n    global px4_state\n    if px4_state is None:\n        px4_state = PX4_State(degrees(ATT.Roll), degrees(ATT.Pitch), degrees(ATT.Yaw), IMU._timestamp)\n\n    gyro  = Vector3(IMU.GyroX, IMU.GyroY, IMU.GyroZ)\n    accel = Vector3(IMU.AccX, IMU.AccY, IMU.AccZ)\n    px4_state.update(gyro, accel, IMU._timestamp)\n    return px4_state", "response": "implement full DCM using PX4 native SD log data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn 1 if armed 0 if not", "response": "def armed(HEARTBEAT):\n    '''return 1 if armed, 0 if not'''\n    from . import mavutil\n    if HEARTBEAT.type == mavutil.mavlink.MAV_TYPE_GCS:\n        self = mavutil.mavfile_global\n        if self.motors_armed():\n            return 1\n        return 0\n    if HEARTBEAT.base_mode & mavutil.mavlink.MAV_MODE_FLAG_SAFETY_ARMED:\n        return 1\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the current DCM rotation matrix", "response": "def rotation_df(ATT):\n    '''return the current DCM rotation matrix'''\n    r = Matrix3()\n    r.from_euler(radians(ATT.Roll), radians(ATT.Pitch), radians(ATT.Yaw))\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rotation2(AHRS2):\n    '''return the current DCM rotation matrix'''\n    r = Matrix3()\n    r.from_euler(AHRS2.roll, AHRS2.pitch, AHRS2.yaw)\n    return r", "response": "return the current DCM rotation matrix"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn earth frame acceleration vector from AHRS2", "response": "def earth_accel2(RAW_IMU,ATTITUDE):\n    '''return earth frame acceleration vector from AHRS2'''\n    r = rotation2(ATTITUDE)\n    accel = Vector3(RAW_IMU.xacc, RAW_IMU.yacc, RAW_IMU.zacc) * 9.81 * 0.001\n    return r * accel"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns earth frame acceleration vector from df log", "response": "def earth_accel_df(IMU,ATT):\n    '''return earth frame acceleration vector from df log'''\n    r = rotation_df(ATT)\n    accel = Vector3(IMU.AccX, IMU.AccY, IMU.AccZ)\n    return r * accel"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn earth frame acceleration vector from df log", "response": "def earth_accel2_df(IMU,IMU2,ATT):\n    '''return earth frame acceleration vector from df log'''\n    r = rotation_df(ATT)\n    accel1 = Vector3(IMU.AccX, IMU.AccY, IMU.AccZ)\n    accel2 = Vector3(IMU2.AccX, IMU2.AccY, IMU2.AccZ)\n    accel = 0.5 * (accel1 + accel2)\n    return r * accel"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning GPS velocity vector", "response": "def gps_velocity_df(GPS):\n    '''return GPS velocity vector'''\n    vx = GPS.Spd * cos(radians(GPS.GCrs))\n    vy = GPS.Spd * sin(radians(GPS.GCrs))\n    return Vector3(vx, vy, GPS.VZ)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndistances between two points", "response": "def distance_gps2(GPS, GPS2):\n    '''distance between two points'''\n    if GPS.TimeMS != GPS2.TimeMS:\n        # reject messages not time aligned\n        return None\n    return distance_two(GPS, GPS2)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating EKF position when EKF disabled", "response": "def ekf1_pos(EKF1):\n  '''calculate EKF position when EKF disabled'''\n  global ekf_home\n  from . import mavutil\n  self = mavutil.mavfile_global\n  if ekf_home is None:\n      if not 'GPS' in self.messages or self.messages['GPS'].Status != 3:\n          return None\n      ekf_home = self.messages['GPS']\n      (ekf_home.Lat, ekf_home.Lng) = gps_offset(ekf_home.Lat, ekf_home.Lng, -EKF1.PE, -EKF1.PN)\n  (lat,lon) = gps_offset(ekf_home.Lat, ekf_home.Lng, EKF1.PE, EKF1.PN)\n  return (lat, lon)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rotate_quat(attitude, roll, pitch, yaw):\n  '''\n  Returns rotated quaternion\n  :param attitude: quaternion [w, x, y , z]\n  :param roll: rotation in rad\n  :param pitch: rotation in rad\n  :param yaw: rotation in rad\n  :returns: quaternion [w, x, y , z]\n  '''\n  quat = Quaternion(attitude)\n  rotation = Quaternion([roll, pitch, yaw])\n  res = rotation * quat\n\n  return res.q", "response": "Rotates the quaternion at the given angles and rolls and yaw."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake off a specific locale", "response": "def cmd_takeoff(self, args):\n        '''take off'''\n        if ( len(args) != 1):\n            print(\"Usage: takeoff ALTITUDE_IN_METERS\")\n            return\n\n        if (len(args) == 1):\n            altitude = float(args[0])\n            print(\"Take Off started\")\n            self.master.mav.command_long_send(\n                self.settings.target_system,  # target_system\n                mavutil.mavlink.MAV_COMP_ID_SYSTEM_CONTROL, # target_component\n                mavutil.mavlink.MAV_CMD_NAV_TAKEOFF, # command\n                0, # confirmation\n                0, # param1\n                0, # param2\n                0, # param3\n                0, # param4\n                0, # param5\n                0, # param6\n                altitude)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncontrol the DIGICAM_CONFIGURE command", "response": "def cmd_camctrlmsg(self, args):\n        '''camctrlmsg'''\n\n        print(\"Sent DIGICAM_CONFIGURE CMD_LONG\")\n        self.master.mav.command_long_send(\n            self.settings.target_system,  # target_system\n            0, # target_component\n            mavutil.mavlink.MAV_CMD_DO_DIGICAM_CONFIGURE, # command\n            0, # confirmation\n            10, # param1\n            20, # param2\n            30, # param3\n            40, # param4\n            50, # param5\n            60, # param6\n            70)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyaw angle angular_speed angle_mode", "response": "def cmd_condition_yaw(self, args):\n        '''yaw angle angular_speed angle_mode'''\n        if ( len(args) != 3):\n            print(\"Usage: yaw ANGLE ANGULAR_SPEED MODE:[0 absolute / 1 relative]\")\n            return\n\n        if (len(args) == 3):\n            angle = float(args[0])\n            angular_speed = float(args[1])\n            angle_mode = float(args[2])\n            print(\"ANGLE %s\" % (str(angle)))\n\n            self.master.mav.command_long_send(\n                self.settings.target_system,  # target_system\n                mavutil.mavlink.MAV_COMP_ID_SYSTEM_CONTROL, # target_component\n                mavutil.mavlink.MAV_CMD_CONDITION_YAW, # command\n                0, # confirmation\n                angle, # param1 (angle value)\n                angular_speed, # param2 (angular speed value)\n                0, # param3\n                angle_mode, # param4 (mode: 0->absolute / 1->relative)\n                0, # param5\n                0, # param6\n                0)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_velocity(self, args):\n        '''velocity x-ms y-ms z-ms'''\n        if (len(args) != 3):\n            print(\"Usage: velocity x y z (m/s)\")\n            return\n\n        if (len(args) == 3):\n            x_mps = float(args[0])\n            y_mps = float(args[1])\n            z_mps = float(args[2])\n            #print(\"x:%f, y:%f, z:%f\" % (x_mps, y_mps, z_mps))\n\n            self.master.mav.set_position_target_local_ned_send(\n                0,       # time_boot_ms (not used)\n                0, 0,    # target system, target component\n                mavutil.mavlink.MAV_FRAME_LOCAL_NED, # frame\n                0b0000111111000111, # type_mask (only speeds enabled)\n                0, 0, 0, # x, y, z positions (not used)\n                x_mps, y_mps, -z_mps, # x, y, z velocity in m/s\n                0, 0, 0, # x, y, z acceleration (not supported yet, ignored in GCS_Mavlink)\n                0, 0)", "response": "velocity x - ms y - ms z - ms"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nposition x - m y - m z - m", "response": "def cmd_position(self, args):\n        '''position x-m y-m z-m'''\n        if (len(args) != 3):\n            print(\"Usage: position x y z (meters)\")\n            return\n\n        if (len(args) == 3):\n            x_m = float(args[0])\n            y_m = float(args[1])\n            z_m = float(args[2])\n            print(\"x:%f, y:%f, z:%f\" % (x_m, y_m, z_m))\n            self.master.mav.set_position_target_local_ned_send(\n                                      0,  # system time in milliseconds\n                                      1,  # target system\n                                      0,  # target component\n                                      8,  # coordinate frame MAV_FRAME_BODY_NED\n                                      3576,     # type mask (pos only)\n                                      x_m, y_m, z_m,  # position x,y,z\n                                      0, 0, 0,  # velocity x,y,z\n                                      0, 0, 0,  # accel x,y,z\n                                      0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cmd_attitude(self, args):\n        '''attitude q0 q1 q2 q3 thrust'''\n        if len(args) != 5:\n            print(\"Usage: attitude q0 q1 q2 q3 thrust (0~1)\")\n            return\n\n        if len(args) == 5:\n            q0 = float(args[0])\n            q1 = float(args[1])\n            q2 = float(args[2])\n            q3 = float(args[3])\n            thrust = float(args[4])\n            att_target = [q0, q1, q2, q3]\n            print(\"q0:%.3f, q1:%.3f, q2:%.3f q3:%.3f thrust:%.2f\" % (q0, q1, q2, q3, thrust))\n            self.master.mav.set_attitude_target_send(\n                                      0,  # system time in milliseconds\n                                      1,  # target system\n                                      0,  # target component\n                                      63, # type mask (ignore all except attitude + thrust)\n                                      att_target, # quaternion attitude\n                                      0,  # body roll rate\n                                      0,  # body pich rate\n                                      0,  # body yaw rate\n                                      thrust)", "response": "attitude q0 q1 q2 q3 thrust"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_image(self, img):\n        '''set the image to be displayed'''\n        self._bmp = wx.BitmapFromImage(img)\n        self.SetMinSize((self._bmp.GetWidth(), self._bmp.GetHeight()))", "response": "set the image to be displayed"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates mavlink message formatters and parsers for a single node", "response": "def mavgen(opts, args):\n    \"\"\"Generate mavlink message formatters and parsers (C and Python ) using options\n    and args where args are a list of xml files. This function allows python\n    scripts under Windows to control mavgen using the same interface as\n    shell scripts under Unix\"\"\"\n\n    xml = []\n\n    # Enable validation by default, disabling it if explicitly requested\n    if opts.validate:\n        try:\n            from lxml import etree\n            with open(schemaFile, 'r') as f:\n                xmlschema_root = etree.parse(f)\n                xmlschema = etree.XMLSchema(xmlschema_root)\n        except:\n            print(\"WARNING: Unable to load XML validator libraries. XML validation will not be performed\", file=sys.stderr)\n            opts.validate = False\n\n    def mavgen_validate(xmlfile):\n        \"\"\"Uses lxml to validate an XML file. We define mavgen_validate\n           here because it relies on the XML libs that were loaded in mavgen(), so it can't be called standalone\"\"\"\n        xmlvalid = True\n        try:\n            with open(xmlfile, 'r') as f:\n                xmldocument = etree.parse(f)\n                xmlschema.assertValid(xmldocument)\n                forbidden_names_re = re.compile(\"^(break$|case$|class$|catch$|const$|continue$|debugger$|default$|delete$|do$|else$|\\\n                                    export$|extends$|finally$|for$|function$|if$|import$|in$|instanceof$|let$|new$|\\\n                                    return$|super$|switch$|this$|throw$|try$|typeof$|var$|void$|while$|with$|yield$|\\\n                                    enum$|await$|implements$|package$|protected$|static$|interface$|private$|public$|\\\n                                    abstract$|boolean$|byte$|char$|double$|final$|float$|goto$|int$|long$|native$|\\\n                                    short$|synchronized$|transient$|volatile$).*\", re.IGNORECASE)\n                for element in xmldocument.iter('enum', 'entry', 'message', 'field'):\n                    if forbidden_names_re.search(element.get('name')):\n                        print(\"Validation error:\", file=sys.stderr)\n                        print(\"Element : %s at line : %s contains forbidden word\" % (element.tag, element.sourceline), file=sys.stderr)\n                        xmlvalid = False\n\n            return xmlvalid\n        except etree.XMLSchemaError:\n            return False\n\n    # Process all XML files, validating them as necessary.\n    for fname in args:\n        if opts.validate:\n            print(\"Validating %s\" % fname)\n            if not mavgen_validate(fname):\n                return False\n        else:\n            print(\"Validation skipped for %s.\" % fname)\n\n        print(\"Parsing %s\" % fname)\n        xml.append(mavparse.MAVXML(fname, opts.wire_protocol))\n\n    # expand includes\n    for x in xml[:]:\n        for i in x.include:\n            fname = os.path.join(os.path.dirname(x.filename), i)\n\n            # Validate XML file with XSD file if possible.\n            if opts.validate:\n                print(\"Validating %s\" % fname)\n                if not mavgen_validate(fname):\n                    return False\n            else:\n                print(\"Validation skipped for %s.\" % fname)\n\n            # Parsing\n            print(\"Parsing %s\" % fname)\n            xml.append(mavparse.MAVXML(fname, opts.wire_protocol))\n\n            # include message lengths and CRCs too\n            x.message_crcs.update(xml[-1].message_crcs)\n            x.message_lengths.update(xml[-1].message_lengths)\n            x.message_min_lengths.update(xml[-1].message_min_lengths)\n            x.message_flags.update(xml[-1].message_flags)\n            x.message_target_system_ofs.update(xml[-1].message_target_system_ofs)\n            x.message_target_component_ofs.update(xml[-1].message_target_component_ofs)\n            x.message_names.update(xml[-1].message_names)\n            x.largest_payload = max(x.largest_payload, xml[-1].largest_payload)\n\n    # work out max payload size across all includes\n    largest_payload = 0\n    for x in xml:\n        if x.largest_payload > largest_payload:\n            largest_payload = x.largest_payload\n    for x in xml:\n        x.largest_payload = largest_payload\n\n    if mavparse.check_duplicates(xml):\n        sys.exit(1)\n\n    print(\"Found %u MAVLink message types in %u XML files\" % (\n        mavparse.total_msgs(xml), len(xml)))\n\n    # Convert language option to lowercase and validate\n    opts.language = opts.language.lower()\n    if opts.language == 'python':\n        from . import mavgen_python\n        mavgen_python.generate(opts.output, xml)\n    elif opts.language == 'c':\n        from . import mavgen_c\n        mavgen_c.generate(opts.output, xml)\n    elif opts.language == 'wlua':\n        from . import mavgen_wlua\n        mavgen_wlua.generate(opts.output, xml)\n    elif opts.language == 'cs':\n        from . import mavgen_cs\n        mavgen_cs.generate(opts.output, xml)\n    elif opts.language == 'javascript':\n        from . import mavgen_javascript\n        mavgen_javascript.generate(opts.output, xml)\n    elif opts.language == 'objc':\n        from . import mavgen_objc\n        mavgen_objc.generate(opts.output, xml)\n    elif opts.language == 'swift':\n        from . import mavgen_swift\n        mavgen_swift.generate(opts.output, xml)\n    elif opts.language == 'java':\n        from . import mavgen_java\n        mavgen_java.generate(opts.output, xml)\n    else:\n        print(\"Unsupported language %s\" % opts.language)\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates the python code on the fly for a MAVLink dialect", "response": "def mavgen_python_dialect(dialect, wire_protocol):\n    '''generate the python code on the fly for a MAVLink dialect'''\n    dialects = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'dialects')\n    mdef = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'message_definitions')\n    if wire_protocol == mavparse.PROTOCOL_0_9:\n        py = os.path.join(dialects, 'v09', dialect + '.py')\n        xml = os.path.join(dialects, 'v09', dialect + '.xml')\n        if not os.path.exists(xml):\n            xml = os.path.join(mdef, 'v0.9', dialect + '.xml')\n    elif wire_protocol == mavparse.PROTOCOL_1_0:\n        py = os.path.join(dialects, 'v10', dialect + '.py')\n        xml = os.path.join(dialects, 'v10', dialect + '.xml')\n        if not os.path.exists(xml):\n            xml = os.path.join(mdef, 'v1.0', dialect + '.xml')\n    else:\n        py = os.path.join(dialects, 'v20', dialect + '.py')\n        xml = os.path.join(dialects, 'v20', dialect + '.xml')\n        if not os.path.exists(xml):\n            xml = os.path.join(mdef, 'v1.0', dialect + '.xml')\n    opts = Opts(py, wire_protocol)\n\n    # Python 2 to 3 compatibility\n    try:\n        import StringIO as io\n    except ImportError:\n        import io\n\n    # throw away stdout while generating\n    stdout_saved = sys.stdout\n    sys.stdout = io.StringIO()\n    try:\n        xml = os.path.relpath(xml)\n        if not mavgen(opts, [xml]):\n            sys.stdout = stdout_saved\n            return False\n    except Exception:\n        sys.stdout = stdout_saved\n        raise\n    sys.stdout = stdout_saved\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwork out signal loss times for a log file", "response": "def sigloss(logfile):\n    '''work out signal loss times for a log file'''\n    print(\"Processing log %s\" % filename)\n    mlog = mavutil.mavlink_connection(filename,\n                                      planner_format=args.planner,\n                                      notimestamps=args.notimestamps,\n                                      robust_parsing=args.robust)\n\n    last_t = 0\n\n    types = args.types\n    if types is not None:\n        types = types.split(',')\n\n    while True:\n        m = mlog.recv_match(condition=args.condition)\n        if m is None:\n            return\n        if types is not None and m.get_type() not in types:\n            continue\n        if args.notimestamps:\n            if not 'usec' in m._fieldnames:\n                continue\n            t = m.usec / 1.0e6\n        else:\n            t = m._timestamp\n        if last_t != 0:\n            if t - last_t > args.deltat:\n                print(\"Sig lost for %.1fs at %s\" % (t-last_t, time.asctime(time.localtime(t))))\n        last_t = t"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_tlog(filename):\n    '''convert a tlog to a .m file'''\n\n    print(\"Processing %s\" % filename)\n\n    mlog = mavutil.mavlink_connection(filename, dialect=args.dialect, zero_time_base=True)\n\n    # first walk the entire file, grabbing all messages into a hash of lists,\n    #and the first message of each type into a hash\n    msg_types = {}\n    msg_lists = {}\n\n    types = args.types\n    if types is not None:\n        types = types.split(',')\n\n    # note that Octave doesn't like any extra '.', '*', '-', characters in the filename\n    (head, tail) = os.path.split(filename)\n    basename = '.'.join(tail.split('.')[:-1])\n    mfilename = re.sub('[\\.\\-\\+\\*]','_', basename) + '.m'\n    # Octave also doesn't like files that don't start with a letter\n    if (re.match('^[a-zA-z]', mfilename) == None):\n        mfilename = 'm_' + mfilename\n\n    if head is not None:\n        mfilename = os.path.join(head, mfilename)\n    print(\"Creating %s\" % mfilename)\n\n    f = open(mfilename, \"w\")\n\n    type_counters = {}\n\n    while True:\n        m = mlog.recv_match(condition=args.condition)\n        if m is None:\n            break\n\n        if types is not None and m.get_type() not in types:\n            continue\n        if m.get_type() == 'BAD_DATA':\n            continue\n\n        fieldnames = m._fieldnames\n        mtype = m.get_type()\n        if mtype in ['FMT', 'PARM']:\n            continue\n\n        if mtype not in type_counters:\n            type_counters[mtype] = 0\n            f.write(\"%s.columns = {'timestamp'\" % mtype)\n            for field in fieldnames:\n                val = getattr(m, field)\n                if not isinstance(val, str):\n                    if type(val) is not list:\n                        f.write(\",'%s'\" % field)\n                    else:\n                        for i in range(0, len(val)):\n                            f.write(\",'%s%d'\" % (field, i + 1))\n            f.write(\"};\\n\")\n\n        type_counters[mtype] += 1\n        f.write(\"%s.data(%u,:) = [%f\" % (mtype, type_counters[mtype], m._timestamp))\n        for field in m._fieldnames:\n            val = getattr(m, field)\n            if not isinstance(val, str):\n                if type(val) is not list:\n                    f.write(\",%.20g\" % val)\n                else:\n                    for i in range(0, len(val)):\n                        f.write(\",%.20g\" % val[i])\n        f.write(\"];\\n\")\n    f.close()", "response": "convert a tlog to a. m file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn radius give data point and offsets", "response": "def radius(d, offsets, motor_ofs):\n    '''return radius give data point and offsets'''\n    (mag, motor) = d\n    return (mag + offsets + motor*motor_ofs).length()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef magfit(logfile):\n    '''find best magnetometer offset fit to a log file'''\n\n    print(\"Processing log %s\" % filename)\n    mlog = mavutil.mavlink_connection(filename, notimestamps=args.notimestamps)\n\n    data = []\n\n    last_t = 0\n    offsets = Vector3(0,0,0)\n    motor_ofs = Vector3(0,0,0)\n    motor = 0.0\n\n    # now gather all the data\n    while True:\n        m = mlog.recv_match(condition=args.condition)\n        if m is None:\n            break\n        if m.get_type() == \"PARAM_VALUE\" and m.param_id == \"RC3_MIN\":\n            rc3_min = float(m.param_value)\n        if m.get_type() == \"SENSOR_OFFSETS\":\n            # update current offsets\n            offsets = Vector3(m.mag_ofs_x, m.mag_ofs_y, m.mag_ofs_z)\n        if m.get_type() == \"SERVO_OUTPUT_RAW\":\n            motor_pwm = m.servo1_raw + m.servo2_raw + m.servo3_raw + m.servo4_raw\n            motor_pwm *= 0.25\n            rc3_min = mlog.param('RC3_MIN', 1100)\n            rc3_max = mlog.param('RC3_MAX', 1900)\n            motor = (motor_pwm - rc3_min) / (rc3_max - rc3_min)\n            if motor > 1.0:\n                motor = 1.0\n            if motor < 0.0:\n                motor = 0.0\n        if m.get_type() == \"RAW_IMU\":\n            mag = Vector3(m.xmag, m.ymag, m.zmag)\n            # add data point after subtracting the current offsets\n            data.append((mag - offsets + noise(), motor))\n\n    print(\"Extracted %u data points\" % len(data))\n    print(\"Current offsets: %s\" % offsets)\n\n    data = select_data(data)\n\n    # do an initial fit with all data\n    (offsets, motor_ofs, field_strength) = fit_data(data)\n\n    for count in range(3):\n        # sort the data by the radius\n        data.sort(lambda a,b : radius_cmp(a,b,offsets,motor_ofs))\n\n        print(\"Fit %u    : %s  %s field_strength=%6.1f to %6.1f\" % (\n            count, offsets, motor_ofs,\n            radius(data[0], offsets, motor_ofs), radius(data[-1], offsets, motor_ofs)))\n\n        # discard outliers, keep the middle 3/4\n        data = data[len(data)/8:-len(data)/8]\n\n        # fit again\n        (offsets, motor_ofs, field_strength) = fit_data(data)\n\n    print(\"Final    : %s  %s field_strength=%6.1f to %6.1f\" % (\n        offsets, motor_ofs,\n        radius(data[0], offsets, motor_ofs), radius(data[-1], offsets, motor_ofs)))\n    print(\"mavgraph.py '%s' 'mag_field(RAW_IMU)' 'mag_field_motors(RAW_IMU,SENSOR_OFFSETS,(%f,%f,%f),SERVO_OUTPUT_RAW,(%f,%f,%f))'\" % (\n        filename,\n        offsets.x,offsets.y,offsets.z,\n        motor_ofs.x, motor_ofs.y, motor_ofs.z))", "response": "find best magnetometer offset fit to a log file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating MVMavlink header and implementation", "response": "def generate_mavlink(directory, xml):\n    '''generate MVMavlink header and implementation'''\n    f = open(os.path.join(directory, \"MVMavlink.h\"), mode='w')\n    t.write(f,'''\n//\n//  MVMavlink.h\n//  MAVLink communications protocol built from ${basename}.xml\n//\n//  Created on ${parse_time} by mavgen_objc.py\n//  http://qgroundcontrol.org/mavlink\n//\n\n#import \"MVMessage.h\"\n${{message_definition_files:#import \"MV${name_camel_case}Messages.h\"\n}}\n\n@class MVMavlink;\n@protocol MVMessage;\n\n@protocol MVMavlinkDelegate <NSObject>\n\n/*!\n Method called on the delegate when a full message has been received. Note that this may be called multiple times when parseData: is called, if the data passed to parseData: contains multiple messages.\n\n @param mavlink The MVMavlink object calling this method\n @param message The id<MVMessage> class containing the parsed message\n */\n- (void)mavlink:(MVMavlink *)mavlink didGetMessage:(id<MVMessage>)message;\n\n/*!\n Method called on the delegate when data should be sent.\n\n @param mavlink The MVMavlink object calling this method\n @param data NSData object containing the bytes to be sent\n */\n- (BOOL)mavlink:(MVMavlink *)mavlink shouldWriteData:(NSData *)data;\n\n@end\n\n/*!\n Class for parsing and sending instances of id<MVMessage>\n\n @discussion MVMavlink receives a stream of bytes via the parseData: method and calls the delegate method mavlink:didGetMessage: each time a message is fully parsed. Users of MVMavlink can call parseData: anytime they get new data, even if that data does not contain a complete message.\n */\n@interface MVMavlink : NSObject\n@property (weak, nonatomic) id<MVMavlinkDelegate> delegate;\n\n/*!\n Parse byte data received from a MAVLink byte stream.\n\n @param data NSData containing the received bytes\n */\n- (void)parseData:(NSData *)data;\n\n/*!\n Compile MVMessage object into a bytes and pass to the delegate for sending.\n\n @param message Object conforming to the MVMessage protocol that represents the data to be sent\n @return YES if message sending was successful\n */\n- (BOOL)sendMessage:(id<MVMessage>)message;\n\n@end\n''', xml)\n    f.close()\n    f = open(os.path.join(directory, \"MVMavlink.m\"), mode='w')\n    t.write(f,'''\n//\n//  MVMavlink.m\n//  MAVLink communications protocol built from ${basename}.xml\n//\n//  Created by mavgen_objc.py\n//  http://qgroundcontrol.org/mavlink\n//\n\n#import \"MVMavlink.h\"\n\n@implementation MVMavlink\n\n- (void)parseData:(NSData *)data {\n  mavlink_message_t msg;\n  mavlink_status_t status;\n  char *bytes = (char *)[data bytes];\n\n  for (NSInteger i = 0; i < [data length]; ++i) {\n    if (mavlink_parse_char(MAVLINK_COMM_0, bytes[i], &msg, &status)) {\n      // Packet received\n      id<MVMessage> message = [MVMessage messageWithCMessage:msg];\n      [_delegate mavlink:self didGetMessage:message];\n    }\n  }\n}\n\n- (BOOL)sendMessage:(id<MVMessage>)message {\n  return [_delegate mavlink:self shouldWriteData:[message data]];\n}\n\n@end\n''', xml)\n    f.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate per - message header and implementation file", "response": "def generate_message(directory, m):\n    '''generate per-message header and implementation file'''\n    f = open(os.path.join(directory, 'MVMessage%s.h' % m.name_camel_case), mode='w')\n    t.write(f, '''\n//\n//  MVMessage${name_camel_case}.h\n//  MAVLink communications protocol built from ${basename}.xml\n//\n//  Created by mavgen_objc.py\n//  http://qgroundcontrol.org/mavlink\n//\n\n#import \"MVMessage.h\"\n\n/*!\n Class that represents a ${name} Mavlink message.\n\n @discussion ${description}\n */\n@interface MVMessage${name_camel_case} : MVMessage\n\n- (id)initWithSystemId:(uint8_t)systemId componentId:(uint8_t)componentId${{arg_fields: ${name_lower_camel_case}:(${arg_type}${array_prefix})${name_lower_camel_case}}};\n\n${{fields://! ${description}\n- (${return_type})${name_lower_camel_case}${get_arg_objc};\n\n}}\n@end\n''', m)\n    f.close()\n    f = open(os.path.join(directory, 'MVMessage%s.m' % m.name_camel_case), mode='w')\n    t.write(f, '''\n//\n//  MVMessage${name_camel_case}.m\n//  MAVLink communications protocol built from ${basename}.xml\n//\n//  Created by mavgen_objc.py\n//  http://qgroundcontrol.org/mavlink\n//\n\n#import \"MVMessage${name_camel_case}.h\"\n\n@implementation MVMessage${name_camel_case}\n\n- (id)initWithSystemId:(uint8_t)systemId componentId:(uint8_t)componentId${{arg_fields: ${name_lower_camel_case}:(${arg_type}${array_prefix})${name_lower_camel_case}}} {\n  if ((self = [super init])) {\n    mavlink_msg_${name_lower}_pack(systemId, componentId, &(self->_message)${{arg_fields:, ${name_lower_camel_case}}});\n  }\n  return self;\n}\n\n${{fields:- (${return_type})${name_lower_camel_case}${get_arg_objc} {\n  ${return_method_implementation}\n}\n\n}}\n- (NSString *)description {\n  return [NSString stringWithFormat:@\"%@${{fields:, ${name_lower_camel_case}=${print_format}}}\", [super description]${{fields:, ${get_message}}}];\n}\n\n@end\n''', m)\n    f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a CamelCase string from an underscore_string.", "response": "def camel_case_from_underscores(string):\n    \"\"\"generate a CamelCase string from an underscore_string.\"\"\"\n    components = string.split('_')\n    string = ''\n    for component in components:\n        string += component[0].upper() + component[1:]\n    return string"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lower_camel_case_from_underscores(string):\n    components = string.split('_')\n    string = components[0]\n    for component in components[1:]:\n        string += component[0].upper() + component[1:]\n    return string", "response": "generate a lower - cased camelCase string from an underscore_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_message_definitions(basename, xml):\n    '''generate files for one XML file'''\n\n    directory = os.path.join(basename, xml.basename)\n\n    print(\"Generating Objective-C implementation in directory %s\" % directory)\n    mavparse.mkdir_p(directory)\n\n    xml.basename_camel_case = camel_case_from_underscores(xml.basename)\n\n    # Add some extra field attributes for convenience\n    for m in xml.message:\n        m.basename = xml.basename\n        m.parse_time = xml.parse_time\n        m.name_camel_case = camel_case_from_underscores(m.name_lower)\n        for f in m.fields:\n            f.name_lower_camel_case = lower_camel_case_from_underscores(f.name);\n            f.get_message = \"[self %s]\" % f.name_lower_camel_case\n            f.return_method_implementation = ''\n            f.array_prefix = ''\n            f.array_return_arg = ''\n            f.get_arg = ''\n            f.get_arg_objc = ''\n            if f.enum:\n                f.return_type = f.enum\n                f.arg_type = f.enum\n            else:\n                f.return_type = f.type\n                f.arg_type = f.type\n            if f.print_format is None:\n                if f.array_length != 0:\n                    f.print_format = \"%@\"\n                elif f.type.startswith('uint64_t'):\n                    f.print_format = \"%lld\"\n                elif f.type.startswith('uint') or f.type.startswith('int'):\n                    f.print_format = \"%d\"\n                elif f.type.startswith('float'):\n                    f.print_format = \"%f\"\n                elif f.type.startswith('char'):\n                    f.print_format = \"%c\"\n                else:\n                    print(\"print_format unsupported for type %s\" % f.type)\n            if f.array_length != 0:\n                f.get_message = '@\"[array of %s[%d]]\"' % (f.type, f.array_length)\n                f.array_prefix = ' *'\n                f.array_return_arg = '%s, %u, ' % (f.name, f.array_length)\n                f.return_type = 'uint16_t'\n                f.get_arg = ', %s' % (f.name)\n                f.get_arg_objc = ':(%s *)%s' % (f.type, f.name)\n                if f.type == 'char':\n                    # Special handling for strings (assumes all char arrays are strings)\n                    f.return_type = 'NSString *'\n                    f.get_arg_objc = ''\n                    f.get_message = \"[self %s]\" % f.name_lower_camel_case\n                    f.return_method_implementation = \\\n\"\"\"char string[%(array_length)d];\n  mavlink_msg_%(message_name_lower)s_get_%(name)s(&(self->_message), (char *)&string);\n  return [[NSString alloc] initWithBytes:string length:%(array_length)d encoding:NSASCIIStringEncoding];\"\"\" % {'array_length': f.array_length, 'message_name_lower': m.name_lower, 'name': f.name}\n\n            if not f.return_method_implementation:\n                f.return_method_implementation = \\\n\"\"\"return mavlink_msg_%(message_name_lower)s_get_%(name)s(&(self->_message)%(get_arg)s);\"\"\" % {'message_name_lower': m.name_lower, 'name': f.name, 'get_arg': f.get_arg}\n\n    for m in xml.message:\n        m.arg_fields = []\n        for f in m.fields:\n            if not f.omit_arg:\n                m.arg_fields.append(f)\n \n    generate_message_definitions_h(directory, xml)\n    for m in xml.message:\n        generate_message(directory, m)", "response": "generate files for one XML file"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate(basename, xml_list):\n    '''generate complete MAVLink Objective-C implemenation'''\n\n    generate_shared(basename, xml_list)\n    for xml in xml_list:\n        generate_message_definitions(basename, xml)", "response": "generate complete MAVLink Objective - C implemenation"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntranslates a CMDVel to a Twist.", "response": "def cmdvel2Twist(vel):\n    '''\n    Translates from JderobotTypes CMDVel to ROS Twist. \n\n    @param vel: JderobotTypes CMDVel to translate\n\n    @type img: JdeRobotTypes.CMDVel\n\n    @return a Twist translated from vel\n\n    '''\n    tw = TwistStamped()\n    tw.twist.linear.x = vel.vx\n    tw.twist.linear.y = vel.vy\n    tw.twist.linear.z = vel.vz\n    tw.twist.angular.x = vel.ax\n    tw.twist.angular.y = vel.ay\n    tw.twist.angular.z = vel.az\n\n    return tw"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning to publish cmdvel.", "response": "def publish (self):\n        '''\n        Function to publish cmdvel. \n        '''\n        self.lock.acquire()\n        tw = cmdvel2Twist(self.vel)\n        self.lock.release()\n        if (self.jdrc.getState() == \"flying\"):\n            self.pub.publish(tw)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding some data to the graph", "response": "def add_values(self, values):\n        '''add some data to the graph'''\n        if self.child.is_alive():\n            self.parent_pipe.send(values)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef magfit(logfile):\n    '''find best magnetometer offset fit to a log file'''\n    print(\"Processing log %s\" % filename)\n    mlog = mavutil.mavlink_connection(filename, notimestamps=args.notimestamps)\n\n    flying = False\n    gps_heading = 0.0\n\n    data = []\n\n    # get the current mag offsets\n    m = mlog.recv_match(type='SENSOR_OFFSETS',condition=args.condition)\n    offsets = vec3(m.mag_ofs_x, m.mag_ofs_y, m.mag_ofs_z)\n\n    attitude = mlog.recv_match(type='ATTITUDE',condition=args.condition)\n\n    # now gather all the data\n    while True:\n        m = mlog.recv_match(condition=args.condition)\n        if m is None:\n            break\n        if m.get_type() == \"GPS_RAW\":\n            # flying if groundspeed more than 5 m/s\n            flying = (m.v > args.minspeed and m.fix_type == 2)\n            gps_heading = m.hdg\n        if m.get_type() == \"GPS_RAW_INT\":\n            # flying if groundspeed more than 5 m/s\n            flying = (m.vel/100 > args.minspeed and m.fix_type == 3)\n            gps_heading = m.cog/100\n        if m.get_type() == \"ATTITUDE\":\n            attitude = m\n        if m.get_type() == \"SENSOR_OFFSETS\":\n            # update current offsets\n            offsets = vec3(m.mag_ofs_x, m.mag_ofs_y, m.mag_ofs_z)\n        if not flying:\n            continue\n        if m.get_type() == \"RAW_IMU\":\n            data.append((m.xmag - offsets.x, m.ymag - offsets.y, m.zmag - offsets.z, attitude.roll, attitude.pitch, gps_heading))\n    print(\"Extracted %u data points\" % len(data))\n    print(\"Current offsets: %s\" % offsets)\n    ofs2 = fit_data(data)\n    print(\"Declination estimate: %.1f\" % ofs2[-1])\n    new_offsets = vec3(ofs2[0], ofs2[1], ofs2[2])\n    a = [[ofs2[3], ofs2[4], ofs2[5]],\n         [ofs2[6], ofs2[7], ofs2[8]],\n         [ofs2[9], ofs2[10], ofs2[11]]]\n    print(a)\n    print(\"New offsets    : %s\" % new_offsets)", "response": "find best magnetometer offset fit to a log file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a header with source files list and creation date", "response": "def generate_header(outf, filelist, xml):\n    \"\"\"Generate Swift file header with source files list and creation date\"\"\"\n\n    print(\"Generating Swift file header\")\n\n    t.write(outf, \"\"\"\n//\n//  MAVLink.swift\n//  MAVLink Micro Air Vehicle Communication Protocol\n//\n//  Generated from ${FILELIST} on ${PARSE_TIME} by mavgen_swift.py \n//  http://qgroundcontrol.org/mavlink/start\n//\n\nimport Foundation\n\n\n/**\n    Common protocol for all MAVLink entities which describes type metadata properties\n*/\npublic protocol MAVLinkEntity: CustomStringConvertible, CustomDebugStringConvertible {\n    \n    /// Original MAVLink enum name (from declarations xml)\n    static var typeName: String { get }\n\n    /// Compact type description\n    static var typeDescription: String { get }\n\n    /// Verbose type description\n    static var typeDebugDescription: String { get }\n}\n\n\n// MARK: MAVLink enums\n\n\n/**\n    Enum protocol description with common for all MAVLink enums property requirements\n*/\npublic protocol Enum: RawRepresentable, Equatable, MAVLinkEntity {\n\n    /// Array with all members of current enum\n    static var allMembers: [Self] { get }\n\n    // Array with `Name` - `Description` tuples (values from declarations xml file)\n    static var membersInfo: [(String, String)] { get }\n\n    /// Original MAVLinks enum member name (as declared in definitions xml file)\n    var memberName: String { get }\n\n    /// Specific member description from definitions xml\n    var memberDescription: String { get }\n}\n\n\n/**\n    Enum protocol default implementations\n*/\nextension Enum {\n    public static var typeDebugDescription: String {\n        // It seems Xcode 7 beta does not support default protocol implementations for type methods.\n        // Calling this method without specific implementations inside enums will cause following error on Xcode 7.0 beta (7A120f):\n        // \"Command failed due to signal: Illegal instruction: 4\"\n        let cases = \"\\\\n\\\\t\".join(allMembers.map { $0.debugDescription })\n        return \"Enum \\(typeName): \\(typeDescription)\\\\nMembers:\\\\n\\\\t\\(cases)\"\n    }\n    \n    public var description: String {\n        return memberName\n    }\n\n    public var debugDescription: String {\n        return \"\\(memberName): \\(memberDescription)\"\n    }\n    \n    public var memberName: String {\n        return Self.membersInfo[Self.allMembers.indexOf(self)!].0\n    }\n\n    public var memberDescription: String {\n        return Self.membersInfo[Self.allMembers.indexOf(self)!].1\n    }\n}\n\n\"\"\", {'FILELIST' : \", \".join(filelist),\n      'PARSE_TIME' : xml[0].parse_time})"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_enums(outf, enums, msgs):\n\n    print(\"Generating Enums\")\n\n    for enum in enums:\n        t.write(outf, \"\"\"\n${formatted_description}public enum ${swift_name}: ${raw_value_type}, Enum {\n${{entry:${formatted_description}\\tcase ${swift_name} = ${value}\\n}}\n}\n\nextension ${swift_name} {\n    public static var typeName = \"${name}\"\n    public static var typeDescription = \"${entity_description}\"\n    public static var typeDebugDescription: String {\n        let cases = \"\\\\n\\\\t\".join(allMembers.map { $0.debugDescription })\n        return \"Enum \\(typeName): \\(typeDescription)\\\\nMembers:\\\\n\\\\t\\(cases)\"\n    }\n    public static var allMembers = [${all_entities}]\n    public static var membersInfo = [${entities_info}]\n}\n\n\"\"\", enum)", "response": "Iterate through all enums and create Swift equivalents"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching appropirate raw type for enums in messages fields", "response": "def get_enum_raw_type(enum, msgs):\n    \"\"\"Search appropirate raw type for enums in messages fields\"\"\"\n\n    for msg in msgs:\n        for field in msg.fields:\n            if  field.enum == enum.name:\n                return swift_types[field.type][0]\n    return \"Int\""}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates Swift structs to represent all MAVLink messages", "response": "def generate_messages(outf, msgs):\n    \"\"\"Generate Swift structs to represent all MAVLink messages\"\"\"\n\n    print(\"Generating Messages\")\n\n    t.write(outf, \"\"\"\n\n// MARK: MAVLink messages\n\n\n/**\n    Message protocol describes common for all MAVLink messages properties and methods requirements\n*/\npublic protocol Message: MAVLinkEntity {\n\n    /**\n        Initialize Message from received data\n\n        - Warning: Throws `ParserError` or `ParserEnumError` if any parsing error occurred\n    */\n    init(data: NSData) throws\n\n    /// Array of tuples with fields name, offset, type and description information\n    static var fieldsInfo: [(String, Int, String, String)] { get }\n\n    /// All fields names and values of current Message\n    var allFields: [(String, Any)] { get }\n}\n\n\n/**\n    Message protocol default implementations\n*/\nextension Message {\n    public static var typeDebugDescription: String {\n        // It seems Xcode 7 beta does not support default protocol implementations for type methods.\n        // Calling this method without specific implementations inside messages will cause following error in Xcode 7.0 beta (7A120f):\n        // \"Command failed due to signal: Illegal instruction: 4\"\n        let fields = \"\\\\n\\\\t\".join(fieldsInfo.map { \"\\($0.0): \\($0.2): \\($0.3)\" })\n        return \"Struct \\(typeName): \\(typeDescription)\\\\nFields:\\\\n\\\\t\\(fields)\"\n    }\n\n    public var description: String {\n        let describeField: ((String, Any)) -> String = { (let name, var value) in\n            value = value is String ? \"\\\\\"\\(value)\\\\\"\" : value\n            return \"\\(name): \\(value)\"\n        }\n        let fieldsDescription = \", \".join(allFields.map(describeField))\n        return \"\\(self.dynamicType)(\\(fieldsDescription))\"\n    }\n\n    public var debugDescription: String {\n        let describeFieldVerbose: ((String, Any)) -> String = { (let name, var value) in\n            value = value is String ? \"\\\\\"\\(value)\\\\\"\" : value\n            let (_, _, _, description) = Self.fieldsInfo.filter { $0.0 == name }.first!\n            return \"\\(name) = \\(value) : \\(description)\"\n        }\n        let fieldsDescription = \"\\\\n\\\\t\".join(allFields.map(describeFieldVerbose))\n        return \"\\(Self.typeName): \\(Self.typeDescription)\\\\nFields:\\\\n\\\\t\\(fieldsDescription)\"\n    }\n\n    public var allFields: [(String, Any)] {\n        var result: [(String, Any)] = []\n        let mirror = reflect(self)\n        for i in 0..<mirror.count {\n            result.append((mirror[i].0, mirror[i].1.value))\n        }\n        return result\n    }\n}\n\n\"\"\")\n\n    for msg in msgs:\n        t.write(outf, \"\"\"\n${formatted_description}public struct ${swift_name}: Message {\n${{fields:${formatted_description}\\tpublic let ${swift_name}: ${return_type}\\n}}\n\n    public init(data: NSData) throws {\n${{ordered_fields:\\t\\tself.${swift_name} = ${initial_value}\\n}}\n    }\n}\n\nextension ${swift_name} {\n    public static var typeName = \"${name}\"\n    public static var typeDescription = \"${message_description}\"\n    public static var typeDebugDescription: String {\n        let fields = \"\\\\n\\\\t\".join(fieldsInfo.map { \"\\($0.0): \\($0.2): \\($0.3)\" })\n        return \"Struct \\(typeName): \\(typeDescription)\\\\nFields:\\\\n\\\\t\\(fields)\"\n    }\n    public static var fieldsInfo = [${fields_info}]\n}\n\n\"\"\", msg)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef append_static_code(filename, outf):\n\n    basepath = os.path.dirname(os.path.realpath(__file__))\n    filepath = os.path.join(basepath, 'swift/%s' % filename)\n    \n    print(\"Appending content of %s\" % filename)\n    \n    with open(filepath) as inf:\n        for line in inf:\n            outf.write(line)", "response": "Append static code from specified file to specified file"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating array for mapping message Ids to proper structs", "response": "def generate_message_mappings_array(outf, msgs):\n    \"\"\"Create array for mapping message Ids to proper structs\"\"\"\n\n    classes = []\n    for msg in msgs:\n        classes.append(\"%u: %s.self\" % (msg.id, msg.swift_name))\n    t.write(outf, \"\"\"\n\n\n\n/**\n    Array for mapping message id to proper struct\n*/\nprivate let messageIdToClass: [UInt8: Message.Type] = [${ARRAY_CONTENT}]\n\"\"\", {'ARRAY_CONTENT' : \", \".join(classes)})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating array with message lengths to validate known message lengths", "response": "def generate_message_lengths_array(outf, msgs):\n    \"\"\"Create array with message lengths to validate known message lengths\"\"\"\n\n    # form message lengths array\n    lengths = []\n    for msg in msgs:\n        lengths.append(\"%u: %u\" % (msg.id, msg.wire_length))\n\n    t.write(outf, \"\"\"\n\n\n/**\n    Message lengths array for known messages length validation\n*/\nprivate let messageLengths: [UInt8: UInt8] = [${ARRAY_CONTENT}]\n\"\"\", {'ARRAY_CONTENT' : \", \".join(lengths)})"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_message_crc_extra_array(outf, msgs):\n\n    crcs = []\n    for msg in msgs:\n        crcs.append(\"%u: %u\" % (msg.id, msg.crc_extra))\n\n    t.write(outf, \"\"\"\n\n\n/**\n    Message CRSs extra for detection incompatible XML changes\n*/\nprivate let messageCrcsExtra: [UInt8: UInt8] = [${ARRAY_CONTENT}]\n\"\"\", {'ARRAY_CONTENT' : \", \".join(crcs)})", "response": "Generate array with CRC extra values for detection incompatible XML changes"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a CamelCase string from an underscore_string", "response": "def camel_case_from_underscores(string):\n    \"\"\"Generate a CamelCase string from an underscore_string\"\"\"\n\n    components = string.split('_')\n    string = ''\n\n    for component in components:\n        if component in abbreviations:\n            string += component\n        else:\n            string += component[0].upper() + component[1:].lower()\n\n    return string"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_enums_info(enums, msgs):\n\n    for enum in enums:\n        enum.swift_name = camel_case_from_underscores(enum.name)\n        enum.raw_value_type = get_enum_raw_type(enum, msgs)\n\n        enum.formatted_description = \"\"\n        if enum.description:\n            enum.description = \" \".join(enum.description.split())\n            enum.formatted_description = \"\\n/**\\n    %s\\n*/\\n\" % enum.description\n\n        all_entities = []\n        entities_info = []\n\n        for entry in enum.entry:\n            name = entry.name.replace(enum.name + '_', '')\n            \"\"\"Ensure that enums entry name does not start from digit\"\"\"\n            if name[0].isdigit():\n                name = \"MAV_\" + name\n            entry.swift_name = camel_case_from_underscores(name)\n            \n            entry.formatted_description = \"\"\n            if entry.description:\n                entry.description = \" \".join(entry.description.split())\n                entry.formatted_description = \"\\n\\t/// \" + entry.description + \"\\n\"\n\n            all_entities.append(entry.swift_name)\n            entities_info.append('(\"%s\", \"%s\")' % (entry.name, entry.description.replace('\"','\\\\\"')))\n\n        enum.all_entities = \", \".join(all_entities)\n        enum.entities_info = \", \".join(entities_info)\n        enum.entity_description = enum.description.replace('\"','\\\\\"')\n\n    enums.sort(key = lambda enum : enum.swift_name)", "response": "Generate the enumeration information for the given list of enums."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_messages_info(msgs):\n\n    for msg in msgs:\n        msg.swift_name = camel_case_from_underscores(msg.name)\n\n        msg.formatted_description = \"\"\n        if msg.description:\n            msg.description = \" \".join(msg.description.split())\n            msg.formatted_description = \"\\n/**\\n    %s\\n*/\\n\" % \" \".join(msg.description.split())\n        msg.message_description = msg.description.replace('\"','\\\\\"')\n\n        for field in msg.ordered_fields:\n            field.swift_name = lower_camel_case_from_underscores(field.name)\n            field.return_type = swift_types[field.type][0]\n            \n            # configure fields initializers\n            if field.enum:\n                # handle enums\n                field.return_type = camel_case_from_underscores(field.enum)\n                field.initial_value = \"try data.mavEnumeration(offset: %u)\" % field.wire_offset\n            elif field.array_length > 0:\n                if field.return_type == \"String\":\n                    # handle strings\n                    field.initial_value = \"data.\" + swift_types[field.type][2] % (field.wire_offset, field.array_length)\n                else:\n                    # other array types\n                    field.return_type = \"[%s]\" % field.return_type\n                    field.initial_value = \"try data.mavArray(offset: %u, count: %u)\" % (field.wire_offset, field.array_length)\n            else:\n                # simple type field\n                field.initial_value = \"try data.\" + swift_types[field.type][2] % field.wire_offset\n            \n            field.formatted_description = \"\"\n            if field.description:\n                field.description = \" \".join(field.description.split())\n                field.formatted_description = \"\\n\\t/// \" + field.description + \"\\n\"\n         \n        fields_info = map(lambda field: '(\"%s\", %u, \"%s\", \"%s\")' % (field.swift_name, field.wire_offset, field.return_type, field.description.replace('\"','\\\\\"')), msg.fields)\n        msg.fields_info = \", \".join(fields_info)\n\n    msgs.sort(key = lambda msg : msg.id)", "response": "Generate the message info for the current language of the current language of the current language of the current language of the current language of the current language of the current language."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate(basename, xml_list):\n\n    if os.path.isdir(basename):\n        filename = os.path.join(basename, 'MAVLink.swift')\n    else:\n        filename = basename\n\n    msgs = []\n    enums = []\n    filelist = []\n    for xml in xml_list:\n        msgs.extend(xml.message)\n        enums.extend(xml.enum)\n        filelist.append(os.path.basename(xml.filename))\n    \n    outf = open(filename, \"w\")\n    generate_header(outf, filelist, xml_list)\n    generate_enums_info(enums, msgs)\n    generate_enums(outf, enums, msgs)\n    generate_messages_info(msgs)\n    generate_messages(outf, msgs)\n    append_static_code('Parser.swift', outf)\n    generate_message_mappings_array(outf, msgs)\n    generate_message_lengths_array(outf, msgs)\n    generate_message_crc_extra_array(outf, msgs)\n    outf.close()", "response": "Generate a complete MAVLink Swift implemenation"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the object with the current values of the object s properties.", "response": "def update(self):\n        '''\n        Updates LaserData.\n        '''\n        if self.hasproxy():\n            sonarD = SonarData()\n            range = 0\n            data = self.proxy.getSonarData()\n\n            sonarD.range = data.range\n            sonarD.maxAngle = data.maxAngle\n            sonarD.minAngle = data.minAngle\n            sonarD.maxRange = data.maxRange\n            sonarD.minRange = data.minRange\n\n\n            self.lock.acquire()\n            self.sonar = sonarD\n            self.lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getSonarData(self):\n        '''\n        Returns last LaserData. \n\n        @return last JdeRobotTypes LaserData saved\n\n        '''     \n        if self.hasproxy():\n            self.lock.acquire()\n            sonar = self.sonar\n            self.lock.release()\n            return sonar\n\n        return None", "response": "Returns last sonar data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wp_is_loiter(self, i):\n        '''return true if waypoint is a loiter waypoint'''\n        loiter_cmds = [mavutil.mavlink.MAV_CMD_NAV_LOITER_UNLIM,\n                mavutil.mavlink.MAV_CMD_NAV_LOITER_TURNS,\n                mavutil.mavlink.MAV_CMD_NAV_LOITER_TIME,\n                mavutil.mavlink.MAV_CMD_NAV_LOITER_TO_ALT]\n\n        if (self.wpoints[i].command in loiter_cmds):\n            return True    \n\n        return False", "response": "return true if waypoint is a loiter waypoint"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_latlonalt(self, lat, lon, altitude, terrain_alt=False):\n        '''add a point via latitude/longitude/altitude'''\n        if terrain_alt:\n            frame = mavutil.mavlink.MAV_FRAME_GLOBAL_TERRAIN_ALT\n        else:\n            frame = mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT\n        p = mavutil.mavlink.MAVLink_mission_item_message(self.target_system,\n                                                         self.target_component,\n                                                         0,\n                                                         frame,\n                                                         mavutil.mavlink.MAV_CMD_NAV_WAYPOINT,\n                                                         0, 0, 0, 0, 0, 0,\n                                                         lat, lon, altitude)\n        self.add(p)", "response": "add a point via latitude / longitude and altitude"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(self, w, idx):\n        '''set a waypoint'''\n        w.seq = idx\n        if w.seq == self.count():\n            return self.add(w)\n        if self.count() <= idx:\n            raise MAVWPError('adding waypoint at idx=%u past end of list (count=%u)' % (idx, self.count()))\n        self.wpoints[idx] = w\n        self.last_change = time.time()", "response": "set a waypoint w. seq idx"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _read_waypoints_v100(self, file):\n        '''read a version 100 waypoint'''\n        cmdmap = {\n            2 : mavutil.mavlink.MAV_CMD_NAV_TAKEOFF,\n            3 : mavutil.mavlink.MAV_CMD_NAV_RETURN_TO_LAUNCH,\n            4 : mavutil.mavlink.MAV_CMD_NAV_LAND,\n            24: mavutil.mavlink.MAV_CMD_NAV_TAKEOFF,\n            26: mavutil.mavlink.MAV_CMD_NAV_LAND,\n            25: mavutil.mavlink.MAV_CMD_NAV_WAYPOINT ,\n            27: mavutil.mavlink.MAV_CMD_NAV_LOITER_UNLIM\n            }\n        comment = ''\n        for line in file:\n            if line.startswith('#'):\n                comment = line[1:].lstrip()\n                continue\n            line = line.strip()\n            if not line:\n                continue\n            a = line.split()\n            if len(a) != 13:\n                raise MAVWPError(\"invalid waypoint line with %u values\" % len(a))\n            if mavutil.mavlink10():\n                fn = mavutil.mavlink.MAVLink_mission_item_message\n            else:\n                fn = mavutil.mavlink.MAVLink_waypoint_message\n            w = fn(self.target_system, self.target_component,\n                   int(a[0]),    # seq\n                   int(a[1]),    # frame\n                   int(a[2]),    # action\n                   int(a[7]),    # current\n                   int(a[12]),   # autocontinue\n                   float(a[5]),  # param1,\n                   float(a[6]),  # param2,\n                   float(a[3]),  # param3\n                   float(a[4]),  # param4\n                   float(a[9]),  # x, latitude\n                   float(a[8]),  # y, longitude\n                   float(a[10])  # z\n                   )\n            if not w.command in cmdmap:\n                raise MAVWPError(\"Unknown v100 waypoint action %u\" % w.command)\n\n            w.command = cmdmap[w.command]\n            self.add(w, comment)\n            comment = ''", "response": "read a version 100 waypoint"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _read_waypoints_v110(self, file):\n        '''read a version 110 waypoint'''\n        comment = ''\n        for line in file:\n            if line.startswith('#'):\n                comment = line[1:].lstrip()\n                continue\n            line = line.strip()\n            if not line:\n                continue\n            a = line.split()\n            if len(a) != 12:\n                raise MAVWPError(\"invalid waypoint line with %u values\" % len(a))\n            if mavutil.mavlink10():\n                fn = mavutil.mavlink.MAVLink_mission_item_message\n            else:\n                fn = mavutil.mavlink.MAVLink_waypoint_message\n            w = fn(self.target_system, self.target_component,\n                   int(a[0]),    # seq\n                   int(a[2]),    # frame\n                   int(a[3]),    # command\n                   int(a[1]),    # current\n                   int(a[11]),   # autocontinue\n                   float(a[4]),  # param1,\n                   float(a[5]),  # param2,\n                   float(a[6]),  # param3\n                   float(a[7]),  # param4\n                   float(a[8]),  # x (latitude)\n                   float(a[9]),  # y (longitude)\n                   float(a[10])  # z (altitude)\n                   )\n            if w.command == 0 and w.seq == 0 and self.count() == 0:\n                # special handling for Mission Planner created home wp\n                w.command = mavutil.mavlink.MAV_CMD_NAV_WAYPOINT\n            self.add(w, comment)\n            comment = ''", "response": "read a version 110 waypoint"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload waypoints from a file. Returns number of waypoints loaded", "response": "def load(self, filename):\n        '''load waypoints from a file.\n        returns number of waypoints loaded'''\n        f = open(filename, mode='r')\n        version_line = f.readline().strip()\n        if version_line == \"QGC WPL 100\":\n            readfn = self._read_waypoints_v100\n        elif version_line == \"QGC WPL 110\":\n            readfn = self._read_waypoints_v110\n        elif version_line == \"QGC WPL PB 110\":\n            readfn = self._read_waypoints_pb_110\n        else:\n            f.close()\n            raise MAVWPError(\"Unsupported waypoint format '%s'\" % version_line)\n\n        self.clear()\n        readfn(f)\n        f.close()\n\n        return len(self.wpoints)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self, filename):\n        '''save waypoints to a file'''\n        f = open(filename, mode='w')\n        f.write(\"QGC WPL 110\\n\")\n        for w in self.wpoints:\n            if getattr(w, 'comment', None):\n                f.write(\"# %s\\n\" % w.comment)\n            f.write(\"%u\\t%u\\t%u\\t%u\\t%f\\t%f\\t%f\\t%f\\t%f\\t%f\\t%f\\t%u\\n\" % (\n                w.seq, w.current, w.frame, w.command,\n                w.param1, w.param2, w.param3, w.param4,\n                w.x, w.y, w.z, w.autocontinue))\n        f.close()", "response": "save waypoints to a file"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsee if the command is a MAV_CMD with a latitide / longitude.", "response": "def is_location_command(self, cmd):\n        '''see if cmd is a MAV_CMD with a latitide/longitude.\n        We check if it has Latitude and Longitude params in the right indexes'''\n        mav_cmd = mavutil.mavlink.enums['MAV_CMD']\n        if not cmd in mav_cmd:\n            return False\n        if not mav_cmd[cmd].param.get(5,'').startswith('Latitude'):\n            return False\n        if not mav_cmd[cmd].param.get(6,'').startswith('Longitude'):\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef view_indexes(self, done=None):\n        '''return a list waypoint indexes in view order'''\n        ret = []\n        if done is None:\n            done = set()\n        idx = 0\n\n        # find first point not done yet\n        while idx < self.count():\n            if not idx in done:\n                break\n            idx += 1\n            \n        while idx < self.count():\n            w = self.wp(idx)\n            if idx in done:\n                if w.x != 0 or w.y != 0:\n                    ret.append(idx)\n                break\n            done.add(idx)\n            if w.command == mavutil.mavlink.MAV_CMD_DO_JUMP:\n                idx = int(w.param1)\n                w = self.wp(idx)\n                if w.x != 0 or w.y != 0:\n                    ret.append(idx)\n                continue\n            if (w.x != 0 or w.y != 0) and self.is_location_command(w.command):\n                ret.append(idx)\n            idx += 1\n        return ret", "response": "return a list waypoint indexes in view order"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef polygon(self, done=None):\n        '''return a polygon for the waypoints'''\n        indexes = self.view_indexes(done)\n        points = []\n        for idx in indexes:\n            w = self.wp(idx)\n            points.append((w.x, w.y))\n        return points", "response": "return a polygon for the waypoints"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of polygons for the waypoints", "response": "def polygon_list(self):\n        '''return a list of polygons for the waypoints'''\n        done = set()\n        ret = []\n        while len(done) != self.count():\n            p = self.polygon(done)\n            if len(p) > 0:\n                ret.append(p)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef view_list(self):\n        '''return a list of polygon indexes lists for the waypoints'''\n        done = set()\n        ret = []\n        while len(done) != self.count():\n            p = self.view_indexes(done)\n            if len(p) > 0:\n                ret.append(p)\n        return ret", "response": "return a list of polygon indexes lists for the waypoints"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresetting counters and indexes", "response": "def reindex(self):\n        '''reset counters and indexes'''\n        for i in range(self.rally_count()):\n            self.rally_points[i].count = self.rally_count()\n            self.rally_points[i].idx = i\n        self.last_change = time.time()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef append_rally_point(self, p):\n        '''add rallypoint to end of list'''\n        if (self.rally_count() > 9):\n           print(\"Can't have more than 10 rally points, not adding.\")\n           return\n\n        self.rally_points.append(p)\n        self.reindex()", "response": "add rallypoint to end of list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_and_append_rally_point(self, lat, lon, alt, break_alt, land_dir, flags):\n        '''add a point via latitude/longitude'''\n        p = mavutil.mavlink.MAVLink_rally_point_message(self.target_system, self.target_component,\n                                                        self.rally_count(), 0, lat, lon, alt, break_alt, land_dir, flags)\n        self.append_rally_point(p)", "response": "create a point via latitude and longitude"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves a rally point", "response": "def remove(self, i):\n        '''remove a rally point'''\n        if i < 1 or i > self.rally_count():\n            print(\"Invalid rally point number %u\" % i)\n        self.rally_points.pop(i-1)\n        self.reindex()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef move(self, i, lat, lng, change_time=True):\n        '''move a rally point'''\n        if i < 1 or i > self.rally_count():\n            print(\"Invalid rally point number %u\" % i)\n        self.rally_points[i-1].lat = int(lat*1e7)\n        self.rally_points[i-1].lng = int(lng*1e7)\n        if change_time:\n            self.last_change = time.time()", "response": "move a rally point"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_alt(self, i, alt, break_alt=None, change_time=True):\n        '''set rally point altitude(s)'''\n        if i < 1 or i > self.rally_count():\n            print(\"Inavlid rally point number %u\" % i)\n            return\n        self.rally_points[i-1].alt = int(alt)\n        if (break_alt != None):\n            self.rally_points[i-1].break_alt = break_alt\n        if change_time:\n            self.last_change = time.time()", "response": "set rally point altitude"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads rally and rally_land points from a file.", "response": "def load(self, filename):\n        '''load rally and rally_land points from a file.\n         returns number of points loaded'''\n        f = open(filename, mode='r')\n        self.clear()\n        for line in f:\n            if line.startswith('#'):\n                continue\n            line = line.strip()\n            if not line:\n                continue\n            a = line.split()\n            if len(a) != 7:\n                raise MAVRallyError(\"invalid rally file line: %s\" % line)\n\n            if (a[0].lower() == \"rally\"):\n                self.create_and_append_rally_point(float(a[1]) * 1e7, float(a[2]) * 1e7,\n                                                   float(a[3]), float(a[4]), float(a[5]) * 100.0, int(a[6]))\n        f.close()\n        return len(self.rally_points)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, filename):\n        '''save fence points to a file'''\n        f = open(filename, mode='w')\n        for p in self.rally_points:\n            f.write(\"RALLY %f\\t%f\\t%f\\t%f\\t%f\\t%d\\n\" % (p.lat * 1e-7, p.lng * 1e-7, p.alt,\n                                                        p.break_alt, p.land_dir, p.flags))\n        f.close()", "response": "save fence points to a file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_latlon(self, lat, lon):\n        '''add a point via latitude/longitude'''\n        p = mavutil.mavlink.MAVLink_fence_point_message(self.target_system, self.target_component,\n                                                        self.count(), 0, lat, lon)\n        self.add(p)", "response": "add a point via latitude and longitude"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(self, filename):\n        '''load points from a file.\n        returns number of points loaded'''\n        f = open(filename, mode='r')\n        self.clear()\n        for line in f:\n            if line.startswith('#'):\n                continue\n            line = line.strip()\n            if not line:\n                continue\n            a = line.split()\n            if len(a) != 2:\n                raise MAVFenceError(\"invalid fence point line: %s\" % line)\n            self.add_latlon(float(a[0]), float(a[1]))\n        f.close()\n        return len(self.points)", "response": "load points from a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves fence points to a file", "response": "def save(self, filename):\n        '''save fence points to a file'''\n        f = open(filename, mode='w')\n        for p in self.points:\n            f.write(\"%f\\t%f\\n\" % (p.lat, p.lng))\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef move(self, i, lat, lng, change_time=True):\n        '''move a fence point'''\n        if i < 0 or i >= self.count():\n            print(\"Invalid fence point number %u\" % i)\n        self.points[i].lat = lat\n        self.points[i].lng = lng\n        # ensure we close the polygon\n        if i == 1:\n                self.points[self.count()-1].lat = lat\n                self.points[self.count()-1].lng = lng\n        if i == self.count() - 1:\n                self.points[1].lat = lat\n                self.points[1].lng = lng\n        if change_time:\n            self.last_change = time.time()", "response": "move a fence point"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove(self, i, change_time=True):\n        '''remove a fence point'''\n        if i < 0 or i >= self.count():\n            print(\"Invalid fence point number %u\" % i)\n        self.points.pop(i)\n         # ensure we close the polygon\n        if i == 1:\n                self.points[self.count()-1].lat = self.points[1].lat\n                self.points[self.count()-1].lng = self.points[1].lng\n        if i == self.count():\n                self.points[1].lat = self.points[self.count()-1].lat\n                self.points[1].lng = self.points[self.count()-1].lng\n        if change_time:\n            self.last_change = time.time()", "response": "remove a fence point from the list"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a polygon for the fence", "response": "def polygon(self):\n            '''return a polygon for the fence'''\n            points = []\n            for fp in self.points[1:]:\n                    points.append((fp.lat, fp.lng))\n            return points"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd some command input to be processed", "response": "def add_input(cmd, immediate=False):\n    '''add some command input to be processed'''\n    if immediate:\n        process_stdin(cmd)\n    else:\n        mpstate.input_queue.put(cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd_status(args):\n    '''show status'''\n    if len(args) == 0:\n        mpstate.status.show(sys.stdout, pattern=None)\n    else:\n        for pattern in args:\n            mpstate.status.show(sys.stdout, pattern=pattern)", "response": "show status of all the available resources"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clear_zipimport_cache():\n    import sys, zipimport\n    syspath_backup = list(sys.path)\n    zipimport._zip_directory_cache.clear()\n\n    # load back items onto sys.path\n    sys.path = syspath_backup\n    # add this too: see https://mail.python.org/pipermail/python-list/2005-May/353229.html\n    sys.path_importer_cache.clear()", "response": "Clear out cached entries from _zip_directory_cache.\n    See http://www. digi. com / wiki / index. php"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef import_package(name):\n    import zipimport\n    try:\n        mod = __import__(name)\n    except ImportError:\n        clear_zipimport_cache()\n        mod = __import__(name)\n\n    components = name.split('.')\n    for comp in components[1:]:\n        mod = getattr(mod, comp)\n    return mod", "response": "Given a package name like foo. bar. quux imports the package\n    and returns the desired module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_stdin(line):\n    '''handle commands from user'''\n    if line is None:\n        sys.exit(0)\n    # allow for modules to override input handling\n    if mpstate.functions.input_handler is not None:\n          mpstate.functions.input_handler(line)\n          return\n\n    line = line.strip()\n\n    if mpstate.status.setup_mode:\n        # in setup mode we send strings straight to the master\n        if line == '.':\n            mpstate.status.setup_mode = False\n            mpstate.status.flightmode = \"MAV\"\n            mpstate.rl.set_prompt(\"MAV> \")\n            return\n        if line != '+++':\n            line += '\\r'\n        for c in line:\n            time.sleep(0.01)\n            mpstate.master().write(c)\n        return\n\n    if not line:\n        return\n\n    args = shlex.split(line)\n    cmd = args[0]\n    while cmd in mpstate.aliases:\n        line = mpstate.aliases[cmd]\n        args = shlex.split(line) + args[1:]\n        cmd = args[0]\n\n    if cmd == 'help':\n        k = command_map.keys()\n        #k.sort()\n        for cmd in k:\n            (fn, help) = command_map[cmd]\n            print(\"%-15s : %s\" % (cmd, help))\n        return\n    if cmd == 'exit' and mpstate.settings.requireexit:\n        mpstate.status.exit = True\n        return\n    ######################################################################################################\n    if cmd == 'velocity' and len(args) == 4:\n        PH_CMDVel = CMDVelI(args[1],args[2],args[3],0,0,0) #1 to avoid indeterminations\n\n\n\n\n\n\n    ######################################################################################################\n    if not cmd in command_map:\n        for (m,pm) in mpstate.modules:\n            if hasattr(m, 'unknown_command'):\n                try:\n                    if m.unknown_command(args):\n                        return\n                except Exception as e:\n                    print(\"ERROR in command: %s\" % str(e))\n        print(\"Unknown command '%s'\" % line)\n        return\n\n    (fn, help) = command_map[cmd]\n    try:\n        fn(args[1:])\n    except Exception as e:\n        print(\"ERROR in command %s: %s\" % (args[1:], str(e)))\n        if mpstate.settings.moddebug > 1:\n            traceback.print_exc()", "response": "handle commands from user"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_master(m):\n    '''process packets from the MAVLink master'''\n    try:\n        s = m.recv(16*1024)\n    except Exception:\n        time.sleep(0.1)\n        return\n    # prevent a dead serial port from causing the CPU to spin. The user hitting enter will\n    # cause it to try and reconnect\n    if len(s) == 0:\n        time.sleep(0.1)\n        return\n\n    if (mpstate.settings.compdebug & 1) != 0:\n        return\n\n    if mpstate.logqueue_raw:\n        mpstate.logqueue_raw.put(str(s))\n\n    if mpstate.status.setup_mode:\n        if mpstate.system == 'Windows':\n           # strip nsh ansi codes\n           s = s.replace(\"\\033[K\",\"\")\n        sys.stdout.write(str(s))\n        sys.stdout.flush()\n        return\n\n    if m.first_byte and opts.auto_protocol:\n        m.auto_mavlink_version(s)\n    msgs = m.mav.parse_buffer(s)\n    if msgs:\n        for msg in msgs:\n            sysid = msg.get_srcSystem()\n            if sysid in mpstate.sysid_outputs:\n                  # the message has been handled by a specialised handler for this system\n                  continue\n            if getattr(m, '_timestamp', None) is None:\n                m.post_message(msg)\n            if msg.get_type() == \"BAD_DATA\":\n                if opts.show_errors:\n                    mpstate.console.writeln(\"MAV error: %s\" % msg)\n                mpstate.status.mav_error += 1", "response": "process packets from the MAVLink master"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_stream_rates():\n    '''set mavlink stream rates'''\n    if (not msg_period.trigger() and\n        mpstate.status.last_streamrate1 == mpstate.settings.streamrate and\n        mpstate.status.last_streamrate2 == mpstate.settings.streamrate2):\n        return\n    mpstate.status.last_streamrate1 = mpstate.settings.streamrate\n    mpstate.status.last_streamrate2 = mpstate.settings.streamrate2\n    for master in mpstate.mav_master:\n        if master.linknum == 0:\n            rate = mpstate.settings.streamrate\n        else:\n            rate = mpstate.settings.streamrate2\n        if rate != -1:\n            master.mav.request_data_stream_send(mpstate.settings.target_system, mpstate.settings.target_component,\n                                                mavutil.mavlink.MAV_DATA_STREAM_ALL,\n                                                rate, 1)", "response": "set mavlink stream rates"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck status of master links", "response": "def check_link_status():\n    '''check status of master links'''\n    tnow = time.time()\n    if mpstate.status.last_message != 0 and tnow > mpstate.status.last_message + 5:\n        say(\"no link\")\n        mpstate.status.heartbeat_error = True\n    for master in mpstate.mav_master:\n        if not master.linkerror and (tnow > master.last_message + 5 or master.portdead):\n            say(\"link %u down\" % (master.linknum+1))\n            master.linkerror = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning periodic checks on the Hz tree", "response": "def periodic_tasks():\n    '''run periodic checks'''\n    if mpstate.status.setup_mode:\n        return\n\n    if (mpstate.settings.compdebug & 2) != 0:\n        return\n\n    if mpstate.settings.heartbeat != 0:\n        heartbeat_period.frequency = mpstate.settings.heartbeat\n\n    if heartbeat_period.trigger() and mpstate.settings.heartbeat != 0:\n        mpstate.status.counters['MasterOut'] += 1\n        for master in mpstate.mav_master:\n            send_heartbeat(master)\n\n    if heartbeat_check_period.trigger():\n        check_link_status()\n\n    set_stream_rates()\n\n    # call optional module idle tasks. These are called at several hundred Hz\n    for (m,pm) in mpstate.modules:\n        if hasattr(m, 'idle_task'):\n            try:\n                m.idle_task()\n            except Exception as msg:\n                if mpstate.settings.moddebug == 1:\n                    print(msg)\n                elif mpstate.settings.moddebug > 1:\n                    exc_type, exc_value, exc_traceback = sys.exc_info()\n                    traceback.print_exception(exc_type, exc_value, exc_traceback,\n                                              limit=2, file=sys.stdout)\n\n        # also see if the module should be unloaded:\n        if m.needs_unloading:\n            unload_module(m.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwaits for user input", "response": "def input_loop():\n    '''wait for user input'''\n    global operation_takeoff\n    global time_init_operation_takeoff\n    global time_end_operation_takeoff\n\n    while mpstate.status.exit != True:\n        try:\n            if mpstate.status.exit != True:\n                if mpstate.udp.bound():\n                    line = mpstate.udp.readln()\n                    mpstate.udp.writeln(line)\n                elif mpstate.tcp.connected():\n                    line = mpstate.tcp.readln()\n                    mpstate.tcp.writeln(line)\n                else:\n                    line = input(mpstate.rl.prompt)\n            if line == 'takeoff':\n                print(\"Detecto takeoff\")\n                operation_takeoff=True\n                time_init_operation_takeoff = int(round(time.time() * 1000))\n                time_end_operation_takeoff = time_init_operation_takeoff + 5000\n                print(time_end_operation_takeoff)\n                mpstate.input_queue.put(\"arm throttle\")\n                return\n            if line == 'land':\n                print(\"Orden de aterrizar\")\n                on_air = False\n        except EOFError:\n            mpstate.status.exit = True\n            sys.exit(1)\n        mpstate.input_queue.put(line)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a script file", "response": "def run_script(scriptfile):\n    '''run a script file'''\n    try:\n        f = open(scriptfile, mode='r')\n    except Exception:\n        return\n    mpstate.console.writeln(\"Running script %s\" % scriptfile)\n    for line in f:\n        line = line.strip()\n        if line == \"\" or line.startswith('#'):\n            continue\n        if line.startswith('@'):\n            line = line[1:]\n        else:\n            mpstate.console.writeln(\"-> %s\" % line)\n        process_stdin(line)\n    f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite status to status. txt", "response": "def show(self, f, pattern=None):\n        '''write status to status.txt'''\n        if pattern is None:\n            f.write('Counters: ')\n            for c in self.counters:\n                f.write('%s:%s ' % (c, self.counters[c]))\n            f.write('\\n')\n            f.write('MAV Errors: %u\\n' % self.mav_error)\n            f.write(str(self.gps)+'\\n')\n        for m in sorted(self.msgs.keys()):\n            if pattern is not None and not fnmatch.fnmatch(str(m).upper(), pattern.upper()):\n                continue\n            f.write(\"%u: %s\\n\" % (self.msg_count[m], str(self.msgs[m])))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write(self):\n        '''write status to status.txt'''\n        f = open('status.txt', mode='w')\n        self.show(f)\n        f.close()", "response": "write status to status. txt"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef master(self):\n        '''return the currently chosen mavlink master object'''\n        if len(self.mav_master) == 0:\n              return None\n        if self.settings.link > len(self.mav_master):\n            self.settings.link = 1\n        # try to use one with no link error\n        if not self.mav_master[self.settings.link-1].linkerror:\n            return self.mav_master[self.settings.link-1]\n        for m in self.mav_master:\n            if not m.linkerror:\n                return m\n        return self.mav_master[self.settings.link-1]", "response": "return the currently chosen mavlink master object"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisplay fft for raw ACC data in logfile", "response": "def fft(logfile):\n    '''display fft for raw ACC data in logfile'''\n\n    print(\"Processing log %s\" % filename)\n    mlog = mavutil.mavlink_connection(filename)\n\n    data = {'ACC1.rate' : 1000,\n            'ACC2.rate' : 1600,\n            'ACC3.rate' : 1000,\n            'GYR1.rate' : 1000,\n            'GYR2.rate' :  800,\n            'GYR3.rate' : 1000}\n    for acc in ['ACC1','ACC2','ACC3']:\n        for ax in ['AccX', 'AccY', 'AccZ']:\n            data[acc+'.'+ax] = []\n    for gyr in ['GYR1','GYR2','GYR3']:\n        for ax in ['GyrX', 'GyrY', 'GyrZ']:\n            data[gyr+'.'+ax] = []\n\n    # now gather all the data\n    while True:\n        m = mlog.recv_match(condition=args.condition)\n        if m is None:\n            break\n        type = m.get_type()\n        if type.startswith(\"ACC\"):\n            data[type+'.AccX'].append(m.AccX)\n            data[type+'.AccY'].append(m.AccY)\n            data[type+'.AccZ'].append(m.AccZ)\n        if type.startswith(\"GYR\"):\n            data[type+'.GyrX'].append(m.GyrX)\n            data[type+'.GyrY'].append(m.GyrY)\n            data[type+'.GyrZ'].append(m.GyrZ)\n\n    print(\"Extracted %u data points\" % len(data['ACC1.AccX']))\n\n    for msg in ['ACC1', 'ACC2', 'ACC3', 'GYR1', 'GYR2', 'GYR3']:\n        pylab.figure()\n\n        if msg.startswith('ACC'):\n            prefix = 'Acc'\n        else:\n            prefix = 'Gyr'\n        for axis in ['X', 'Y', 'Z']:\n            field = msg + '.' + prefix + axis\n            d = data[field]\n            if args.sample_length != 0:\n                d = d[0:args.sample_length]\n            d = numpy.array(d)\n            if len(d) == 0:\n                continue\n            avg = numpy.sum(d) / len(d)\n            d -= avg\n            d_fft = numpy.fft.rfft(d)\n            freq  = numpy.fft.rfftfreq(len(d), 1.0 / data[msg+'.rate'])\n            pylab.plot( freq, numpy.abs(d_fft), label=field )\n        pylab.legend(loc='upper right')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate(basename, xml):\n    '''generate complete MAVLink CSharp implemenation'''\n    structsfilename = basename + '.generated.cs'\n   \n    msgs = []\n    enums = []\n    filelist = []\n    for x in xml:\n        msgs.extend(x.message)\n        enums.extend(x.enum)\n        filelist.append(os.path.basename(x.filename))\n\n    for m in msgs:\n        m.order_map = [ 0 ] * len(m.fieldnames)\n        for i in range(0, len(m.fieldnames)):\n            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])\n        \n        m.fields_in_order = []\n        for i in range(0, len(m.fieldnames)):\n            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])\n        \n    print(\"Generating messages file: %s\" % structsfilename)\n    dir = os.path.dirname(structsfilename)\n    if not os.path.exists(dir):\n        os.makedirs(dir)\n    outf = open(structsfilename, \"w\")\n    generate_preamble(outf, msgs, filelist, xml[0])\n    \n    outf.write(\"\"\"\n    \nusing System.Reflection;    \n    \n[assembly: AssemblyTitle(\"Mavlink Classes\")]\n[assembly: AssemblyDescription(\"Generated Message Classes for Mavlink. See http://qgroundcontrol.org/mavlink/start\")]\n[assembly: AssemblyProduct(\"Mavlink\")]\n[assembly: AssemblyVersion(\"1.0.0.0\")]\n[assembly: AssemblyFileVersion(\"1.0.0.0\")]\n\n    \"\"\")\n    \n    generate_enums(outf, enums)\n    generate_classes(outf, msgs)\n    outf.close()\n    \n    print(\"Generating the (De)Serializer classes\")\n    serfilename = basename + '_codec.generated.cs'\n    outf = open(serfilename, \"w\")\n    generate_CodecIndex(outf, msgs, xml)\n    generate_Deserialization(outf, msgs)\n    generate_Serialization(outf, msgs)\n    \n    outf.write(\"\\t}\\n\\n\")\n    outf.write(\"}\\n\\n\")\n    \n    outf.close()\n    \n    # Some build commands depend on the platform - eg MS .NET Windows Vs Mono on Linux\n    if platform.system() == \"Windows\":\n        winpath=os.environ['WinDir']\n        cscCommand = winpath + \"\\\\Microsoft.NET\\\\Framework\\\\v4.0.30319\\\\csc.exe\"\n        \n        if (os.path.exists(cscCommand)==False):\n            print(\"\\nError: CS compiler not found. .Net Assembly generation skipped\")\n            return   \n    else:\n        print(\"Error:.Net Assembly generation not yet supported on non Windows platforms\")\n        return\n        cscCommand = \"csc\"\n\n    print(\"Compiling Assembly for .Net Framework 4.0\")\n    \n    generatedCsFiles = [ serfilename, structsfilename]\n    \n    includedCsFiles =  [ 'CS/common/ByteArrayUtil.cs', 'CS/common/FrameworkBitConverter.cs', 'CS/common/Mavlink.cs'  ]\n    \n    outputLibraryPath = os.path.normpath(dir + \"/mavlink.dll\")\n    \n    compileCommand = \"%s %s\" % (cscCommand, \"/target:library /debug /out:\" + outputLibraryPath)\n    compileCommand = compileCommand + \" /doc:\" + os.path.normpath(dir + \"/mavlink.xml\")  \n    \n    for csFile in generatedCsFiles + includedCsFiles:\n        compileCommand = compileCommand + \" \" + os.path.normpath(csFile)\n    \n    #print(\"Cmd:\" + compileCommand)\n    res = os.system (compileCommand)\n    \n    if res == '0':\n        print(\"Generated %s OK\" % filename)\n    else:\n        print(\"Error\")", "response": "generate complete MAVLink CSharp implemenation"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_stylesheet(pyside=True):\n    # Smart import of the rc file\n    if pyside:\n        import qdarkstyle.pyside_style_rc\n    else:\n        import qdarkstyle.pyqt_style_rc\n\n    # Load the stylesheet content from resources\n    if not pyside:\n        from PyQt4.QtCore import QFile, QTextStream\n    else:\n        from PySide.QtCore import QFile, QTextStream\n\n    f = QFile(\":qdarkstyle/style.qss\")\n    if not f.exists():\n        _logger().error(\"Unable to load stylesheet, file not found in \"\n                        \"resources\")\n        return \"\"\n    else:\n        f.open(QFile.ReadOnly | QFile.Text)\n        ts = QTextStream(f)\n        stylesheet = ts.readAll()\n        if platform.system().lower() == 'darwin':  # see issue #12 on github\n            mac_fix = '''\n            QDockWidget::title\n            {\n                background-color: #31363b;\n                text-align: center;\n                height: 12px;\n            }\n            '''\n            stylesheet += mac_fix\n        return stylesheet", "response": "Loads the stylesheet from resources and returns the string"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads the stylesheet for use in a pyqt5 application.", "response": "def load_stylesheet_pyqt5():\n    \"\"\"\n    Loads the stylesheet for use in a pyqt5 application.\n\n    :param pyside: True to load the pyside rc file, False to load the PyQt rc file\n\n    :return the stylesheet string\n    \"\"\"\n    # Smart import of the rc file\n    import qdarkstyle.pyqt5_style_rc\n\n    # Load the stylesheet content from resources\n    from PyQt5.QtCore import QFile, QTextStream\n\n    f = QFile(\":qdarkstyle/style.qss\")\n    if not f.exists():\n        _logger().error(\"Unable to load stylesheet, file not found in \"\n                        \"resources\")\n        return \"\"\n    else:\n        f.open(QFile.ReadOnly | QFile.Text)\n        ts = QTextStream(f)\n        stylesheet = ts.readAll()\n        if platform.system().lower() == 'darwin':  # see issue #12 on github\n            mac_fix = '''\n            QDockWidget::title\n            {\n                background-color: #31363b;\n                text-align: center;\n                height: 12px;\n            }\n            '''\n            stylesheet += mac_fix\n        return stylesheet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nappend this item to a menu", "response": "def _append(self, menu):\n        '''append this menu item to a menu'''\n        menu.Append(self.id(), self.name, self.description)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds the selected menu item", "response": "def find_selected(self, event):\n        '''find the selected menu item'''\n        if event.GetId() == self.id():\n            self.checked = event.IsChecked()\n            return self\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _append(self, menu):\n        '''append this menu item to a menu'''\n        menu.AppendCheckItem(self.id(), self.name, self.description)\n        menu.Check(self.id(), self.checked)", "response": "append this item to a menu"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_selected(self, event):\n        '''find the selected menu item'''\n        first = self.id()\n        last = first + len(self.items) - 1\n        evid = event.GetId()\n        if evid >= first and evid <= last:\n            self.choice = evid - first\n            return self\n        return None", "response": "find the selected menu item"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _append(self, menu):\n        '''append this menu item to a menu'''\n        from wx_loader import wx\n        submenu = wx.Menu()\n        for i in range(len(self.items)):\n            submenu.AppendRadioItem(self.id()+i, self.items[i], self.description)\n            if self.items[i] == self.initial:\n                submenu.Check(self.id()+i, True)\n        menu.AppendMenu(-1, self.name, submenu)", "response": "append this menu item to a menu"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_to_submenu(self, submenu_path, item):\n        '''add an item to a submenu using a menu path array'''\n        if len(submenu_path) == 0:\n            self.add(item)\n            return\n        for m in self.items:\n            if isinstance(m, MPMenuSubMenu) and submenu_path[0] == m.name:\n                m.add_to_submenu(submenu_path[1:], item)\n                return\n        self.add(MPMenuSubMenu(submenu_path[0], []))\n        self.add_to_submenu(submenu_path, item)", "response": "add an item to a submenu using a menu path array"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_selected(self, event):\n        '''find the selected menu item'''\n        for m in self.items:\n            ret = m.find_selected(event)\n            if ret is not None:\n                return ret\n        return None", "response": "find the selected item in the menu"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _append(self, menu):\n        '''append this menu item to a menu'''\n        from wx_loader import wx\n\n        menu.AppendMenu(-1, self.name, self.wx_menu())", "response": "append this menu item to a menu"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_selected(self, event):\n        '''find the selected menu item'''\n        for i in range(len(self.items)):\n            m = self.items[i]\n            ret = m.find_selected(event)\n            if ret is not None:\n                return ret\n        return None", "response": "find the selected menu item"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshowing a file dialog", "response": "def call(self):\n        '''show a file dialog'''\n        from wx_loader import wx\n\n        # remap flags to wx descriptors\n        flag_map = {\n            'open': wx.FD_OPEN,\n            'save': wx.FD_SAVE,\n            'overwrite_prompt': wx.FD_OVERWRITE_PROMPT,\n        }\n        flags = map(lambda x: flag_map[x], self.flags)\n\n        dlg = wx.FileDialog(None, self.title, '', \"\", self.wildcard, flags)\n        if dlg.ShowModal() != wx.ID_OK:\n            return None\n        return dlg.GetPath()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef call(self):\n        '''show a value dialog'''\n        from wx_loader import wx\n\n        dlg = wx.TextEntryDialog(None, self.title, self.title, defaultValue=str(self.default))\n        if dlg.ShowModal() != wx.ID_OK:\n            return None\n        return dlg.GetValue()", "response": "show a value dialog"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nshow the dialog as a child process", "response": "def call(self):\n        '''show the dialog as a child process'''\n        mp_util.child_close_fds()\n        import wx_processguard\n        from wx_loader import wx\n        from wx.lib.agw.genericmessagedialog import GenericMessageDialog\n        app = wx.App(False)\n        # note! font size change is not working. I don't know why yet\n        font = wx.Font(self.font_size, wx.MODERN, wx.NORMAL, wx.NORMAL)\n        dlg = GenericMessageDialog(None, self.message, self.title, wx.ICON_INFORMATION|wx.OK)\n        dlg.SetFont(font)\n        dlg.ShowModal()\n        app.MainLoop()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading in a DEM file and associated. erspper file.", "response": "def read_ermapper(self, ifile):\n        '''Read in a DEM file and associated .ers file'''\n        ers_index = ifile.find('.ers')\n        if ers_index > 0:\n            data_file = ifile[0:ers_index]\n            header_file = ifile\n        else:\n            data_file = ifile\n            header_file = ifile + '.ers'\n\n        self.header = self.read_ermapper_header(header_file)\n\n        nroflines = int(self.header['nroflines'])\n        nrofcellsperlines = int(self.header['nrofcellsperline'])\n        self.data = self.read_ermapper_data(data_file, offset=int(self.header['headeroffset']))\n        self.data = numpy.reshape(self.data,(nroflines,nrofcellsperlines))\n\n        longy =  numpy.fromstring(self.getHeaderParam('longitude'), sep=':')\n        latty =  numpy.fromstring(self.getHeaderParam('latitude'), sep=':')\n\n        self.deltalatitude = float(self.header['ydimension'])\n        self.deltalongitude = float(self.header['xdimension'])\n\n        if longy[0] < 0:\n            self.startlongitude = longy[0]+-((longy[1]/60)+(longy[2]/3600))\n            self.endlongitude = self.startlongitude - int(self.header['nrofcellsperline'])*self.deltalongitude\n        else:\n            self.startlongitude = longy[0]+(longy[1]/60)+(longy[2]/3600)\n            self.endlongitude = self.startlongitude + int(self.header['nrofcellsperline'])*self.deltalongitude\n        if latty[0] < 0:\n            self.startlatitude = latty[0]-((latty[1]/60)+(latty[2]/3600))\n            self.endlatitude = self.startlatitude - int(self.header['nroflines'])*self.deltalatitude\n        else:\n            self.startlatitude = latty[0]+(latty[1]/60)+(latty[2]/3600)\n            self.endlatitude = self.startlatitude + int(self.header['nroflines'])*self.deltalatitude"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef printBoundingBox(self):\n        '''Print the bounding box that this DEM covers'''\n        print (\"Bounding Latitude: \")\n        print (self.startlatitude)\n        print (self.endlatitude)\n\n        print (\"Bounding Longitude: \")\n        print (self.startlongitude)\n        print (self.endlongitude)", "response": "Print the bounding box that this DEM covers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getPercentBlank(self):\n        '''Print how many null cells are in the DEM - Quality measure'''\n        blank = 0\n        nonblank = 0\n        for x in self.data.flat:\n            if x == -99999.0:\n                blank = blank + 1\n            else:\n                nonblank = nonblank + 1\n\n        print (\"Blank tiles =  \", blank, \"out of \", (nonblank+blank))", "response": "Print how many null cells are in the DEM - Quality measure"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_rc_override(self):\n        '''send RC override packet'''\n        if self.sitl_output:\n            buf = struct.pack('<HHHHHHHH',\n                              *self.override)\n            self.sitl_output.write(buf)\n        else:\n            self.master.mav.rc_channels_override_send(self.target_system,\n                                                           self.target_component,\n                                                           *self.override)", "response": "send RC override packet"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cmd_switch(self, args):\n        '''handle RC switch changes'''\n        mapping = [ 0, 1165, 1295, 1425, 1555, 1685, 1815 ]\n        if len(args) != 1:\n            print(\"Usage: switch <pwmvalue>\")\n            return\n        value = int(args[0])\n        if value < 0 or value > 6:\n            print(\"Invalid switch value. Use 1-6 for flight modes, '0' to disable\")\n            return\n        if self.vehicle_type == 'copter':\n            default_channel = 5\n        else:\n            default_channel = 8\n        if self.vehicle_type == 'rover':\n            flite_mode_ch_parm = int(self.get_mav_param(\"MODE_CH\", default_channel))\n        else:\n            flite_mode_ch_parm = int(self.get_mav_param(\"FLTMODE_CH\", default_channel))\n        self.override[flite_mode_ch_parm - 1] = mapping[value]\n        self.override_counter = 10\n        self.send_rc_override()\n        if value == 0:\n            print(\"Disabled RC switch override\")\n        else:\n            print(\"Set RC switch override to %u (PWM=%u channel=%u)\" % (\n                value, mapping[value], flite_mode_ch_parm))", "response": "handle RC switch changes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting override for all channels", "response": "def set_override(self, newchannels):\n        '''this is a public method for use by drone API or other scripting'''\n        self.override = newchannels\n        self.override_counter = 10\n        self.send_rc_override()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting georeference info to a netcdf file", "response": "def write_NetCDF_georeference(origin, outfile):\n    \"\"\"Write georeference info to a netcdf file, usually sww.\n\n    The origin can be a georef instance or parameters for a geo_ref instance\n\n    outfile is the name of the file to be written to.\n    \"\"\"\n\n    geo_ref = ensure_geo_reference(origin)\n    geo_ref.write_NetCDF(outfile)\n    return geo_ref"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ensure_geo_reference(origin):\n\n    if isinstance(origin, Geo_reference):\n        geo_ref = origin\n    elif origin is None:\n        geo_ref = None\n    else:\n        geo_ref = apply(Geo_reference, origin)\n\n    return geo_ref", "response": "Ensures that a geo - ref object is returned."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging the geo reference of a list or numeric array of points to be this reference.", "response": "def change_points_geo_ref(self, points, points_geo_ref=None):\n        \"\"\"Change the geo reference of a list or numeric array of points to\n        be this reference.(The reference used for this object)\n        If the points do not have a geo ref, assume 'absolute' values\n        \"\"\"\n        import copy\n\n        # remember if we got a list\n        is_list = isinstance(points, list)\n\n        points = ensure_numeric(points, num.float)\n\n        # sanity checks\n        if len(points.shape) == 1:\n            #One point has been passed\n            msg = 'Single point must have two elements'\n            assert len(points) == 2, msg\n            points = num.reshape(points, (1,2))\n\n        msg = 'Points array must be two dimensional.\\n'\n        msg += 'I got %d dimensions' %len(points.shape)\n        assert len(points.shape) == 2, msg\n\n        msg = 'Input must be an N x 2 array or list of (x,y) values. '\n        msg += 'I got an %d x %d array' %points.shape\n        assert points.shape[1] == 2, msg\n\n        # FIXME (Ole): Could also check if zone, xllcorner, yllcorner\n        # are identical in the two geo refs.\n        if points_geo_ref is not self:\n            # If georeferences are different\n            points = copy.copy(points) # Don't destroy input\n            if not points_geo_ref is None:\n                # Convert points to absolute coordinates\n                points[:,0] += points_geo_ref.xllcorner\n                points[:,1] += points_geo_ref.yllcorner\n\n            # Make points relative to primary geo reference\n            points[:,0] -= self.xllcorner\n            points[:,1] -= self.yllcorner\n\n        if is_list:\n            points = points.tolist()\n\n        return points"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_absolute(self):\n\n        # FIXME(Ole): It is unfortunate that decision about whether points\n        # are absolute or not lies with the georeference object. Ross pointed this out.\n        # Moreover, this little function is responsible for a large fraction of the time\n        # using in data fitting (something in like 40 - 50%.\n        # This was due to the repeated calls to allclose.\n        # With the flag method fitting is much faster (18 Mar 2009).\n\n        # FIXME(Ole): HACK to be able to reuse data already cached (18 Mar 2009).\n        # Remove at some point\n        if not hasattr(self, 'absolute'):\n            self.absolute = num.allclose([self.xllcorner, self.yllcorner], 0)\n\n        # Return absolute flag\n        return self.absolute", "response": "Return True if xllcorner == yllcorner == 0 indicating that points\n        in question are absolute."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef gps_distance(lat1, lon1, lat2, lon2):\n    '''return distance between two points in meters,\n    coordinates are in degrees\n    thanks to http://www.movable-type.co.uk/scripts/latlong.html'''\n    lat1 = math.radians(lat1)\n    lat2 = math.radians(lat2)\n    lon1 = math.radians(lon1)\n    lon2 = math.radians(lon2)\n    dLat = lat2 - lat1\n    dLon = lon2 - lon1\n\n    a = math.sin(0.5*dLat)**2 + math.sin(0.5*dLon)**2 * math.cos(lat1) * math.cos(lat2)\n    c = 2.0 * math.atan2(math.sqrt(a), math.sqrt(1.0-a))\n    return radius_of_earth * c", "response": "return distance between two points in meters lon1 and lon2"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns bearing between two points in degrees in range 0 - 360", "response": "def gps_bearing(lat1, lon1, lat2, lon2):\n    '''return bearing between two points in degrees, in range 0-360\n    thanks to http://www.movable-type.co.uk/scripts/latlong.html'''\n    lat1 = math.radians(lat1)\n    lat2 = math.radians(lat2)\n    lon1 = math.radians(lon1)\n    lon2 = math.radians(lon2)\n    dLat = lat2 - lat1\n    dLon = lon2 - lon1\n    y = math.sin(dLon) * math.cos(lat2)\n    x = math.cos(lat1)*math.sin(lat2) - math.sin(lat1)*math.cos(lat2)*math.cos(dLon)\n    bearing = math.degrees(math.atan2(y, x))\n    if bearing < 0:\n        bearing += 360.0\n    return bearing"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef gps_newpos(lat, lon, bearing, distance):\n    '''extrapolate latitude/longitude given a heading and distance\n    thanks to http://www.movable-type.co.uk/scripts/latlong.html\n    '''\n    lat1 = math.radians(lat)\n    lon1 = math.radians(lon)\n    brng = math.radians(bearing)\n    dr = distance/radius_of_earth\n\n    lat2 = math.asin(math.sin(lat1)*math.cos(dr) +\n                     math.cos(lat1)*math.sin(dr)*math.cos(brng))\n    lon2 = lon1 + math.atan2(math.sin(brng)*math.sin(dr)*math.cos(lat1),\n                             math.cos(dr)-math.sin(lat1)*math.sin(lat2))\n    return (math.degrees(lat2), wrap_valid_longitude(math.degrees(lon2)))", "response": "extrapolate latitude and longitude given a heading and distance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning new lat / lon after moving east / north by the given number of meters", "response": "def gps_offset(lat, lon, east, north):\n    '''return new lat/lon after moving east/north\n    by the given number of meters'''\n    bearing = math.degrees(math.atan2(east, north))\n    distance = math.sqrt(east**2 + north**2)\n    return gps_newpos(lat, lon, bearing, distance)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mkdir_p(dir):\n    '''like mkdir -p'''\n    if not dir:\n        return\n    if dir.endswith(\"/\") or dir.endswith(\"\\\\\"):\n        mkdir_p(dir[:-1])\n        return\n    if os.path.isdir(dir):\n        return\n    mkdir_p(os.path.dirname(dir))\n    try:\n        os.mkdir(dir)\n    except Exception:\n        pass", "response": "like mkdir - p"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a polygon from a file", "response": "def polygon_load(filename):\n    '''load a polygon from a file'''\n    ret = []\n    f = open(filename)\n    for line in f:\n        if line.startswith('#'):\n            continue\n        line = line.strip()\n        if not line:\n            continue\n        a = line.split()\n        if len(a) != 2:\n            raise RuntimeError(\"invalid polygon line: %s\" % line)\n        ret.append((float(a[0]), float(a[1])))\n    f.close()\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns bounding box of a polygon in ( x y width height form", "response": "def polygon_bounds(points):\n    '''return bounding box of a polygon in (x,y,width,height) form'''\n    (minx, miny) = (points[0][0], points[0][1])\n    (maxx, maxy) = (minx, miny)\n    for p in points:\n        minx = min(minx, p[0])\n        maxx = max(maxx, p[0])\n        miny = min(miny, p[1])\n        maxy = max(maxy, p[1])\n    return (minx, miny, maxx-minx, maxy-miny)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bounds_overlap(bound1, bound2):\n    '''return true if two bounding boxes overlap'''\n    (x1,y1,w1,h1) = bound1\n    (x2,y2,w2,h2) = bound2\n    if x1+w1 < x2:\n        return False\n    if x2+w2 < x1:\n        return False\n    if y1+h1 < y2:\n        return False\n    if y2+h2 < y1:\n        return False\n    return True", "response": "return true if two bounding boxes overlap"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef degrees_to_dms(degrees):\n    '''return a degrees:minutes:seconds string'''\n    deg = int(degrees)\n    min = int((degrees - deg)*60)\n    sec = ((degrees - deg) - (min/60.0))*60*60\n    return u'%d\\u00b0%02u\\'%05.2f\"' % (deg, abs(min), abs(sec))", "response": "return a degrees : minutes : seconds string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert to UTM grid reference", "response": "def latlon_to_grid(latlon):\n    '''convert to grid reference'''\n    from MAVProxy.modules.lib.ANUGA import redfearn\n    (zone, easting, northing) = redfearn.redfearn(latlon[0], latlon[1])\n    if latlon[0] < 0:\n        hemisphere = 'S'\n    else:\n        hemisphere = 'N'\n    return UTMGrid(zone, easting, northing, hemisphere=hemisphere)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrounds to nearest grid corner", "response": "def latlon_round(latlon, spacing=1000):\n    '''round to nearest grid corner'''\n    g = latlon_to_grid(latlon)\n    g.easting = (g.easting // spacing) * spacing\n    g.northing = (g.northing // spacing) * spacing\n    return g.latlon()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wxToPIL(wimg):\n    '''convert a wxImage to a PIL Image'''\n    from PIL import Image\n    (w,h) = wimg.GetSize()\n    d     = wimg.GetData()\n    pimg  = Image.new(\"RGB\", (w,h), color=1)\n    pimg.fromstring(d)\n    return pimg", "response": "convert a wxImage to a PIL Image"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a PIL Image to a wx image", "response": "def PILTowx(pimg):\n    '''convert a PIL Image to a wx image'''\n    from wx_loader import wx\n    wimg = wx.EmptyImage(pimg.size[0], pimg.size[1])\n    wimg.SetData(pimg.convert('RGB').tostring())\n    return wimg"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a path to store mavproxy data", "response": "def dot_mavproxy(name):\n    '''return a path to store mavproxy data'''\n    dir = os.path.join(os.environ['HOME'], '.mavproxy')\n    mkdir_p(dir)\n    return os.path.join(dir, name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download_url(url):\n    '''download a URL and return the content'''\n    import urllib2\n    try:\n        resp = urllib2.urlopen(url)\n        headers = resp.info()\n    except urllib2.URLError as e:\n        print('Error downloading %s' % url)\n        return None\n    return resp.read()", "response": "download a URL and return the content"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclosing file descriptors that a child process should not inherit. Should be called from child processes.", "response": "def child_close_fds():\n    '''close file descriptors that a child process should not inherit.\n       Should be called from child processes.'''\n    global child_fd_list\n    import os\n    while len(child_fd_list) > 0:\n        fd = child_fd_list.pop(0)\n        try:\n            os.close(fd)\n        except Exception as msg:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef latlon(self):\n        '''return (lat,lon) for the grid coordinates'''\n        from MAVProxy.modules.lib.ANUGA import lat_long_UTM_conversion\n        (lat, lon) = lat_long_UTM_conversion.UTMtoLL(self.northing, self.easting, self.zone, isSouthernHemisphere=(self.hemisphere=='S'))\n        return (lat, lon)", "response": "return the latitude and longitude for the grid coordinates"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef snapshot_folder():\n    logger.info(\"Snapshot folder\")\n    try:\n        stdout = subprocess.check_output([\"git\", \"show\", \"-s\", \"--format=%cI\", \"HEAD\"])\n    except subprocess.CalledProcessError as e:\n        logger.error(\"Error: {}\".format(e.output.decode('ascii', 'ignore').strip()))\n        sys.exit(2)\n    except FileNotFoundError as e:\n        logger.error(\"Error: {}\".format(e))\n        sys.exit(2)\n    ds = stdout.decode('ascii', 'ignore').strip()\n    dt = datetime.fromisoformat(ds)\n    utc = dt - dt.utcoffset()\n    return utc.strftime(\"%Y%m%d_%H%M%S\")", "response": "Get the name of the current folder in UTC"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef opengraph_get(html, prop):\n    match = re.search('<meta [^>]*property=\"og:' + prop + '\" content=\"([^\"]*)\"', html)\n    if match is None:\n        match = re.search('<meta [^>]*content=\"([^\"]*)\" property=\"og:' + prop + '\"', html)\n        if match is None:\n            return None\n    return match.group(1)", "response": "Extract specified OpenGraph property from html."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndecodes html entities in a string.", "response": "def decode_html_entities(s):\n    \"\"\"\n    Replaces html entities with the character they represent.\n\n        >>> print(decode_html_entities(\"&lt;3 &amp;\"))\n        <3 &\n    \"\"\"\n    parser = HTMLParser.HTMLParser()\n\n    def unesc(m):\n        return parser.unescape(m.group())\n    return re.sub(r'(&[^;]+;)', unesc, ensure_unicode(s))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filenamify(title):\n    # ensure it is unicode\n    title = ensure_unicode(title)\n\n    # NFD decomposes chars into base char and diacritical mark, which\n    # means that we will get base char when we strip out non-ascii.\n    title = unicodedata.normalize('NFD', title)\n\n    # Convert to lowercase\n    # Drop any non ascii letters/digits\n    # Drop any leading/trailing whitespace that may have appeared\n    title = re.sub(r'[^a-z0-9 .-]', '', title.lower().strip())\n\n    # Replace whitespace with dot\n    title = re.sub(r'\\s+', '.', title)\n    title = re.sub(r'\\.-\\.', '-', title)\n\n    return title", "response": "Convert a string to something suitable as a file name. E. g. Matlagning del 1 av 10 - R\u00e4ksm\u00f6rg\u00e5s | SVT Play\n       -. raksmorgas -. svt -. play\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a list of streams and a prioritized list of accepted protocols return a list of VideoRetriever objects that are accepted and sorted by bitrate then protocol priority.", "response": "def protocol_prio(streams, priolist):\n    \"\"\"\n    Given a list of VideoRetriever objects and a prioritized list of\n    accepted protocols (as strings) (highest priority first), return\n    a list of VideoRetriever objects that are accepted, and sorted\n    by bitrate, and then protocol priority.\n    \"\"\"\n    # Map score's to the reverse of the list's index values\n    proto_score = dict(zip(priolist, range(len(priolist), 0, -1)))\n    logging.debug(\"Protocol priority scores (higher is better): %s\", str(proto_score))\n\n    # Build a tuple (bitrate, proto_score, stream), and use it\n    # for sorting.\n    prioritized = [(s.bitrate, proto_score[s.name], s) for\n                   s in streams if s.name in proto_score]\n    return [x[2] for x in sorted(prioritized, key=itemgetter(0, 1), reverse=True)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download(self):\n        _, ext = os.path.splitext(self.url)\n        if ext == \".mp3\":\n            self.output_extention = \"mp3\"\n        else:\n            self.output_extention = \"mp4\"  # this might be wrong..\n        data = self.http.request(\"get\", self.url, stream=True)\n        try:\n            total_size = data.headers['content-length']\n        except KeyError:\n            total_size = 0\n        total_size = int(total_size)\n        bytes_so_far = 0\n\n        file_d = output(self.output, self.config, self.output_extention)\n        if file_d is None:\n            return\n\n        eta = ETA(total_size)\n        for i in data.iter_content(8192):\n            bytes_so_far += len(i)\n            file_d.write(i)\n            if not self.config.get(\"silent\"):\n                eta.update(bytes_so_far)\n                progressbar(total_size, bytes_so_far, ''.join([\"ETA: \", str(eta)]))\n\n        file_d.close()\n        self.finished = True", "response": "Download the file from HTTP"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main():\n    parse, options = parser(__version__)\n\n    if options.flexibleq and not options.quality:\n        logging.error(\"flexible-quality requires a quality\")\n\n    if len(options.urls) == 0:\n        parse.print_help()\n        sys.exit(0)\n    urls = options.urls\n    config = parsertoconfig(setup_defaults(), options)\n    if len(urls) < 1:\n        parse.error(\"Incorrect number of arguments\")\n    setup_log(config.get(\"silent\"), config.get(\"verbose\"))\n\n    if options.cmoreoperatorlist:\n        config = parsertoconfig(setup_defaults(), options)\n        c = Cmore(config, urls)\n        c.operatorlist()\n        sys.exit(0)\n\n    try:\n        if len(urls) == 1:\n            get_media(urls[0], config, __version__)\n        else:\n            get_multiple_media(urls, config)\n    except KeyboardInterrupt:\n        print(\"\")\n    except (yaml.YAMLError, yaml.MarkedYAMLError) as e:\n        logging.error('Your settings file(s) contain invalid YAML syntax! Please fix and restart!, {}'.format(str(e)))\n        sys.exit(2)", "response": "Main function for the sequence of media items."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting some progress about how much we have downloaded", "response": "def progress(byte, total, extra=\"\"):\n    \"\"\" Print some info about how much we have downloaded \"\"\"\n    if total == 0:\n        progresstr = \"Downloaded %dkB bytes\" % (byte >> 10)\n        progress_stream.write(progresstr + '\\r')\n        return\n    progressbar(total, byte, extra)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef progressbar(total, pos, msg=\"\"):\n    width = get_terminal_size()[0] - 40\n    rel_pos = int(float(pos) / total * width)\n    bar = ''.join([\"=\" * rel_pos, \".\" * (width - rel_pos)])\n\n    # Determine how many digits in total (base 10)\n    digits_total = len(str(total))\n    fmt_width = \"%0\" + str(digits_total) + \"d\"\n    fmt = \"\\r[\" + fmt_width + \"/\" + fmt_width + \"][%s] %s\"\n\n    progress_stream.write(fmt % (pos, total, bar, msg))", "response": "Prints a progress bar for the given total and a progress position."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, pos):\n        self.pos = pos\n        self.now = time.time()", "response": "Updates the current state of the current object based on the current position."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_video_id(self, url=None):\n        if url:\n            html_data = self.http.request(\"get\", url).text\n        else:\n            html_data = self.get_urldata()\n        html_data = self.get_urldata()\n        match = re.search(r'data-video-id=\"([0-9]+)\"', html_data)\n        if match:\n            return match.group(1)\n        match = re.search(r'data-videoid=\"([0-9]+)', html_data)\n        if match:\n            return match.group(1)\n        match = re.search(r'\"mediaGuid\":\"([0-9]+)\"', html_data)\n        if match:\n            return match.group(1)\n\n        clips = False\n        slug = None\n        match = re.search('params\":({.*}),\"query', self.get_urldata())\n        if match:\n            jansson = json.loads(match.group(1))\n            if \"seasonNumberOrVideoId\" in jansson:\n                season = jansson[\"seasonNumberOrVideoId\"]\n                match = re.search(r\"\\w-(\\d+)$\", season)\n                if match:\n                    season = match.group(1)\n            else:\n                match = self._conentpage(self.get_urldata())\n                if match:  # this only happen on the program page?\n                    janson2 = json.loads(match.group(1))\n                    if janson2[\"formatPage\"][\"format\"]:\n                        season = janson2[\"formatPage\"][\"format\"][\"seasonNumber\"]\n                        return janson2[\"formatPage\"][\"format\"][\"videos\"][str(season)][\"program\"][0][\"id\"]\n                return None\n            if \"videoIdOrEpisodeNumber\" in jansson:\n                videp = jansson[\"videoIdOrEpisodeNumber\"]\n                match = re.search(r'(\\w+)-(\\d+)', videp)\n                if match:\n                    episodenr = match.group(2)\n                else:\n                    episodenr = videp\n                    clips = True\n                match = re.search(r'(s\\w+)-(\\d+)', season)\n                if match:\n                    season = match.group(2)\n            else:\n                # sometimes videoIdOrEpisodeNumber does not work.. this is a workaround\n                match = re.search(r'(episode|avsnitt)-(\\d+)', self.url)\n                if match:\n                    episodenr = match.group(2)\n                else:\n                    episodenr = season\n            if \"slug\" in jansson:\n                slug = jansson[\"slug\"]\n\n            if clips:\n                return episodenr\n            else:\n                match = self._conentpage(self.get_urldata())\n                if match:\n                    janson = json.loads(match.group(1))\n                    for i in janson[\"formatPage\"][\"format\"][\"videos\"].keys():\n                        if \"program\" in janson[\"formatPage\"][\"format\"][\"videos\"][str(i)]:\n                            for n in janson[\"formatPage\"][\"format\"][\"videos\"][i][\"program\"]:\n                                if str(n[\"episodeNumber\"]) and int(episodenr) == n[\"episodeNumber\"] and int(season) == n[\"seasonNumber\"]:\n                                    if slug is None or slug == n[\"formatSlug\"]:\n                                        return n[\"id\"]\n                                elif n[\"id\"] == episodenr:\n                                    return episodenr\n\n        parse = urlparse(self.url)\n        match = re.search(r'/\\w+/(\\d+)', parse.path)\n        if match:\n            return match.group(1)\n        match = re.search(r'iframe src=\"http://play.juicyplay.se[^\\\"]+id=(\\d+)', html_data)\n        if match:\n            return match.group(1)\n\n        match = re.search(r'<meta property=\"og:image\" content=\"([\\S]+)\"', html_data)\n        if match:\n            return match.group(1).split(\"/\")[-2]\n\n        return None", "response": "Extract video id from the HTML document."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef child_task(self):\n        '''child process - this holds all the GUI elements'''\n        self.parent_pipe_send.close()\n        self.parent_pipe_recv.close()\n\n        from MAVProxy.modules.lib import wx_processguard\n        from MAVProxy.modules.lib.wx_loader import wx\n        from MAVProxy.modules.lib.wxconsole_ui import ConsoleFrame\n        app = wx.App(False)\n        app.frame = ConsoleFrame(state=self, title=self.title)\n        app.frame.SetDoubleBuffered(True)\n        app.frame.Show()\n        app.MainLoop()", "response": "child process - this holds all the GUI elements"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef watch_thread(self):\n        '''watch for menu events from child'''\n        from MAVProxy.modules.lib.mp_settings import MPSetting\n        try:\n            while True:\n                msg = self.parent_pipe_recv.recv()\n                if isinstance(msg, win_layout.WinLayout):\n                    win_layout.set_layout(msg, self.set_layout)\n                elif self.menu_callback is not None:\n                    self.menu_callback(msg)\n                time.sleep(0.1)\n        except EOFError:\n            pass", "response": "watch for menu events from child"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle AUX switches (CH7 CH8", "response": "def cmd_auxopt(self, args):\n        '''handle AUX switches (CH7, CH8) settings'''\n        if self.mpstate.vehicle_type != 'copter':\n            print(\"This command is only available for copter\")\n            return\n        if len(args) == 0 or args[0] not in ('set', 'show', 'reset', 'list'):\n            print(\"Usage: auxopt set|show|reset|list\")\n            return\n        if args[0] == 'list':\n            print(\"Options available:\")\n            for s in sorted(aux_options.keys()):\n                print('  ' + s)\n        elif args[0] == 'show':\n            if len(args) > 2 and args[1] not in ['7', '8', 'all']:\n                print(\"Usage: auxopt show [7|8|all]\")\n                return\n            if len(args) < 2 or args[1] == 'all':\n                self.aux_show('7')\n                self.aux_show('8')\n                return\n            self.aux_show(args[1])\n        elif args[0] == 'reset':\n            if len(args) < 2 or args[1] not in ['7', '8', 'all']:\n                print(\"Usage: auxopt reset 7|8|all\")\n                return\n            if args[1] == 'all':\n                self.param_set('CH7_OPT', '0')\n                self.param_set('CH8_OPT', '0')\n                return\n            param = \"CH%s_OPT\" % args[1]\n            self.param_set(param, '0')\n        elif args[0] == 'set':\n            if len(args) < 3 or args[1] not in ['7', '8']:\n                print(\"Usage: auxopt set 7|8 OPTION\")\n                return\n            option = self.aux_option_validate(args[2])\n            if not option:\n                print(\"Invalid option \" + args[2])\n                return\n            param = \"CH%s_OPT\" % args[1]\n            self.param_set(param, aux_options[option])\n        else:\n            print(\"Usage: auxopt set|show|list\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_xlim_change(self):\n        '''check for new X bounds'''\n        if self.xlim_pipe is None:\n            return None\n        xlim = None\n        while self.xlim_pipe[0].poll():\n            try:\n                xlim = self.xlim_pipe[0].recv()\n            except EOFError:\n                return None\n        if xlim != self.xlim:\n            return xlim\n        return None", "response": "check for new X bounds"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_xlim(self, xlim):\n        '''set new X bounds'''\n        if self.xlim_pipe is not None and self.xlim != xlim:\n            #print(\"send0: \", graph_count, xlim)\n            try:\n                self.xlim_pipe[0].send(xlim)\n            except IOError:\n                return False\n            self.xlim = xlim\n        return True", "response": "set new X bounds"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        if m.get_type() == 'SERIAL_CONTROL':\n            data = m.data[:m.count]\n            s = ''.join(str(chr(x)) for x in data)\n            sys.stdout.write(s)", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef serial_lock(self, lock):\n        '''lock or unlock the port'''\n        mav = self.master.mav\n        if lock:\n            flags = mavutil.mavlink.SERIAL_CONTROL_FLAG_EXCLUSIVE\n            self.locked = True\n        else:\n            flags = 0\n            self.locked = False\n        mav.serial_control_send(self.serial_settings.port,\n                                flags,\n                                0, 0, 0, [0]*70)", "response": "lock or unlock the port"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mp_icon(filename):\n    '''load an icon from the data directory'''\n    # we have to jump through a lot of hoops to get an OpenCV image\n    # when we may be in a package zip file\n    try:\n        import pkg_resources\n        name = __name__\n        if name == \"__main__\":\n            name = \"MAVProxy.modules.mavproxy_map.mp_tile\"\n        stream = pkg_resources.resource_stream(name, \"data/%s\" % filename).read()\n        raw = np.fromstring(stream, dtype=np.uint8)\n    except Exception:\n        try:\n            stream = open(os.path.join(__file__, 'data', filename)).read()\n            raw = np.fromstring(stream, dtype=np.uint8)\n        except Exception:\n            #we're in a Windows exe, where pkg_resources doesn't work\n            import pkgutil\n            raw = pkgutil.get_data( 'MAVProxy', 'modules//mavproxy_map//data//' + filename)\n    img = cv2.imdecode(raw, cv2.IMREAD_COLOR)\n    return img", "response": "load an icon from the data directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_tile_lowres(self, tile):\n        '''load a lower resolution tile from cache to fill in a\n        map while waiting for a higher resolution tile'''\n        if tile.zoom == self.min_zoom:\n            return None\n\n        # find the equivalent lower res tile\n        (lat,lon) = tile.coord()\n\n        width2 = TILES_WIDTH\n        height2 = TILES_HEIGHT\n\n        for zoom2 in range(tile.zoom-1, self.min_zoom-1, -1):\n            width2 //= 2\n            height2 //= 2\n\n            if width2 == 0 or height2 == 0:\n                break\n\n            tile_info = self.coord_to_tile(lat, lon, zoom2)\n\n            # see if its in the tile cache\n            key = tile_info.key()\n            if key in self._tile_cache:\n                img = self._tile_cache[key]\n                if np.array_equal(img, np.array(self._unavailable)):\n                    continue\n            else:\n                path = self.tile_to_path(tile_info)\n                img = cv2.imread(path)\n                if img is None:\n                    continue\n                # add it to the tile cache\n                self._tile_cache[key] = img\n                while len(self._tile_cache) > self.cache_size:\n                    self._tile_cache.popitem(0)\n\n            # copy out the quadrant we want\n            availx = min(TILES_WIDTH - tile_info.offsetx, width2)\n            availy = min(TILES_HEIGHT - tile_info.offsety, height2)\n            if availx != width2 or availy != height2:\n                continue\n            roi = img[tile_info.offsety:tile_info.offsety+height2, tile_info.offsetx:tile_info.offsetx+width2]\n\n            # and scale it\n            scaled = cv2.resize(roi, (TILES_HEIGHT,TILES_WIDTH))\n            #cv.Rectangle(scaled, (0,0), (255,255), (0,255,0), 1)\n            return scaled\n        return None", "response": "load a lower resolution tile from cache to fill in a\n            map while waiting for a higher resolution tile"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_tile(self, tile):\n        '''load a tile from cache or tile server'''\n\n        # see if its in the tile cache\n        key = tile.key()\n        if key in self._tile_cache:\n            img = self._tile_cache[key]\n            if np.array_equal(img, self._unavailable):\n                img = self.load_tile_lowres(tile)\n                if img is None:\n                    img = self._unavailable\n            return img\n\n\n        path = self.tile_to_path(tile)\n        ret = cv2.imread(path)\n        if ret is not None:\n            # if it is an old tile, then try to refresh\n            if os.path.getmtime(path) + self.refresh_age < time.time():\n                try:\n                        self._download_pending[key].refresh_time()\n                except Exception:\n                        self._download_pending[key] = tile\n                self.start_download_thread()\n                    \n            # add it to the tile cache\n            self._tile_cache[key] = ret\n            while len(self._tile_cache) > self.cache_size:\n                self._tile_cache.popitem(0)\n            return ret\n\n        if not self.download:\n            img = self.load_tile_lowres(tile)\n            if img is None:\n                img = self._unavailable\n            return img\n\n        try:\n            self._download_pending[key].refresh_time()\n        except Exception:\n            self._download_pending[key] = tile\n        self.start_download_thread()\n\n        img = self.load_tile_lowres(tile)\n        if img is None:\n            img = self._loading\n        return img", "response": "load a tile from cache or tile server"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a scaled tile", "response": "def scaled_tile(self, tile):\n        '''return a scaled tile'''\n        width = int(TILES_WIDTH / tile.scale)\n        height = int(TILES_HEIGHT / tile.scale)\n        full_tile = self.load_tile(tile)\n        scaled_tile = cv2.resize(full_tile, (height, width))\n        return scaled_tile"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an RGB image for an area of land with ground_width in meters and width / height in pixels.", "response": "def area_to_image(self, lat, lon, width, height, ground_width, zoom=None, ordered=True):\n        '''return an RGB image for an area of land, with ground_width\n        in meters, and width/height in pixels.\n\n        lat/lon is the top left corner. The zoom is automatically\n        chosen to avoid having to grow the tiles'''\n\n        img = np.zeros((height,width,3), np.uint8)\n\n        tlist = self.area_to_tile_list(lat, lon, width, height, ground_width, zoom)\n\n        # order the display by distance from the middle, so the download happens\n        # close to the middle of the image first\n        if ordered:\n            (midlat, midlon) = self.coord_from_area(width/2, height/2, lat, lon, width, ground_width)\n            tlist.sort(key=lambda d: d.distance(midlat, midlon), reverse=True)\n\n        for t in tlist:\n            scaled_tile = self.scaled_tile(t)\n\n            w = min(width - t.dstx, scaled_tile.shape[1] - t.srcx)\n            h = min(height - t.dsty, scaled_tile.shape[0] - t.srcy)\n            if w > 0 and h > 0:\n                scaled_tile_roi = scaled_tile[t.srcy:t.srcy+h, t.srcx:t.srcx+w]\n                img[t.dsty:t.dsty+h, t.dstx:t.dstx+w] = scaled_tile_roi.copy()\n\n        # return as an RGB image\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        return img"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_fw(self, args):\n        '''execute command defined in args'''\n        if len(args) == 0:\n            print(self.usage())\n            return\n        rest = args[1:]\n        if args[0] == \"manifest\":\n            self.cmd_fw_manifest(rest)\n        elif args[0] == \"list\":\n            self.cmd_fw_list(rest)\n        elif args[0] == \"download\":\n            self.cmd_fw_download(rest)\n        elif args[0] in [\"help\",\"usage\"]:\n            self.cmd_fw_help(rest)\n        else:\n            print(self.usage())", "response": "execute command defined in args"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef frame_from_firmware(self, firmware):\n        '''extract information from firmware, return pretty string to user'''\n        # see Tools/scripts/generate-manifest for this map:\n        frame_to_mavlink_dict = {\n            \"quad\": \"QUADROTOR\",\n            \"hexa\": \"HEXAROTOR\",\n            \"y6\": \"ARDUPILOT_Y6\",\n            \"tri\": \"TRICOPTER\",\n            \"octa\": \"OCTOROTOR\",\n            \"octa-quad\": \"ARDUPILOT_OCTAQUAD\",\n            \"heli\": \"HELICOPTER\",\n            \"Plane\": \"FIXED_WING\",\n            \"Tracker\": \"ANTENNA_TRACKER\",\n            \"Rover\": \"GROUND_ROVER\",\n            \"PX4IO\": \"ARDUPILOT_PX4IO\",\n        }\n        mavlink_to_frame_dict = { v : k  for k,v in frame_to_mavlink_dict.items() }\n        x = firmware[\"mav-type\"]\n        if firmware[\"mav-autopilot\"] != \"ARDUPILOTMEGA\":\n            return x\n        if x in mavlink_to_frame_dict:\n            return mavlink_to_frame_dict[x]\n\n        return x", "response": "extract information from firmware return pretty string to user"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nextracts a tuple of major minor patch from a firmware instance", "response": "def semver_from_firmware(self, firmware):\n        '''Extract a tuple of (major,minor,patch) from a firmware instance'''\n        version = firmware.get(\"mav-firmware-version-major\",None)\n        if version is None:\n            return (None,None,None)\n        return (firmware[\"mav-firmware-version-major\"],\n                firmware[\"mav-firmware-version-minor\"],\n                firmware[\"mav-firmware-version-patch\"])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if row should NOT be included according to filters", "response": "def row_is_filtered(self, row_subs, filters):\n        '''returns True if row should NOT be included according to filters'''\n        for filtername in filters:\n            filtervalue = filters[filtername]\n            if filtername in row_subs:\n                row_subs_value = row_subs[filtername]\n                if str(row_subs_value) != str(filtervalue):\n                    return True\n            else:\n                print(\"fw: Unknown filter keyword (%s)\" % (filtername,))\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake any argument of the form name = value anmd put it into a dict ; return that and the remaining arguments", "response": "def filters_from_args(self, args):\n        '''take any argument of the form name=value anmd put it into a dict; return that and the remaining arguments'''\n        filters = dict()\n        remainder = []\n        for arg in args:\n            try:\n                equals = arg.index('=')\n                # anything ofthe form key-value is taken as a filter\n                filters[arg[0:equals]] = arg[equals+1:];\n            except ValueError:\n                remainder.append(arg)\n        return (filters,remainder)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn all firmware entries from all manifests", "response": "def all_firmwares(self):\n        ''' return firmware entries from all manifests'''\n        all = []\n        for manifest in self.manifests:\n            for firmware in manifest[\"firmware\"]:\n                all.append(firmware)\n        return all"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rows_for_firmwares(self, firmwares):\n        '''provide user-readable text for a firmware entry'''\n        rows = []\n        i = 0\n        for firmware in firmwares:\n            frame = self.frame_from_firmware(firmware)\n            row = {\n                \"seq\": i,\n                \"platform\": firmware[\"platform\"],\n                \"frame\": frame,\n#                \"type\": firmware[\"mav-type\"],\n                \"releasetype\": firmware[\"mav-firmware-version-type\"],\n                \"latest\": firmware[\"latest\"],\n                \"git-sha\": firmware[\"git-sha\"][0:7],\n                \"format\": firmware[\"format\"],\n                \"_firmware\": firmware,\n            }\n            (major,minor,patch) = self.semver_from_firmware(firmware)\n            if major is None:\n                row[\"version\"] = \"\"\n                row[\"major\"] = \"\"\n                row[\"minor\"] = \"\"\n                row[\"patch\"] = \"\"\n            else:\n                row[\"version\"] = firmware[\"mav-firmware-version\"]\n                row[\"major\"] = major\n                row[\"minor\"] = minor\n                row[\"patch\"] = patch\n\n            i += 1\n            rows.append(row)\n\n        return rows", "response": "provide user - readable text for a firmware entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns rows as filtered by filters", "response": "def filter_rows(self, filters, rows):\n        '''returns rows as filtered by filters'''\n        ret = []\n        for row in rows:\n            if not self.row_is_filtered(row, filters):\n                ret.append(row)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef filtered_rows_from_args(self, args):\n        '''extracts filters from args, rows from manifests, returns filtered rows'''\n        if len(self.manifests) == 0:\n            print(\"fw: No manifests downloaded.  Try 'manifest download'\")\n            return None\n\n        (filters,remainder) = self.filters_from_args(args)\n        all = self.all_firmwares()\n        rows = self.rows_for_firmwares(all)\n        filtered = self.filter_rows(filters, rows)\n        return (filtered, remainder)", "response": "extracts filters from args rows from manifests returns filtered rows"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_manifests(self):\n        '''locate manifests and return filepaths thereof'''\n        manifest_dir = mp_util.dot_mavproxy()\n\n        ret = []\n        for file in os.listdir(manifest_dir):\n            try:\n                file.index(\"manifest\")\n                ret.append(os.path.join(manifest_dir,file))\n            except ValueError:\n                pass\n        return ret", "response": "locate manifests and return filepaths thereof"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_fw_manifest_purge(self):\n        '''remove all downloaded manifests'''\n        for filepath in self.find_manifests():\n            os.unlink(filepath)\n        self.manifests_parse()", "response": "remove all downloaded manifests"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_fw_manifest(self, args):\n        '''cmd handler for manipulating manifests'''\n        if len(args) == 0:\n            print(self.fw_manifest_usage())\n            return\n        rest = args[1:]\n        if args[0] == \"download\":\n            return self.manifest_download()\n        if args[0] == \"list\":\n            return self.cmd_fw_manifest_list()\n        if args[0] == \"load\":\n            return self.cmd_fw_manifest_load()\n        if args[0] == \"purge\":\n            return self.cmd_fw_manifest_purge()\n        if args[0] == \"help\":\n            return self.cmd_fw_manifest_help()\n        else:\n            print(\"fw: Unknown manifest option (%s)\" % args[0])\n            print(fw_manifest_usage())", "response": "cmd handler for manipulating manifests"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef manifest_parse(self, path):\n        '''parse manifest at path, return JSON object'''\n        print(\"fw: parsing manifests\")\n        content = open(path).read()\n        return json.loads(content)", "response": "parse manifest at path return JSON object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if path is more than a day old", "response": "def manifest_path_is_old(self, path):\n        '''return true if path is more than a day old'''\n        mtime = os.path.getmtime(path)\n        return (time.time() - mtime) > 24*60*60"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing manifests present on system", "response": "def manifests_parse(self):\n        '''parse manifests present on system'''\n        self.manifests = []\n        for manifest_path in self.find_manifests():\n            if self.manifest_path_is_old(manifest_path):\n                print(\"fw: Manifest (%s) is old; consider 'manifest download'\" % (manifest_path))\n            manifest = self.manifest_parse(manifest_path)\n            if self.semver_major(manifest[\"format-version\"]) != 1:\n                print(\"fw: Manifest (%s) has major version %d; MAVProxy only understands version 1\" % (manifest_path,manifest[\"format-version\"]))\n                continue\n            self.manifests.append(manifest)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling rapidly by mavproxy", "response": "def idle_task(self):\n        '''called rapidly by mavproxy'''\n        if self.downloaders_lock.acquire(False):\n            removed_one = False\n            for url in self.downloaders.keys():\n                if not self.downloaders[url].is_alive():\n                    print(\"fw: Download thread for (%s) done\" % url)\n                    del self.downloaders[url]\n                    removed_one = True\n            if removed_one and not self.downloaders.keys():\n                # all downloads finished - parse them\n                self.manifests_parse()\n\n            self.downloaders_lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a version of url safe for use as a filename", "response": "def make_safe_filename_from_url(self, url):\n        '''return a version of url safe for use as a filename'''\n        r = re.compile(\"([^a-zA-Z0-9_.-])\")\n        filename = r.sub(lambda m : \"%\" + str(hex(ord(str(m.group(1))))).upper(), url)\n        return filename"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cmd_msg(self, args):\n        '''control behaviour of the module'''\n        if len(args) == 0:\n            print(self.usage())\n        txt = ' '.join(args)\n        self.master.mav.statustext_send(mavutil.mavlink.MAV_SEVERITY_NOTICE,\n                                        txt)", "response": "control behaviour of the module"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle an incoming mavlink packet", "response": "def mavlink_packet(self, m):\n        \"\"\"handle an incoming mavlink packet\"\"\"\n        mtype = m.get_type()\n        if mtype == 'GPS_RAW':\n            (self.lat, self.lon) = (m.lat, m.lon)\n        elif mtype == 'GPS_RAW_INT':\n            (self.lat, self.lon) = (m.lat / 1.0e7, m.lon / 1.0e7)\n        elif mtype == \"VFR_HUD\":\n            self.heading = m.heading\n            self.alt = m.alt\n            self.airspeed = m.airspeed\n            self.groundspeed = m.groundspeed"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates path and mission as an image file", "response": "def create_imagefile(options, filename, latlon, ground_width, path_objs, mission_obj, fence_obj, width=600, height=600, used_flightmodes=[], mav_type=None):\n    '''create path and mission as an image file'''\n    mt = mp_tile.MPTile(service=options.service)\n\n    map_img = mt.area_to_image(latlon[0], latlon[1],\n                               width, height, ground_width)\n    while mt.tiles_pending() > 0:\n        print(\"Waiting on %u tiles\" % mt.tiles_pending())\n        time.sleep(1)\n    map_img = mt.area_to_image(latlon[0], latlon[1],\n                               width, height, ground_width)\n    # a function to convert from (lat,lon) to (px,py) on the map\n    pixmapper = functools.partial(pixel_coords, ground_width=ground_width, mt=mt, topleft=latlon, width=width)\n    for path_obj in path_objs:\n        path_obj.draw(map_img, pixmapper, None)\n    if mission_obj is not None:\n        for m in mission_obj:\n            m.draw(map_img, pixmapper, None)\n    if fence_obj is not None:\n        fence_obj.draw(map_img, pixmapper, None)\n    if (options is not None and\n        mav_type is not None and\n        options.colour_source == \"flightmode\"):\n        tuples = [ (mode, colour_for_flightmode(mav_type, mode))\n                   for mode in used_flightmodes.keys() ]\n        legend = mp_slipmap.SlipFlightModeLegend(\"legend\", tuples)\n        legend.draw(map_img, pixmapper, None)\n\n    map_img = cv2.cvtColor(map_img, cv2.COLOR_BGR2RGB)\n    cv2.imwrite(filename, map_img)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nindicate a colour to be used to plot a point", "response": "def colour_for_point(mlog, point, instance, options):\n    global colour_expression_exceptions, colour_source_max, colour_source_min\n    '''indicate a colour to be used to plot point'''\n    source = getattr(options, \"colour_source\", \"flightmode\")\n    if source == \"flightmode\":\n        return colour_for_point_flightmode(mlog, point, instance, options)\n\n    # evaluate source as an expression which should return a\n    # number in the range 0..255\n    try:\n        v = eval(source, globals(),mlog.messages)\n    except Exception as e:\n        str_e = str(e)\n        try:\n            count = colour_expression_exceptions[str_e]\n        except KeyError:\n            colour_expression_exceptions[str_e] = 0\n            count = 0\n        if count > 100:\n            print(\"Too many exceptions processing (%s): %s\" % (source, str_e))\n            sys.exit(1)\n        colour_expression_exceptions[str_e] += 1\n        v = 0\n\n    # we don't use evaluate_expression as we want the exceptions...\n#    v = mavutil.evaluate_expression(source, mlog.messages)\n\n    if v is None:\n        v = 0\n    elif isinstance(v, str):\n        print(\"colour expression returned a string: %s\" % v)\n        sys.exit(1)\n    elif v < 0:\n        print(\"colour expression returned %d (< 0)\" % v)\n        v = 0\n    elif v > 255:\n        print(\"colour expression returned %d (> 255)\" % v)\n        v = 255\n\n    if v < colour_source_min:\n        colour_source_min = v\n    if v > colour_source_max:\n        colour_source_max = v\n\n    r = 255\n    g = 255\n    b = v\n    return (b,b,b)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mavflightview_mav(mlog, options=None, flightmode_selections=[]):\n    '''create a map for a log file'''\n    wp = mavwp.MAVWPLoader()\n    if options.mission is not None:\n        wp.load(options.mission)\n    fen = mavwp.MAVFenceLoader()\n    if options.fence is not None:\n        fen.load(options.fence)\n    all_false = True\n    for s in flightmode_selections:\n        if s:\n            all_false = False\n    idx = 0\n    path = [[]]\n    instances = {}\n    ekf_counter = 0\n    nkf_counter = 0\n    types = ['MISSION_ITEM','CMD']\n    if options.types is not None:\n        types.extend(options.types.split(','))\n    else:\n        types.extend(['GPS','GLOBAL_POSITION_INT'])\n        if options.rawgps or options.dualgps:\n            types.extend(['GPS', 'GPS_RAW_INT'])\n        if options.rawgps2 or options.dualgps:\n            types.extend(['GPS2_RAW','GPS2'])\n        if options.ekf:\n            types.extend(['EKF1', 'GPS'])\n        if options.nkf:\n            types.extend(['NKF1', 'GPS'])\n        if options.ahr2:\n            types.extend(['AHR2', 'AHRS2', 'GPS'])\n    print(\"Looking for types %s\" % str(types))\n\n    last_timestamps = {}\n    used_flightmodes = {}\n\n    while True:\n        try:\n            m = mlog.recv_match(type=types)\n            if m is None:\n                break\n        except Exception:\n            break\n\n        type = m.get_type()\n\n        if type == 'MISSION_ITEM':\n            try:\n                while m.seq > wp.count():\n                    print(\"Adding dummy WP %u\" % wp.count())\n                    wp.set(m, wp.count())\n                wp.set(m, m.seq)\n            except Exception:\n                pass\n            continue\n        if type == 'CMD':\n            m = mavutil.mavlink.MAVLink_mission_item_message(0,\n                                                             0,\n                                                             m.CNum,\n                                                             mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT,\n                                                             m.CId,\n                                                             0, 1,\n                                                             m.Prm1, m.Prm2, m.Prm3, m.Prm4,\n                                                             m.Lat, m.Lng, m.Alt)\n            try:\n                while m.seq > wp.count():\n                    print(\"Adding dummy WP %u\" % wp.count())\n                    wp.set(m, wp.count())\n                wp.set(m, m.seq)\n            except Exception:\n                pass\n            continue\n        if not mlog.check_condition(options.condition):\n            continue\n        if options.mode is not None and mlog.flightmode.lower() != options.mode.lower():\n            continue\n\n        if not all_false and len(flightmode_selections) > 0 and idx < len(options._flightmodes) and m._timestamp >= options._flightmodes[idx][2]:\n            idx += 1\n        elif (idx < len(flightmode_selections) and flightmode_selections[idx]) or all_false or len(flightmode_selections) == 0:\n            used_flightmodes[mlog.flightmode] = 1\n            if type in ['GPS','GPS2']:\n                status = getattr(m, 'Status', None)\n                if status is None:\n                    status = getattr(m, 'FixType', None)\n                    if status is None:\n                        print(\"Can't find status on GPS message\")\n                        print(m)\n                        break\n                if status < 2:\n                    continue\n                # flash log\n                lat = m.Lat\n                lng = getattr(m, 'Lng', None)\n                if lng is None:\n                    lng = getattr(m, 'Lon', None)\n                    if lng is None:\n                        print(\"Can't find longitude on GPS message\")\n                        print(m)\n                        break\n            elif type in ['EKF1', 'ANU1']:\n                pos = mavextra.ekf1_pos(m)\n                if pos is None:\n                    continue\n                ekf_counter += 1\n                if ekf_counter % options.ekf_sample != 0:\n                    continue\n                (lat, lng) = pos\n            elif type in ['NKF1']:\n                pos = mavextra.ekf1_pos(m)\n                if pos is None:\n                    continue\n                nkf_counter += 1\n                if nkf_counter % options.nkf_sample != 0:\n                    continue\n                (lat, lng) = pos\n            elif type in ['ANU5']:\n                (lat, lng) = (m.Alat*1.0e-7, m.Alng*1.0e-7)\n            elif type in ['AHR2', 'POS', 'CHEK']:\n                (lat, lng) = (m.Lat, m.Lng)\n            elif type == 'AHRS2':\n                (lat, lng) = (m.lat*1.0e-7, m.lng*1.0e-7)\n            elif type == 'ORGN':\n                (lat, lng) = (m.Lat, m.Lng)\n            else:\n                lat = m.lat * 1.0e-7\n                lng = m.lon * 1.0e-7\n\n            # automatically add new types to instances\n            if type not in instances:\n                instances[type] = len(instances)\n                while len(instances) >= len(path):\n                    path.append([])\n            instance = instances[type]\n\n            if abs(lat)>0.01 or abs(lng)>0.01:\n                colour = colour_for_point(mlog, (lat, lng), instance, options)\n                point = (lat, lng, colour)\n\n                if options.rate == 0 or not type in last_timestamps or m._timestamp - last_timestamps[type] > 1.0/options.rate:\n                    last_timestamps[type] = m._timestamp\n                    path[instance].append(point)\n    if len(path[0]) == 0:\n        print(\"No points to plot\")\n        return None\n\n    return [path, wp, fen, used_flightmodes, getattr(mlog, 'mav_type',None)]", "response": "create a map for a log file"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntranslates mavlink python messages in json string", "response": "def mavlink_to_json(msg):\n    '''Translate mavlink python messages in json string'''\n    ret = '\\\"%s\\\": {' % msg._type\n    for fieldname in msg._fieldnames:\n        data = getattr(msg, fieldname)\n        ret += '\\\"%s\\\" : \\\"%s\\\", ' % (fieldname, data)\n    ret = ret[0:-2] + '}'\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mpstatus_to_json(status):\n    '''Translate MPStatus in json string'''\n    msg_keys = list(status.msgs.keys())\n    data = '{'\n    for key in msg_keys[:-1]:\n        data += mavlink_to_json(status.msgs[key]) + ','\n    data += mavlink_to_json(status.msgs[msg_keys[-1]])\n    data += '}'\n    return data", "response": "Translate MPStatus in json string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset ip and port", "response": "def set_ip_port(self, ip, port):\n        '''set ip and port'''\n        self.address = ip\n        self.port = port\n        self.stop()\n        self.start()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stop(self):\n        '''Stop server'''\n        self.app = None\n        if self.run_thread:\n            self.run_thread = None\n        if self.server:\n            self.server.shutdown()\n            self.server = None", "response": "Stop the application and server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_endpoint(self):\n        '''Set endpoits'''\n        self.app.add_url_rule('/rest/mavlink/<path:arg>', 'rest', self.request)\n        self.app.add_url_rule('/rest/mavlink/', 'rest', self.request)", "response": "Add the endpoint to the endpoits list"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cmds(self, args):\n        '''control behaviour of the module'''\n        if not args or len(args) < 1:\n            print(self.usage())\n            return\n\n        if args[0] == \"start\":\n            if self.rest_server.running():\n                print(\"Rest server already running.\")\n                return\n            self.rest_server.start()\n            print(\"Rest server running: %s:%s\" % \\\n                (self.rest_server.address, self.rest_server.port))\n\n        elif args[0] == \"stop\":\n            if not self.rest_server.running():\n                print(\"Rest server is not running.\")\n                return\n            self.rest_server.stop()\n\n        elif args[0] == \"address\":\n            # Check if have necessary amount of arguments\n            if len(args) != 2:\n                print(\"usage: restserver address <ip:port>\")\n                return\n\n            address = args[1].split(':')\n            # Check if argument is correct\n            if len(address) == 2:\n                self.rest_server.set_ip_port(address[0], int(address[1]))\n                return\n\n        else:\n            print(self.usage())", "response": "control behaviour of the module"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef power_status_update(self, POWER_STATUS):\n        '''update POWER_STATUS warnings level'''\n        now = time.time()\n        Vservo = POWER_STATUS.Vservo * 0.001\n        Vcc = POWER_STATUS.Vcc * 0.001\n        self.high_servo_voltage = max(self.high_servo_voltage, Vservo)\n        if self.high_servo_voltage > 1 and Vservo < self.settings.servowarn:\n            if now - self.last_servo_warn_time > 30:\n                self.last_servo_warn_time = now\n                self.say(\"Servo volt %.1f\" % Vservo)\n                if Vservo < 1:\n                    # prevent continuous announcements on power down\n                    self.high_servo_voltage = Vservo\n\n        if Vcc > 0 and Vcc < self.settings.vccwarn:\n            if now - self.last_vcc_warn_time > 30:\n                self.last_vcc_warn_time = now\n                self.say(\"Vcc %.1f\" % Vcc)", "response": "update POWER_STATUS warnings level"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling an incoming mavlink packet", "response": "def mavlink_packet(self, msg):\n        '''handle an incoming mavlink packet'''\n        type = msg.get_type()\n\n        master = self.master\n\n        # add some status fields\n        if type in [ 'RC_CHANNELS_RAW' ]:\n            rc6 = msg.chan6_raw\n            if rc6 > 1500:\n                ign_colour = 'green'\n            else:\n                ign_colour = 'red'\n            self.console.set_status('IGN', 'IGN', fg=ign_colour, row=4)\n\n        if type in [ 'SERVO_OUTPUT_RAW' ]:\n            rc8 = msg.servo8_raw\n            if rc8 < 1200:\n                thr_colour = 'red'\n            elif rc8 < 1300:\n                thr_colour = 'orange'\n            else:\n                thr_colour = 'green'\n            self.console.set_status('THR', 'THR', fg=thr_colour, row=4)\n\n        if type in [ 'RPM' ]:\n            rpm = msg.rpm1\n            if rpm < 3000:\n                rpm_colour = 'red'\n            elif rpm < 10000:\n                rpm_colour = 'orange'\n            else:\n                rpm_colour = 'green'\n            self.console.set_status('RPM', 'RPM: %u' % rpm, fg=rpm_colour, row=4)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend some more WP requests", "response": "def send_wp_requests(self, wps=None):\n        '''send some more WP requests'''\n        if wps is None:\n            wps = self.missing_wps_to_request()\n        tnow = time.time()\n        for seq in wps:\n            #print(\"REQUESTING %u/%u (%u)\" % (seq, self.wploader.expected_count, i))\n            self.wp_requested[seq] = tnow\n            self.master.waypoint_request_send(seq)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wp_status(self):\n        '''show status of wp download'''\n        try:\n            print(\"Have %u of %u waypoints\" % (self.wploader.count()+len(self.wp_received), self.wploader.expected_count))\n        except Exception:\n            print(\"Have %u waypoints\" % (self.wploader.count()+len(self.wp_received)))", "response": "show status of wp download"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing slope of waypoints", "response": "def wp_slope(self):\n        '''show slope of waypoints'''\n        last_w = None\n        for i in range(1, self.wploader.count()):\n            w = self.wploader.wp(i)\n            if w.command not in [mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, mavutil.mavlink.MAV_CMD_NAV_LAND]:\n                continue\n            if last_w is not None:\n                if last_w.frame != w.frame:\n                    print(\"WARNING: frame change %u -> %u at %u\" % (last_w.frame, w.frame, i))\n                delta_alt = last_w.z - w.z\n                if delta_alt == 0:\n                    slope = \"Level\"\n                else:\n                    delta_xy = mp_util.gps_distance(w.x, w.y, last_w.x, last_w.y)\n                    slope = \"%.1f\" % (delta_xy / delta_alt)\n                print(\"WP%u: slope %s\" % (i, slope))\n            last_w = w"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        mtype = m.get_type()\n        if mtype in ['WAYPOINT_COUNT','MISSION_COUNT']:\n            self.wploader.expected_count = m.count\n            if self.wp_op is None:\n                #self.console.error(\"No waypoint load started\")\n                pass\n            else:\n                self.wploader.clear()\n                self.console.writeln(\"Requesting %u waypoints t=%s now=%s\" % (m.count,\n                                                                                 time.asctime(time.localtime(m._timestamp)),\n                                                                                 time.asctime()))\n                self.send_wp_requests()\n\n        elif mtype in ['WAYPOINT', 'MISSION_ITEM'] and self.wp_op is not None:\n            if m.seq < self.wploader.count():\n                #print(\"DUPLICATE %u\" % m.seq)\n                return\n            if m.seq+1 > self.wploader.expected_count:\n                self.console.writeln(\"Unexpected waypoint number %u - expected %u\" % (m.seq, self.wploader.count()))\n            self.wp_received[m.seq] = m\n            next_seq = self.wploader.count()\n            while next_seq in self.wp_received:\n                m = self.wp_received.pop(next_seq)\n                self.wploader.add(m)\n                next_seq += 1\n            if self.wploader.count() != self.wploader.expected_count:\n                #print(\"m.seq=%u expected_count=%u\" % (m.seq, self.wploader.expected_count))\n                self.send_wp_requests()\n                return\n            if self.wp_op == 'list':\n                for i in range(self.wploader.count()):\n                    w = self.wploader.wp(i)\n                    print(\"%u %u %.10f %.10f %f p1=%.1f p2=%.1f p3=%.1f p4=%.1f cur=%u auto=%u\" % (\n                        w.command, w.frame, w.x, w.y, w.z,\n                        w.param1, w.param2, w.param3, w.param4,\n                        w.current, w.autocontinue))\n                if self.logdir is not None:\n                    fname = 'way.txt'\n                    if m.get_srcSystem() != 1:\n                        fname = 'way_%u.txt' % m.get_srcSystem()\n                    waytxt = os.path.join(self.logdir, fname)\n                    self.save_waypoints(waytxt)\n                    print(\"Saved waypoints to %s\" % waytxt)\n                self.loading_waypoints = False\n            elif self.wp_op == \"save\":\n                self.save_waypoints(self.wp_save_filename)\n            self.wp_op = None\n            self.wp_requested = {}\n            self.wp_received = {}\n\n        elif mtype in [\"WAYPOINT_REQUEST\", \"MISSION_REQUEST\"]:\n            self.process_waypoint_request(m, self.master)\n\n        elif mtype in [\"WAYPOINT_CURRENT\", \"MISSION_CURRENT\"]:\n            if m.seq != self.last_waypoint:\n                self.last_waypoint = m.seq\n                if self.settings.wpupdates:\n                    self.say(\"waypoint %u\" % m.seq,priority='message')\n\n        elif mtype == \"MISSION_ITEM_REACHED\":\n            wp = self.wploader.wp(m.seq)\n            if wp is None:\n                # should we spit out a warning?!\n                # self.say(\"No waypoints\")\n                pass\n            else:\n                if wp.command == mavutil.mavlink.MAV_CMD_DO_LAND_START:\n                    alt_offset = self.get_mav_param('ALT_OFFSET', 0)\n                    if alt_offset > 0.005:\n                        self.say(\"ALT OFFSET IS NOT ZERO passing DO_LAND_START\")", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_waypoints(self, filename):\n        '''save waypoints to a file'''\n        try:\n            #need to remove the leading and trailing quotes in filename\n            self.wploader.save(filename.strip('\"'))\n        except Exception as msg:\n            print(\"Failed to save %s - %s\" % (filename, msg))\n            return\n        print(\"Saved %u waypoints to %s\" % (self.wploader.count(), filename))", "response": "save waypoints to a file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving waypoints to a file in a human readable CSV file", "response": "def save_waypoints_csv(self, filename):\n        '''save waypoints to a file in a human readable CSV file'''\n        try:\n            #need to remove the leading and trailing quotes in filename\n            self.wploader.savecsv(filename.strip('\"'))\n        except Exception as msg:\n            print(\"Failed to save %s - %s\" % (filename, msg))\n            return\n        print(\"Saved %u waypoints to CSV %s\" % (self.wploader.count(), filename))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nofly_add(self):\n        '''add a square flight exclusion zone'''\n        try:\n            latlon = self.module('map').click_position\n        except Exception:\n            print(\"No position chosen\")\n            return\n        loader = self.wploader\n        (center_lat, center_lon) = latlon\n        points = []\n        points.append(mp_util.gps_offset(center_lat, center_lon, -25,  25))\n        points.append(mp_util.gps_offset(center_lat, center_lon,  25,  25))\n        points.append(mp_util.gps_offset(center_lat, center_lon,  25, -25))\n        points.append(mp_util.gps_offset(center_lat, center_lon, -25, -25))\n        start_idx = loader.count()\n        for p in points:\n            wp = mavutil.mavlink.MAVLink_mission_item_message(0, 0, 0, 0, mavutil.mavlink.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION,\n                                                              0, 1, 4, 0, 0, 0, p[0], p[1], 0)\n            loader.add(wp)\n        self.loading_waypoints = True\n        self.loading_waypoint_lasttime = time.time()\n        self.master.mav.mission_write_partial_list_send(self.target_system,\n                                                        self.target_component,\n                                                        start_idx, start_idx+4)\n        print(\"Added nofly zone\")", "response": "add a square flight exclusion zone"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling wp change target alt of multiple waypoints", "response": "def cmd_wp_changealt(self, args):\n        '''handle wp change target alt of multiple waypoints'''\n        if len(args) < 2:\n            print(\"usage: wp changealt WPNUM NEWALT <NUMWP>\")\n            return\n        idx = int(args[0])\n        if idx < 1 or idx > self.wploader.count():\n            print(\"Invalid wp number %u\" % idx)\n            return\n        newalt = float(args[1])\n        if len(args) >= 3:\n            count = int(args[2])\n        else:\n            count = 1\n\n        for wpnum in range(idx, idx+count):\n            wp = self.wploader.wp(wpnum)\n            if not self.wploader.is_location_command(wp.command):\n                continue\n            wp.z = newalt\n            wp.target_system    = self.target_system\n            wp.target_component = self.target_component\n            self.wploader.set(wp, wpnum)\n\n        self.loading_waypoints = True\n        self.loading_waypoint_lasttime = time.time()\n        self.master.mav.mission_write_partial_list_send(self.target_system,\n                                                        self.target_component,\n                                                        idx, idx+count)\n        print(\"Changed alt for WPs %u:%u to %f\" % (idx, idx+(count-1), newalt))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfix up jumps when we add or remove rows", "response": "def fix_jumps(self, idx, delta):\n        '''fix up jumps when we add/remove rows'''\n        numrows = self.wploader.count()\n        for row in range(numrows):\n            wp = self.wploader.wp(row)\n            jump_cmds = [mavutil.mavlink.MAV_CMD_DO_JUMP]\n            if hasattr(mavutil.mavlink, \"MAV_CMD_DO_CONDITION_JUMP\"):\n                jump_cmds.append(mavutil.mavlink.MAV_CMD_DO_CONDITION_JUMP)\n            if wp.command in jump_cmds:\n                p1 = int(wp.param1)\n                if p1 > idx and p1+delta>0:\n                    wp.param1 = float(p1+delta)\n                    self.wploader.set(wp, row)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef csv_line(self, line):\n        '''turn a list of values into a CSV line'''\n        self.csv_sep = \",\"\n        return self.csv_sep.join(['\"' + str(x) + '\"' for x in line])", "response": "turn a list of values into a CSV line"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef savecsv(self, filename):\n        '''save waypoints to a file in human-readable CSV file'''\n        f = open(filename, mode='w')\n        headers = [\"Seq\", \"Frame\", \"Cmd\", \"P1\", \"P2\", \"P3\", \"P4\", \"X\", \"Y\", \"Z\"]\n        print(self.csv_line(headers))\n        f.write(self.csv_line(headers) + \"\\n\")\n        for w in self.wploader.wpoints:\n            if getattr(w, 'comment', None):\n#                f.write(\"# %s\\n\" % w.comment)\n                pass\n            out_list = [ w.seq,\n                         self.pretty_enum_value('MAV_FRAME', w.frame),\n                         self.pretty_enum_value('MAV_CMD', w.command),\n                         self.pretty_parameter_value(w.param1),\n                         self.pretty_parameter_value(w.param2),\n                         self.pretty_parameter_value(w.param3),\n                         self.pretty_parameter_value(w.param4),\n                         self.pretty_parameter_value(w.x),\n                         self.pretty_parameter_value(w.y),\n                         self.pretty_parameter_value(w.z),\n                         ]\n            print(self.csv_line(out_list))\n            f.write(self.csv_line(out_list) + \"\\n\")\n        f.close()", "response": "save waypoints to a file in human - readable CSV file"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint a list of available joysticks", "response": "def list_joysticks():\n    '''Print a list of available joysticks'''\n\n    print('Available joysticks:')\n    print()\n    for jid in range(pygame.joystick.get_count()):\n        j = pygame.joystick.Joystick(jid)\n        print('({}) {}'.format(jid, j.get_name()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef select_joystick():\n    '''Allow user to select a joystick from a menu'''\n\n    list_joysticks()\n\n    while True:\n        print('Select a joystick (L to list, Q to quit)'),\n        choice = sys.stdin.readline().strip()\n\n        if choice.lower() == 'l':\n            list_joysticks()\n        elif choice.lower() == 'q':\n            return\n        elif choice.isdigit():\n            jid = int(choice)\n            if jid not in range(pygame.joystick.get_count()):\n                print('Invalid joystick.')\n                continue\n            break\n        else:\n            print('What?')\n\n    return jid", "response": "Allow user to select a joystick from a menu"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef select(versions, optionsRequired=False):\n    if type(versions) == str:\n        versions = [versions]\n\n    global _selected\n    if _selected is not None:\n        # A version was previously selected, ensure that it matches\n        # this new request\n        for ver in versions:\n            if _selected.Score(_wxPackageInfo(ver), optionsRequired) > 0:\n                return\n        # otherwise, raise an exception\n        raise VersionError(\"A previously selected wx version does not match the new request.\")\n\n    # If we get here then this is the first time wxversion is used, \n    # ensure that wxPython hasn't been imported yet.\n    if sys.modules.has_key('wx') or sys.modules.has_key('wxPython'):\n        raise AlreadyImportedError(\"wxversion.select() must be called before wxPython is imported\")\n    \n    # Look for a matching version and manipulate the sys.path as\n    # needed to allow it to be imported.\n    installed = _find_installed(True)\n    bestMatch = _get_best_match(installed, versions, optionsRequired)\n    \n    if bestMatch is None:\n        raise VersionError(\"Requested version of wxPython not found\")\n\n    sys.path.insert(0, bestMatch.pathname)\n    # q.v. Bug #1409256\n    path64 = re.sub('/lib/','/lib64/',bestMatch.pathname)\n    if os.path.isdir(path64):\n        sys.path.insert(0, path64)\n    _selected = bestMatch", "response": "Select a wxPython installation that matches a specific version string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if wxPython is installed that matches one of the given versions.", "response": "def checkInstalled(versions, optionsRequired=False):\n    \"\"\"\n    Check if there is a version of wxPython installed that matches one\n    of the versions given.  Returns True if so, False if not.  This\n    can be used to determine if calling `select` will succeed or not.\n\n        :param versions: Same as in `select`, either a string or a list\n            of strings specifying the version(s) to check for.\n\n        :param optionsRequired: Same as in `select`.\n    \"\"\"\n    \n    if type(versions) == str:\n        versions = [versions]\n    installed = _find_installed()\n    bestMatch = _get_best_match(installed, versions, optionsRequired)\n    return bestMatch is not None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of strings representing the installed wxPython versions on the system.", "response": "def getInstalled():\n    \"\"\"\n    Returns a list of strings representing the installed wxPython\n    versions that are found on the system.\n    \"\"\"\n    installed = _find_installed()\n    return [os.path.basename(p.pathname)[3:] for p in installed]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef menu_callback(m):\n    '''called on menu selection'''\n    if m.returnkey.startswith('# '):\n        cmd = m.returnkey[2:]\n        if m.handler is not None:\n            if m.handler_result is None:\n                return\n            cmd += m.handler_result\n        process_stdin(cmd)\n    elif m.returnkey == 'menuSettings':\n        wxsettings.WXSettings(mestate.settings)\n    elif m.returnkey.startswith(\"mode-\"):\n        idx = int(m.returnkey[5:])\n        mestate.flightmode_selections[idx] = m.IsChecked()\n    elif m.returnkey.startswith(\"loadLog\"):\n        print(\"File: \" + m.returnkey[8:])\n    elif m.returnkey == 'quit':\n        mestate.console.close()\n        mestate.exit = True\n        print(\"Exited. Press Enter to continue.\")\n        sys.exit(0)\n\n    else:\n        print('Unknown menu selection: %s' % m.returnkey)", "response": "called on menu selection"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads graphs from mavgraphs. xml", "response": "def load_graphs():\n    '''load graphs from mavgraphs.xml'''\n    mestate.graphs = []\n    gfiles = ['mavgraphs.xml']\n    if 'HOME' in os.environ:\n        for dirname, dirnames, filenames in os.walk(os.path.join(os.environ['HOME'], \".mavproxy\")):\n            for filename in filenames:\n                if filename.lower().endswith('.xml'):\n                    gfiles.append(os.path.join(dirname, filename))\n    elif 'LOCALAPPDATA' in os.environ:\n        for dirname, dirnames, filenames in os.walk(os.path.join(os.environ['LOCALAPPDATA'], \"MAVProxy\")):\n            for filename in filenames:\n                if filename.lower().endswith('.xml'):\n                    gfiles.append(os.path.join(dirname, filename))\n\n    for file in gfiles:\n        if not os.path.exists(file):\n            continue\n        graphs = load_graph_xml(open(file).read(), file)\n        if graphs:\n            mestate.graphs.extend(graphs)\n            mestate.console.writeln(\"Loaded %s\" % file)\n    # also load the built in graphs\n    try:\n        dlist = pkg_resources.resource_listdir(\"MAVProxy\", \"tools/graphs\")\n        for f in dlist:\n            raw = pkg_resources.resource_stream(\"MAVProxy\", \"tools/graphs/%s\" % f).read()\n            graphs = load_graph_xml(raw, None)\n            if graphs:\n                mestate.graphs.extend(graphs)\n                mestate.console.writeln(\"Loaded %s\" % f)\n    except Exception:\n        #we're in a Windows exe, where pkg_resources doesn't work\n        import pkgutil\n        for f in [\"ekf3Graphs.xml\", \"ekfGraphs.xml\", \"mavgraphs.xml\", \"mavgraphs2.xml\"]:\n            raw = pkgutil.get_data( 'MAVProxy', 'tools//graphs//' + f)\n            graphs = load_graph_xml(raw, None)\n            if graphs:\n                mestate.graphs.extend(graphs)\n                mestate.console.writeln(\"Loaded %s\" % f)\n    mestate.graphs = sorted(mestate.graphs, key=lambda g: g.name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn mapping of flight mode to colours", "response": "def flightmode_colours():\n    '''return mapping of flight mode to colours'''\n    from MAVProxy.modules.lib.grapher import flightmode_colours\n    mapping = {}\n    idx = 0\n    for (mode,t0,t1) in flightmodes:\n        if not mode in mapping:\n            mapping[mode] = flightmode_colours[idx]\n            idx += 1\n            if idx >= len(flightmode_colours):\n                idx = 0\n    return mapping"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndisplaying fft from log", "response": "def cmd_fft(args):\n    '''display fft from log'''\n    from MAVProxy.modules.lib import mav_fft\n    if len(args) > 0:\n        condition = args[0]\n    else:\n        condition = None\n    child = multiproc.Process(target=mav_fft.mavfft_display, args=[mestate.filename,condition])\n    child.start()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save_graph(graphdef):\n    '''save a graph as XML'''\n    if graphdef.filename is None:\n        if 'HOME' in os.environ:\n            dname = os.path.join(os.environ['HOME'], '.mavproxy')\n            if os.path.exists(dname):\n                mp_util.mkdir_p(dname)\n                graphdef.filename = os.path.join(dname, 'mavgraphs.xml')\n        elif 'LOCALAPPDATA' in os.environ:\n            dname = os.path.join(os.environ['LOCALAPPDATA'], 'MAVProxy')\n            if os.path.exists(dname):\n                mp_util.mkdir_p(dname)\n                graphdef.filename = os.path.join(dname, 'mavgraphs.xml')\n        else:\n            graphdef.filename = 'mavgraphs.xml'\n    if graphdef.filename is None:\n        print(\"No file to save graph to\")\n        return\n    try:\n        graphs = load_graph_xml(open(graphdef.filename).read(), graphdef.filename, load_all=True)\n    except Exception:\n        graphs = []\n    found_name = False\n    for i in range(len(graphs)):\n        if graphs[i].name == graphdef.name:\n            graphs[i] = graphdef\n            found_name = True\n            break\n    if not found_name:\n        graphs.append(graphdef)\n    pipe_console_input.send(\"Saving %u graphs to %s\" % (len(graphs), graphdef.filename))\n    f = open(graphdef.filename, \"w\")\n    f.write(\"<graphs>\\n\\n\")\n    for g in graphs:\n        f.write(\" <graph name='%s'>\\n\" % g.name.strip())\n        if g.description is None:\n            g.description = ''\n        f.write(\"  <description>%s</description>\\n\" % g.description.strip())\n        for e in g.expressions:\n            f.write(\"  <expression>%s</expression>\\n\" % e.strip())\n        f.write(\" </graph>\\n\\n\")\n    f.write(\"</graphs>\\n\")\n    f.close()", "response": "save a graph as XML"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing for saving a graph", "response": "def save_process(MAVExpLastGraph, child_pipe_console_input, child_pipe_graph_input, statusMsgs):\n    '''process for saving a graph'''\n    from MAVProxy.modules.lib import wx_processguard\n    from MAVProxy.modules.lib.wx_loader import wx\n    from MAVProxy.modules.lib.wxgrapheditor import GraphDialog\n    \n    #This pipe is used to send text to the console\n    global pipe_console_input\n    pipe_console_input = child_pipe_console_input\n\n    #This pipe is used to send graph commands\n    global pipe_graph_input\n    pipe_graph_input = child_pipe_graph_input\n    \n    #The valid expression messages, required to\n    #validate the expression in the dialog box\n    global msgs\n    msgs = statusMsgs\n    \n    app = wx.App(False)\n    if MAVExpLastGraph.description is None:\n        MAVExpLastGraph.description = ''\n    frame = GraphDialog('Graph Editor',\n                        MAVExpLastGraph,\n                        save_callback)\n    frame.ShowModal()\n    frame.Destroy()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing messages in a random order", "response": "def cmd_messages(args):\n    '''show messages'''\n    if len(args) > 0:\n        wildcard = args[0]\n        if wildcard.find('*') == -1 and wildcard.find('?') == -1:\n            wildcard = \"*\" + wildcard + \"*\"\n    else:\n        wildcard = '*'\n    mestate.mlog.rewind()\n    types = set(['MSG','STATUSTEXT'])\n    while True:\n        m = mestate.mlog.recv_match(type=types, condition=mestate.settings.condition)\n        if m is None:\n            break\n        if m.get_type() == 'MSG':\n            mstr = m.Message\n        else:\n            mstr = m.text\n        if fnmatch.fnmatch(mstr.upper(), wildcard.upper()):\n            tstr = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(m._timestamp))\n            print(\"%s %s\" % (tstr, mstr))\n    mestate.mlog.rewind()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef loadfile(args):\n    '''load a log file (path given by arg)'''\n    mestate.console.write(\"Loading %s...\\n\" % args)\n    t0 = time.time()\n    mlog = mavutil.mavlink_connection(args, notimestamps=False,\n                                      zero_time_base=False,\n                                      progress_callback=progress_bar)\n    mestate.filename = args\n    mestate.mlog = mlog\n    mestate.status.msgs = mlog.messages\n    t1 = time.time()\n    mestate.console.write(\"\\ndone (%u messages in %.1fs)\\n\" % (mestate.mlog._count, t1-t0))\n\n    global flightmodes\n    flightmodes = mlog.flightmode_list()\n\n    load_graphs()\n    setup_menus()", "response": "load a log file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process_stdin(line):\n    '''handle commands from user'''\n    if line is None:\n        sys.exit(0)\n\n    line = line.strip()\n    if not line:\n        return\n\n    args = shlex.split(line)\n    cmd = args[0]\n    if cmd == 'help':\n        k = command_map.keys()\n        k.sort()\n        for cmd in k:\n            (fn, help) = command_map[cmd]\n            print(\"%-15s : %s\" % (cmd, help))\n        return\n    if cmd == 'exit':\n        mestate.exit = True\n        return\n\n    if not cmd in command_map:\n        print(\"Unknown command '%s'\" % line)\n        return\n    (fn, help) = command_map[cmd]\n    try:\n        fn(args[1:])\n    except Exception as e:\n        print(\"ERROR in command %s: %s\" % (args[1:], str(e)))", "response": "handle commands from user"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef input_loop():\n    '''wait for user input'''\n    while mestate.exit != True:\n        try:\n            if mestate.exit != True:\n                line = input(mestate.rl.prompt)\n        except EOFError:\n            mestate.exit = True\n            sys.exit(1)\n        mestate.input_queue.put(line)", "response": "wait for user input"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwatch for piped data from save dialog", "response": "def pipeRecvConsole(self):\n        '''watch for piped data from save dialog'''\n        try:\n            while True:\n                console_msg = self.parent_pipe_recv_console.recv()\n                if console_msg is not None:\n                    self.console.writeln(console_msg)\n                time.sleep(0.1)\n        except EOFError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pipeRecvGraph(self):\n        '''watch for piped data from save dialog'''\n        try:\n            while True:\n                graph_rec = self.parent_pipe_recv_graph.recv()\n                if graph_rec is not None:\n                    mestate.input_queue.put(graph_rec)\n                time.sleep(0.1)\n        except EOFError:\n            pass", "response": "watch for piped data from save dialog"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle a mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle a mavlink packet'''\n        mtype = m.get_type()\n        if mtype == \"GLOBAL_POSITION_INT\":\n            for cam in self.camera_list:\n                cam.boSet_GPS(m)\n        if mtype == \"ATTITUDE\":\n            for cam in self.camera_list:\n                cam.boSet_Attitude(m)\n        if mtype == \"CAMERA_STATUS\":\n            print (\"Got Message camera_status\")\n        if mtype == \"CAMERA_FEEDBACK\":\n            print (\"Got Message camera_feedback\")\n            '''self.__vCmdCamTrigger(m)'''\n        if mtype == \"COMMAND_LONG\":\n            if m.command == mavutil.mavlink.MAV_CMD_DO_DIGICAM_CONFIGURE:\n                print (\"Got Message Digicam_configure\")\n                self.__vDecodeDIGICAMConfigure(m)\n            elif m.command == mavutil.mavlink.MAV_CMD_DO_DIGICAM_CONTROL:\n                print (\"Got Message Digicam_control\")\n                self.__vDecodeDIGICAMControl(m)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef idle_task(self):\n        '''called in idle time'''\n        \n        try:\n            datagram = self.port.recvfrom(self.BUFFER_SIZE)\n            data = json.loads(datagram[0])\n            \n        except socket.error as e:\n            if e.errno in [ errno.EAGAIN, errno.EWOULDBLOCK ]:\n                return\n            raise\n        \n        for key in data.keys():\n            self.data[key] = data[key]\n        \n        try:\n            self.master.mav.gps_input_send(\n                self.data['time_usec'],\n                self.data['gps_id'],\n                self.data['ignore_flags'],\n                self.data['time_week_ms'],\n                self.data['time_week'],\n                self.data['fix_type'],\n                self.data['lat'],\n                self.data['lon'],\n                self.data['alt'],\n                self.data['hdop'],\n                self.data['vdop'],\n                self.data['vn'],\n                self.data['ve'],\n                self.data['vd'],\n                self.data['speed_accuracy'],\n                self.data['horiz_accuracy'],\n                self.data['vert_accuracy'],\n                self.data['satellites_visible'])\n        \n        except Exception as e:\n            print(\"GPS Input Failed:\", e)", "response": "called in idle time"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef substitute(self, text, subvars={},\n                   checkmissing=None):\n        '''substitute variables in a string'''\n\n        if checkmissing is None:\n            checkmissing = self.checkmissing\n\n        while True:\n            idx = text.find(self.start_var_token)\n            if idx == -1:\n                return text\n            endidx = text[idx:].find(self.end_var_token)\n            if endidx == -1:\n                raise MAVSubstituteError('missing end of variable: %s' % text[idx:idx+10])\n            varname = text[idx+2:idx+endidx]\n            fullvar = varname\n\n            # allow default value after a :\n            def_value = None\n            colon = varname.find(':')\n            if colon != -1:\n                def_value = varname[colon+1:]\n                varname = varname[:colon]\n\n            if varname in subvars:\n                value = subvars[varname]\n            elif def_value is not None:\n                value = def_value\n            elif checkmissing:\n                raise MAVSubstituteError(\"unknown variable in '%s%s%s'\" % (\n                    self.start_var_token, varname, self.end_var_token))\n            else:\n                return text[0:idx+endidx] + self.substitute(text[idx+endidx:], subvars, checkmissing=False)\n            text = text.replace(\"%s%s%s\" % (self.start_var_token, fullvar, self.end_var_token), str(value))\n        return text", "response": "substitute variables in a string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef RunScript(self, script):\n        '''\n        Actuate on the vehicle through a script. The script is a sequence of\n        commands. Each command is a sequence with the first element as the\n        command name and the remaining values as parameters.\n\n        The script is executed asynchronously by a timer with a period of 0.1\n        seconds. At each timer tick, the next command is executed if it's ready\n        for execution.\n\n        If a command name starts with '.', then the remaining characters are a\n        method name and the arguments are passed to the method call. For\n        example, the command ('.SetEuler', 0, math.pi / 2, 0) sets the vehicle\n        nose up. The methods available for that type of command are in the\n        class property script_available_methods.\n\n        The other possible commands are:\n         - wait(sec): wait for sec seconds. Because of the timer period, some\n           inaccuracy is expected depending on the value of sec.\n         - restart: go back to the first command.\n\n        Example::\n\n            vehicle.RunScript((\n                ('.SetEuler', 0, 0, 0), # Set vehicle level\n                ('wait', 2), # Wait for 2 seconds\n                # Rotate continuously on the x-axis at a rate of 90 degrees per\n                # second\n                ('.SetAngvel', (1, 0, 0), math.pi / 2),\n                ('wait', 5), # Let the vehicle rotating for 5 seconds\n                ('restart',), # Restart the script\n            ))\n        '''\n        self.script = script\n        self.script_command = 0\n        self.script_command_start_time = 0\n        self.script_command_state = 'ready'\n        self.script_timer.Start(100)\n        self.script_wait_time = 0", "response": "This method executes the specified script and returns the result of the command."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ppp_read(self, ppp_fd):\n        '''called from main select loop in mavproxy when the pppd child\n        sends us some data'''\n        buf = os.read(ppp_fd, 100)\n        if len(buf) == 0:\n            # EOF on the child fd\n            self.stop_ppp_link()\n            return\n        print(\"ppp packet len=%u\" % len(buf))\n        master = self.master\n        master.mav.ppp_send(len(buf), buf)", "response": "called from main select loop in main select loop in mavproxy when the pppd child receives us some data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stop_ppp_link(self):\n        '''stop the link'''\n        if self.ppp_fd == -1:\n            return\n        try:\n            self.mpself.select_extra.pop(self.ppp_fd)\n            os.close(self.ppp_fd)\n            os.waitpid(self.pid, 0)\n        except Exception:\n            pass\n        self.pid = -1\n        self.ppp_fd = -1\n        print(\"stopped ppp link\")", "response": "stop the ppp link"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_ppp(self, args):\n        '''set ppp parameters and start link'''\n        usage = \"ppp <command|start|stop>\"\n        if len(args) == 0:\n            print(usage)\n            return\n        if args[0] == \"command\":\n            if len(args) == 1:\n                print(\"ppp.command=%s\" % \" \".join(self.command))\n            else:\n                self.command = args[1:]\n        elif args[0] == \"start\":\n            self.start_ppp_link()\n        elif args[0] == \"stop\":\n            self.stop_ppp_link()\n        elif args[0] == \"status\":\n            self.console.writeln(\"%u packets %u bytes\" % (self.packet_count, self.byte_count))", "response": "set ppp parameters and start link"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles an incoming mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        if m.get_type() == 'PPP' and self.ppp_fd != -1:\n            print(\"got ppp mavlink pkt len=%u\" % m.length)\n            os.write(self.ppp_fd, m.data[:m.length])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef module_matching(self, name):\n        '''Find a list of modules matching a wildcard pattern'''\n        import fnmatch\n        ret = []\n        for mname in self.mpstate.public_modules.keys():\n            if fnmatch.fnmatch(mname, name):\n                ret.append(self.mpstate.public_modules[mname])\n        return ret", "response": "Find a list of modules matching a wildcard pattern"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget time using ATTITUDE. time_boot_ms", "response": "def get_time(self):\n        '''get time, using ATTITUDE.time_boot_ms if in SITL with SIM_SPEEDUP != 1'''\n        systime = time.time() - self.mpstate.start_time_s\n        if not self.mpstate.is_sitl:\n            return systime\n        try:\n            speedup = int(self.get_mav_param('SIM_SPEEDUP',1))\n        except Exception:\n            return systime\n        if speedup != 1:\n            return self.mpstate.attitude_time_s\n        return systime"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dist_string(self, val_meters):\n        '''return a distance as a string'''\n        if self.settings.dist_unit == 'nm':\n            return \"%.1fnm\" % (val_meters * 0.000539957)\n        if self.settings.dist_unit == 'miles':\n            return \"%.1fmiles\" % (val_meters * 0.000621371)\n        return \"%um\" % val_meters", "response": "return a distance as a string"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef speed_convert_units(self, val_ms):\n        '''return a speed in configured units'''\n        if self.settings.speed_unit == 'knots':\n            return val_ms * 1.94384\n        elif self.settings.speed_unit == 'mph':\n            return val_ms * 2.23694\n        return val_ms", "response": "return a speed in configured units"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_prompt(self, prompt):\n        '''set prompt for command line'''\n        if prompt and self.settings.vehicle_name:\n            # add in optional vehicle name\n            prompt = self.settings.vehicle_name + ':' + prompt\n        self.mpstate.rl.set_prompt(prompt)", "response": "set prompt for command line"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef link_label(link):\n        '''return a link label as a string'''\n        if hasattr(link, 'label'):\n            label = link.label\n        else:\n            label = str(link.linknum+1)\n        return label", "response": "return a link label as a string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_primary_vehicle(self, msg):\n        '''see if a msg is from our primary vehicle'''\n        sysid = msg.get_srcSystem()\n        if self.target_system == 0 or self.target_system == sysid:\n            return True\n        return False", "response": "see if a msg is from our primary vehicle"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nallocates a colour to be used for a flight mode", "response": "def next_flightmode_colour(self):\n        '''allocate a colour to be used for a flight mode'''\n        if self.flightmode_colour_index > len(flightmode_colours):\n            print(\"Out of colours; reusing\")\n            self.flightmode_colour_index = 0\n        ret = flightmode_colours[self.flightmode_colour_index]\n        self.flightmode_colour_index += 1\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef flightmode_colour(self, flightmode):\n        '''return colour to be used for rendering a flight mode background'''\n        if flightmode not in self.flightmode_colourmap:\n            self.flightmode_colourmap[flightmode] = self.next_flightmode_colour()\n        return self.flightmode_colourmap[flightmode]", "response": "return colour to be used for rendering a flight mode background"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef xlim_changed(self, axsubplot):\n        '''called when x limits are changed'''\n        xrange = axsubplot.get_xbound()\n        xlim = axsubplot.get_xlim()\n        self.setup_xrange(xrange[1] - xrange[0])\n        if self.draw_events == 0:\n            # ignore limit change before first draw event\n            return\n        if self.xlim_pipe is not None and axsubplot == self.ax1 and xlim != self.xlim:\n            self.xlim = xlim\n            #print('send', self.graph_num, xlim)\n            self.xlim_pipe[1].send(xlim)", "response": "called when x limits are changed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef plotit(self, x, y, fields, colors=[], title=None):\n        '''plot a set of graphs using date for x axis'''\n        pylab.ion()\n        self.fig = pylab.figure(num=1, figsize=(12,6))\n        self.ax1 = self.fig.gca()\n        ax2 = None\n        for i in range(0, len(fields)):\n            if len(x[i]) == 0: continue\n            if self.lowest_x is None or x[i][0] < self.lowest_x:\n                self.lowest_x = x[i][0]\n            if self.highest_x is None or x[i][-1] > self.highest_x:\n                self.highest_x = x[i][-1]\n        if self.highest_x is None or self.lowest_x is None:\n            return\n        self.formatter = matplotlib.dates.DateFormatter('%H:%M:%S')\n        if not self.xaxis:\n            self.setup_xrange(self.highest_x - self.lowest_x)\n            self.ax1.xaxis.set_major_formatter(self.formatter)\n            self.ax1.callbacks.connect('xlim_changed', self.xlim_changed)\n            self.fig.canvas.mpl_connect('draw_event', self.draw_event)\n        empty = True\n        ax1_labels = []\n        ax2_labels = []\n\n        for i in range(0, len(fields)):\n            if len(x[i]) == 0:\n                #print(\"Failed to find any values for field %s\" % fields[i])\n                continue\n            if i < len(colors):\n                color = colors[i]\n            else:\n                color = 'red'\n                (tz, tzdst) = time.tzname\n\n            if self.axes[i] == 2:\n                if ax2 is None:\n                    ax2 = self.ax1.twinx()\n                    ax2.format_coord = self.make_format(ax2, self.ax1)\n                ax = ax2\n                if not self.xaxis:\n                    ax2.xaxis.set_major_locator(self.locator)\n                    ax2.xaxis.set_major_formatter(self.formatter)\n                label = fields[i]\n                if label.endswith(\":2\"):\n                    label = label[:-2]\n                ax2_labels.append(label)\n            else:\n                ax1_labels.append(fields[i])\n                ax = self.ax1\n\n            if self.xaxis:\n                if self.marker is not None:\n                    marker = self.marker\n                else:\n                    marker = '+'\n                if self.linestyle is not None:\n                    linestyle = self.linestyle\n                else:\n                    linestyle = 'None'\n                ax.plot(x[i], y[i], color=color, label=fields[i],\n                        linestyle=linestyle, marker=marker)\n            else:\n                if self.marker is not None:\n                    marker = self.marker\n                else:\n                    marker = 'None'\n                if self.linestyle is not None:\n                    linestyle = self.linestyle\n                else:\n                    linestyle = '-'\n                if len(y[i]) > 0 and isinstance(y[i][0],str):\n                    # assume this is a piece of text to be rendered at a point in time\n                    last_text_time = -1\n                    last_text = None\n                    for n in range(0, len(x[i])):\n                        this_text_time = round(x[i][n], 6)\n                        this_text = y[i][n]\n                        if last_text is None:\n                            last_text = \"[y\" + this_text + \"]\"\n                            last_text_time = this_text_time\n                        elif this_text_time == last_text_time:\n                            last_text += (\"[x\" + this_text + \"]\")\n                        else:\n                            ax.text(last_text_time,\n                                    10,\n                                    last_text,\n                                    rotation=90,\n                                    alpha=0.3,\n                                    verticalalignment='baseline')\n                            last_text = this_text\n                            last_text_time = this_text_time\n                    if last_text is not None:\n                        ax.text(last_text_time, 10, last_text,\n                                rotation=90,\n                                alpha=0.3,\n                                verticalalignment='baseline')\n                else:\n                    ax.plot_date(x[i], y[i], color=color, label=fields[i],\n                                 linestyle=linestyle, marker=marker, tz=None)\n\n            empty = False\n            \n        if self.show_flightmode:\n            alpha = 0.3\n            xlim = self.ax1.get_xlim()\n            for i in range(len(self.flightmode_list)):\n                (mode_name,t0,t1) = self.flightmode_list[i]\n                c = self.flightmode_colour(mode_name)\n                tday0 = self.timestamp_to_days(t0)\n                tday1 = self.timestamp_to_days(t1)\n                if tday0 > xlim[1] or tday1 < xlim[0]:\n                    continue\n                tday0 = max(tday0, xlim[0])\n                tday1 = min(tday1, xlim[1])\n                self.ax1.axvspan(tday0, tday1, fc=c, ec=edge_colour, alpha=alpha)\n                self.modes_plotted[mode_name] = (c, alpha)\n\n        if empty:\n            print(\"No data to graph\")\n            return\n\n        if title is not None:\n            pylab.title(title)\n\n        if self.show_flightmode:\n            mode_patches = []\n            for mode in self.modes_plotted.keys():\n                (color, alpha) = self.modes_plotted[mode]\n                mode_patches.append(matplotlib.patches.Patch(color=color,\n                                                             label=mode, alpha=alpha*1.5))\n            labels = [patch.get_label() for patch in mode_patches]\n            if ax1_labels != []:\n                patches_legend = matplotlib.pyplot.legend(mode_patches, labels, loc=self.legend_flightmode)\n                self.fig.gca().add_artist(patches_legend)\n            else:\n                pylab.legend(mode_patches, labels)\n\n        if ax1_labels != []:\n            self.ax1.legend(ax1_labels,loc=self.legend)\n        if ax2_labels != []:\n            ax2.legend(ax2_labels,loc=self.legend2)", "response": "plot a set of graphs using date for x axis"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_data(self, t, msg, vars):\n        '''add some data'''\n        mtype = msg.get_type()\n        for i in range(0, len(self.fields)):\n            if mtype not in self.field_types[i]:\n                continue\n            f = self.fields[i]\n            simple = self.simple_field[i]\n            if simple is not None:\n                v = getattr(vars[simple[0]], simple[1])\n            else:\n                v = mavutil.evaluate_expression(f, vars)\n            if v is None:\n                continue\n            if self.xaxis is None:\n                xv = t\n            else:\n                xv = mavutil.evaluate_expression(self.xaxis, vars)\n                if xv is None:\n                    continue\n            try:\n                v_f = float(v)\n                xv_f = float(xv)\n            except Exception:\n                continue\n            self.y[i].append(v_f)\n            self.x[i].append(xv_f)", "response": "add some data to the internal list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert log timestamp to days", "response": "def timestamp_to_days(self, timestamp):\n        '''convert log timestamp to days'''\n        if self.tday_base is None:\n            try:\n                self.tday_base = matplotlib.dates.date2num(datetime.datetime.fromtimestamp(timestamp+self.timeshift))\n                self.tday_basetime = timestamp\n            except ValueError:\n                # this can happen if the log is corrupt\n                # ValueError: year is out of range\n                return 0\n        sec_to_days = 1.0 / (60*60*24)\n        return self.tday_base + (timestamp - self.tday_basetime) * sec_to_days"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling xlim change requests from queue", "response": "def xlim_change_check(self, idx):\n        '''handle xlim change requests from queue'''\n        if not self.xlim_pipe[1].poll():\n            return\n        xlim = self.xlim_pipe[1].recv()\n        if xlim is None:\n            return\n        #print(\"recv: \", self.graph_num, xlim)\n        if self.ax1 is not None and xlim != self.xlim:\n            self.xlim = xlim\n            self.fig.canvas.toolbar.push_current()\n            #print(\"setting: \", self.graph_num, xlim)\n            self.ax1.set_xlim(xlim)\n            # trigger the timer, this allows us to setup a v slow animation,\n            # which saves a lot of CPU\n            self.ani.event_source._on_timer()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprocess and display the current state of the object", "response": "def process(self, flightmode_selections, _flightmodes, block=True):\n        '''process and display graph'''\n        self.msg_types = set()\n        self.multiplier = []\n        self.field_types = []\n        self.xlim = None\n        self.flightmode_list = _flightmodes\n\n        # work out msg types we are interested in\n        self.x = []\n        self.y = []\n        self.modes = []\n        self.axes = []\n        self.first_only = []\n        re_caps = re.compile('[A-Z_][A-Z0-9_]+')\n        for f in self.fields:\n            caps = set(re.findall(re_caps, f))\n            self.msg_types = self.msg_types.union(caps)\n            self.field_types.append(caps)\n            self.y.append([])\n            self.x.append([])\n            self.axes.append(1)\n            self.first_only.append(False)\n\n        timeshift = self.timeshift\n\n        for fi in range(0, len(self.mav_list)):\n            mlog = self.mav_list[fi]\n            self.process_mav(mlog, flightmode_selections)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show(self, lenmavlist, block=True, xlim_pipe=None):\n        '''show graph'''\n        if xlim_pipe is not None:\n            xlim_pipe[0].close()\n        self.xlim_pipe = xlim_pipe\n        if self.labels is not None:\n            labels = self.labels.split(',')\n            if len(labels) != len(fields)*lenmavlist:\n                print(\"Number of labels (%u) must match number of fields (%u)\" % (\n                    len(labels), len(fields)*lenmavlist))\n                return\n        else:\n            labels = None\n\n        for fi in range(0, lenmavlist):\n            timeshift = 0\n            for i in range(0, len(self.x)):\n                if self.first_only[i] and fi != 0:\n                    self.x[i] = []\n                    self.y[i] = []\n            if labels:\n                lab = labels[fi*len(self.fields):(fi+1)*len(self.fields)]\n            else:\n                lab = self.fields[:]\n            if self.multi:\n                col = colors[:]\n            else:\n                col = colors[fi*len(self.fields):]\n            self.plotit(self.x, self.y, lab, colors=col, title=self.title)\n            for i in range(0, len(self.x)):\n                self.x[i] = []\n                self.y[i] = []\n\n        if self.xlim_pipe is not None:\n            import matplotlib.animation\n            self.ani = matplotlib.animation.FuncAnimation(self.fig, self.xlim_change_check,\n                                                          frames=10, interval=20000,\n                                                          repeat=True, blit=False)\n            threading.Timer(0.1, self.xlim_timer).start()\n\n        pylab.draw()\n        pylab.show(block=block)", "response": "show graph of the current state of the object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_ublox(self, args):\n        '''control behaviour of the module'''\n        if len(args) == 0:\n            print(self.usage())\n        elif args[0] == \"status\":\n            print(self.cmd_status())\n        elif args[0] == \"set\":\n            self.ublox_settings.command(args[1:])\n        elif args[0] == \"reset\":\n            self.cmd_ublox_reset(args[1:])\n        elif args[0] == \"mga\":\n            self.cmd_ublox_mga(args[1:])\n        else:\n            print(self.usage())", "response": "control behaviour of the module"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nattempts to cold-reboot (factory-reboot) gps module", "response": "def cmd_ublox_reset(self, args):\n        '''attempts to cold-reboot (factory-reboot) gps module'''\n        print(\"Sending uBlox reset\")\n        msg = struct.pack(\"<HBB\", 0xFFFF, 0x0, 0)\n        self.master.mav.gps_inject_data_send(\n            self.target_system,\n            self.target_component,\n            len(msg),\n            bytearray(msg.ljust(110, '\\0')))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef idle_task(self):\n        '''called rapidly by mavproxy'''\n        if self.fix_type >= 3:\n            # don't do anything if we have a fix\n            return\n        if self.mpstate.status.armed:\n            # do not upload data over telemetry link if we are armed\n            # perhaps we should just limit rate instead.\n            return\n        now = time.time()\n        if self.auto:\n            if now-self.last_auto > 2:\n                self.last_auto = now\n                print(\"Doing auto things\")\n                if self.idle_upload_mga_dbd():\n                    self.auto_status = \"DBD uploaded\"\n\n                if not self.idle_upload_mga_online():\n                    self.auto_status = \"Online uploaded\"\n\n                if not self.idle_upload_mga_offline():\n                    self.auto_status = \"Offline uploaded\"", "response": "called rapidly by mavproxy"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_led(self, args):\n        '''send LED pattern as override'''\n        if len(args) < 3:\n            print(\"Usage: led RED GREEN BLUE <RATE>\")\n            return\n        pattern = [0] * 24\n        pattern[0] = int(args[0])\n        pattern[1] = int(args[1])\n        pattern[2] = int(args[2])\n        \n        if len(args) == 4:\n            plen = 4\n            pattern[3] = int(args[3])\n        else:\n            plen = 3\n            \n        self.master.mav.led_control_send(self.settings.target_system,\n                                         self.settings.target_component,\n                                         0, 0, plen, pattern)", "response": "send LED pattern as override"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend LED pattern as override using OreoLED conventions", "response": "def cmd_oreoled(self, args):\n        '''send LED pattern as override, using OreoLED conventions'''\n        if len(args) < 4:\n            print(\"Usage: oreoled LEDNUM RED GREEN BLUE <RATE>\")\n            return\n        lednum = int(args[0])\n        pattern = [0] * 24\n        pattern[0] = ord('R')\n        pattern[1] = ord('G')\n        pattern[2] = ord('B')\n        pattern[3] = ord('0')\n        pattern[4] = 0\n        pattern[5] = int(args[1])\n        pattern[6] = int(args[2])\n        pattern[7] = int(args[3])\n        \n        self.master.mav.led_control_send(self.settings.target_system,\n                                         self.settings.target_component,\n                                         lednum, 255, 8, pattern)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cmd_devid(self, args):\n        '''decode device IDs from parameters'''\n        for p in self.mav_param.keys():\n            if p.startswith('COMPASS_DEV_ID'):\n                mp_util.decode_devid(self.mav_param[p], p)\n            if p.startswith('INS_') and p.endswith('_ID'):\n                mp_util.decode_devid(self.mav_param[p], p)", "response": "decode device IDs from parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds to the default popup menu", "response": "def add_menu(self, menu):\n        '''add to the default popup menu'''\n        from MAVProxy.modules.mavproxy_map import mp_slipmap\n        self.default_popup.add(menu)\n        self.map.add_object(mp_slipmap.SlipDefaultPopup(self.default_popup, combine=True))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling commands for a specific map", "response": "def cmd_map(self, args):\n        '''map commands'''\n        from MAVProxy.modules.mavproxy_map import mp_slipmap\n        if len(args) < 1:\n            print(\"usage: map <icon|set>\")\n        elif args[0] == \"icon\":\n            if len(args) < 3:\n                print(\"Usage: map icon <lat> <lon> <icon>\")\n            else:\n                lat = args[1]\n                lon = args[2]\n                flag = 'flag.png'\n                if len(args) > 3:\n                    flag = args[3] + '.png'\n                icon = self.map.icon(flag)\n                self.map.add_object(mp_slipmap.SlipIcon('icon - %s [%u]' % (str(flag),self.icon_counter),\n                                                           (float(lat),float(lon)),\n                                                   icon, layer=3, rotation=0, follow=False))\n                self.icon_counter += 1\n        elif args[0] == \"set\":\n            self.map_settings.command(args[1:])\n            self.map.add_object(mp_slipmap.SlipBrightness(self.map_settings.brightness))\n        elif args[0] == \"sethome\":\n            self.cmd_set_home(args)\n        elif args[0] == \"sethomepos\":\n            self.cmd_set_homepos(args)\n        elif args[0] == \"setorigin\":\n            self.cmd_set_origin(args)\n        elif args[0] == \"setoriginpos\":\n            self.cmd_set_originpos(args)\n        elif args[0] == \"zoom\":\n            self.cmd_zoom(args)\n        elif args[0] == \"center\":\n            self.cmd_center(args)\n        elif args[0] == \"follow\":\n            self.cmd_follow(args)\n        else:\n            print(\"usage: map <icon|set>\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef colour_for_wp(self, wp_num):\n        '''return a tuple describing the colour a waypoint should appear on the map'''\n        wp = self.module('wp').wploader.wp(wp_num)\n        command = wp.command\n        return self._colour_for_wp_command.get(command, (0,255,0))", "response": "return a tuple describing the colour a waypoint should appear on the map"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the label the waypoint which should appear on the map", "response": "def label_for_waypoint(self, wp_num):\n        '''return the label the waypoint which should appear on the map'''\n        wp = self.module('wp').wploader.wp(wp_num)\n        command = wp.command\n        if command not in self._label_suffix_for_wp_command:\n            return str(wp_num)\n        return str(wp_num) + \"(\" + self._label_suffix_for_wp_command[command] + \")\""}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves a mission nofly polygon", "response": "def remove_mission_nofly(self, key, selection_index):\n        '''remove a mission nofly polygon'''\n        if not self.validate_nofly():\n            print(\"NoFly invalid\")\n            return\n        print(\"NoFly valid\")\n\n        idx = self.selection_index_to_idx(key, selection_index)\n        wploader = self.module('wp').wploader\n\n        if idx < 0 or idx >= wploader.count():\n            print(\"Invalid wp number %u\" % idx)\n            return\n        wp = wploader.wp(idx)\n        if wp.command != mavutil.mavlink.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION:\n            print(\"Not an exclusion point (%u)\" % idx)\n            return\n\n        # we know the list is valid.  Search for the start of the sequence to delete\n        tmp_idx = idx\n        while tmp_idx > 0:\n            tmp = wploader.wp(tmp_idx-1)\n            if (tmp.command != wp.command or\n                tmp.param1 != wp.param1):\n                break\n            tmp_idx -= 1\n\n        start_idx_to_delete = idx - ((idx-tmp_idx)%int(wp.param1))\n        for i in range(int(start_idx_to_delete+wp.param1)-1,start_idx_to_delete-1,-1):\n            # remove in reverse order as wploader.remove re-indexes\n            print(\"Removing at %u\" % i)\n            deadun = wploader.wp(i)\n            wploader.remove(deadun)\n        self.module('wp').send_all_waypoints()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles a popup menu event from the map", "response": "def handle_menu_event(self, obj):\n        '''handle a popup menu event from the map'''\n        menuitem = obj.menuitem\n        if menuitem.returnkey.startswith('# '):\n            cmd = menuitem.returnkey[2:]\n            if menuitem.handler is not None:\n                if menuitem.handler_result is None:\n                    return\n                cmd += menuitem.handler_result\n            self.mpstate.functions.process_stdin(cmd)\n        elif menuitem.returnkey == 'popupRallyRemove':\n            self.remove_rally(obj.selected[0].objkey)\n        elif menuitem.returnkey == 'popupRallyMove':\n            self.move_rally(obj.selected[0].objkey)\n        elif menuitem.returnkey == 'popupMissionSet':\n            self.set_mission(obj.selected[0].objkey, obj.selected[0].extra_info)\n        elif menuitem.returnkey == 'popupMissionRemoveNoFly':\n            self.remove_mission_nofly(obj.selected[0].objkey, obj.selected[0].extra_info)\n        elif menuitem.returnkey == 'popupMissionRemove':\n            self.remove_mission(obj.selected[0].objkey, obj.selected[0].extra_info)\n        elif menuitem.returnkey == 'popupMissionMove':\n            self.move_mission(obj.selected[0].objkey, obj.selected[0].extra_info)\n        elif menuitem.returnkey == 'popupFenceRemove':\n            self.remove_fencepoint(obj.selected[0].objkey, obj.selected[0].extra_info)\n        elif menuitem.returnkey == 'popupFenceMove':\n            self.move_fencepoint(obj.selected[0].objkey, obj.selected[0].extra_info)\n        elif menuitem.returnkey == 'showPosition':\n            self.show_position()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls when an event occurs on the slipmap", "response": "def map_callback(self, obj):\n        '''called when an event happens on the slipmap'''\n        from MAVProxy.modules.mavproxy_map import mp_slipmap\n        if isinstance(obj, mp_slipmap.SlipMenuEvent):\n            self.handle_menu_event(obj)\n            return\n        if not isinstance(obj, mp_slipmap.SlipMouseEvent):\n            return\n        if obj.event.leftIsDown and self.moving_rally is not None:\n            self.click_position = obj.latlon\n            self.click_time = time.time()\n            self.mpstate.functions.process_stdin(\"rally move %u\" % self.moving_rally)\n            self.moving_rally = None\n            return\n        if obj.event.rightIsDown and self.moving_rally is not None:\n            print(\"Cancelled rally move\")\n            self.moving_rally = None\n            return\n        if obj.event.leftIsDown and self.moving_wp is not None:\n            self.click_position = obj.latlon\n            self.click_time = time.time()\n            self.mpstate.functions.process_stdin(\"wp move %u\" % self.moving_wp)\n            self.moving_wp = None\n            return\n        if obj.event.leftIsDown and self.moving_fencepoint is not None:\n            self.click_position = obj.latlon\n            self.click_time = time.time()\n            self.mpstate.functions.process_stdin(\"fence move %u\" % (self.moving_fencepoint+1))\n            self.moving_fencepoint = None\n            return\n        if obj.event.rightIsDown and self.moving_wp is not None:\n            print(\"Cancelled wp move\")\n            self.moving_wp = None\n            return\n        if obj.event.rightIsDown and self.moving_fencepoint is not None:\n            print(\"Cancelled fence move\")\n            self.moving_fencepoint = None\n            return\n        elif obj.event.leftIsDown:\n            if time.time() - self.click_time > 0.1:\n                self.click_position = obj.latlon\n                self.click_time = time.time()\n                self.drawing_update()\n\n            if self.module('misseditor') is not None:\n                self.module('misseditor').update_map_click_position(self.click_position)\n\n        if obj.event.rightIsDown:\n            if self.draw_callback is not None:\n                self.drawing_end()\n                return\n            if time.time() - self.click_time > 0.1:\n                self.click_position = obj.latlon\n                self.click_time = time.time()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndrawing a series of connected lines on the map calling callback when done", "response": "def draw_lines(self, callback):\n        '''draw a series of connected lines on the map, calling callback when done'''\n        from MAVProxy.modules.mavproxy_map import mp_slipmap\n        self.draw_callback = callback\n        self.draw_line = []\n        self.map.add_object(mp_slipmap.SlipDefaultPopup(None))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd_set_homepos(self, args):\n        '''called when user selects \"Set Home\" on map'''\n        (lat, lon) = (self.click_position[0], self.click_position[1])\n        print(\"Setting home to: \", lat, lon)\n        self.master.mav.command_int_send(\n            self.settings.target_system, self.settings.target_component,\n            mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT,\n            mavutil.mavlink.MAV_CMD_DO_SET_HOME,\n            1, # current\n            0, # autocontinue\n            0, # param1\n            0, # param2\n            0, # param3\n            0, # param4\n            int(lat*1e7), # lat\n            int(lon*1e7), # lon\n            0)", "response": "called when user selects Set Home on map"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling when user selects Set Origin ( with height", "response": "def cmd_set_origin(self, args):\n        '''called when user selects \"Set Origin (with height)\" on map'''\n        (lat, lon) = (self.click_position[0], self.click_position[1])\n        alt = self.ElevationMap.GetElevation(lat, lon)\n        print(\"Setting origin to: \", lat, lon, alt)\n        self.master.mav.set_gps_global_origin_send(\n            self.settings.target_system,\n            lat*10000000, # lat\n            lon*10000000, # lon\n            alt*1000)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_set_originpos(self, args):\n        '''called when user selects \"Set Origin\" on map'''\n        (lat, lon) = (self.click_position[0], self.click_position[1])\n        print(\"Setting origin to: \", lat, lon)\n        self.master.mav.set_gps_global_origin_send(\n            self.settings.target_system,\n            lat*10000000, # lat\n            lon*10000000, # lon\n            0*1000)", "response": "called when user selects Set Origin on map"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncontrol center of view", "response": "def cmd_center(self, args):\n        '''control center of view'''\n        if len(args) < 3:\n            print(\"map center LAT LON\")\n            return\n        lat = float(args[1])\n        lon = float(args[2])\n        self.map.set_center(lat, lon)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncontrols following of vehicle", "response": "def cmd_follow(self, args):\n        '''control following of vehicle'''\n        if len(args) < 2:\n            print(\"map follow 0|1\")\n            return\n        follow = int(args[1])\n        self.map.set_follow(follow)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_secondary_vehicle_position(self, m):\n        '''show 2nd vehicle on map'''\n        if m.get_type() != 'GLOBAL_POSITION_INT':\n            return\n        (lat, lon, heading) = (m.lat*1.0e-7, m.lon*1.0e-7, m.hdg*0.01)\n        if abs(lat) < 1.0e-3 and abs(lon) > 1.0e-3:\n            return\n        # hack for OBC2016\n        alt = self.ElevationMap.GetElevation(lat, lon)\n        agl = m.alt * 0.001 - alt\n        agl_s = str(int(agl)) + 'm'\n        self.create_vehicle_icon('VehiclePos2', 'blue', follow=False, vehicle_type='plane')\n        self.map.set_position('VehiclePos2', (lat, lon), rotation=heading, label=agl_s, colour=(0,255,255))", "response": "show 2nd vehicle on map"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles an incoming mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        from MAVProxy.modules.mavproxy_map import mp_slipmap\n        mtype = m.get_type()\n        sysid = m.get_srcSystem()\n\n        if mtype == \"HEARTBEAT\":\n            vname = 'plane'\n            if m.type in [mavutil.mavlink.MAV_TYPE_FIXED_WING]:\n                vname = 'plane'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_GROUND_ROVER]:\n                vname = 'rover'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_SUBMARINE]:\n                vname = 'sub'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_SURFACE_BOAT]:\n                vname = 'boat'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_QUADROTOR,\n                            mavutil.mavlink.MAV_TYPE_HEXAROTOR,\n                            mavutil.mavlink.MAV_TYPE_OCTOROTOR,\n                            mavutil.mavlink.MAV_TYPE_TRICOPTER]:\n                vname = 'copter'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_COAXIAL]:\n                vname = 'singlecopter'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_HELICOPTER]:\n                vname = 'heli'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_ANTENNA_TRACKER]:\n                vname = 'antenna'\n            self.vehicle_type_by_sysid[sysid] = vname\n\n        if not sysid in self.vehicle_type_by_sysid:\n            self.vehicle_type_by_sysid[sysid] = 'plane'\n        self.vehicle_type_name = self.vehicle_type_by_sysid[sysid]\n\n        # this is the beginnings of allowing support for multiple vehicles\n        # in the air at the same time\n        vehicle = 'Vehicle%u' % m.get_srcSystem()\n\n        if mtype == \"SIMSTATE\" and self.map_settings.showsimpos:\n            self.create_vehicle_icon('Sim' + vehicle, 'green')\n            self.map.set_position('Sim' + vehicle, (m.lat*1.0e-7, m.lng*1.0e-7), rotation=math.degrees(m.yaw))\n\n        elif mtype == \"AHRS2\" and self.map_settings.showahrs2pos:\n            self.create_vehicle_icon('AHRS2' + vehicle, 'blue')\n            self.map.set_position('AHRS2' + vehicle, (m.lat*1.0e-7, m.lng*1.0e-7), rotation=math.degrees(m.yaw))\n\n        elif mtype == \"AHRS3\" and self.map_settings.showahrs3pos:\n            self.create_vehicle_icon('AHRS3' + vehicle, 'orange')\n            self.map.set_position('AHRS3' + vehicle, (m.lat*1.0e-7, m.lng*1.0e-7), rotation=math.degrees(m.yaw))\n\n        elif mtype == \"GPS_RAW_INT\" and self.map_settings.showgpspos:\n            (lat, lon) = (m.lat*1.0e-7, m.lon*1.0e-7)\n            if lat != 0 or lon != 0:\n                if m.vel > 300 or 'ATTITUDE' not in self.master.messages:\n                    cog = m.cog*0.01\n                else:\n                    cog = math.degrees(self.master.messages['ATTITUDE'].yaw)\n                self.create_vehicle_icon('GPS' + vehicle, 'blue')\n                self.map.set_position('GPS' + vehicle, (lat, lon), rotation=cog)\n\n        elif mtype == \"GPS2_RAW\" and self.map_settings.showgps2pos:\n            (lat, lon) = (m.lat*1.0e-7, m.lon*1.0e-7)\n            if lat != 0 or lon != 0:\n                self.create_vehicle_icon('GPS2' + vehicle, 'green')\n                self.map.set_position('GPS2' + vehicle, (lat, lon), rotation=m.cog*0.01)\n\n        elif mtype == 'GLOBAL_POSITION_INT':\n            (lat, lon, heading) = (m.lat*1.0e-7, m.lon*1.0e-7, m.hdg*0.01)\n            self.lat_lon[m.get_srcSystem()] = (lat,lon)\n            if abs(lat) > 1.0e-3 or abs(lon) > 1.0e-3:\n                self.have_global_position = True\n                self.create_vehicle_icon('Pos' + vehicle, 'red', follow=True)\n                if len(self.vehicle_type_by_sysid) > 1:\n                    label = str(sysid)\n                else:\n                    label = None\n                self.map.set_position('Pos' + vehicle, (lat, lon), rotation=heading, label=label, colour=(255,255,255))\n                self.map.set_follow_object('Pos' + vehicle, self.is_primary_vehicle(m))\n\n        elif mtype == 'LOCAL_POSITION_NED' and not self.have_global_position:\n            (lat, lon) = mp_util.gps_offset(0, 0, m.x, m.y)\n            self.lat_lon[m.get_srcSystem()] = (lat,lon)\n            heading = math.degrees(math.atan2(m.vy, m.vx))\n            self.create_vehicle_icon('Pos' + vehicle, 'red', follow=True)\n            self.map.set_position('Pos' + vehicle, (lat, lon), rotation=heading)\n            self.map.set_follow_object('Pos' + vehicle, self.is_primary_vehicle(m))\n\n        elif mtype == 'HOME_POSITION':\n            (lat, lon) = (m.latitude*1.0e-7, m.longitude*1.0e-7)\n            icon = self.map.icon('home.png')\n            self.map.add_object(mp_slipmap.SlipIcon('HOME_POSITION',\n                                                            (lat,lon),\n                                                            icon, layer=3, rotation=0, follow=False))\n\n        elif mtype == \"NAV_CONTROLLER_OUTPUT\":\n            tlayer = 'Trajectory%u' % m.get_srcSystem()\n            if (self.master.flightmode in [ \"AUTO\", \"GUIDED\", \"LOITER\", \"RTL\", \"QRTL\", \"QLOITER\", \"QLAND\", \"FOLLOW\" ] and\n                m.get_srcSystem() in self.lat_lon):\n                (lat,lon) = self.lat_lon[m.get_srcSystem()]\n                trajectory = [ (lat, lon),\n                                mp_util.gps_newpos(lat, lon, m.target_bearing, m.wp_dist) ]\n                self.map.add_object(mp_slipmap.SlipPolygon('trajectory',\n                                                           trajectory, layer=tlayer,\n                                                               linewidth=2, colour=(255,0,180)))\n            else:\n                self.map.add_object(mp_slipmap.SlipClearLayer(tlayer))\n\n        elif mtype == \"POSITION_TARGET_GLOBAL_INT\":\n            # FIXME: base this off SYS_STATUS.MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL?\n            if not m.get_srcSystem() in self.lat_lon:\n                return\n            tlayer = 'PostionTarget%u' % m.get_srcSystem()\n            (lat,lon) = self.lat_lon[m.get_srcSystem()]\n            if (self.master.flightmode in [ \"AUTO\", \"GUIDED\", \"LOITER\", \"RTL\", \"QRTL\", \"QLOITER\", \"QLAND\", \"FOLLOW\" ]):\n                lat_float = m.lat_int*1e-7\n                lon_float = m.lon_int*1e-7\n                vec = [ (lat_float, lon_float),\n                        (lat, lon) ]\n                self.map.add_object(mp_slipmap.SlipPolygon('position_target',\n                                                           vec,\n                                                           layer=tlayer,\n                                                           linewidth=2,\n                                                           colour=(0,255,0)))\n            else:\n                self.map.add_object(mp_slipmap.SlipClearLayer(tlayer))\n\n        if not self.is_primary_vehicle(m):\n            # the rest should only be done for the primary vehicle\n            return\n\n        # if the waypoints have changed, redisplay\n        last_wp_change = self.module('wp').wploader.last_change\n        if self.wp_change_time != last_wp_change and abs(time.time() - last_wp_change) > 1:\n            self.wp_change_time = last_wp_change\n            self.display_waypoints()\n\n            #this may have affected the landing lines from the rally points:\n            self.rally_change_time = time.time()\n\n        # if the fence has changed, redisplay\n        if self.fence_change_time != self.module('fence').fenceloader.last_change:\n            self.display_fence()\n\n        # if the rallypoints have changed, redisplay\n        if self.rally_change_time != self.module('rally').rallyloader.last_change:\n            self.rally_change_time = self.module('rally').rallyloader.last_change\n            icon = self.map.icon('rallypoint.png')\n            self.map.add_object(mp_slipmap.SlipClearLayer('RallyPoints'))\n            for i in range(self.module('rally').rallyloader.rally_count()):\n                rp = self.module('rally').rallyloader.rally_point(i)\n                popup = MPMenuSubMenu('Popup',\n                                      items=[MPMenuItem('Rally Remove', returnkey='popupRallyRemove'),\n                                             MPMenuItem('Rally Move', returnkey='popupRallyMove')])\n                self.map.add_object(mp_slipmap.SlipIcon('Rally %u' % (i+1), (rp.lat*1.0e-7, rp.lng*1.0e-7), icon,\n                                                                layer='RallyPoints', rotation=0, follow=False,\n                                                                popup_menu=popup))\n\n                loiter_rad = self.get_mav_param('WP_LOITER_RAD')\n\n                if self.map_settings.rallycircle:\n                    self.map.add_object(mp_slipmap.SlipCircle('Rally Circ %u' % (i+1), 'RallyPoints', (rp.lat*1.0e-7, rp.lng*1.0e-7),\n                                                                      loiter_rad, (255,255,0), 2, arrow = self.map_settings.showdirection))\n\n                #draw a line between rally point and nearest landing point\n                nearest_land_wp = None\n                nearest_distance = 10000000.0\n                for j in range(self.module('wp').wploader.count()):\n                    w = self.module('wp').wploader.wp(j)\n                    if (w.command == 21): #if landing waypoint\n                        #get distance between rally point and this waypoint\n                        dis = mp_util.gps_distance(w.x, w.y, rp.lat*1.0e-7, rp.lng*1.0e-7)\n                        if (dis < nearest_distance):\n                            nearest_land_wp = w\n                            nearest_distance = dis\n\n                if nearest_land_wp is not None:\n                    points = []\n                    #tangential approach?\n                    if self.get_mav_param('LAND_BREAK_PATH') == 0:\n                        theta = math.degrees(math.atan(loiter_rad / nearest_distance))\n                        tan_dis = math.sqrt(nearest_distance * nearest_distance - (loiter_rad * loiter_rad))\n\n                        ral_bearing = mp_util.gps_bearing(nearest_land_wp.x, nearest_land_wp.y,rp.lat*1.0e-7, rp.lng*1.0e-7)\n\n                        points.append(mp_util.gps_newpos(nearest_land_wp.x,nearest_land_wp.y, ral_bearing + theta, tan_dis))\n\n                    else: #not tangential approach\n                        points.append((rp.lat*1.0e-7, rp.lng*1.0e-7))\n\n                    points.append((nearest_land_wp.x, nearest_land_wp.y))\n                    self.map.add_object(mp_slipmap.SlipPolygon('Rally Land %u' % (i+1), points, 'RallyPoints', (255,255,0), 2))\n\n        # check for any events from the map\n        self.map.check_events()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_snap_wp(self, args):\n        '''snap waypoints to KML'''\n        threshold = 10.0\n        if len(args) > 0:\n            threshold = float(args[0])\n        wpmod = self.module('wp')\n        wploader = wpmod.wploader\n        changed = False\n        for i in range(1,wploader.count()):\n            w = wploader.wp(i)\n            if not wploader.is_location_command(w.command):\n                continue\n            lat = w.x\n            lon = w.y\n            best = None\n            best_dist = (threshold+1)*3\n            for (snap_lat,snap_lon) in self.snap_points:\n                dist = mp_util.gps_distance(lat, lon, snap_lat, snap_lon)\n                if dist < best_dist:\n                    best_dist = dist\n                    best = (snap_lat, snap_lon)\n            if best is not None and best_dist <= threshold:\n                if w.x != best[0] or w.y != best[1]:\n                    w.x = best[0]\n                    w.y = best[1]\n                    print(\"Snapping WP %u to %f %f\" % (i, w.x, w.y))\n                    wploader.set(w, i)\n                    changed = True\n            elif best is not None:\n                if best_dist <= (threshold+1)*3:\n                    print(\"Not snapping wp %u dist %.1f\" % (i, best_dist))\n        if changed:\n            wpmod.send_all_waypoints()", "response": "snap waypoints to KML"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cmd_snap_fence(self, args):\n        '''snap fence to KML'''\n        threshold = 10.0\n        if len(args) > 0:\n            threshold = float(args[0])\n        fencemod = self.module('fence')\n        loader = fencemod.fenceloader\n        changed = False\n        for i in range(0,loader.count()):\n            fp = loader.point(i)\n            lat = fp.lat\n            lon = fp.lng\n            best = None\n            best_dist = (threshold+1)*3\n            for (snap_lat,snap_lon) in self.snap_points:\n                dist = mp_util.gps_distance(lat, lon, snap_lat, snap_lon)\n                if dist < best_dist:\n                    best_dist = dist\n                    best = (snap_lat, snap_lon)\n            if best is not None and best_dist <= threshold:\n                if best[0] != lat or best[1] != lon:\n                    loader.move(i, best[0], best[1])\n                    print(\"Snapping fence point %u to %f %f\" % (i, best[0], best[1]))\n                    changed = True\n            elif best is not None:\n                if best_dist <= (threshold+1)*3:\n                    print(\"Not snapping fence point %u dist %.1f\" % (i, best_dist))\n\n        if changed:\n            fencemod.send_fence()", "response": "snap fence to KML"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets a layer as the geofence", "response": "def fencekml(self, layername):\n        '''set a layer as the geofence'''\n        #Strip quotation marks if neccessary\n        if layername.startswith('\"') and layername.endswith('\"'):\n            layername = layername[1:-1]\n        \n        #for each point in the layer, add it in\n        for layer in self.allayers:\n            if layer.key == layername:\n                #clear the current fence\n                self.fenceloader.clear()\n                if len(layer.points) < 3:\n                    return\n                self.fenceloader.target_system = self.target_system\n                self.fenceloader.target_component = self.target_component\n                #send centrepoint  to fence[0] as the return point\n                bounds = mp_util.polygon_bounds(layer.points)\n                (lat, lon, width, height) = bounds\n                center = (lat+width/2, lon+height/2)\n                self.fenceloader.add_latlon(center[0], center[1])\n                for lat, lon in layer.points:\n                    #add point\n                    self.fenceloader.add_latlon(lat, lon)\n                #and send\n                self.send_fence()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntoggle the display of a kml", "response": "def togglekml(self, layername):\n        '''toggle the display of a kml'''\n        #Strip quotation marks if neccessary\n        if layername.startswith('\"') and layername.endswith('\"'):\n            layername = layername[1:-1]\n        #toggle layer off (plus associated text element)\n        if layername in self.curlayers:\n            for layer in self.curlayers:\n                if layer == layername:\n                    self.mpstate.map.remove_object(layer)\n                    self.curlayers.remove(layername)\n                    if layername in self.curtextlayers:\n                        for clayer in self.curtextlayers:\n                            if clayer == layername:\n                                self.mpstate.map.remove_object(clayer)\n                                self.curtextlayers.remove(clayer)\n        #toggle layer on (plus associated text element)\n        else:\n            for layer in self.allayers:\n                if layer.key == layername:\n                    self.mpstate.map.add_object(layer)\n                    self.curlayers.append(layername)\n                    for alayer in self.alltextlayers:\n                        if alayer.key == layername:\n                            self.mpstate.map.add_object(alayer)\n                            self.curtextlayers.append(layername)\n        self.menu_needs_refreshing = True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clearkml(self):\n        '''Clear the kmls from the map'''\n        #go through all the current layers and remove them\n        for layer in self.curlayers:\n            self.mpstate.map.remove_object(layer)\n        for layer in self.curtextlayers:\n            self.mpstate.map.remove_object(layer)\n        self.allayers = []\n        self.curlayers = []\n        self.alltextlayers = []\n        self.curtextlayers = []\n        self.menu_needs_refreshing = True", "response": "Clear the kmls from the map"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading a kml file and put it on the map", "response": "def loadkml(self, filename):\n        '''Load a kml from file and put it on the map'''\n        #Open the zip file\n        nodes = self.readkmz(filename)\n\n        self.snap_points = []\n\n        #go through each object in the kml...\n        for n in nodes:     \n            point = self.readObject(n)\n\n            #and place any polygons on the map\n            if self.mpstate.map is not None and point[0] == 'Polygon':\n                self.snap_points.extend(point[2])\n\n                #print(\"Adding \" + point[1])\n                newcolour = (random.randint(0, 255), 0, random.randint(0, 255))\n                curpoly = mp_slipmap.SlipPolygon(point[1], point[2],\n                                                             layer=2, linewidth=2, colour=newcolour)\n                self.mpstate.map.add_object(curpoly)\n                self.allayers.append(curpoly)\n                self.curlayers.append(point[1])\n                \n                \n            #and points - barrell image and text\n            if self.mpstate.map is not None and point[0] == 'Point':\n                #print(\"Adding \" + point[1])\n                icon = self.mpstate.map.icon('barrell.png')\n                curpoint = mp_slipmap.SlipIcon(point[1], latlon = (point[2][0][0], point[2][0][1]), layer=3, img=icon, rotation=0, follow=False)\n                curtext = mp_slipmap.SlipLabel(point[1], point = (point[2][0][0], point[2][0][1]), layer=4, label=point[1], colour=(0,255,255))\n                self.mpstate.map.add_object(curpoint)\n                self.mpstate.map.add_object(curtext)\n                self.allayers.append(curpoint)\n                self.alltextlayers.append(curtext)\n                self.curlayers.append(point[1])\n                self.curtextlayers.append(point[1])\n        self.menu_needs_refreshing = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading in a kmz file and returns xml nodes", "response": "def readkmz(self, filename):\n        '''reads in a kmz file and returns xml nodes'''\n        #Strip quotation marks if neccessary\n        filename.strip('\"')\n        #Open the zip file (as applicable)    \n        if filename[-4:] == '.kml':\n            fo = open(filename, \"r\")\n            fstring = fo.read()\n            fo.close()\n        elif filename[-4:] == '.kmz':\n            zip=ZipFile(filename)\n            for z in zip.filelist:\n                if z.filename[-4:] == '.kml':\n                    fstring=zip.read(z)\n                    break\n            else:\n                raise Exception(\"Could not find kml file in %s\" % filename)\n        else:\n            raise Exception(\"Is not a valid kml or kmz file in %s\" % filename)\n                \n        #send into the xml parser\n        kmlstring = parseString(fstring)\n\n        #get all the placenames\n        nodes=kmlstring.getElementsByTagName('Placemark')\n        \n        return nodes"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading in a node and returns as a tuple", "response": "def readObject(self, innode):\n        '''reads in a node and returns as a tuple: (type, name, points[])'''\n        #get name\n        names=innode.getElementsByTagName('name')[0].childNodes[0].data.strip()\n        \n        #get type\n        pointType = 'Unknown'\n        if len(innode.getElementsByTagName('LineString')) == 0 and len(innode.getElementsByTagName('Point')) == 0:\n            pointType = 'Polygon'\n        elif len(innode.getElementsByTagName('Polygon')) == 0 and len(innode.getElementsByTagName('Point')) == 0:\n            pointType = 'Polygon'\n        elif len(innode.getElementsByTagName('LineString')) == 0 and len(innode.getElementsByTagName('Polygon')) == 0:\n            pointType = 'Point'\n            \n        #get coords\n        coords = innode.getElementsByTagName('coordinates')[0].childNodes[0].data.strip()\n        coordsSplit = coords.split()\n        ret_s = []\n        for j in coordsSplit:\n            jcoord = j.split(',')\n            if len(jcoord) == 3 and jcoord[0] != '' and jcoord[1] != '':\n                #print(\"Got lon \" + jcoord[0] + \" and lat \" + jcoord[1])\n                ret_s.append((float(jcoord[1]), float(jcoord[0])))\n            \n        #return tuple\n        return (str(pointType), str(names), ret_s)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart listening for packets", "response": "def start_listener(self):\n        '''start listening for packets'''\n        if self.sock is not None:\n            self.sock.close()\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.sock.bind(('', self.asterix_settings.port))\n        self.sock.setblocking(False)\n        print(\"Started on port %u\" % self.asterix_settings.port)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstopping listening for packets", "response": "def stop_listener(self):\n        '''stop listening for packets'''\n        if self.sock is not None:\n            self.sock.close()\n            self.sock = None\n        self.tracks = {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_secondary_vehicle_position(self, m):\n        '''store second vehicle position for filtering purposes'''\n        if m.get_type() != 'GLOBAL_POSITION_INT':\n            return\n        (lat, lon, heading) = (m.lat*1.0e-7, m.lon*1.0e-7, m.hdg*0.01)\n        if abs(lat) < 1.0e-3 and abs(lon) < 1.0e-3:\n            return\n        self.vehicle2_pos = VehiclePos(m)", "response": "store second vehicle position for filtering purposes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn true if vehicle could come within filter_dist_xy meters of adsb vehicle in timeout seconds", "response": "def could_collide_hor(self, vpos, adsb_pkt):\n        '''return true if vehicle could come within filter_dist_xy meters of adsb vehicle in timeout seconds'''\n        margin = self.asterix_settings.filter_dist_xy\n        timeout = self.asterix_settings.filter_time\n        alat = adsb_pkt.lat * 1.0e-7\n        alon = adsb_pkt.lon * 1.0e-7\n        avel = adsb_pkt.hor_velocity * 0.01\n        vvel = sqrt(vpos.vx**2 + vpos.vy**2)\n        dist = mp_util.gps_distance(vpos.lat, vpos.lon, alat, alon)\n        dist -= avel * timeout\n        dist -= vvel * timeout\n        if dist <= margin:\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning true if vehicle could come within filter_dist_z meters of adsb vehicle in timeout seconds", "response": "def could_collide_ver(self, vpos, adsb_pkt):\n        '''return true if vehicle could come within filter_dist_z meters of adsb vehicle in timeout seconds'''\n        if adsb_pkt.emitter_type < 100 or adsb_pkt.emitter_type > 104:\n            return True\n        margin = self.asterix_settings.filter_dist_z\n        vtype = adsb_pkt.emitter_type - 100\n        valt = vpos.alt\n        aalt1 = adsb_pkt.altitude * 0.001\n        if vtype == 2:\n            # weather, always yes\n            return True\n        if vtype == 4:\n            # bird of prey, always true\n            return True\n        # planes and migrating birds have 150m margin\n        aalt2 = aalt1 + adsb_pkt.ver_velocity * 0.01 * self.asterix_settings.filter_time\n        altsep1 = abs(valt - aalt1)\n        altsep2 = abs(valt - aalt2)\n        if altsep1 > 150 + margin and altsep2 > 150 + margin:\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mavlink_packet(self, m):\n        '''get time from mavlink ATTITUDE'''\n        if m.get_type() == 'GLOBAL_POSITION_INT':\n            if abs(m.lat) < 1000 and abs(m.lon) < 1000:\n                return\n            self.vehicle_pos = VehiclePos(m)", "response": "get time from mavlink ATTITUDE"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncontrol behaviour of the module", "response": "def cmd_system_time(self, args):\n        '''control behaviour of the module'''\n        if len(args) == 0:\n            print(self.usage())\n        elif args[0] == \"status\":\n            print(self.status())\n        elif args[0] == \"set\":\n            self.system_time_settings.command(args[1:])\n        else:\n            print(self.usage())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall rapidly by mavproxy", "response": "def idle_task(self):\n        '''called rapidly by mavproxy'''\n        now = time.time()\n\n        if now-self.last_sent > self.system_time_settings.interval:\n            self.last_sent = now\n            time_us = time.time() * 1000000\n            if self.system_time_settings.verbose:\n                print(\"ST: Sending system time: (%u/%u)\" %\n                      (time_us, self.uptime(),))\n            self.master.mav.system_time_send(time_us,\n                                             self.uptime())\n\n        if (now-self.last_sent_timesync >\n            self.system_time_settings.interval_timesync):\n            self.last_sent_timesync = now\n            time_ns = time.time() * 1000000000\n            time_ns += 1234\n            if self.system_time_settings.verbose:\n                print(\"ST: Sending timesync request\")\n            self.master.mav.timesync_send(0, time_ns)\n            self.last_sent_ts1 = time_ns"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_relay(self, args):\n        '''set relays'''\n        if len(args) == 0 or args[0] not in ['set', 'repeat']:\n            print(\"Usage: relay <set|repeat>\")\n            return\n        if args[0] == \"set\":\n            if len(args) < 3:\n                print(\"Usage: relay set <RELAY_NUM> <0|1>\")\n                return\n            self.master.mav.command_long_send(self.target_system,\n                                                   self.target_component,\n                                                   mavutil.mavlink.MAV_CMD_DO_SET_RELAY, 0,\n                                                   int(args[1]), int(args[2]),\n                                                   0, 0, 0, 0, 0)\n        if args[0] == \"repeat\":\n            if len(args) < 4:\n                print(\"Usage: relay repeat <RELAY_NUM> <COUNT> <PERIOD>\")\n                return\n            self.master.mav.command_long_send(self.target_system,\n                                                   self.target_component,\n                                                   mavutil.mavlink.MAV_CMD_DO_REPEAT_RELAY, 0,\n                                                   int(args[1]), int(args[2]), float(args[3]),\n                                                   0, 0, 0, 0)", "response": "relays a single entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns list of serial ports", "response": "def complete_serial_ports(self, text):\n        '''return list of serial ports'''\n        ports = mavutil.auto_detect_serial(preferred_list=preferred_ports)\n        return [ p.device for p in ports ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns list of links", "response": "def complete_links(self, text):\n        '''return list of links'''\n        try:\n            ret = [ m.address for m in self.mpstate.mav_master ]\n            for m in self.mpstate.mav_master:\n                ret.append(m.address)\n                if hasattr(m, 'label'):\n                    ret.append(m.label)\n            return ret\n        except Exception as e:\n            print(\"Caught exception: %s\" % str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dict based on some_json", "response": "def parse_link_attributes(self, some_json):\n        '''return a dict based on some_json (empty if json invalid)'''\n        try:\n            return json.loads(some_json)\n        except ValueError:\n            print('Invalid JSON argument: {0}'.format(some_json))\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_link_descriptor(self, descriptor):\n        '''parse e.g. 'udpin:127.0.0.1:9877:{\"foo\":\"bar\"}' into\n        python structure (\"udpin:127.0.0.1:9877\", {\"foo\":\"bar\"})'''\n        optional_attributes = {}\n        link_components = descriptor.split(\":{\", 1)\n        device = link_components[0]\n        if (len(link_components) == 2 and link_components[1].endswith(\"}\")):\n            # assume json\n            some_json = \"{\" + link_components[1]\n            optional_attributes = self.parse_link_attributes(some_json)\n        return (device, optional_attributes)", "response": "parse e. g. udp. 127. 0. 1. 9877 into\n python structure"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_link_attributes(self, args):\n        '''change optional link attributes'''\n        link = args[0]\n        attributes = args[1]\n        print(\"Setting link %s attributes (%s)\" % (link, attributes))\n        self.link_attributes(link, attributes)", "response": "change optional link attributes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind a device based on number name or label", "response": "def find_link(self, device):\n        '''find a device based on number, name or label'''\n        for i in range(len(self.mpstate.mav_master)):\n            conn = self.mpstate.mav_master[i]\n            if (str(i) == device or\n                conn.address == device or\n                getattr(conn, 'label', None) == device):\n                return i\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef master_send_callback(self, m, master):\n        '''called on sending a message'''\n        if self.status.watch is not None:\n            for msg_type in self.status.watch:\n                if fnmatch.fnmatch(m.get_type().upper(), msg_type.upper()):\n                    self.mpstate.console.writeln('> '+ str(m))\n                    break\n\n        mtype = m.get_type()\n        if mtype != 'BAD_DATA' and self.mpstate.logqueue:\n            usec = self.get_usec()\n            usec = (usec & ~3) | 3 # linknum 3\n            self.mpstate.logqueue.put(bytearray(struct.pack('>Q', usec) + m.get_msgbuf()))", "response": "called on sending a message"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef report_altitude(self, altitude):\n        '''possibly report a new altitude'''\n        master = self.master\n        if getattr(self.console, 'ElevationMap', None) is not None and self.mpstate.settings.basealt != 0:\n            lat = master.field('GLOBAL_POSITION_INT', 'lat', 0)*1.0e-7\n            lon = master.field('GLOBAL_POSITION_INT', 'lon', 0)*1.0e-7\n            alt1 = self.console.ElevationMap.GetElevation(lat, lon)\n            if alt1 is not None:\n                alt2 = self.mpstate.settings.basealt\n                altitude += alt2 - alt1\n        self.status.altitude = altitude\n        altitude_converted = self.height_convert_units(altitude)\n        if (int(self.mpstate.settings.altreadout) > 0 and\n            math.fabs(altitude_converted - self.last_altitude_announce) >=\n            int(self.settings.altreadout)):\n            self.last_altitude_announce = altitude_converted\n            rounded_alt = int(self.settings.altreadout) * ((self.settings.altreadout/2 + int(altitude_converted)) / int(self.settings.altreadout))\n            self.say(\"height %u\" % rounded_alt, priority='notification')", "response": "report a new altitude"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmastering message handling for an upstream link", "response": "def master_msg_handling(self, m, master):\n        '''link message handling for an upstream link'''\n        if self.settings.target_system != 0 and m.get_srcSystem() != self.settings.target_system:\n            # don't process messages not from our target\n            if m.get_type() == \"BAD_DATA\":\n                if self.mpstate.settings.shownoise and mavutil.all_printable(m.data):\n                    self.mpstate.console.write(str(m.data), bg='red')\n            return\n\n        if self.settings.target_system != 0 and master.target_system != self.settings.target_system:\n            # keep the pymavlink level target system aligned with the MAVProxy setting\n            master.target_system = self.settings.target_system\n\n        if self.settings.target_component != 0 and master.target_component != self.settings.target_component:\n            # keep the pymavlink level target component aligned with the MAVProxy setting\n            print(\"change target_component %u\" % self.settings.target_component)\n            master.target_component = self.settings.target_component\n            \n        mtype = m.get_type()\n\n        if mtype == 'HEARTBEAT' and m.type != mavutil.mavlink.MAV_TYPE_GCS:\n            if self.settings.target_system == 0 and self.settings.target_system != m.get_srcSystem():\n                self.settings.target_system = m.get_srcSystem()\n                self.say(\"online system %u\" % self.settings.target_system,'message')\n                for mav in self.mpstate.mav_master:\n                    mav.target_system = self.settings.target_system\n\n            if self.status.heartbeat_error:\n                self.status.heartbeat_error = False\n                self.say(\"heartbeat OK\")\n            if master.linkerror:\n                master.linkerror = False\n                self.say(\"link %s OK\" % (self.link_label(master)))\n            self.status.last_heartbeat = time.time()\n            master.last_heartbeat = self.status.last_heartbeat\n\n            armed = self.master.motors_armed()\n            if armed != self.status.armed:\n                self.status.armed = armed\n                if armed:\n                    self.say(\"ARMED\")\n                else:\n                    self.say(\"DISARMED\")\n\n            if master.flightmode != self.status.flightmode:\n                self.status.flightmode = master.flightmode\n                if self.mpstate.functions.input_handler is None:\n                    self.set_prompt(self.status.flightmode + \"> \")\n\n            if master.flightmode != self.status.last_mode_announced and time.time() > self.status.last_mode_announce + 2:\n                    self.status.last_mode_announce = time.time()\n                    self.status.last_mode_announced = master.flightmode\n                    self.say(\"Mode \" + self.status.flightmode)\n\n            if m.type == mavutil.mavlink.MAV_TYPE_FIXED_WING:\n                self.mpstate.vehicle_type = 'plane'\n                self.mpstate.vehicle_name = 'ArduPlane'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_GROUND_ROVER,\n                            mavutil.mavlink.MAV_TYPE_SURFACE_BOAT]:\n                self.mpstate.vehicle_type = 'rover'\n                self.mpstate.vehicle_name = 'APMrover2'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_SUBMARINE]:\n                self.mpstate.vehicle_type = 'sub'\n                self.mpstate.vehicle_name = 'ArduSub'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_QUADROTOR,\n                            mavutil.mavlink.MAV_TYPE_COAXIAL,\n                            mavutil.mavlink.MAV_TYPE_HEXAROTOR,\n                            mavutil.mavlink.MAV_TYPE_OCTOROTOR,\n                            mavutil.mavlink.MAV_TYPE_TRICOPTER,\n                            mavutil.mavlink.MAV_TYPE_HELICOPTER,\n                            mavutil.mavlink.MAV_TYPE_DODECAROTOR]:\n                self.mpstate.vehicle_type = 'copter'\n                self.mpstate.vehicle_name = 'ArduCopter'\n            elif m.type in [mavutil.mavlink.MAV_TYPE_ANTENNA_TRACKER]:\n                self.mpstate.vehicle_type = 'antenna'\n                self.mpstate.vehicle_name = 'AntennaTracker'\n\n        elif mtype == 'STATUSTEXT':\n            if m.text != self.status.last_apm_msg or time.time() > self.status.last_apm_msg_time+2:\n                (fg, bg) = self.colors_for_severity(m.severity)\n                self.mpstate.console.writeln(\"APM: %s\" % mp_util.null_term(m.text), bg=bg, fg=fg)\n                self.status.last_apm_msg = m.text\n                self.status.last_apm_msg_time = time.time()\n\n        elif mtype == \"VFR_HUD\":\n            have_gps_lock = False\n            if 'GPS_RAW' in self.status.msgs and self.status.msgs['GPS_RAW'].fix_type == 2:\n                have_gps_lock = True\n            elif 'GPS_RAW_INT' in self.status.msgs and self.status.msgs['GPS_RAW_INT'].fix_type == 3:\n                have_gps_lock = True\n            if have_gps_lock and not self.status.have_gps_lock and m.alt != 0:\n                self.say(\"GPS lock at %u meters\" % m.alt, priority='notification')\n                self.status.have_gps_lock = True\n\n        elif mtype == \"GPS_RAW\":\n            if self.status.have_gps_lock:\n                if m.fix_type != 2 and not self.status.lost_gps_lock and (time.time() - self.status.last_gps_lock) > 3:\n                    self.say(\"GPS fix lost\")\n                    self.status.lost_gps_lock = True\n                if m.fix_type == 2 and self.status.lost_gps_lock:\n                    self.say(\"GPS OK\")\n                    self.status.lost_gps_lock = False\n                if m.fix_type == 2:\n                    self.status.last_gps_lock = time.time()\n\n        elif mtype == \"GPS_RAW_INT\":\n            if self.status.have_gps_lock:\n                if m.fix_type < 3 and not self.status.lost_gps_lock and (time.time() - self.status.last_gps_lock) > 3:\n                    self.say(\"GPS fix lost\")\n                    self.status.lost_gps_lock = True\n                if m.fix_type >= 3 and self.status.lost_gps_lock:\n                    self.say(\"GPS OK\")\n                    self.status.lost_gps_lock = False\n                if m.fix_type >= 3:\n                    self.status.last_gps_lock = time.time()\n\n        elif mtype == \"NAV_CONTROLLER_OUTPUT\" and self.status.flightmode == \"AUTO\" and self.mpstate.settings.distreadout:\n            rounded_dist = int(m.wp_dist/self.mpstate.settings.distreadout)*self.mpstate.settings.distreadout\n            if math.fabs(rounded_dist - self.status.last_distance_announce) >= self.mpstate.settings.distreadout:\n                if rounded_dist != 0:\n                    self.say(\"%u\" % rounded_dist, priority=\"progress\")\n            self.status.last_distance_announce = rounded_dist\n\n        elif mtype == \"GLOBAL_POSITION_INT\":\n            self.report_altitude(m.relative_alt*0.001)\n\n        elif mtype == \"COMPASSMOT_STATUS\":\n            print(m)\n\n        elif mtype == \"SIMSTATE\":\n            self.mpstate.is_sitl = True\n\n        elif mtype == \"ATTITUDE\":\n            att_time = m.time_boot_ms * 0.001\n            self.mpstate.attitude_time_s = max(self.mpstate.attitude_time_s, att_time)\n            if self.mpstate.attitude_time_s - att_time > 120:\n                # cope with wrap\n                self.mpstate.attitude_time_s = att_time\n\n        elif mtype in [ \"COMMAND_ACK\", \"MISSION_ACK\" ]:\n            self.mpstate.console.writeln(\"Got MAVLink msg: %s\" % m)\n\n            if mtype == \"COMMAND_ACK\" and m.command == mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION:\n                if m.result == mavutil.mavlink.MAV_RESULT_ACCEPTED:\n                    self.say(\"Calibrated\")\n                elif m.result == mavutil.mavlink.MAV_RESULT_FAILED:\n                    self.say(\"Calibration failed\")\n                elif m.result == mavutil.mavlink.MAV_RESULT_UNSUPPORTED:\n                    self.say(\"Calibration unsupported\")\n                elif m.result == mavutil.mavlink.MAV_RESULT_TEMPORARILY_REJECTED:\n                    self.say(\"Calibration temporarily rejected\")\n                else:\n                    self.say(\"Calibration response (%u)\" % m.result)\n        else:\n            #self.mpstate.console.writeln(\"Got MAVLink msg: %s\" % m)\n            pass\n\n        if self.status.watch is not None:\n            for msg_type in self.status.watch:\n                if fnmatch.fnmatch(mtype.upper(), msg_type.upper()):\n                    self.mpstate.console.writeln('< '+ str(m))\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess mavlink message m on master sending any messages to recipients", "response": "def master_callback(self, m, master):\n        '''process mavlink message m on master, sending any messages to recipients'''\n\n        # see if it is handled by a specialised sysid connection\n        sysid = m.get_srcSystem()\n        mtype = m.get_type()\n        if sysid in self.mpstate.sysid_outputs:\n            self.mpstate.sysid_outputs[sysid].write(m.get_msgbuf())\n            if mtype == \"GLOBAL_POSITION_INT\":\n                for modname in 'map', 'asterix', 'NMEA', 'NMEA2':\n                    mod = self.module(modname)\n                    if mod is not None:\n                        mod.set_secondary_vehicle_position(m)\n            return\n\n        if getattr(m, '_timestamp', None) is None:\n            master.post_message(m)\n        self.status.counters['MasterIn'][master.linknum] += 1\n\n        if mtype == 'GLOBAL_POSITION_INT':\n            # send GLOBAL_POSITION_INT to 2nd GCS for 2nd vehicle display\n            for sysid in self.mpstate.sysid_outputs:\n                self.mpstate.sysid_outputs[sysid].write(m.get_msgbuf())\n\n            if self.mpstate.settings.fwdpos:\n                for link in self.mpstate.mav_master:\n                    if link != master:\n                        link.write(m.get_msgbuf())\n\n        # and log them\n        if mtype not in dataPackets and self.mpstate.logqueue:\n            # put link number in bottom 2 bits, so we can analyse packet\n            # delay in saved logs\n            usec = self.get_usec()\n            usec = (usec & ~3) | master.linknum\n            self.mpstate.logqueue.put(bytearray(struct.pack('>Q', usec) + m.get_msgbuf()))\n\n        # keep the last message of each type around\n        self.status.msgs[mtype] = m\n        if mtype not in self.status.msg_count:\n            self.status.msg_count[mtype] = 0\n        self.status.msg_count[mtype] += 1\n\n        if m.get_srcComponent() == mavutil.mavlink.MAV_COMP_ID_GIMBAL and mtype == 'HEARTBEAT':\n            # silence gimbal heartbeat packets for now\n            return\n\n        if getattr(m, 'time_boot_ms', None) is not None and self.settings.target_system == m.get_srcSystem():\n            # update link_delayed attribute\n            self.handle_msec_timestamp(m, master)\n\n        if mtype in activityPackets:\n            if master.linkerror:\n                master.linkerror = False\n                self.say(\"link %s OK\" % (self.link_label(master)))\n            self.status.last_message = time.time()\n            master.last_message = self.status.last_message\n\n        if master.link_delayed and self.mpstate.settings.checkdelay:\n            # don't process delayed packets that cause double reporting\n            if mtype in delayedPackets:\n                return\n\n        self.master_msg_handling(m, master)\n\n        # don't pass along bad data\n        if mtype != 'BAD_DATA':\n            # pass messages along to listeners, except for REQUEST_DATA_STREAM, which\n            # would lead a conflict in stream rate setting between mavproxy and the other\n            # GCS\n            if self.mpstate.settings.mavfwd_rate or mtype != 'REQUEST_DATA_STREAM':\n                if mtype not in self.no_fwd_types:\n                    for r in self.mpstate.mav_outputs:\n                        r.write(m.get_msgbuf())\n\n            sysid = m.get_srcSystem()\n            target_sysid = self.target_system\n\n            # pass to modules\n            for (mod,pm) in self.mpstate.modules:\n                if not hasattr(mod, 'mavlink_packet'):\n                    continue\n                if not mod.multi_vehicle and sysid != target_sysid:\n                    # only pass packets not from our target to modules that\n                    # have marked themselves as being multi-vehicle capable\n                    continue\n                try:\n                    mod.mavlink_packet(m)\n                except Exception as msg:\n                    if self.mpstate.settings.moddebug == 1:\n                        print(msg)\n                    elif self.mpstate.settings.moddebug > 1:\n                        exc_type, exc_value, exc_traceback = sys.exc_info()\n                        traceback.print_exception(exc_type, exc_value, exc_traceback,\n                                                  limit=2, file=sys.stdout)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite to a device", "response": "def devop_write(self, args, bustype):\n        '''write to a device'''\n        usage = \"Usage: devop write <spi|i2c> name bus address regstart count <bytes>\"\n        if len(args) < 5:\n            print(usage)\n            return\n        name = args[0]\n        bus = int(args[1],base=0)\n        address = int(args[2],base=0)\n        reg = int(args[3],base=0)\n        count = int(args[4],base=0)\n        args = args[5:]\n        if len(args) < count:\n            print(usage)\n            return\n        bytes = [0]*128\n        for i in range(count):\n            bytes[i] = int(args[i],base=0)\n        self.master.mav.device_op_write_send(self.target_system,\n                                             self.target_component,\n                                             self.request_id,\n                                             bustype,\n                                             bus,\n                                             address,\n                                             name,\n                                             reg,\n                                             count,\n                                             bytes)\n        self.request_id += 1"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling a mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle a mavlink packet'''\n        mtype = m.get_type()\n        if mtype == \"DEVICE_OP_READ_REPLY\":\n            if m.result != 0:\n                print(\"Operation %u failed: %u\" % (m.request_id, m.result))\n            else:\n                print(\"Operation %u OK: %u bytes\" % (m.request_id, m.count))\n                self.read_show_reply(m)\n\n        if mtype == \"DEVICE_OP_WRITE_REPLY\":\n            if m.result != 0:\n                print(\"Operation %u failed: %u\" % (m.request_id, m.result))\n            else:\n                print(\"Operation %u OK\" % m.request_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a set of points geo referenced to this instance return the points as absolute values.", "response": "def get_absolute(self, points):\n        \"\"\"Given a set of points geo referenced to this instance,\n        return the points as absolute values.\n        \"\"\"\n\n        # remember if we got a list\n        is_list = isinstance(points, list)\n\n        points = ensure_numeric(points, num.float)\n        if len(points.shape) == 1:\n            # One point has been passed\n            msg = 'Single point must have two elements'\n            if not len(points) == 2:\n                raise ValueError(msg)\n\n\n        msg = 'Input must be an N x 2 array or list of (x,y) values. '\n        msg += 'I got an %d x %d array' %points.shape\n        if not points.shape[1] == 2:\n            raise ValueError(msg)\n\n\n        # Add geo ref to points\n        if not self.is_absolute():\n            points = copy.copy(points) # Don't destroy input\n            points[:,0] += self.xllcorner\n            points[:,1] += self.yllcorner\n\n\n        if is_list:\n            points = points.tolist()\n\n        return points"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nscale a PWM value", "response": "def scale_rc(self, servo, min, max, param):\n        '''scale a PWM value'''\n        # default to servo range of 1000 to 2000\n        min_pwm  = self.get_mav_param('%s_MIN'  % param, 0)\n        max_pwm  = self.get_mav_param('%s_MAX'  % param, 0)\n        if min_pwm == 0 or max_pwm == 0:\n            return 0\n        if max_pwm == min_pwm:\n            p = 0.0\n        else:\n            p = (servo-min_pwm) / float(max_pwm-min_pwm)\n        v = min + p*(max-min)\n        if v < min:\n            v = min\n        if v > max:\n            v = max\n        return v"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        state = self\n        mtype = m.get_type()\n        if mtype == 'GLOBAL_POSITION_INT':\n            state.lat, state.lon = m.lat*scale_latlon, m.lon*scale_latlon\n            state.hdg = m.hdg*scale_hdg\n            agl = state.elevation_model.GetElevation(state.lat, state.lon)\n            if agl is not None:\n                state.height = m.relative_alt*scale_relative_alt + state.home_height - agl\n        elif mtype == 'ATTITUDE':\n            state.roll, state.pitch, state.yaw = math.degrees(m.roll), math.degrees(m.pitch), math.degrees(m.yaw)\n        elif mtype in ['GPS_RAW', 'GPS_RAW_INT']:\n            if self.module('wp').wploader.count() > 0:\n                home = self.module('wp').wploader.wp(0).x, self.module('wp').wploader.wp(0).y\n            else:\n                home = [self.master.field('HOME', c)*scale_latlon for c in ['lat', 'lon']]\n            old = state.home_height # TODO TMP\n            agl = state.elevation_model.GetElevation(*home)\n            if agl is None:\n                return\n            state.home_height = agl\n\n            # TODO TMP\n            if state.home_height != old:\n                # tridge said to get home pos from wploader,\n                # but this is not the same as from master() below...!!\n                # using master() gives the right coordinates\n                # (i.e. matches GLOBAL_POSITION_INT coords, and $IMHOME in sim_arduplane.sh)\n                # and wploader is a bit off\n                print('home height changed from',old,'to',state.home_height)\n        elif mtype == 'SERVO_OUTPUT_RAW':\n            for (axis, attr) in [('ROLL', 'mount_roll'), ('TILT', 'mount_pitch'), ('PAN', 'mount_yaw')]:\n                channel = int(self.get_mav_param('MNT_RC_IN_{0}'.format(axis), 0))\n                if self.get_mav_param('MNT_STAB_{0}'.format(axis), 0) and channel:\n                    # enabled stabilisation on this axis\n                    # TODO just guessing that RC_IN_ROLL gives the servo number, but no idea if this is really the case\n                    servo = 'servo{0}_raw'.format(channel)\n                    centidegrees = self.scale_rc(getattr(m, servo),\n                                            self.get_mav_param('MNT_ANGMIN_{0}'.format(axis[:3])),\n                                            self.get_mav_param('MNT_ANGMAX_{0}'.format(axis[:3])),\n                                            param='RC{0}'.format(channel))\n                    setattr(state, attr, centidegrees*0.01)\n            #state.mount_roll = min(max(-state.roll,-45),45)#TODO TMP\n            #state.mount_yaw = min(max(-state.yaw,-45),45)#TODO TMP\n            #state.mount_pitch = min(max(-state.pitch,-45),45)#TODO TMP\n        else:\n            return\n        if self.mpstate.map: # if the map module is loaded, redraw polygon\n            # get rid of the old polygon\n            self.mpstate.map.add_object(mp_slipmap.SlipClearLayer('CameraView'))\n\n            # camera view polygon determined by projecting corner pixels of the image onto the ground\n            pixel_positions = [cuav_util.pixel_position(px[0],px[1], state.height, state.pitch+state.mount_pitch, state.roll+state.mount_roll, state.yaw+state.mount_yaw, state.camera_params) for px in [(0,0), (state.camera_params.xresolution,0), (state.camera_params.xresolution,state.camera_params.yresolution), (0,state.camera_params.yresolution)]]\n            if any(pixel_position is None for pixel_position in pixel_positions):\n                # at least one of the pixels is not on the ground\n                # so it doesn't make sense to try to draw the polygon\n                return\n            gps_positions = [mp_util.gps_newpos(state.lat, state.lon, math.degrees(math.atan2(*pixel_position)), math.hypot(*pixel_position)) for pixel_position in pixel_positions]\n\n            # draw new polygon\n            self.mpstate.map.add_object(mp_slipmap.SlipPolygon('cameraview', gps_positions+[gps_positions[0]], # append first element to close polygon\n                                                          layer='CameraView', linewidth=2, colour=state.col))", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef debug_on_error(type, value, tb):\n    traceback.print_exc(type, value, tb)\n    print()\n    pdb.pm()", "response": "Debugging function for error messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef error_msg_wx(msg, parent=None):\n    dialog =wx.MessageDialog(parent  = parent,\n                             message = msg,\n                             caption = 'Matplotlib backend_wx error',\n                             style=wx.OK | wx.CENTRE)\n    dialog.ShowModal()\n    dialog.Destroy()\n    return None", "response": "Signal an error condition in a GUI"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a raise message to a string.", "response": "def raise_msg_to_str(msg):\n    \"\"\"msg is a return arg from a raise.  Join with new lines\"\"\"\n    if not is_string_like(msg):\n        msg = '\\n'.join(map(str, msg))\n    return msg"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _create_wx_app():\n    wxapp = wx.GetApp()\n    if wxapp is None:\n        wxapp = wx.App(False)\n        wxapp.SetExitOnFrameDelete(True)\n        # retain a reference to the app object so it does not get garbage\n        # collected and cause segmentation faults\n        _create_wx_app.theWxApp = wxapp", "response": "Creates a wx. App instance if it has not been created sofar."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndraw the current color of the current color if interactive.", "response": "def draw_if_interactive():\n    \"\"\"\n    This should be overriden in a windowing environment if drawing\n    should be done in interactive python mode\n    \"\"\"\n    DEBUG_MSG(\"draw_if_interactive()\", 1, None)\n\n    if matplotlib.is_interactive():\n\n        figManager = Gcf.get_active()\n        if figManager is not None:\n            figManager.canvas.draw_idle()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new figure manager instance", "response": "def new_figure_manager(num, *args, **kwargs):\n    \"\"\"\n    Create a new figure manager instance\n    \"\"\"\n    # in order to expose the Figure constructor to the pylab\n    # interface we need to create the figure here\n    DEBUG_MSG(\"new_figure_manager()\", 3, None)\n    _create_wx_app()\n\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    fig = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, fig)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new figure manager instance for the given figure.", "response": "def new_figure_manager_given_figure(num, figure):\n    \"\"\"\n    Create a new figure manager instance for the given figure.\n    \"\"\"\n    fig = figure\n    frame = FigureFrameWx(num, fig)\n    figmgr = frame.get_figure_manager()\n    if matplotlib.is_interactive():\n        figmgr.frame.Show()\n\n    return figmgr"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _load_bitmap(filename):\n\n    basedir = os.path.join(rcParams['datapath'],'images')\n\n    bmpFilename = os.path.normpath(os.path.join(basedir, filename))\n    if not os.path.exists(bmpFilename):\n        raise IOError('Could not find bitmap file \"%s\"; dying'%bmpFilename)\n\n    bmp = wx.Bitmap(bmpFilename)\n    return bmp", "response": "Load a bitmap file from the backends folder"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the width and height in display coords of the string s with FontPropertry prop", "response": "def get_text_width_height_descent(self, s, prop, ismath):\n        \"\"\"\n        get the width and height in display coords of the string s\n        with FontPropertry prop\n        \"\"\"\n        #return 1, 1\n        if ismath: s = self.strip_math(s)\n\n        if self.gc is None:\n            gc = self.new_gc()\n        else:\n            gc = self.gc\n        gfx_ctx = gc.gfx_ctx\n        font = self.get_wx_font(s, prop)\n        gfx_ctx.SetFont(font, wx.BLACK)\n        w, h, descent, leading = gfx_ctx.GetFullTextExtent(s)\n\n        return w, h, descent"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an instance of GraphicsContextWx and sets the current gc copy", "response": "def new_gc(self):\n        \"\"\"\n        Return an instance of a GraphicsContextWx, and sets the current gc copy\n        \"\"\"\n        DEBUG_MSG('new_gc()', 2, self)\n        self.gc = GraphicsContextWx(self.bitmap, self)\n        self.gc.select()\n        self.gc.unselect()\n        return self.gc"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_wx_font(self, s, prop):\n        DEBUG_MSG(\"get_wx_font()\", 1, self)\n\n\n        key = hash(prop)\n        fontprop = prop\n        fontname = fontprop.get_name()\n\n        font = self.fontd.get(key)\n        if font is not None:\n            return font\n\n        # Allow use of platform independent and dependent font names\n        wxFontname = self.fontnames.get(fontname, wx.ROMAN)\n        wxFacename = '' # Empty => wxPython chooses based on wx_fontname\n\n        # Font colour is determined by the active wx.Pen\n        # TODO: It may be wise to cache font information\n        size = self.points_to_pixels(fontprop.get_size_in_points())\n\n\n        font =wx.Font(int(size+0.5),             # Size\n                      wxFontname,                # 'Generic' name\n                      self.fontangles[fontprop.get_style()],   # Angle\n                      self.fontweights[fontprop.get_weight()], # Weight\n                      False,                     # Underline\n                      wxFacename)                # Platform font name\n\n        # cache the font and gc and return it\n        self.fontd[key] = font\n\n        return font", "response": "Return a wx. Font object for the given wx. Font object s and wx. Property object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nselect the current bitmap into this wxDC instance", "response": "def select(self):\n        \"\"\"\n        Select the current bitmap into this wxDC instance\n        \"\"\"\n\n        if sys.platform=='win32':\n            self.dc.SelectObject(self.bitmap)\n            self.IsSelected = True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unselect(self):\n        if sys.platform=='win32':\n            self.dc.SelectObject(wx.NullBitmap)\n            self.IsSelected = False", "response": "Unselects a Null bitmasp into this wxDC instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the foreground color.", "response": "def set_foreground(self, fg, isRGBA=None):\n        \"\"\"\n        Set the foreground color.  fg can be a matlab format string, a\n        html hex color string, an rgb unit tuple, or a float between 0\n        and 1.  In the latter case, grayscale is used.\n        \"\"\"\n        # Implementation note: wxPython has a separate concept of pen and\n        # brush - the brush fills any outline trace left by the pen.\n        # Here we set both to the same colour - if a figure is not to be\n        # filled, the renderer will set the brush to be transparent\n        # Same goes for text foreground...\n        DEBUG_MSG(\"set_foreground()\", 1, self)\n        self.select()\n        GraphicsContextBase.set_foreground(self, fg, isRGBA)\n\n        self._pen.SetColour(self.get_wxcolour(self.get_rgb()))\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_graylevel(self, frac):\n        DEBUG_MSG(\"set_graylevel()\", 1, self)\n        self.select()\n        GraphicsContextBase.set_graylevel(self, frac)\n        self._pen.SetColour(self.get_wxcolour(self.get_rgb()))\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()", "response": "Set the foreground color."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_linewidth(self, w):\n        DEBUG_MSG(\"set_linewidth()\", 1, self)\n        self.select()\n        if w>0 and w<1: w = 1\n        GraphicsContextBase.set_linewidth(self, w)\n        lw = int(self.renderer.points_to_pixels(self._linewidth))\n        if lw==0: lw = 1\n        self._pen.SetWidth(lw)\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()", "response": "Set the line width."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_capstyle(self, cs):\n        DEBUG_MSG(\"set_capstyle()\", 1, self)\n        self.select()\n        GraphicsContextBase.set_capstyle(self, cs)\n        self._pen.SetCap(GraphicsContextWx._capd[self._capstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()", "response": "Set the capstyle as a string in ( butt round projecting"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_joinstyle(self, js):\n        DEBUG_MSG(\"set_joinstyle()\", 1, self)\n        self.select()\n        GraphicsContextBase.set_joinstyle(self, js)\n        self._pen.SetJoin(GraphicsContextWx._joind[self._joinstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()", "response": "Set the join style of the current context."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_linestyle(self, ls):\n        DEBUG_MSG(\"set_linestyle()\", 1, self)\n        self.select()\n        GraphicsContextBase.set_linestyle(self, ls)\n        try:\n            self._style = GraphicsContextWx._dashd_wx[ls]\n        except KeyError:\n            self._style = wx.LONG_DASH# Style not used elsewhere...\n\n        # On MS Windows platform, only line width of 1 allowed for dash lines\n        if wx.Platform == '__WXMSW__':\n            self.set_linewidth(1)\n\n        self._pen.SetStyle(self._style)\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()", "response": "Set the line style of the current color for the current color."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a wx. Colour from RGB format", "response": "def get_wxcolour(self, color):\n        \"\"\"return a wx.Colour from RGB format\"\"\"\n        DEBUG_MSG(\"get_wx_color()\", 1, self)\n        if len(color) == 3:\n            r, g, b = color\n            r *= 255\n            g *= 255\n            b *= 255\n            return wx.Colour(red=int(r), green=int(g), blue=int(b))\n        else:\n            r, g, b, a = color\n            r *= 255\n            g *= 255\n            b *= 255\n            a *= 255\n            return wx.Colour(red=int(r), green=int(g), blue=int(b), alpha=int(a))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncopy bitmap of canvas to system clipboard", "response": "def Copy_to_Clipboard(self, event=None):\n        \"copy bitmap of canvas to system clipboard\"\n        bmp_obj = wx.BitmapDataObject()\n        bmp_obj.SetBitmap(self.bitmap)\n\n        if not wx.TheClipboard.IsOpened():\n           open_success = wx.TheClipboard.Open()\n           if open_success:\n              wx.TheClipboard.SetData(bmp_obj)\n              wx.TheClipboard.Close()\n              wx.TheClipboard.Flush()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef draw_idle(self):\n        DEBUG_MSG(\"draw_idle()\", 1, self)\n        self._isDrawn = False  # Force redraw\n        # Create a timer for handling draw_idle requests\n        # If there are events pending when the timer is\n        # complete, reset the timer and continue.  The\n        # alternative approach, binding to wx.EVT_IDLE,\n        # doesn't behave as nicely.\n        if hasattr(self,'_idletimer'):\n            self._idletimer.Restart(IDLE_DELAY)\n        else:\n            self._idletimer = wx.FutureCall(IDLE_DELAY,self._onDrawIdle)", "response": "Delay rendering until the GUI is idle."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef draw(self, drawDC=None):\n        DEBUG_MSG(\"draw()\", 1, self)\n        self.renderer = RendererWx(self.bitmap, self.figure.dpi)\n        self.figure.draw(self.renderer)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)", "response": "Render the figure using RendererWx instance renderer or using a\n        previously defined renderer."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts an event loop.", "response": "def start_event_loop(self, timeout=0):\n        \"\"\"\n        Start an event loop.  This is used to start a blocking event\n        loop so that interactive functions, such as ginput and\n        waitforbuttonpress, can wait for events.  This should not be\n        confused with the main GUI event loop, which is always running\n        and has nothing to do with this.\n\n        Call signature::\n\n        start_event_loop(self,timeout=0)\n\n        This call blocks until a callback function triggers\n        stop_event_loop() or *timeout* is reached.  If *timeout* is\n        <=0, never timeout.\n\n        Raises RuntimeError if event loop is already running.\n        \"\"\"\n        if hasattr(self, '_event_loop'):\n            raise RuntimeError(\"Event loop already running\")\n        id = wx.NewId()\n        timer = wx.Timer(self, id=id)\n        if timeout > 0:\n            timer.Start(timeout*1000, oneShot=True)\n            bind(self, wx.EVT_TIMER, self.stop_event_loop, id=id)\n\n        # Event loop handler for start/stop event loop\n        self._event_loop = wx.EventLoop()\n        self._event_loop.Run()\n        timer.Stop()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstop an event loop.", "response": "def stop_event_loop(self, event=None):\n        \"\"\"\n        Stop an event loop.  This is used to stop a blocking event\n        loop so that interactive functions, such as ginput and\n        waitforbuttonpress, can wait for events.\n\n        Call signature::\n\n        stop_event_loop_default(self)\n        \"\"\"\n        if hasattr(self,'_event_loop'):\n            if self._event_loop.IsRunning():\n                self._event_loop.Exit()\n            del self._event_loop"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_imagesave_wildcards(self):\n        'return the wildcard string for the filesave dialog'\n        default_filetype = self.get_default_filetype()\n        filetypes = self.get_supported_filetypes_grouped()\n        sorted_filetypes = filetypes.items()\n        sorted_filetypes.sort()\n        wildcards = []\n        extensions = []\n        filter_index = 0\n        for i, (name, exts) in enumerate(sorted_filetypes):\n            ext_list = ';'.join(['*.%s' % ext for ext in exts])\n            extensions.append(exts[0])\n            wildcard = '%s (%s)|%s' % (name, ext_list, ext_list)\n            if default_filetype in exts:\n                filter_index = i\n            wildcards.append(wildcard)\n        wildcards = '|'.join(wildcards)\n        return wildcards, extensions, filter_index", "response": "return the wildcard string for the filesave dialog"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gui_repaint(self, drawDC=None):\n        DEBUG_MSG(\"gui_repaint()\", 1, self)\n        if self.IsShownOnScreen():\n            if drawDC is None:\n                drawDC=wx.ClientDC(self)\n\n            #drawDC.BeginDrawing()\n            drawDC.DrawBitmap(self.bitmap, 0, 0)\n            #drawDC.EndDrawing()\n            #wx.GetApp().Yield()\n        else:\n            pass", "response": "Re - draws the image of the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _onPaint(self, evt):\n\n        DEBUG_MSG(\"_onPaint()\", 1, self)\n        drawDC = wx.PaintDC(self)\n        if not self._isDrawn:\n            self.draw(drawDC=drawDC)\n        else:\n            self.gui_repaint(drawDC=drawDC)\n        evt.Skip()", "response": "Called when wxPaintEvt is generated"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling when wxEventSize is generated. This method is called when the window is resized.", "response": "def _onSize(self, evt):\n        \"\"\"\n        Called when wxEventSize is generated.\n\n        In this application we attempt to resize to fit the window, so it\n        is better to take the performance hit and redraw the whole window.\n        \"\"\"\n\n        DEBUG_MSG(\"_onSize()\", 2, self)\n        # Create a new, correctly sized bitmap\n        self._width, self._height = self.GetClientSize()\n        self.bitmap =wx.EmptyBitmap(self._width, self._height)\n        self._isDrawn = False\n\n        if self._width <= 1 or self._height <= 1: return # Empty figure\n\n        dpival = self.figure.dpi\n        winch = self._width/dpival\n        hinch = self._height/dpival\n        self.figure.set_size_inches(winch, hinch)\n\n        # Rendering will happen on the associated paint event\n        # so no need to do anything here except to make sure\n        # the whole background is repainted.\n        self.Refresh(eraseBackground=False)\n        FigureCanvasBase.resize_event(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles key up event.", "response": "def _onKeyUp(self, evt):\n        \"\"\"Release key.\"\"\"\n        key = self._get_key(evt)\n        #print 'release key', key\n        evt.Skip()\n        FigureCanvasBase.key_release_event(self, key, guiEvent=evt)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _onLeftButtonDown(self, evt):\n        x = evt.GetX()\n        y = self.figure.bbox.height - evt.GetY()\n        evt.Skip()\n        self.CaptureMouse()\n        FigureCanvasBase.button_press_event(self, x, y, 1, guiEvent=evt)", "response": "Start measuring on an axis."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _onLeftButtonDClick(self, evt):\n        x = evt.GetX()\n        y = self.figure.bbox.height - evt.GetY()\n        evt.Skip()\n        self.CaptureMouse()\n        FigureCanvasBase.button_press_event(self, x, y, 1, dblclick=True, guiEvent=evt)", "response": "Start measuring on an axis."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nend measuring on an axis.", "response": "def _onLeftButtonUp(self, evt):\n        \"\"\"End measuring on an axis.\"\"\"\n        x = evt.GetX()\n        y = self.figure.bbox.height - evt.GetY()\n        #print 'release button', 1\n        evt.Skip()\n        if self.HasCapture(): self.ReleaseMouse()\n        FigureCanvasBase.button_release_event(self, x, y, 1, guiEvent=evt)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _onMouseWheel(self, evt):\n\n        # Determine mouse location\n        x = evt.GetX()\n        y = self.figure.bbox.height - evt.GetY()\n\n        # Convert delta/rotation/rate into a floating point step size\n        delta = evt.GetWheelDelta()\n        rotation = evt.GetWheelRotation()\n        rate = evt.GetLinesPerAction()\n        #print \"delta,rotation,rate\",delta,rotation,rate\n        step = rate*float(rotation)/delta\n\n        # Done handling event\n        evt.Skip()\n\n        # Mac is giving two events for every wheel event\n        # Need to skip every second one\n        if wx.Platform == '__WXMAC__':\n            if not hasattr(self,'_skipwheelevent'):\n                self._skipwheelevent = True\n            elif self._skipwheelevent:\n                self._skipwheelevent = False\n                return  # Return without processing event\n            else:\n                self._skipwheelevent = True\n\n        # Convert to mpl event\n        FigureCanvasBase.scroll_event(self, x, y, step, guiEvent=evt)", "response": "Translate mouse wheel events into matplotlib events"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstarting measuring on an axis.", "response": "def _onMotion(self, evt):\n        \"\"\"Start measuring on an axis.\"\"\"\n\n        x = evt.GetX()\n        y = self.figure.bbox.height - evt.GetY()\n        evt.Skip()\n        FigureCanvasBase.motion_notify_event(self, x, y, guiEvent=evt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _onLeave(self, evt):\n\n        evt.Skip()\n        FigureCanvasBase.leave_notify_event(self, guiEvent = evt)", "response": "Called when the user leaves the window."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resize(self, width, height):\n        'Set the canvas size in pixels'\n        self.canvas.SetInitialSize(wx.Size(width, height))\n        self.window.GetSizer().Fit(self.window)", "response": "Set the canvas size in pixels"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _onMenuButton(self, evt):\n        x, y = self.GetPositionTuple()\n        w, h = self.GetSizeTuple()\n        self.PopupMenuXY(self._menu, x, y+h-4)\n                # When menu returned, indicate selection in button\n        evt.Skip()", "response": "Handle menu button pressed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _handleSelectAllAxes(self, evt):\n        if len(self._axisId) == 0:\n            return\n        for i in range(len(self._axisId)):\n            self._menu.Check(self._axisId[i], True)\n        self._toolbar.set_active(self.getActiveAxes())\n        evt.Skip()", "response": "Called when the select all axes menu item is selected."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall when the invert all menu item is selected", "response": "def _handleInvertAxesSelected(self, evt):\n        \"\"\"Called when the invert all menu item is selected\"\"\"\n        if len(self._axisId) == 0: return\n        for i in range(len(self._axisId)):\n            if self._menu.IsChecked(self._axisId[i]):\n                self._menu.Check(self._axisId[i], False)\n            else:\n                self._menu.Check(self._axisId[i], True)\n        self._toolbar.set_active(self.getActiveAxes())\n        evt.Skip()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling when one of the specific axis menu items is selected", "response": "def _onMenuItemSelected(self, evt):\n        \"\"\"Called whenever one of the specific axis menu items is selected\"\"\"\n        current = self._menu.IsChecked(evt.GetId())\n        if current:\n            new = False\n        else:\n            new = True\n        self._menu.Check(evt.GetId(), new)\n        # Lines above would be deleted based on svn tracker ID 2841525;\n        # not clear whether this matters or not.\n        self._toolbar.set_active(self.getActiveAxes())\n        evt.Skip()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring that there are entries for max_axis axes in the menu.", "response": "def updateAxes(self, maxAxis):\n        \"\"\"Ensures that there are entries for max_axis axes in the menu\n        (selected by default).\"\"\"\n        if maxAxis > len(self._axisId):\n            for i in range(len(self._axisId) + 1, maxAxis + 1, 1):\n                menuId =wx.NewId()\n                self._axisId.append(menuId)\n                self._menu.Append(menuId, \"Axis %d\" % i, \"Select axis %d\" % i, True)\n                self._menu.Check(menuId, True)\n                bind(self, wx.EVT_MENU, self._onMenuItemSelected, id=menuId)\n        elif maxAxis < len(self._axisId):\n            for menuId in self._axisId[maxAxis:]:\n                self._menu.Delete(menuId)\n            self._axisId = self._axisId[:maxAxis]\n        self._toolbar.set_active(range(maxAxis))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of the selected axes.", "response": "def getActiveAxes(self):\n        \"\"\"Return a list of the selected axes.\"\"\"\n        active = []\n        for i in range(len(self._axisId)):\n            if self._menu.IsChecked(self._axisId[i]):\n                active.append(i)\n        return active"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef updateButtonText(self, lst):\n        axis_txt = ''\n        for e in lst:\n            axis_txt += '%d,' % (e+1)\n        # remove trailing ',' and add to button string\n        self.SetLabel(\"Axes: %s\" % axis_txt[:-1])", "response": "Update the list of selected axes in the menu button"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef draw_rubberband(self, event, x0, y0, x1, y1):\n        'adapted from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/189744'\n        canvas = self.canvas\n        dc =wx.ClientDC(canvas)\n\n        # Set logical function to XOR for rubberbanding\n        dc.SetLogicalFunction(wx.XOR)\n\n        # Set dc brush and pen\n        # Here I set brush and pen to white and grey respectively\n        # You can set it to your own choices\n\n        # The brush setting is not really needed since we\n        # dont do any filling of the dc. It is set just for\n        # the sake of completion.\n\n        wbrush =wx.Brush(wx.Colour(255,255,255), wx.TRANSPARENT)\n        wpen =wx.Pen(wx.Colour(200, 200, 200), 1, wx.SOLID)\n        dc.SetBrush(wbrush)\n        dc.SetPen(wpen)\n\n\n        dc.ResetBoundingBox()\n        dc.BeginDrawing()\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n\n        if y1<y0: y0, y1 = y1, y0\n        if x1<y0: x0, x1 = x1, x0\n\n        w = x1 - x0\n        h = y1 - y0\n\n        rect = int(x0), int(y0), int(w), int(h)\n        try: lastrect = self.lastrect\n        except AttributeError: pass\n        else: dc.DrawRectangle(*lastrect)  #erase last\n        self.lastrect = rect\n        dc.DrawRectangle(*rect)\n        dc.EndDrawing()", "response": "adapted from http://aspn. activestate. com / ASPN / Cookbook / Python / Recipe / 1987744"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create_menu(self):\n        DEBUG_MSG(\"_create_menu()\", 1, self)\n        self._menu = MenuButtonWx(self)\n        self.AddControl(self._menu)\n        self.AddSeparator()", "response": "Creates the menu - implemented as a button which opens a\n        pop - up menu since wxPython does not allow a menu as a control"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create_controls(self, can_kill):\n        DEBUG_MSG(\"_create_controls()\", 1, self)\n        # Need the following line as Windows toolbars default to 15x16\n\n        self.SetToolBitmapSize(wx.Size(16,16))\n        self.AddSimpleTool(_NTB_X_PAN_LEFT, _load_bitmap('stock_left.xpm'),\n                           'Left', 'Scroll left')\n        self.AddSimpleTool(_NTB_X_PAN_RIGHT, _load_bitmap('stock_right.xpm'),\n                           'Right', 'Scroll right')\n        self.AddSimpleTool(_NTB_X_ZOOMIN, _load_bitmap('stock_zoom-in.xpm'),\n                           'Zoom in', 'Increase X axis magnification')\n        self.AddSimpleTool(_NTB_X_ZOOMOUT, _load_bitmap('stock_zoom-out.xpm'),\n                           'Zoom out', 'Decrease X axis magnification')\n        self.AddSeparator()\n        self.AddSimpleTool(_NTB_Y_PAN_UP,_load_bitmap('stock_up.xpm'),\n                           'Up', 'Scroll up')\n        self.AddSimpleTool(_NTB_Y_PAN_DOWN, _load_bitmap('stock_down.xpm'),\n                           'Down', 'Scroll down')\n        self.AddSimpleTool(_NTB_Y_ZOOMIN, _load_bitmap('stock_zoom-in.xpm'),\n                           'Zoom in', 'Increase Y axis magnification')\n        self.AddSimpleTool(_NTB_Y_ZOOMOUT, _load_bitmap('stock_zoom-out.xpm'),\n                           'Zoom out', 'Decrease Y axis magnification')\n        self.AddSeparator()\n        self.AddSimpleTool(_NTB_SAVE, _load_bitmap('stock_save_as.xpm'),\n                           'Save', 'Save plot contents as images')\n        self.AddSeparator()\n\n        bind(self, wx.EVT_TOOL, self._onLeftScroll, id=_NTB_X_PAN_LEFT)\n        bind(self, wx.EVT_TOOL, self._onRightScroll, id=_NTB_X_PAN_RIGHT)\n        bind(self, wx.EVT_TOOL, self._onXZoomIn, id=_NTB_X_ZOOMIN)\n        bind(self, wx.EVT_TOOL, self._onXZoomOut, id=_NTB_X_ZOOMOUT)\n        bind(self, wx.EVT_TOOL, self._onUpScroll, id=_NTB_Y_PAN_UP)\n        bind(self, wx.EVT_TOOL, self._onDownScroll, id=_NTB_Y_PAN_DOWN)\n        bind(self, wx.EVT_TOOL, self._onYZoomIn, id=_NTB_Y_ZOOMIN)\n        bind(self, wx.EVT_TOOL, self._onYZoomOut, id=_NTB_Y_ZOOMOUT)\n        bind(self, wx.EVT_TOOL, self._onSave, id=_NTB_SAVE)\n        bind(self, wx.EVT_TOOL_ENTER, self._onEnterTool, id=self.GetId())\n        if can_kill:\n            bind(self, wx.EVT_TOOL, self._onClose, id=_NTB_CLOSE)\n        bind(self, wx.EVT_MOUSEWHEEL, self._onMouseWheel)", "response": "Create the button controls and links them to event handlers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the active axes.", "response": "def set_active(self, ind):\n        \"\"\"\n        ind is a list of index numbers for the axes which are to be made active\n        \"\"\"\n        DEBUG_MSG(\"set_active()\", 1, self)\n        self._ind = ind\n        if ind != None:\n            self._active = [ self._axes[i] for i in self._ind ]\n        else:\n            self._active = []\n        # Now update button text wit active axes\n        self._menu.updateButtonText(ind)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self):\n        DEBUG_MSG(\"update()\", 1, self)\n        self._axes = self.canvas.figure.get_axes()\n        self._menu.updateAxes(len(self._axes))", "response": "Update the toolbar menu - e. g. called when a new subplot is added\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef createFileList(self):\n        global childFileListDownload\n        global filelistDownloadActive\n        mypid = os.getpid()\n        if mypid not in childFileListDownload or not childFileListDownload[mypid].is_alive():\n            childFileListDownload[mypid] = multiproc.Process(target=self.createFileListHTTP)\n            filelistDownloadActive = 1\n            childFileListDownload[mypid].start()\n            filelistDownloadActive = 0", "response": "SRTM data is split into different directories get a list of all of\n            them and create a dictionary for easy lookup"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getURIWithRedirect(self, url):\n        '''fetch a URL with redirect handling'''\n        tries = 0\n        while tries < 5:\n                conn = httplib.HTTPConnection(self.server)\n                conn.request(\"GET\", url)\n                r1 = conn.getresponse()\n                if r1.status in [301, 302, 303, 307]:\n                    location = r1.getheader('Location')\n                    if self.debug:\n                        print(\"redirect from %s to %s\" % (url, location))\n                    url = location\n                    conn.close()\n                    tries += 1\n                    continue\n                data = r1.read()\n                conn.close()\n                if sys.version_info.major < 3:\n                    return data\n                else:\n                    encoding = r1.headers.get_content_charset(default)\n                    return data.decode(encoding)\n        return None", "response": "fetch a URL with redirect handling"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef createFileListHTTP(self):\n        mp_util.child_close_fds()\n        if self.debug:\n            print(\"Connecting to %s\" % self.server, self.directory)\n        try:\n            data = self.getURIWithRedirect(self.directory)\n        except Exception:\n            return\n        parser = parseHTMLDirectoryListing()\n        parser.feed(data)\n        continents = parser.getDirListing()\n        if self.debug:\n            print('continents: ', continents)\n\n        for continent in continents:\n            if not continent[0].isalpha() or continent.startswith('README'):\n                continue\n            if self.debug:\n                print(\"Downloading file list for: \", continent)\n            url = \"%s%s\" % (self.directory,continent)\n            if self.debug:\n                print(\"fetching %s\" % url)\n            try:\n                data = self.getURIWithRedirect(url)\n            except Exception as ex:\n                print(\"Failed to download %s : %s\" % (url, ex))\n                continue\n            parser = parseHTMLDirectoryListing()\n            parser.feed(data)\n            files = parser.getDirListing()\n\n            for filename in files:\n                self.filelist[self.parseFilename(filename)] = (\n                            continent, filename)\n\n            '''print(self.filelist)'''\n        # Add meta info\n        self.filelist[\"server\"] = self.server\n        self.filelist[\"directory\"] = self.directory\n        tmpname = self.filelist_file + \".tmp\"\n        with open(tmpname , 'wb') as output:\n            pickle.dump(self.filelist, output)\n            output.close()\n            try:\n                os.unlink(self.filelist_file)\n            except Exception:\n                pass\n            try:\n                os.rename(tmpname, self.filelist_file)\n            except Exception:\n                pass\n        if self.debug:\n            print(\"created file list with %u entries\" % len(self.filelist))", "response": "Create a list of available SRTM files on the server using HTTP file transfer protocol."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a filename into lat and lon values.", "response": "def parseFilename(self, filename):\n        \"\"\"Get lat/lon values from filename.\"\"\"\n        match = self.filename_regex.match(filename)\n        if match is None:\n            # TODO?: Raise exception?\n            '''print(\"Filename\", filename, \"unrecognized!\")'''\n            return None\n        lat = int(match.group(2))\n        lon = int(match.group(4))\n        if match.group(1) == \"S\":\n            lat = -lat\n        if match.group(3) == \"W\":\n            lon = -lon\n        return lat, lon"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getTile(self, lat, lon):\n        global childFileListDownload\n        global filelistDownloadActive\n        mypid = os.getpid()\n        if mypid in childFileListDownload and childFileListDownload[mypid].is_alive():\n            if self.debug:\n                print(\"still getting file list\")\n            return 0\n        elif not os.path.isfile(self.filelist_file) and filelistDownloadActive == 0:\n            self.createFileList()\n            return 0\n        elif not self.filelist:\n            if self.debug:\n                print(\"Filelist download complete, loading data \", self.filelist_file)\n            data = open(self.filelist_file, 'rb')\n            self.filelist = pickle.load(data)\n            data.close()\n\n        try:\n            continent, filename = self.filelist[(int(lat), int(lon))]\n        except KeyError:\n            if len(self.filelist) > self.min_filelist_len:\n                # we appear to have a full filelist - this must be ocean\n                return SRTMOceanTile(int(lat), int(lon))\n            return 0\n\n        global childTileDownload\n        mypid = os.getpid()\n        if not os.path.exists(os.path.join(self.cachedir, filename)):\n            if not mypid in childTileDownload or not childTileDownload[mypid].is_alive():\n                try:\n                    childTileDownload[mypid] = multiproc.Process(target=self.downloadTile, args=(str(continent), str(filename)))\n                    childTileDownload[mypid].start()\n                except Exception as ex:\n                    if mypid in childTileDownload:\n                        childTileDownload.pop(mypid)\n                    return 0\n                '''print(\"Getting Tile\")'''\n            return 0\n        elif mypid in childTileDownload and childTileDownload[mypid].is_alive():\n            '''print(\"Still Getting Tile\")'''\n            return 0\n        # TODO: Currently we create a new tile object each time.\n        # Caching is required for improved performance.\n        try:\n            return SRTMTile(os.path.join(self.cachedir, filename), int(lat), int(lon))\n        except InvalidTileError:\n            return 0", "response": "This function returns either an SRTM1 or SRTM3 object depending on what is available. This function returns either an SRTM1 or SRTM3 object depending on what is available."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncontrol behaviour of the module", "response": "def cmd_example(self, args):\n        '''control behaviour of the module'''\n        if len(args) == 0:\n            print(self.usage())\n        elif args[0] == \"status\":\n            print(self.status())\n        elif args[0] == \"set\":\n            self.example_settings.command(args[1:])\n        else:\n            print(self.usage())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef status(self):\n        '''returns information about module'''\n        self.status_callcount += 1\n        self.last_bored = time.time() # status entertains us\n        return(\"status called %(status_callcount)d times.  My target positions=%(packets_mytarget)u  Other target positions=%(packets_mytarget)u\" %\n               {\"status_callcount\": self.status_callcount,\n                \"packets_mytarget\": self.packets_mytarget,\n                \"packets_othertarget\": self.packets_othertarget,\n               })", "response": "returns information about module"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall rapidly by mavproxy", "response": "def idle_task(self):\n        '''called rapidly by mavproxy'''\n        now = time.time()\n        if now-self.last_bored > self.boredom_interval:\n            self.last_bored = now\n            message = self.boredom_message()\n            self.say(\"%s: %s\" % (self.name,message))\n            # See if whatever we're connected to would like to play:\n            self.master.mav.statustext_send(mavutil.mavlink.MAV_SEVERITY_NOTICE,\n                                            message)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_rc(self, args):\n        '''handle RC value override'''\n        if len(args) != 2:\n            print(\"Usage: rc <channel|all> <pwmvalue>\")\n            return\n        value = int(args[1])\n        if value > 65535 or value < -1:\n            raise ValueError(\"PWM value must be a positive integer between 0 and 65535\")\n        if value == -1:\n            value = 65535\n        channels = self.override\n        if args[0] == 'all':\n            for i in range(16):\n                channels[i] = value\n        else:\n            channel = int(args[0])\n            if channel < 1 or channel > 16:\n                print(\"Channel must be between 1 and 8 or 'all'\")\n                return\n            channels[channel - 1] = value\n        self.set_override(channels)", "response": "handle RC value override"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef complete_variable(text):\n    '''complete a MAVLink variable or expression'''\n    if text == '':\n        return list(rline_mpstate.status.msgs.keys())\n\n    if text.endswith(\":2\"):\n        suffix = \":2\"\n        text = text[:-2]\n    else:\n        suffix = ''\n\n    try:\n        if mavutil.evaluate_expression(text, rline_mpstate.status.msgs) is not None:\n            return [text+suffix]\n    except Exception as ex:\n        pass\n\n    try:\n        m1 = re.match(\"^(.*?)([A-Z0-9][A-Z0-9_]*)[.]([A-Za-z0-9_]*)$\", text)\n    except Exception as ex:\n        return []\n    if m1 is not None:\n        prefix = m1.group(1)\n        mtype = m1.group(2)\n        fname = m1.group(3)\n        if mtype in rline_mpstate.status.msgs:\n            ret = []\n            for f in rline_mpstate.status.msgs[mtype].get_fieldnames():\n                if f.startswith(fname):\n                    ret.append(prefix + mtype + '.' + f + suffix)\n            return ret\n        return []\n    try:\n        m2 = re.match(\"^(.*?)([A-Z0-9][A-Z0-9_]*)$\", text)\n    except Exception as ex:\n        return []\n    prefix = m2.group(1)\n    mtype = m2.group(2)\n    ret = []\n    for k in list(rline_mpstate.status.msgs.keys()):\n        if k.startswith(mtype):\n            ret.append(prefix + k + suffix)\n    return ret", "response": "complete a MAVLink variable or expression"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef complete_rule(rule, cmd):\n    '''complete using one rule'''\n    global rline_mpstate\n    rule_components = rule.split(' ')\n\n    #  complete the empty string (e.g \"graph <TAB><TAB>\")\n    if len(cmd) == 0:\n        return rule_expand(rule_components[0], \"\")\n\n    # check it matches so far\n    for i in range(len(cmd)-1):\n        if not rule_match(rule_components[i], cmd[i]):\n            return []\n\n    # expand the next rule component\n    expanded = rule_expand(rule_components[len(cmd)-1], cmd[-1])\n    return expanded", "response": "complete using one rule"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getAltitudeAtPoint(self, latty, longy):\n        '''Return the altitude at a particular long/lat'''\n        #check the bounds\n        if self.startlongitude > 0 and (longy < self.startlongitude or longy > self.endlongitude):\n            return -1\n        if self.startlongitude < 0 and (longy > self.startlongitude or longy < self.endlongitude):\n            return -1\n        if self.startlatitude > 0 and (latty < self.startlatitude or longy > self.endlatitude):\n            return -1\n        if self.startlatitude < 0 and (latty > self.startlatitude or longy < self.endlatitude):\n            return -1\n\n        x = numpy.abs((latty - self.startlatitude)/self.deltalatitude)\n        y = numpy.abs((longy - self.startlongitude)/self.deltalongitude)\n\n        #do some interpolation\n        # print(\"x,y\", x, y)\n        x_int = int(x)\n        x_frac = x - int(x)\n        y_int = int(y)\n        y_frac = y - int(y)\n        #print(\"frac\", x_int, x_frac, y_int, y_frac)\n        value00 = self.data[x_int, y_int]\n        value10 = self.data[x_int+1, y_int]\n        value01 = self.data[x_int, y_int+1]\n        value11 = self.data[x_int+1, y_int+1]\n        #print(\"values \", value00, value10, value01, value11)\n\n        #check for null values\n        if value00 == -99999:\n            value00 = 0\n        if value10 == -99999:\n            value10 = 0\n        if value01 == -99999:\n            value01 = 0\n        if value11 == -99999:\n            value11 = 0\n\n        value1 = self._avg(value00, value10, x_frac)\n        value2 = self._avg(value01, value11, x_frac)\n        value  = self._avg(value1,  value2, y_frac)\n\n        return value", "response": "Return the altitude at a particular latty and longy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate the figure and axes for the plotting panel.", "response": "def createPlotPanel(self):\n        '''Creates the figure and axes for the plotting panel.'''\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot(111)\n        self.canvas = FigureCanvas(self,-1,self.figure)\n        self.canvas.SetSize(wx.Size(300,300))\n        self.axes.axis('off')\n        self.figure.subplots_adjust(left=0,right=1,top=1,bottom=0)\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas,1,wx.EXPAND,wx.ALL)\n        self.SetSizerAndFit(self.sizer)\n        self.Fit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calcFontScaling(self):\n        '''Calculates the current font size and left position for the current window.'''\n        self.ypx = self.figure.get_size_inches()[1]*self.figure.dpi\n        self.xpx = self.figure.get_size_inches()[0]*self.figure.dpi\n        self.fontSize = self.vertSize*(self.ypx/2.0)\n        self.leftPos = self.axes.get_xlim()[0]\n        self.rightPos = self.axes.get_xlim()[1]", "response": "Calculates the current font size and left position for the current window."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the window was resized.", "response": "def checkReszie(self):\n        '''Checks if the window was resized.'''\n        if not self.resized:\n            oldypx = self.ypx\n            oldxpx = self.xpx\n            self.ypx = self.figure.get_size_inches()[1]*self.figure.dpi\n            self.xpx = self.figure.get_size_inches()[0]*self.figure.dpi\n            if (oldypx != self.ypx) or (oldxpx != self.xpx):\n                self.resized = True\n            else:\n                self.resized = False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef createHeadingPointer(self):\n        '''Creates the pointer for the current heading.'''\n        self.headingTri = patches.RegularPolygon((0.0,0.80),3,0.05,color='k',zorder=4)\n        self.axes.add_patch(self.headingTri)\n        self.headingText = self.axes.text(0.0,0.675,'0',color='k',size=self.fontSize,horizontalalignment='center',verticalalignment='center',zorder=4)", "response": "Creates the pointer for the current heading."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef adjustHeadingPointer(self):\n        '''Adjust the value of the heading pointer.'''\n        self.headingText.set_text(str(self.heading))\n        self.headingText.set_size(self.fontSize)", "response": "Adjust the value of the heading pointer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef createNorthPointer(self):\n        '''Creates the north pointer relative to current heading.'''\n        self.headingNorthTri = patches.RegularPolygon((0.0,0.80),3,0.05,color='k',zorder=4)\n        self.axes.add_patch(self.headingNorthTri)\n        self.headingNorthText = self.axes.text(0.0,0.675,'N',color='k',size=self.fontSize,horizontalalignment='center',verticalalignment='center',zorder=4)", "response": "Creates the north pointer relative to current heading."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadjust the position and orientation of the north pointer.", "response": "def adjustNorthPointer(self):\n        '''Adjust the position and orientation of\n        the north pointer.'''\n        self.headingNorthText.set_size(self.fontSize) \n        headingRotate = mpl.transforms.Affine2D().rotate_deg_around(0.0,0.0,self.heading)+self.axes.transData\n        self.headingNorthText.set_transform(headingRotate)\n        if (self.heading > 90) and (self.heading < 270):\n            headRot = self.heading-180\n        else:\n            headRot = self.heading\n        self.headingNorthText.set_rotation(headRot)\n        self.headingNorthTri.set_transform(headingRotate)\n        # Adjust if overlapping with heading pointer\n        if (self.heading <= 10.0) or (self.heading >= 350.0):\n            self.headingNorthText.set_text('')\n        else:\n            self.headingNorthText.set_text('N')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhiding or shows the given widgets.", "response": "def toggleWidgets(self,widgets):\n        '''Hides/shows the given widgets.'''\n        for wig in widgets:\n            if wig.get_visible():\n                wig.set_visible(False)\n            else:\n                wig.set_visible(True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the text for roll pitch and yaw.", "response": "def createRPYText(self):\n        '''Creates the text for roll, pitch and yaw.'''\n        self.rollText = self.axes.text(self.leftPos+(self.vertSize/10.0),-0.97+(2*self.vertSize)-(self.vertSize/10.0),'Roll:   %.2f' % self.roll,color='w',size=self.fontSize)\n        self.pitchText = self.axes.text(self.leftPos+(self.vertSize/10.0),-0.97+self.vertSize-(0.5*self.vertSize/10.0),'Pitch: %.2f' % self.pitch,color='w',size=self.fontSize)\n        self.yawText = self.axes.text(self.leftPos+(self.vertSize/10.0),-0.97,'Yaw:   %.2f' % self.yaw,color='w',size=self.fontSize)\n        self.rollText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])\n        self.pitchText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])\n        self.yawText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the locations of roll pitch yaw text.", "response": "def updateRPYLocations(self):\n        '''Update the locations of roll, pitch, yaw text.'''\n        # Locations\n        self.rollText.set_position((self.leftPos+(self.vertSize/10.0),-0.97+(2*self.vertSize)-(self.vertSize/10.0)))\n        self.pitchText.set_position((self.leftPos+(self.vertSize/10.0),-0.97+self.vertSize-(0.5*self.vertSize/10.0)))\n        self.yawText.set_position((self.leftPos+(self.vertSize/10.0),-0.97))\n        # Font Size\n        self.rollText.set_size(self.fontSize)\n        self.pitchText.set_size(self.fontSize)\n        self.yawText.set_size(self.fontSize)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the displayed Roll Pitch Yaw Text", "response": "def updateRPYText(self):\n        'Updates the displayed Roll, Pitch, Yaw Text'\n        self.rollText.set_text('Roll:   %.2f' % self.roll)\n        self.pitchText.set_text('Pitch: %.2f' % self.pitch)\n        self.yawText.set_text('Yaw:   %.2f' % self.yaw)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef createCenterPointMarker(self):\n        '''Creates the center pointer in the middle of the screen.'''\n        self.axes.add_patch(patches.Rectangle((-0.75,-self.thick),0.5,2.0*self.thick,facecolor='orange',zorder=3))\n        self.axes.add_patch(patches.Rectangle((0.25,-self.thick),0.5,2.0*self.thick,facecolor='orange',zorder=3))\n        self.axes.add_patch(patches.Circle((0,0),radius=self.thick,facecolor='orange',edgecolor='none',zorder=3))", "response": "Creates the center pointer in the middle of the screen."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef createHorizonPolygons(self):\n        '''Creates the two polygons to show the sky and ground.'''\n        # Sky Polygon\n        vertsTop = [[-1,0],[-1,1],[1,1],[1,0],[-1,0]]\n        self.topPolygon = Polygon(vertsTop,facecolor='dodgerblue',edgecolor='none')\n        self.axes.add_patch(self.topPolygon)\n        # Ground Polygon\n        vertsBot = [[-1,0],[-1,-1],[1,-1],[1,0],[-1,0]]\n        self.botPolygon = Polygon(vertsBot,facecolor='brown',edgecolor='none')\n        self.axes.add_patch(self.botPolygon)", "response": "Creates the two polygons to show the sky and ground."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the verticies of the patches for the ground and sky.", "response": "def calcHorizonPoints(self):\n        '''Updates the verticies of the patches for the ground and sky.'''\n        ydiff = math.tan(math.radians(-self.roll))*float(self.ratio)\n        pitchdiff = self.dist10deg*(self.pitch/10.0)\n        # Sky Polygon\n        vertsTop = [(-self.ratio,ydiff-pitchdiff),(-self.ratio,1),(self.ratio,1),(self.ratio,-ydiff-pitchdiff),(-self.ratio,ydiff-pitchdiff)]       \n        self.topPolygon.set_xy(vertsTop)\n        # Ground Polygon\n        vertsBot = [(-self.ratio,ydiff-pitchdiff),(-self.ratio,-1),(self.ratio,-1),(self.ratio,-ydiff-pitchdiff),(-self.ratio,ydiff-pitchdiff)]       \n        self.botPolygon.set_xy(vertsBot)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate the rectangle patches for the pitch indicators.", "response": "def createPitchMarkers(self):\n        '''Creates the rectangle patches for the pitch indicators.'''\n        self.pitchPatches = []\n        # Major Lines (multiple of 10 deg)\n        for i in [-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9]:\n            width = self.calcPitchMarkerWidth(i)\n            currPatch = patches.Rectangle((-width/2.0,self.dist10deg*i-(self.thick/2.0)),width,self.thick,facecolor='w',edgecolor='none')\n            self.axes.add_patch(currPatch)\n            self.pitchPatches.append(currPatch)\n        # Add Label for +-30 deg\n        self.vertSize = 0.09\n        self.pitchLabelsLeft = []\n        self.pitchLabelsRight = []\n        i=0\n        for j in [-90,-60,-30,30,60,90]:\n            self.pitchLabelsLeft.append(self.axes.text(-0.55,(j/10.0)*self.dist10deg,str(j),color='w',size=self.fontSize,horizontalalignment='center',verticalalignment='center'))\n            self.pitchLabelsLeft[i].set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])\n            self.pitchLabelsRight.append(self.axes.text(0.55,(j/10.0)*self.dist10deg,str(j),color='w',size=self.fontSize,horizontalalignment='center',verticalalignment='center'))\n            self.pitchLabelsRight[i].set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])\n            i += 1"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadjusting the location and orientation of pitch markers.", "response": "def adjustPitchmarkers(self):\n        '''Adjusts the location and orientation of pitch markers.'''\n        pitchdiff = self.dist10deg*(self.pitch/10.0)\n        rollRotate = mpl.transforms.Affine2D().rotate_deg_around(0.0,-pitchdiff,self.roll)+self.axes.transData\n        j=0\n        for i in [-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9]:\n            width = self.calcPitchMarkerWidth(i)\n            self.pitchPatches[j].set_xy((-width/2.0,self.dist10deg*i-(self.thick/2.0)-pitchdiff))\n            self.pitchPatches[j].set_transform(rollRotate)\n            j+=1\n        # Adjust Text Size and rotation\n        i=0\n        for j in [-9,-6,-3,3,6,9]:\n                self.pitchLabelsLeft[i].set_y(j*self.dist10deg-pitchdiff)\n                self.pitchLabelsRight[i].set_y(j*self.dist10deg-pitchdiff)\n                self.pitchLabelsLeft[i].set_size(self.fontSize)\n                self.pitchLabelsRight[i].set_size(self.fontSize)\n                self.pitchLabelsLeft[i].set_rotation(self.roll)\n                self.pitchLabelsRight[i].set_rotation(self.roll)\n                self.pitchLabelsLeft[i].set_transform(rollRotate)\n                self.pitchLabelsRight[i].set_transform(rollRotate)\n                i += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef createAARText(self):\n        '''Creates the text for airspeed, altitude and climb rate.'''\n        self.airspeedText = self.axes.text(self.rightPos-(self.vertSize/10.0),-0.97+(2*self.vertSize)-(self.vertSize/10.0),'AS:   %.1f m/s' % self.airspeed,color='w',size=self.fontSize,ha='right')\n        self.altitudeText = self.axes.text(self.rightPos-(self.vertSize/10.0),-0.97+self.vertSize-(0.5*self.vertSize/10.0),'ALT: %.1f m   ' % self.relAlt,color='w',size=self.fontSize,ha='right')\n        self.climbRateText = self.axes.text(self.rightPos-(self.vertSize/10.0),-0.97,'CR:   %.1f m/s' % self.climbRate,color='w',size=self.fontSize,ha='right')\n        self.airspeedText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])\n        self.altitudeText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])\n        self.climbRateText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])", "response": "Creates the text for airspeed altitude and climb rate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef updateAARLocations(self):\n        '''Update the locations of airspeed, altitude and Climb rate.'''\n        # Locations\n        self.airspeedText.set_position((self.rightPos-(self.vertSize/10.0),-0.97+(2*self.vertSize)-(self.vertSize/10.0)))\n        self.altitudeText.set_position((self.rightPos-(self.vertSize/10.0),-0.97+self.vertSize-(0.5*self.vertSize/10.0)))\n        self.climbRateText.set_position((self.rightPos-(self.vertSize/10.0),-0.97))\n        # Font Size\n        self.airspeedText.set_size(self.fontSize)\n        self.altitudeText.set_size(self.fontSize)\n        self.climbRateText.set_size(self.fontSize)", "response": "Update the locations of airspeed altitude and Climb rate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef updateAARText(self):\n        'Updates the displayed airspeed, altitude, climb rate Text'\n        self.airspeedText.set_text('AR:   %.1f m/s' % self.airspeed)\n        self.altitudeText.set_text('ALT: %.1f m   ' % self.relAlt)\n        self.climbRateText.set_text('CR:   %.1f m/s' % self.climbRate)", "response": "Updates the displayed airspeed altitude climb rate Text"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates the bar to display current battery percentage.", "response": "def createBatteryBar(self):\n        '''Creates the bar to display current battery percentage.'''\n        self.batOutRec = patches.Rectangle((self.rightPos-(1.3+self.rOffset)*self.batWidth,1.0-(0.1+1.0+(2*0.075))*self.batHeight),self.batWidth*1.3,self.batHeight*1.15,facecolor='darkgrey',edgecolor='none')\n        self.batInRec = patches.Rectangle((self.rightPos-(self.rOffset+1+0.15)*self.batWidth,1.0-(0.1+1+0.075)*self.batHeight),self.batWidth,self.batHeight,facecolor='lawngreen',edgecolor='none')\n        self.batPerText = self.axes.text(self.rightPos - (self.rOffset+0.65)*self.batWidth,1-(0.1+1+(0.075+0.15))*self.batHeight,'%.f' % self.batRemain,color='w',size=self.fontSize,ha='center',va='top')\n        self.batPerText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])\n        self.voltsText = self.axes.text(self.rightPos-(self.rOffset+1.3+0.2)*self.batWidth,1-(0.1+0.05+0.075)*self.batHeight,'%.1f V' % self.voltage,color='w',size=self.fontSize,ha='right',va='top')\n        self.ampsText = self.axes.text(self.rightPos-(self.rOffset+1.3+0.2)*self.batWidth,1-self.vertSize-(0.1+0.05+0.1+0.075)*self.batHeight,'%.1f A' % self.current,color='w',size=self.fontSize,ha='right',va='top')\n        self.voltsText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])\n        self.ampsText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])\n        \n        self.axes.add_patch(self.batOutRec)\n        self.axes.add_patch(self.batInRec)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef updateBatteryBar(self):\n        '''Updates the position and values of the battery bar.'''\n        # Bar\n        self.batOutRec.set_xy((self.rightPos-(1.3+self.rOffset)*self.batWidth,1.0-(0.1+1.0+(2*0.075))*self.batHeight))\n        self.batInRec.set_xy((self.rightPos-(self.rOffset+1+0.15)*self.batWidth,1.0-(0.1+1+0.075)*self.batHeight))\n        self.batPerText.set_position((self.rightPos - (self.rOffset+0.65)*self.batWidth,1-(0.1+1+(0.075+0.15))*self.batHeight))\n        self.batPerText.set_fontsize(self.fontSize)\n        self.voltsText.set_text('%.1f V' % self.voltage)\n        self.ampsText.set_text('%.1f A' % self.current)\n        self.voltsText.set_position((self.rightPos-(self.rOffset+1.3+0.2)*self.batWidth,1-(0.1+0.05)*self.batHeight))\n        self.ampsText.set_position((self.rightPos-(self.rOffset+1.3+0.2)*self.batWidth,1-self.vertSize-(0.1+0.05+0.1)*self.batHeight))\n        self.voltsText.set_fontsize(self.fontSize)\n        self.ampsText.set_fontsize(self.fontSize)\n        if self.batRemain >= 0:\n            self.batPerText.set_text(int(self.batRemain))\n            self.batInRec.set_height(self.batRemain*self.batHeight/100.0)\n            if self.batRemain/100.0 > 0.5:\n                self.batInRec.set_facecolor('lawngreen')\n            elif self.batRemain/100.0 <= 0.5 and self.batRemain/100.0 > 0.2:\n                self.batInRec.set_facecolor('yellow')\n            elif self.batRemain/100.0 <= 0.2 and self.batRemain >= 0.0:\n                self.batInRec.set_facecolor('r')\n        elif self.batRemain == -1:\n            self.batInRec.set_height(self.batHeight)\n            self.batInRec.set_facecolor('k')", "response": "Updates the position and values of the battery bar."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate the mode and arm state text.", "response": "def createStateText(self):\n        '''Creates the mode and arm state text.'''\n        self.modeText = self.axes.text(self.leftPos+(self.vertSize/10.0),0.97,'UNKNOWN',color='grey',size=1.5*self.fontSize,ha='left',va='top')\n        self.modeText.set_path_effects([PathEffects.withStroke(linewidth=self.fontSize/10.0,foreground='black')])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the mode and colours red or green depending on arm state.", "response": "def updateStateText(self):\n        '''Updates the mode and colours red or green depending on arm state.'''\n        self.modeText.set_position((self.leftPos+(self.vertSize/10.0),0.97))\n        self.modeText.set_text(self.mode)\n        self.modeText.set_size(1.5*self.fontSize)\n        if self.armed:\n            self.modeText.set_color('red')\n            self.modeText.set_path_effects([PathEffects.withStroke(linewidth=self.fontSize/10.0,foreground='yellow')])\n        elif (self.armed == False):\n            self.modeText.set_color('lightgreen')\n            self.modeText.set_bbox(None)\n            self.modeText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='black')])\n        else:\n            # Fall back if unknown\n            self.modeText.set_color('grey')\n            self.modeText.set_bbox(None)\n            self.modeText.set_path_effects([PathEffects.withStroke(linewidth=self.fontSize/10.0,foreground='black')])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef createWPText(self):\n        '''Creates the text for the current and final waypoint,\n        and the distance to the new waypoint.'''\n        self.wpText = self.axes.text(self.leftPos+(1.5*self.vertSize/10.0),0.97-(1.5*self.vertSize)+(0.5*self.vertSize/10.0),'0/0\\n(0 m, 0 s)',color='w',size=self.fontSize,ha='left',va='top')\n        self.wpText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='black')])", "response": "Creates the text for the current and final waypoint\n        and the distance to the new waypoint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the current waypoint and distance to it.", "response": "def updateWPText(self):\n        '''Updates the current waypoint and distance to it.''' \n        self.wpText.set_position((self.leftPos+(1.5*self.vertSize/10.0),0.97-(1.5*self.vertSize)+(0.5*self.vertSize/10.0)))\n        self.wpText.set_size(self.fontSize)\n        if type(self.nextWPTime) is str:\n            self.wpText.set_text('%.f/%.f\\n(%.f m, ~ s)' % (self.currentWP,self.finalWP,self.wpDist))\n        else:\n            self.wpText.set_text('%.f/%.f\\n(%.f m, %.f s)' % (self.currentWP,self.finalWP,self.wpDist,self.nextWPTime))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef createWPPointer(self):\n        '''Creates the waypoint pointer relative to current heading.'''\n        self.headingWPTri = patches.RegularPolygon((0.0,0.55),3,0.05,facecolor='lime',zorder=4,ec='k')\n        self.axes.add_patch(self.headingWPTri)\n        self.headingWPText = self.axes.text(0.0,0.45,'1',color='lime',size=self.fontSize,horizontalalignment='center',verticalalignment='center',zorder=4)   \n        self.headingWPText.set_path_effects([PathEffects.withStroke(linewidth=1,foreground='k')])", "response": "Creates the waypoint pointer relative to current heading."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef adjustWPPointer(self):\n        '''Adjust the position and orientation of\n        the waypoint pointer.'''\n        self.headingWPText.set_size(self.fontSize) \n        headingRotate = mpl.transforms.Affine2D().rotate_deg_around(0.0,0.0,-self.wpBearing+self.heading)+self.axes.transData\n        self.headingWPText.set_transform(headingRotate)\n        angle = self.wpBearing - self.heading\n        if angle < 0:\n            angle += 360\n        if (angle > 90) and (angle < 270):\n            headRot = angle-180\n        else:\n            headRot = angle\n        self.headingWPText.set_rotation(-headRot)\n        self.headingWPTri.set_transform(headingRotate)\n        self.headingWPText.set_text('%.f' % (angle))", "response": "Adjust the position and orientation of\n        the waypoint pointer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef createAltHistoryPlot(self):\n        '''Creates the altitude history plot.'''\n        self.altHistRect = patches.Rectangle((self.leftPos+(self.vertSize/10.0),-0.25),0.5,0.5,facecolor='grey',edgecolor='none',alpha=0.4,zorder=4)\n        self.axes.add_patch(self.altHistRect)\n        self.altPlot, = self.axes.plot([self.leftPos+(self.vertSize/10.0),self.leftPos+(self.vertSize/10.0)+0.5],[0.0,0.0],color='k',marker=None,zorder=4)\n        self.altMarker, = self.axes.plot(self.leftPos+(self.vertSize/10.0)+0.5,0.0,marker='o',color='k',zorder=4)\n        self.altText2 = self.axes.text(self.leftPos+(4*self.vertSize/10.0)+0.5,0.0,'%.f m' % self.relAlt,color='k',size=self.fontSize,ha='left',va='center',zorder=4)", "response": "Creates the altitude history plot."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the altitude history plot.", "response": "def updateAltHistory(self):\n        '''Updates the altitude history plot.'''\n        self.altHist.append(self.relAlt)\n        self.timeHist.append(self.relAltTime)\n        \n        # Delete entries older than x seconds\n        histLim = 10\n        currentTime = time.time()\n        point = 0\n        for i in range(0,len(self.timeHist)):\n            if (self.timeHist[i] > (currentTime - 10.0)):\n                break\n        # Remove old entries\n        self.altHist = self.altHist[i:]\n        self.timeHist = self.timeHist[i:]\n        \n        # Transform Data\n        x = []\n        y = []\n        tmin = min(self.timeHist)\n        tmax = max(self.timeHist)\n        x1 = self.leftPos+(self.vertSize/10.0)\n        y1 = -0.25\n        altMin = 0\n        altMax = max(self.altHist)\n        # Keep alt max for whole mission\n        if altMax > self.altMax:\n            self.altMax = altMax\n        else:\n            altMax = self.altMax\n        if tmax != tmin:\n            mx = 0.5/(tmax-tmin)\n        else:\n            mx = 0.0\n        if altMax != altMin:\n            my = 0.5/(altMax-altMin)\n        else:\n            my = 0.0\n        for t in self.timeHist:\n            x.append(mx*(t-tmin)+x1)\n        for alt in self.altHist:\n            val = my*(alt-altMin)+y1\n            # Crop extreme noise\n            if val < -0.25:\n                val = -0.25\n            elif val > 0.25:\n                val = 0.25\n            y.append(val)\n        # Display Plot\n        self.altHistRect.set_x(self.leftPos+(self.vertSize/10.0))\n        self.altPlot.set_data(x,y)\n        self.altMarker.set_data(self.leftPos+(self.vertSize/10.0)+0.5,val)\n        self.altText2.set_position((self.leftPos+(4*self.vertSize/10.0)+0.5,val))\n        self.altText2.set_size(self.fontSize)\n        self.altText2.set_text('%.f m' % self.relAlt)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_tuneopt(self, args):\n        '''Select option for Tune Pot on Channel 6 (quadcopter only)'''\n        usage = \"usage: tuneopt <set|show|reset|list>\"\n        if self.mpstate.vehicle_type != 'copter':\n            print(\"This command is only available for copter\")\n            return\n        if len(args) < 1:\n            print(usage)\n            return\n        if args[0].lower() == 'reset':\n            self.param_set('TUNE', '0')\n        elif args[0].lower() == 'set':\n            if len(args) < 4:\n                print('Usage: tuneopt set OPTION LOW HIGH')\n                return\n            option = self.tune_option_validate(args[1])\n            if not option:\n                print('Invalid Tune option: ' + args[1])\n                return\n            low = args[2]\n            high = args[3]\n            self.param_set('TUNE', tune_options[option])\n            self.param_set('TUNE_LOW', float(low) * 1000)\n            self.param_set('TUNE_HIGH', float(high) * 1000)\n        elif args[0].lower() == 'show':\n            self.tune_show()\n        elif args[0].lower() == 'list':\n            print(\"Options available:\")\n            for s in sorted(tune_options.keys()):\n                print('  ' + s)\n        else:\n            print(usage)", "response": "Select option for Tune Pot on Channel 6"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fenceloader(self):\n        '''fence loader by sysid'''\n        if not self.target_system in self.fenceloader_by_sysid:\n            self.fenceloader_by_sysid[self.target_system] = mavwp.MAVFenceLoader()\n        return self.fenceloader_by_sysid[self.target_system]", "response": "fence loader by sysid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling and incoming mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle and incoming mavlink packet'''\n        if m.get_type() == \"FENCE_STATUS\":\n            self.last_fence_breach = m.breach_time\n            self.last_fence_status = m.breach_status\n        elif m.get_type() in ['SYS_STATUS']:\n            bits = mavutil.mavlink.MAV_SYS_STATUS_GEOFENCE\n\n            present = ((m.onboard_control_sensors_present & bits) == bits)\n            if self.present == False and present == True:\n                self.say(\"fence present\")\n            elif self.present == True and present == False:\n                self.say(\"fence removed\")\n            self.present = present\n\n            enabled = ((m.onboard_control_sensors_enabled & bits) == bits)\n            if self.enabled == False and enabled == True:\n                self.say(\"fence enabled\")\n            elif self.enabled == True and enabled == False:\n                self.say(\"fence disabled\")\n            self.enabled = enabled\n\n            healthy = ((m.onboard_control_sensors_health & bits) == bits)\n            if self.healthy == False and healthy == True:\n                self.say(\"fence OK\")\n            elif self.healthy == True and healthy == False:\n                self.say(\"fence breach\")\n            self.healthy = healthy\n\n            #console output for fence:\n            if not self.present:\n                self.console.set_status('Fence', 'FEN', row=0, fg='black')\n            elif self.enabled == False:\n                self.console.set_status('Fence', 'FEN', row=0, fg='grey')\n            elif self.enabled == True and self.healthy == True:\n                self.console.set_status('Fence', 'FEN', row=0, fg='green')\n            elif self.enabled == True and self.healthy == False:\n                self.console.set_status('Fence', 'FEN', row=0, fg='red')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload fence points from a file", "response": "def load_fence(self, filename):\n        '''load fence points from a file'''\n        try:\n            self.fenceloader.target_system = self.target_system\n            self.fenceloader.target_component = self.target_component\n            self.fenceloader.load(filename.strip('\"'))\n        except Exception as msg:\n            print(\"Unable to load %s - %s\" % (filename, msg))\n            return\n        print(\"Loaded %u geo-fence points from %s\" % (self.fenceloader.count(), filename))\n        self.send_fence()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_fence(self, filename):\n        '''list fence points, optionally saving to a file'''\n        self.fenceloader.clear()\n        count = self.get_mav_param('FENCE_TOTAL', 0)\n        if count == 0:\n            print(\"No geo-fence points\")\n            return\n        for i in range(int(count)):\n            p = self.fetch_fence_point(i)\n            if p is None:\n                return\n            self.fenceloader.add(p)\n\n        if filename is not None:\n            try:\n                self.fenceloader.save(filename.strip('\"'))\n            except Exception as msg:\n                print(\"Unable to save %s - %s\" % (filename, msg))\n                return\n            print(\"Saved %u geo-fence points to %s\" % (self.fenceloader.count(), filename))\n        else:\n            for i in range(self.fenceloader.count()):\n                p = self.fenceloader.point(i)\n                self.console.writeln(\"lat=%f lng=%f\" % (p.lat, p.lng))\n        if self.status.logdir is not None:\n            fname = 'fence.txt'\n            if self.target_system > 1:\n                fname = 'fence_%u.txt' % self.target_system\n            fencetxt = os.path.join(self.status.logdir, fname)\n            self.fenceloader.save(fencetxt.strip('\"'))\n            print(\"Saved fence to %s\" % fencetxt)\n        self.have_list = True", "response": "list fence points optionally saving to a file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndisplaying raw ACC data in logfile", "response": "def mavfft_display(logfile, condition=None):\n    '''display fft for raw ACC data in logfile'''\n\n    '''object to store data about a single FFT plot'''\n    class PlotData(object):\n        def __init__(self, ffth):\n            self.seqno = -1\n            self.fftnum = ffth.N\n            self.sensor_type = ffth.type\n            self.instance = ffth.instance\n            self.sample_rate_hz = ffth.smp_rate\n            self.multiplier = ffth.mul\n            self.data = {}\n            self.data[\"X\"] = []\n            self.data[\"Y\"] = []\n            self.data[\"Z\"] = []\n            self.holes = False\n            self.freq = None\n\n        def add_fftd(self, fftd):\n            if fftd.N != self.fftnum:\n                print(\"Skipping ISBD with wrong fftnum (%u vs %u)\\n\" % (fftd.fftnum, self.fftnum))\n                return\n            if self.holes:\n                print(\"Skipping ISBD(%u) for ISBH(%u) with holes in it\" % (fftd.seqno, self.fftnum))\n                return\n            if fftd.seqno != self.seqno+1:\n                print(\"ISBH(%u) has holes in it\" % fftd.N)\n                self.holes = True\n                return\n            self.seqno += 1\n            self.data[\"X\"].extend(fftd.x)\n            self.data[\"Y\"].extend(fftd.y)\n            self.data[\"Z\"].extend(fftd.z)\n\n        def prefix(self):\n            if self.sensor_type == 0:\n                return \"Accel\"\n            elif self.sensor_type == 1:\n                return \"Gyro\"\n            else:\n                return \"?Unknown Sensor Type?\"\n\n        def tag(self):\n            return str(self)\n\n        def __str__(self):\n            return \"%s[%u]\" % (self.prefix(), self.instance)\n\n    print(\"Processing log for ISBH and ISBD messages\")\n\n    things_to_plot = []\n    plotdata = None\n    start_time = time.time()\n    mlog = mavutil.mavlink_connection(logfile)\n    while True:\n        m = mlog.recv_match(type=['ISBH','ISBD'],condition=condition)\n        if m is None:\n            break\n        msg_type = m.get_type()\n        if msg_type == \"ISBH\":\n            if plotdata is not None:\n                # close off previous data collection\n                things_to_plot.append(plotdata)\n            # initialise plot-data collection object\n            plotdata = PlotData(m)\n            continue\n\n        if msg_type == \"ISBD\":\n            if plotdata is None:\n                continue\n            plotdata.add_fftd(m)\n\n    if len(things_to_plot) == 0:\n        print(\"No FFT data. Did you set INS_LOG_BAT_MASK?\")\n        return\n    time_delta = time.time() - start_time\n    print(\"Extracted %u fft data sets\" % len(things_to_plot))\n\n    sum_fft = {}\n    freqmap = {}\n    count = 0\n\n    first_freq = None\n    for thing_to_plot in things_to_plot:\n        for axis in [ \"X\",\"Y\",\"Z\" ]:\n            d = numpy.array(thing_to_plot.data[axis])/float(thing_to_plot.multiplier)\n            if len(d) == 0:\n                print(\"No data?!?!?!\")\n                continue\n            \n            avg = numpy.sum(d) / len(d)\n            d -= avg\n            d_fft = numpy.fft.rfft(d)\n            if thing_to_plot.tag() not in sum_fft:\n                sum_fft[thing_to_plot.tag()] = {\n                    \"X\": 0,\n                    \"Y\": 0,\n                    \"Z\": 0\n                }\n            sum_fft[thing_to_plot.tag()][axis] = numpy.add(sum_fft[thing_to_plot.tag()][axis], d_fft)\n            count += 1\n            freq = numpy.fft.rfftfreq(len(d), 1.0/thing_to_plot.sample_rate_hz)\n            freqmap[thing_to_plot.tag()] = freq\n\n    for sensor in sum_fft:\n        pylab.figure(str(sensor))\n        for axis in [ \"X\",\"Y\",\"Z\" ]:\n            pylab.plot(freqmap[sensor], numpy.abs(sum_fft[sensor][axis]/count), label=axis)\n        pylab.legend(loc='upper right')\n        pylab.xlabel('Hz')\n\n    pylab.show()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the currently displayed image", "response": "def set_image(self, img, bgr=False):\n        '''set the currently displayed image'''\n        if not self.is_alive():\n            return\n        if not hasattr(img, 'shape'):\n            img = np.asarray(img[:,:])\n        if bgr:\n            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        self.in_queue.put(MPImageData(img))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef poll(self):\n        '''check for events, returning one event'''\n        if self.out_queue.qsize() <= 0:\n            return None\n        evt = self.out_queue.get()\n        while isinstance(evt, win_layout.WinLayout):\n            win_layout.set_layout(evt, self.set_layout)\n            if self.out_queue.qsize() == 0:\n                return None\n            evt = self.out_queue.get()\n        return evt", "response": "check for events returning one event"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef events(self):\n        '''check for events a list of events'''\n        ret = []\n        while True:\n            e = self.poll()\n            if e is None:\n                break\n            ret.append(e)\n        return ret", "response": "check for events a list of events"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef on_idle(self, event):\n        '''prevent the main loop spinning too fast'''\n        state = self.state\n        now = time.time()\n        if now - self.last_layout_send > 1:\n            self.last_layout_send = now\n            state.out_queue.put(win_layout.get_wx_window_layout(self))\n        time.sleep(0.1)", "response": "prevent the main loop spinning too fast"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_redraw_timer(self, event):\n        '''the redraw timer ensures we show new map tiles as they\n        are downloaded'''\n        state = self.state\n        while state.in_queue.qsize():\n            try:\n                obj = state.in_queue.get()\n            except Exception:\n                time.sleep(0.05)\n                return\n            if isinstance(obj, MPImageData):\n                with warnings.catch_warnings():\n                    warnings.simplefilter('ignore')\n                    img = wx.EmptyImage(obj.width, obj.height)\n                img.SetData(obj.data)\n                self.img = img\n                self.need_redraw = True\n                if state.auto_size:\n                    client_area = state.frame.GetClientSize()\n                    total_area = state.frame.GetSize()\n                    bx = max(total_area.x - client_area.x,0)\n                    by = max(total_area.y - client_area.y,0)\n                    state.frame.SetSize(wx.Size(obj.width+bx, obj.height+by))\n            if isinstance(obj, MPImageTitle):\n                state.frame.SetTitle(obj.title)\n            if isinstance(obj, MPImageRecenter):\n                self.on_recenter(obj.location)\n            if isinstance(obj, MPImageMenu):\n                self.set_menu(obj.menu)\n            if isinstance(obj, MPImagePopupMenu):\n                self.set_popup_menu(obj.menu)\n            if isinstance(obj, MPImageBrightness):\n                state.brightness = obj.brightness\n                self.need_redraw = True\n            if isinstance(obj, MPImageFullSize):\n                self.full_size()\n            if isinstance(obj, MPImageFitToWindow):\n                self.fit_to_window()\n            if isinstance(obj, win_layout.WinLayout):\n                win_layout.set_wx_window_layout(state.frame, obj)\n                \n        if self.need_redraw:\n            self.redraw()", "response": "the redraw timer ensures we show new map tiles as they are downloaded"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_mouse_wheel(self, event):\n        '''handle mouse wheel zoom changes'''\n        state = self.state\n        if not state.can_zoom:\n            return\n        mousepos = self.image_coordinates(event.GetPosition())\n        rotation = event.GetWheelRotation() / event.GetWheelDelta()\n        oldzoom = self.zoom\n        if rotation > 0:\n            self.zoom /= 1.0/(1.1 * rotation)\n        elif rotation < 0:\n            self.zoom /= 1.1 * (-rotation)\n        if self.zoom > 10:\n            self.zoom = 10\n        elif self.zoom < 0.1:\n            self.zoom = 0.1\n        if oldzoom < 1 and self.zoom > 1:\n            self.zoom = 1\n        if oldzoom > 1 and self.zoom < 1:\n            self.zoom = 1\n        client_area = state.frame.GetClientSize()\n        fit_window_zoom_level = min(float(client_area.x) / self.img.GetWidth(),\n                                    float(client_area.y) / self.img.GetHeight())\n        if self.zoom < fit_window_zoom_level:\n            self.zoom = fit_window_zoom_level\n        self.need_redraw = True\n        new = self.image_coordinates(event.GetPosition())\n        # adjust dragpos so the zoom doesn't change what pixel is under the mouse\n        self.dragpos = wx.Point(self.dragpos.x - (new.x-mousepos.x), self.dragpos.y - (new.y-mousepos.y))\n        self.limit_dragpos()", "response": "handle mouse wheel zoom changes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_object(self, key, layers):\n        '''find an object to be modified'''\n        state = self.state\n\n        if layers is None or layers == '':\n            layers = state.layers.keys()\n        for layer in layers:\n            if key in state.layers[layer]:\n                return state.layers[layer][key]\n        return None", "response": "find an object to be modified"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds an object to a layer", "response": "def add_object(self, obj):\n        '''add an object to a layer'''\n        state = self.state\n        if not obj.layer in state.layers:\n            # its a new layer\n            state.layers[obj.layer] = {}\n        state.layers[obj.layer][obj.key] = obj\n        state.need_redraw = True\n        if (not self.legend_checkbox_menuitem_added and\n            isinstance(obj, SlipFlightModeLegend)):\n            self.add_legend_checkbox_menuitem()\n            self.legend_checkbox_menuitem_added = True\n            self.SetMenuBar(self.menu.wx_menu())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_idle(self, event):\n        '''prevent the main loop spinning too fast'''\n        state = self.state\n\n        if state.close_window.acquire(False):\n            self.state.app.ExitMainLoop()\n\n        now = time.time()\n        if now - self.last_layout_send > 1:\n            self.last_layout_send = now\n            state.event_queue.put(win_layout.get_wx_window_layout(self))\n\n        # receive any display objects from the parent\n        obj = None\n\n        while not state.object_queue.empty():\n            obj = state.object_queue.get()\n\n            if isinstance(obj, win_layout.WinLayout):\n                win_layout.set_wx_window_layout(self, obj)\n                \n            if isinstance(obj, SlipObject):\n                self.add_object(obj)\n\n            if isinstance(obj, SlipPosition):\n                # move an object\n                object = self.find_object(obj.key, obj.layer)\n                if object is not None:\n                    object.update_position(obj)\n                    if getattr(object, 'follow', False):\n                        self.follow(object)\n                    if obj.label is not None:\n                        object.label = obj.label\n                    if obj.colour is not None:\n                        object.colour = obj.colour\n                    state.need_redraw = True\n\n            if isinstance(obj, SlipDefaultPopup):\n                state.default_popup = obj\n\n            if isinstance(obj, SlipInformation):\n                # see if its a existing one or a new one\n                if obj.key in state.info:\n#                    print('update %s' % str(obj.key))\n                    state.info[obj.key].update(obj)\n                else:\n#                    print('add %s' % str(obj.key))\n                    state.info[obj.key] = obj\n                state.need_redraw = True\n\n            if isinstance(obj, SlipCenter):\n                # move center\n                (lat,lon) = obj.latlon\n                state.panel.re_center(state.width/2, state.height/2, lat, lon)\n                state.need_redraw = True\n\n            if isinstance(obj, SlipZoom):\n                # change zoom\n                state.panel.set_ground_width(obj.ground_width)\n                state.need_redraw = True\n                \n            if isinstance(obj, SlipFollow):\n                # enable/disable follow\n                state.follow = obj.enable\n\n            if isinstance(obj, SlipFollowObject):\n                # enable/disable follow on an object\n                for layer in state.layers:\n                    if obj.key in state.layers[layer]:\n                        if hasattr(state.layers[layer][obj.key], 'follow'):\n                            state.layers[layer][obj.key].follow = obj.enable\n                \n            if isinstance(obj, SlipBrightness):\n                # set map brightness\n                state.brightness = obj.brightness\n                state.need_redraw = True\n\n            if isinstance(obj, SlipClearLayer):\n                # remove all objects from a layer\n                if obj.layer in state.layers:\n                    state.layers.pop(obj.layer)\n                state.need_redraw = True\n\n            if isinstance(obj, SlipRemoveObject):\n                # remove an object by key\n                for layer in state.layers:\n                    if obj.key in state.layers[layer]:\n                        state.layers[layer].pop(obj.key)\n                state.need_redraw = True\n\n            if isinstance(obj, SlipHideObject):\n                # hide an object by key\n                for layer in state.layers:\n                    if obj.key in state.layers[layer]:\n                        state.layers[layer][obj.key].set_hidden(obj.hide)\n                state.need_redraw = True\n\n        if obj is None:\n            time.sleep(0.05)", "response": "prevent the main loop spinning too fast"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_ground_width(self, ground_width):\n        '''set ground width of view'''\n        state = self.state\n        state.ground_width = ground_width\n        state.panel.re_center(state.width/2, state.height/2, state.lat, state.lon)", "response": "set ground width of view"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef draw_objects(self, objects, bounds, img):\n        '''draw objects on the image'''\n        keys = sorted(objects.keys())\n        for k in keys:\n            obj = objects[k]\n            if not self.state.legend and isinstance(obj, SlipFlightModeLegend):\n                continue\n            bounds2 = obj.bounds()\n            if bounds2 is None or mp_util.bounds_overlap(bounds, bounds2):\n                obj.draw(img, self.pixmapper, bounds)", "response": "draw objects on the image"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nredrawing the map with current settings", "response": "def redraw_map(self):\n        '''redraw the map with current settings'''\n        state = self.state\n\n        view_same = (self.last_view is not None and self.map_img is not None and self.last_view == self.current_view())\n\n        if view_same and not state.need_redraw:\n            return\n\n        # get the new map\n        self.map_img = state.mt.area_to_image(state.lat, state.lon,\n                                              state.width, state.height, state.ground_width)\n        if state.brightness != 0: # valid state.brightness range is [-255, 255]\n            brightness = np.uint8(np.abs(state.brightness))\n            if state.brightness > 0:\n                self.map_img = np.where((255 - self.map_img) < brightness, 255, self.map_img + brightness)\n            else:\n                self.map_img = np.where((255 + self.map_img) < brightness, 0, self.map_img - brightness)\n            \n        # find display bounding box\n        (lat2,lon2) = self.coordinates(state.width-1, state.height-1)\n        bounds = (lat2, state.lon, state.lat-lat2, lon2-state.lon)\n\n        # get the image\n        img = self.map_img.copy()\n\n        # possibly draw a grid\n        if state.grid:\n            SlipGrid('grid', layer=3, linewidth=1, colour=(255,255,0)).draw(img, self.pixmapper, bounds)\n\n        # draw layer objects\n        keys = state.layers.keys()\n        keys = sorted(list(keys))\n        for k in keys:\n            self.draw_objects(state.layers[k], bounds, img)\n\n        # draw information objects\n        for key in state.info:\n            state.info[key].draw(state.panel, state.panel.information)\n\n        # display the image\n        self.imagePanel.set_image(img)\n\n        self.update_position()\n\n        self.mainSizer.Fit(self)\n        self.Refresh()\n        self.last_view = self.current_view()\n        self.SetFocus()\n        state.need_redraw = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_mouse_wheel(self, event):\n        '''handle mouse wheel zoom changes'''\n        rotation = event.GetWheelRotation() / event.GetWheelDelta()\n        if rotation > 0:\n            zoom = 1.0/(1.1 * rotation)\n        elif rotation < 0:\n            zoom = 1.1 * (-rotation)\n        self.change_zoom(zoom)\n        self.redraw_map()", "response": "handle mouse wheel zoom changes"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nshow popup menu for an object", "response": "def show_popup(self, selected, pos):\n        '''show popup menu for an object'''\n        state = self.state\n        if selected.popup_menu is not None:\n            import copy\n            popup_menu = selected.popup_menu\n            if state.default_popup is not None and state.default_popup.combine:\n                popup_menu = copy.deepcopy(popup_menu)\n                popup_menu.add(MPMenuSeparator())\n                popup_menu.combine(state.default_popup.popup)\n            wx_menu = popup_menu.wx_menu()\n            state.frame.PopupMenu(wx_menu, pos)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef child_task(self):\n        '''child process - this holds all the GUI elements'''\n        mp_util.child_close_fds()\n\n        import matplotlib, platform\n        if platform.system() != \"Darwin\":\n            # on MacOS we can't set WxAgg here as it conflicts with the MacOS version\n            matplotlib.use('WXAgg')\n\n        from MAVProxy.modules.lib import wx_processguard\n        from MAVProxy.modules.lib.wx_loader import wx\n\n        app = wx.App(False)\n        from MAVProxy.modules.lib import live_graph_ui\n        app.frame = live_graph_ui.GraphFrame(state=self)\n        app.frame.Show()\n        app.MainLoop()", "response": "child process - this holds all the GUI elements"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_watch(args):\n    '''watch a mavlink packet pattern'''\n    if len(args) == 0:\n        mpstate.status.watch = None\n        return\n    mpstate.status.watch = args\n    print(\"Watching %s\" % mpstate.status.watch)", "response": "watch a mavlink packet pattern"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncommanding line interface for module commands", "response": "def cmd_module(args):\n    '''module commands'''\n    usage = \"usage: module <list|load|reload|unload>\"\n    if len(args) < 1:\n        print(usage)\n        return\n    if args[0] == \"list\":\n        for (m,pm) in mpstate.modules:\n            print(\"%s: %s\" % (m.name, m.description))\n    elif args[0] == \"load\":\n        if len(args) < 2:\n            print(\"usage: module load <name>\")\n            return\n        (modname, kwargs) = generate_kwargs(args[1])\n        try:\n            load_module(modname, **kwargs)\n        except TypeError as ex:\n            print(ex)\n            print(\"%s module does not support keyword arguments\"% modname)\n            return\n    elif args[0] == \"reload\":\n        if len(args) < 2:\n            print(\"usage: module reload <name>\")\n            return\n        (modname, kwargs) = generate_kwargs(args[1])\n        pmodule = None\n        for (m,pm) in mpstate.modules:\n            if m.name == modname:\n                pmodule = pm\n        if pmodule is None:\n            print(\"Module %s not loaded\" % modname)\n            return\n        if unload_module(modname):\n            import zipimport\n            try:\n                reload(pmodule)\n            except ImportError:\n                clear_zipimport_cache()\n                reload(pmodule)\n            try:\n                if load_module(modname, quiet=True, **kwargs):\n                    print(\"Reloaded module %s\" % modname)\n            except TypeError:\n                print(\"%s module does not support keyword arguments\" % modname)\n    elif args[0] == \"unload\":\n        if len(args) < 2:\n            print(\"usage: module unload <name>\")\n            return\n        modname = os.path.basename(args[1])\n        unload_module(modname)\n    else:\n        print(usage)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nseeing http://stackoverflow. com/questions/6868382/python - shlex - split - ignore - single - quotes", "response": "def shlex_quotes(value):\n    '''see http://stackoverflow.com/questions/6868382/python-shlex-split-ignore-single-quotes'''\n    lex = shlex.shlex(value)\n    lex.quotes = '\"'\n    lex.whitespace_split = True\n    lex.commenters = ''\n    return list(lex)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses packets from MAVLink slaves forwarding to the master", "response": "def process_mavlink(slave):\n    '''process packets from MAVLink slaves, forwarding to the master'''\n    try:\n        buf = slave.recv()\n    except socket.error:\n        return\n    try:\n        global mavversion\n        if slave.first_byte and mavversion is None:\n            slave.auto_mavlink_version(buf)\n        msgs = slave.mav.parse_buffer(buf)\n    except mavutil.mavlink.MAVError as e:\n        mpstate.console.error(\"Bad MAVLink slave message from %s: %s\" % (slave.address, e.message))\n        return\n    if msgs is None:\n        return\n    if mpstate.settings.mavfwd and not mpstate.status.setup_mode:\n        for m in msgs:\n            mpstate.master().write(m.get_msgbuf())\n            if mpstate.status.watch:\n                for msg_type in mpstate.status.watch:\n                    if fnmatch.fnmatch(m.get_type().upper(), msg_type.upper()):\n                        mpstate.console.writeln('> '+ str(m))\n                        break\n    mpstate.status.counters['Slave'] += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns tuple of logdir telemetry_log_filepath raw_telemetry_log_filepath", "response": "def log_paths():\n    '''Returns tuple (logdir, telemetry_log_filepath, raw_telemetry_log_filepath)'''\n    if opts.aircraft is not None:\n        dirname = \"\"\n        if opts.mission is not None:\n            print(opts.mission)\n            dirname += \"%s/logs/%s/Mission%s\" % (opts.aircraft, time.strftime(\"%Y-%m-%d\"), opts.mission)\n        else:\n            dirname += \"%s/logs/%s\" % (opts.aircraft, time.strftime(\"%Y-%m-%d\"))\n        # dirname is currently relative.  Possibly add state_basedir:\n        if mpstate.settings.state_basedir is not None:\n            dirname = os.path.join(mpstate.settings.state_basedir,dirname)\n        mkdir_p(dirname)\n        highest = None\n        for i in range(1, 10000):\n            fdir = os.path.join(dirname, 'flight%u' % i)\n            if not os.path.exists(fdir):\n                break\n            highest = fdir\n        if mpstate.continue_mode and highest is not None:\n            fdir = highest\n        elif os.path.exists(fdir):\n            print(\"Flight logs full\")\n            sys.exit(1)\n        logname = 'flight.tlog'\n        logdir = fdir\n    else:\n        logname = os.path.basename(opts.logfile)\n        dir_path = os.path.dirname(opts.logfile)\n        if not os.path.isabs(dir_path) and mpstate.settings.state_basedir is not None:\n            dir_path = os.path.join(mpstate.settings.state_basedir,dir_path)\n\n        logdir = dir_path\n\n    mkdir_p(logdir)\n    return (logdir,\n            os.path.join(logdir, logname),\n            os.path.join(logdir, logname + '.raw'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nopen log files and return the current telemetry log id", "response": "def open_telemetry_logs(logpath_telem, logpath_telem_raw):\n    '''open log files'''\n    if opts.append_log or opts.continue_mode:\n        mode = 'ab'\n    else:\n        mode = 'wb'\n\n    try:\n        mpstate.logfile = open(logpath_telem, mode=mode)\n        mpstate.logfile_raw = open(logpath_telem_raw, mode=mode)\n        print(\"Log Directory: %s\" % mpstate.status.logdir)\n        print(\"Telemetry log: %s\" % logpath_telem)\n\n        #make sure there's enough free disk space for the logfile (>200Mb)\n        #statvfs doesn't work in Windows\n        if platform.system() != 'Windows':\n            stat = os.statvfs(logpath_telem)\n            if stat.f_bfree*stat.f_bsize < 209715200:\n                print(\"ERROR: Not enough free disk space for logfile\")\n                mpstate.status.exit = True\n                return\n\n        # use a separate thread for writing to the logfile to prevent\n        # delays during disk writes (important as delays can be long if camera\n        # app is running)\n        t = threading.Thread(target=log_writer, name='log_writer')\n        t.daemon = True\n        t.start()\n    except Exception as e:\n        print(\"ERROR: opening log file for writing: %s\" % e)\n        mpstate.status.exit = True\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_link_status():\n    '''check status of master links'''\n    tnow = time.time()\n    if mpstate.status.last_message != 0 and tnow > mpstate.status.last_message + 5:\n        say(\"no link\")\n        mpstate.status.heartbeat_error = True\n    for master in mpstate.mav_master:\n        if not master.linkerror and (tnow > master.last_message + 5 or master.portdead):\n            say(\"link %s down\" % (mp_module.MPModule.link_label(master)))\n            master.linkerror = True", "response": "check status of master links"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main_loop():\n    '''main processing loop'''\n\n    global screensaver_cookie\n\n    if not mpstate.status.setup_mode and not opts.nowait:\n        for master in mpstate.mav_master:\n            if master.linknum != 0:\n                break\n            print(\"Waiting for heartbeat from %s\" % master.address)\n            send_heartbeat(master)\n            master.wait_heartbeat(timeout=0.1)\n        set_stream_rates()\n\n    while True:\n        if mpstate is None or mpstate.status.exit:\n            return\n\n        # enable or disable screensaver:\n        if (mpstate.settings.inhibit_screensaver_when_armed and\n            screensaver_interface is not None):\n            if mpstate.status.armed and screensaver_cookie is None:\n                # now we can inhibit the screensaver\n                screensaver_cookie = screensaver_interface.Inhibit(\"MAVProxy\",\n                                                             \"Vehicle is armed\")\n            elif not mpstate.status.armed and screensaver_cookie is not None:\n                # we can also restore it\n                screensaver_interface.UnInhibit(screensaver_cookie)\n                screensaver_cookie = None\n\n        while not mpstate.input_queue.empty():\n            line = mpstate.input_queue.get()\n            mpstate.input_count += 1\n            cmds = line.split(';')\n            if len(cmds) == 1 and cmds[0] == \"\":\n                  mpstate.empty_input_count += 1\n            for c in cmds:\n                process_stdin(c)\n\n        for master in mpstate.mav_master:\n            if master.fd is None:\n                if master.port.inWaiting() > 0:\n                    process_master(master)\n\n        periodic_tasks()\n\n        rin = []\n        for master in mpstate.mav_master:\n            if master.fd is not None and not master.portdead:\n                rin.append(master.fd)\n        for m in mpstate.mav_outputs:\n            rin.append(m.fd)\n        for sysid in mpstate.sysid_outputs:\n            m = mpstate.sysid_outputs[sysid]\n            rin.append(m.fd)\n        if rin == []:\n            time.sleep(0.0001)\n            continue\n\n        for fd in mpstate.select_extra:\n            rin.append(fd)\n        try:\n            (rin, win, xin) = select.select(rin, [], [], mpstate.settings.select_timeout)\n        except select.error:\n            continue\n\n        if mpstate is None:\n            return\n\n        for fd in rin:\n            if mpstate is None:\n                  return\n            for master in mpstate.mav_master:\n                  if fd == master.fd:\n                        process_master(master)\n                        if mpstate is None:\n                              return\n                        continue\n            for m in mpstate.mav_outputs:\n                if fd == m.fd:\n                    process_mavlink(m)\n                    if mpstate is None:\n                          return\n                    continue\n\n            for sysid in mpstate.sysid_outputs:\n                m = mpstate.sysid_outputs[sysid]\n                if fd == m.fd:\n                    process_mavlink(m)\n                    if mpstate is None:\n                          return\n                    continue\n\n            # this allow modules to register their own file descriptors\n            # for the main select loop\n            if fd in mpstate.select_extra:\n                try:\n                    # call the registered read function\n                    (fn, args) = mpstate.select_extra[fd]\n                    fn(args)\n                except Exception as msg:\n                    if mpstate.settings.moddebug == 1:\n                        print(msg)\n                    # on an exception, remove it from the select list\n                    mpstate.select_extra.pop(fd)", "response": "main loop for the internal state of the system"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwaits for user input", "response": "def input_loop():\n    '''wait for user input'''\n    while mpstate.status.exit != True:\n        try:\n            if mpstate.status.exit != True:\n                line = input(mpstate.rl.prompt)\n        except EOFError:\n            mpstate.status.exit = True\n            sys.exit(1)\n        mpstate.input_queue.put(line)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a script file", "response": "def run_script(scriptfile):\n    '''run a script file'''\n    try:\n        f = open(scriptfile, mode='r')\n    except Exception:\n        return\n    mpstate.console.writeln(\"Running script %s\" % scriptfile)\n    sub = mp_substitute.MAVSubstitute()\n    for line in f:\n        line = line.strip()\n        if line == \"\" or line.startswith('#'):\n            continue\n        try:\n            line = sub.substitute(line, os.environ)\n        except mp_substitute.MAVSubstituteError as ex:\n            print(\"Bad variable: %s\" % str(ex))\n            if mpstate.settings.script_fatal:\n                sys.exit(1)\n            continue\n        if line.startswith('@'):\n            line = line[1:]\n        else:\n            mpstate.console.writeln(\"-> %s\" % line)\n        process_stdin(line)\n    f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_mav_version(mav10, mav20, autoProtocol, mavversionArg):\n    '''Set the Mavlink version based on commandline options'''\n#    if(mav10 == True or mav20 == True or autoProtocol == True):\n#        print(\"Warning: Using deprecated --mav10, --mav20 or --auto-protocol options. Use --mavversion instead\")\n\n    #sanity check the options\n    if (mav10 == True or mav20 == True) and autoProtocol == True:\n        print(\"Error: Can't have [--mav10, --mav20] and --auto-protocol both True\")\n        sys.exit(1)\n    if mav10 == True and mav20 == True:\n        print(\"Error: Can't have --mav10 and --mav20 both True\")\n        sys.exit(1)\n    if mavversionArg is not None and (mav10 == True or mav20 == True or autoProtocol == True):\n        print(\"Error: Can't use --mavversion with legacy (--mav10, --mav20 or --auto-protocol) options\")\n        sys.exit(1)\n\n    #and set the specific mavlink version (False = autodetect)\n    global mavversion\n    if mavversionArg == \"1.0\" or mav10 == True:\n        os.environ['MAVLINK09'] = '1'\n        mavversion = \"1\"\n    else:\n        os.environ['MAVLINK20'] = '1'\n        mavversion = \"2\"", "response": "set the Mavlink version based on commandline options"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mav_param(self):\n        '''map mav_param onto the current target system parameters'''\n        compid = self.settings.target_component\n        if compid == 0:\n            compid = 1\n        sysid = (self.settings.target_system, compid)\n        if not sysid in self.mav_param_by_sysid:\n            self.mav_param_by_sysid[sysid] = mavparm.MAVParmDict()\n        return self.mav_param_by_sysid[sysid]", "response": "map mav_param onto the current target system parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef redfearn(lat, lon, false_easting=None, false_northing=None,\n             zone=None, central_meridian=None, scale_factor=None):\n    \"\"\"Compute UTM projection using Redfearn's formula\n\n    lat, lon is latitude and longitude in decimal degrees\n\n    If false easting and northing are specified they will override\n    the standard\n\n    If zone is specified reproject lat and long to specified zone instead of\n    standard zone\n\n    If meridian is specified, reproject lat and lon to that instead of zone. In this case\n    zone will be set to -1 to indicate non-UTM projection\n\n    Note that zone and meridian cannot both be specifed\n    \"\"\"\n\n\n    from math import pi, sqrt, sin, cos, tan\n\n\n\n    #GDA Specifications\n    a = 6378137.0                       #Semi major axis\n    inverse_flattening = 298.257222101  #1/f\n    if scale_factor is None:\n        K0 = 0.9996                         #Central scale factor\n    else:\n        K0 = scale_factor\n    #print('scale', K0)\n    zone_width = 6                      #Degrees\n\n    longitude_of_central_meridian_zone0 = -183\n    longitude_of_western_edge_zone0 = -186\n\n    if false_easting is None:\n        false_easting = 500000\n\n    if false_northing is None:\n        if lat < 0:\n            false_northing = 10000000  #Southern hemisphere\n        else:\n            false_northing = 0         #Northern hemisphere)\n\n\n    #Derived constants\n    f = 1.0/inverse_flattening\n    b = a*(1-f)       #Semi minor axis\n\n    e2 = 2*f - f*f#    = f*(2-f) = (a^2-b^2/a^2   #Eccentricity\n    e = sqrt(e2)\n    e2_ = e2/(1-e2)   # = (a^2-b^2)/b^2 #Second eccentricity\n    e_ = sqrt(e2_)\n    e4 = e2*e2\n    e6 = e2*e4\n\n    #Foot point latitude\n    n = (a-b)/(a+b) #Same as e2 - why ?\n    n2 = n*n\n    n3 = n*n2\n    n4 = n2*n2\n\n    G = a*(1-n)*(1-n2)*(1+9*n2/4+225*n4/64)*pi/180\n\n\n    phi = lat*pi/180     #Convert latitude to radians\n\n    sinphi = sin(phi)\n    sin2phi = sin(2*phi)\n    sin4phi = sin(4*phi)\n    sin6phi = sin(6*phi)\n\n    cosphi = cos(phi)\n    cosphi2 = cosphi*cosphi\n    cosphi3 = cosphi*cosphi2\n    cosphi4 = cosphi2*cosphi2\n    cosphi5 = cosphi*cosphi4\n    cosphi6 = cosphi2*cosphi4\n    cosphi7 = cosphi*cosphi6\n    cosphi8 = cosphi4*cosphi4\n\n    t = tan(phi)\n    t2 = t*t\n    t4 = t2*t2\n    t6 = t2*t4\n\n    #Radius of Curvature\n    rho = a*(1-e2)/(1-e2*sinphi*sinphi)**1.5\n    nu = a/(1-e2*sinphi*sinphi)**0.5\n    psi = nu/rho\n    psi2 = psi*psi\n    psi3 = psi*psi2\n    psi4 = psi2*psi2\n\n\n\n    #Meridian distance\n\n    A0 = 1 - e2/4 - 3*e4/64 - 5*e6/256\n    A2 = 3.0/8*(e2+e4/4+15*e6/128)\n    A4 = 15.0/256*(e4+3*e6/4)\n    A6 = 35*e6/3072\n\n    term1 = a*A0*phi\n    term2 = -a*A2*sin2phi\n    term3 = a*A4*sin4phi\n    term4 = -a*A6*sin6phi\n\n    m = term1 + term2 + term3 + term4 #OK\n\n    if zone is not None and central_meridian is not None:\n        msg = 'You specified both zone and central_meridian. Provide only one of them'\n        raise ValueError(msg)\n\n    # Zone\n    if zone is None:\n        zone = int((lon - longitude_of_western_edge_zone0)/zone_width)\n\n    # Central meridian\n    if central_meridian is None:\n        central_meridian = zone*zone_width+longitude_of_central_meridian_zone0\n    else:\n        zone = -1\n\n    omega = (lon-central_meridian)*pi/180 #Relative longitude (radians)\n    omega2 = omega*omega\n    omega3 = omega*omega2\n    omega4 = omega2*omega2\n    omega5 = omega*omega4\n    omega6 = omega3*omega3\n    omega7 = omega*omega6\n    omega8 = omega4*omega4\n\n    #Northing\n    term1 = nu*sinphi*cosphi*omega2/2\n    term2 = nu*sinphi*cosphi3*(4*psi2+psi-t2)*omega4/24\n    term3 = nu*sinphi*cosphi5*\\\n            (8*psi4*(11-24*t2)-28*psi3*(1-6*t2)+\\\n             psi2*(1-32*t2)-psi*2*t2+t4-t2)*omega6/720\n    term4 = nu*sinphi*cosphi7*(1385-3111*t2+543*t4-t6)*omega8/40320\n    northing = false_northing + K0*(m + term1 + term2 + term3 + term4)\n\n    #Easting\n    term1 = nu*omega*cosphi\n    term2 = nu*cosphi3*(psi-t2)*omega3/6\n    term3 = nu*cosphi5*(4*psi3*(1-6*t2)+psi2*(1+8*t2)-2*psi*t2+t4)*omega5/120\n    term4 = nu*cosphi7*(61-479*t2+179*t4-t6)*omega7/5040\n    easting = false_easting + K0*(term1 + term2 + term3 + term4)\n\n    return zone, easting, northing", "response": "Compute UTM projection using Redfearn s formula."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef LLtoUTM( Lat, Long, ReferenceEllipsoid=23):\r\n    a = _ellipsoid[ReferenceEllipsoid][_EquatorialRadius]\r\n    eccSquared = _ellipsoid[ReferenceEllipsoid][_eccentricitySquared]\r\n    k0 = 0.9996\r\n\r\n#Make sure the longitude is between -180.00 .. 179.9\r\n    LongTemp = (Long+180)-int((Long+180)/360)*360-180 # -180.00 .. 179.9\r\n\r\n    LatRad = Lat*_deg2rad\r\n    LongRad = LongTemp*_deg2rad\r\n\r\n    ZoneNumber = int((LongTemp + 180)/6) + 1\r\n\r\n    if Lat >= 56.0 and Lat < 64.0 and LongTemp >= 3.0 and LongTemp < 12.0:\r\n        ZoneNumber = 32\r\n\r\n    # Special zones for Svalbard\r\n    if Lat >= 72.0 and Lat < 84.0:\r\n        if  LongTemp >= 0.0  and LongTemp <  9.0:ZoneNumber = 31\r\n        elif LongTemp >= 9.0  and LongTemp < 21.0: ZoneNumber = 33\r\n        elif LongTemp >= 21.0 and LongTemp < 33.0: ZoneNumber = 35\r\n        elif LongTemp >= 33.0 and LongTemp < 42.0: ZoneNumber = 37\r\n\r\n    LongOrigin = (ZoneNumber - 1)*6 - 180 + 3 #+3 puts origin in middle of zone\r\n    LongOriginRad = LongOrigin * _deg2rad\r\n\r\n    #compute the UTM Zone from the latitude and longitude\r\n    UTMZone = \"%d%c\" % (ZoneNumber, _UTMLetterDesignator(Lat))\r\n\r\n    eccPrimeSquared = (eccSquared)/(1-eccSquared)\r\n    N = a/sqrt(1-eccSquared*sin(LatRad)*sin(LatRad))\r\n    T = tan(LatRad)*tan(LatRad)\r\n    C = eccPrimeSquared*cos(LatRad)*cos(LatRad)\r\n    A = cos(LatRad)*(LongRad-LongOriginRad)\r\n\r\n    M = a*((1\r\n            - eccSquared/4\r\n            - 3*eccSquared*eccSquared/64\r\n            - 5*eccSquared*eccSquared*eccSquared/256)*LatRad\r\n           - (3*eccSquared/8\r\n              + 3*eccSquared*eccSquared/32\r\n              + 45*eccSquared*eccSquared*eccSquared/1024)*sin(2*LatRad)\r\n           + (15*eccSquared*eccSquared/256 + 45*eccSquared*eccSquared*eccSquared/1024)*sin(4*LatRad)\r\n           - (35*eccSquared*eccSquared*eccSquared/3072)*sin(6*LatRad))\r\n\r\n    UTMEasting = (k0*N*(A+(1-T+C)*A*A*A/6\r\n                        + (5-18*T+T*T+72*C-58*eccPrimeSquared)*A*A*A*A*A/120)\r\n                  + 500000.0)\r\n\r\n    UTMNorthing = (k0*(M+N*tan(LatRad)*(A*A/2+(5-T+9*C+4*C*C)*A*A*A*A/24\r\n                                        + (61\r\n                                           -58*T\r\n                                           +T*T\r\n                                           +600*C\r\n                                           -330*eccPrimeSquared)*A*A*A*A*A*A/720)))\r\n\r\n    if Lat < 0:\r\n        UTMNorthing = UTMNorthing + 10000000.0; #10000000 meter offset for southern hemisphere\r\n    #UTMZone was originally returned here.  I don't know what the\r\n    #letter at the end was for.\r\n    #print(\"UTMZone\", UTMZone)\r\n    return (ZoneNumber, UTMEasting, UTMNorthing)", "response": "Returns a new ISO 8601 date string from the given latitude and long."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a WinLayout for a wx window", "response": "def get_wx_window_layout(wx_window):\n    '''get a WinLayout for a wx window'''\n    dsize = wx.DisplaySize()\n    pos = wx_window.GetPosition()\n    size = wx_window.GetSize()\n    name = wx_window.GetTitle()\n    return WinLayout(name, pos, size, dsize)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_wx_window_layout(wx_window, layout):\n    '''set a WinLayout for a wx window'''\n    try:\n        wx_window.SetSize(layout.size)\n        wx_window.SetPosition(layout.pos)\n    except Exception as ex:\n        print(ex)", "response": "set a WinLayout for a wx window"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef layout_filename(fallback):\n    '''get location of layout file'''\n    global display_size\n    global vehiclename\n    (dw,dh) = display_size\n    if 'HOME' in os.environ:\n        dirname = os.path.join(os.environ['HOME'], \".mavproxy\")\n        if not os.path.exists(dirname):\n            try:\n                os.mkdir(dirname)\n            except Exception:\n                pass\n    elif 'LOCALAPPDATA' in os.environ:\n        dirname = os.path.join(os.environ['LOCALAPPDATA'], \"MAVProxy\")\n    else:\n        return None\n    if vehiclename:\n        fname = os.path.join(dirname, \"layout-%s-%ux%u\" % (vehiclename,dw,dh))\n        if not fallback or os.path.exists(fname):\n            return fname\n    return os.path.join(dirname, \"layout-%ux%u\" % (dw,dh))", "response": "get location of layout file"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_layout(vehname):\n    '''save window layout'''\n    global display_size\n    global window_list\n    global vehiclename\n    if display_size is None:\n        print(\"No layouts to save\")\n        return\n    vehiclename = vehname\n    fname = layout_filename(False)\n    if fname is None:\n        print(\"No file to save layout to\")\n        return\n    layout = {}\n    try:\n        # include previous layout, so we retain layouts for widows not\n        # currently displayed\n        layout = pickle.load(open(fname,\"rb\"))\n    except Exception:\n        pass\n    count = 0\n    for name in window_list:\n        layout[name] = window_list[name].layout\n        count += 1\n    pickle.dump(layout, open(fname,\"wb\"))\n    print(\"Saved layout for %u windows\" % count)", "response": "save window layout to file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef on_save(self, event):\n        '''called on save button'''\n        dlg = wx.FileDialog(None, self.settings.get_title(), '', \"\", '*.*',\n                            wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)\n        if dlg.ShowModal() == wx.ID_OK:\n            self.settings.save(dlg.GetPath())", "response": "called on save button"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef on_load(self, event):\n        '''called on load button'''\n        dlg = wx.FileDialog(None, self.settings.get_title(), '', \"\", '*.*', wx.FD_OPEN)\n        if dlg.ShowModal() == wx.ID_OK:\n            self.settings.load(dlg.GetPath())\n        # update the controls with new values\n        for label in self.setting_map.keys():\n            setting = self.setting_map[label]\n            ctrl = self.controls[label]\n            value = ctrl.GetValue()\n            if isinstance(value, str) or isinstance(value, unicode):\n                ctrl.SetValue(str(setting.value))\n            else:\n                ctrl.SetValue(setting.value)", "response": "called on load button"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a text input line", "response": "def add_text(self, setting, width=300, height=100, multiline=False):\n        '''add a text input line'''\n        tab = self.panel(setting.tab)\n        if multiline:\n            ctrl = wx.TextCtrl(tab, -1, \"\", size=(width,height), style=wx.TE_MULTILINE|wx.TE_PROCESS_ENTER)\n        else:\n            ctrl = wx.TextCtrl(tab, -1, \"\", size=(width,-1) )\n        self._add_input(setting, ctrl)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_choice(self, setting, choices):\n        '''add a choice input line'''\n        tab = self.panel(setting.tab)\n        default = setting.value\n        if default is None:\n            default = choices[0]\n        ctrl = wx.ComboBox(tab, -1, choices=choices,\n                           value = str(default),\n                           style = wx.CB_DROPDOWN | wx.CB_READONLY | wx.CB_SORT )\n        self._add_input(setting, ctrl)", "response": "add a choice input line"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_intspin(self, setting):\n        '''add a spin control'''\n        tab = self.panel(setting.tab)\n        default = setting.value\n        (minv, maxv) = setting.range\n        ctrl = wx.SpinCtrl(tab, -1,\n                           initial = default,\n                           min = minv,\n                           max = maxv)\n        self._add_input(setting, ctrl, value=default)", "response": "add a spin control"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a floating point spin control", "response": "def add_floatspin(self, setting):\n        '''add a floating point spin control'''\n        from wx.lib.agw.floatspin import FloatSpin\n\n        tab = self.panel(setting.tab)\n        default = setting.value\n        (minv, maxv) = setting.range\n        ctrl = FloatSpin(tab, -1,\n                         value = default,\n                         min_val = minv,\n                         max_val = maxv,\n                         increment = setting.increment)\n        if setting.format is not None:\n            ctrl.SetFormat(setting.format)\n        if setting.digits is not None:\n            ctrl.SetDigits(setting.digits)\n        self._add_input(setting, ctrl, value=default)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles an incoming mavlink packet", "response": "def process_mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        mtype = m.get_type()\n\n        # if you add processing for an mtype here, remember to add it\n        # to mavlink_packet, above\n        if mtype in ['WAYPOINT_COUNT','MISSION_COUNT']:\n            if (self.num_wps_expected == 0):\n                #I haven't asked for WPs, or these messages are duplicates\n                #of msgs I've already received.\n                self.console.error(\"No waypoint load started (from Editor).\")\n            #I only clear the mission in the Editor if this was a read event\n            elif (self.num_wps_expected == -1):\n                self.gui_event_queue.put(MissionEditorEvent(\n                    me_event.MEGE_CLEAR_MISS_TABLE))\n                self.num_wps_expected = m.count\n                self.wps_received = {}\n\n                if (m.count > 0):\n                    self.gui_event_queue.put(MissionEditorEvent(\n                        me_event.MEGE_ADD_MISS_TABLE_ROWS,num_rows=m.count-1))\n            #write has been sent by the mission editor:\n            elif (self.num_wps_expected > 1):\n                if (m.count != self.num_wps_expected):\n                    self.console.error(\"Unepxected waypoint count from APM after write (Editor)\")\n                #since this is a write operation from the Editor there\n                #should be no need to update number of table rows\n\n        elif mtype in ['WAYPOINT', 'MISSION_ITEM']:\n            #still expecting wps?\n            if (len(self.wps_received) < self.num_wps_expected):\n                #if we haven't already received this wp, write it to the GUI:\n                if (m.seq not in self.wps_received.keys()):\n                    self.gui_event_queue.put(MissionEditorEvent(\n                        me_event.MEGE_SET_MISS_ITEM,\n                        num=m.seq,command=m.command,param1=m.param1,\n                        param2=m.param2,param3=m.param3,param4=m.param4,\n                        lat=m.x,lon=m.y,alt=m.z,frame=m.frame))\n\n                    self.wps_received[m.seq] = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef child_task(self, q, l, gq, gl, cw_sem):\n        '''child process - this holds GUI elements'''\n        mp_util.child_close_fds()\n\n        from MAVProxy.modules.lib import wx_processguard\n        from ..lib.wx_loader import wx\n        from MAVProxy.modules.mavproxy_misseditor import missionEditorFrame\n\n        self.app = wx.App(False)\n        self.app.frame = missionEditorFrame.MissionEditorFrame(parent=None,id=wx.ID_ANY)\n\n        self.app.frame.set_event_queue(q)\n        self.app.frame.set_event_queue_lock(l)\n        self.app.frame.set_gui_event_queue(gq)\n        self.app.frame.set_gui_event_queue_lock(gl)\n        self.app.frame.set_close_window_semaphore(cw_sem)\n\n        self.app.SetExitOnFrameDelete(True)\n        self.app.frame.Show()\n\n        # start a thread to monitor the \"close window\" semaphore:\n        class CloseWindowSemaphoreWatcher(threading.Thread):\n            def __init__(self, task, sem):\n                threading.Thread.__init__(self)\n                self.task = task\n                self.sem = sem\n            def run(self):\n                self.sem.acquire(True)\n                self.task.app.ExitMainLoop()\n        watcher_thread = CloseWindowSemaphoreWatcher(self, cw_sem)\n        watcher_thread.start()\n\n        self.app.MainLoop()\n        # tell the watcher it is OK to quit:\n        cw_sem.release()\n        watcher_thread.join()", "response": "child task - this holds GUI elements"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef close(self):\n        '''close the Mission Editor window'''\n        self.time_to_quit = True\n        self.close_window.release()\n        if self.child.is_alive():\n            self.child.join(1)\n\n        self.child.terminate()\n\n        self.mavlink_message_queue_handler.join()\n\n        self.event_queue_lock.acquire()\n        self.event_queue.put(MissionEditorEvent(me_event.MEE_TIME_TO_QUIT));\n        self.event_queue_lock.release()", "response": "close the Mission Editor window"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new figure manager instance.", "response": "def new_figure_manager(num, *args, **kwargs):\n    \"\"\"\n    Create a new figure manager instance\n    \"\"\"\n    if __debug__: verbose.report('backend_agg.new_figure_manager',\n                                 'debug-annoying')\n\n\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    thisFig = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, thisFig)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef new_figure_manager_given_figure(num, figure):\n    canvas = FigureCanvasAgg(figure)\n    manager = FigureManagerBase(canvas, num)\n    return manager", "response": "Create a new figure manager instance for the given figure."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef draw_path(self, gc, path, transform, rgbFace=None):\n        nmax = rcParams['agg.path.chunksize'] # here at least for testing\n        npts = path.vertices.shape[0]\n        if (nmax > 100 and npts > nmax and path.should_simplify and\n            rgbFace is None and gc.get_hatch() is None):\n            nch = np.ceil(npts/float(nmax))\n            chsize = int(np.ceil(npts/nch))\n            i0 = np.arange(0, npts, chsize)\n            i1 = np.zeros_like(i0)\n            i1[:-1] = i0[1:] - 1\n            i1[-1] = npts\n            for ii0, ii1 in zip(i0, i1):\n                v = path.vertices[ii0:ii1,:]\n                c = path.codes\n                if c is not None:\n                    c = c[ii0:ii1]\n                    c[0] = Path.MOVETO # move to end of last chunk\n                p = Path(v, c)\n                self._renderer.draw_path(gc, p, transform, rgbFace)\n        else:\n            self._renderer.draw_path(gc, path, transform, rgbFace)", "response": "Draw the path based on the current color."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef draw_mathtext(self, gc, x, y, s, prop, angle):\n        if __debug__: verbose.report('RendererAgg.draw_mathtext',\n                                     'debug-annoying')\n        ox, oy, width, height, descent, font_image, used_characters = \\\n            self.mathtext_parser.parse(s, self.dpi, prop)\n\n        xd = descent * np.sin(np.deg2rad(angle))\n        yd = descent * np.cos(np.deg2rad(angle))\n        x = np.round(x + ox + xd)\n        y = np.round(y - oy + yd)\n        self._renderer.draw_text_image(font_image, x, y + 1, angle, gc)", "response": "Draw the math text using matplotlib. mathtext."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        if __debug__: verbose.report('RendererAgg.draw_text', 'debug-annoying')\n\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        flags = get_hinting_flag()\n        font = self._get_agg_font(prop)\n        if font is None: return None\n        if len(s) == 1 and ord(s) > 127:\n            font.load_char(ord(s), flags=flags)\n        else:\n            # We pass '0' for angle here, since it will be rotated (in raster\n            # space) in the following call to draw_text_image).\n            font.set_text(s, 0, flags=flags)\n        font.draw_glyphs_to_bitmap(antialiased=rcParams['text.antialiased'])\n        d = font.get_descent() / 64.0\n        # The descent needs to be adjusted for the angle\n        xd = -d * np.sin(np.deg2rad(angle))\n        yd = d * np.cos(np.deg2rad(angle))\n\n        #print x, y, int(x), int(y), s\n        self._renderer.draw_text_image(\n            font.get_image(), np.round(x - xd), np.round(y + yd) + 1, angle, gc)", "response": "Render the text for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_text_width_height_descent(self, s, prop, ismath):\n        if rcParams['text.usetex']:\n            # todo: handle props\n            size = prop.get_size_in_points()\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(s, fontsize,\n                                                               renderer=self)\n            return w, h, d\n\n        if ismath:\n            ox, oy, width, height, descent, fonts, used_characters = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        flags = get_hinting_flag()\n        font = self._get_agg_font(prop)\n        font.set_text(s, 0.0, flags=flags)  # the width and height of unrotated string\n        w, h = font.get_width_height()\n        d = font.get_descent()\n        w /= 64.0  # convert from subpixels\n        h /= 64.0\n        d /= 64.0\n        return w, h, d", "response": "get the width and height of the string s with FontPropertry prop"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the font for text instance t cacheing for efficiency", "response": "def _get_agg_font(self, prop):\n        \"\"\"\n        Get the font for text instance t, cacheing for efficiency\n        \"\"\"\n        if __debug__: verbose.report('RendererAgg._get_agg_font',\n                                     'debug-annoying')\n\n        key = hash(prop)\n        font = RendererAgg._fontd.get(key)\n\n        if font is None:\n            fname = findfont(prop)\n            font = RendererAgg._fontd.get(fname)\n            if font is None:\n                font = FT2Font(\n                    str(fname),\n                    hinting_factor=rcParams['text.hinting_factor'])\n                RendererAgg._fontd[fname] = font\n            RendererAgg._fontd[key] = font\n\n        font.clear()\n        size = prop.get_size_in_points()\n        font.set_size(size, self.dpi)\n\n        return font"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef restore_region(self, region, bbox=None, xy=None):\n        if bbox is not None or xy is not None:\n            if bbox is None:\n                x1, y1, x2, y2 = region.get_extents()\n            elif isinstance(bbox, BboxBase):\n                x1, y1, x2, y2 = bbox.extents\n            else:\n                x1, y1, x2, y2 = bbox\n\n            if xy is None:\n                ox, oy = x1, y1\n            else:\n                ox, oy = xy\n\n            self._renderer.restore_region2(region, x1, y1, x2, y2, ox, oy)\n\n        else:\n            self._renderer.restore_region(region)", "response": "Restore the saved region. If bbox (instance of BboxBase, or\n        its extents) is given, only the region specified by the bbox\n        will be restored. *xy* (a tuple of two floasts) optionally\n        specifies the new position (the LLC of the original region,\n        not the LLC of the bbox) where the region will be restored.\n\n        >>> region = renderer.copy_from_bbox()\n        >>> x1, y1, x2, y2 = region.get_extents()\n        >>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n        ...                         xy=(x1-dx, y1))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start_filter(self):\n        self._filter_renderers.append(self._renderer)\n        self._renderer = _RendererAgg(int(self.width), int(self.height),\n                                      self.dpi)\n        self._update_methods()", "response": "Start filtering the image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstop the filter for the current image and apply the post processing function to the image.", "response": "def stop_filter(self, post_processing):\n        \"\"\"\n        Save the plot in the current canvas as a image and apply\n        the *post_processing* function.\n\n           def post_processing(image, dpi):\n             # ny, nx, depth = image.shape\n             # image (numpy array) has RGBA channels and has a depth of 4.\n             ...\n             # create a new_image (numpy array of 4 channels, size can be\n             # different). The resulting image may have offsets from\n             # lower-left corner of the original image\n             return new_image, offset_x, offset_y\n\n        The saved renderer is restored and the returned image from\n        post_processing is plotted (using draw_image) on it.\n        \"\"\"\n\n        # WARNING.\n        # For agg_filter to work, the rendere's method need\n        # to overridden in the class. See draw_markers, and draw_path_collections\n\n        from matplotlib._image import fromarray\n\n        width, height = int(self.width), int(self.height)\n\n        buffer, bounds = self._renderer.tostring_rgba_minimized()\n\n        l, b, w, h = bounds\n\n\n        self._renderer = self._filter_renderers.pop()\n        self._update_methods()\n\n        if w > 0 and h > 0:\n            img = np.fromstring(buffer, np.uint8)\n            img, ox, oy = post_processing(img.reshape((h, w, 4)) / 255.,\n                                          self.dpi)\n            image = fromarray(img, 1)\n            image.flipud_out()\n\n            gc = self.new_gc()\n            self._renderer.draw_image(gc,\n                                      l+ox, height - b - h +oy,\n                                      image)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndrawing the figure using the renderer", "response": "def draw(self):\n        \"\"\"\n        Draw the figure using the renderer\n        \"\"\"\n        if __debug__: verbose.report('FigureCanvasAgg.draw', 'debug-annoying')\n\n        self.renderer = self.get_renderer(cleared=True)\n        # acquire a lock on the shared font cache\n        RendererAgg.lock.acquire()\n\n        try:\n            self.figure.draw(self.renderer)\n        finally:\n            RendererAgg.lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a status value", "response": "def set_check(self, name, state):\n        '''set a status value'''\n        if self.child.is_alive():\n            self.parent_pipe.send(CheckItem(name, state))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef createLists(self):\n        '''Generate the checklists. Note that:\n        0,1 = off/on for auto-ticked items\n        2,3 = off/on for manually ticked items'''\n\n        self.beforeAssemblyList = {\n        'Confirm batteries charged':2,\n        'No physical damage to airframe':2,\n        'All electronics present and connected':2,\n        'Bottle loaded':2,\n        'Ground station operational':2\n        }\n\n        self.beforeEngineList = {\n        'Avionics Power ON':2,\n        'Pixhawk Booted':0,\n        'Odroid Booted':2,\n        'Cameras calibrated and capturing':2,\n        'GPS lock':0,\n        'Airspeed check':2,\n        'Barometer check':2,\n        'Compass check':2,\n        'Flight mode MANUAL':0,\n        'Avionics Power':0,\n        'Servo Power':0,\n        'IMU Check':0,\n        'Aircraft Params Loaded':2,\n        'Waypoints Loaded':0,\n        'Servo and clevis check':2,\n        'Geofence loaded':2,\n        'Ignition circuit and battery check':2,\n        'Check stabilisation in FBWA mode':2\n        }\n\n        self.beforeTakeoffList = {\n        'Engine throttle responsive':2,\n        'Runway clear':2,\n        'Radio links > 6db margin':0,\n        'Antenna tracker check':2,\n        'GCS stable':2,\n        }\n\n        self.beforeCruiseList = {\n        'Airspeed > 10 m/s':0,\n        'Altitude > 30 m':0,\n        '< 100 degrees to 1st Waypoint':2,\n        'Airspeed and climb rate nominal':2\n        }\n\n        self.bottleDropList = {\n        'Joe found':2,\n        'Joe waypoint laid in':2,\n        '< 100m to Joe waypoint':2,\n        'Bottle drop mechanism activated':2\n        }\n\n        self.beforeLandingList = {\n        'Runway clear':2,\n        'APM set to FBWA mode':2,\n        '< 100m from airfield home':2\n        }\n\n        self.beforeShutdownList = {\n        'Taxi to parking':2,\n        'Engine cutoff':2,\n        'Data downloaded':2,\n        'Ignition power off':2,\n        'Avionics power off':2\n        }", "response": "Generate the checklists. Note that:\n        0,1 = off/on for auto-ticked items\n        2,3 = off/on for manually ticked items"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef createWidgets(self):\n        #create the panels for the tabs\n        PanelAssembly = wx.Panel(self.nb)\n        boxAssembly = wx.BoxSizer(wx.VERTICAL)\n        PanelAssembly.SetAutoLayout(True)\n        PanelAssembly.SetSizer(boxAssembly)\n        PanelAssembly.Layout()\n\n        PanelEngine = wx.Panel(self.nb)\n        boxEngine = wx.BoxSizer(wx.VERTICAL)\n        PanelEngine.SetAutoLayout(True)\n        PanelEngine.SetSizer(boxEngine)\n        PanelEngine.Layout()\n\n        PanelTakeoff = wx.Panel(self.nb)\n        boxTakeoff = wx.BoxSizer(wx.VERTICAL)\n        PanelTakeoff.SetAutoLayout(True)\n        PanelTakeoff.SetSizer(boxTakeoff)\n        PanelTakeoff.Layout()\n\n        PanelCruise = wx.Panel(self.nb)\n        boxCruise = wx.BoxSizer(wx.VERTICAL)\n        PanelCruise.SetAutoLayout(True)\n        PanelCruise.SetSizer(boxCruise)\n        PanelCruise.Layout()\n\n        PanelDrop = wx.Panel(self.nb)\n        boxDrop = wx.BoxSizer(wx.VERTICAL)\n        PanelDrop.SetAutoLayout(True)\n        PanelDrop.SetSizer(boxDrop)\n        PanelDrop.Layout()\n\n        PanelLanding = wx.Panel(self.nb)\n        boxLanding = wx.BoxSizer(wx.VERTICAL)\n        PanelLanding.SetAutoLayout(True)\n        PanelLanding.SetSizer(boxLanding)\n        PanelLanding.Layout()\n\n        PanelShutdown = wx.Panel(self.nb)\n        boxShutdown = wx.BoxSizer(wx.VERTICAL)\n        PanelShutdown.SetAutoLayout(True)\n        PanelShutdown.SetSizer(boxShutdown)\n        PanelShutdown.Layout()\n\n        #add the data to the individual tabs\n\n        '''before assembly checklist'''\n        for key in self.beforeAssemblyList:\n            if self.beforeAssemblyList[key] == 0:\n                disCheckBox = wx.CheckBox(PanelAssembly, wx.ID_ANY, key)\n                disCheckBox.Enable(False)\n                boxAssembly.Add(disCheckBox)\n            if self.beforeAssemblyList[key] == 2:\n                boxAssembly.Add(wx.CheckBox(PanelAssembly, wx.ID_ANY, key))\n\n        self.AssemblyButton = wx.Button(PanelAssembly, wx.ID_ANY, \"Close final hatches\")\n        boxAssembly.Add(self.AssemblyButton)\n\n        '''before Engine Start checklist'''\n        for key in self.beforeEngineList:\n            if self.beforeEngineList[key] == 0:\n                disCheckBox = wx.CheckBox(PanelEngine, wx.ID_ANY, key)\n                disCheckBox.Enable(False)\n                boxEngine.Add(disCheckBox)\n            if self.beforeEngineList[key] == 2:\n                boxEngine.Add(wx.CheckBox(PanelEngine, wx.ID_ANY, key))\n\n        self.EngineButton = wx.Button(PanelEngine, wx.ID_ANY, \"Ready for Engine start\")\n        boxEngine.Add(self.EngineButton)\n\n        '''before takeoff checklist'''\n        for key in self.beforeTakeoffList:\n            if self.beforeTakeoffList[key] == 0:\n                disCheckBox = wx.CheckBox(PanelTakeoff, wx.ID_ANY, key)\n                disCheckBox.Enable(False)\n                boxTakeoff.Add(disCheckBox)\n            if self.beforeTakeoffList[key] == 2:\n                boxTakeoff.Add(wx.CheckBox(PanelTakeoff, wx.ID_ANY, key))\n\n        self.TakeoffButton = wx.Button(PanelTakeoff, wx.ID_ANY, \"Ready for Takeoff\")\n        boxTakeoff.Add(self.TakeoffButton)\n\n        '''before cruise/AUTO checklist'''\n        for key in self.beforeCruiseList:\n            if self.beforeCruiseList[key] == 0:\n                disCheckBox = wx.CheckBox(PanelCruise, wx.ID_ANY, key)\n                disCheckBox.Enable(False)\n                boxCruise.Add(disCheckBox)\n            if self.beforeCruiseList[key] == 2:\n                boxCruise.Add(wx.CheckBox(PanelCruise, wx.ID_ANY, key))\n\n        self.CruiseButton = wx.Button(PanelCruise, wx.ID_ANY, \"Ready for Cruise/AUTO\")\n        boxCruise.Add(self.CruiseButton)\n\n        '''before bottle drop checklist'''\n        for key in self.bottleDropList:\n            if self.bottleDropList[key] == 0:\n                disCheckBox = wx.CheckBox(PanelDrop, wx.ID_ANY, key)\n                disCheckBox.Enable(False)\n                boxDrop.Add(disCheckBox)\n            if self.bottleDropList[key] == 2:\n                boxDrop.Add(wx.CheckBox(PanelDrop, wx.ID_ANY, key))\n\n        self.DropButton = wx.Button(PanelDrop, wx.ID_ANY, \"Ready for Bottle Drop\")\n        boxDrop.Add(self.DropButton)\n\n        '''before landing checklist'''\n        for key in self.beforeLandingList:\n            if self.beforeLandingList[key] == 0:\n                disCheckBox = wx.CheckBox(PanelLanding, wx.ID_ANY, key)\n                disCheckBox.Enable(False)\n                boxLanding.Add(disCheckBox)\n            if self.beforeLandingList[key] == 2:\n                boxLanding.Add(wx.CheckBox(PanelLanding, wx.ID_ANY, key))\n\n        self.LandingButton = wx.Button(PanelLanding, wx.ID_ANY, \"Ready for Landing\")\n        boxLanding.Add(self.LandingButton)\n\n        '''before shutdown checklist'''\n        for key in self.beforeShutdownList:\n            if self.beforeShutdownList[key] == 0:\n                disCheckBox = wx.CheckBox(PanelShutdown, wx.ID_ANY, key)\n                disCheckBox.Enable(False)\n                boxShutdown.Add(disCheckBox)\n            if self.beforeShutdownList[key] == 2:\n                boxShutdown.Add(wx.CheckBox(PanelShutdown, wx.ID_ANY, key))\n\n        self.ShutdownButton = wx.Button(PanelShutdown, wx.ID_ANY, \"Ready for Shutdown\")\n        boxShutdown.Add(self.ShutdownButton)\n\n        #and add in the tabs\n        self.nb.AddPage(PanelAssembly, \"1. During Assembly\")\n        self.nb.AddPage(PanelEngine, \"2. Before Engine Start\")\n        self.nb.AddPage(PanelTakeoff, \"3. Before Takeoff\")\n        self.nb.AddPage(PanelCruise, \"4. Before Cruise/AUTO\")\n        self.nb.AddPage(PanelDrop, \"5. Before Bottle Drop\")\n        self.nb.AddPage(PanelLanding, \"6. Before Landing\")\n        self.nb.AddPage(PanelShutdown, \"7. Before Shutdown\")", "response": "create the panels for the tabs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vehicle_type_string(self, hb):\n        '''return vehicle type string from a heartbeat'''\n        if hb.type == mavutil.mavlink.MAV_TYPE_FIXED_WING:\n            return 'Plane'\n        if hb.type == mavutil.mavlink.MAV_TYPE_GROUND_ROVER:\n            return 'Rover'\n        if hb.type == mavutil.mavlink.MAV_TYPE_SURFACE_BOAT:\n            return 'Boat'\n        if hb.type == mavutil.mavlink.MAV_TYPE_SUBMARINE:\n            return 'Sub'\n        if hb.type in [mavutil.mavlink.MAV_TYPE_QUADROTOR,\n                           mavutil.mavlink.MAV_TYPE_COAXIAL,\n                           mavutil.mavlink.MAV_TYPE_HEXAROTOR,\n                           mavutil.mavlink.MAV_TYPE_OCTOROTOR,\n                           mavutil.mavlink.MAV_TYPE_TRICOPTER,\n                           mavutil.mavlink.MAV_TYPE_DODECAROTOR]:\n            return \"Copter\"\n        if hb.type == mavutil.mavlink.MAV_TYPE_HELICOPTER:\n            return \"Heli\"\n        if hb.type == mavutil.mavlink.MAV_TYPE_ANTENNA_TRACKER:\n            return \"Tracker\"\n        return \"UNKNOWN(%u)\" % hb.type", "response": "return vehicle type string from a heartbeat"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating menu for new vehicles", "response": "def update_vehicle_menu(self):\n        '''update menu for new vehicles'''\n        self.vehicle_menu.items = []\n        for s in sorted(self.vehicle_list):\n            clist = self.module('param').get_component_id_list(s)\n            if len(clist) == 1:\n                name = 'SysID %u: %s' % (s, self.vehicle_name_by_sysid[s])\n                self.vehicle_menu.items.append(MPMenuItem(name, name, '# vehicle %u' % s))\n            else:\n                for c in sorted(clist):\n                    try:\n                        name = 'SysID %u[%u]: %s' % (s, c, self.component_name[s][c])\n                    except KeyError as e:\n                        name = 'SysID %u[%u]: ?' % (s,c)\n                    self.vehicle_menu.items.append(MPMenuItem(name, name, '# vehicle %u:%u' % (s,c)))\n        self.mpstate.console.set_menu(self.menu, self.menu_callback)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_new_vehicle(self, hb):\n        '''add a new vehicle'''\n        if hb.type == mavutil.mavlink.MAV_TYPE_GCS:\n            return\n        sysid = hb.get_srcSystem()\n        self.vehicle_list.append(sysid)\n        self.vehicle_name_by_sysid[sysid] = self.vehicle_type_string(hb)\n        self.update_vehicle_menu()", "response": "add a new vehicle"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling an incoming mavlink packet", "response": "def mavlink_packet(self, msg):\n        '''handle an incoming mavlink packet'''\n        if not isinstance(self.console, wxconsole.MessageConsole):\n            return\n        if not self.console.is_alive():\n            self.mpstate.console = textconsole.SimpleConsole()\n            return\n        type = msg.get_type()\n\n        if type == 'HEARTBEAT':\n            sysid = msg.get_srcSystem()\n            if not sysid in self.vehicle_list:\n                self.add_new_vehicle(msg)\n            if sysid not in self.component_name:\n                self.component_name[sysid] = {}\n            compid = msg.get_srcComponent()\n            if compid not in self.component_name[sysid]:\n                self.component_name[sysid][compid] = self.component_type_string(msg)\n                self.update_vehicle_menu()\n\n        if self.last_param_sysid_timestamp != self.module('param').new_sysid_timestamp:\n            '''a new component ID has appeared for parameters'''\n            self.last_param_sysid_timestamp = self.module('param').new_sysid_timestamp\n            self.update_vehicle_menu()\n\n        if type in ['RADIO', 'RADIO_STATUS']:\n            # handle RADIO msgs from all vehicles\n            if msg.rssi < msg.noise+10 or msg.remrssi < msg.remnoise+10:\n                fg = 'red'\n            else:\n                fg = 'black'\n            self.console.set_status('Radio', 'Radio %u/%u %u/%u' % (msg.rssi, msg.noise, msg.remrssi, msg.remnoise), fg=fg)\n            \n        if not self.is_primary_vehicle(msg):\n            # don't process msgs from other than primary vehicle, other than\n            # updating vehicle list\n            return\n\n        master = self.master\n        # add some status fields\n        if type in [ 'GPS_RAW', 'GPS_RAW_INT' ]:\n            if type == \"GPS_RAW\":\n                num_sats1 = master.field('GPS_STATUS', 'satellites_visible', 0)\n            else:\n                num_sats1 = msg.satellites_visible\n            num_sats2 = master.field('GPS2_RAW', 'satellites_visible', -1)\n            if num_sats2 == -1:\n                sats_string = \"%u\" % num_sats1\n            else:\n                sats_string = \"%u/%u\" % (num_sats1, num_sats2)\n            if ((msg.fix_type >= 3 and master.mavlink10()) or\n                (msg.fix_type == 2 and not master.mavlink10())):\n                if (msg.fix_type >= 4):\n                    fix_type = \"%u\" % msg.fix_type\n                else:\n                    fix_type = \"\"\n                self.console.set_status('GPS', 'GPS: OK%s (%s)' % (fix_type, sats_string), fg='green')\n            else:\n                self.console.set_status('GPS', 'GPS: %u (%s)' % (msg.fix_type, sats_string), fg='red')\n            if master.mavlink10():\n                gps_heading = int(self.mpstate.status.msgs['GPS_RAW_INT'].cog * 0.01)\n            else:\n                gps_heading = self.mpstate.status.msgs['GPS_RAW'].hdg\n            self.console.set_status('Heading', 'Hdg %s/%u' % (master.field('VFR_HUD', 'heading', '-'), gps_heading))\n        elif type == 'VFR_HUD':\n            if master.mavlink10():\n                alt = master.field('GPS_RAW_INT', 'alt', 0) / 1.0e3\n            else:\n                alt = master.field('GPS_RAW', 'alt', 0)\n            home = self.module('wp').get_home()\n            if home is not None:\n                home_lat = home.x\n                home_lng = home.y\n            else:\n                home_lat = None\n                home_lng = None\n            lat = master.field('GLOBAL_POSITION_INT', 'lat', 0) * 1.0e-7\n            lng = master.field('GLOBAL_POSITION_INT', 'lon', 0) * 1.0e-7\n            rel_alt = master.field('GLOBAL_POSITION_INT', 'relative_alt', 0) * 1.0e-3\n            agl_alt = None\n            if self.settings.basealt != 0:\n                agl_alt = self.console.ElevationMap.GetElevation(lat, lng)\n                if agl_alt is not None:\n                    agl_alt = self.settings.basealt - agl_alt\n            else:\n                try:\n                    agl_alt_home = self.console.ElevationMap.GetElevation(home_lat, home_lng)\n                except Exception as ex:\n                    print(ex)\n                    agl_alt_home = None\n                if agl_alt_home is not None:\n                    agl_alt = self.console.ElevationMap.GetElevation(lat, lng)\n                if agl_alt is not None:\n                    agl_alt = agl_alt_home - agl_alt\n            if agl_alt is not None:\n                agl_alt += rel_alt\n                vehicle_agl = master.field('TERRAIN_REPORT', 'current_height', None)\n                if vehicle_agl is None:\n                    vehicle_agl = '---'\n                else:\n                    vehicle_agl = self.height_string(vehicle_agl)\n                self.console.set_status('AGL', 'AGL %s/%s' % (self.height_string(agl_alt), vehicle_agl))\n            self.console.set_status('Alt', 'Alt %s' % self.height_string(rel_alt))\n            self.console.set_status('AirSpeed', 'AirSpeed %s' % self.speed_string(msg.airspeed))\n            self.console.set_status('GPSSpeed', 'GPSSpeed %s' % self.speed_string(msg.groundspeed))\n            self.console.set_status('Thr', 'Thr %u' % msg.throttle)\n            t = time.localtime(msg._timestamp)\n            flying = False\n            if self.mpstate.vehicle_type == 'copter':\n                flying = self.master.motors_armed()\n            else:\n                flying = msg.groundspeed > 3\n            if flying and not self.in_air:\n                self.in_air = True\n                self.start_time = time.mktime(t)\n            elif flying and self.in_air:\n                self.total_time = time.mktime(t) - self.start_time\n                self.console.set_status('FlightTime', 'FlightTime %u:%02u' % (int(self.total_time)/60, int(self.total_time)%60))\n            elif not flying and self.in_air:\n                self.in_air = False\n                self.total_time = time.mktime(t) - self.start_time\n                self.console.set_status('FlightTime', 'FlightTime %u:%02u' % (int(self.total_time)/60, int(self.total_time)%60))\n        elif type == 'ATTITUDE':\n            self.console.set_status('Roll', 'Roll %u' % math.degrees(msg.roll))\n            self.console.set_status('Pitch', 'Pitch %u' % math.degrees(msg.pitch))\n        elif type in ['SYS_STATUS']:\n            sensors = { 'AS'   : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE,\n                        'MAG'  : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_3D_MAG,\n                        'INS'  : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_3D_ACCEL | mavutil.mavlink.MAV_SYS_STATUS_SENSOR_3D_GYRO,\n                        'AHRS' : mavutil.mavlink.MAV_SYS_STATUS_AHRS,\n                        'RC'   : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_RC_RECEIVER,\n                        'TERR' : mavutil.mavlink.MAV_SYS_STATUS_TERRAIN,\n                        'RNG'  : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_LASER_POSITION,\n                        'LOG'  : mavutil.mavlink.MAV_SYS_STATUS_LOGGING,\n            }\n            announce = [ 'RC' ]\n            for s in sensors.keys():\n                bits = sensors[s]\n                present = ((msg.onboard_control_sensors_present & bits) == bits)\n                enabled = ((msg.onboard_control_sensors_enabled & bits) == bits)\n                healthy = ((msg.onboard_control_sensors_health & bits) == bits)\n                if not present:\n                    fg = 'black'\n                elif not enabled:\n                    fg = 'grey'\n                elif not healthy:\n                    fg = 'red'\n                else:\n                    fg = 'green'\n                # for terrain show yellow if still loading\n                if s == 'TERR' and fg == 'green' and master.field('TERRAIN_REPORT', 'pending', 0) != 0:\n                    fg = 'yellow'\n                self.console.set_status(s, s, fg=fg)\n            for s in announce:\n                bits = sensors[s]\n                enabled = ((msg.onboard_control_sensors_enabled & bits) == bits)\n                healthy = ((msg.onboard_control_sensors_health & bits) == bits)\n                was_healthy = ((self.last_sys_status_health & bits) == bits)\n                if enabled and not healthy and was_healthy:\n                    self.say(\"%s fail\" % s)\n            self.last_sys_status_health = msg.onboard_control_sensors_health\n\n            # check for any error bits being set:\n            now = time.time()\n            if now - self.last_sys_status_errors_announce > self.mpstate.settings.sys_status_error_warn_interval:\n                for field_num in range(1, 5):\n                    field = \"errors_count%u\" % field_num\n                    x = getattr(msg, field, None)\n                    if x is None:\n                        self.console.writeln(\"Failed to get field %s\" % field)\n                        self.last_sys_status_errors_announce = now\n                        break\n                    if x != 0:\n                        self.last_sys_status_errors_announce = now\n                        self.say(\"Critical failure\")\n                        break\n\n        elif type == 'WIND':\n            self.console.set_status('Wind', 'Wind %u/%.2f' % (msg.direction, msg.speed))\n\n        elif type == 'EKF_STATUS_REPORT':\n            highest = 0.0\n            vars = ['velocity_variance',\n                    'pos_horiz_variance',\n                    'pos_vert_variance',\n                    'compass_variance',\n                    'terrain_alt_variance']\n            for var in vars:\n                v = getattr(msg, var, 0)\n                highest = max(v, highest)\n            if highest >= 1.0:\n                fg = 'red'\n            elif highest >= 0.5:\n                fg = 'orange'\n            else:\n                fg = 'green'\n            self.console.set_status('EKF', 'EKF', fg=fg)\n\n        elif type == 'HWSTATUS':\n            if msg.Vcc >= 4600 and msg.Vcc <= 5300:\n                fg = 'green'\n            else:\n                fg = 'red'\n            self.console.set_status('Vcc', 'Vcc %.2f' % (msg.Vcc * 0.001), fg=fg)\n        elif type == 'POWER_STATUS':\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_CHANGED:\n                fg = 'red'\n            else:\n                fg = 'green'\n            status = 'PWR:'\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_USB_CONNECTED:\n                status += 'U'\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_BRICK_VALID:\n                status += 'B'\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_SERVO_VALID:\n                status += 'S'\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_PERIPH_OVERCURRENT:\n                status += 'O1'\n            if msg.flags & mavutil.mavlink.MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT:\n                status += 'O2'\n            self.console.set_status('PWR', status, fg=fg)\n            self.console.set_status('Srv', 'Srv %.2f' % (msg.Vservo*0.001), fg='green')\n        elif type == 'HEARTBEAT':\n            fmode = master.flightmode\n            if self.settings.vehicle_name:\n                fmode = self.settings.vehicle_name + ':' + fmode\n            self.console.set_status('Mode', '%s' % fmode, fg='blue')\n            if len(self.vehicle_list) > 1:\n                self.console.set_status('SysID', 'Sys:%u' % msg.get_srcSystem(), fg='blue')\n            if self.master.motors_armed():\n                arm_colour = 'green'\n            else:\n                arm_colour = 'red'\n            armstring = 'ARM'\n            # add safety switch state\n            if 'SYS_STATUS' in self.mpstate.status.msgs:\n                if (self.mpstate.status.msgs['SYS_STATUS'].onboard_control_sensors_enabled & mavutil.mavlink.MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS) == 0:\n                    armstring += '(SAFE)'\n            self.console.set_status('ARM', armstring, fg=arm_colour)\n            if self.max_link_num != len(self.mpstate.mav_master):\n                for i in range(self.max_link_num):\n                    self.console.set_status('Link%u'%(i+1), '', row=1)\n                self.max_link_num = len(self.mpstate.mav_master)\n            for m in self.mpstate.mav_master:\n                if self.mpstate.settings.checkdelay:\n                    linkdelay = (self.mpstate.status.highest_msec - m.highest_msec)*1.0e-3\n                else:\n                    linkdelay = 0\n                linkline = \"Link %s \" % (self.link_label(m))\n                fg = 'dark green'\n                if m.linkerror:\n                    linkline += \"down\"\n                    fg = 'red'\n                else:\n                    packets_rcvd_percentage = 100\n                    if (m.mav_count+m.mav_loss) != 0: #avoid divide-by-zero\n                        packets_rcvd_percentage = (100.0 * m.mav_count) / (m.mav_count + m.mav_loss)\n\n                    linkbits = [\"%u pkts\" % m.mav_count,\n                                \"%u lost\" % m.mav_loss,\n                                \"%.2fs delay\" % linkdelay,\n                    ]\n                    try:\n                        if m.mav.signing.sig_count:\n                            # other end is sending us signed packets\n                            if not m.mav.signing.secret_key:\n                                # we've received signed packets but\n                                # can't verify them\n                                fg = 'orange'\n                                linkbits.append(\"!KEY\")\n                            elif not m.mav.signing.sign_outgoing:\n                                # we've received signed packets but aren't\n                                # signing outselves; this can lead to hairloss\n                                fg = 'orange'\n                                linkbits.append(\"!SIGNING\")\n                            if m.mav.signing.badsig_count:\n                                fg = 'orange'\n                                linkbits.append(\"%u badsigs\" % m.mav.signing.badsig_count)\n                    except AttributeError as e:\n                        # mav.signing.sig_count probably doesn't exist\n                        pass\n\n                    linkline += \"OK {rcv_pct:.1f}% ({bits})\".format(\n                        rcv_pct=packets_rcvd_percentage,\n                        bits=\", \".join(linkbits))\n\n                    if linkdelay > 1 and fg == 'dark green':\n                        fg = 'orange'\n\n                self.console.set_status('Link%u'%m.linknum, linkline, row=1, fg=fg)\n        elif type in ['WAYPOINT_CURRENT', 'MISSION_CURRENT']:\n            wpmax = self.module('wp').wploader.count()\n            if wpmax > 0:\n                wpmax = \"/%u\" % wpmax\n            else:\n                wpmax = \"\"\n            self.console.set_status('WP', 'WP %u%s' % (msg.seq, wpmax))\n            lat = master.field('GLOBAL_POSITION_INT', 'lat', 0) * 1.0e-7\n            lng = master.field('GLOBAL_POSITION_INT', 'lon', 0) * 1.0e-7\n            if lat != 0 and lng != 0:\n                airspeed = master.field('VFR_HUD', 'airspeed', 30)\n                if abs(airspeed - self.speed) > 5:\n                    self.speed = airspeed\n                else:\n                    self.speed = 0.98*self.speed + 0.02*airspeed\n                self.speed = max(1, self.speed)\n                time_remaining = int(self.estimated_time_remaining(lat, lng, msg.seq, self.speed))\n                self.console.set_status('ETR', 'ETR %u:%02u' % (time_remaining/60, time_remaining%60))\n\n        elif type == 'NAV_CONTROLLER_OUTPUT':\n            self.console.set_status('WPDist', 'Distance %s' % self.dist_string(msg.wp_dist))\n            self.console.set_status('WPBearing', 'Bearing %u' % msg.target_bearing)\n            if msg.alt_error > 0:\n                alt_error_sign = \"L\"\n            else:\n                alt_error_sign = \"H\"\n            if msg.aspd_error > 0:\n                aspd_error_sign = \"L\"\n            else:\n                aspd_error_sign = \"H\"\n            if math.isnan(msg.alt_error):\n                alt_error = \"NaN\"\n            else:\n                alt_error = \"%d%s\" % (msg.alt_error, alt_error_sign)\n            self.console.set_status('AltError', 'AltError %s' % alt_error)\n            self.console.set_status('AspdError', 'AspdError %.1f%s' % (msg.aspd_error*0.01, aspd_error_sign))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef say_espeak(self, text, priority='important'):\n        '''speak some text using espeak'''\n        from espeak import espeak\n        if self.settings.speech_voice:\n            espeak.set_voice(self.settings.speech_voice)\n        espeak.synth(text)", "response": "speak some text using espeak"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling an incoming mavlink packet", "response": "def mavlink_packet(self, msg):\n        '''handle an incoming mavlink packet'''\n        type = msg.get_type()\n        if type == \"STATUSTEXT\":\n            # say some statustext values\n            if msg.text.startswith(\"Tuning: \"):\n                self.say(msg.text[8:])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef handle_log_data(self, m):\n        '''handling incoming log data'''\n        if self.download_file is None:\n            return\n        # lose some data\n        # import random\n        # if random.uniform(0,1) < 0.05:\n        #    print('dropping ', str(m))\n        #    return\n        if m.ofs != self.download_ofs:\n            self.download_file.seek(m.ofs)\n            self.download_ofs = m.ofs\n        if m.count != 0:\n            s = bytearray(m.data[:m.count])\n            self.download_file.write(s)\n            self.download_set.add(m.ofs // 90)\n            self.download_ofs += m.count\n        self.download_last_timestamp = time.time()\n        if m.count == 0 or (m.count < 90 and len(self.download_set) == 1 + (m.ofs // 90)):\n            dt = time.time() - self.download_start\n            self.download_file.close()\n            size = os.path.getsize(self.download_filename)\n            speed = size / (1000.0 * dt)\n            print(\"Finished downloading %s (%u bytes %u seconds, %.1f kbyte/sec %u retries)\" % (\n                self.download_filename,\n                size,\n                dt, speed,\n                self.retries))\n            self.download_file = None\n            self.download_filename = None\n            self.download_set = set()\n            self.master.mav.log_request_end_send(self.target_system,\n                                                 self.target_component)\n            if len(self.download_queue):\n                self.log_download_next()", "response": "handle incoming log data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nappend this menu item to a menu", "response": "def _append(self, menu):\n        '''append this menu item to a menu'''\n        from MAVProxy.modules.lib.wx_loader import wx\n        submenu = wx.Menu()\n        for i in range(len(self.items)):\n            submenu.AppendRadioItem(self.id()+i, self.items[i], self.description)\n            if self.items[i] == self.initial:\n                submenu.Check(self.id()+i, True)\n        menu.AppendSubMenu(submenu, self.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wx_menu(self):\n        '''return a wx.Menu() for this menu'''\n        from MAVProxy.modules.lib.wx_loader import wx\n        menu = wx.Menu()\n        for i in range(len(self.items)):\n            m = self.items[i]\n            m._append(menu)\n        return menu", "response": "return a wx. Menu object for this menu"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_to_submenu(self, submenu_path, item):\n        '''\n        add an item to a submenu using a menu path array\n        '''\n        for m in self.items:\n            if m.name == submenu_path[0]:\n                m.add_to_submenu(submenu_path[1:], item)\n                return\n        raise(ValueError(\"No submenu (%s) found\" % (submenu_path[0])))", "response": "add an item to a submenu using a menu path"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a wx. MenuBar object for the menu", "response": "def wx_menu(self):\n        '''return a wx.MenuBar() for the menu'''\n        from MAVProxy.modules.lib.wx_loader import wx\n\n        menubar = wx.MenuBar()\n        for i in range(len(self.items)):\n            m = self.items[i]\n            menubar.Append(m.wx_menu(), m.name)\n        return menubar"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef call(self):\n        '''show a file dialog'''\n        from MAVProxy.modules.lib.wx_loader import wx\n\n        # remap flags to wx descriptors\n        flag_map = {\n            'open': wx.FD_OPEN,\n            'save': wx.FD_SAVE,\n            'overwrite_prompt': wx.FD_OVERWRITE_PROMPT,\n        }\n        flagsMapped = map(lambda x: flag_map[x], self.flags)\n\n        #need to OR together the elements of the flagsMapped tuple\n        if len(flagsMapped) == 1:\n            dlg = wx.FileDialog(None, self.title, '', \"\", self.wildcard, flagsMapped[0])\n        else:\n            dlg = wx.FileDialog(None, self.title, '', \"\", self.wildcard, flagsMapped[0]|flagsMapped[1])\n        if dlg.ShowModal() != wx.ID_OK:\n            return None\n        return \"\\\"\" + dlg.GetPath().encode('utf8') + \"\\\"\"", "response": "show a file dialog"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows a value dialog", "response": "def call(self):\n        '''show a value dialog'''\n        from MAVProxy.modules.lib.wx_loader import wx\n        try:\n            dlg = wx.TextEntryDialog(None, self.title, self.title, defaultValue=str(self.default))\n        except TypeError:\n            dlg = wx.TextEntryDialog(None, self.title, self.title, value=str(self.default))\n        if dlg.ShowModal() != wx.ID_OK:\n            return None\n        return dlg.GetValue()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndo a DIGICAM_CONTROL command", "response": "def cmd_cammsg(self, args):\n        '''cammsg'''\n\n        params = [0, 0, 0, 0, 1, 0, 0]\n\n        # fill in any args passed by user\n        for i in range(min(len(args),len(params))):\n            params[i] = float(args[i])\n\n        print(\"Sent DIGICAM_CONTROL CMD_LONG\")\n        self.master.mav.command_long_send(\n            self.settings.target_system,  # target_system\n            0, # target_component\n            mavutil.mavlink.MAV_CMD_DO_DIGICAM_CONTROL, # command\n            0, # confirmation\n            params[0], # param1\n            params[1], # param2\n            params[2], # param3\n            params[3], # param4\n            params[4], # param5\n            params[5], # param6\n            params[6])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_do_change_speed(self, args):\n        '''speed value'''\n        if ( len(args) != 1):\n            print(\"Usage: setspeed SPEED_VALUE\")\n            return\n\n        if (len(args) == 1):\n            speed = float(args[0])\n            print(\"SPEED %s\" % (str(speed)))\n            self.master.mav.command_long_send(\n                self.settings.target_system,  # target_system\n                mavutil.mavlink.MAV_COMP_ID_SYSTEM_CONTROL, # target_component\n                mavutil.mavlink.MAV_CMD_DO_CHANGE_SPEED, # command\n                0, # confirmation\n                0, # param1\n                speed, # param2 (Speed value)\n                0, # param3\n                0, # param4\n                0, # param5\n                0, # param6\n                0)", "response": "change the speed of a node"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_long(self, args):\n        '''execute supplied command long'''\n        if len(args) < 1:\n            print(\"Usage: long <command> [arg1] [arg2]...\")\n            return\n        command = None\n        if args[0].isdigit():\n            command = int(args[0])\n        else:\n            try:\n                command = eval(\"mavutil.mavlink.\" + args[0])\n            except AttributeError as e:\n                try:\n                    command = eval(\"mavutil.mavlink.MAV_CMD_\" + args[0])\n                except AttributeError as e:\n                    pass\n\n        if command is None:\n            print(\"Unknown command long ({0})\".format(args[0]))\n            return\n\n        floating_args = [ float(x) for x in args[1:] ]\n        while len(floating_args) < 7:\n            floating_args.append(float(0))\n        self.master.mav.command_long_send(self.settings.target_system,\n                                          self.settings.target_component,\n                                          command,\n                                          0,\n                                          *floating_args)", "response": "execute supplied command long"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scale(val,\n          inlow=-1, inhigh=1,\n          outlow=1000, outhigh=2000):\n    '''Scale an in value in the range (inlow, inhigh) to the\n    range (outlow, outhigh).'''\n    return (\n        ((float(val) - inlow) / (inhigh - inlow)) *\n        (outhigh - outlow) + outlow\n    )", "response": "Scale an in value in the range inlow to inhigh."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_reverse_lookup(command_name):\n    '''returns 0 if key not found'''\n    for key, value in miss_cmds.items():\n        if (value.upper() == command_name.upper()):\n            return key\n    return 0", "response": "returns 0 if key not found"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntrying to work out a reasonable column name from parameter description", "response": "def make_column_label(command_name, description, default):\n    '''try to work out a reasonable column name from parameter description'''\n    for (pattern, label) in description_map:\n        if fnmatch.fnmatch(description, pattern):\n            return label\n    return default"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_column_labels(command_name):\n    '''return dictionary of column labels if available'''\n    cmd = cmd_reverse_lookup(command_name)\n    if cmd == 0:\n        return {}\n    labels = {}\n    enum = mavutil.mavlink.enums['MAV_CMD'][cmd]\n    for col in enum.param.keys():\n        labels[col] = make_column_label(command_name, enum.param[col], \"P%u\" % col)\n    return labels", "response": "return dictionary of column labels if available"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds an antenna tracker connection if possible", "response": "def find_connection(self):\n        '''find an antenna tracker connection if possible'''\n        if self.connection is not None:\n            return self.connection\n        for m in self.mpstate.mav_master:\n            if 'HEARTBEAT' in m.messages:\n                if m.messages['HEARTBEAT'].type == mavutil.mavlink.MAV_TYPE_ANTENNA_TRACKER:\n                    return m\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cmd_tracker_position(self, args):\n        '''tracker manual positioning commands'''\n        connection = self.find_connection()\n        if not connection:\n            print(\"No antenna tracker found\")\n            return\n        positions = [0, 0, 0, 0, 0] # x, y, z, r, buttons. only position[0] (yaw) and position[1] (pitch) are currently used\n        for i in range(0, 4):\n            if len(args) > i:\n                positions[i] = int(args[i]) # default values are 0\n        connection.mav.manual_control_send(connection.target_system,\n                                           positions[0], positions[1],\n                                           positions[2], positions[3],\n                                           positions[4])", "response": "tracker manual positioning commands"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_tracker_calpress(self, args):\n        '''calibrate barometer on tracker'''\n        connection = self.find_connection()\n        if not connection:\n            print(\"No antenna tracker found\")\n            return\n        connection.calibrate_pressure()", "response": "calibrate barometer on tracker"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mavlink_packet(self, m):\n        '''handle an incoming mavlink packet from the master vehicle. Relay it to the tracker\n        if it is a GLOBAL_POSITION_INT'''\n        if m.get_type() in ['GLOBAL_POSITION_INT', 'SCALED_PRESSURE']:\n            connection = self.find_connection()\n            if not connection:\n                return\n            if m.get_srcSystem() != connection.target_system:\n                connection.mav.send(m)", "response": "handle an incoming mavlink packet from the vehicle"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef idle_task(self):\n        '''called in idle time'''\n        if not self.connection:\n            return\n\n        # check for a mavlink message from the tracker\n        m = self.connection.recv_msg()\n        if m is None:\n            return\n\n        if self.tracker_settings.debug:\n            print(m)\n\n        self.pstate.handle_mavlink_packet(self.connection, m)\n        self.pstate.fetch_check(self.connection)\n\n        if self.module('map') is None:\n            return\n\n        if m.get_type() == 'GLOBAL_POSITION_INT':\n            (self.lat, self.lon, self.heading) = (m.lat*1.0e-7, m.lon*1.0e-7, m.hdg*0.01)\n            if self.lat != 0 or self.lon != 0:\n                self.module('map').create_vehicle_icon('AntennaTracker', 'red', follow=False, vehicle_type='antenna')\n                self.mpstate.map.set_position('AntennaTracker', (self.lat, self.lon), rotation=self.heading)", "response": "called in idle time"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfixes up jumps when we add or remove rows", "response": "def fix_jumps(self, row_selected, delta):\n        '''fix up jumps when we add/remove rows'''\n        numrows = self.grid_mission.GetNumberRows()\n        for row in range(numrows):\n            command = self.grid_mission.GetCellValue(row, ME_COMMAND_COL)\n            if command in [\"DO_JUMP\", \"DO_CONDITION_JUMP\"]:\n                p1 = int(float(self.grid_mission.GetCellValue(row, ME_P1_COL)))\n                if p1 > row_selected and p1+delta>0:\n                    self.grid_mission.SetCellValue(row, ME_P1_COL, str(float(p1+delta)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_gimbal_roi_vel(self, args):\n        '''control roi position and velocity'''\n        if len(args) != 0 and len(args) != 3 and len(args) != 6:\n            print(\"usage: gimbal roivel [VEL_NORTH VEL_EAST VEL_DOWN] [ACC_NORTH ACC_EASY ACC_DOWN]\")\n            return\n        latlon = None\n        vel = [0,0,0]\n        acc = [0,0,0]\n        if (len(args) >= 3):\n            vel[0:3] = args[0:3]\n        if (len(args) == 6):\n            acc[0:3] = args[3:6]\n        try:\n            latlon = self.module('map').click_position\n        except Exception:\n            print(\"No map available\")\n            return\n        if latlon is None:\n            print(\"No map click position available\")\n            latlon = (0,0,0)\n        self.master.mav.set_roi_global_int_send(0, #time_boot_ms\n            1, #target_system\n            1, #target_component\n            mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT,\n            0, #type_mask\n            0, #roi_index\n            0, #timeout_ms\n            int(latlon[0]*1e7), #lat int\n            int(latlon[1]*1e7), #lng int\n            float(0),       #alt\n            float(vel[0]), #vx\n            float(vel[1]), #vy\n            float(vel[2]), #vz\n            float(acc[0]), #ax\n            float(acc[1]), #ay\n            float(acc[2]))", "response": "control roi position and velocity"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles an incoming mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n\n        if not self.mpstate.map:\n            # don't draw if no map\n            return\n\n        if m.get_type() != 'GIMBAL_REPORT':\n            return\n\n        needed = ['ATTITUDE', 'GLOBAL_POSITION_INT']\n        for n in needed:\n            if not n in self.master.messages:\n                return\n\n        # clear the camera icon\n        self.mpstate.map.add_object(mp_slipmap.SlipClearLayer('GimbalView'))\n\n        gpi = self.master.messages['GLOBAL_POSITION_INT']\n        att = self.master.messages['ATTITUDE']\n        vehicle_dcm = Matrix3()\n        vehicle_dcm.from_euler(att.roll, att.pitch, att.yaw)\n\n        rotmat_copter_gimbal = Matrix3()\n        rotmat_copter_gimbal.from_euler312(m.joint_roll, m.joint_el, m.joint_az)\n        gimbal_dcm = vehicle_dcm * rotmat_copter_gimbal\n\n        lat = gpi.lat * 1.0e-7\n        lon = gpi.lon * 1.0e-7\n        alt = gpi.relative_alt * 1.0e-3\n\n        # ground plane\n        ground_plane = Plane()\n\n        # the position of the camera in the air, remembering its a right\n        # hand coordinate system, so +ve z is down\n        camera_point = Vector3(0, 0, -alt)\n\n        # get view point of camera when not rotated\n        view_point = Vector3(1, 0, 0)\n\n        # rotate view_point to form current view vector\n        rot_point = gimbal_dcm * view_point\n\n        # a line from the camera to the ground\n        line = Line(camera_point, rot_point)\n\n        # find the intersection with the ground\n        pt = line.plane_intersection(ground_plane, forward_only=True)\n        if pt is None:\n            # its pointing up into the sky\n            return None\n\n        (view_lat, view_lon) = mp_util.gps_offset(lat, lon, pt.y, pt.x)\n\n        icon = self.mpstate.map.icon('camera-small-red.png')\n        self.mpstate.map.add_object(mp_slipmap.SlipIcon('gimbalview',\n                                                        (view_lat,view_lon),\n                                                        icon, layer='GimbalView', rotation=0, follow=False))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef image_shape(img):\n    '''handle different image formats, returning (width,height) tuple'''\n    if hasattr(img, 'shape'):\n        return (img.shape[1], img.shape[0])\n    return (img.width, img.height)", "response": "handle different image formats returning width height tuple"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef draw_line(self, img, pixmapper, pt1, pt2, colour, linewidth):\n        '''draw a line on the image'''\n        pix1 = pixmapper(pt1)\n        pix2 = pixmapper(pt2)\n        (width, height) = image_shape(img)\n        (ret, pix1, pix2) = cv2.clipLine((0, 0, width, height), pix1, pix2)\n        if ret is False:\n            if len(self._pix_points) == 0:\n                self._pix_points.append(None)\n            self._pix_points.append(None)\n            return\n        cv2.line(img, pix1, pix2, colour, linewidth)\n        cv2.circle(img, pix2, linewidth*2, colour)\n        if len(self._pix_points) == 0:\n            self._pix_points.append(pix1)\n        self._pix_points.append(pix2)\n        if self.arrow:\n            xdiff = pix2[0]-pix1[0]\n            ydiff = pix2[1]-pix1[1]\n            if (xdiff*xdiff + ydiff*ydiff) > 400: # the segment is longer than 20 pix\n                SlipArrow(self.key, self.layer, (int(pix1[0]+xdiff/2.0), int(pix1[1]+ydiff/2.0)), self.colour,\n                          self.linewidth, math.atan2(ydiff, xdiff)+math.pi/2.0).draw(img)", "response": "draw a line on the image"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndrawing a line on the image", "response": "def draw_line(self, img, pixmapper, pt1, pt2, colour, linewidth):\n        '''draw a line on the image'''\n        pix1 = pixmapper(pt1)\n        pix2 = pixmapper(pt2)\n        (width, height) = image_shape(img)\n        (ret, pix1, pix2) = cv2.clipLine((0, 0, width, height), pix1, pix2)\n        if ret is False:\n            return\n        cv2.line(img, pix1, pix2, colour, linewidth)\n        cv2.circle(img, pix2, linewidth*2, colour)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef draw(self, img, pixmapper, bounds):\n        '''draw legend on the image'''\n        if self._img is None:\n            self._img = self.draw_legend()\n\n        w = self._img.shape[1]\n        h = self._img.shape[0]\n        px = 5\n        py = 5\n        img[py:py+h,px:px+w] = self._img", "response": "draw legend on the image"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef img(self):\n        '''return a cv image for the thumbnail'''\n        if self._img is not None:\n            return self._img \n        self._img = cv2.cvtColor(self.original_img, cv2.COLOR_BGR2RGB)\n        if self.border_width and self.border_colour is not None:\n            cv2.rectangle(self._img, (0, 0), (self.width-1, self.height-1),\n                          self.border_colour, self.border_width)\n        return self._img", "response": "return a cv image for the thumbnail"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef draw(self, img, pixmapper, bounds):\n        '''draw the thumbnail on the image'''\n        if self.hidden:\n            return\n        thumb = self.img()\n        (px,py) = pixmapper(self.latlon)\n\n        # find top left\n        (w, h) = image_shape(thumb)\n        px -= w//2\n        py -= h//2\n\n        (px, py, sx, sy, w, h) = self.clip(px, py, w, h, img)\n\n        thumb_roi = thumb[sy:sy+h, sx:sx+w]\n        img[py:py+h, px:px+w] = thumb_roi\n\n        # remember where we placed it for clicked()\n        self.posx = px+w//2\n        self.posy = py+h//2", "response": "draw the thumbnail on the image"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a cv image for the icon", "response": "def img(self):\n        '''return a cv image for the icon'''\n        SlipThumbnail.img(self)\n\n        if self.rotation:\n            # rotate the image\n            mat = cv2.getRotationMatrix2D((self.height//2, self.width//2), -self.rotation, 1.0)\n            self._rotated = cv2.warpAffine(self._img, mat, (self.height, self.width))\n        else:\n            self._rotated = self._img\n        return self._rotated"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef draw(self, img, pixmapper, bounds):\n        '''draw the icon on the image'''\n\n        if self.hidden:\n            return\n\n        if self.trail is not None:\n            self.trail.draw(img, pixmapper, bounds)\n\n        icon = self.img()\n        (px,py) = pixmapper(self.latlon)\n\n        # find top left\n        (w, h) = image_shape(icon)\n        px -= w//2\n        py -= h//2\n\n        (px, py, sx, sy, w, h) = self.clip(px, py, w, h, img)\n\n        img[py:py + h, px:px + w] = cv2.add(img[py:py+h, px:px+w], icon[sy:sy+h, sx:sx+w])\n\n        if self.label is not None:\n            cv2.putText(img, self.label, (px,py), cv2.FONT_HERSHEY_SIMPLEX, 1.0, self.colour)\n        \n        # remember where we placed it for clicked()\n        self.posx = px+w//2\n        self.posy = py+h//2", "response": "draw the icon on the image"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a wx image", "response": "def img(self):\n        '''return a wx image'''\n        import wx\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            img = wx.EmptyImage(self.width, self.height)\n            img.SetData(self.imgstr)\n        return img"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_terrain_check(self, args):\n        '''check a piece of terrain data'''\n        if len(args) >= 2:\n            latlon = (float(args[0]), float(args[1]))\n        else:\n            try:\n                latlon = self.module('map').click_position\n            except Exception:\n                print(\"No map available\")\n                return\n            if latlon is None:\n                print(\"No map click position available\")\n                return\n        self.check_lat = int(latlon[0]*1e7)\n        self.check_lon = int(latlon[1]*1e7)\n        self.master.mav.terrain_check_send(self.check_lat, self.check_lon)", "response": "check a piece of terrain data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mavlink_packet(self, msg):\n        '''handle an incoming mavlink packet'''\n        type = msg.get_type()\n        master = self.master\n        # add some status fields\n        if type == 'TERRAIN_REQUEST':\n            self.current_request = msg\n            self.sent_mask = 0\n            self.requests_received += 1\n        elif type == 'TERRAIN_REPORT':\n            if (msg.lat == self.check_lat and\n                msg.lon == self.check_lon and\n                (self.check_lat != 0 or self.check_lon != 0)):\n                print(msg)\n                self.check_lat = 0\n                self.check_lon = 0", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend some terrain data", "response": "def send_terrain_data_bit(self, bit):\n        '''send some terrain data'''\n        lat = self.current_request.lat * 1.0e-7\n        lon = self.current_request.lon * 1.0e-7\n        bit_spacing = self.current_request.grid_spacing * 4\n        (lat, lon) = mp_util.gps_offset(lat, lon,\n                                        east=bit_spacing * (bit % 8),\n                                        north=bit_spacing * (bit // 8))\n        data = []\n        for i in range(4*4):\n            y = i % 4\n            x = i // 4\n            (lat2,lon2) = mp_util.gps_offset(lat, lon,\n                                             east=self.current_request.grid_spacing * y,\n                                             north=self.current_request.grid_spacing * x)\n            alt = self.ElevationModel.GetElevation(lat2, lon2)\n            if alt is None:\n                if self.terrain_settings.debug:\n                    print(\"no alt \", lat2, lon2)\n                return\n            data.append(int(alt))\n        self.master.mav.terrain_data_send(self.current_request.lat,\n                                          self.current_request.lon,\n                                          self.current_request.grid_spacing,\n                                          bit,\n                                          data)\n        self.blocks_sent += 1\n        self.last_send_time = time.time()\n        self.sent_mask |= 1<<bit\n        if self.terrain_settings.debug and bit == 55:\n            lat = self.current_request.lat * 1.0e-7\n            lon = self.current_request.lon * 1.0e-7\n            print(\"--lat=%f --lon=%f %.1f\" % (\n                lat, lon, self.ElevationModel.GetElevation(lat, lon)))\n            (lat2,lon2) = mp_util.gps_offset(lat, lon,\n                                             east=32*self.current_request.grid_spacing,\n                                             north=28*self.current_request.grid_spacing)\n            print(\"--lat=%f --lon=%f %.1f\" % (\n                lat2, lon2, self.ElevationModel.GetElevation(lat2, lon2)))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending some terrain data", "response": "def send_terrain_data(self):\n        '''send some terrain data'''\n        for bit in range(56):\n            if self.current_request.mask & (1<<bit) and self.sent_mask & (1<<bit) == 0:\n                self.send_terrain_data_bit(bit)\n                return\n        # no bits to send\n        self.current_request = None\n        self.sent_mask = 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unknown_command(self, args):\n        '''handle mode switch by mode name as command'''\n        mode_mapping = self.master.mode_mapping()\n        mode = args[0].upper()\n        if mode in mode_mapping:\n            self.master.set_mode(mode_mapping[mode])\n            return True\n        return False", "response": "handle mode switch by mode name as command"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck for FDM packets from runsim", "response": "def check_sim_in(self):\n        '''check for FDM packets from runsim'''\n        try:\n            pkt = self.sim_in.recv(17*8 + 4)\n        except socket.error as e:\n            if not e.errno in [ errno.EAGAIN, errno.EWOULDBLOCK ]:\n                raise\n            return\n        if len(pkt) != 17*8 + 4:\n            # wrong size, discard it\n            print(\"wrong size %u\" % len(pkt))\n            return\n        (latitude, longitude, altitude, heading, v_north, v_east, v_down,\n         ax, ay, az,\n         phidot, thetadot, psidot,\n         roll, pitch, yaw,\n         vcas, check) = struct.unpack('<17dI', pkt)\n        (p, q, r) = self.convert_body_frame(radians(roll), radians(pitch), radians(phidot), radians(thetadot), radians(psidot))\n\n        try:\n            self.hil_state_msg = self.master.mav.hil_state_encode(int(time.time()*1e6),\n                                                                        radians(roll),\n                                                                        radians(pitch),\n                                                                        radians(yaw),\n                                                                        p,\n                                                                        q,\n                                                                        r,\n                                                                        int(latitude*1.0e7),\n                                                                        int(longitude*1.0e7),\n                                                                        int(altitude*1.0e3),\n                                                                        int(v_north*100),\n                                                                        int(v_east*100),\n                                                                        0,\n                                                                        int(ax*1000/9.81),\n                                                                        int(ay*1000/9.81),\n                                                                        int(az*1000/9.81))\n        except Exception:\n            return"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_sim_out(self):\n        '''check if we should send new servos to flightgear'''\n        now = time.time()\n        if now - self.last_sim_send_time < 0.02 or self.rc_channels_scaled is None:\n            return\n        self.last_sim_send_time = now\n\n        servos = []\n        for ch in range(1,9):\n            servos.append(self.scale_channel(ch, getattr(self.rc_channels_scaled, 'chan%u_scaled' % ch)))\n        servos.extend([0,0,0, 0,0,0])\n        buf = struct.pack('<14H', *servos)\n        try:\n            self.sim_out.send(buf)\n        except socket.error as e:\n            if not e.errno in [ errno.ECONNREFUSED ]:\n                raise\n            return", "response": "check if we should send new servos to flightgear"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if we should send new data to the APM", "response": "def check_apm_out(self):\n        '''check if we should send new data to the APM'''\n        now = time.time()\n        if now - self.last_apm_send_time < 0.02:\n            return\n        self.last_apm_send_time = now\n        if self.hil_state_msg is not None:\n            self.master.mav.send(self.hil_state_msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_body_frame(self, phi, theta, phiDot, thetaDot, psiDot):\n        '''convert a set of roll rates from earth frame to body frame'''\n        p = phiDot - psiDot*math.sin(theta)\n        q = math.cos(phi)*thetaDot + math.sin(phi)*psiDot*math.cos(theta)\n        r = math.cos(phi)*psiDot*math.cos(theta) - math.sin(phi)*thetaDot\n        return (p, q, r)", "response": "convert a set of roll rates from earth frame to body frame"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scale_channel(self, ch, value):\n        '''scale a channel to 1000/1500/2000'''\n        v = value/10000.0\n        if v < -1:\n            v = -1\n        elif v > 1:\n            v = 1\n        if ch == 3 and self.mpstate.vehicle_type != 'rover':\n            if v < 0:\n                v = 0\n            return int(1000 + v*1000)\n        return int(1500 + v*500)", "response": "scale a channel to 10001500 2000 2000"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_messagerate(self, args):\n        '''control behaviour of the module'''\n        if len(args) == 0:\n            print(self.usage())\n        elif args[0] == \"status\":\n            print(self.status())\n        elif args[0] == \"reset\":\n            self.reset()\n        else:\n            print(self.usage())", "response": "control behaviour of the module"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns status of the current state of the object", "response": "def status(self):\n        '''returns rates'''\n        counts = {}\n        for bucket in self.buckets:\n            for x in bucket:\n                if not x in counts:\n                    counts[x] = 0\n                counts[x] += bucket[x]\n\n        ret = \"\"\n        mtypes = counts.keys()\n        mtypes.sort()\n        for mtype in mtypes:\n            ret += \"%s: %0.1f/s\\n\" % (mtype,\n                                      counts[mtype]/float(len(self.buckets)))\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall rapidly by mavproxy", "response": "def idle_task(self):\n        '''called rapidly by mavproxy'''\n        now = time.time()\n        time_delta = now - self.last_calc\n        if time_delta > 1:\n            self.last_calc = now\n            self.buckets.append(self.counts)\n            self.counts = {}\n            if len(self.buckets) > self.max_buckets:\n                self.buckets = self.buckets[-self.max_buckets:]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new setting", "response": "def append(self, v):\n        '''add a new setting'''\n        if isinstance(v, MPSetting):\n            setting = v\n        else:\n            (name,type,default) = v\n            label = name\n            tab = None\n            if len(v) > 3:\n                label = v[3]\n            if len(v) > 4:\n                tab = v[4]\n            setting = MPSetting(name, type, default, label=label, tab=tab)\n\n        # when a tab name is set, cascade it to future settings\n        if setting.tab is None:\n            setting.tab = self._default_tab\n        else:\n            self._default_tab = setting.tab\n        self._vars[setting.name] = setting\n        self._keys.append(setting.name)\n        self._last_change = time.time()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef command(self, args):\n        '''control options from cmdline'''\n        if len(args) == 0:\n            self.show_all()\n            return\n        if getattr(self, args[0], [None]) == [None]:\n            print(\"Unknown setting '%s'\" % args[0])\n            return\n        if len(args) == 1:\n            self.show(args[0])\n        else:\n            self.set(args[0], args[1])", "response": "control options from cmdline"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save(self, filename):\n        '''save settings to a file. Return True/False on success/failure'''\n        try:\n            f = open(filename, mode='w')\n        except Exception:\n            return False\n        for k in self.list():\n            f.write(\"%s=%s\\n\" % (k, self.get(k)))\n        f.close()\n        return True", "response": "save settings to a file. Return True on success / failure"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload settings from a file. Return True on success and False on failure", "response": "def load(self, filename):\n        '''load settings from a file. Return True/False on success/failure'''\n        try:\n            f = open(filename, mode='r')\n        except Exception:\n            return False\n        while True:\n            line = f.readline()\n            if not line:\n                break\n            line = line.rstrip()\n            eq = line.find('=')\n            if eq == -1:\n                continue\n            name = line[:eq]\n            value = line[eq+1:]\n            self.set(name, value)\n        f.close()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef all_checks_enabled(self):\n        ''' returns true if the UAV is skipping any arming checks'''\n        arming_mask = int(self.get_mav_param(\"ARMING_CHECK\",0))\n        if arming_mask == 1:\n            return True\n        for bit in arming_masks.values():\n            if not arming_mask & bit and bit != 1:\n                return False\n        return True", "response": "returns true if the UAV is skipping any arming checks"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handle_px4_param_value(self, m):\n        '''special handling for the px4 style of PARAM_VALUE'''\n        if m.param_type == mavutil.mavlink.MAV_PARAM_TYPE_REAL32:\n            # already right type\n            return m.param_value\n        is_px4_params = False\n        if m.get_srcComponent() in [mavutil.mavlink.MAV_COMP_ID_UDP_BRIDGE]:\n            # ESP8266 uses PX4 style parameters\n            is_px4_params = True\n        sysid = m.get_srcSystem()\n        if self.autopilot_type_by_sysid.get(sysid,-1) in [mavutil.mavlink.MAV_AUTOPILOT_PX4]:\n            is_px4_params = True\n        if not is_px4_params:\n            return m.param_value\n        # try to extract px4 param value\n        value = m.param_value\n        try:\n            v = struct.pack(\">f\", value)\n        except Exception:\n            return value\n        if m.param_type == mavutil.mavlink.MAV_PARAM_TYPE_UINT8:\n            value, = struct.unpack(\">B\", v[3:])\n        elif m.param_type == mavutil.mavlink.MAV_PARAM_TYPE_INT8:\n            value, = struct.unpack(\">b\", v[3:])\n        elif m.param_type == mavutil.mavlink.MAV_PARAM_TYPE_UINT16:\n            value, = struct.unpack(\">H\", v[2:])\n        elif m.param_type == mavutil.mavlink.MAV_PARAM_TYPE_INT16:\n            value, = struct.unpack(\">h\", v[2:])\n        elif m.param_type == mavutil.mavlink.MAV_PARAM_TYPE_UINT32:\n            value, = struct.unpack(\">I\", v[0:])\n        elif m.param_type == mavutil.mavlink.MAV_PARAM_TYPE_INT32:\n            value, = struct.unpack(\">i\", v[0:])\n        # can't pack other types\n\n        # remember type for param set\n        self.param_types[m.param_id.upper()] = m.param_type\n        return value", "response": "special handling for the px4 style of PARAM_VALUE"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_mavlink_packet(self, master, m):\n        '''handle an incoming mavlink packet'''\n        if m.get_type() == 'PARAM_VALUE':\n            value = self.handle_px4_param_value(m)\n            param_id = \"%.16s\" % m.param_id\n            # Note: the xml specifies param_index is a uint16, so -1 in that field will show as 65535\n            # We accept both -1 and 65535 as 'unknown index' to future proof us against someday having that\n            # xml fixed.\n            if self.fetch_set is not None:\n                self.fetch_set.discard(m.param_index)\n            if m.param_index != -1 and m.param_index != 65535 and m.param_index not in self.mav_param_set:\n                added_new_parameter = True\n                self.mav_param_set.add(m.param_index)\n            else:\n                added_new_parameter = False\n            if m.param_count != -1:\n                self.mav_param_count = m.param_count\n            self.mav_param[str(param_id)] = value\n            if param_id in self.fetch_one and self.fetch_one[param_id] > 0:\n                self.fetch_one[param_id] -= 1\n                if isinstance(value, float):\n                    print(\"%s = %.7f\" % (param_id, value))\n                else:\n                    print(\"%s = %s\" % (param_id, str(value)))\n            if added_new_parameter and len(self.mav_param_set) == m.param_count:\n                print(\"Received %u parameters\" % m.param_count)\n                if self.logdir is not None:\n                    self.mav_param.save(os.path.join(self.logdir, self.parm_file), '*', verbose=True)\n                self.fetch_set = None\n            if self.fetch_set is not None and len(self.fetch_set) == 0:\n                self.fetch_check(master, force=True)\n        elif m.get_type() == 'HEARTBEAT':\n            if m.get_srcComponent() == 1:\n                # remember autopilot types so we can handle PX4 parameters\n                self.autopilot_type_by_sysid[m.get_srcSystem()] = m.autopilot", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads XML files for parameters", "response": "def param_help_download(self):\n        '''download XML files for parameters'''\n        files = []\n        for vehicle in ['APMrover2', 'ArduCopter', 'ArduPlane', 'ArduSub', 'AntennaTracker']:\n            url = 'http://autotest.ardupilot.org/Parameters/%s/apm.pdef.xml' % vehicle\n            path = mp_util.dot_mavproxy(\"%s.xml\" % vehicle)\n            files.append((url, path))\n            url = 'http://autotest.ardupilot.org/%s-defaults.parm' % vehicle\n            if vehicle != 'AntennaTracker':\n                # defaults not generated for AntennaTracker ATM\n                path = mp_util.dot_mavproxy(\"%s-defaults.parm\" % vehicle)\n                files.append((url, path))\n        try:\n            child = multiproc.Process(target=mp_util.download_files, args=(files,))\n            child.start()\n        except Exception as e:\n            print(e)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef param_help_tree(self):\n        '''return a \"help tree\", a map between a parameter and its metadata.  May return None if help is not available'''\n        if self.xml_filepath is not None:\n            print(\"param: using xml_filepath=%s\" % self.xml_filepath)\n            path = self.xml_filepath\n        else:\n            if self.vehicle_name is None:\n                print(\"Unknown vehicle type\")\n                return None\n            path = mp_util.dot_mavproxy(\"%s.xml\" % self.vehicle_name)\n            if not os.path.exists(path):\n                print(\"Please run 'param download' first (vehicle_name=%s)\" % self.vehicle_name)\n                return None\n        if not os.path.exists(path):\n            print(\"Param XML (%s) does not exist\" % path)\n            return None\n        xml = open(path,'rb').read()\n        from lxml import objectify\n        objectify.enable_recursive_str()\n        tree = objectify.fromstring(xml)\n        htree = {}\n        for p in tree.vehicles.parameters.param:\n            n = p.get('name').split(':')[1]\n            htree[n] = p\n        for lib in tree.libraries.parameters:\n            for p in lib.param:\n                n = p.get('name')\n                htree[n] = p\n        return htree", "response": "return a help tree"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef param_apropos(self, args):\n        '''search parameter help for a keyword, list those parameters'''\n        if len(args) == 0:\n            print(\"Usage: param apropos keyword\")\n            return\n\n        htree = self.param_help_tree()\n        if htree is None:\n            return\n\n        contains = {}\n        for keyword in args:\n            for param in htree.keys():\n                if str(htree[param]).find(keyword) != -1:\n                    contains[param] = True\n        for param in contains.keys():\n            print(\"%s\" % (param,))", "response": "search parameter help for a keyword list those parameters"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef param_help(self, args):\n        '''show help on a parameter'''\n        if len(args) == 0:\n            print(\"Usage: param help PARAMETER_NAME\")\n            return\n\n        htree = self.param_help_tree()\n        if htree is None:\n            return\n\n        for h in args:\n            h = h.upper()\n            if h in htree:\n                help = htree[h]\n                print(\"%s: %s\\n\" % (h, help.get('humanName')))\n                print(help.get('documentation'))\n                try:\n                    print(\"\\n\")\n                    for f in help.field:\n                        print(\"%s : %s\" % (f.get('name'), str(f)))\n                except Exception as e:\n                    pass\n                try:\n                    # The entry \"values\" has been blatted by a cython\n                    # function at this point, so we instead get the\n                    # \"values\" by offset rather than name.\n                    children = help.getchildren()\n                    vchild = children[0]\n                    values = vchild.getchildren()\n                    if len(values):\n                        print(\"\\nValues: \")\n                        for v in values:\n                            print(\"\\t%s : %s\" % (v.get('code'), str(v)))\n                except Exception as e:\n                    print(\"Caught exception %s\" % repr(e))\n                    pass\n            else:\n                print(\"Parameter '%s' not found in documentation\" % h)", "response": "show help on a parameter"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef handle_command(self, master, mpstate, args):\n        '''handle parameter commands'''\n        param_wildcard = \"*\"\n        usage=\"Usage: param <fetch|save|set|show|load|preload|forceload|diff|download|help>\"\n        if len(args) < 1:\n            print(usage)\n            return\n        if args[0] == \"fetch\":\n            if len(args) == 1:\n                master.param_fetch_all()\n                self.mav_param_set = set()\n                print(\"Requested parameter list\")\n            else:\n                found = False\n                pname = args[1].upper()\n                for p in self.mav_param.keys():\n                    if fnmatch.fnmatch(p, pname):\n                        master.param_fetch_one(p)\n                        if p not in self.fetch_one:\n                            self.fetch_one[p] = 0\n                        self.fetch_one[p] += 1\n                        found = True\n                        print(\"Requested parameter %s\" % p)\n                if not found and args[1].find('*') == -1:\n                    master.param_fetch_one(pname)\n                    if pname not in self.fetch_one:\n                        self.fetch_one[pname] = 0\n                    self.fetch_one[pname] += 1\n                    print(\"Requested parameter %s\" % pname)\n                        \n        elif args[0] == \"save\":\n            if len(args) < 2:\n                print(\"usage: param save <filename> [wildcard]\")\n                return\n            if len(args) > 2:\n                param_wildcard = args[2]\n            else:\n                param_wildcard = \"*\"\n            self.mav_param.save(args[1], param_wildcard, verbose=True)\n        elif args[0] == \"diff\":\n            wildcard = '*'\n            if len(args) < 2 or args[1].find('*') != -1:\n                if self.vehicle_name is None:\n                    print(\"Unknown vehicle type\")\n                    return\n                filename = mp_util.dot_mavproxy(\"%s-defaults.parm\" % self.vehicle_name)\n                if not os.path.exists(filename):\n                    print(\"Please run 'param download' first (vehicle_name=%s)\" % self.vehicle_name)\n                    return\n                if len(args) >= 2:\n                    wildcard = args[1]\n            else:\n                filename = args[1]\n                if len(args) == 3:\n                    wildcard = args[2]\n            print(\"%-16.16s %12.12s %12.12s\" % ('Parameter', 'Defaults', 'Current'))\n            self.mav_param.diff(filename, wildcard=wildcard)\n        elif args[0] == \"set\":\n            if len(args) < 2:\n                print(\"Usage: param set PARMNAME VALUE\")\n                return\n            if len(args) == 2:\n                self.mav_param.show(args[1])\n                return\n            param = args[1]\n            value = args[2]\n            if value.startswith('0x'):\n                value = int(value, base=16)\n            if not param.upper() in self.mav_param:\n                print(\"Unable to find parameter '%s'\" % param)\n                return\n            uname = param.upper()\n            ptype = None\n            if uname in self.param_types:\n                ptype = self.param_types[uname]\n            self.mav_param.mavset(master, uname, value, retries=3, parm_type=ptype)\n\n            if (param.upper() == \"WP_LOITER_RAD\" or param.upper() == \"LAND_BREAK_PATH\"):\n                #need to redraw rally points\n                mpstate.module('rally').rallyloader.last_change = time.time()\n                #need to redraw loiter points\n                mpstate.module('wp').wploader.last_change = time.time()\n\n        elif args[0] == \"load\":\n            if len(args) < 2:\n                print(\"Usage: param load <filename> [wildcard]\")\n                return\n            if len(args) > 2:\n                param_wildcard = args[2]\n            else:\n                param_wildcard = \"*\"\n            self.mav_param.load(args[1], param_wildcard, master)\n        elif args[0] == \"preload\":\n            if len(args) < 2:\n                print(\"Usage: param preload <filename>\")\n                return\n            self.mav_param.load(args[1])\n        elif args[0] == \"forceload\":\n            if len(args) < 2:\n                print(\"Usage: param forceload <filename> [wildcard]\")\n                return\n            if len(args) > 2:\n                param_wildcard = args[2]\n            else:\n                param_wildcard = \"*\"\n            self.mav_param.load(args[1], param_wildcard, master, check=False)\n        elif args[0] == \"download\":\n            self.param_help_download()\n        elif args[0] == \"apropos\":\n            self.param_apropos(args[1:])\n        elif args[0] == \"help\":\n            self.param_help(args[1:])\n        elif args[0] == \"set_xml_filepath\":\n            self.param_set_xml_filepath(args[1:])\n        elif args[0] == \"show\":\n            if len(args) > 1:\n                pattern = args[1]\n            else:\n                pattern = \"*\"\n            self.mav_param.show(pattern)\n        elif args[0] == \"status\":\n            print(\"Have %u/%u params\" % (len(self.mav_param_set), self.mav_param_count))\n        else:\n            print(usage)", "response": "handle command - fetch save and diff"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_component_id_list(self, system_id):\n        '''get list of component IDs with parameters for a given system ID'''\n        ret = []\n        for (s,c) in self.mpstate.mav_param_by_sysid.keys():\n            if s == system_id:\n                ret.append(c)\n        return ret", "response": "get list of component IDs with parameters for a given system ID"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle a new target_system", "response": "def add_new_target_system(self, sysid):\n        '''handle a new target_system'''\n        if sysid in self.pstate:\n            return\n        if not sysid in self.mpstate.mav_param_by_sysid:\n            self.mpstate.mav_param_by_sysid[sysid] = mavparm.MAVParmDict()\n            self.new_sysid_timestamp = time.time()\n        fname = 'mav.parm'\n        if sysid not in [(0,0),(1,1),(1,0)]:\n\n            fname = 'mav_%u_%u.parm' % (sysid[0], sysid[1])\n        self.pstate[sysid] = ParamState(self.mpstate.mav_param_by_sysid[sysid], self.logdir, self.vehicle_name, fname)\n        if self.continue_mode and self.logdir is not None:\n            parmfile = os.path.join(self.logdir, fname)\n            if os.path.exists(parmfile):\n                mpstate.mav_param.load(parmfile)\n                self.pstate[sysid].mav_param_set = set(self.mav_param.keys())\n        self.pstate[sysid].xml_filepath = self.xml_filepath"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_sysid(self):\n        '''get sysid tuple to use for parameters'''\n        component = self.target_component\n        if component == 0:\n            component = 1\n        return (self.target_system, component)", "response": "get sysid tuple to use for parameters"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle a new target_system", "response": "def check_new_target_system(self):\n        '''handle a new target_system'''\n        sysid = self.get_sysid()\n        if sysid in self.pstate:\n            return\n        self.add_new_target_system(sysid)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        sysid = (m.get_srcSystem(),m.get_srcComponent())\n        self.add_new_target_system(sysid)\n        self.pstate[sysid].handle_mavlink_packet(self.master, m)", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the tuple of options and args for this instance of the class.", "response": "def getOptionsAndArgs( self ):\n        '''Returns the tuple ( options, args )\n        options -  a dictionary of option names and values\n        args - a sequence of args'''\n\n        option_values = self._getOptions()\n        args = self._getArgs()\n        return option_values, args"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_args( self, args = None, values = None ):\n        '''\n        multiprocessing wrapper around _parse_args\n        '''\n        q = multiproc.Queue()\n        p = multiproc.Process(target=self._parse_args, args=(q, args, values))\n        p.start()\n        ret = q.get()\n        p.join()\n        return ret", "response": "wrapper around _parse_argsmultroc wrapper around _parse_args\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_args( self, q, args, values):\n        '''\n        This is the heart of it all - overrides optparse.OptionParser.parse_args\n        @param arg is irrelevant and thus ignored,\n               it is here only for interface compatibility\n        '''\n        if wx.GetApp() is None:\n            self.app = wx.App( False )\n\n        # preprocess command line arguments and set to defaults\n        option_values, args = self.SUPER.parse_args(self, args, values)\n        for option in self.option_list:\n            if option.dest and hasattr(option_values, option.dest):\n                default = getattr(option_values, option.dest)\n                if default is not None:\n                    option.default = default\n\n        dlg = OptparseDialog( option_parser = self, title=self.get_description() )\n\n        if args:\n            dlg.args_ctrl.Value = ' '.join(args)\n\n        dlg_result = dlg.ShowModal()\n        if wx.ID_OK != dlg_result:\n            raise UserCancelledError( 'User has canceled' )\n\n        if values is None:\n            values = self.get_default_values()\n\n        option_values, args = dlg.getOptionsAndArgs()\n\n        for option, value in option_values.iteritems():\n            if ( 'store_true' == option.action ) and ( value is False ):\n                setattr( values, option.dest, False )\n                continue\n            if ( 'store_false' == option.action ) and ( value is True ):\n                setattr( values, option.dest, False )\n                continue\n\n            if option.takes_value() is False:\n                value = None\n\n            option.process( option, value, values, self )\n\n        q.put((values, args))", "response": "This method is used to parse command line arguments and set values to the values attribute of the options and the values attribute of the options object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef distance_from(self, lat, lon):\n        '''get distance from a point'''\n        lat1 = self.pkt['I105']['Lat']['val']\n        lon1 = self.pkt['I105']['Lon']['val']\n        return mp_util.gps_distance(lat1, lon1, lat, lon)", "response": "get distance from a point"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn height above ground in feet", "response": "def ground_height(self):\n        '''return height above ground in feet'''\n        lat = self.pkt['I105']['Lat']['val']\n        lon = self.pkt['I105']['Lon']['val']\n        global ElevationMap\n        ret = ElevationMap.GetElevation(lat, lon)\n        ret -= gen_settings.wgs84_to_AMSL\n        return ret * 3.2807"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmove position by bearing and distance", "response": "def move(self, bearing, distance):\n        '''move position by bearing and distance'''\n        lat = self.pkt['I105']['Lat']['val']\n        lon = self.pkt['I105']['Lon']['val']\n        (lat, lon) = mp_util.gps_newpos(lat, lon, bearing, distance)\n        self.setpos(lat, lon)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, deltat=1.0):\n        '''fly a square circuit'''\n        DNFZ.update(self, deltat)\n        self.dist_flown += self.speed * deltat\n        if self.dist_flown > self.circuit_width:\n            self.desired_heading = self.heading + 90\n            self.dist_flown = 0\n        if self.getalt() < self.ground_height() or self.getalt() > self.ground_height() + 2000:\n            self.randpos()\n            self.randalt()", "response": "update the state of the current object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the current state of the class", "response": "def update(self, deltat=1.0):\n        '''fly circles, then dive'''\n        DNFZ.update(self, deltat)\n        self.time_circling += deltat\n        self.setheading(self.heading + self.turn_rate * deltat)\n        self.move(self.drift_heading, self.drift_speed)\n        if self.getalt() > self.max_alt or self.getalt() < self.ground_height():\n            if self.getalt() > self.ground_height():\n                self.setclimbrate(self.dive_rate)\n            else:\n                self.setclimbrate(self.climb_rate)\n        if self.getalt() < self.ground_height():\n            self.setalt(self.ground_height())\n        if self.distance_from_home() > gen_settings.region_width:\n            self.randpos()\n            self.randalt()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, deltat=1.0):\n        '''fly in long curves'''\n        DNFZ.update(self, deltat)\n        if (self.distance_from_home() > gen_settings.region_width or\n            self.getalt() < self.ground_height() or\n            self.getalt() > self.ground_height() + 1000):\n            self.randpos()\n            self.randalt()", "response": "update the current state of the object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, deltat=1.0):\n        '''straight lines, with short life'''\n        DNFZ.update(self, deltat)\n        self.lifetime -= deltat\n        if self.lifetime <= 0:\n            self.randpos()\n            self.lifetime = random.uniform(300,600)", "response": "straight lines with short life"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndrop an object on the map", "response": "def cmd_dropobject(self, obj):\n        '''drop an object on the map'''\n        latlon = self.module('map').click_position\n        if self.last_click is not None and self.last_click == latlon:\n            return\n        self.last_click = latlon\n        if latlon is not None:\n            obj.setpos(latlon[0], latlon[1])\n            self.aircraft.append(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncommanding parser for genobstacles", "response": "def cmd_genobstacles(self, args):\n        '''genobstacles command parser'''\n        usage = \"usage: genobstacles <start|stop|restart|clearall|status|set>\"\n        if len(args) == 0:\n            print(usage)\n            return\n        if args[0] == \"set\":\n            gen_settings.command(args[1:])\n        elif args[0] == \"start\":\n            if self.have_home:\n                self.start()\n            else:\n                self.pending_start = True\n        elif args[0] == \"stop\":\n            self.stop()\n            self.pending_start = False\n        elif args[0] == \"restart\":\n            self.stop()\n            self.start()\n        elif args[0] == \"status\":\n            print(self.status())\n        elif args[0] == \"remove\":\n            latlon = self.module('map').click_position\n            if self.last_click is not None and self.last_click == latlon:\n                return\n            self.last_click = latlon\n            if latlon is not None:\n                closest = None\n                closest_distance = 1000\n                for a in self.aircraft:\n                    dist = a.distance_from(latlon[0], latlon[1])\n                    if dist < closest_distance:\n                        closest_distance = dist\n                        closest = a\n                if closest is not None:\n                    self.aircraft.remove(closest)\n                else:\n                    print(\"No obstacle found at click point\")\n                    \n        elif args[0] == \"dropcloud\":\n            self.cmd_dropobject(Weather())\n        elif args[0] == \"dropeagle\":\n            self.cmd_dropobject(BirdOfPrey())\n        elif args[0] == \"dropbird\":\n            self.cmd_dropobject(BirdMigrating())\n        elif args[0] == \"dropplane\":\n            self.cmd_dropobject(Aircraft())\n        elif args[0] == \"clearall\":\n            self.clearall()\n        else:\n            print(usage)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntriggers sends from ATTITUDE packets", "response": "def mavlink_packet(self, m):\n        '''trigger sends from ATTITUDE packets'''\n        if not self.have_home and m.get_type() == 'GPS_RAW_INT' and m.fix_type >= 3:\n            gen_settings.home_lat = m.lat * 1.0e-7\n            gen_settings.home_lon = m.lon * 1.0e-7\n            self.have_home = True\n            if self.pending_start:\n                self.start()\n        if m.get_type() != 'ATTITUDE':\n            return\n        t = self.get_time()\n        dt = t - self.last_t\n        if dt < 0 or dt > 10:\n            self.last_t = t\n            return\n        if dt > 10 or dt < 0.9:\n            return\n        self.last_t = t\n        for a in self.aircraft:\n            if not gen_settings.stop:\n                a.update(1.0)\n                self.pkt_queue.append(a.pickled())\n                while len(self.pkt_queue) > len(self.aircraft)*2:\n                    self.pkt_queue.pop(0)\n                    \n        if self.module('map') is not None and not self.menu_added_map:\n            self.menu_added_map = True\n            self.module('map').add_menu(self.menu)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, state, tnow):\n        '''update the threat state'''\n        self.state = state\n        self.update_time = tnow", "response": "update the threat state"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the distance between threats and vehicle", "response": "def update_threat_distances(self, latlonalt):\n        '''update the distance between threats and vehicle'''\n        for id in self.threat_vehicles.keys():\n            threat_latlonalt = (self.threat_vehicles[id].state['lat'] * 1e-7,\n                                self.threat_vehicles[id].state['lon'] * 1e-7,\n                                self.threat_vehicles[id].state['altitude'])\n\n            self.threat_vehicles[id].h_distance = self.get_h_distance(latlonalt, threat_latlonalt)\n            self.threat_vehicles[id].v_distance = self.get_v_distance(latlonalt, threat_latlonalt)\n\n            # calculate and set the total distance between threat and vehicle\n            self.threat_vehicles[id].distance = sqrt(\n                self.threat_vehicles[id].h_distance**2 + (self.threat_vehicles[id].v_distance)**2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_h_distance(self, latlonalt1, latlonalt2):\n        '''get the horizontal distance between threat and vehicle'''\n        (lat1, lon1, alt1) = latlonalt1\n        (lat2, lon2, alt2) = latlonalt2\n\n        lat1 = radians(lat1)\n        lon1 = radians(lon1)\n        lat2 = radians(lat2)\n        lon2 = radians(lon2)\n\n        dLat = lat2 - lat1\n        dLon = lon2 - lon1\n\n        # math as per mavextra.distance_two()\n        a = sin(0.5 * dLat)**2 + sin(0.5 * dLon)**2 * cos(lat1) * cos(lat2)\n        c = 2.0 * atan2(sqrt(a), sqrt(1.0 - a))\n        return 6371 * 1000 * c", "response": "get the horizontal distance between threat and vehicle"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the horizontal distance between threat and vehicle", "response": "def get_v_distance(self, latlonalt1, latlonalt2):\n        '''get the horizontal distance between threat and vehicle'''\n        (lat1, lon1, alt1) = latlonalt1\n        (lat2, lon2, alt2) = latlonalt2\n        return alt2 - alt1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_threat_timeout(self):\n        '''check and handle threat time out'''\n        for id in self.threat_vehicles.keys():\n            if self.threat_vehicles[id].update_time == 0:\n                self.threat_vehicles[id].update_time = self.get_time()\n            dt = self.get_time() - self.threat_vehicles[id].update_time\n            if dt > self.ADSB_settings.timeout:\n                # if the threat has timed out...\n                del self.threat_vehicles[id]  # remove the threat from the dict\n                for mp in self.module_matching('map*'):\n                    # remove the threat from the map\n                    mp.map.remove_object(id)\n                    mp.map.remove_object(id+\":circle\")\n                # we've modified the dict we're iterating over, so\n                # we'll get any more timed-out threats next time we're\n                # called:\n                return", "response": "check and handle threat time out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling an incoming mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        if m.get_type() == \"ADSB_VEHICLE\":\n            id = 'ADSB-' + str(m.ICAO_address)\n            if id not in self.threat_vehicles.keys():  # check to see if the vehicle is in the dict\n                # if not then add it\n                self.threat_vehicles[id] = ADSBVehicle(id=id, state=m.to_dict())\n                for mp in self.module_matching('map*'):\n                    from MAVProxy.modules.lib import mp_menu\n                    from MAVProxy.modules.mavproxy_map import mp_slipmap\n                    self.threat_vehicles[id].menu_item = mp_menu.MPMenuItem(name=id, returnkey=None)\n                    if m.emitter_type >= 100 and m.emitter_type-100 in obc_icons:\n                        icon = mp.map.icon(obc_icons[m.emitter_type-100])\n                        threat_radius = get_threat_radius(m.emitter_type-100)\n                    else:\n                        icon = mp.map.icon(self.threat_vehicles[id].icon)\n                        threat_radius = 0\n                    popup = mp_menu.MPMenuSubMenu('ADSB', items=[self.threat_vehicles[id].menu_item])\n                    # draw the vehicle on the map\n                    mp.map.add_object(mp_slipmap.SlipIcon(id, (m.lat * 1e-7, m.lon * 1e-7),\n                                                                    icon, layer=3, rotation=m.heading*0.01, follow=False,\n                                                                    trail=mp_slipmap.SlipTrail(colour=(0, 255, 255)),\n                                                                    popup_menu=popup))\n                    if threat_radius > 0:\n                        mp.map.add_object(mp_slipmap.SlipCircle(id+\":circle\", 3,\n                                                    (m.lat * 1e-7, m.lon * 1e-7),\n                                                    threat_radius, (0, 255, 255), linewidth=1))\n            else:  # the vehicle is in the dict\n                # update the dict entry\n                self.threat_vehicles[id].update(m.to_dict(), self.get_time())\n                for mp in self.module_matching('map*'):\n                    # update the map\n                    ground_alt = mp.ElevationMap.GetElevation(m.lat*1e-7, m.lon*1e-7)\n                    alt_amsl = m.altitude * 0.001\n                    if alt_amsl > 0:\n                        alt = int(alt_amsl - ground_alt)\n                        label = str(alt) + \"m\"\n                    else:\n                        label = None\n                    mp.map.set_position(id, (m.lat * 1e-7, m.lon * 1e-7), rotation=m.heading*0.01, label=label, colour=(0,250,250))\n                    mp.map.set_position(id+\":circle\", (m.lat * 1e-7, m.lon * 1e-7))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle an incoming mavlink packet", "response": "def mavlink_packet(self, msg):\n        '''handle an incoming mavlink packet'''\n        if not isinstance(self.checklist, mp_checklist.CheckUI):\n            return\n        if not self.checklist.is_alive():\n            return\n\n        type = msg.get_type()\n        master = self.master\n\n        if type == 'HEARTBEAT':\n            '''beforeEngineList - APM booted'''\n            if self.mpstate.status.heartbeat_error == True:\n                self.checklist.set_check(\"Pixhawk Booted\", 0)\n            else:\n                self.checklist.set_check(\"Pixhawk Booted\", 1)\n\n        '''beforeEngineList - Flight mode MANUAL'''\n        if self.mpstate.status.flightmode == \"MANUAL\":\n            self.checklist.set_check(\"Flight mode MANUAL\", 1)\n        else:\n            self.checklist.set_check(\"Flight mode MANUAL\", 0)\n\n        if type in [ 'GPS_RAW', 'GPS_RAW_INT' ]:\n            '''beforeEngineList - GPS lock'''\n            if ((msg.fix_type >= 3 and master.mavlink10()) or\n                (msg.fix_type == 2 and not master.mavlink10())):\n                self.checklist.set_check(\"GPS lock\", 1)\n            else:\n                self.checklist.set_check(\"GPS lock\", 0)\n\n        '''beforeEngineList - Radio Links > 6db margin TODO: figure out how to read db levels'''\n        if type in ['RADIO', 'RADIO_STATUS']:\n            if msg.rssi < msg.noise+6 or msg.remrssi < msg.remnoise+6:\n                self.checklist.set_check(\"Radio links > 6db margin\", 0)\n            else:\n                self.checklist.set_check(\"Radio Links > 6db margin\", 0)\n\n        if type == 'HWSTATUS':\n            '''beforeEngineList - Avionics Battery'''\n            if msg.Vcc >= 4600 and msg.Vcc <= 5300:\n                self.checklist.set_check(\"Avionics Power\", 1)\n            else:\n                self.checklist.set_check(\"Avionics Power\", 0)\n\n        if type == 'POWER_STATUS':\n            '''beforeEngineList - Servo Power'''\n            if msg.Vservo >= 4900 and msg.Vservo <= 6500:\n                self.checklist.set_check(\"Servo Power\", 1)\n            else:\n                self.checklist.set_check(\"Servo Power\", 0)\n\n        '''beforeEngineList - Waypoints Loaded'''\n        if type == 'HEARTBEAT':\n            if self.module('wp').wploader.count() == 0:\n                self.checklist.set_check(\"Waypoints Loaded\", 0)\n            else:\n                self.checklist.set_check(\"Waypoints Loaded\", 1)\n\n\t\t'''beforeTakeoffList - Compass active'''\n        if type == 'GPS_RAW':\n            if math.fabs(msg.hdg - master.field('VFR_HUD', 'heading', '-')) < 10 or math.fabs(msg.hdg - master.field('VFR_HUD', 'heading', '-')) > 355:\n                self.checklist.set_check(\"Compass active\", 1)\n            else:\n                self.checklist.set_check(\"Compass active\", 0)\n\n\t\t'''beforeCruiseList - Airspeed > 10 m/s , Altitude > 30 m'''\n        if type == 'VFR_HUD':\n            rel_alt = master.field('GLOBAL_POSITION_INT', 'relative_alt', 0) * 1.0e-3\n            if rel_alt > 30:\n                self.checklist.set_check(\"Altitude > 30 m\", 1)\n            else:\n                self.checklist.set_check(\"Altitude > 30 m\", 0)\n            if msg.airspeed > 10 or msg.groundspeed > 10:\n                self.checklist.set_check(\"Airspeed > 10 m/s\", 1)\n            else:\n                self.checklist.set_check(\"Airspeed > 10 m/s\", 0)\n\n\t\t'''beforeEngineList - IMU'''\n        if type in ['SYS_STATUS']:\n            sensors = { 'AS'  : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE,\n                        'MAG' : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_3D_MAG,\n                        'INS' : mavutil.mavlink.MAV_SYS_STATUS_SENSOR_3D_ACCEL | mavutil.mavlink.MAV_SYS_STATUS_SENSOR_3D_GYRO,\n                        'AHRS' : mavutil.mavlink.MAV_SYS_STATUS_AHRS}\n            bits = sensors['INS']\n            present = ((msg.onboard_control_sensors_enabled & bits) == bits)\n            healthy = ((msg.onboard_control_sensors_health & bits) == bits)\n            if not present or not healthy:\n                self.checklist.set_check(\"IMU Check\", 1)\n            else:\n                self.checklist.set_check(\"IMU Check\", 0)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the altitude ( m ASL ) of a given lat / long pair.", "response": "def GetElevation(self, latitude, longitude, timeout=0):\n        '''Returns the altitude (m ASL) of a given lat/long pair, or None if unknown'''\n        if latitude is None or longitude is None:\n            return None\n        if self.database == 'srtm':\n            TileID = (numpy.floor(latitude), numpy.floor(longitude))\n            if TileID in self.tileDict:\n                alt = self.tileDict[TileID].getAltitudeFromLatLon(latitude, longitude)\n            else:\n                tile = self.downloader.getTile(numpy.floor(latitude), numpy.floor(longitude))\n                if tile == 0:\n                    if timeout > 0:\n                        t0 = time.time()\n                        while time.time() < t0+timeout and tile == 0:\n                            tile = self.downloader.getTile(numpy.floor(latitude), numpy.floor(longitude))\n                            if tile == 0:\n                                time.sleep(0.1)\n                if tile == 0:\n                    return None\n                self.tileDict[TileID] = tile\n                alt = tile.getAltitudeFromLatLon(latitude, longitude)\n        if self.database == 'geoscience':\n             alt = self.mappy.getAltitudeAtPoint(latitude, longitude)\n        return alt"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_text_url(self, event):\n        '''handle double clicks on URL text'''\n        try:\n            import webbrowser\n        except ImportError:\n            return\n        mouse_event = event.GetMouseEvent()\n        if mouse_event.LeftDClick():\n            url_start = event.GetURLStart()\n            url_end = event.GetURLEnd()\n            url = self.control.GetRange(url_start, url_end)\n            try:\n                # attempt to use google-chrome\n                browser_controller = webbrowser.get('google-chrome')\n                browser_controller.open_new_tab(url)\n            except webbrowser.Error:\n                # use the system configured default browser\n                webbrowser.open_new_tab(url)", "response": "handle double clicks on URL text"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mavlink_packet(self, msg):\n        '''handle an incoming mavlink packet'''\n        type = msg.get_type()\n\n        master = self.master\n\n        # add some status fields\n        if type in [ 'RC_CHANNELS' ]:\n            ilock = self.get_rc_input(msg, self.interlock_channel)\n            if ilock <= 0:\n                self.console.set_status('ILOCK', 'ILOCK:--', fg='grey', row=4)\n            elif ilock >= 1800:\n                self.console.set_status('ILOCK', 'ILOCK:ON', fg='red', row=4)\n            else:\n                self.console.set_status('ILOCK', 'ILOCK:OFF', fg='green', row=4)\n\n            override = self.get_rc_input(msg, self.override_channel)\n            if override <= 0:\n                self.console.set_status('OVR', 'OVR:--', fg='grey', row=4)\n            elif override >= 1800:\n                self.console.set_status('OVR', 'OVR:ON', fg='red', row=4)\n            else:\n                self.console.set_status('OVR', 'OVR:OFF', fg='green', row=4)\n\n            zeroi = self.get_rc_input(msg, self.zero_I_channel)\n            if zeroi <= 0:\n                self.console.set_status('ZEROI', 'ZEROI:--', fg='grey', row=4)\n            elif zeroi >= 1800:\n                self.console.set_status('ZEROI', 'ZEROI:ON', fg='red', row=4)\n            else:\n                self.console.set_status('ZEROI', 'ZEROI:OFF', fg='green', row=4)\n\n            novtol = self.get_rc_input(msg, self.no_vtol_channel)\n            if novtol <= 0:\n                self.console.set_status('NOVTOL', 'NOVTOL:--', fg='grey', row=4)\n            elif novtol >= 1800:\n                self.console.set_status('NOVTOL', 'NOVTOL:ON', fg='red', row=4)\n            else:\n                self.console.set_status('NOVTOL', 'NOVTOL:OFF', fg='green', row=4)\n                \n        if type in [ 'SERVO_OUTPUT_RAW' ]:\n            rsc = self.get_pwm_output(msg, self.rsc_out_channel)\n            if rsc <= 0:\n                self.console.set_status('RSC', 'RSC:--', fg='grey', row=4)\n            elif rsc <= 1200:\n                self.console.set_status('RSC', 'RSC:%u' % rsc, fg='red', row=4)\n            elif rsc <= 1600:\n                self.console.set_status('RSC', 'RSC:%u' % rsc, fg='orange', row=4)\n            else:\n                self.console.set_status('RSC', 'RSC:%u' % rsc, fg='green', row=4)\n\n            thr = self.get_pwm_output(msg, self.fwd_thr_channel)\n            if thr <= 0:\n                self.console.set_status('FTHR', 'FTHR:--', fg='grey', row=4)\n            elif thr <= 1100:\n                self.console.set_status('FTHR', 'FTHR:%u' % thr, fg='red', row=4)\n            elif thr <= 1500:\n                self.console.set_status('FTHR', 'FTHR:%u' % thr, fg='orange', row=4)\n            else:\n                self.console.set_status('FTHR', 'FTHR:%u' % thr, fg='green', row=4)\n                \n        if type in [ 'RPM' ]:\n            rpm = msg.rpm1\n            if rpm < 1000:\n                rpm_colour = 'red'\n            elif rpm < 2000:\n                rpm_colour = 'orange'\n            else:\n                rpm_colour = 'green'\n            self.console.set_status('RPM', 'RPM: %u' % rpm, fg=rpm_colour, row=4)", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_channels(self):\n        '''update which channels provide input'''\n        self.interlock_channel = -1\n        self.override_channel = -1\n        self.zero_I_channel = -1\n        self.no_vtol_channel = -1\n\n        # output channels\n        self.rsc_out_channel = 9\n        self.fwd_thr_channel = 10\n\n        for ch in range(1,16):\n            option = self.get_mav_param(\"RC%u_OPTION\" % ch, 0)\n            if option == 32:\n                self.interlock_channel = ch;\n            elif option == 63:\n                self.override_channel = ch;\n            elif option == 64:\n                self.zero_I_channel = ch;\n            elif option == 65:\n                self.override_channel = ch;\n            elif option == 66:\n                self.no_vtol_channel = ch;\n\n            function = self.get_mav_param(\"SERVO%u_FUNCTION\" % ch, 0)\n            if function == 32:\n                self.rsc_out_channel = ch\n            if function == 70:\n                self.fwd_thr_channel = ch", "response": "update which channels provide input"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rallyloader(self):\n        '''rally loader by system ID'''\n        if not self.target_system in self.rallyloader_by_sysid:\n            self.rallyloader_by_sysid[self.target_system] = mavwp.MAVRallyLoader(self.settings.target_system,\n                                                                                 self.settings.target_component)\n        return self.rallyloader_by_sysid[self.target_system]", "response": "rally loader by system ID"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef idle_task(self):\n        '''called in idle time'''\n        try:\n            data = self.port.recv(1024) # Attempt to read up to 1024 bytes.\n        except socket.error as e:\n            if e.errno in [ errno.EAGAIN, errno.EWOULDBLOCK ]:\n                return\n            raise\n        try:\n            self.send_rtcm_msg(data)\n\n        except Exception as e:\n            print(\"DGPS: GPS Inject Failed:\", e)", "response": "called in idle time"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fpsInformation(self,args):\n        '''fps command'''\n        invalidStr = 'Invalid number of arguments. Usage horizon-fps set <fps> or horizon-fps get. Set fps to zero to get unrestricted framerate.'\n        if len(args)>0:\n            if args[0] == \"get\":\n                '''Get the current framerate.'''\n                if (self.fps == 0.0):\n                    print('Horizon Framerate: Unrestricted')\n                else:\n                    print(\"Horizon Framerate: \" + str(self.fps))\n            elif args[0] == \"set\":\n                if len(args)==2:\n                    self.fps = float(args[1])\n                    if (self.fps != 0):\n                        self.sendDelay = 1.0/self.fps\n                    else:\n                        self.sendDelay = 0.0\n                    self.msgList.append(FPS(self.fps))\n                    if (self.fps == 0.0):\n                        print('Horizon Framerate: Unrestricted')\n                    else:\n                        print(\"Horizon Framerate: \" + str(self.fps))\n                else:\n                    print(invalidStr)\n            else:\n                print(invalidStr)\n        else:\n            print(invalidStr)", "response": "Horizon FPS information command"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mavlink_packet(self, msg):\n        '''handle an incoming mavlink packet'''\n        msgType = msg.get_type()\n        master = self.master       \n        if msgType == 'HEARTBEAT':\n            # Update state and mode information\n            if type(master.motors_armed()) == type(True):\n                self.armed = master.motors_armed()\n                self.mode = master.flightmode\n                # Send Flight State information down pipe\n                self.msgList.append(FlightState(self.mode,self.armed))\n        elif msgType == 'ATTITUDE':\n            # Send attitude information down pipe\n            self.msgList.append(Attitude(msg))\n        elif msgType == 'VFR_HUD':\n            # Send HUD information down pipe\n            self.msgList.append(VFR_HUD(msg))\n        elif msgType == 'GLOBAL_POSITION_INT':\n            # Send altitude information down pipe\n            self.msgList.append(Global_Position_INT(msg,time.time()))\n        elif msgType == 'SYS_STATUS':\n            # Mode and Arm State\n            self.msgList.append(BatteryInfo(msg))\n        elif msgType in ['WAYPOINT_CURRENT', 'MISSION_CURRENT']:\n            # Waypoints\n            self.currentWP = msg.seq\n            self.finalWP = self.module('wp').wploader.count()\n            self.msgList.append(WaypointInfo(self.currentWP,self.finalWP,self.currentDist,self.nextWPTime,self.wpBearing))\n        elif msgType == 'NAV_CONTROLLER_OUTPUT':\n            self.currentDist = msg.wp_dist\n            self.speed = master.field('VFR_HUD', 'airspeed', 30)\n            if self.speed > 1:\n                self.nextWPTime = self.currentDist / self.speed\n            else:\n                self.nextWPTime = '-'\n            self.wpBearing = msg.target_bearing\n            self.msgList.append(WaypointInfo(self.currentWP,self.finalWP,self.currentDist,self.nextWPTime,self.wpBearing))", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the image to be displayed", "response": "def set_image(self, img):\n        '''set the image to be displayed'''\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            if hasattr(img, 'shape'):\n                (width, height) = (img.shape[1], img.shape[0])\n                self._bmp = wx.BitmapFromBuffer(width, height, np.uint8(img)) # http://stackoverflow.com/a/16866833/2559632\n            elif hasattr(img, 'GetHeight'):\n                self._bmp = wx.BitmapFromImage(img)\n            else:\n                print(\"Unsupported image type: %s\" % type(img))\n                return\n            self.SetMinSize((self._bmp.GetWidth(), self._bmp.GetHeight()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns information about module", "response": "def status(self):\n        '''returns information about module'''\n        if self.download is None:\n            return \"Not started\"\n\n        transferred = self.download - self.prev_download\n        self.prev_download = self.download\n        now = time.time()\n        interval = now - self.last_status_time\n        self.last_status_time = now\n        return(\"DFLogger: %(state)s Rate(%(interval)ds):%(rate).3fkB/s \"\n               \"Block:%(block_cnt)d Missing:%(missing)d Fixed:%(fixed)d \"\n               \"Abandoned:%(abandoned)d\" %\n               {\"interval\": interval,\n                \"rate\": transferred/(interval*1000),\n                \"block_cnt\": self.last_seqno,\n                \"missing\": len(self.missing_blocks),\n                \"fixed\": self.missing_found,\n                \"abandoned\": self.abandoned,\n                \"state\": \"Inactive\" if self.stopped else \"Active\"})"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprints out statistics every 10 seconds from idle loop", "response": "def idle_print_status(self):\n        '''print out statistics every 10 seconds from idle loop'''\n        now = time.time()\n        if (now - self.last_idle_status_printed_time) >= 10:\n            print(self.status())\n            self.last_idle_status_printed_time = now"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend packets to UAV in idle loop", "response": "def idle_send_acks_and_nacks(self):\n        '''Send packets to UAV in idle loop'''\n        max_blocks_to_send = 10\n        blocks_sent = 0\n        i = 0\n        now = time.time()\n        while (i < len(self.blocks_to_ack_and_nack) and\n               blocks_sent < max_blocks_to_send):\n            # print(\"ACKLIST: %s\" %\n            # ([x[1] for x in self.blocks_to_ack_and_nack],))\n            stuff = self.blocks_to_ack_and_nack[i]\n\n            [master, block, status, first_sent, last_sent] = stuff\n            if status == 1:\n                # print(\"DFLogger: ACKing block (%d)\" % (block,))\n                mavstatus = mavutil.mavlink.MAV_REMOTE_LOG_DATA_BLOCK_ACK\n                (target_sys, target_comp) = self.sender\n                self.master.mav.remote_log_block_status_send(target_sys,\n                                                             target_comp,\n                                                             block,\n                                                             mavstatus)\n                blocks_sent += 1\n                del self.acking_blocks[block]\n                del self.blocks_to_ack_and_nack[i]\n                continue\n\n            if block not in self.missing_blocks:\n                # we've received this block now\n                del self.blocks_to_ack_and_nack[i]\n                continue\n\n            # give up on packet if we have seen one with a much higher\n            # number (or after 60 seconds):\n            if (self.last_seqno - block > 200) or (now - first_sent > 60):\n                if self.log_settings.verbose:\n                    print(\"DFLogger: Abandoning block (%d)\" % (block,))\n                del self.blocks_to_ack_and_nack[i]\n                del self.missing_blocks[block]\n                self.abandoned += 1\n                continue\n\n            i += 1\n            # only send each nack every-so-often:\n            if last_sent is not None:\n                if now - last_sent < 0.1:\n                    continue\n\n            if self.log_settings.verbose:\n                print(\"DFLogger: Asking for block (%d)\" % (block,))\n            mavstatus = mavutil.mavlink.MAV_REMOTE_LOG_DATA_BLOCK_NACK\n            (target_sys, target_comp) = self.sender\n            self.master.mav.remote_log_block_status_send(target_sys,\n                                                         target_comp,\n                                                         block,\n                                                         mavstatus)\n            blocks_sent += 1\n            stuff[4] = now"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a stop packet", "response": "def tell_sender_to_stop(self, m):\n        '''send a stop packet (if we haven't sent one in the last second)'''\n        now = time.time()\n        if now - self.time_last_stop_packet_sent < 1:\n            return\n        if self.log_settings.verbose:\n            print(\"DFLogger: Sending stop packet\")\n        self.time_last_stop_packet_sent = now\n        self.master.mav.remote_log_block_status_send(\n            m.get_srcSystem(),\n            m.get_srcComponent(),\n            mavutil.mavlink.MAV_REMOTE_LOG_DATA_BLOCK_STOP,\n            1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a start packet", "response": "def tell_sender_to_start(self):\n        '''send a start packet (if we haven't sent one in the last second)'''\n        now = time.time()\n        if now - self.time_last_start_packet_sent < 1:\n            return\n        self.time_last_start_packet_sent = now\n\n        if self.log_settings.verbose:\n            print(\"DFLogger: Sending start packet\")\n\n        target_sys = self.log_settings.df_target_system\n        target_comp = self.log_settings.df_target_component\n        self.master.mav.remote_log_block_status_send(\n            target_sys,\n            target_comp,\n            mavutil.mavlink.MAV_REMOTE_LOG_DATA_BLOCK_START,\n            1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef packet_is_for_me(self, m):\n        '''returns true if this packet is appropriately addressed'''\n        if m.target_system != self.master.mav.srcSystem:\n            return False\n        if m.target_component != self.master.mav.srcComponent:\n            return False\n        # if have a sender we can also check the source address:\n        if self.sender is not None:\n            if (m.get_srcSystem(), m.get_srcComponent()) != self.sender:\n                return False\n        return True", "response": "returns true if this packet is appropriately addressed"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef new_figure_manager_given_figure(num, figure):\n    frame = FigureFrameWxAgg(num, figure)\n    figmgr = frame.get_figure_manager()\n    if matplotlib.is_interactive():\n        figmgr.frame.Show()\n    return figmgr", "response": "Create a new figure manager instance for the given figure."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _convert_agg_to_wx_image(agg, bbox):\n    if bbox is None:\n        # agg => rgb -> image\n        image = wx.EmptyImage(int(agg.width), int(agg.height))\n        image.SetData(agg.tostring_rgb())\n        return image\n    else:\n        # agg => rgba buffer -> bitmap => clipped bitmap => image\n        return wx.ImageFromBitmap(_WX28_clipped_agg_as_bitmap(agg, bbox))", "response": "Convert the region of the agg buffer bounded by bbox to a wx. Image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert the region of the agg buffer bounded by bbox to a wx. Bitmap.", "response": "def _convert_agg_to_wx_bitmap(agg, bbox):\n    \"\"\"\n    Convert the region of the agg buffer bounded by bbox to a wx.Bitmap.  If\n    bbox is None, the entire buffer is converted.\n\n    Note: agg must be a backend_agg.RendererAgg instance.\n    \"\"\"\n    if bbox is None:\n        # agg => rgba buffer -> bitmap\n        return wx.BitmapFromBufferRGBA(int(agg.width), int(agg.height),\n            agg.buffer_rgba())\n    else:\n        # agg => rgba buffer -> bitmap => clipped bitmap\n        return _WX28_clipped_agg_as_bitmap(agg, bbox)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the region of a the agg buffer bounded by bbox to a wx. Bitmap.", "response": "def _WX28_clipped_agg_as_bitmap(agg, bbox):\n    \"\"\"\n    Convert the region of a the agg buffer bounded by bbox to a wx.Bitmap.\n\n    Note: agg must be a backend_agg.RendererAgg instance.\n    \"\"\"\n    l, b, width, height = bbox.bounds\n    r = l + width\n    t = b + height\n\n    srcBmp = wx.BitmapFromBufferRGBA(int(agg.width), int(agg.height),\n        agg.buffer_rgba())\n    srcDC = wx.MemoryDC()\n    srcDC.SelectObject(srcBmp)\n\n    destBmp = wx.EmptyBitmap(int(width), int(height))\n    destDC = wx.MemoryDC()\n    destDC.SelectObject(destBmp)\n\n    destDC.BeginDrawing()\n    x = int(l)\n    y = int(int(agg.height) - t)\n    destDC.Blit(0, 0, int(width), int(height), srcDC, x, y)\n    destDC.EndDrawing()\n\n    srcDC.SelectObject(wx.NullBitmap)\n    destDC.SelectObject(wx.NullBitmap)\n\n    return destBmp"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef draw(self, drawDC=None):\n        DEBUG_MSG(\"draw()\", 1, self)\n        FigureCanvasAgg.draw(self)\n\n        self.bitmap = _convert_agg_to_wx_bitmap(self.get_renderer(), None)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)", "response": "Render the figure using agg."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef blit(self, bbox=None):\n        if bbox is None:\n            self.bitmap = _convert_agg_to_wx_bitmap(self.get_renderer(), None)\n            self.gui_repaint()\n            return\n\n        l, b, w, h = bbox.bounds\n        r = l + w\n        t = b + h\n        x = int(l)\n        y = int(self.bitmap.GetHeight() - t)\n\n        srcBmp = _convert_agg_to_wx_bitmap(self.get_renderer(), None)\n        srcDC = wx.MemoryDC()\n        srcDC.SelectObject(srcBmp)\n\n        destDC = wx.MemoryDC()\n        destDC.SelectObject(self.bitmap)\n\n        destDC.BeginDrawing()\n        destDC.Blit(x, y, int(w), int(h), srcDC, x, y)\n        destDC.EndDrawing()\n\n        destDC.SelectObject(wx.NullBitmap)\n        srcDC.SelectObject(wx.NullBitmap)\n        self.gui_repaint()", "response": "Transfer the region of the agg buffer defined by bbox to the display."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite to the console", "response": "def write(self, text, fg='black', bg='white'):\n        '''write to the console'''\n        if isinstance(text, str):\n            sys.stdout.write(text)\n        else:\n            sys.stdout.write(str(text))\n        sys.stdout.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        if self.gcs_location is None and self.module('wp').wploader.count() > 0:\n            home = self.module('wp').get_home()\n            self.gcs_location = (home.x, home.y)\n            print(\"Antenna home set\")\n        if self.gcs_location is None:\n            return\n        if m.get_type() == 'GPS_RAW' and self.gcs_location is not None:\n            (gcs_lat, gcs_lon) = self.gcs_location\n            bearing = cuav_util.gps_bearing(gcs_lat, gcs_lon, m.lat, m.lon)\n        elif m.get_type() == 'GPS_RAW_INT' and self.gcs_location is not None:\n            (gcs_lat, gcs_lon) = self.gcs_location\n            bearing = cuav_util.gps_bearing(gcs_lat, gcs_lon, m.lat / 1.0e7, m.lon / 1.0e7)\n        else:\n            return\n        self.console.set_status('Antenna', 'Antenna %.0f' % bearing, row=0)\n        if abs(bearing - self.last_bearing) > 5 and (time.time() - self.last_announce) > 15:\n            self.last_bearing = bearing\n            self.last_announce = time.time()\n            self.say(\"Antenna %u\" % int(bearing + 0.5))", "response": "handle an incoming mavlink packet"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_rccal(self, args):\n        '''start/stop RC calibration'''\n        if len(args) < 1:\n            self.print_cal_usage()\n            return\n\n        if (args[0] == \"start\"):\n            if len(args) > 1:\n                self.num_channels = int(args[1])\n            print(\"Calibrating %u channels\" % self.num_channels)\n            print(\"WARNING: remove propellers from electric planes!!\")\n            print(\"Push return when ready to calibrate.\")\n            raw_input()\n\n            self.clear_rc_cal()\n            self.calibrating = True\n        elif (args[0] == \"done\"):\n            self.calibrating = False\n            self.apply_rc_cal()\n        else:\n            self.print_cal_usage()", "response": "start stop RC calibration"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling an incoming mavlink packet", "response": "def mavlink_packet(self, m):\n        '''handle an incoming mavlink packet'''\n        #do nothing if not caibrating\n        if (self.calibrating == False):\n            return\n\n        if m.get_type() == 'RC_CHANNELS_RAW':\n            for i in range(1,self.num_channels+1):\n                v = getattr(m, 'chan%u_raw' % i)\n\n                if self.get_cal_min(i) > v:\n                    self.set_cal_min(i,v)\n                    self.console.writeln(\"Calibrating: RC%u_MIN=%u\" % (i, v))\n                if self.get_cal_max(i) < v:\n                    self.set_cal_max(i,v)\n                    self.console.writeln(\"Calibrating: RC%u_MAX=%u\" % (i, v))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a passphrase to a 32 byte key", "response": "def passphrase_to_key(self, passphrase):\n        '''convert a passphrase to a 32 byte key'''\n        import hashlib\n        h = hashlib.new('sha256')\n        h.update(passphrase)\n        return h.digest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef allow_unsigned(self, mav, msgId):\n        '''see if an unsigned packet should be allowed'''\n        if self.allow is None:\n            self.allow = {\n                mavutil.mavlink.MAVLINK_MSG_ID_RADIO : True,\n                mavutil.mavlink.MAVLINK_MSG_ID_RADIO_STATUS : True\n                }\n        if msgId in self.allow:\n            return True\n        if self.settings.allow_unsigned:\n            return True\n        return False", "response": "see if an unsigned packet should be allowed"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cmd_signing_key(self, args):\n        '''set signing key on connection'''\n        if len(args) == 0:\n            print(\"usage: signing setup passphrase\")\n            return\n        if not self.master.mavlink20():\n            print(\"You must be using MAVLink2 for signing\")\n            return\n        passphrase = args[0]\n        key = self.passphrase_to_key(passphrase)\n        self.master.setup_signing(key, sign_outgoing=True, allow_unsigned_callback=self.allow_unsigned)\n        print(\"Setup signing key\")", "response": "set signing key on connection"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves signing from server", "response": "def cmd_signing_remove(self, args):\n        '''remove signing from server'''\n        if not self.master.mavlink20():\n            print(\"You must be using MAVLink2 for signing\")\n            return\n        self.master.mav.setup_signing_send(self.target_system, self.target_component, [0]*32, 0)\n        self.master.disable_signing()\n        print(\"Removed signing\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Draw(self, grid, attr, dc, rect, row, col, isSelected):\n        dc.SetBrush(wx.Brush(wx.SystemSettings.GetColour(\n            wx.SYS_COLOUR_BTNFACE)))\n        dc.DrawRectangle( rect.GetX(), rect.GetY(), rect.GetWidth(), rect.GetHeight())\n        #draw a shaded rectangle to emulate a button\n        #(taken from src/generic/renderg.cpp)\n        strength = 1\n        pen1 = wx.Pen(wx.WHITE, strength)\n        dc.SetPen(pen1)\n        dc.DrawLine(rect.GetLeft()+strength-1, rect.GetTop()+strength-1,\n                rect.GetLeft()+strength-1, rect.GetBottom()-strength+1)\n        dc.DrawLine(rect.GetLeft()+strength-1, rect.GetTop()+strength-1,\n                rect.GetRight()-strength, rect.GetTop()+strength-1)\n        pen2 = wx.Pen(wx.BLACK, strength)\n        dc.SetPen(pen2)\n        dc.DrawLine(rect.GetRight()-strength, rect.GetTop(),\n                rect.GetRight()-strength, rect.GetBottom());\n        dc.DrawLine(rect.GetLeft(), rect.GetBottom(),\n                rect.GetRight() - strength, rect.GetBottom());\n\n        '''\n        #another drawing routine\n        #(taken from src/generic/renderg.cpp)\n        #Could port this later for animating the button when clicking\n\n  const wxCoord x = rect.x,\n                y = rect.y,\n                w = rect.width,\n                h = rect.height;\n\n  dc.SetBrush(*wxTRANSPARENT_BRUSH);\n\n  wxPen pen(*wxBLACK, 1);\n\n  dc.SetPen(pen);\n  dc.DrawLine( x+w, y, x+w, y+h );            // right (outer)\n  dc.DrawRectangle( x, y+h, w+1, 1 );         // bottom (outer)\n\n  pen.SetColour(wxColour(wxT(\"DARK GREY\")));\n  dc.SetPen(pen);\n  dc.DrawLine( x+w-1, y, x+w-1, y+h );        // right (inner)\n  dc.DrawRectangle( x+1, y+h-1, w-2, 1 );     // bottom (inner)\n\n  pen.SetColour(*wxWHITE);\n  dc.SetPen(pen);\n  dc.DrawRectangle( x, y, w, 1 );             // top (outer)\n  dc.DrawRectangle( x, y, 1, h );             // left (outer)\n  dc.DrawLine( x, y+h-1, x+1, y+h-1 );\n  dc.DrawLine( x+w-1, y, x+w-1, y+1 );\n        '''\n\n        # draw the button-label\n        dc.SetBackgroundMode(wx.TRANSPARENT )\n        dc.SetTextForeground(attr.GetTextColour() )\n        dc.SetFont( attr.GetFont() )\n        #dc.DrawLabel( wxT(\"Delete\"), rect,\n        dc.DrawLabel( self.label, rect,\n                wx.ALIGN_CENTER_VERTICAL | wx.ALIGN_CENTER_HORIZONTAL)", "response": "This method draws the area of the current page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding new output for a specific MAVLink sysID", "response": "def cmd_output_sysid(self, args):\n        '''add new output for a specific MAVLink sysID'''\n        sysid = int(args[0])\n        device = args[1]\n        print(\"Adding output %s for sysid %u\" % (device, sysid))\n        try:\n            conn = mavutil.mavlink_connection(device, input=False, source_system=self.settings.source_system)\n            conn.mav.srcComponent = self.settings.source_component\n        except Exception:\n            print(\"Failed to connect to %s\" % device)\n            return\n        try:\n            mp_util.child_fd_list_add(conn.port.fileno())\n        except Exception:\n            pass\n        if sysid in self.mpstate.sysid_outputs:\n            self.mpstate.sysid_outputs[sysid].close()\n        self.mpstate.sysid_outputs[sysid] = conn"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset center of view", "response": "def set_center(self, lat, lon):\n        '''set center of view'''\n        self.object_queue.put(SlipCenter((lat,lon)))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting follow on or off on an object", "response": "def set_follow_object(self, key, enable):\n        '''set follow on/off on an object'''\n        self.object_queue.put(SlipFollowObject(key, enable))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn next event or None", "response": "def get_event(self):\n        '''return next event or None'''\n        if self.event_queue.qsize() == 0:\n            return None\n        evt = self.event_queue.get()\n        while isinstance(evt, win_layout.WinLayout):\n            win_layout.set_layout(evt, self.set_layout)\n            if self.event_queue.qsize() == 0:\n                return None\n            evt = self.event_queue.get()\n        return evt"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef PILTowx(pimg):\n    '''convert a PIL Image to a wx image'''\n    from MAVProxy.modules.lib.wx_loader import wx\n    wimg = wx.EmptyImage(pimg.size[0], pimg.size[1])\n    try:\n        wimg.SetData(pimg.convert('RGB').tobytes())\n    except NotImplementedError:\n        # old, removed method:\n        wimg.SetData(pimg.convert('RGB').tostring())\n    return wimg", "response": "convert a PIL Image to a wx image"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dot_mavproxy(name=None):\n    '''return a path to store mavproxy data'''\n    if 'HOME' not in os.environ:\n        dir = os.path.join(os.environ['LOCALAPPDATA'], '.mavproxy')\n    else:\n        dir = os.path.join(os.environ['HOME'], '.mavproxy')\n    mkdir_p(dir)\n    if name is None:\n        return dir\n    return os.path.join(dir, name)", "response": "return a path to store mavproxy data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading a URL and return the content", "response": "def download_url(url):\n    '''download a URL and return the content'''\n    if sys.version_info.major < 3:\n        from urllib2 import urlopen as url_open\n        from urllib2 import URLError as url_error\n    else:\n        from urllib.request import urlopen as url_open\n        from urllib.error import URLError as url_error\n    try:\n        resp = url_open(url)\n        headers = resp.info()\n    except url_error as e:\n        print('Error downloading %s' % url)\n        return None\n    return resp.read()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndownload an array of files", "response": "def download_files(files):\n    '''download an array of files'''\n    for (url, file) in files:\n        print(\"Downloading %s as %s\" % (url, file))\n        data = download_url(url)\n        if data is None:\n            continue\n        try:\n            open(file, mode='wb').write(data)\n        except Exception as e:\n            print(\"Failed to save to %s : %s\" % (file, e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nnulls terminate a string for py3", "response": "def null_term(str):\n    '''null terminate a string for py3'''\n    if sys.version_info.major < 3:\n        return str\n    if isinstance(str, bytes):\n        str = str.decode(\"utf-8\")\n    idx = str.find(\"\\0\")\n    if idx != -1:\n        str = str[:idx]\n    return str"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndecodes one device ID. Used for MAVProxy and MAVExplorer", "response": "def decode_devid(devid, pname):\n    '''decode one device ID. Used for 'devid' command in mavproxy and MAVExplorer'''\n    devid = int(devid)\n    if devid == 0:\n        return\n\n    bus_type=devid & 0x07\n    bus=(devid>>3) & 0x1F\n    address=(devid>>8)&0xFF\n    devtype=(devid>>16)\n\n    bustypes = {\n        1: \"I2C\",\n        2: \"SPI\",\n        3: \"UAVCAN\",\n        4: \"SITL\"\n        }\n\n    compass_types = {\n        0x01 : \"DEVTYPE_HMC5883_OLD\",\n        0x07 : \"DEVTYPE_HMC5883\",\n        0x02 : \"DEVTYPE_LSM303D\",\n        0x04 : \"DEVTYPE_AK8963 \",\n        0x05 : \"DEVTYPE_BMM150 \",\n        0x06 : \"DEVTYPE_LSM9DS1\",\n        0x08 : \"DEVTYPE_LIS3MDL\",\n        0x09 : \"DEVTYPE_AK09916\",\n        0x0A : \"DEVTYPE_IST8310\",\n        0x0B : \"DEVTYPE_ICM20948\",\n        0x0C : \"DEVTYPE_MMC3416\",\n        0x0D : \"DEVTYPE_QMC5883L\",\n        0x0E : \"DEVTYPE_MAG3110\",\n        0x0F : \"DEVTYPE_SITL\",\n        0x10 : \"DEVTYPE_IST8308\",\n        0x11 : \"DEVTYPE_RM3100\",\n        }\n\n    imu_types = {\n        0x09 : \"DEVTYPE_BMI160\",\n        0x10 : \"DEVTYPE_L3G4200D\",\n        0x11 : \"DEVTYPE_ACC_LSM303D\",\n        0x12 : \"DEVTYPE_ACC_BMA180\",\n        0x13 : \"DEVTYPE_ACC_MPU6000\",\n        0x16 : \"DEVTYPE_ACC_MPU9250\",\n        0x17 : \"DEVTYPE_ACC_IIS328DQ\",\n        0x21 : \"DEVTYPE_GYR_MPU6000\",\n        0x22 : \"DEVTYPE_GYR_L3GD20\",\n        0x24 : \"DEVTYPE_GYR_MPU9250\",\n        0x25 : \"DEVTYPE_GYR_I3G4250D\",\n        0x26 : \"DEVTYPE_GYR_LSM9DS1\",\n        0x27 : \"DEVTYPE_INS_ICM20789\",\n        0x28 : \"DEVTYPE_INS_ICM20689\",\n        0x29 : \"DEVTYPE_INS_BMI055\",\n        0x2A : \"DEVTYPE_SITL\",\n        0x2B : \"DEVTYPE_INS_BMI088\",\n        0x2C : \"DEVTYPE_INS_ICM20948\",\n        0x2D : \"DEVTYPE_INS_ICM20648\",\n        0x2E : \"DEVTYPE_INS_ICM20649\",\n        0x2F : \"DEVTYPE_INS_ICM20602\",\n        }\n\n    decoded_devname = \"\"\n\n    if pname.startswith(\"COMPASS\"):\n        decoded_devname = compass_types.get(devtype, \"UNKNOWN\")\n\n    if pname.startswith(\"INS\"):\n        decoded_devname = imu_types.get(devtype, \"UNKNOWN\")\n\n    print(\"%s: bus_type:%s(%u)  bus:%u address:%u(0x%x) devtype:%u(0x%x) %s\" % (\n        pname,\n        bustypes.get(bus_type,\"UNKNOWN\"), bus_type,\n        bus, address, address, devtype, devtype, decoded_devname))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npopulating the Django user object with the default bind credentials.", "response": "def populate_user(self):\n        \"\"\"\n        Populates the Django user object using the default bind credentials.\n        \"\"\"\n        user = None\n\n        try:\n            # self.attrs will only be non-None if we were able to load this user\n            # from the LDAP directory, so this filters out nonexistent users.\n            if self.attrs is not None:\n                self._get_or_create_user(force_populate=True)\n\n            user = self._user\n        except ldap.LDAPError as e:\n            results = ldap_error.send(\n                self.backend.__class__,\n                context=\"populate_user\",\n                user=self._user,\n                exception=e,\n            )\n            if len(results) == 0:\n                logger.warning(\n                    \"Caught LDAPError while authenticating {}: {}\".format(\n                        self._username, pprint.pformat(e)\n                    )\n                )\n        except Exception as e:\n            logger.warning(\"{} while authenticating {}\".format(e, self._username))\n            raise\n\n        return user"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbinds to the LDAP server with the user s DN and password. Raises AuthenticationFailed on failure.", "response": "def _authenticate_user_dn(self, password):\n        \"\"\"\n        Binds to the LDAP server with the user's DN and password. Raises\n        AuthenticationFailed on failure.\n        \"\"\"\n        if self.dn is None:\n            raise self.AuthenticationFailed(\"failed to map the username to a DN.\")\n\n        try:\n            sticky = self.settings.BIND_AS_AUTHENTICATING_USER\n\n            self._bind_as(self.dn, password, sticky=sticky)\n        except ldap.INVALID_CREDENTIALS:\n            raise self.AuthenticationFailed(\"user DN/password rejected by LDAP server.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads the user DN from LDAP and sets it in the self. _user_dn attribute.", "response": "def _load_user_dn(self):\n        \"\"\"\n        Populates self._user_dn with the distinguished name of our user.\n\n        This will either construct the DN from a template in\n        AUTH_LDAP_USER_DN_TEMPLATE or connect to the server and search for it.\n        If we have to search, we'll cache the DN.\n\n        \"\"\"\n        if self._using_simple_bind_mode():\n            self._user_dn = self._construct_simple_user_dn()\n        else:\n            if self.settings.CACHE_TIMEOUT > 0:\n                cache_key = valid_cache_key(\n                    \"django_auth_ldap.user_dn.{}\".format(self._username)\n                )\n                self._user_dn = cache.get_or_set(\n                    cache_key, self._search_for_user_dn, self.settings.CACHE_TIMEOUT\n                )\n            else:\n                self._user_dn = self._search_for_user_dn()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _search_for_user_dn(self):\n        search = self.settings.USER_SEARCH\n        if search is None:\n            raise ImproperlyConfigured(\n                \"AUTH_LDAP_USER_SEARCH must be an LDAPSearch instance.\"\n            )\n\n        results = search.execute(self.connection, {\"user\": self._username})\n        if results is not None and len(results) == 1:\n            (user_dn, self._user_attrs) = next(iter(results))\n        else:\n            user_dn = None\n\n        return user_dn", "response": "Searches the directory for a user matching AUTH_LDAP_USER_SEARCH. Returns the user DN and attributes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_required_group(self):\n        required_group_dn = self.settings.REQUIRE_GROUP\n\n        if required_group_dn is not None:\n            if not isinstance(required_group_dn, LDAPGroupQuery):\n                required_group_dn = LDAPGroupQuery(required_group_dn)\n            result = required_group_dn.resolve(self)\n            if not result:\n                raise self.AuthenticationFailed(\n                    \"user does not satisfy AUTH_LDAP_REQUIRE_GROUP\"\n                )\n\n        return True", "response": "Checks if the LDAP group requirement is met."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if the negative group requirement is met.", "response": "def _check_denied_group(self):\n        \"\"\"\n        Returns True if the negative group requirement (AUTH_LDAP_DENY_GROUP)\n        is met. Always returns True if AUTH_LDAP_DENY_GROUP is None.\n        \"\"\"\n        denied_group_dn = self.settings.DENY_GROUP\n\n        if denied_group_dn is not None:\n            is_member = self._get_groups().is_member_of(denied_group_dn)\n            if is_member:\n                raise self.AuthenticationFailed(\n                    \"user does not satisfy AUTH_LDAP_DENY_GROUP\"\n                )\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload the User model object from the database or creates it if it doesn t exist.", "response": "def _get_or_create_user(self, force_populate=False):\n        \"\"\"\n        Loads the User model object from the database or creates it if it\n        doesn't exist. Also populates the fields, subject to\n        AUTH_LDAP_ALWAYS_UPDATE_USER.\n        \"\"\"\n        save_user = False\n\n        username = self.backend.ldap_to_django_username(self._username)\n\n        self._user, built = self.backend.get_or_build_user(username, self)\n        self._user.ldap_user = self\n        self._user.ldap_username = self._username\n\n        should_populate = force_populate or self.settings.ALWAYS_UPDATE_USER or built\n\n        if built:\n            if self.settings.NO_NEW_USERS:\n                raise self.AuthenticationFailed(\n                    \"user does not satisfy AUTH_LDAP_NO_NEW_USERS\"\n                )\n\n            logger.debug(\"Creating Django user {}\".format(username))\n            self._user.set_unusable_password()\n            save_user = True\n\n        if should_populate:\n            logger.debug(\"Populating Django user {}\".format(username))\n            self._populate_user()\n            save_user = True\n\n            # Give the client a chance to finish populating the user just\n            # before saving.\n            populate_user.send(self.backend.__class__, user=self._user, ldap_user=self)\n\n        if save_user:\n            self._user.save()\n\n        # This has to wait until we're sure the user has a pk.\n        if self.settings.MIRROR_GROUPS or self.settings.MIRROR_GROUPS_EXCEPT:\n            self._normalize_mirror_settings()\n            self._mirror_groups()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _normalize_group_dns(self, group_dns):\n        if isinstance(group_dns, LDAPGroupQuery):\n            query = group_dns\n        elif isinstance(group_dns, str):\n            query = LDAPGroupQuery(group_dns)\n        elif isinstance(group_dns, (list, tuple)) and len(group_dns) > 0:\n            query = reduce(operator.or_, map(LDAPGroupQuery, group_dns))\n        else:\n            raise ValueError(group_dns)\n\n        return query", "response": "Converts one or more group DNs to an LDAPGroupQuery."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _normalize_mirror_settings(self):\n\n        def malformed_mirror_groups_except():\n            return ImproperlyConfigured(\n                \"{} must be a collection of group names\".format(\n                    self.settings._name(\"MIRROR_GROUPS_EXCEPT\")\n                )\n            )\n\n        def malformed_mirror_groups():\n            return ImproperlyConfigured(\n                \"{} must be True or a collection of group names\".format(\n                    self.settings._name(\"MIRROR_GROUPS\")\n                )\n            )\n\n        mge = self.settings.MIRROR_GROUPS_EXCEPT\n        mg = self.settings.MIRROR_GROUPS\n\n        if mge is not None:\n            if isinstance(mge, (set, frozenset)):\n                pass\n            elif isinstance(mge, (list, tuple)):\n                mge = self.settings.MIRROR_GROUPS_EXCEPT = frozenset(mge)\n            else:\n                raise malformed_mirror_groups_except()\n\n            if not all(isinstance(value, str) for value in mge):\n                raise malformed_mirror_groups_except()\n            elif mg:\n                warnings.warn(\n                    ConfigurationWarning(\n                        \"Ignoring {} in favor of {}\".format(\n                            self.settings._name(\"MIRROR_GROUPS\"),\n                            self.settings._name(\"MIRROR_GROUPS_EXCEPT\"),\n                        )\n                    )\n                )\n                mg = self.settings.MIRROR_GROUPS = None\n\n        if mg is not None:\n            if isinstance(mg, (bool, set, frozenset)):\n                pass\n            elif isinstance(mg, (list, tuple)):\n                mg = self.settings.MIRROR_GROUPS = frozenset(mg)\n            else:\n                raise malformed_mirror_groups()\n\n            if isinstance(mg, (set, frozenset)) and (\n                not all(isinstance(value, str) for value in mg)\n            ):\n                raise malformed_mirror_groups()", "response": "Validates the group mirroring settings and converts them as necessary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _mirror_groups(self):\n        target_group_names = frozenset(self._get_groups().get_group_names())\n        current_group_names = frozenset(\n            self._user.groups.values_list(\"name\", flat=True).iterator()\n        )\n\n        # These were normalized to sets above.\n        MIRROR_GROUPS_EXCEPT = self.settings.MIRROR_GROUPS_EXCEPT\n        MIRROR_GROUPS = self.settings.MIRROR_GROUPS\n\n        # If the settings are white- or black-listing groups, we'll update\n        # target_group_names such that we won't modify the membership of groups\n        # beyond our purview.\n        if isinstance(MIRROR_GROUPS_EXCEPT, (set, frozenset)):\n            target_group_names = (target_group_names - MIRROR_GROUPS_EXCEPT) | (\n                current_group_names & MIRROR_GROUPS_EXCEPT\n            )\n        elif isinstance(MIRROR_GROUPS, (set, frozenset)):\n            target_group_names = (target_group_names & MIRROR_GROUPS) | (\n                current_group_names - MIRROR_GROUPS\n            )\n\n        if target_group_names != current_group_names:\n            existing_groups = list(\n                Group.objects.filter(name__in=target_group_names).iterator()\n            )\n            existing_group_names = frozenset(group.name for group in existing_groups)\n\n            new_groups = [\n                Group.objects.get_or_create(name=name)[0]\n                for name in target_group_names\n                if name not in existing_group_names\n            ]\n\n            self._user.groups.set(existing_groups + new_groups)", "response": "Mirrors the LDAP groups in the Django database and updates the user s membership."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_groups(self):\n        if self._groups is None:\n            self._groups = _LDAPUserGroups(self)\n\n        return self._groups", "response": "Returns an _LDAPUserGroups object which can determine group\n        membership."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _bind(self):\n        self._bind_as(self.settings.BIND_DN, self.settings.BIND_PASSWORD, sticky=True)", "response": "Binds to LDAP server with LDAP_BIND_DN and LDAP_BIND_PASSWORD."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _bind_as(self, bind_dn, bind_password, sticky=False):\n        self._get_connection().simple_bind_s(bind_dn, bind_password)\n\n        self._connection_bound = sticky", "response": "Bind to the LDAP server with the given credentials."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_connection(self):\n        if self._connection is None:\n            uri = self.settings.SERVER_URI\n            if callable(uri):\n                if func_supports_parameter(uri, \"request\"):\n                    uri = uri(self._request)\n                else:\n                    warnings.warn(\n                        \"Update AUTH_LDAP_SERVER_URI callable %s.%s to accept \"\n                        \"a positional `request` argument. Support for callables \"\n                        \"accepting no arguments will be removed in a future \"\n                        \"version.\" % (uri.__module__, uri.__name__),\n                        DeprecationWarning,\n                    )\n                    uri = uri()\n\n            self._connection = self.backend.ldap.initialize(uri, bytes_mode=False)\n\n            for opt, value in self.settings.CONNECTION_OPTIONS.items():\n                self._connection.set_option(opt, value)\n\n            if self.settings.START_TLS:\n                logger.debug(\"Initiating TLS\")\n                self._connection.start_tls_s()\n\n        return self._connection", "response": "Returns our LDAPObject which may or may not be bound."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _init_group_settings(self):\n        self._group_type = self.settings.GROUP_TYPE\n        if self._group_type is None:\n            raise ImproperlyConfigured(\n                \"AUTH_LDAP_GROUP_TYPE must be an LDAPGroupType instance.\"\n            )\n\n        self._group_search = self.settings.GROUP_SEARCH\n        if self._group_search is None:\n            raise ImproperlyConfigured(\n                \"AUTH_LDAP_GROUP_SEARCH must be an LDAPSearch instance.\"\n            )", "response": "Loads the settings we need to deal with groups."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_group_names(self):\n        if self._group_names is None:\n            self._load_cached_attr(\"_group_names\")\n\n        if self._group_names is None:\n            group_infos = self._get_group_infos()\n            self._group_names = {\n                self._group_type.group_name_from_info(group_info)\n                for group_info in group_infos\n            }\n            self._cache_attr(\"_group_names\")\n\n        return self._group_names", "response": "Returns the set of Django group names that this user belongs to by the LDAP group memberships."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning true if our user is a member of the given group.", "response": "def is_member_of(self, group_dn):\n        \"\"\"\n        Returns true if our user is a member of the given group.\n        \"\"\"\n        is_member = None\n\n        # Normalize the DN\n        group_dn = group_dn.lower()\n\n        # If we have self._group_dns, we'll use it. Otherwise, we'll try to\n        # avoid the cost of loading it.\n        if self._group_dns is None:\n            is_member = self._group_type.is_member(self._ldap_user, group_dn)\n\n        if is_member is None:\n            is_member = group_dn in self.get_group_dns()\n\n        logger.debug(\n            \"{} is{}a member of {}\".format(\n                self._ldap_user.dn, is_member and \" \" or \" not \", group_dn\n            )\n        )\n\n        return is_member"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_group_infos(self):\n        if self._group_infos is None:\n            self._group_infos = self._group_type.user_groups(\n                self._ldap_user, self._group_search\n            )\n\n        return self._group_infos", "response": "Returns a list of group_info structures for the groups that ourCOOKIE user is a member of."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the cache key for the attribute name.", "response": "def _cache_key(self, attr_name):\n        \"\"\"\n        Memcache keys can't have spaces in them, so we'll remove them from the\n        DN for maximum compatibility.\n        \"\"\"\n        dn = self._ldap_user.dn\n        return valid_cache_key(\n            \"auth_ldap.{}.{}.{}\".format(self.__class__.__name__, attr_name, dn)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ldap(cls, global_options=None):\n        # Apply global LDAP options once\n        if not cls._ldap_configured and global_options is not None:\n            for opt, value in global_options.items():\n                ldap.set_option(opt, value)\n\n            cls._ldap_configured = True\n\n        return ldap", "response": "Returns the configured ldap module."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_logger(cls):\n        if cls.logger is None:\n            cls.logger = logging.getLogger(\"django_auth_ldap\")\n            cls.logger.addHandler(logging.NullHandler())\n\n        return cls.logger", "response": "Initializes and returns our logger instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef search_with_additional_terms(self, term_dict, escape=True):\n        term_strings = [self.filterstr]\n\n        for name, value in term_dict.items():\n            if escape:\n                value = self.ldap.filter.escape_filter_chars(value)\n            term_strings.append(\"({}={})\".format(name, value))\n\n        filterstr = \"(&{})\".format(\"\".join(term_strings))\n\n        return self.__class__(\n            self.base_dn, self.scope, filterstr, attrlist=self.attrlist\n        )", "response": "Returns a new search object with additional terms and - ed to the\n            filter string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a new object with filterstr and - ed to the original filter string.", "response": "def search_with_additional_term_string(self, filterstr):\n        \"\"\"\n        Returns a new search object with filterstr and-ed to the original filter\n        string. The caller is responsible for passing in a properly escaped\n        string.\n        \"\"\"\n        filterstr = \"(&{}{})\".format(self.filterstr, filterstr)\n\n        return self.__class__(\n            self.base_dn, self.scope, filterstr, attrlist=self.attrlist\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef group_name_from_info(self, group_info):\n        try:\n            name = group_info[1][self.name_attr][0]\n        except (KeyError, IndexError):\n            name = None\n\n        return name", "response": "This function returns the name of the Django group that is associated with the LDAP group."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsearching for any group that is either the user s primary or contains the user as a member.", "response": "def user_groups(self, ldap_user, group_search):\n        \"\"\"\n        Searches for any group that is either the user's primary or contains the\n        user as a member.\n        \"\"\"\n        groups = []\n\n        try:\n            user_uid = ldap_user.attrs[\"uid\"][0]\n\n            if \"gidNumber\" in ldap_user.attrs:\n                user_gid = ldap_user.attrs[\"gidNumber\"][0]\n                filterstr = \"(|(gidNumber={})(memberUid={}))\".format(\n                    self.ldap.filter.escape_filter_chars(user_gid),\n                    self.ldap.filter.escape_filter_chars(user_uid),\n                )\n            else:\n                filterstr = \"(memberUid={})\".format(\n                    self.ldap.filter.escape_filter_chars(user_uid)\n                )\n\n            search = group_search.search_with_additional_term_string(filterstr)\n            groups = search.execute(ldap_user.connection)\n        except (KeyError, IndexError):\n            pass\n\n        return groups"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_member(self, ldap_user, group_dn):\n        try:\n            user_uid = ldap_user.attrs[\"uid\"][0]\n\n            try:\n                is_member = ldap_user.connection.compare_s(\n                    group_dn, \"memberUid\", user_uid.encode()\n                )\n            except (ldap.UNDEFINED_TYPE, ldap.NO_SUCH_ATTRIBUTE):\n                is_member = False\n\n            if not is_member:\n                try:\n                    user_gid = ldap_user.attrs[\"gidNumber\"][0]\n                    is_member = ldap_user.connection.compare_s(\n                        group_dn, \"gidNumber\", user_gid.encode()\n                    )\n                except (ldap.UNDEFINED_TYPE, ldap.NO_SUCH_ATTRIBUTE):\n                    is_member = False\n        except (KeyError, IndexError):\n            is_member = False\n\n        return is_member", "response": "Returns True if the user is a member of the group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a function for aggregating a sequence of sub - results.", "response": "def aggregator(self):\n        \"\"\"\n        Returns a function for aggregating a sequence of sub-results.\n        \"\"\"\n        if self.connector == self.AND:\n            aggregator = all\n        elif self.connector == self.OR:\n            aggregator = any\n        else:\n            raise ValueError(self.connector)\n\n        return aggregator"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _resolve_children(self, ldap_user, groups):\n        for child in self.children:\n            if isinstance(child, LDAPGroupQuery):\n                yield child.resolve(ldap_user, groups)\n            else:\n                yield groups.is_member_of(child)", "response": "Generates the query result for each child."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef gather_positions(tree):\n    pos = {'data-x': 'r0',\n           'data-y': 'r0',\n           'data-z': 'r0',\n           'data-rotate-x': 'r0',\n           'data-rotate-y': 'r0',\n           'data-rotate-z': 'r0',\n           'data-scale': 'r0',\n           'is_path': False\n           }\n\n    steps = 0\n    default_movement = True\n\n    for step in tree.findall('step'):\n        steps += 1\n\n        for key in POSITION_ATTRIBS:\n            value = step.get(key)\n\n            if value is not None:\n                # We have a new value\n                default_movement = False  # No longer use the default movement\n                pos[key] = value\n            elif pos[key] and not pos[key].startswith('r'):\n                # The old value was absolute and no new value, so stop\n                pos[key] = 'r0'\n            # We had no new value, and the old value was a relative\n            # movement, so we just keep moving.\n\n        if steps == 1 and pos['data-scale'] == 'r0':\n            # No scale given for first slide, it needs to start at 1\n            pos['data-scale'] = '1'\n\n        if default_movement and steps != 1:\n            # No positioning has been given, use default:\n            pos['data-x'] = 'r%s' % DEFAULT_MOVEMENT\n\n        if 'data-rotate' in step.attrib:\n            # data-rotate is an alias for data-rotate-z\n            pos['data-rotate-z'] = step.get('data-rotate')\n            del step.attrib['data-rotate']\n\n        if 'hovercraft-path' in step.attrib:\n            # Path given x and y will be calculated from the path\n            default_movement = False  # No longer use the default movement\n            pos['is_path'] = True\n            # Add the path spec\n            pos['path'] = step.attrib['hovercraft-path']\n            yield pos.copy()\n            # And get rid of it for the next step\n            del pos['path']\n        else:\n            if 'data-x' in step.attrib or 'data-y' in step.attrib:\n                # No longer using a path\n                pos['is_path'] = False\n            yield pos.copy()", "response": "Given a tree returns a list of positions and position commands that are available in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the positions of the current node in the order they appear.", "response": "def calculate_positions(positions):\n    \"\"\"Calculates position information\"\"\"\n    current_position = {'data-x': 0,\n                        'data-y': 0,\n                        'data-z': 0,\n                        'data-rotate-x': 0,\n                        'data-rotate-y': 0,\n                        'data-rotate-z': 0,\n                        'data-scale': 1,\n                        }\n\n    positer = iter(positions)\n    position = next(positer)\n    _update_position(current_position, position)\n\n    while True:\n\n        if 'path' in position:\n            # Start of a new path!\n            path = position['path']\n            # Follow the path specification\n            first_point = _pos_to_cord(current_position)\n\n            # Paths that end in Z or z are closed.\n            closed_path = path.strip()[-1].upper() == 'Z'\n            path = parse_path(path)\n\n            # Find out how many positions should be calculated:\n            count = 1\n            last = False\n            deferred_positions = []\n            while True:\n                try:\n                    position = next(positer)\n                    deferred_positions.append(position)\n                except StopIteration:\n                    last = True  # This path goes to the end\n                    break\n                if not position.get('is_path') or 'path' in position:\n                    # The end of the path, or the start of a new one\n                    break\n                count += 1\n\n            if count < 2:\n                raise AssertionError(\"The path specification is only used for \"\n                                     \"one slide, which makes it pointless.\")\n\n            if closed_path:\n                # This path closes in on itself. Skip the last part, so that\n                # the first and last step doesn't overlap.\n                endcount = count + 1\n            else:\n                endcount = count\n\n            multiplier = (endcount * DEFAULT_MOVEMENT) / path.length()\n            offset = path.point(0)\n\n            path_iter = iter(deferred_positions)\n            for x in range(count):\n\n                point = path.point(x / (endcount - 1))\n                point = ((point - offset) * multiplier) + first_point\n\n                current_position.update(_coord_to_pos(point))\n\n                rotation = _path_angle(path, x / (endcount - 1))\n                current_position['data-rotate-z'] = rotation\n                yield current_position.copy()\n                try:\n                    position = next(path_iter)\n                except StopIteration:\n                    last = True\n                    break\n                _update_position(current_position, position)\n\n            if last:\n                break\n\n            continue\n\n        yield current_position.copy()\n        try:\n            position = next(positer)\n        except StopIteration:\n            break\n        _update_position(current_position, position)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_positions(tree, positions):\n\n    for step, pos in zip(tree.findall('step'), positions):\n        for key in sorted(pos):\n            value = pos.get(key)\n            if key.endswith(\"-rel\"):\n                abs_key = key[:key.index(\"-rel\")]\n                if value is not None:\n                    els = tree.findall(\".//*[@id='\" + value + \"']\")\n                    for el in els :\n                        pos[abs_key] = num(el.get(abs_key)) + pos.get(abs_key)\n                        step.attrib[abs_key] = str(pos.get(abs_key))\n            else:\n                step.attrib[key] = str(pos[key])\n\n        if 'hovercraft-path' in step.attrib:\n            del step.attrib['hovercraft-path']", "response": "Updates the tree with new positions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef position_slides(tree):\n\n    positions = gather_positions(tree)\n    positions = calculate_positions(positions)\n    update_positions(tree, positions)", "response": "Position the slides in the tree"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake a copy of a node with the same attributes text but no children.", "response": "def copy_node(node):\n    \"\"\"Makes a copy of a node with the same attributes and text, but no children.\"\"\"\n    element = node.makeelement(node.tag)\n    element.text = node.text\n    element.tail = node.tail\n    for key, value in node.items():\n        element.set(key, value)\n\n    return element"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef copy_resource(self, resource, targetdir):\n        final_path = resource.final_path()\n        if final_path[0] == '/' or (':' in final_path) or ('?' in final_path):\n            # Absolute path or URI: Do nothing\n            return\n\n        source_path = self.get_source_path(resource)\n\n        if resource.resource_type == DIRECTORY_RESOURCE:\n            for file_path in glob.iglob(os.path.join(source_path, '**'), recursive=True):\n                if os.path.isdir(file_path):\n                    continue\n                rest_target_path = file_path[len(source_path)+1:]\n                target_path = os.path.join(targetdir, final_path, rest_target_path)\n                # Don't yield the result, we don't monitor these.\n                self._copy_file(file_path, target_path)\n        else:\n            target_path = os.path.join(targetdir, final_path)\n            yield self._copy_file(source_path, target_path)", "response": "Copies a resource file and returns the source path for monitoring"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate(args):\n\n    source_files = {args.presentation}\n\n    # Parse the template info\n    template_info = Template(args.template)\n    if args.css:\n        presentation_dir = os.path.split(args.presentation)[0]\n        target_path = os.path.relpath(args.css, presentation_dir)\n        template_info.add_resource(args.css, CSS_RESOURCE, target=target_path, extra_info='all')\n        source_files.add(args.css)\n    if args.js:\n        presentation_dir = os.path.split(args.presentation)[0]\n        target_path = os.path.relpath(args.js, presentation_dir)\n        template_info.add_resource(args.js, JS_RESOURCE, target=target_path, extra_info=JS_POSITION_BODY)\n        source_files.add(args.js)\n\n    # Make the resulting HTML\n    htmldata, dependencies = rst2html(args.presentation, template_info,\n                                      args.auto_console, args.skip_help,\n                                      args.skip_notes, args.mathjax,\n                                      args.slide_numbers)\n    source_files.update(dependencies)\n\n    # Write the HTML out\n    if not os.path.exists(args.targetdir):\n        os.makedirs(args.targetdir)\n    with open(os.path.join(args.targetdir, 'index.html'), 'wb') as outfile:\n        outfile.write(htmldata)\n\n    # Copy supporting files\n    source_files.update(template_info.copy_resources(args.targetdir))\n\n    # Copy images from the source:\n    sourcedir = os.path.split(os.path.abspath(args.presentation))[0]\n    tree = html.fromstring(htmldata)\n    for image in tree.iterdescendants('img'):\n        filename = image.attrib['src']\n        source_files.add(copy_resource(filename, sourcedir, args.targetdir))\n\n    RE_CSS_URL = re.compile(br\"\"\"url\\(['\"]?(.*?)['\"]?[\\)\\?\\#]\"\"\")\n\n    # Copy any files referenced by url() in the css-files:\n    for resource in template_info.resources:\n        if resource.resource_type != CSS_RESOURCE:\n            continue\n        # path in CSS is relative to CSS file; construct source/dest accordingly\n        css_base = template_info.template_root if resource.is_in_template else sourcedir\n        css_sourcedir = os.path.dirname(os.path.join(css_base, resource.filepath))\n        css_targetdir = os.path.dirname(os.path.join(args.targetdir, resource.final_path()))\n        uris = RE_CSS_URL.findall(template_info.read_data(resource))\n        uris = [uri.decode() for uri in uris]\n        if resource.is_in_template and template_info.builtin_template:\n            for filename in uris:\n                template_info.add_resource(filename, OTHER_RESOURCE, target=css_targetdir,\n                                           is_in_template=True)\n        else:\n            for filename in uris:\n                source_files.add(copy_resource(filename, css_sourcedir, css_targetdir))\n\n    # All done!\n\n    return {os.path.abspath(f) for f in source_files if f}", "response": "Generates the presentation and returns a list of files used"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting the server. Do nothing if server is already running. This function will block if no_block is not set to True.", "response": "def start(self):\n        \"\"\"Start the server.\n\n        Do nothing if server is already running.\n        This function will block if no_block is not set to True.\n        \"\"\"\n        if not self.is_run:\n            # set class attribute\n            ThreadingTCPServer.address_family = socket.AF_INET6 if self.ipv6 else socket.AF_INET\n            ThreadingTCPServer.daemon_threads = True\n            # init server\n            self._service = ThreadingTCPServer((self.host, self.port), self.ModbusService, bind_and_activate=False)\n            # set socket options\n            self._service.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            self._service.socket.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n            # TODO test no_delay with bench\n            self._service.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n            # bind and activate\n            self._service.server_bind()\n            self._service.server_activate()\n            # serve request\n            if self.no_block:\n                self._serve_th = Thread(target=self._serve)\n                self._serve_th.daemon = True\n                self._serve_th.start()\n            else:\n                self._serve()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstop the server. Do nothing if server is already not running.", "response": "def stop(self):\n        \"\"\"Stop the server.\n\n        Do nothing if server is already not running.\n        \"\"\"\n        if self.is_run:\n            self._service.shutdown()\n            self._service.server_close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting or set host", "response": "def host(self, hostname=None):\n        \"\"\"Get or set host (IPv4/IPv6 or hostname like 'plc.domain.net')\n\n        :param hostname: hostname or IPv4/IPv6 address or None for get value\n        :type hostname: str or None\n        :returns: hostname or None if set fail\n        :rtype: str or None\n        \"\"\"\n        if (hostname is None) or (hostname == self.__hostname):\n            return self.__hostname\n        # when hostname change ensure old socket is close\n        self.close()\n        # IPv4 ?\n        try:\n            socket.inet_pton(socket.AF_INET, hostname)\n            self.__hostname = hostname\n            return self.__hostname\n        except socket.error:\n            pass\n        # IPv6 ?\n        try:\n            socket.inet_pton(socket.AF_INET6, hostname)\n            self.__hostname = hostname\n            return self.__hostname\n        except socket.error:\n            pass\n        # DNS name ?\n        if re.match('^[a-z][a-z0-9\\.\\-]+$', hostname):\n            self.__hostname = hostname\n            return self.__hostname\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef port(self, port=None):\n        if (port is None) or (port == self.__port):\n            return self.__port\n        # when port change ensure old socket is close\n        self.close()\n        # valid port ?\n        if 0 < int(port) < 65536:\n            self.__port = int(port)\n            return self.__port\n        else:\n            return None", "response": "Get or set TCP port number"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets or set unit ID field", "response": "def unit_id(self, unit_id=None):\n        \"\"\"Get or set unit ID field\n\n        :param unit_id: unit ID (0 to 255) or None for get value\n        :type unit_id: int or None\n        :returns: unit ID or None if set fail\n        :rtype: int or None\n        \"\"\"\n        if unit_id is None:\n            return self.__unit_id\n        if 0 <= int(unit_id) < 256:\n            self.__unit_id = int(unit_id)\n            return self.__unit_id\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef timeout(self, timeout=None):\n        if timeout is None:\n            return self.__timeout\n        if 0 < float(timeout) < 3600:\n            self.__timeout = float(timeout)\n            return self.__timeout\n        else:\n            return None", "response": "Get or set socket timeout field\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets or set debug mode", "response": "def debug(self, state=None):\n        \"\"\"Get or set debug mode\n\n        :param state: debug state or None for get value\n        :type state: bool or None\n        :returns: debug state or None if set fail\n        :rtype: bool or None\n        \"\"\"\n        if state is None:\n            return self.__debug\n        self.__debug = bool(state)\n        return self.__debug"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef auto_open(self, state=None):\n        if state is None:\n            return self.__auto_open\n        self.__auto_open = bool(state)\n        return self.__auto_open", "response": "Get or set automatic TCP connect mode\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget or set automatic TCP close mode", "response": "def auto_close(self, state=None):\n        \"\"\"Get or set automatic TCP close mode (after each request)\n\n        :param state: auto_close state or None for get value\n        :type state: bool or None\n        :returns: auto_close state or None if set fail\n        :rtype: bool or None\n        \"\"\"\n        if state is None:\n            return self.__auto_close\n        self.__auto_close = bool(state)\n        return self.__auto_close"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets or set modbus mode", "response": "def mode(self, mode=None):\n        \"\"\"Get or set modbus mode (TCP or RTU)\n\n        :param mode: mode (MODBUS_TCP/MODBUS_RTU) to set or None for get value\n        :type mode: int\n        :returns: mode or None if set fail\n        :rtype: int or None\n        \"\"\"\n        if mode is None:\n            return self.__mode\n        if mode == const.MODBUS_TCP or mode == const.MODBUS_RTU:\n            self.__mode = mode\n            return self.__mode\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nopens the modbus server and return True if open otherwise False.", "response": "def open(self):\n        \"\"\"Connect to modbus server (open TCP connection)\n\n        :returns: connect status (True if open)\n        :rtype: bool\n        \"\"\"\n        # restart TCP if already open\n        if self.is_open():\n            self.close()\n        # init socket and connect\n        # list available sockets on the target host/port\n        # AF_xxx : AF_INET -> IPv4, AF_INET6 -> IPv6,\n        #          AF_UNSPEC -> IPv6 (priority on some system) or 4\n        # list available socket on target host\n        for res in socket.getaddrinfo(self.__hostname, self.__port,\n                                      socket.AF_UNSPEC, socket.SOCK_STREAM):\n            af, sock_type, proto, canon_name, sa = res\n            try:\n                self.__sock = socket.socket(af, sock_type, proto)\n            except socket.error:\n                self.__sock = None\n                continue\n            try:\n                self.__sock.settimeout(self.__timeout)\n                self.__sock.connect(sa)\n            except socket.error:\n                self.__sock.close()\n                self.__sock = None\n                continue\n            break\n        # check connect status\n        if self.__sock is not None:\n            return True\n        else:\n            self.__last_error = const.MB_CONNECT_ERR\n            self.__debug_msg('connect error')\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose TCP connection and returns close status", "response": "def close(self):\n        \"\"\"Close TCP connection\n\n        :returns: close status (True for close/None if already close)\n        :rtype: bool or None\n        \"\"\"\n        if self.__sock:\n            self.__sock.close()\n            self.__sock = None\n            return True\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_input_registers(self, reg_addr, reg_nb=1):\n        # check params\n        if not (0x0000 <= int(reg_addr) <= 0xffff):\n            self.__debug_msg('read_input_registers(): reg_addr out of range')\n            return None\n        if not (0x0001 <= int(reg_nb) <= 0x007d):\n            self.__debug_msg('read_input_registers(): reg_nb out of range')\n            return None\n        if (int(reg_addr) + int(reg_nb)) > 0x10000:\n            self.__debug_msg('read_input_registers(): read after ad 65535')\n            return None\n        # build frame\n        tx_buffer = self._mbus_frame(const.READ_INPUT_REGISTERS, struct.pack('>HH', reg_addr, reg_nb))\n        # send request\n        s_send = self._send_mbus(tx_buffer)\n        # check error\n        if not s_send:\n            return None\n        # receive\n        f_body = self._recv_mbus()\n        # check error\n        if not f_body:\n            return None\n        # check min frame body size\n        if len(f_body) < 2:\n            self.__last_error = const.MB_RECV_ERR\n            self.__debug_msg('read_input_registers(): rx frame under min size')\n            self.close()\n            return None\n        # extract field \"byte count\"\n        rx_byte_count = struct.unpack('B', f_body[0:1])[0]\n        # frame with regs value\n        f_regs = f_body[1:]\n        # check rx_byte_count: buffer size must be consistent and have at least the requested number of registers\n        if not ((rx_byte_count >= 2 * reg_nb) and\n                (rx_byte_count == len(f_regs))):\n            self.__last_error = const.MB_RECV_ERR\n            self.__debug_msg('read_input_registers(): rx byte count mismatch')\n            self.close()\n            return None\n        # allocate a reg_nb size list\n        registers = [None] * reg_nb\n        # fill registers list with register items\n        for i, item in enumerate(registers):\n            registers[i] = struct.unpack('>H', f_regs[i * 2:i * 2 + 2])[0]\n        # return registers list\n        return registers", "response": "This function is used to read the modbus registers from the Modbus interface."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a single modbus entry.", "response": "def write_single_coil(self, bit_addr, bit_value):\n        \"\"\"Modbus function WRITE_SINGLE_COIL (0x05)\n\n        :param bit_addr: bit address (0 to 65535)\n        :type bit_addr: int\n        :param bit_value: bit value to write\n        :type bit_value: bool\n        :returns: True if write ok or None if fail\n        :rtype: bool or None\n        \"\"\"\n        # check params\n        if not (0 <= int(bit_addr) <= 65535):\n            self.__debug_msg('write_single_coil(): bit_addr out of range')\n            return None\n        # build frame\n        bit_value = 0xFF if bit_value else 0x00\n        tx_buffer = self._mbus_frame(const.WRITE_SINGLE_COIL, struct.pack('>HBB', bit_addr, bit_value, 0))\n        # send request\n        s_send = self._send_mbus(tx_buffer)\n        # check error\n        if not s_send:\n            return None\n        # receive\n        f_body = self._recv_mbus()\n        # check error\n        if not f_body:\n            return None\n        # check fix frame size\n        if len(f_body) != 4:\n            self.__last_error = const.MB_RECV_ERR\n            self.__debug_msg('write_single_coil(): rx frame size error')\n            self.close()\n            return None\n        # register extract\n        (rx_bit_addr, rx_bit_value, rx_padding) = struct.unpack('>HBB', f_body[:4])\n        # check bit write\n        is_ok = (rx_bit_addr == bit_addr) and (rx_bit_value == bit_value)\n        return True if is_ok else None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a single register to the modbus.", "response": "def write_single_register(self, reg_addr, reg_value):\n        \"\"\"Modbus function WRITE_SINGLE_REGISTER (0x06)\n\n        :param reg_addr: register address (0 to 65535)\n        :type reg_addr: int\n        :param reg_value: register value to write\n        :type reg_value: int\n        :returns: True if write ok or None if fail\n        :rtype: bool or None\n        \"\"\"\n        # check params\n        if not (0 <= int(reg_addr) <= 65535):\n            self.__debug_msg('write_single_register(): reg_addr out of range')\n            return None\n        if not (0 <= int(reg_value) <= 65535):\n            self.__debug_msg('write_single_register(): reg_value out of range')\n            return None\n        # build frame\n        tx_buffer = self._mbus_frame(const.WRITE_SINGLE_REGISTER,\n                                     struct.pack('>HH', reg_addr, reg_value))\n        # send request\n        s_send = self._send_mbus(tx_buffer)\n        # check error\n        if not s_send:\n            return None\n        # receive\n        f_body = self._recv_mbus()\n        # check error\n        if not f_body:\n            return None\n        # check fix frame size\n        if len(f_body) != 4:\n            self.__last_error = const.MB_RECV_ERR\n            self.__debug_msg('write_single_register(): rx frame size error')\n            self.close()\n            return None\n        # register extract\n        rx_reg_addr, rx_reg_value = struct.unpack('>HH', f_body)\n        # check register write\n        is_ok = (rx_reg_addr == reg_addr) and (rx_reg_value == reg_value)\n        return True if is_ok else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwait for data available for socket read", "response": "def _can_read(self):\n        \"\"\"Wait data available for socket read\n\n        :returns: True if data available or None if timeout or socket error\n        :rtype: bool or None\n        \"\"\"\n        if self.__sock is None:\n            return None\n        if select.select([self.__sock], [], [], self.__timeout)[0]:\n            return True\n        else:\n            self.__last_error = const.MB_TIMEOUT_ERR\n            self.__debug_msg('timeout error')\n            self.close()\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _send(self, data):\n        # check link\n        if self.__sock is None:\n            self.__debug_msg('call _send on close socket')\n            return None\n        # send\n        data_l = len(data)\n        try:\n            send_l = self.__sock.send(data)\n        except socket.error:\n            send_l = None\n        # handle send error\n        if (send_l is None) or (send_l != data_l):\n            self.__last_error = const.MB_SEND_ERR\n            self.__debug_msg('_send error')\n            self.close()\n            return None\n        else:\n            return send_l", "response": "Send data over current socket and return the number of bytes sent."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreceives data over current socket and return it as bytes or None if no data is available.", "response": "def _recv(self, max_size):\n        \"\"\"Receive data over current socket\n\n        :param max_size: number of bytes to receive\n        :type max_size: int\n        :returns: receive data or None if error\n        :rtype: str (Python2) or class bytes (Python3) or None\n        \"\"\"\n        # wait for read\n        if not self._can_read():\n            self.close()\n            return None\n        # recv\n        try:\n            r_buffer = self.__sock.recv(max_size)\n        except socket.error:\n            r_buffer = None\n        # handle recv error\n        if not r_buffer:\n            self.__last_error = const.MB_RECV_ERR\n            self.__debug_msg('_recv error')\n            self.close()\n            return None\n        return r_buffer"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _recv_all(self, size):\n        r_buffer = bytes()\n        while len(r_buffer) < size:\n            r_packet = self._recv(size - len(r_buffer))\n            if not r_packet:\n                return None\n            r_buffer += r_packet\n        return r_buffer", "response": "Receive data over current socket loop until all bytes are received"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a modbus frame to modbus and return the number of bytes sent or None if error.", "response": "def _send_mbus(self, frame):\n        \"\"\"Send modbus frame\n\n        :param frame: modbus frame to send (with MBAP for TCP/CRC for RTU)\n        :type frame: str (Python2) or class bytes (Python3)\n        :returns: number of bytes send or None if error\n        :rtype: int or None\n        \"\"\"\n        # for auto_open mode, check TCP and open if need\n        if self.__auto_open and not self.is_open():\n            self.open()\n        # send request\n        bytes_send = self._send(frame)\n        if bytes_send:\n            if self.__debug:\n                self._pretty_dump('Tx', frame)\n            return bytes_send\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreceiving a modbus frame and return the next modbus frame.", "response": "def _recv_mbus(self):\n        \"\"\"Receive a modbus frame\n\n        :returns: modbus frame body or None if error\n        :rtype: str (Python2) or class bytes (Python3) or None\n        \"\"\"\n        # receive\n        # modbus TCP receive\n        if self.__mode == const.MODBUS_TCP:\n            # 7 bytes header (mbap)\n            rx_buffer = self._recv_all(7)\n            # check recv\n            if not (rx_buffer and len(rx_buffer) == 7):\n                self.__last_error = const.MB_RECV_ERR\n                self.__debug_msg('_recv MBAP error')\n                self.close()\n                return None\n            rx_frame = rx_buffer\n            # decode header\n            (rx_hd_tr_id, rx_hd_pr_id,\n             rx_hd_length, rx_hd_unit_id) = struct.unpack('>HHHB', rx_frame)\n            # check header\n            if not ((rx_hd_tr_id == self.__hd_tr_id) and\n                    (rx_hd_pr_id == 0) and\n                    (rx_hd_length < 256) and\n                    (rx_hd_unit_id == self.__unit_id)):\n                self.__last_error = const.MB_RECV_ERR\n                self.__debug_msg('MBAP format error')\n                if self.__debug:\n                    rx_frame += self._recv_all(rx_hd_length - 1)\n                    self._pretty_dump('Rx', rx_frame)\n                self.close()\n                return None\n            # end of frame\n            rx_buffer = self._recv_all(rx_hd_length - 1)\n            if not (rx_buffer and\n                    (len(rx_buffer) == rx_hd_length - 1) and\n                    (len(rx_buffer) >= 2)):\n                self.__last_error = const.MB_RECV_ERR\n                self.__debug_msg('_recv frame body error')\n                self.close()\n                return None\n            rx_frame += rx_buffer\n            # dump frame\n            if self.__debug:\n                self._pretty_dump('Rx', rx_frame)\n            # body decode\n            rx_bd_fc = struct.unpack('B', rx_buffer[0:1])[0]\n            f_body = rx_buffer[1:]\n        # modbus RTU receive\n        elif self.__mode == const.MODBUS_RTU:\n            # receive modbus RTU frame (max size is 256 bytes)\n            rx_buffer = self._recv(256)\n            # on _recv error\n            if not rx_buffer:\n                return None\n            rx_frame = rx_buffer\n            # dump frame\n            if self.__debug:\n                self._pretty_dump('Rx', rx_frame)\n            # RTU frame min size is 5 bytes\n            if len(rx_buffer) < 5:\n                self.__last_error = const.MB_RECV_ERR\n                self.__debug_msg('short frame error')\n                self.close()\n                return None\n            # check CRC\n            if not self._crc_is_ok(rx_frame):\n                self.__last_error = const.MB_CRC_ERR\n                self.__debug_msg('CRC error')\n                self.close()\n                return None\n            # body decode\n            (rx_unit_id, rx_bd_fc) = struct.unpack(\"BB\", rx_frame[:2])\n            # check\n            if not (rx_unit_id == self.__unit_id):\n                self.__last_error = const.MB_RECV_ERR\n                self.__debug_msg('unit ID mismatch error')\n                self.close()\n                return None\n            # format f_body: remove unit ID, function code and CRC 2 last bytes\n            f_body = rx_frame[2:-2]\n        # for auto_close mode, close socket after each request\n        if self.__auto_close:\n            self.close()\n        # check except\n        if rx_bd_fc > 0x80:\n            # except code\n            exp_code = struct.unpack('B', f_body[0:1])[0]\n            self.__last_error = const.MB_EXCEPT_ERR\n            self.__last_except = exp_code\n            self.__debug_msg('except (code ' + str(exp_code) + ')')\n            return None\n        else:\n            # return\n            return f_body"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild modbus frame for modbus function code fc and body.", "response": "def _mbus_frame(self, fc, body):\n        \"\"\"Build modbus frame (add MBAP for Modbus/TCP, slave AD + CRC for RTU)\n\n        :param fc: modbus function code\n        :type fc: int\n        :param body: modbus frame body\n        :type body: str (Python2) or class bytes (Python3)\n        :returns: modbus frame\n        :rtype: str (Python2) or class bytes (Python3)\n        \"\"\"\n        # build frame body\n        f_body = struct.pack('B', fc) + body\n        # modbus/TCP\n        if self.__mode == const.MODBUS_TCP:\n            # build frame ModBus Application Protocol header (mbap)\n            self.__hd_tr_id = random.randint(0, 65535)\n            tx_hd_pr_id = 0\n            tx_hd_length = len(f_body) + 1\n            f_mbap = struct.pack('>HHHB', self.__hd_tr_id, tx_hd_pr_id,\n                                 tx_hd_length, self.__unit_id)\n            return f_mbap + f_body\n        # modbus RTU\n        elif self.__mode == const.MODBUS_RTU:\n            # format [slave addr(unit_id)]frame_body[CRC16]\n            slave_ad = struct.pack('B', self.__unit_id)\n            return self._add_crc(slave_ad + f_body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pretty_dump(self, label, data):\n        # split data string items to a list of hex value\n        dump = ['%02X' % c for c in bytearray(data)]\n        # format for TCP or RTU\n        if self.__mode == const.MODBUS_TCP:\n            if len(dump) > 6:\n                # [MBAP] ...\n                dump[0] = '[' + dump[0]\n                dump[6] += ']'\n        elif self.__mode == const.MODBUS_RTU:\n            if len(dump) > 4:\n                # ... [CRC]\n                dump[-2] = '[' + dump[-2]\n                dump[-1] += ']'\n        # print result\n        print(label)\n        s = ''\n        for i in dump:\n            s += i + ' '\n        print(s)", "response": "Print the contents of the modbus frame to stdout."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _add_crc(self, frame):\n        crc = struct.pack('<H', crc16(frame))\n        return frame + crc", "response": "Add CRC to modbus RTU frame"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_bits_from_int(val_int, val_size=16):\n    # allocate a bit_nb size list\n    bits = [None] * val_size\n    # fill bits list with bit items\n    for i, item in enumerate(bits):\n        bits[i] = bool((val_int >> i) & 0x01)\n    # return bits list\n    return bits", "response": "Get the list of bits of val_int integer."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a list of 16 bits int to 32 bits int", "response": "def word_list_to_long(val_list, big_endian=True):\n    \"\"\"Word list (16 bits int) to long list (32 bits int)\n\n        By default word_list_to_long() use big endian order. For use little endian, set\n        big_endian param to False.\n\n        :param val_list: list of 16 bits int value\n        :type val_list: list\n        :param big_endian: True for big endian/False for little (optional)\n        :type big_endian: bool\n        :returns: list of 32 bits int value\n        :rtype: list\n    \"\"\"\n    # allocate list for long int\n    long_list = [None] * int(len(val_list) / 2)\n    # fill registers list with register items\n    for i, item in enumerate(long_list):\n        if big_endian:\n            long_list[i] = (val_list[i * 2] << 16) + val_list[(i * 2) + 1]\n        else:\n            long_list[i] = (val_list[(i * 2) + 1] << 16) + val_list[i * 2]\n    # return long list\n    return long_list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef long_list_to_word(val_list, big_endian=True):\n    # allocate list for long int\n    word_list = list()\n    # fill registers list with register items\n    for i, item in enumerate(val_list):\n        if big_endian:\n            word_list.append(val_list[i] >> 16)\n            word_list.append(val_list[i] & 0xffff)\n        else:\n            word_list.append(val_list[i] & 0xffff)\n            word_list.append(val_list[i] >> 16)\n    # return long list\n    return word_list", "response": "Convert a 32 bits int list to a list of 16 bits int list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef crc16(frame):\n    crc = 0xFFFF\n    for index, item in enumerate(bytearray(frame)):\n        next_byte = item\n        crc ^= next_byte\n        for i in range(8):\n            lsb = crc & 1\n            crc >>= 1\n            if lsb:\n                crc ^= 0xA001\n    return crc", "response": "Compute CRC16 of a sequence of bytes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _wc_hard_wrap(line, length):\n    chars = []\n    chars_len = 0\n    for char in line:\n        char_len = wcwidth(char)\n        if chars_len + char_len > length:\n            yield \"\".join(chars)\n            chars = []\n            chars_len = 0\n\n        chars.append(char)\n        chars_len += char_len\n\n    if chars:\n        yield \"\".join(chars)", "response": "Wrap text to length characters breaking when target length is reached."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wc_wrap(text, length):\n    line_words = []\n    line_len = 0\n\n    words = re.split(r\"\\s+\", text.strip())\n    for word in words:\n        word_len = wcswidth(word)\n\n        if line_words and line_len + word_len > length:\n            line = \" \".join(line_words)\n            if line_len <= length:\n                yield line\n            else:\n                yield from _wc_hard_wrap(line, length)\n\n            line_words = []\n            line_len = 0\n\n        line_words.append(word)\n        line_len += word_len + 1  # add 1 to account for space between words\n\n    if line_words:\n        line = \" \".join(line_words)\n        if line_len <= length:\n            yield line\n        else:\n            yield from _wc_hard_wrap(line, length)", "response": "Wrap text to given length breaking on whitespace taking into account for space between words and paragraphs and destroy spacing between words and paragraphs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trunc(text, length):\n    if length < 1:\n        raise ValueError(\"length should be 1 or larger\")\n\n    # Remove whitespace first so no unneccesary truncation is done.\n    text = text.strip()\n    text_length = wcswidth(text)\n\n    if text_length <= length:\n        return text\n\n    # We cannot just remove n characters from the end since we don't know how\n    # wide these characters are and how it will affect text length.\n    # Use wcwidth to determine how many characters need to be truncated.\n    chars_to_truncate = 0\n    trunc_length = 0\n    for char in reversed(text):\n        chars_to_truncate += 1\n        trunc_length += wcwidth(char)\n        if text_length - trunc_length <= length:\n            break\n\n    # Additional char to make room for elipsis\n    n = chars_to_truncate + 1\n    return text[:-n].strip() + '\u2026'", "response": "Truncates text to given length taking into account wide characters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npad text to given length taking into account wide characters.", "response": "def pad(text, length):\n    \"\"\"Pads text to given length, taking into account wide characters.\"\"\"\n    text_length = wcswidth(text)\n\n    if text_length < length:\n        return text + ' ' * (length - text_length)\n\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking text fit the given length by padding or truncating it.", "response": "def fit_text(text, length):\n    \"\"\"Makes text fit the given length by padding or truncating it.\"\"\"\n    text_length = wcswidth(text)\n\n    if text_length > length:\n        return trunc(text, length)\n\n    if text_length < length:\n        return pad(text, length)\n\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_error_message(response):\n    try:\n        data = response.json()\n        if \"error_description\" in data:\n            return data['error_description']\n        if \"error\" in data:\n            return data['error']\n    except Exception:\n        pass\n\n    return \"Unknown error\"", "response": "Attempt to extract an error message from response body"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a config file at the given path.", "response": "def make_config(path):\n    \"\"\"Creates a config file.\n\n    Attempts to load data from legacy config files if they exist.\n    \"\"\"\n    apps, user = load_legacy_config()\n\n    apps = {a.instance: a._asdict() for a in apps}\n    users = {user_id(user): user._asdict()} if user else {}\n    active_user = user_id(user) if user else None\n\n    config = {\n        \"apps\": apps,\n        \"users\": users,\n        \"active_user\": active_user,\n    }\n\n    print_out(\"Creating config file at <blue>{}</blue>\".format(path))\n\n    # Ensure dir exists\n    os.makedirs(dirname(path), exist_ok=True)\n\n    with open(path, 'w') as f:\n        json.dump(config, f, indent=True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nposting a new status.", "response": "def post_status(\n    app,\n    user,\n    status,\n    visibility='public',\n    media_ids=None,\n    sensitive=False,\n    spoiler_text=None,\n    in_reply_to_id=None\n):\n    \"\"\"\n    Posts a new status.\n    https://github.com/tootsuite/documentation/blob/master/Using-the-API/API.md#posting-a-new-status\n    \"\"\"\n\n    # Idempotency key assures the same status is not posted multiple times\n    # if the request is retried.\n    headers = {\"Idempotency-Key\": uuid.uuid4().hex}\n\n    return http.post(app, user, '/api/v1/statuses', {\n        'status': status,\n        'media_ids[]': media_ids,\n        'visibility': visibility,\n        'sensitive': str_bool(sensitive),\n        'spoiler_text': spoiler_text,\n        'in_reply_to_id': in_reply_to_id,\n    }, headers=headers).json()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete a status with given ID.", "response": "def delete_status(app, user, status_id):\n    \"\"\"\n    Deletes a status with given ID.\n    https://github.com/tootsuite/documentation/blob/master/Using-the-API/API.md#deleting-a-status\n    \"\"\"\n    return http.delete(app, user, '/api/v1/statuses/{}'.format(status_id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a timeline response headers returns the path to the next batch", "response": "def _get_next_path(headers):\n    \"\"\"Given timeline response headers, returns the path to the next batch\"\"\"\n    links = headers.get('Link', '')\n    matches = re.match('<([^>]+)>; rel=\"next\"', links)\n    if matches:\n        parsed = urlparse(matches.group(1))\n        return \"?\".join([parsed.path, parsed.query])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreply to the selected status", "response": "def reply(self):\n        \"\"\"Reply to the selected status\"\"\"\n        status = self.get_selected_status()\n        app, user = self.app, self.user\n        if not app or not user:\n            self.footer.draw_message(\"You must be logged in to reply\", Color.RED)\n            return\n\n        compose_modal = ComposeModal(self.stdscr, default_cw='\\n'.join(status['spoiler_text']) or None, resize_callback=self.on_resize)\n        content, cw = compose_modal.loop()\n        self.full_redraw()\n        if content is None:\n            return\n        elif len(content) == 0:\n            self.footer.draw_message(\"Status must contain content\", Color.RED)\n            return\n\n        self.footer.draw_message(\"Submitting reply...\", Color.YELLOW)\n        response = api.post_status(app, user, content, spoiler_text=cw, sensitive=cw is not None, in_reply_to_id=status['id'])\n        status = parse_status(response)\n        self.statuses.insert(0, status)\n        self.selected += 1\n        self.left.draw_statuses(self.statuses, self.selected)\n        self.footer.draw_message(\"\u2713 Reply posted\", Color.GREEN)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntoggle reblog or unreblog selected status.", "response": "def toggle_reblog(self):\n        \"\"\"Reblog or unreblog selected status.\"\"\"\n        status = self.get_selected_status()\n        assert status\n        app, user = self.app, self.user\n        if not app or not user:\n            self.footer.draw_message(\"You must be logged in to reblog\", Color.RED)\n            return\n        status_id = status['id']\n        if status['reblogged']:\n            status['reblogged'] = False\n            self.footer.draw_message(\"Unboosting status...\", Color.YELLOW)\n            api.unreblog(app, user, status_id)\n            self.footer.draw_message(\"\u2713 Status unboosted\", Color.GREEN)\n        else:\n            status['reblogged'] = True\n            self.footer.draw_message(\"Boosting status...\", Color.YELLOW)\n            api.reblog(app, user, status_id)\n            self.footer.draw_message(\"\u2713 Status boosted\", Color.GREEN)\n\n        self.right.draw(status)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef toggle_favourite(self):\n        status = self.get_selected_status()\n        assert status\n        app, user = self.app, self.user\n        if not app or not user:\n            self.footer.draw_message(\"You must be logged in to favourite\", Color.RED)\n            return\n        status_id = status['id']\n        if status['favourited']:\n            self.footer.draw_message(\"Undoing favourite status...\", Color.YELLOW)\n            api.unfavourite(app, user, status_id)\n            self.footer.draw_message(\"\u2713 Status unfavourited\", Color.GREEN)\n        else:\n            self.footer.draw_message(\"Favourite status...\", Color.YELLOW)\n            api.favourite(app, user, status_id)\n            self.footer.draw_message(\"\u2713 Status favourited\", Color.GREEN)\n        status['favourited'] = not status['favourited']\n\n        self.right.draw(status)", "response": "Favourite or unfavourite selected status."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmove to the previous status in the timeline.", "response": "def select_previous(self):\n        \"\"\"Move to the previous status in the timeline.\"\"\"\n        self.footer.clear_message()\n\n        if self.selected == 0:\n            self.footer.draw_message(\"Cannot move beyond first toot.\", Color.GREEN)\n            return\n\n        old_index = self.selected\n        new_index = self.selected - 1\n\n        self.selected = new_index\n        self.redraw_after_selection_change(old_index, new_index)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef select_next(self):\n        self.footer.clear_message()\n\n        old_index = self.selected\n        new_index = self.selected + 1\n\n        # Load more statuses if no more are available\n        if self.selected + 1 >= len(self.statuses):\n            self.fetch_next()\n            self.left.draw_statuses(self.statuses, self.selected, new_index - 1)\n            self.draw_footer_status()\n\n        self.selected = new_index\n        self.redraw_after_selection_change(old_index, new_index)", "response": "Move to the next status in the timeline."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms a full redraw of the UI.", "response": "def full_redraw(self):\n        \"\"\"Perform a full redraw of the UI.\"\"\"\n        self.left.draw_statuses(self.statuses, self.selected)\n        self.right.draw(self.get_selected_status())\n\n        self.header.draw(self.user)\n        self.draw_footer_status()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef size_as_drawn(lines, screen_width):\n    y = 0\n    x = 0\n    for line in lines:\n        wrapped = list(wc_wrap(line, screen_width))\n        if len(wrapped) > 0:\n            for wrapped_line in wrapped:\n                x = len(wrapped_line)\n                y += 1\n        else:\n            x = 0\n            y += 1\n    return y - 1, x - 1 if x != 0 else 0", "response": "Get the bottom - right corner of some text as would be drawn by draw_lines"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the Account object for a given account name Raises an exception if not found.", "response": "def _find_account(app, user, account_name):\n    \"\"\"For a given account name, returns the Account object.\n\n    Raises an exception if not found.\n    \"\"\"\n    if not account_name:\n        raise ConsoleError(\"Empty account name given\")\n\n    accounts = api.search_accounts(app, user, account_name)\n\n    if account_name[0] == \"@\":\n        account_name = account_name[1:]\n\n    for account in accounts:\n        if account['acct'] == account_name:\n            return account\n\n    raise ConsoleError(\"Account not found\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_username(user, apps):\n    if not user:\n        return None\n\n    apps = [a for a in apps if a.instance == user.instance]\n\n    if not apps:\n        return None\n\n    from toot.api import verify_credentials\n    creds = verify_credentials(apps.pop(), user)\n\n    return User(user.instance, creds['username'], user.access_token)", "response": "Add username to the list of apps"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_text(html):\n\n    # Ignore warnings made by BeautifulSoup, if passed something that looks like\n    # a file (e.g. a dot which matches current dict), it will warn that the file\n    # should be opened instead of passing a filename.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        text = BeautifulSoup(html.replace('&apos;', \"'\"), \"html.parser\").get_text()\n\n    return unicodedata.normalize('NFKC', text)", "response": "Converts html to text strips all tags."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nattempts to convert html to plain text while keeping line breaks. Returns a list of paragraphs each being a list of lines.", "response": "def parse_html(html):\n    \"\"\"Attempt to convert html to plain text while keeping line breaks.\n    Returns a list of paragraphs, each being a list of lines.\n    \"\"\"\n    paragraphs = re.split(\"</?p[^>]*>\", html)\n\n    # Convert <br>s to line breaks and remove empty paragraphs\n    paragraphs = [re.split(\"<br */?>\", p) for p in paragraphs if p]\n\n    # Convert each line in each paragraph to plain text:\n    return [[get_text(l) for l in p] for p in paragraphs]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a Status contents in HTML converts it into lines of plain text.", "response": "def format_content(content):\n    \"\"\"Given a Status contents in HTML, converts it into lines of plain text.\n\n    Returns a generator yielding lines of content.\n    \"\"\"\n\n    paragraphs = parse_html(content)\n\n    first = True\n\n    for paragraph in paragraphs:\n        if not first:\n            yield \"\"\n\n        for line in paragraph:\n            yield line\n\n        first = False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef multiline_input():\n    lines = []\n    while True:\n        try:\n            lines.append(input())\n        except EOFError:\n            break\n\n    return \"\\n\".join(lines).strip()", "response": "Lets user input multiple lines of text terminated by EOF."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_dict(self):\n        return {\"name\": self.table_name, \"kind\": self.table_kind, \"data\": [r.to_dict() for r in self]}", "response": "Converts the table to a dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a string to a datetime.", "response": "def to_datetime(value):\n    \"\"\"Converts a string to a datetime.\"\"\"\n    if value is None:\n        return None\n\n    if isinstance(value, six.integer_types):\n        return parser.parse(value)\n    return parser.isoparse(value)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a string to a timedelta.", "response": "def to_timedelta(value):\n    \"\"\"Converts a string to a timedelta.\"\"\"\n    if value is None:\n        return None\n    if isinstance(value, (six.integer_types, float)):\n        return timedelta(microseconds=(float(value) / 10))\n    match = _TIMESPAN_PATTERN.match(value)\n    if match:\n        if match.group(1) == \"-\":\n            factor = -1\n        else:\n            factor = 1\n        return factor * timedelta(\n            days=int(match.group(\"d\") or 0),\n            hours=int(match.group(\"h\")),\n            minutes=int(match.group(\"m\")),\n            seconds=float(match.group(\"s\")),\n        )\n    else:\n        raise ValueError(\"Timespan value '{}' cannot be decoded\".format(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ingest_from_dataframe(self, df, ingestion_properties):\n\n        from pandas import DataFrame\n\n        if not isinstance(df, DataFrame):\n            raise ValueError(\"Expected DataFrame instance, found {}\".format(type(df)))\n\n        file_name = \"df_{timestamp}_{pid}.csv.gz\".format(timestamp=int(time.time()), pid=os.getpid())\n        temp_file_path = os.path.join(tempfile.gettempdir(), file_name)\n\n        df.to_csv(temp_file_path, index=False, encoding=\"utf-8\", header=False, compression=\"gzip\")\n\n        fd = FileDescriptor(temp_file_path)\n\n        blob_name = \"{db}__{table}__{guid}__{file}\".format(\n            db=ingestion_properties.database, table=ingestion_properties.table, guid=uuid.uuid4(), file=file_name\n        )\n\n        containers = self._resource_manager.get_containers()\n        container_details = random.choice(containers)\n        storage_client = CloudStorageAccount(container_details.storage_account_name, sas_token=container_details.sas)\n        blob_service = storage_client.create_block_blob_service()\n\n        blob_service.create_blob_from_path(\n            container_name=container_details.object_name, blob_name=blob_name, file_path=temp_file_path\n        )\n\n        url = blob_service.make_blob_url(container_details.object_name, blob_name, sas_token=container_details.sas)\n\n        self.ingest_from_blob(BlobDescriptor(url, fd.size), ingestion_properties=ingestion_properties)\n\n        fd.delete_files()\n        os.unlink(temp_file_path)", "response": "Enqueuing an ingest command from a pandas. DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting Kusto result tables into pandas DataFrame.", "response": "def dataframe_from_result_table(table):\n    import pandas as pd\n    from ._models import KustoResultTable\n    from dateutil.tz import UTC\n\n    \"\"\"Converts Kusto tables into pandas DataFrame.\n    :param azure.kusto.data._models.KustoResultTable table: Table received from the response.\n    :return: pandas DataFrame.\n    :rtype: pandas.DataFrame\n    \"\"\"\n    if not table:\n        raise ValueError()\n\n    if not isinstance(table, KustoResultTable):\n        raise TypeError(\"Expected KustoResultTable got {}\".format(type(table).__name__))\n\n    columns = [col.column_name for col in table.columns]\n    frame = pd.DataFrame(table._rows, columns=columns)\n\n    # fix types\n    for col in table.columns:\n        if col.column_type == \"bool\":\n            frame[col.column_name] = frame[col.column_name].astype(bool)\n\n    return frame"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a list to a json string", "response": "def _convert_list_to_json(array):\n    \"\"\" Converts array to a json string \"\"\"\n    return json.dumps(array, skipkeys=False, allow_nan=False, indent=None, separators=(\",\", \":\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a dictionary to a json string", "response": "def _convert_dict_to_json(array):\n    \"\"\" Converts array to a json string \"\"\"\n    return json.dumps(\n        array,\n        skipkeys=False,\n        allow_nan=False,\n        indent=None,\n        separators=(\",\", \":\"),\n        sort_keys=True,\n        default=lambda o: o.__dict__,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nassuming called on Travis, to prepare a package to be deployed This method prints on stdout for Travis. Return is obj to pass to sys.exit() directly", "response": "def travis_build_package():\n    \"\"\"Assumed called on Travis, to prepare a package to be deployed\n    This method prints on stdout for Travis.\n    Return is obj to pass to sys.exit() directly\n    \"\"\"\n    travis_tag = os.environ.get(\"TRAVIS_TAG\")\n    if not travis_tag:\n        print(\"TRAVIS_TAG environment variable is not present\")\n        return \"TRAVIS_TAG environment variable is not present\"\n\n    try:\n        version = Version(travis_tag)\n    except InvalidVersion:\n        failure = \"Version must be a valid PEP440 version (version is: {})\".format(version)\n        print(failure)\n        return failure\n\n    abs_dist_path = Path(os.environ[\"TRAVIS_BUILD_DIR\"], \"dist\")\n    [create_package(package, text_type(abs_dist_path)) for package in package_list]\n\n    print(\"Produced:\\n{}\".format(list(abs_dist_path.glob(\"*\"))))\n\n    pattern = \"*{}*\".format(version)\n    packages = list(abs_dist_path.glob(pattern))\n    if not packages:\n        return \"Package version does not match tag {}, abort\".format(version)\n    pypi_server = os.environ.get(\"PYPI_SERVER\", \"default PyPI server\")\n    print(\"Package created as expected and will be pushed to {}\".format(pypi_server))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef acquire_authorization_header(self):\n        try:\n            return self._acquire_authorization_header()\n        except AdalError as error:\n            if self._authentication_method is AuthenticationMethod.aad_username_password:\n                kwargs = {\"username\": self._username, \"client_id\": self._client_id}\n            elif self._authentication_method is AuthenticationMethod.aad_application_key:\n                kwargs = {\"client_id\": self._client_id}\n            elif self._authentication_method is AuthenticationMethod.aad_device_login:\n                kwargs = {\"client_id\": self._client_id}\n            elif self._authentication_method is AuthenticationMethod.aad_application_certificate:\n                kwargs = {\"client_id\": self._client_id, \"thumbprint\": self._thumbprint}\n            else:\n                raise error\n\n            kwargs[\"resource\"] = self._kusto_cluster\n            kwargs[\"authority\"] = self._adal_context.authority.url\n\n            raise KustoAuthenticationError(self._authentication_method.value, error, **kwargs)", "response": "Acquire tokens from AAD."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef with_aad_user_password_authentication(cls, connection_string, user_id, password, authority_id=\"common\"):\r\n        _assert_value_is_valid(user_id)\r\n        _assert_value_is_valid(password)\r\n        kcsb = cls(connection_string)\r\n        kcsb[kcsb.ValidKeywords.aad_federated_security] = True\r\n        kcsb[kcsb.ValidKeywords.aad_user_id] = user_id\r\n        kcsb[kcsb.ValidKeywords.password] = password\r\n        kcsb[kcsb.ValidKeywords.authority_id] = authority_id\r\n\r\n        return kcsb", "response": "Returns a new KustoConnection string builder that will authenticate with AAD user name and password."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef with_aad_application_key_authentication(cls, connection_string, aad_app_id, app_key, authority_id):\r\n        _assert_value_is_valid(aad_app_id)\r\n        _assert_value_is_valid(app_key)\r\n        _assert_value_is_valid(authority_id)\r\n        kcsb = cls(connection_string)\r\n        kcsb[kcsb.ValidKeywords.aad_federated_security] = True\r\n        kcsb[kcsb.ValidKeywords.application_client_id] = aad_app_id\r\n        kcsb[kcsb.ValidKeywords.application_key] = app_key\r\n        kcsb[kcsb.ValidKeywords.authority_id] = authority_id\r\n\r\n        return kcsb", "response": "Returns a new KustoConnection string builder that will authenticate with AAD application and key."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a new string builder that will authenticate with AAD application and a certificate credentials.", "response": "def with_aad_application_certificate_authentication(\r\n        cls, connection_string, aad_app_id, certificate, thumbprint, authority_id\r\n    ):\r\n        \"\"\"Creates a KustoConnection string builder that will authenticate with AAD application and\r\n        a certificate credentials.\r\n        :param str connection_string: Kusto connection string should by of the format:\r\n        https://<clusterName>.kusto.windows.net\r\n        :param str aad_app_id: AAD application ID.\r\n        :param str certificate: A PEM encoded certificate private key.\r\n        :param str thumbprint: hex encoded thumbprint of the certificate.\r\n        :param str authority_id: Authority id (aka Tenant id) must be provided\r\n        \"\"\"\r\n        _assert_value_is_valid(aad_app_id)\r\n        _assert_value_is_valid(certificate)\r\n        _assert_value_is_valid(thumbprint)\r\n        _assert_value_is_valid(authority_id)\r\n        kcsb = cls(connection_string)\r\n        kcsb[kcsb.ValidKeywords.aad_federated_security] = True\r\n        kcsb[kcsb.ValidKeywords.application_client_id] = aad_app_id\r\n        kcsb[kcsb.ValidKeywords.application_certificate] = certificate\r\n        kcsb[kcsb.ValidKeywords.application_certificate_thumbprint] = thumbprint\r\n        kcsb[kcsb.ValidKeywords.authority_id] = authority_id\r\n\r\n        return kcsb"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new KustoConnection string builder that will authenticate with AAD application and password.", "response": "def with_aad_device_authentication(cls, connection_string, authority_id=\"common\"):\r\n        \"\"\"Creates a KustoConnection string builder that will authenticate with AAD application and\r\n        password.\r\n        :param str connection_string: Kusto connection string should by of the format: https://<clusterName>.kusto.windows.net\r\n        :param str authority_id: optional param. defaults to \"common\"\r\n        \"\"\"\r\n        kcsb = cls(connection_string)\r\n        kcsb[kcsb.ValidKeywords.aad_federated_security] = True\r\n        kcsb[kcsb.ValidKeywords.authority_id] = authority_id\r\n\r\n        return kcsb"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes a query or management command.", "response": "def execute(self, database, query, properties=None):\r\n        \"\"\"Executes a query or management command.\r\n        :param str database: Database against query will be executed.\r\n        :param str query: Query to be executed.\r\n        :param azure.kusto.data.request.ClientRequestProperties properties: Optional additional properties.\r\n        :return: Kusto response data set.\r\n        :rtype: azure.kusto.data._response.KustoResponseDataSet\r\n        \"\"\"\r\n        if query.startswith(\".\"):\r\n            return self.execute_mgmt(database, query, properties)\r\n        return self.execute_query(database, query, properties)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute a query against a database.", "response": "def execute_query(self, database, query, properties=None):\r\n        \"\"\"Executes a query.\r\n        :param str database: Database against query will be executed.\r\n        :param str query: Query to be executed.\r\n        :param azure.kusto.data.request.ClientRequestProperties properties: Optional additional properties.\r\n        :return: Kusto response data set.\r\n        :rtype: azure.kusto.data._response.KustoResponseDataSet\r\n        \"\"\"\r\n        return self._execute(self._query_endpoint, database, query, KustoClient._query_default_timeout, properties)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting a management command.", "response": "def execute_mgmt(self, database, query, properties=None):\r\n        \"\"\"Executes a management command.\r\n        :param str database: Database against query will be executed.\r\n        :param str query: Query to be executed.\r\n        :param azure.kusto.data.request.ClientRequestProperties properties: Optional additional properties.\r\n        :return: Kusto response data set.\r\n        :rtype: azure.kusto.data._response.KustoResponseDataSet\r\n        \"\"\"\r\n        return self._execute(self._mgmt_endpoint, database, query, KustoClient._mgmt_default_timeout, properties)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _execute(self, endpoint, database, query, default_timeout, properties=None):\r\n\r\n        request_payload = {\"db\": database, \"csl\": query}\r\n        if properties:\r\n            request_payload[\"properties\"] = properties.to_json()\r\n\r\n        request_headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Accept-Encoding\": \"gzip,deflate\",\r\n            \"Content-Type\": \"application/json; charset=utf-8\",\r\n            \"x-ms-client-version\": \"Kusto.Python.Client:\" + VERSION,\r\n            \"x-ms-client-request-id\": \"KPC.execute;\" + str(uuid.uuid4()),\r\n        }\r\n\r\n        if self._auth_provider:\r\n            request_headers[\"Authorization\"] = self._auth_provider.acquire_authorization_header()\r\n\r\n        timeout = self._get_timeout(properties, default_timeout)\r\n        response = self._session.post(endpoint, headers=request_headers, json=request_payload, timeout=timeout.seconds)\r\n\r\n        if response.status_code == 200:\r\n            if endpoint.endswith(\"v2/rest/query\"):\r\n                return KustoResponseDataSetV2(response.json())\r\n            return KustoResponseDataSetV1(response.json())\r\n\r\n        raise KustoServiceError([response.json()], response)", "response": "Executes given query against this client"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef execute_streaming_ingest(\r\n        self,\r\n        database,\r\n        table,\r\n        stream,\r\n        stream_format,\r\n        mapping_name=None,\r\n        accept=None,\r\n        accept_encoding=\"gzip,deflate\",\r\n        connection=\"Keep-Alive\",\r\n        content_length=None,\r\n        content_encoding=None,\r\n        expect=None,\r\n    ):\r\n        \"\"\"Executes streaming ingest against this client.\r\n        :param str database: Target database.\r\n        :param str table: Target table.\r\n        :param io.BaseIO stream: stream object which contains the data to ingest.\r\n        :param DataFormat stream_format: Format of the data in the stream.\r\n        :param str mapping_name: Pre-defined mapping of the table. Required when stream_format is json/avro.\r\n        Other optional params: optional request headers as documented at:\r\n            https://kusto.azurewebsites.net/docs/api/rest/streaming-ingest.html\r\n        \"\"\"\r\n\r\n        request_params = {\"streamFormat\": stream_format}\r\n\r\n        if stream_format in self._mapping_required_formats and mapping_name is not None:\r\n            request_params[\"mappingName\"] = mapping_name\r\n\r\n        request_headers = {\r\n            \"Accept-Encoding\": accept_encoding,\r\n            \"Connection\": connection,\r\n            \"x-ms-client-version\": \"Kusto.Python.StreamingClient:\" + VERSION,\r\n            \"x-ms-client-request-id\": \"KPSC.execute;\" + str(uuid.uuid4()),\r\n            \"Host\": self._streaming_ingest_endpoint.split(\"/\")[2],\r\n        }\r\n\r\n        if accept is not None:\r\n            request_headers[\"Accept\"] = accept\r\n        if content_encoding is not None:\r\n            request_headers[\"Content-Encoding\"] = content_encoding\r\n        if expect is not None:\r\n            request_headers[\"Expect\"] = expect\r\n        if content_length is not None:\r\n            request_headers[\"Content-Length\"] = str(content_length)\r\n        if self._auth_provider:\r\n            request_headers[\"Authorization\"] = self._auth_provider.acquire_authorization_header()\r\n\r\n        response = self._session.post(\r\n            self._streaming_ingest_endpoint + database + \"/\" + table,\r\n            params=request_params,\r\n            headers=request_headers,\r\n            data=stream,\r\n            timeout=KustoClient._query_default_timeout,\r\n        )\r\n\r\n        if response.status_code == 200:\r\n            return KustoResponseDataSetV1(response.json())\r\n\r\n        raise KustoServiceError([response.content], response)", "response": "Executes a streaming ingest against this client."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset an option s value", "response": "def set_option(self, name, value):\r\n        \"\"\"Sets an option's value\"\"\"\r\n        _assert_value_is_valid(name)\r\n        self._options[name] = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(cls, uri):\n        match = _URI_FORMAT.search(uri)\n        return cls(match.group(1), match.group(2), match.group(3), match.group(4))", "response": "Parses a resource uri into a ResourceUri object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef peek(self, n=1, raw=False):\n\n        def _peek_specific_q(_q, _n):\n            has_messages = False\n            for m in _q.service.peek_messages(_q.name, num_messages=_n):\n                if m is not None:\n                    has_messages = True\n                    result.append(m if raw else self._deserialize_message(m))\n\n                    # short circut to prevent unneeded work\n                    if len(result) == n:\n                        return True\n            return has_messages\n\n        q_services = self._get_q_services()\n        random.shuffle(q_services)\n\n        per_q = int(n / len(q_services)) + 1\n\n        result = []\n\n        non_empty_qs = []\n\n        for q in q_services:\n            if _peek_specific_q(q, per_q):\n                non_empty_qs.append(q)\n\n            if len(result) == n:\n                return result\n\n        # in-case queues aren't balanced, and we didn't get enough messages, iterate again and this time get all that we can\n        for q in non_empty_qs:\n            _peek_specific_q(q, n)\n            if len(result) == n:\n                return result\n\n        # because we ask for n / len(qs) + 1, we might get more message then requests\n        return result", "response": "Return the status of the requested number of messages in the queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pop(self, n=1, raw=False, delete=True):\n\n        def _pop_specific_q(_q, _n):\n            has_messages = False\n            for m in _q.service.get_messages(_q.name, num_messages=_n):\n                if m is not None:\n                    has_messages = True\n                    result.append(m if raw else self._deserialize_message(m))\n                    if delete:\n                        _q.service.delete_message(_q.name, m.id, m.pop_receipt)\n\n                    # short circut to prevent unneeded work\n                    if len(result) == n:\n                        return True\n            return has_messages\n\n        q_services = self._get_q_services()\n        random.shuffle(q_services)\n\n        per_q = int(n / len(q_services)) + 1\n\n        result = []\n\n        non_empty_qs = []\n\n        for q in q_services:\n            if _pop_specific_q(q, per_q):\n                non_empty_qs.append(q)\n\n            if len(result) == n:\n                return result\n\n        # in-case queues aren't balanced, and we didn't get enough messages, iterate again and this time get all that we can\n        for q in non_empty_qs:\n            _pop_specific_q(q, n)\n            if len(result) == n:\n                return result\n\n        # because we ask for n / len(qs) + 1, we might get more message then requests\n        return result", "response": "Pop n messages from status queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ningesting from pandas DataFrame.", "response": "def ingest_from_dataframe(self, df, ingestion_properties):\n        \"\"\"Ingest from pandas DataFrame.\n        :param pandas.DataFrame df: input dataframe to ingest.\n        :param azure.kusto.ingest.IngestionProperties ingestion_properties: Ingestion properties.\n        \"\"\"\n\n        from pandas import DataFrame\n\n        if not isinstance(df, DataFrame):\n            raise ValueError(\"Expected DataFrame instance, found {}\".format(type(df)))\n\n        file_name = \"df_{timestamp}_{pid}.csv.gz\".format(timestamp=int(time.time()), pid=os.getpid())\n        temp_file_path = os.path.join(tempfile.gettempdir(), file_name)\n\n        df.to_csv(temp_file_path, index=False, encoding=\"utf-8\", header=False, compression=\"gzip\")\n\n        fd = FileDescriptor(temp_file_path)\n\n        ingestion_properties.format = DataFormat.csv\n        self._ingest(fd.zipped_stream, fd.size, ingestion_properties, content_encoding=\"gzip\")\n\n        fd.delete_files()\n        os.unlink(temp_file_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ningests from local files.", "response": "def ingest_from_file(self, file_descriptor, ingestion_properties):\n        \"\"\"Ingest from local files.\n        :param file_descriptor: a FileDescriptor to be ingested.\n        :param azure.kusto.ingest.IngestionProperties ingestion_properties: Ingestion properties.\n        \"\"\"\n\n        if isinstance(file_descriptor, FileDescriptor):\n            descriptor = file_descriptor\n        else:\n            descriptor = FileDescriptor(file_descriptor)\n\n        self._ingest(descriptor.zipped_stream, descriptor.size, ingestion_properties, content_encoding=\"gzip\")\n\n        descriptor.delete_files()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ningests from a stream.", "response": "def ingest_from_stream(self, stream_descriptor, ingestion_properties):\n        \"\"\"Ingest from io streams.\n        :param azure.kusto.ingest.StreamDescriptor stream_descriptor: An object that contains a description of the stream to\n               be ingested.\n        :param azure.kusto.ingest.IngestionProperties ingestion_properties: Ingestion properties.\n        \"\"\"\n\n        if not isinstance(stream_descriptor, StreamDescriptor):\n            stream_descriptor = StreamDescriptor(stream_descriptor)\n\n        if isinstance(stream_descriptor.stream, TextIOWrapper):\n            stream = stream_descriptor.stream.buffer\n        else:\n            stream = stream_descriptor.stream\n\n        self._ingest(stream, stream_descriptor.size, ingestion_properties)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndictate the corresponding mapping to the format.", "response": "def get_mapping_format(self):\n        \"\"\"Dictating the corresponding mapping to the format.\"\"\"\n        if self.format == DataFormat.json or self.format == DataFormat.avro:\n            return self.format.name\n        else:\n            return DataFormat.csv.name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getAtomChars(t):\n    s = c_char_p()\n    if PL_get_atom_chars(t, byref(s)):\n        return s.value\n    else:\n        raise InvalidTypeError(\"atom\")", "response": "Returns the atom character string of the given type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getBool(t):\n    b = c_int()\n    if PL_get_long(t, byref(b)):\n        return bool(b.value)\n    else:\n        raise InvalidTypeError(\"bool\")", "response": "Returns t if t is of type bool otherwise raise InvalidTypeError."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the value of a node in the tree tree.", "response": "def getLong(t):\n    \"\"\"If t is of type long, return it, otherwise raise InvalidTypeError.\n    \"\"\"\n    i = c_long()\n    if PL_get_long(t, byref(i)):\n        return i.value\n    else:\n        raise InvalidTypeError(\"long\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getFloat(t):\n    d = c_double()\n    if PL_get_float(t, byref(d)):\n        return d.value\n    else:\n        raise InvalidTypeError(\"float\")", "response": "Returns the value of t if it is of type float otherwise raise InvalidTypeError."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the string representation of t.", "response": "def getString(t):\n    \"\"\"If t is of type string, return it, otherwise raise InvalidTypeError.\n    \"\"\"\n    slen = c_int()\n    s = c_char_p()\n    if PL_get_string_chars(t, byref(s), byref(slen)):\n        return s.value\n    else:\n        raise InvalidTypeError(\"string\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn t as a list.", "response": "def getList(x):\n    \"\"\"\n    Return t as a list.\n    \"\"\"\n\n    t = PL_copy_term_ref(x)\n    head = PL_new_term_ref()\n    result = []\n    while PL_get_list(t, head, t):\n        result.append(getTerm(head))\n        head = PL_new_term_ref()\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef registerForeign(func, name=None, arity=None, flags=0):\n    global cwraps\n\n    if arity is None:\n        arity = func.arity\n\n    if name is None:\n        name = func.__name__\n\n    cwrap = _callbackWrapper(arity)\n    fwrap = _foreignWrapper(func)\n    fwrap2 = cwrap(fwrap)\n    cwraps.append(fwrap2)\n    return PL_register_foreign(name, arity, fwrap2, flags)", "response": "Register a Python predicate\n    function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef call(*terms, **kwargs):\n    for kwarg in kwargs:\n        if kwarg not in [\"module\"]:\n            raise KeyError\n\n    module = kwargs.get(\"module\", None)\n\n    t = terms[0]\n    for tx in terms[1:]:\n        t = _comma(t, tx)\n\n    return PL_call(t.handle, module)", "response": "Call a term in module.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef newModule(name):\n    if isinstance(name, str):\n        name = Atom(name)\n\n    return PL_new_module(name.handle)", "response": "Create a new module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating an atom from a Term or term handle.", "response": "def fromTerm(cls, term):\n        \"\"\"Create an atom from a Term or term handle.\"\"\"\n\n        if isinstance(term, Term):\n            term = term.handle\n        elif not isinstance(term, (c_void_p, int)):\n            raise ArgumentTypeError((str(Term), str(c_void_p)), str(type(term)))\n\n        a = atom_t()\n        if PL_get_atom(term, byref(a)):\n            return cls(a.value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a functor from a Term or term handle.", "response": "def fromTerm(cls, term):\n        \"\"\"Create a functor from a Term or term handle.\"\"\"\n\n        if isinstance(term, Term):\n            term = term.handle\n        elif not isinstance(term, (c_void_p, int)):\n            raise ArgumentTypeError((str(Term), str(int)), str(type(term)))\n\n        f = functor_t()\n        if PL_get_functor(term, byref(f)):\n            # get args\n            args = []\n            arity = PL_functor_arity(f.value)\n            # let's have all args be consecutive\n            a0 = PL_new_term_refs(arity)\n            for i, a in enumerate(range(1, arity + 1)):\n                if PL_get_arg(a, term, a0 + i):\n                    args.append(getTerm(a0 + i))\n\n            return cls(f.value, args=args, a0=a0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _findSwiplFromExec():\n\n    platform = sys.platform[:3]\n\n    fullName = None\n    swiHome = None\n\n    try: # try to get library path from swipl executable.\n\n        # We may have pl or swipl as the executable\n        try:\n            cmd = Popen(['swipl', '--dump-runtime-variables'], stdout=PIPE)\n        except OSError:\n            cmd = Popen(['pl', '--dump-runtime-variables'], stdout=PIPE)\n        ret = cmd.communicate()\n\n        # Parse the output into a dictionary\n        ret = ret[0].decode().replace(';', '').splitlines()\n        ret = [line.split('=', 1) for line in ret]\n        rtvars = dict((name, value[1:-1]) for name, value in ret) # [1:-1] gets\n                                                                  # rid of the\n                                                                  # quotes\n\n        if rtvars['PLSHARED'] == 'no':\n            raise ImportError('SWI-Prolog is not installed as a shared '\n                              'library.')\n        else: # PLSHARED == 'yes'\n            swiHome = rtvars['PLBASE']   # The environment is in PLBASE\n            if not os.path.exists(swiHome):\n                swiHome = None\n\n            # determine platform specific path\n            if platform == \"win\":\n                dllName = rtvars['PLLIB'][:-4] + '.' + rtvars['PLSOEXT']\n                path = os.path.join(rtvars['PLBASE'], 'bin')\n                fullName = os.path.join(path, dllName)\n\n                if not os.path.exists(fullName):\n                    fullName = None\n\n            elif platform == \"cyg\":\n                # e.g. /usr/lib/pl-5.6.36/bin/i686-cygwin/cygpl.dll\n\n                dllName = 'cygpl.dll'\n                path = os.path.join(rtvars['PLBASE'], 'bin', rtvars['PLARCH'])\n                fullName = os.path.join(path, dllName)\n\n                if not os.path.exists(fullName):\n                    fullName = None\n\n            elif platform == \"dar\":\n                dllName = 'lib' + rtvars['PLLIB'][2:] + '.' + rtvars['PLSOEXT']\n                path = os.path.join(rtvars['PLBASE'], 'lib', rtvars['PLARCH'])\n                baseName = os.path.join(path, dllName)\n\n                if os.path.exists(baseName):\n                    fullName = baseName\n                else:  # We will search for versions\n                    fullName = None\n\n            else: # assume UNIX-like\n                # The SO name in some linuxes is of the form libswipl.so.5.10.2,\n                # so we have to use glob to find the correct one\n                dllName = 'lib' + rtvars['PLLIB'][2:] + '.' + rtvars['PLSOEXT']\n                path = os.path.join(rtvars['PLBASE'], 'lib', rtvars['PLARCH'])\n                baseName = os.path.join(path, dllName)\n\n                if os.path.exists(baseName):\n                    fullName = baseName\n                else:  # We will search for versions\n                    pattern = baseName + '.*'\n                    files = glob.glob(pattern)\n                    if len(files) == 0:\n                        fullName = None\n                    elif len(files) == 1:\n                        fullName = files[0]\n                    else:  # Will this ever happen?\n                        fullName = None\n\n    except (OSError, KeyError): # KeyError from accessing rtvars\n        pass\n\n    return (fullName, swiHome)", "response": "This function tries to find the SWI - Prolog and the resource file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _findSwiplWin():\n    import re\n\n    \"\"\"\n    This function uses several heuristics to gues where SWI-Prolog is installed\n    in Windows. It always returns None as the path of the resource file because,\n    in Windows, the way to find it is more robust so the SWI-Prolog DLL is\n    always able to find it.\n\n    :returns:\n        A tuple of (path to the swipl DLL, path to the resource file)\n\n    :returns type:\n        ({str, None}, {str, None})\n    \"\"\"\n\n    dllNames = ('swipl.dll', 'libswipl.dll')\n\n    # First try: check the usual installation path (this is faster but\n    # hardcoded)\n    programFiles = os.getenv('ProgramFiles')\n    paths = [os.path.join(programFiles, r'pl\\bin', dllName)\n             for dllName in dllNames]\n    for path in paths:\n        if os.path.exists(path):\n            return (path, None)\n\n    # Second try: use the find_library\n    path = _findSwiplPathFromFindLib()\n    if path is not None and os.path.exists(path):\n        return (path, None)\n\n    # Third try: use reg.exe to find the installation path in the registry\n    # (reg should be installed in all Windows XPs)\n    try:\n        cmd = Popen(['reg', 'query',\n            r'HKEY_LOCAL_MACHINE\\Software\\SWI\\Prolog',\n            '/v', 'home'], stdout=PIPE)\n        ret = cmd.communicate()\n\n        # Result is like:\n        # ! REG.EXE VERSION 3.0\n        #\n        # HKEY_LOCAL_MACHINE\\Software\\SWI\\Prolog\n        #    home        REG_SZ  C:\\Program Files\\pl\n        # (Note: spaces may be \\t or spaces in the output)\n        ret = ret[0].splitlines()\n        ret = [line.decode(\"utf-8\") for line in ret if len(line) > 0]\n        pattern = re.compile('[^h]*home[^R]*REG_SZ( |\\t)*(.*)$')\n        match = pattern.match(ret[-1])\n        if match is not None:\n            path = match.group(2)\n\n            paths = [os.path.join(path, 'bin', dllName)\n                     for dllName in dllNames]\n            for path in paths:\n                if os.path.exists(path):\n                    return (path, None)\n\n    except OSError:\n        # reg.exe not found? Weird...\n        pass\n\n    # May the exec is on path?\n    (path, swiHome) = _findSwiplFromExec()\n    if path is not None:\n        return (path, swiHome)\n\n    # Last try: maybe it is in the current dir\n    for dllName in dllNames:\n        if os.path.exists(dllName):\n            return (dllName, None)\n\n    return (None, None)", "response": "This function uses several heuristics to gues where SWI - Prolog is installed in Windows."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef walk(path, name):\n    back_path = path[:]\n    path = os.path.join(path, name)\n    \n    if os.path.exists(path):\n        return path\n    else:\n        for dir_ in os.listdir(back_path):\n            path = os.path.join(back_path, dir_)\n\n            if os.path.isdir(path):\n                res_path = walk(path, name)\n                if res_path is not None:\n                    return (res_path, back_path)\n\n    return None", "response": "This function is a 2 - time recursive func that walks the directory tree and returns the path to the resource file that we findin."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _findSwiplMacOSHome():\n\n    # Need more help with MacOS\n    # That way works, but need more work\n    names = ['libswipl.dylib', 'libpl.dylib']\n    \n    path = os.environ.get('SWI_HOME_DIR')\n    if path is None:\n        path = os.environ.get('SWI_LIB_DIR')\n        if path is None:\n            path = os.environ.get('PLBASE')\n            if path is None:\n                swi_ver = get_swi_ver()\n                path = '/Applications/SWI-Prolog.app/Contents/swipl-' + swi_ver + '/lib/'\n    \n    paths = [path]\n\n    for name in names:\n        for path in paths:\n            (path_res, back_path) = walk(path, name)\n\n            if path_res is not None:\n                os.environ['SWI_LIB_DIR'] = back_path\n                return (path_res, None)\n\n    return (None, None)", "response": "This function is guesing where SWI - Prolog is installed in MacOS."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _findSwiplDar():\n\n    # If the exec is in path\n    (path, swiHome) = _findSwiplFromExec()\n    if path is not None:\n        return (path, swiHome)\n\n    # If it is not, use  find_library\n    path = _findSwiplPathFromFindLib()\n    if path is not None:\n        return (path, swiHome)\n\n    # Last guess, searching for the file\n    paths = ['.', './lib', '/usr/lib/', '/usr/local/lib', '/opt/local/lib']\n    names = ['libswipl.dylib', 'libpl.dylib']\n\n    for name in names:\n        for path in paths:\n            path = os.path.join(path, name)\n            if os.path.exists(path):\n                return (path, None)\n\n    return (None, None)", "response": "This function tries to guess where SWI - Prolog is installed in MacOS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _fixWindowsPath(dll):\n\n    if sys.platform[:3] != 'win':\n        return # Nothing to do here\n\n    pathToDll = os.path.dirname(dll)\n    currentWindowsPath = os.getenv('PATH')\n\n    if pathToDll not in currentWindowsPath:\n        # We will prepend the path, to avoid conflicts between DLLs\n        newPath = pathToDll + ';' + currentWindowsPath\n        os.putenv('PATH', newPath)", "response": "This function fixes the path to the DLL to be in Windows search path."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef str_to_bytes(string):\n    if string is None or isinstance(string, (int, c_char_p)):\n        return string\n\n    if not isinstance(string, bytes):\n        if string not in _stringMap:\n            _stringMap[string] = string.encode()\n        string = _stringMap[string]\n\n    return string", "response": "Converts a string into a bytes object if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_to_bytes_list(strList):\n    pList = c_char_p * len(strList)\n\n    # if strList is already a pointerarray or None, there is nothing to do\n    if isinstance(strList, (pList, type(None))):\n        return strList\n\n    if not isinstance(strList, (list, set, tuple)):\n        raise TypeError(\"strList must be list, set or tuple, not \" +\n                str(type(strList)))\n\n    pList = pList()\n    for i, elem in enumerate(strList):\n        pList[i] = str_to_bytes(elem)\n    return pList", "response": "This function turns an array of strings into a pointer array containing the encodings of those strings that are contained in bytes."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_strings(strings, arrays):\n\n    # if given a single element, turn it into a list\n    if isinstance(strings, int):\n        strings = [strings]\n    elif strings is None:\n        strings = []\n\n    # check if all entries are integers\n    for i,k in enumerate(strings):\n        if not isinstance(k, int):\n            raise TypeError(('Wrong type for index at {0} '+\n                    'in strings. Must be int, not {1}!').format(i,k))\n\n    # if given a single element, turn it into a list\n    if isinstance(arrays, int):\n        arrays = [arrays]\n    elif arrays is None:\n        arrays = []\n\n    # check if all entries are integers\n    for i,k in enumerate(arrays):\n        if not isinstance(k, int):\n            raise TypeError(('Wrong type for index at {0} '+\n                    'in arrays. Must be int, not {1}!').format(i,k))\n\n    # check if some index occurs in both\n    if set(strings).intersection(arrays):\n        raise ValueError('One or more elements occur in both arrays and ' +\n                ' strings. One parameter cannot be both list and string!')\n\n    # create the checker that will check all arguments given by argsToCheck\n    # and turn them into the right datatype.\n    def checker(func):\n        def check_and_call(*args):\n            args = list(args)\n            for i in strings:\n                arg = args[i]\n                args[i] = str_to_bytes(arg)\n            for i in arrays:\n                arg = args[i]\n                args[i] = list_to_bytes_list(arg)\n\n            return func(*args)\n\n        return check_and_call\n\n    return checker", "response": "Decorator function that checks if the given strings and arrays are valid and returns a checker function that can be used to automatically turn an incoming string into a bytes object and an incoming list to a pointer array if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning a prolog query and return a generator of dicts with keys as keys.", "response": "def query(cls, query, maxresult=-1, catcherrors=True, normalize=True):\n        \"\"\"Run a prolog query and return a generator.\n        If the query is a yes/no question, returns {} for yes, and nothing for no.\n        Otherwise returns a generator of dicts with variables as keys.\n\n        >>> prolog = Prolog()\n        >>> prolog.assertz(\"father(michael,john)\")\n        >>> prolog.assertz(\"father(michael,gina)\")\n        >>> bool(list(prolog.query(\"father(michael,john)\")))\n        True\n        >>> bool(list(prolog.query(\"father(michael,olivia)\")))\n        False\n        >>> print sorted(prolog.query(\"father(michael,X)\"))\n        [{'X': 'gina'}, {'X': 'john'}]\n        \"\"\"\n        return cls._QueryWrapper()(query, maxresult, catcherrors, normalize)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calculate_size(uuid, partition_id, interrupt):\n    data_size = 0\n    data_size += calculate_size_str(uuid)\n    data_size += INT_SIZE_IN_BYTES\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nencoding a request into a client_message.", "response": "def encode_request(uuid, partition_id, interrupt):\n    \"\"\" Encode request into client_message\"\"\"\n    client_message = ClientMessage(payload_size=calculate_size(uuid, partition_id, interrupt))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(uuid)\n    client_message.append_int(partition_id)\n    client_message.append_bool(interrupt)\n    client_message.update_frame_length()\n    return client_message"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the size of the request payload.", "response": "def calculate_size(name, include_value, local_only):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decode_response(client_message, to_object=None):\n    parameters = dict(response=None)\n    parameters['response'] = client_message.read_str()\n    return parameters", "response": "Decode response from client message"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle(client_message, handle_event_entry=None, to_object=None):\n    message_type = client_message.get_message_type()\n    if message_type == EVENT_ENTRY and handle_event_entry is not None:\n        key = None\n        if not client_message.read_bool():\n            key = client_message.read_data()\n        value = None\n        if not client_message.read_bool():\n            value = client_message.read_data()\n        old_value = None\n        if not client_message.read_bool():\n            old_value = client_message.read_data()\n        merging_value = None\n        if not client_message.read_bool():\n            merging_value = client_message.read_data()\n        event_type = client_message.read_int()\n        uuid = client_message.read_str()\n        number_of_affected_entries = client_message.read_int()\n        handle_event_entry(key=key, value=value, old_value=old_value, merging_value=merging_value, event_type=event_type, uuid=uuid, number_of_affected_entries=number_of_affected_entries)", "response": "Handles the client message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculate_size(name, function):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_data(function)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndecode response from client message", "response": "def decode_response(client_message, to_object=None):\n    \"\"\" Decode response from client message\"\"\"\n    parameters = dict(response=None)\n    if not client_message.read_bool():\n        parameters['response'] = to_object(client_message.read_data())\n    return parameters"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calculate_size(name, expected):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    if expected is not None:\n        data_size += calculate_size_data(expected)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate the size of the request payload.", "response": "def calculate_size(name, permits):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the size of the request payload.", "response": "def calculate_size(name, value_list):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    for value_list_item in value_list:\n        data_size += calculate_size_data(value_list_item)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode_request(name, value_list):\n    client_message = ClientMessage(payload_size=calculate_size(name, value_list))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_int(len(value_list))\n    for value_list_item in value_list:\n        client_message.append_data(value_list_item)\n    client_message.update_frame_length()\n    return client_message", "response": "Encode a request into a client_message"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, item):\n        def result_fnc(f):\n            if f.result():\n                return True\n            raise Full(\"Queue is full!\")\n\n        return self.offer(item).continue_with(result_fnc)", "response": "Adds the specified item to this queue if there is available space."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_all(self, items):\n        check_not_none(items, \"Value can't be None\")\n        data_items = []\n        for item in items:\n            check_not_none(item, \"Value can't be None\")\n            data_items.append(self._to_data(item))\n        return self._encode_invoke(queue_add_all_codec, data_list=data_items)", "response": "Adds the specified items to this queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a listener for all items in the queue.", "response": "def add_listener(self, include_value=False, item_added_func=None, item_removed_func=None):\n        \"\"\"\n        Adds an item listener for this queue. Listener will be notified for all queue add/remove events.\n\n        :param include_value: (bool), whether received events include the updated item or not (optional).\n        :param item_added_func: Function to be called when an item is added to this set (optional).\n        :param item_removed_func: Function to be called when an item is deleted from this set (optional).\n        :return: (str), a registration id which is used as a key to remove the listener.\n        \"\"\"\n        request = queue_add_listener_codec.encode_request(self.name, include_value, False)\n\n        def handle_event_item(item, uuid, event_type):\n            item = item if include_value else None\n            member = self._client.cluster.get_member_by_uuid(uuid)\n\n            item_event = ItemEvent(self.name, item, event_type, member, self._to_object)\n            if event_type == ItemEventType.added:\n                if item_added_func:\n                    item_added_func(item_event)\n            else:\n                if item_removed_func:\n                    item_removed_func(item_event)\n\n        return self._start_listening(request,\n                                     lambda m: queue_add_listener_codec.handle(m, handle_event_item),\n                                     lambda r: queue_add_listener_codec.decode_response(r)['response'],\n                                     self.partition_key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines whether this queue contains all of the specified items in the specified collection or not.", "response": "def contains_all(self, items):\n        \"\"\"\n        Determines whether this queue contains all of the items in the specified collection or not.\n\n        :param items: (Collection), the specified collection which includes the items to be searched.\n        :return: (bool), ``true`` if all of the items in the specified collection exist in this queue, ``false`` otherwise.\n        \"\"\"\n        check_not_none(items, \"Items can't be None\")\n        data_items = []\n        for item in items:\n            check_not_none(item, \"item can't be None\")\n            data_items.append(self._to_data(item))\n        return self._encode_invoke(queue_contains_all_codec, data_list=data_items)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef offer(self, item, timeout=0):\n        check_not_none(item, \"Value can't be None\")\n        element_data = self._to_data(item)\n        return self._encode_invoke(queue_offer_codec, value=element_data, timeout_millis=to_millis(timeout))", "response": "Adds an item into this queue if it is available. Returns true if the item was added to this queue. Returns false otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the specified item into this queue. If there is no space it waits until necessary space becomes available.", "response": "def put(self, item):\n        \"\"\"\n        Adds the specified element into this queue. If there is no space, it waits until necessary space becomes\n        available.\n\n        :param item: (object), the specified item.\n        \"\"\"\n        check_not_none(item, \"Value can't be None\")\n        element_data = self._to_data(item)\n        return self._encode_invoke(queue_put_codec, value=element_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_all(self, items):\n        check_not_none(items, \"Value can't be None\")\n        data_items = []\n        for item in items:\n            check_not_none(item, \"Value can't be None\")\n            data_items.append(self._to_data(item))\n        return self._encode_invoke(queue_compare_and_remove_all_codec, data_list=data_items)", "response": "Removes all of the elements of the specified collection from this queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_listener(self, registration_id):\n        return self._stop_listening(registration_id, lambda i: queue_remove_listener_codec.encode_request(self.name, i))", "response": "Removes the specified item listener. Returns silently if the specified listener was not added before."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef retain_all(self, items):\n        check_not_none(items, \"Value can't be None\")\n        data_items = []\n        for item in items:\n            check_not_none(item, \"Value can't be None\")\n            data_items.append(self._to_data(item))\n        return self._encode_invoke(queue_compare_and_retain_all_codec, data_list=data_items)", "response": "Removes the items which are not contained in the specified collection and returns True if this queue changed as a result of the call."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decode_response(client_message, to_object=None):\n    parameters = dict(partitions=None)\n    partitions_size = client_message.read_int()\n    partitions = {}\n    for _ in range(0, partitions_size):\n        partitions_key = AddressCodec.decode(client_message, to_object)\n        partitions_val_size = client_message.read_int()\n        partitions_val = []\n        for _ in range(0, partitions_val_size):\n            partitions_val_item = client_message.read_int()\n            partitions_val.append(partitions_val_item)\n        partitions[partitions_key] = partitions_val\n    parameters['partitions'] = partitions\n    return parameters", "response": "Decode response from client message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the size of the request payload.", "response": "def calculate_size(name, data_list):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    for data_list_item in data_list:\n        data_size += calculate_size_data(data_list_item)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencoding a request into a client_message", "response": "def encode_request(name, data_list):\n    \"\"\" Encode request into client_message\"\"\"\n    client_message = ClientMessage(payload_size=calculate_size(name, data_list))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_int(len(data_list))\n    for data_list_item in data_list:\n        client_message.append_data(data_list_item)\n    client_message.update_frame_length()\n    return client_message"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculate_size(name, new_value):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the given value to the current value and returns the previous value.", "response": "def get_and_add(self, delta):\n        \"\"\"\n        Adds the given value to the current value and returns the previous value.\n\n        :raises NoDataMemberInClusterError: if the cluster does not contain any data members.\n        :raises UnsupportedOperationError: if the cluster version is less than 3.10.\n        :raises ConsistencyLostError: if the session guarantees have been lost.\n\n        :param delta: (int), the value to add.\n        :return: (int), the previous value.\n        \"\"\"\n\n        return self._invoke_internal(pn_counter_add_codec, delta=delta, get_before_update=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding the given value to the current value and returns the updated value.", "response": "def add_and_get(self, delta):\n        \"\"\"\n        Adds the given value to the current value and returns the updated value.\n\n        :raises NoDataMemberInClusterError: if the cluster does not contain any data members.\n        :raises UnsupportedOperationError: if the cluster version is less than 3.10.\n        :raises ConsistencyLostError: if the session guarantees have been lost.\n\n        :param delta: (int), the value to add.\n        :return: (int), the updated value.\n        \"\"\"\n\n        return self._invoke_internal(pn_counter_add_codec, delta=delta, get_before_update=False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_and_subtract(self, delta):\n\n        return self._invoke_internal(pn_counter_add_codec, delta=-1 * delta, get_before_update=True)", "response": "Subtracts the given value from the current value and returns the previous value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsubtracts the given value from the current value and returns the updated value.", "response": "def subtract_and_get(self, delta):\n        \"\"\"\n        Subtracts the given value from the current value and returns the updated value.\n\n        :raises NoDataMemberInClusterError: if the cluster does not contain any data members.\n        :raises UnsupportedOperationError: if the cluster version is less than 3.10.\n        :raises ConsistencyLostError: if the session guarantees have been lost.\n\n        :param delta: (int), the value to subtract.\n        :return: (int), the updated value.\n        \"\"\"\n\n        return self._invoke_internal(pn_counter_add_codec, delta=-1 * delta, get_before_update=False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecode response from client message", "response": "def decode_response(client_message, to_object=None):\n    \"\"\" Decode response from client message\"\"\"\n    parameters = dict(response=None)\n    parameters['response'] = client_message.read_int()\n    return parameters"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles an event from the server.", "response": "def handle(client_message, handle_event_map_partition_lost=None, to_object=None):\n    \"\"\" Event handler \"\"\"\n    message_type = client_message.get_message_type()\n    if message_type == EVENT_MAPPARTITIONLOST and handle_event_map_partition_lost is not None:\n        partition_id = client_message.read_int()\n        uuid = client_message.read_str()\n        handle_event_map_partition_lost(partition_id=partition_id, uuid=uuid)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add(self, item):\n        check_not_none(item, \"item can't be none\")\n        return self._encode_invoke(transactional_list_add_codec, item=self._to_data(item))", "response": "Adds the specified item to the end of the list."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove(self, item):\n        check_not_none(item, \"item can't be none\")\n        return self._encode_invoke(transactional_list_remove_codec, item=self._to_data(item))", "response": "Removes the specified item from the list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the size of the request payload.", "response": "def calculate_size(name, permits, timeout):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the size of the request payload.", "response": "def calculate_size(name, service_name):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_str(service_name)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the IdGenerator proxy for the given name.", "response": "def get_id_generator(self, name):\n        \"\"\"\n        Creates cluster-wide :class:`~hazelcast.proxy.id_generator.IdGenerator`.\n\n        :param name: (str), name of the IdGenerator proxy.\n        :return: (:class:`~hazelcast.proxy.id_generator.IdGenerator`), IdGenerator proxy for the given name.\n        \"\"\"\n        atomic_long = self.get_atomic_long(ID_GENERATOR_ATOMIC_LONG_PREFIX + name)\n        return self.proxy.get_or_create(ID_GENERATOR_SERVICE, name, atomic_long=atomic_long)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef new_transaction(self, timeout=120, durability=1, type=TWO_PHASE):\n        return self.transaction_manager.new_transaction(timeout, durability, type)", "response": "Creates a new Transaction associated with the current thread."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshut down this HazelcastClient.", "response": "def shutdown(self):\n        \"\"\"\n        Shuts down this HazelcastClient.\n        \"\"\"\n        if self.lifecycle.is_live:\n            self.lifecycle.fire_lifecycle_event(LIFECYCLE_STATE_SHUTTING_DOWN)\n            self.near_cache_manager.destroy_all_near_caches()\n            self.statistics.shutdown()\n            self.partition_service.shutdown()\n            self.heartbeat.shutdown()\n            self.cluster.shutdown()\n            self.reactor.shutdown()\n            self.lifecycle.fire_lifecycle_event(LIFECYCLE_STATE_SHUTDOWN)\n            self.logger.info(\"Client shutdown.\", extra=self._logger_extras)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle(client_message, handle_event_member=None, handle_event_member_list=None, handle_event_member_attribute_change=None, to_object=None):\n    message_type = client_message.get_message_type()\n    if message_type == EVENT_MEMBER and handle_event_member is not None:\n        member = MemberCodec.decode(client_message, to_object)\n        event_type = client_message.read_int()\n        handle_event_member(member=member, event_type=event_type)\n    if message_type == EVENT_MEMBERLIST and handle_event_member_list is not None:\n        members_size = client_message.read_int()\n        members = []\n        for _ in range(0, members_size):\n            members_item = MemberCodec.decode(client_message, to_object)\n            members.append(members_item)\n        handle_event_member_list(members=members)\n    if message_type == EVENT_MEMBERATTRIBUTECHANGE and handle_event_member_attribute_change is not None:\n        uuid = client_message.read_str()\n        key = client_message.read_str()\n        operation_type = client_message.read_int()\n        value = None\n        if not client_message.read_bool():\n            value = client_message.read_str()\n        handle_event_member_attribute_change(uuid=uuid, key=key, operation_type=operation_type, value=value)", "response": "Handles the given client message."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_listener(self, on_message=None):\n        request = topic_add_message_listener_codec.encode_request(self.name, False)\n\n        def handle(item, publish_time, uuid):\n            member = self._client.cluster.get_member_by_uuid(uuid)\n            item_event = TopicMessage(self.name, item, publish_time, member, self._to_object)\n            on_message(item_event)\n\n        return self._start_listening(request,\n                                     lambda m: topic_add_message_listener_codec.handle(m, handle),\n                                     lambda r: topic_add_message_listener_codec.decode_response(r)['response'],\n                                     self.partition_key)", "response": "Subscribe to this topic. When someone publishes a message on this topic on_message is called when a message is published on this topic."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npublish the message to all subscribers of this topic.", "response": "def publish(self, message):\n        \"\"\"\n        Publishes the message to all subscribers of this topic\n\n        :param message: (object), the message to be published.\n        \"\"\"\n        message_data = self._to_data(message)\n        self._encode_invoke(topic_publish_codec, message=message_data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_listener(self, registration_id):\n        return self._stop_listening(registration_id,\n                                    lambda i: topic_remove_message_listener_codec.encode_request(self.name, i))", "response": "Stops receiving messages for the given registration id."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the size of the request payload.", "response": "def calculate_size(name, from_, to):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    data_size += INT_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encode_request(name, from_, to):\n    client_message = ClientMessage(payload_size=calculate_size(name, from_, to))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_int(from_)\n    client_message.append_int(to)\n    client_message.update_frame_length()\n    return client_message", "response": "Encode a request into a client_message."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decode_response(client_message, to_object=None):\n    parameters = dict(response=None)\n    response_size = client_message.read_int()\n    response = []\n    for _ in range(0, response_size):\n        response_item = client_message.read_data()\n        response.append(response_item)\n    parameters['response'] = ImmutableLazyDataList(response, to_object)\n    return parameters", "response": "Decode response from client message"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating the serializer for given type.", "response": "def validate_serializer(serializer, _type):\n    \"\"\"\n    Validates the serializer for given type.\n\n    :param serializer: (Serializer), the serializer to be validated.\n    :param _type: (Type), type to be used for serializer validation.\n    \"\"\"\n    if not issubclass(serializer, _type):\n        raise ValueError(\"Serializer should be an instance of {}\".format(_type.__name__))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef enum(**enums):\n    enums['reverse'] = dict((value, key) for key, value in six.iteritems(enums))\n    return type('Enum', (), enums)", "response": "Utility method for defining enums."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert the value to seconds in the given time_unit", "response": "def to_seconds(value, time_unit):\n        \"\"\"\n        :param value: (Number), value to be translated to seconds\n        :param time_unit: Time duration in seconds\n        :return: Value of the value in seconds\n        \"\"\"\n        if isinstance(value, bool):\n            # bool is a subclass of int. Don't let bool and float multiplication.\n            raise TypeError\n        return float(value) * time_unit"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculate_size(name, listener_flags, local_only):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle an event in the IMAP archive.", "response": "def handle(client_message, handle_event_imap_invalidation=None, handle_event_imap_batch_invalidation=None, to_object=None):\n    \"\"\" Event handler \"\"\"\n    message_type = client_message.get_message_type()\n    if message_type == EVENT_IMAPINVALIDATION and handle_event_imap_invalidation is not None:\n        key = None\n        if not client_message.read_bool():\n            key = client_message.read_data()\n        handle_event_imap_invalidation(key=key)\n    if message_type == EVENT_IMAPBATCHINVALIDATION and handle_event_imap_batch_invalidation is not None:\n        keys_size = client_message.read_int()\n        keys = []\n        for _ in range(0, keys_size):\n            keys_item = client_message.read_data()\n            keys.append(keys_item)\n        handle_event_imap_batch_invalidation(keys=keys)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_exception(error_codec):\n    if error_codec.error_code in ERROR_CODE_TO_ERROR:\n        return ERROR_CODE_TO_ERROR[error_codec.error_code](error_codec.message)\n\n    stack_trace = \"\\n\".join(\n        [\"\\tat %s.%s(%s:%s)\" % (x.declaring_class, x.method_name, x.file_name, x.line_number) for x in\n         error_codec.stack_trace])\n    message = \"Got exception from server:\\n %s: %s\\n %s\" % (error_codec.class_name,\n                                                            error_codec.message,\n                                                            stack_trace)\n    return HazelcastError(message)", "response": "Creates an exception with given error codec."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the size of the data payload.", "response": "def calculate_size(name, start_sequence, min_count, max_count, filter):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += LONG_SIZE_IN_BYTES\n    data_size += INT_SIZE_IN_BYTES\n    data_size += INT_SIZE_IN_BYTES\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    if filter is not None:\n        data_size += calculate_size_data(filter)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encode_request(name, start_sequence, min_count, max_count, filter):\n    client_message = ClientMessage(payload_size=calculate_size(name, start_sequence, min_count, max_count, filter))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_long(start_sequence)\n    client_message.append_int(min_count)\n    client_message.append_int(max_count)\n    client_message.append_bool(filter is None)\n    if filter is not None:\n        client_message.append_data(filter)\n    client_message.update_frame_length()\n    return client_message", "response": "Encode a request into a client_message."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode_response(client_message, to_object=None):\n    parameters = dict(read_count=None, items=None)\n    parameters['read_count'] = client_message.read_int()\n    items_size = client_message.read_int()\n    items = []\n    for _ in range(0, items_size):\n        items_item = client_message.read_data()\n        items.append(items_item)\n    parameters['items'] = ImmutableLazyDataList(items, to_object)\n    return parameters", "response": "Decode response from client message into dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the size of the request payload.", "response": "def calculate_size(name, items):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    for items_item in items:\n        data_size += calculate_size_data(items_item)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef encode_request(name, items):\n    client_message = ClientMessage(payload_size=calculate_size(name, items))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_int(len(items))\n    for items_item in items:\n        client_message.append_data(items_item)\n    client_message.update_frame_length()\n    return client_message", "response": "Encode request into client_message"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef capacity(self):\n        if not self._capacity:\n            def cache_capacity(f):\n                self._capacity = f.result()\n                return f.result()\n\n            return self._encode_invoke(ringbuffer_capacity_codec).continue_with(cache_capacity)\n        return ImmediateFuture(self._capacity)", "response": "Returns the capacity of this Ringbuffer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(self, item, overflow_policy=OVERFLOW_POLICY_OVERWRITE):\n        return self._encode_invoke(ringbuffer_add_codec, value=self._to_data(item), overflow_policy=overflow_policy)", "response": "Adds the specified item to the tail of the Ringbuffer. If there is no space in the Ringbuffer the action is is\n        determined by overflow_policy as OverflowPolicyOverWrite. If the space in the Ringbuffer is not empty the action is is\n        determined by overflow_policy as OverflowPolicyFail."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds all of the items in the specified collection to the tail of the Ringbuffer.", "response": "def add_all(self, items, overflow_policy=OVERFLOW_POLICY_OVERWRITE):\n        \"\"\"\n        Adds all of the item in the specified collection to the tail of the Ringbuffer. An add_all is likely to\n        outperform multiple calls to add(object) due to better io utilization and a reduced number of executed\n        operations. The items are added in the order of the Iterator of the collection.\n\n        If there is no space in the Ringbuffer, the action is determined by overflow policy as :const:`OVERFLOW_POLICY_OVERWRITE`\n        or :const:`OVERFLOW_POLICY_FAIL`.\n\n        :param items: (Collection), the specified collection which contains the items to be added.\n        :param overflow_policy: (int), the OverflowPolicy to be used when there is no space (optional).\n        :return: (long), the sequenceId of the last written item, or -1 of the last write is failed.\n        \"\"\"\n        check_not_empty(items, \"items can't be empty\")\n        if len(items) > MAX_BATCH_SIZE:\n            raise AssertionError(\"Batch size can't be greater than %d\" % MAX_BATCH_SIZE)\n        for item in items:\n            check_not_none(item, \"item can't be None\")\n\n        item_list = [self._to_data(x) for x in items]\n        return self._encode_invoke(ringbuffer_add_all_codec, value_list=item_list, overflow_policy=overflow_policy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread one item from the Ringbuffer.", "response": "def read_one(self, sequence):\n        \"\"\"\n        Reads one item from the Ringbuffer. If the sequence is one beyond the current tail, this call blocks until an\n        item is added. Currently it isn't possible to control how long this call is going to block.\n\n        :param sequence: (long), the sequence of the item to read.\n        :return: (object), the read item.\n        \"\"\"\n        check_not_negative(sequence, \"sequence can't be smaller than 0\")\n        return self._encode_invoke(ringbuffer_read_one_codec, sequence=sequence)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_many(self, start_sequence, min_count, max_count):\n        check_not_negative(start_sequence, \"sequence can't be smaller than 0\")\n        check_true(max_count >= min_count, \"max count should be greater or equal to min count\")\n        check_true(min_count <= self.capacity().result(), \"min count should be smaller or equal to capacity\")\n        check_true(max_count < MAX_BATCH_SIZE, \"max count can't be greater than %d\" % MAX_BATCH_SIZE)\n\n        return self._encode_invoke(ringbuffer_read_many_codec, response_handler=self._read_many_response_handler,\n                                   start_sequence=start_sequence, min_count=min_count,\n                                   max_count=max_count, filter=None)", "response": "Reads a batch of items from the Ringbuffer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the size of the request payload.", "response": "def calculate_size(name, reduction):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculate_size(timeout, durability, transaction_type, thread_id):\n    data_size = 0\n    data_size += LONG_SIZE_IN_BYTES\n    data_size += INT_SIZE_IN_BYTES\n    data_size += INT_SIZE_IN_BYTES\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nencode a request into a client_message", "response": "def encode_request(timeout, durability, transaction_type, thread_id):\n    \"\"\" Encode request into client_message\"\"\"\n    client_message = ClientMessage(payload_size=calculate_size(timeout, durability, transaction_type, thread_id))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_long(timeout)\n    client_message.append_int(durability)\n    client_message.append_int(transaction_type)\n    client_message.append_long(thread_id)\n    client_message.update_frame_length()\n    return client_message"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init(self, id):\n\n        # Add 1 hour worth of IDs as a reserve: due to long batch validity some clients might be still getting\n        # older IDs. 1 hour is just a safe enough value, not a real guarantee: some clients might have longer\n        # validity.\n        # The init method should normally be called before any client generated IDs: in this case no reserve is\n        # needed, so we don't want to increase the reserve excessively.\n        reserve = to_millis(TimeUnit.HOUR) << (FlakeIdGenerator._BITS_NODE_ID + FlakeIdGenerator._BITS_SEQUENCE)\n        return self.new_id().continue_with(lambda f: f.result() >= (id + reserve))", "response": "This method will return True if the next ID will be larger than the supplied ID False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntry to initialize this IdGenerator instance with the given id.", "response": "def init(self, initial):\n        \"\"\"\n        Try to initialize this IdGenerator instance with the given id. The first generated id will be 1 greater than id.\n\n        :param initial: (long), the given id.\n        :return: (bool), ``true`` if initialization succeeded, ``false`` if id is less than 0.\n        \"\"\"\n        if initial <= 0:\n            return False\n        step = initial // BLOCK_SIZE\n        with self._lock:\n            init = self._atomic_long.compare_and_set(0, step + 1).result()\n            if init:\n                self._local = step\n                self._residue = (initial % BLOCK_SIZE) + 1\n            return init"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef new_id(self):\n        with self._lock:\n            curr = self._residue\n            self._residue += 1\n            if self._residue >= BLOCK_SIZE:\n                increment = self._atomic_long.get_and_increment().result()\n                self._local = increment\n                self._residue = 0\n                return self.new_id()\n            return self._local * BLOCK_SIZE + curr", "response": "Generates and returns a new unique id."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calculate_size(name, id):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_str(id)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef offer(self, item, timeout=0):\n        check_not_none(item, \"item can't be none\")\n        return self._encode_invoke(transactional_queue_offer_codec, item=self._to_data(item),\n                                   timeout=to_millis(timeout))", "response": "Offer an item to the queue."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calculate_size(name, service_name, target):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_str(service_name)\n    data_size += calculate_size_address(target)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the size of the request payload.", "response": "def calculate_size(name, entry_processor):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_data(entry_processor)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstore the value for the specified key - value tuple in the multimap. Returns True if the size of the multimap is increased False otherwise.", "response": "def put(self, key, value):\n        \"\"\"\n        Transactional implementation of :func:`MultiMap.put(key, value) <hazelcast.proxy.multi_map.MultiMap.put>`\n\n        :param key: (object), the key to be stored.\n        :param value: (object), the value to be stored.\n        :return: (bool), ``true`` if the size of the multimap is increased, ``false`` if the multimap already contains the\n        key-value tuple.\n        \"\"\"\n        check_not_none(key, \"key can't be none\")\n        check_not_none(value, \"value can't be none\")\n        return self._encode_invoke(transactional_multi_map_put_codec, key=self._to_data(key),\n                                   value=self._to_data(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, key):\n        check_not_none(key, \"key can't be none\")\n        return self._encode_invoke(transactional_multi_map_get_codec, key=self._to_data(key))", "response": "Gets the value associated with the specified key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the specified key - value pair from this MultiMap.", "response": "def remove(self, key, value):\n        \"\"\"\n        Transactional implementation of :func:`MultiMap.remove(key, value)\n        <hazelcast.proxy.multi_map.MultiMap.remove>`\n\n        :param key: (object), the key of the entry to remove.\n        :param value: (object), the value of the entry to remove.\n        :return:\n        \"\"\"\n        check_not_none(key, \"key can't be none\")\n        check_not_none(value, \"value can't be none\")\n        return self._encode_invoke(transactional_multi_map_remove_entry_codec, key=self._to_data(key),\n                                   value=self._to_data(value))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_all(self, key):\n        check_not_none(key, \"key can't be none\")\n        return self._encode_invoke(transactional_multi_map_remove_codec, key=self._to_data(key))", "response": "Removes all entries associated with the specified key from this MultiMap."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef value_count(self, key):\n        check_not_none(key, \"key can't be none\")\n        return self._encode_invoke(transactional_multi_map_value_count_codec, key=self._to_data(key))", "response": "Gets the number of values matching the given key in the multimap."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calculate_size(name, batch_size):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndecode response from client message", "response": "def decode_response(client_message, to_object=None):\n    \"\"\" Decode response from client message\"\"\"\n    parameters = dict(base=None, increment=None, batch_size=None)\n    parameters['base'] = client_message.read_long()\n    parameters['increment'] = client_message.read_long()\n    parameters['batch_size'] = client_message.read_int()\n    return parameters"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calculate_size(name, expected, updated):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    if expected is not None:\n        data_size += calculate_size_data(expected)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    if updated is not None:\n        data_size += calculate_size_data(updated)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef encode_request(name, expected, updated):\n    client_message = ClientMessage(payload_size=calculate_size(name, expected, updated))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_bool(expected is None)\n    if expected is not None:\n        client_message.append_data(expected)\n    client_message.append_bool(updated is None)\n    if updated is not None:\n        client_message.append_data(updated)\n    client_message.update_frame_length()\n    return client_message", "response": "Encode a request into a client_message."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calculate_size(name, max_size):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nencode a request into a client_message.", "response": "def encode_request(name, max_size):\n    \"\"\" Encode request into client_message\"\"\"\n    client_message = ClientMessage(payload_size=calculate_size(name, max_size))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_int(max_size)\n    client_message.update_frame_length()\n    return client_message"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute_on_key_owner(self, key, task):\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        partition_id = self._client.partition_service.get_partition_id(key_data)\n\n        uuid = self._get_uuid()\n        return self._encode_invoke_on_partition(executor_service_submit_to_partition_codec, partition_id,\n                                                uuid=uuid, callable=self._to_data(task),\n                                                partition_id=partition_id)", "response": "Executes a task on the owner of the specified key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting a task on the specified member.", "response": "def execute_on_member(self, member, task):\n        \"\"\"\n        Executes a task on the specified member.\n\n        :param member: (Member), the specified member.\n        :param task: (Task), the task executed on the specified member.\n        :return: (:class:`~hazelcast.future.Future`), Future representing pending completion of the task.\n        \"\"\"\n        uuid = self._get_uuid()\n        address = member.address\n        return self._execute_on_member(address, uuid, self._to_data(task))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes a task on each of the specified members.", "response": "def execute_on_members(self, members, task):\n        \"\"\"\n        Executes a task on each of the specified members.\n\n        :param members: (Collection), the specified members.\n        :param task: (Task), the task executed on the specified members.\n        :return: (Map), :class:`~hazelcast.future.Future` tuples representing pending completion of the task on each member.\n        \"\"\"\n        task_data = self._to_data(task)\n        futures = []\n        uuid = self._get_uuid()\n        for member in members:\n            f = self._execute_on_member(member.address, uuid, task_data)\n            futures.append(f)\n        return future.combine_futures(*futures)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef execute_on_all_members(self, task):\n        return self.execute_on_members(self._client.cluster.get_member_list(), task)", "response": "Executes a task on all known cluster members."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef calculate_size(name, replace_existing_values):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle(client_message, handle_event_distributed_object=None, to_object=None):\n    message_type = client_message.get_message_type()\n    if message_type == EVENT_DISTRIBUTEDOBJECT and handle_event_distributed_object is not None:\n        name = client_message.read_str()\n        service_name = client_message.read_str()\n        event_type = client_message.read_str()\n        handle_event_distributed_object(name=name, service_name=service_name, event_type=event_type)", "response": "Handle an event distributed object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calculate_size(name, entries):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    for key, val in six.iteritems(entries):\n        data_size += calculate_size_data(key)\n        data_size += calculate_size_data(val)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef encode_request(name, entries):\n    client_message = ClientMessage(payload_size=calculate_size(name, entries))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_int(len(entries))\n    for entries_item in six.iteritems(entries):\n        client_message.append_tuple(entries_item)\n    client_message.update_frame_length()\n    return client_message", "response": "Encode request into client_message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a listener object to listen for lifecycle events.", "response": "def add_listener(self, on_lifecycle_change):\n        \"\"\"\n        Add a listener object to listen for lifecycle events.\n\n        :param on_lifecycle_change: (Function), function to be called when LifeCycle state is changed.\n        :return: (str), id of the listener.\n        \"\"\"\n        id = str(uuid.uuid4())\n        self._listeners[id] = on_lifecycle_change\n        return id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_listener(self, registration_id):\n        try:\n            self._listeners.pop(registration_id)\n            return True\n        except KeyError:\n            return False", "response": "Removes a lifecycle listener."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fire_lifecycle_event(self, new_state):\n        if new_state == LIFECYCLE_STATE_SHUTTING_DOWN:\n            self.is_live = False\n\n        self.state = new_state\n        self.logger.info(self._git_info + \"HazelcastClient is %s\", new_state, extra=self._logger_extras)\n        for listener in list(self._listeners.values()):\n            try:\n                listener(new_state)\n            except:\n                self.logger.exception(\"Exception in lifecycle listener\", extra=self._logger_extras)", "response": "Called when the instance s state changes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle(client_message, handle_event_item=None, to_object=None):\n    message_type = client_message.get_message_type()\n    if message_type == EVENT_ITEM and handle_event_item is not None:\n        item = None\n        if not client_message.read_bool():\n            item = client_message.read_data()\n        uuid = client_message.read_str()\n        event_type = client_message.read_int()\n        handle_event_item(item=item, uuid=uuid, event_type=event_type)", "response": "Handle an event from the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the size of the request payload.", "response": "def calculate_size(name, value, timeout_millis):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_data(value)\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nacquiring the lock for the current thread.", "response": "def lock(self, lease_time=-1):\n        \"\"\"\n        Acquires the lock. If a lease time is specified, lock will be released after this lease time.\n\n        If the lock is not available, the current thread becomes disabled for thread scheduling purposes and lies\n        dormant until the lock has been acquired.\n\n        :param lease_time: (long), time to wait before releasing the lock (optional).\n        \"\"\"\n        return self._encode_invoke(lock_lock_codec, invocation_timeout=MAX_SIZE, lease_time=to_millis(lease_time),\n                                   thread_id=thread_id(), reference_id=self.reference_id_generator.get_and_increment())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef try_lock(self, timeout=0, lease_time=-1):\n        return self._encode_invoke(lock_try_lock_codec, invocation_timeout=MAX_SIZE, lease=to_millis(lease_time),\n                                   thread_id=thread_id(), timeout=to_millis(timeout),\n                                   reference_id=self.reference_id_generator.get_and_increment())", "response": "Tries to acquire the lock."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calculate_size(name, txn_id, thread_id, key, value):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_str(txn_id)\n    data_size += LONG_SIZE_IN_BYTES\n    data_size += calculate_size_data(key)\n    data_size += calculate_size_data(value)\n    return data_size", "response": "Calculates the size of the data payload."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the size of the request payload.", "response": "def calculate_size(name, new_value):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    if new_value is not None:\n        data_size += calculate_size_data(new_value)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calculate_size(name, key, thread_id):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_data(key)\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decode_response(client_message, to_object=None):\n    parameters = dict(response=None)\n    if not client_message.read_bool():\n        parameters['response'] = EntryViewCodec.decode(client_message, to_object)\n    return parameters", "response": "Decode response from client message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nencoding request into client_message", "response": "def encode_request(name, entries):\n    \"\"\" Encode request into client_message\"\"\"\n    client_message = ClientMessage(payload_size=calculate_size(name, entries))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_int(len(entries))\n    for key, value in six.iteritems(entries):\n        client_message.append_data(key)\n        client_message.append_data(value)\n    client_message.update_frame_length()\n    return client_message"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a listener for all entries in the multimap.", "response": "def add_entry_listener(self, include_value=False, key=None, added_func=None, removed_func=None, clear_all_func=None):\n        \"\"\"\n        Adds an entry listener for this multimap. The listener will be notified for all multimap add/remove/clear-all\n        events.\n\n        :param include_value: (bool), whether received event should include the value or not (optional).\n        :param key: (object), key for filtering the events (optional).\n        :param added_func: Function to be called when an entry is added to map (optional).\n        :param removed_func: Function to be called when an entry is removed_func from map (optional).\n        :param clear_all_func: Function to be called when entries are cleared from map (optional).\n        :return: (str), a registration id which is used as a key to remove the listener.\n        \"\"\"\n        if key:\n            key_data = self._to_data(key)\n            request = multi_map_add_entry_listener_to_key_codec.encode_request(name=self.name, key=key_data,\n                                                                               include_value=include_value,\n                                                                               local_only=False)\n        else:\n            request = multi_map_add_entry_listener_codec.encode_request(name=self.name, include_value=include_value,\n                                                                        local_only=False)\n\n        def handle_event_entry(**_kwargs):\n            event = EntryEvent(self._to_object, **_kwargs)\n            if event.event_type == EntryEventType.added and added_func:\n                added_func(event)\n            elif event.event_type == EntryEventType.removed and removed_func:\n                removed_func(event)\n            elif event.event_type == EntryEventType.clear_all and clear_all_func:\n                clear_all_func(event)\n\n        return self._start_listening(request,\n                                     lambda m: multi_map_add_entry_listener_codec.handle(m,\n                                                                                         handle_event_entry),\n                                     lambda r: multi_map_add_entry_listener_codec.decode_response(r)[\n                                         'response'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndetermines whether this multimap contains the specified key.", "response": "def contains_key(self, key):\n        \"\"\"\n        Determines whether this multimap contains an entry with the key.\n\n        **Warning: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        :param key: (object), the specified key.\n        :return: (bool), ``true`` if this multimap contains an entry for the specified key.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(multi_map_contains_key_codec, key_data, key=key_data,\n                                          thread_id=thread_id())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef contains_value(self, value):\n        check_not_none(value, \"value can't be None\")\n        value_data = self._to_data(value)\n        return self._encode_invoke(multi_map_contains_value_codec, value=value_data)", "response": "Determines whether this multimap contains one or more keys for the specified value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef contains_entry(self, key, value):\n        check_not_none(key, \"key can't be None\")\n        check_not_none(value, \"value can't be None\")\n        key_data = self._to_data(key)\n        value_data = self._to_data(value)\n        return self._encode_invoke_on_key(multi_map_contains_entry_codec, key_data, key=key_data,\n                                          value=value_data, thread_id=thread_id())", "response": "Returns true if this multimap contains an entry with the value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the list of values associated with the specified key.", "response": "def get(self, key):\n        \"\"\"\n        Returns the list of values associated with the key. ``None`` if this map does not contain this key.\n\n        **Warning:\n        This method uses hashCode and equals of the binary form of the key, not the actual implementations of hashCode\n        and equals defined in the key's class.**\n\n        **Warning-2:\n        The list is NOT backed by the multimap, so changes to the map are list reflected in the collection, and\n        vice-versa.**\n\n        :param key: (object), the specified key.\n        :return: (Sequence), the list of the values associated with the specified key.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(multi_map_get_codec, key_data, key=key_data,\n                                          thread_id=thread_id())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the lock for the specified key. Returns true if the lock is acquired otherwise returns false.", "response": "def is_locked(self, key):\n        \"\"\"\n        Checks the lock for the specified key. If the lock is acquired, returns ``true``. Otherwise, returns false.\n\n        **Warning: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        :param key: (object), the key that is checked for lock.\n        :return: (bool), ``true`` if lock is acquired, false otherwise.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(multi_map_is_locked_codec, key_data, key=key_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lock(self, key, lease_time=-1):\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(multi_map_lock_codec, key_data, key=key_data,\n                                          thread_id=thread_id(), ttl=to_millis(lease_time),\n                                          reference_id=self.reference_id_generator.get_and_increment())", "response": "Acquires the lock for the specified key in this map. If the lock is not available the current thread is disabled for thread scheduling purposes and lies_on is dormant until the lock has been acquired."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove(self, key, value):\n        check_not_none(key, \"key can't be None\")\n        check_not_none(key, \"value can't be None\")\n        key_data = self._to_data(key)\n        value_data = self._to_data(value)\n        return self._encode_invoke_on_key(multi_map_remove_entry_codec, key_data, key=key_data,\n                                          value=value_data, thread_id=thread_id())", "response": "Removes the given key - value tuple from the multimap."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves all the entries with the given key and returns the value list associated with this key.", "response": "def remove_all(self, key):\n        \"\"\"\n        Removes all the entries with the given key and returns the value list associated with this key.\n\n        **Warning: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        **Warning-2:\n        The returned list is NOT backed by the map, so changes to the map are NOT reflected in the list, and\n        vice-versa.**\n\n        :param key: (object), the key of the entries to remove.\n        :return: (Sequence), the collection of removed values associated with the given key.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(multi_map_remove_codec, key_data, key=key_data,\n                                          thread_id=thread_id())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef put(self, key, value):\n        check_not_none(key, \"key can't be None\")\n        check_not_none(value, \"value can't be None\")\n        key_data = self._to_data(key)\n        value_data = self._to_data(value)\n        return self._encode_invoke_on_key(multi_map_put_codec, key_data, key=key_data, value=value_data,\n                                          thread_id=thread_id())", "response": "Stores a key - value tuple in the multimap. Returns True if the multimap contains the key - value tuple otherwise False."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the specified entry listener. Returns silently if there is no such listener added before.", "response": "def remove_entry_listener(self, registration_id):\n        \"\"\"\n        Removes the specified entry listener. Returns silently if there is no such listener added before.\n\n        :param registration_id: (str), id of registered listener.\n        :return: (bool), ``true`` if registration is removed, ``false`` otherwise.\n        \"\"\"\n        return self._stop_listening(registration_id,\n                                    lambda i: multi_map_remove_entry_listener_codec.encode_request(self.name, i))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the number of values that match the given key in the multimap.", "response": "def value_count(self, key):\n        \"\"\"\n        Returns the number of values that match the given key in the multimap.\n\n        **Warning: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        :param key: (object), the key whose values count is to be returned.\n        :return: (int), the number of values that match the given key in the multimap.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(multi_map_value_count_codec, key_data, key=key_data,\n                                          thread_id=thread_id())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef try_lock(self, key, lease_time=-1, timeout=-1):\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(multi_map_try_lock_codec, key_data, key=key_data,\n                                          thread_id=thread_id(), lease=to_millis(lease_time),\n                                          timeout=to_millis(timeout),\n                                          reference_id=self.reference_id_generator.get_and_increment())", "response": "Tries to acquire the lock for the specified key. If the lock is not available returns false immediately. If the lock is available returns true immediately."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the size of the request payload.", "response": "def calculate_size(name, values):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    for values_item in values:\n        data_size += calculate_size_data(values_item)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef encode_request(name, values):\n    client_message = ClientMessage(payload_size=calculate_size(name, values))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_int(len(values))\n    for values_item in values:\n        client_message.append_data(values_item)\n    client_message.update_frame_length()\n    return client_message", "response": "Encode a request into a client_message"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns true if this map contains the specified key.", "response": "def contains_key(self, key):\n        \"\"\"\n        Transactional implementation of :func:`Map.contains_key(key) <hazelcast.proxy.map.Map.contains_key>`\n\n        :param key: (object), the specified key.\n        :return: (bool), ``true`` if this map contains an entry for the specified key, ``false`` otherwise.\n        \"\"\"\n        check_not_none(key, \"key can't be none\")\n        return self._encode_invoke(transactional_map_contains_key_codec, key=self._to_data(key))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, key):\n        check_not_none(key, \"key can't be none\")\n        return self._encode_invoke(transactional_map_get_codec, key=self._to_data(key))", "response": "Gets the value for the specified key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_for_update(self, key):\n        check_not_none(key, \"key can't be none\")\n        return self._encode_invoke(transactional_map_get_for_update_codec, key=self._to_data(key))", "response": "Gets the value for the specified key for update."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef put_if_absent(self, key, value):\n        check_not_none(key, \"key can't be none\")\n        check_not_none(value, \"value can't be none\")\n        return self._encode_invoke(transactional_map_put_if_absent_codec, key=self._to_data(key),\n                                   value=self._to_data(value))", "response": "Puts an entry in the map if the key is not present in the current transaction context."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the value of the object identified by key.", "response": "def set(self, key, value):\n        \"\"\"\n        Transactional implementation of :func:`Map.set(key, value) <hazelcast.proxy.map.Map.set>`\n\n        The object to be set will be accessible only in the current transaction context till the transaction is\n        committed.\n\n        :param key: (object), key of the entry.\n        :param value: (object), value of the entry.\n        \"\"\"\n        check_not_none(key, \"key can't be none\")\n        check_not_none(value, \"value can't be none\")\n        return self._encode_invoke(transactional_map_set_codec, key=self._to_data(key),\n                                   value=self._to_data(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreplaces the value associated with key with the given value. If the key does not exist in the current transaction context then None is returned.", "response": "def replace(self, key, value):\n        \"\"\"\n        Transactional implementation of :func:`Map.replace(key, value) <hazelcast.proxy.map.Map.replace>`\n\n        The object to be replaced will be accessible only in the current transaction context till the transaction is\n        committed.\n\n        :param key: (object), the specified key.\n        :param value: (object), the value to replace the previous value.\n        :return: (object), previous value associated with key, or ``None`` if there was no mapping for key.\n        \"\"\"\n        check_not_none(key, \"key can't be none\")\n        check_not_none(value, \"value can't be none\")\n        return self._encode_invoke(transactional_map_replace_codec, key=self._to_data(key),\n                                   value=self._to_data(value))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef replace_if_same(self, key, old_value, new_value):\n        check_not_none(key, \"key can't be none\")\n        check_not_none(old_value, \"old_value can't be none\")\n        check_not_none(new_value, \"new_value can't be none\")\n        return self._encode_invoke(transactional_map_replace_if_same_codec, key=self._to_data(key),\n                                   old_value=self._to_data(old_value), new_value=self._to_data(new_value))", "response": "Replaces the value of the specified key with the specified value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove(self, key):\n        check_not_none(key, \"key can't be none\")\n        return self._encode_invoke(transactional_map_remove_codec, key=self._to_data(key))", "response": "Removes the object associated with the given key from this map."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the value from the specified key if it has the specified value.", "response": "def remove_if_same(self, key, value):\n        \"\"\"\n        Transactional implementation of :func:`Map.remove_if_same(key, value)\n        <hazelcast.proxy.map.Map.remove_if_same>`\n\n        The object to be removed will be removed from only the current transaction context until the transaction is\n        committed.\n\n        :param key: (object), the specified key.\n        :param value: (object), remove the key if it has this value.\n        :return: (bool), ``true`` if the value was removed, ``false`` otherwise.\n        \"\"\"\n\n        check_not_none(key, \"key can't be none\")\n        check_not_none(value, \"value can't be none\")\n        return self._encode_invoke(transactional_map_remove_if_same_codec, key=self._to_data(key),\n                                   value=self._to_data(value))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete the object with the given key from this map.", "response": "def delete(self, key):\n        \"\"\"\n        Transactional implementation of :func:`Map.delete(key) <hazelcast.proxy.map.Map.delete>`\n\n        The object to be deleted will be removed from only the current transaction context until the transaction is\n        committed.\n\n        :param key: (object), key of the mapping to be deleted.\n        \"\"\"\n        check_not_none(key, \"key can't be none\")\n        return self._encode_invoke(transactional_map_delete_codec, key=self._to_data(key))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef key_set(self, predicate=None):\n\n        if predicate:\n            return self._encode_invoke(transactional_map_key_set_with_predicate_codec,\n                                       predicate=self._to_data(predicate))\n        return self._encode_invoke(transactional_map_key_set_codec)", "response": "Returns a list of the keys that match the predicate."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of the values contained in this map.", "response": "def values(self, predicate=None):\n        \"\"\"\n        Transactional implementation of :func:`Map.values(predicate) <hazelcast.proxy.map.Map.values>`\n\n        :param predicate: (Predicate), predicate to filter the entries (optional).\n        :return: (Sequence), a list of clone of the values contained in this map.\n\n        .. seealso::\n            :class:`~hazelcast.serialization.predicate.Predicate` for more info about predicates.\n        \"\"\"\n        if predicate:\n            return self._encode_invoke(transactional_map_values_with_predicate_codec,\n                                       predicate=self._to_data(predicate))\n        return self._encode_invoke(transactional_map_values_codec)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef alter(self, function):\n        check_not_none(function, \"function can't be None\")\n        return self._encode_invoke(atomic_reference_alter_codec, function=self._to_data(function))", "response": "Alters the currently stored reference by applying a function on it."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\napplies a function on the value the actual stored value will not change.", "response": "def apply(self, function):\n        \"\"\"\n        Applies a function on the value, the actual stored value will not change.\n\n        :param function: (Function), A stateful serializable object which represents the Function defined on\n            server side.\n            This object must have a serializable Function counter part registered on server side with the actual\n            ``org.hazelcast.core.IFunction`` implementation.\n        :return: (object), the result of the function application.\n        \"\"\"\n        check_not_none(function, \"function can't be None\")\n        return self._encode_invoke(atomic_reference_apply_codec, function=self._to_data(function))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\naltering the currently stored reference by applying a function on it and gets the result.", "response": "def alter_and_get(self, function):\n        \"\"\"\n        Alters the currently stored reference by applying a function on it and gets the result.\n\n        :param function: (Function), A stateful serializable object which represents the Function defined on\n            server side.\n            This object must have a serializable Function counter part registered on server side with the actual\n            ``org.hazelcast.core.IFunction`` implementation.\n        :return: (object), the new value, the result of the applied function.\n        \"\"\"\n        check_not_none(function, \"function can't be None\")\n        return self._encode_invoke(atomic_reference_alter_and_get_codec, function=self._to_data(function))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef contains(self, expected):\n\n        return self._encode_invoke(atomic_reference_contains_codec,\n                                   expected=self._to_data(expected))", "response": "Checks if the reference contains the value."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nalter the currently stored reference by applying a function on it on and gets the old value before the function is applied.", "response": "def get_and_alter(self, function):\n        \"\"\"\n        Alters the currently stored reference by applying a function on it on and gets the old value.\n\n        :param function: (Function), A stateful serializable object which represents the Function defined on\n            server side.\n            This object must have a serializable Function counter part registered on server side with the actual\n            ``org.hazelcast.core.IFunction`` implementation.\n        :return: (object), the old value, the value before the function is applied.\n        \"\"\"\n\n        check_not_none(function, \"function can't be None\")\n        return self._encode_invoke(atomic_reference_get_and_alter_codec, function=self._to_data(function))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_and_set(self, new_value):\n        return self._encode_invoke(atomic_reference_get_and_set_codec,\n                                   new_value=self._to_data(new_value))", "response": "Gets the old value and sets the new value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_and_get(self, new_value):\n        return self._encode_invoke(atomic_reference_set_and_get_codec,\n                                   new_value=self._to_data(new_value))", "response": "Sets and gets the value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculate_size(name, uuid, callable, address):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_str(uuid)\n    data_size += calculate_size_data(callable)\n    data_size += calculate_size_address(address)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode_request(name, uuid, callable, address):\n    client_message = ClientMessage(payload_size=calculate_size(name, uuid, callable, address))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_str(uuid)\n    client_message.append_data(callable)\n    AddressCodec.encode(client_message, address)\n    client_message.update_frame_length()\n    return client_message", "response": "Encode a request into a client_message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the size of the request payload.", "response": "def calculate_size(name, registration_id):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_str(registration_id)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_type(self):\n        if self.total_size() == 0:\n            return CONSTANT_TYPE_NULL\n        return unpack_from(FMT_BE_INT, self._buffer, TYPE_OFFSET)[0]", "response": "Returns the serialization type of binary form."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the partition hash calculated for serialized object.", "response": "def get_partition_hash(self):\n        \"\"\"\n        Returns partition hash calculated for serialized object.\n            Partition hash is used to determine partition of a Data and is calculated using\n                * PartitioningStrategy during serialization.\n                * If partition hash is not set then hash_code() is used.\n\n        :return: partition hash\n        \"\"\"\n        if self.has_partition_hash():\n            return unpack_from(FMT_BE_INT, self._buffer, PARTITION_HASH_OFFSET)[0]\n        return self.hash_code()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_partition_hash(self):\n        return self._buffer is not None \\\n               and len(self._buffer) >= HEAP_DATA_OVERHEAD \\\n               and unpack_from(FMT_BE_INT, self._buffer, PARTITION_HASH_OFFSET)[0] != 0", "response": "Determines whether this Data has partition hash or not."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the size of the data payload.", "response": "def calculate_size(name, overflow_policy, value):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    data_size += calculate_size_data(value)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decode_response(client_message, to_object=None):\n    parameters = dict(response=None)\n    parameters['response'] = client_message.read_long()\n    return parameters", "response": "Decode response from client message"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nserializing the input object into byte array representation.", "response": "def to_data(self, obj, partitioning_strategy=None):\n        \"\"\"\n        Serialize the input object into byte array representation\n        :param obj: input object\n        :param partitioning_strategy: function in the form of lambda key:partitioning_key\n        :return: Data object\n        \"\"\"\n        if obj is None:\n            return None\n\n        if isinstance(obj, Data):\n            return obj\n\n        out = self._create_data_output()\n        try:\n            serializer = self._registry.serializer_for(obj)\n            partitioning_hash = self._calculate_partitioning_hash(obj, partitioning_strategy)\n\n            out.write_int_big_endian(partitioning_hash)\n            out.write_int_big_endian(serializer.get_type_id())\n            serializer.write(out, obj)\n            return Data(out.to_byte_array())\n        except:\n            handle_exception(sys.exc_info()[1], sys.exc_info()[2])\n        finally:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds and return the serializer for the type - id.", "response": "def serializer_by_type_id(self, type_id):\n        \"\"\"\n        Find and return the serializer for the type-id\n        :param type_id: type-id the serializer\n        :return: the serializer\n        \"\"\"\n        if type_id <= 0:\n            indx = index_for_default_type(type_id)\n            serializer = self._constant_type_ids.get(indx, None)\n            if serializer is not None:\n                return serializer\n        return self._id_dic.get(type_id, None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches for a serializer for the provided object.", "response": "def serializer_for(self, obj):\n        \"\"\"\n            Searches for a serializer for the provided object\n            Serializers will be  searched in this order;\n\n            1-NULL serializer\n            2-Default serializers, like primitives, arrays, string and some default types\n            3-Custom registered types by user\n            4-Global serializer if registered by user\n            4-pickle serialization as a fallback\n\n        :param obj: input object\n        :return: Serializer\n        \"\"\"\n        # 1-NULL serializer\n        if obj is None:\n            return self._null_serializer\n\n        obj_type = type(obj)\n\n        # 2-Default serializers, Dataserializable, Portable, primitives, arrays, String and some helper types(BigInteger etc)\n        serializer = self.lookup_default_serializer(obj_type, obj)\n\n        # 3-Custom registered types by user\n        if serializer is None:\n            serializer = self.lookup_custom_serializer(obj_type)\n\n        # 5-Global serializer if registered by user\n        if serializer is None:\n            serializer = self.lookup_global_serializer(obj_type)\n\n        # 4 Internal serializer\n        if serializer is None:\n            serializer = self.lookup_python_serializer(obj_type)\n\n        if serializer is None:\n            raise HazelcastSerializationError(\"There is no suitable serializer for:\" + str(obj_type))\n        return serializer"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndetermines whether this record is expired or not.", "response": "def is_expired(self, max_idle_seconds):\n        \"\"\"\n        Determines whether this record is expired or not.\n\n        :param max_idle_seconds: (long), the maximum idle time of record, maximum time after the last access time.\n        :return: (bool), ``true`` is this record is not expired.\n        \"\"\"\n\n        now = current_time()\n        return (self.expiration_time is not None and self.expiration_time < now) or \\\n               (max_idle_seconds is not None and self.last_access_time + max_idle_seconds < now)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_statistics(self):\n        stats = {\n            \"creation_time\": self._creation_time_in_seconds,\n            \"evictions\": self._evictions,\n            \"expirations\": self._expirations,\n            \"misses\": self._misses,\n            \"hits\": self._hits,\n            \"invalidations\": self._invalidations,\n            \"invalidation_requests\": self._invalidation_requests,\n            \"owned_entry_count\": self.__len__(),\n            \"owned_entry_memory_cost\": getsizeof(self),\n        }\n\n        return stats", "response": "Returns the statistics of the NearCache."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncombines a set of futures into a single Future.", "response": "def combine_futures(*futures):\n    \"\"\"\n    Combines set of Futures.\n\n    :param futures: (Futures), Futures to be combined.\n    :return: Result of the combination.\n    \"\"\"\n    expected = len(futures)\n    results = []\n    completed = AtomicInteger()\n    combined = Future()\n\n    def done(f):\n        if not combined.done():\n            if f.is_success():  # TODO: ensure ordering of results as original list\n                results.append(f.result())\n                if completed.get_and_increment() + 1 == expected:\n                    combined.set_result(results)\n            else:\n                combined.set_exception(f.exception(), f.traceback())\n\n    for future in futures:\n        future.add_done_callback(done)\n\n    return combined"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_result(self, result):\n        if result is None:\n            self._result = NONE_RESULT\n        else:\n            self._result = result\n        self._event.set()\n        self._invoke_callbacks()", "response": "Sets the result of the Future."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the exception for this Future in case of errors.", "response": "def set_exception(self, exception, traceback=None):\n        \"\"\"\n        Sets the exception for this Future in case of errors.\n\n        :param exception: (Exception), exception to be threw in case of error.\n        :param traceback: (Function), function to be called on traceback (optional).\n        \"\"\"\n        if not isinstance(exception, BaseException):\n            raise RuntimeError(\"Exception must be of BaseException type\")\n        self._exception = exception\n        self._traceback = traceback\n        self._event.set()\n        self._invoke_callbacks()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef result(self):\n        self._reactor_check()\n        self._event.wait()\n        if self._exception:\n            six.reraise(self._exception.__class__, self._exception, self._traceback)\n        if self._result == NONE_RESULT:\n            return None\n        else:\n            return self._result", "response": "Returns the result of the Future."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef continue_with(self, continuation_func, *args):\n        future = Future()\n\n        def callback(f):\n            try:\n                future.set_result(continuation_func(f, *args))\n            except:\n                future.set_exception(sys.exc_info()[1], sys.exc_info()[2])\n\n        self.add_done_callback(callback)\n        return future", "response": "Create a continuation that executes when the future is completed."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_or_connect(self, address, authenticator=None):\n        if address in self.connections:\n            return ImmediateFuture(self.connections[address])\n        else:\n            with self._new_connection_mutex:\n                if address in self._pending_connections:\n                    return self._pending_connections[address]\n                else:\n                    authenticator = authenticator or self._cluster_authenticator\n                    try:\n                        translated_address = self._address_translator.translate(address)\n                        if translated_address is None:\n                            raise ValueError(\"Address translator could not translate address: {}\".format(address))\n                        connection = self._new_connection_func(translated_address,\n                                                               self._client.config.network_config.connection_timeout,\n                                                               self._client.config.network_config.socket_options,\n                                                               connection_closed_callback=self._connection_closed,\n                                                               message_callback=self._client.invoker._handle_client_message,\n                                                               network_config=self._client.config.network_config)\n                    except IOError:\n                        return ImmediateExceptionFuture(sys.exc_info()[1], sys.exc_info()[2])\n\n                    future = authenticator(connection).continue_with(self.on_auth, connection, address)\n                    if not future.done():\n                        self._pending_connections[address] = future\n                    return future", "response": "Gets the existing connection for a given address. If the connection does not exist it will create one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall when the client is authenticating with a new connection.", "response": "def on_auth(self, f, connection, address):\n        \"\"\"\n        Checks for authentication of a connection.\n\n        :param f: (:class:`~hazelcast.future.Future`), future that contains the result of authentication.\n        :param connection: (:class:`~hazelcast.connection.Connection`), newly established connection.\n        :param address: (:class:`~hazelcast.core.Address`), the adress of new connection.\n        :return: Result of authentication.\n        \"\"\"\n        if f.is_success():\n            self.logger.info(\"Authenticated with %s\", f.result(), extra=self._logger_extras)\n            with self._new_connection_mutex:\n                self.connections[connection.endpoint] = f.result()\n                try:\n                    self._pending_connections.pop(address)\n                except KeyError:\n                    pass\n            for on_connection_opened, _ in self._connection_listeners:\n                if on_connection_opened:\n                    on_connection_opened(f.result())\n            return f.result()\n        else:\n            self.logger.debug(\"Error opening %s\", connection, extra=self._logger_extras)\n            with self._new_connection_mutex:\n                try:\n                    self._pending_connections.pop(address)\n                except KeyError:\n                    pass\n            six.reraise(f.exception().__class__, f.exception(), f.traceback())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef close_connection(self, address, cause):\n        try:\n            connection = self.connections[address]\n            connection.close(cause)\n        except KeyError:\n            self.logger.warning(\"No connection with %s was found to close.\", address, extra=self._logger_extras)\n            return False", "response": "Closes the connection with given address."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self):\n        def _heartbeat():\n            if not self._client.lifecycle.is_live:\n                return\n            self._heartbeat()\n            self._heartbeat_timer = self._client.reactor.add_timer(self._heartbeat_interval, _heartbeat)\n\n        self._heartbeat_timer = self._client.reactor.add_timer(self._heartbeat_interval, _heartbeat)", "response": "Starts sending periodic HeartBeat operations."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a message to this connection.", "response": "def send_message(self, message):\n        \"\"\"\n        Sends a message to this connection.\n\n        :param message: (Message), message to be sent to this connection.\n        \"\"\"\n        if not self.live():\n            raise IOError(\"Connection is not live.\")\n\n        message.add_flag(BEGIN_END_FLAG)\n        self.write(message.buffer)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef receive_message(self):\n        # split frames\n        while len(self._read_buffer) >= INT_SIZE_IN_BYTES:\n            frame_length = struct.unpack_from(FMT_LE_INT, self._read_buffer, 0)[0]\n            if frame_length > len(self._read_buffer):\n                return\n            message = ClientMessage(memoryview(self._read_buffer)[:frame_length])\n            self._read_buffer = self._read_buffer[frame_length:]\n            self._builder.on_message(message)", "response": "Receives a message from this connection."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd the specified item to the set.", "response": "def add(self, item):\n        \"\"\"\n        Transactional implementation of :func:`Set.add(item) <hazelcast.proxy.set.Set.add>`\n\n        :param item: (object), the new item to be added.\n        :return: (bool), ``true`` if item is added successfully, ``false`` otherwise.\n        \"\"\"\n        check_not_none(item, \"item can't be none\")\n        return self._encode_invoke(transactional_set_add_codec, item=self._to_data(item))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the specified item from the set.", "response": "def remove(self, item):\n        \"\"\"\n        Transactional implementation of :func:`Set.remove(item) <hazelcast.proxy.set.Set.remove>`\n\n        :param item: (object), the specified item to be deleted.\n        :return: (bool), ``true`` if item is remove successfully, ``false`` otherwise.\n        \"\"\"\n        check_not_none(item, \"item can't be none\")\n        return self._encode_invoke(transactional_set_remove_codec, item=self._to_data(item))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the size of the request payload.", "response": "def calculate_size(name, attribute, ordered):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_str(attribute)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nencodes request into client_message", "response": "def encode_request(name, attribute, ordered):\n    \"\"\" Encode request into client_message\"\"\"\n    client_message = ClientMessage(payload_size=calculate_size(name, attribute, ordered))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_str(attribute)\n    client_message.append_bool(ordered)\n    client_message.update_frame_length()\n    return client_message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the size of the request payload.", "response": "def calculate_size(name, sequence):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_size(name, count):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize this semaphore with the given permit count.", "response": "def init(self, permits):\n        \"\"\"\n        Try to initialize this Semaphore instance with the given permit count.\n\n        :param permits: (int), the given permit count.\n        :return: (bool), ``true`` if initialization success.\n        \"\"\"\n        check_not_negative(permits, \"Permits cannot be negative!\")\n        return self._encode_invoke(semaphore_init_codec, permits=permits)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef acquire(self, permits=1):\n        check_not_negative(permits, \"Permits cannot be negative!\")\n        return self._encode_invoke(semaphore_acquire_codec, permits=permits)", "response": "Acquires one or specified amount of permits if available and returns immediately."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reduce_permits(self, reduction):\n        check_not_negative(reduction, \"Reduction cannot be negative!\")\n        return self._encode_invoke(semaphore_reduce_permits_codec, reduction=reduction)", "response": "Shrinks the number of available permits by the specified reduction."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef release(self, permits=1):\n        check_not_negative(permits, \"Permits cannot be negative!\")\n        return self._encode_invoke(semaphore_release_codec, permits=permits)", "response": "Releases one or given number of permits."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle(client_message, handle_event_topic=None, to_object=None):\n    message_type = client_message.get_message_type()\n    if message_type == EVENT_TOPIC and handle_event_topic is not None:\n        item = client_message.read_data()\n        publish_time = client_message.read_long()\n        uuid = client_message.read_str()\n        handle_event_topic(item=item, publish_time=publish_time, uuid=uuid)", "response": "Handle an event from the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the size of the request payload.", "response": "def calculate_size(name, entry_processor, keys):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_data(entry_processor)\n    data_size += INT_SIZE_IN_BYTES\n    for keys_item in keys:\n        data_size += calculate_size_data(keys_item)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nencoding a request into a client_message", "response": "def encode_request(name, entry_processor, keys):\n    \"\"\" Encode request into client_message\"\"\"\n    client_message = ClientMessage(payload_size=calculate_size(name, entry_processor, keys))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_data(entry_processor)\n    client_message.append_int(len(keys))\n    for keys_item in keys:\n        client_message.append_data(keys_item)\n    client_message.update_frame_length()\n    return client_message"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calculate_size(username, password, uuid, owner_uuid, is_owner_connection, client_type, serialization_version, client_hazelcast_version):\n    data_size = 0\n    data_size += calculate_size_str(username)\n    data_size += calculate_size_str(password)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    if uuid is not None:\n        data_size += calculate_size_str(uuid)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    if owner_uuid is not None:\n        data_size += calculate_size_str(owner_uuid)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    data_size += calculate_size_str(client_type)\n    data_size += BYTE_SIZE_IN_BYTES\n    data_size += calculate_size_str(client_hazelcast_version)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef encode_request(username, password, uuid, owner_uuid, is_owner_connection, client_type, serialization_version, client_hazelcast_version):\n    client_message = ClientMessage(payload_size=calculate_size(username, password, uuid, owner_uuid, is_owner_connection, client_type, serialization_version, client_hazelcast_version))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(username)\n    client_message.append_str(password)\n    client_message.append_bool(uuid is None)\n    if uuid is not None:\n        client_message.append_str(uuid)\n    client_message.append_bool(owner_uuid is None)\n    if owner_uuid is not None:\n        client_message.append_str(owner_uuid)\n    client_message.append_bool(is_owner_connection)\n    client_message.append_str(client_type)\n    client_message.append_byte(serialization_version)\n    client_message.append_str(client_hazelcast_version)\n    client_message.update_frame_length()\n    return client_message", "response": "Encode request into a client_message"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode_response(client_message, to_object=None):\n    parameters = dict(status=None, address=None, uuid=None, owner_uuid=None, serialization_version=None, server_hazelcast_version=None, client_unregistered_members=None)\n    parameters['status'] = client_message.read_byte()\n    if not client_message.read_bool():\n        parameters['address'] = AddressCodec.decode(client_message, to_object)\n    if not client_message.read_bool():\n        parameters['uuid'] = client_message.read_str()\n    if not client_message.read_bool():\n        parameters['owner_uuid'] = client_message.read_str()\n    parameters['serialization_version'] = client_message.read_byte()\n    if client_message.is_complete():\n        return parameters\n    parameters['server_hazelcast_version'] = client_message.read_str()\n    if not client_message.read_bool():\n        client_unregistered_members_size = client_message.read_int()\n        client_unregistered_members = []\n        for _ in range(0, client_unregistered_members_size):\n            client_unregistered_members_item = MemberCodec.decode(client_message, to_object)\n            client_unregistered_members.append(client_unregistered_members_item)\n        parameters['client_unregistered_members'] = ImmutableLazyDataList(client_unregistered_members, to_object)\n    return parameters", "response": "Decodes a response from a client message into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_membership_listener(self, member_added=None, member_removed=None, fire_for_existing=False):\n        self.membership_listeners.append((member_added, member_removed, fire_for_existing))\n        return self", "response": "Adds a listener to the membership listeners for this configuration."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_custom_serializer(self, _type, serializer):\n        validate_type(_type)\n        validate_serializer(serializer, StreamSerializer)\n        self._custom_serializers[_type] = serializer", "response": "Assign a custom serializer for the type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, property):\n        return self._properties.get(property.name) or os.getenv(property.name) or property.default_value", "response": "Gets the value of the given property."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_bool(self, property):\n        value = self.get(property)\n        if isinstance(value, bool):\n            return value\n        return value.lower() == \"true\"", "response": "Gets the value of the given property as boolean."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the value of the given property in seconds.", "response": "def get_seconds(self, property):\n        \"\"\"\n        Gets the value of the given property in seconds. If the value of the given property is not a number,\n        throws TypeError.\n\n        :param property: (:class:`~hazelcast.config.ClientProperty`), Property to get seconds from\n        :return: (float), Value of the given property in seconds\n        \"\"\"\n        return TimeUnit.to_seconds(self.get(property), property.time_unit)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the value of the given property in seconds if it is positive or the default value of the given property in seconds.", "response": "def get_seconds_positive_or_default(self, property):\n        \"\"\"\n        Gets the value of the given property in seconds. If the value of the given property is not a number,\n        throws TypeError. If the value of the given property in seconds is not positive, tries to\n        return the default value in seconds.\n\n        :param property: (:class:`~hazelcast.config.ClientProperty`), Property to get seconds from\n        :return: (float), Value of the given property in seconds if it is positive.\n            Else, value of the default value of given property in seconds.\n        \"\"\"\n        seconds = self.get_seconds(property)\n        return seconds if seconds > 0 else TimeUnit.to_seconds(property.default_value, property.time_unit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_size(credentials, uuid, owner_uuid, is_owner_connection, client_type, serialization_version, client_hazelcast_version):\n    data_size = 0\n    data_size += calculate_size_data(credentials)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    if uuid is not None:\n        data_size += calculate_size_str(uuid)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    if owner_uuid is not None:\n        data_size += calculate_size_str(owner_uuid)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    data_size += calculate_size_str(client_type)\n    data_size += BYTE_SIZE_IN_BYTES\n    data_size += calculate_size_str(client_hazelcast_version)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculate_size(name, replica_timestamps, target_replica):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    for replica_timestamps_item in replica_timestamps:\n        key = replica_timestamps_item[0]\n        val = replica_timestamps_item[1]\n        data_size += calculate_size_str(key)\n        data_size += LONG_SIZE_IN_BYTES\n\n    data_size += calculate_size_address(target_replica)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encode_request(name, replica_timestamps, target_replica):\n    client_message = ClientMessage(payload_size=calculate_size(name, replica_timestamps, target_replica))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_int(len(replica_timestamps))\n    for replica_timestamps_item in replica_timestamps:\n        key = replica_timestamps_item[0]\n        val = replica_timestamps_item[1]\n        client_message.append_str(key)\n        client_message.append_long(val)\n\n    AddressCodec.encode(client_message, target_replica)\n    client_message.update_frame_length()\n    return client_message", "response": "Encode request into client_message"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decode_response(client_message, to_object=None):\n    parameters = dict(value=None, replica_timestamps=None, replica_count=None)\n    parameters['value'] = client_message.read_long()\n\n    replica_timestamps_size = client_message.read_int()\n    replica_timestamps = []\n    for _ in range(0, replica_timestamps_size):\n        replica_timestamps_item = (client_message.read_str(), client_message.read_long())\n        replica_timestamps.append(replica_timestamps_item)\n\n    parameters['replica_timestamps'] = ImmutableLazyDataList(replica_timestamps, to_object)\n    parameters['replica_count'] = client_message.read_int()\n    return parameters", "response": "Decode response from client message into parameters"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the size of the request payload.", "response": "def calculate_size(name, value):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_data(value)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a continuous entry listener for this map.", "response": "def add_entry_listener(self, key=None, predicate=None, added_func=None, removed_func=None, updated_func=None,\n                           evicted_func=None, clear_all_func=None):\n        \"\"\"\n        Adds a continuous entry listener for this map. Listener will get notified for map events filtered with given\n        parameters.\n\n        :param key: (object), key for filtering the events (optional).\n        :param predicate: (Predicate), predicate for filtering the events (optional).\n        :param added_func: Function to be called when an entry is added to map (optional).\n        :param removed_func: Function to be called when an entry is removed from map (optional).\n        :param updated_func: Function to be called when an entry is updated (optional).\n        :param evicted_func: Function to be called when an entry is evicted from map (optional).\n        :param clear_all_func: Function to be called when entries are cleared from map (optional).\n        :return: (str), a registration id which is used as a key to remove the listener.\n\n        .. seealso:: :class:`~hazelcast.serialization.predicate.Predicate` for more info about predicates.\n        \"\"\"\n        if key and predicate:\n            key_data = self._to_data(key)\n            predicate_data = self._to_data(predicate)\n            request = replicated_map_add_entry_listener_to_key_with_predicate_codec.encode_request(self.name, key_data,\n                                                                                                   predicate_data,\n                                                                                                   False)\n        elif key and not predicate:\n            key_data = self._to_data(key)\n            request = replicated_map_add_entry_listener_to_key_codec.encode_request(self.name, key_data, False)\n        elif not key and predicate:\n            predicate = self._to_data(predicate)\n            request = replicated_map_add_entry_listener_with_predicate_codec.encode_request(self.name, predicate,\n                                                                                            False)\n        else:\n            request = replicated_map_add_entry_listener_codec.encode_request(self.name, False)\n\n        def handle_event_entry(**_kwargs):\n            event = EntryEvent(self._to_object, **_kwargs)\n            if event.event_type == EntryEventType.added and added_func:\n                added_func(event)\n            elif event.event_type == EntryEventType.removed and removed_func:\n                removed_func(event)\n            elif event.event_type == EntryEventType.updated and updated_func:\n                updated_func(event)\n            elif event.event_type == EntryEventType.evicted and evicted_func:\n                evicted_func(event)\n            elif event.event_type == EntryEventType.clear_all and clear_all_func:\n                clear_all_func(event)\n\n        return self._start_listening(request,\n                                     lambda m: replicated_map_add_entry_listener_codec.handle(m,\n                                                                                              handle_event_entry),\n                                     lambda r: replicated_map_add_entry_listener_codec.decode_response(r)[\n                                         'response'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef contains_key(self, key):\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(replicated_map_contains_key_codec, key_data, key=key_data)", "response": "Determines whether this map contains the specified key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetermine whether this map contains one or more keys for the specified value.", "response": "def contains_value(self, value):\n        \"\"\"\n        Determines whether this map contains one or more keys for the specified value.\n\n        :param value: (object), the specified value.\n        :return: (bool), ``true`` if this map contains an entry for the specified value.\n        \"\"\"\n        check_not_none(value, \"value can't be None\")\n        return self._encode_invoke_on_target_partition(replicated_map_contains_value_codec, value=self._to_data(value))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the value associated with the specified key.", "response": "def get(self, key):\n        \"\"\"\n        Returns the value for the specified key, or None if this map does not contain this key.\n\n        **Warning:\n        This method uses hashCode and equals of the binary form of the key, not the actual implementations of hashCode\n        and equals defined in the key's class.**\n\n        :param key: (object), the specified key.\n        :return: (Sequence), the list of the values associated with the specified key.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(replicated_map_get_codec, key_data, key=key_data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef put_all(self, map):\n        entries = {}\n        for key, value in six.iteritems(map):\n            check_not_none(key, \"key can't be None\")\n            check_not_none(value, \"value can't be None\")\n            entries[self._to_data(key)] = self._to_data(value)\n        self._encode_invoke(replicated_map_put_all_codec, entries=entries)", "response": "Copies all of the mappings from the specified map to this map."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves the mapping for a key from this map if it is present. Returns None if there is no mapping for the key.", "response": "def remove(self, key):\n        \"\"\"\n        Removes the mapping for a key from this map if it is present. The map will not contain a mapping for the\n        specified key once the call returns.\n\n        **Warning: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        :param key: (object), key of the mapping to be deleted.\n        :return: (object), the previous value associated with key, or None if there was no mapping for key.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(replicated_map_remove_codec, key_data, key=key_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the specified entry listener. Returns silently if there is no such listener added before.", "response": "def remove_entry_listener(self, registration_id):\n        \"\"\"\n        Removes the specified entry listener. Returns silently if there is no such listener added before.\n\n        :param registration_id: (str), id of registered listener.\n        :return: (bool), ``true`` if registration is removed, ``false`` otherwise.\n        \"\"\"\n        return self._stop_listening(registration_id,\n                                    lambda i: replicated_map_remove_entry_listener_codec.encode_request(self.name, i))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the size of the request payload.", "response": "def calculate_size(name, timeout):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts the partition service.", "response": "def start(self):\n        \"\"\"\n        Starts the partition service.\n        \"\"\"\n        self.logger.debug(\"Starting partition service\", extra=self._logger_extras)\n\n        def partition_updater():\n            self._do_refresh()\n            self.timer = self._client.reactor.add_timer(PARTITION_UPDATE_INTERVAL, partition_updater)\n\n        self.timer = self._client.reactor.add_timer(PARTITION_UPDATE_INTERVAL, partition_updater)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_partition_owner(self, partition_id):\n        if partition_id not in self.partitions:\n            self._do_refresh()\n        return self.partitions.get(partition_id, None)", "response": "Gets the owner of the partition if it s set. Otherwise it will trigger partition assignment."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_partition_id(self, key):\n        data = self._client.serialization_service.to_data(key)\n        count = self.get_partition_count()\n        if count <= 0:\n            return 0\n        return hash_to_index(data.get_partition_hash(), count)", "response": "Returns the partition id for a Data key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef murmur_hash3_x86_32(data, offset, size, seed=0x01000193):\n    key = bytearray(data[offset: offset + size])\n    length = len(key)\n    nblocks = int(length / 4)\n\n    h1 = seed\n\n    c1 = 0xcc9e2d51\n    c2 = 0x1b873593\n\n    # body\n    for block_start in range(0, nblocks * 4, 4):\n        # ??? big endian?\n        k1 = key[block_start + 3] << 24 | \\\n             key[block_start + 2] << 16 | \\\n             key[block_start + 1] << 8 | \\\n             key[block_start + 0]\n\n        k1 = c1 * k1 & 0xFFFFFFFF\n        k1 = (k1 << 15 | k1 >> 17) & 0xFFFFFFFF  # inlined ROTL32\n        k1 = (c2 * k1) & 0xFFFFFFFF\n\n        h1 ^= k1\n        h1 = (h1 << 13 | h1 >> 19) & 0xFFFFFFFF  # inlined _ROTL32\n        h1 = (h1 * 5 + 0xe6546b64) & 0xFFFFFFFF\n\n    # tail\n    tail_index = nblocks * 4\n    k1 = 0\n    tail_size = length & 3\n\n    if tail_size >= 3:\n        k1 ^= key[tail_index + 2] << 16\n    if tail_size >= 2:\n        k1 ^= key[tail_index + 1] << 8\n    if tail_size >= 1:\n        k1 ^= key[tail_index + 0]\n\n    if tail_size != 0:\n        k1 = (k1 * c1) & 0xFFFFFFFF\n        k1 = (k1 << 15 | k1 >> 17) & 0xFFFFFFFF  # _ROTL32\n        k1 = (k1 * c2) & 0xFFFFFFFF\n        h1 ^= k1\n\n    result = _fmix(h1 ^ length)\n    return -(result & 0x80000000) | (result & 0x7FFFFFFF)", "response": "murmur3 hash function to determine partition of a murmur3 hash."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calculate_size(name, index, value):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    data_size += calculate_size_data(value)\n    return data_size", "response": "Calculates the size of the data payload."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the size of the request payload.", "response": "def calculate_size(name, index):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(self, item):\n        check_not_none(item, \"Value can't be None\")\n        element_data = self._to_data(item)\n        return self._encode_invoke(list_add_codec, value=element_data)", "response": "Adds the specified item to the end of this list. If the item is not already present in this list returns false."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds all of the specified items to the end of this list.", "response": "def add_all(self, items):\n        \"\"\"\n        Adds all of the items in the specified collection to the end of this list. The order of new elements is\n        determined by the specified collection's iterator.\n\n        :param items: (Collection), the specified collection which includes the elements to be added to list.\n        :return: (bool), ``true`` if this call changed the list, ``false`` otherwise.\n        \"\"\"\n        check_not_none(items, \"Value can't be None\")\n        data_items = []\n        for item in items:\n            check_not_none(item, \"Value can't be None\")\n            data_items.append(self._to_data(item))\n        return self._encode_invoke(list_add_all_codec, value_list=data_items)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds all of the elements in the specified collection into this list at the specified position.", "response": "def add_all_at(self, index, items):\n        \"\"\"\n        Adds all of the elements in the specified collection into this list at the specified position. Elements in this\n        positions and following elements are shifted to the right, if any. The order of new elements is determined by the\n        specified collection's iterator.\n\n        :param index: (int), the specified index at which the first element of specified collection is added.\n        :param items: (Collection), the specified collection which includes the elements to be added to list.\n        :return: (bool), ``true`` if this call changed the list, ``false`` otherwise.\n        \"\"\"\n        check_not_none(items, \"Value can't be None\")\n        data_items = []\n        for item in items:\n            check_not_none(item, \"Value can't be None\")\n            data_items.append(self._to_data(item))\n        return self._encode_invoke(list_add_all_with_index_codec, index=index, value_list=data_items)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef contains_all(self, items):\n        check_not_none(items, \"Items can't be None\")\n        data_items = []\n        for item in items:\n            check_not_none(item, \"item can't be None\")\n            data_items.append(self._to_data(item))\n        return self._encode_invoke(list_contains_all_codec, values=data_items)", "response": "Determines whether this list contains all of the specified items in the specified collection or not."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the first index of the specified item in this list. If the specified item is not present in this list returns - 1.", "response": "def index_of(self, item):\n        \"\"\"\n        Returns the first index of specified items's occurrences in this list. If specified item is not present in this\n        list, returns -1.\n\n        :param item: (object), the specified item to be searched for.\n        :return: (int), the first index of specified items's occurrences, -1 if item is not present in this list.\n        \"\"\"\n        check_not_none(item, \"Value can't be None\")\n        item_data = self._to_data(item)\n        return self._encode_invoke(list_index_of_codec, value=item_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef last_index_of(self, item):\n        check_not_none(item, \"Value can't be None\")\n        item_data = self._to_data(item)\n        return self._encode_invoke(list_last_index_of_codec, value=item_data)", "response": "Returns the last index of the specified item in this list. If the specified item is not present in this list returns - 1."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove(self, item):\n        check_not_none(item, \"Value can't be None\")\n        item_data = self._to_data(item)\n        return self._encode_invoke(list_remove_codec, value=item_data)", "response": "Removes the specified element from the list if it exists in this list. Returns True if the specified element is present in the list otherwise returns False."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_all(self, items):\n        check_not_none(items, \"Value can't be None\")\n        data_items = []\n        for item in items:\n            check_not_none(item, \"Value can't be None\")\n            data_items.append(self._to_data(item))\n        return self._encode_invoke(list_compare_and_remove_all_codec, values=data_items)", "response": "Removes all of the elements that are present in the specified collection from this list."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves the specified item listener. Returns silently if the specified listener was not added before.", "response": "def remove_listener(self, registration_id):\n        \"\"\"\n        Removes the specified item listener. Returns silently if the specified listener was not added before.\n\n        :param registration_id: (str), id of the listener to be deleted.\n        :return: (bool), ``true`` if the item listener is removed, ``false`` otherwise.\n        \"\"\"\n        return self._stop_listening(registration_id, lambda i: list_remove_listener_codec.encode_request(self.name, i))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretaining only the items that are contained in the specified collection.", "response": "def retain_all(self, items):\n        \"\"\"\n        Retains only the items that are contained in the specified collection. It means, items which are not present in\n        the specified collection are removed from this list.\n\n        :param items: (Collection), collections which includes the elements to be retained in this list.\n        :return: (bool), ``true`` if this list changed as a result of the call.\n        \"\"\"\n        check_not_none(items, \"Value can't be None\")\n        data_items = []\n        for item in items:\n            check_not_none(item, \"Value can't be None\")\n            data_items.append(self._to_data(item))\n        return self._encode_invoke(list_compare_and_retain_all_codec, values=data_items)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreplaces the specified element with the specified item at the specified position in this list.", "response": "def set_at(self, index, item):\n        \"\"\"\n        Replaces the specified element with the element at the specified position in this list.\n\n        :param index: (int), index of the item to be replaced.\n        :param item: (object), item to be stored.\n        :return: (object), the previous item in the specified index.\n        \"\"\"\n        check_not_none(item, \"Value can't be None\")\n        element_data = self._to_data(item)\n        return self._encode_invoke(list_set_codec, index=index, value=element_data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of the entries in this list that are contained within the specified range from_index and to_index.", "response": "def sub_list(self, from_index, to_index):\n        \"\"\"\n        Returns a sublist from this list, whose range is specified with from_index(inclusive) and to_index(exclusive).\n        The returned list is backed by this list, so non-structural changes in the returned list are reflected in this\n        list, and vice-versa.\n\n        :param from_index: (int), the start point(inclusive) of the sub_list.\n        :param to_index: (int), th end point(exclusive) of the sub_list.\n        :return: (Sequence), a view of the specified range within this list.\n        \"\"\"\n        return self._encode_invoke(list_sub_codec, from_=from_index, to=to_index)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_entry_listener(self, include_value=False, key=None, predicate=None, added_func=None, removed_func=None, updated_func=None,\n                           evicted_func=None, evict_all_func=None, clear_all_func=None, merged_func=None, expired_func=None):\n        \"\"\"\n        Adds a continuous entry listener for this map. Listener will get notified for map events filtered with given\n        parameters.\n\n        :param include_value: (bool), whether received event should include the value or not (optional).\n        :param key: (object), key for filtering the events (optional).\n        :param predicate: (Predicate), predicate for filtering the events (optional).\n        :param added_func: Function to be called when an entry is added to map (optional).\n        :param removed_func: Function to be called when an entry is removed from map (optional).\n        :param updated_func: Function to be called when an entry is updated (optional).\n        :param evicted_func: Function to be called when an entry is evicted from map (optional).\n        :param evict_all_func: Function to be called when entries are evicted from map (optional).\n        :param clear_all_func: Function to be called when entries are cleared from map (optional).\n        :param merged_func: Function to be called when WAN replicated entry is merged_func (optional).\n        :param expired_func: Function to be called when an entry's live time is expired (optional).\n        :return: (str), a registration id which is used as a key to remove the listener.\n\n        .. seealso:: :class:`~hazelcast.serialization.predicate.Predicate` for more info about predicates.\n        \"\"\"\n        flags = get_entry_listener_flags(added=added_func, removed=removed_func, updated=updated_func,\n                                         evicted=evicted_func, evict_all=evict_all_func, clear_all=clear_all_func, merged=merged_func,\n                                         expired=expired_func)\n\n        if key and predicate:\n            key_data = self._to_data(key)\n            predicate_data = self._to_data(predicate)\n            request = map_add_entry_listener_to_key_with_predicate_codec.encode_request(self.name, key_data,\n                                                                                        predicate_data, include_value,\n                                                                                        flags, False)\n        elif key and not predicate:\n            key_data = self._to_data(key)\n            request = map_add_entry_listener_to_key_codec.encode_request(self.name, key_data, include_value, flags,\n                                                                         False)\n        elif not key and predicate:\n            predicate = self._to_data(predicate)\n            request = map_add_entry_listener_with_predicate_codec.encode_request(self.name, predicate, include_value,\n                                                                                 flags, False)\n        else:\n            request = map_add_entry_listener_codec.encode_request(self.name, include_value, flags, False)\n\n        def handle_event_entry(**_kwargs):\n            event = EntryEvent(self._to_object, **_kwargs)\n            if event.event_type == EntryEventType.added:\n                added_func(event)\n            elif event.event_type == EntryEventType.removed:\n                removed_func(event)\n            elif event.event_type == EntryEventType.updated:\n                updated_func(event)\n            elif event.event_type == EntryEventType.evicted:\n                evicted_func(event)\n            elif event.event_type == EntryEventType.evict_all:\n                evict_all_func(event)\n            elif event.event_type == EntryEventType.clear_all:\n                clear_all_func(event)\n            elif event.event_type == EntryEventType.merged:\n                merged_func(event)\n            elif event.event_type == EntryEventType.expired:\n                expired_func(event)\n\n        return self._start_listening(request, lambda m: map_add_entry_listener_codec.handle(m, handle_event_entry),\n                                     lambda r: map_add_entry_listener_codec.decode_response(r)['response'])", "response": "Adds a continuous entry listener for this map."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an index to this map for the specified entries.", "response": "def add_index(self, attribute, ordered=False):\n        \"\"\"\n        Adds an index to this map for the specified entries so that queries can run faster.\n\n        Example:\n            Let's say your map values are Employee objects.\n                >>> class Employee(IdentifiedDataSerializable):\n                >>>     active = false\n                >>>     age = None\n                >>>     name = None\n                >>>     #other fields\n                >>>\n                >>>     #methods\n\n            If you query your values mostly based on age and active fields, you should consider indexing these.\n                >>> map = self.client.get_map(\"employees\")\n                >>> map.add_index(\"age\" , true) #ordered, since we have ranged queries for this field\n                >>> map.add_index(\"active\", false) #not ordered, because boolean field cannot have range\n\n\n        :param attribute: (str), index attribute of the value.\n        :param ordered: (bool), for ordering the index or not (optional).\n        \"\"\"\n        return self._encode_invoke(map_add_index_codec, attribute=attribute, ordered=ordered)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an interceptor to this map.", "response": "def add_interceptor(self, interceptor):\n        \"\"\"\n        Adds an interceptor for this map. Added interceptor will intercept operations and execute user defined methods.\n\n        :param interceptor: (object), interceptor for the map which includes user defined methods.\n        :return: (str),id of registered interceptor.\n        \"\"\"\n        return self._encode_invoke(map_add_interceptor_codec, interceptor=self._to_data(interceptor))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef contains_key(self, key):\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._contains_key_internal(key_data)", "response": "Determines whether this map contains the specified key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetermining whether this map contains one or more keys for the specified value.", "response": "def contains_value(self, value):\n        \"\"\"\n        Determines whether this map contains one or more keys for the specified value.\n\n        :param value: (object), the specified value.\n        :return: (bool), ``true`` if this map contains an entry for the specified value.\n        \"\"\"\n        check_not_none(value, \"value can't be None\")\n        value_data = self._to_data(value)\n        return self._encode_invoke(map_contains_value_codec, value=value_data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(self, key):\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._delete_internal(key_data)", "response": "Deletes the entry with the specified key from this map."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of key - value tuples containing the mappings contained in this map.", "response": "def entry_set(self, predicate=None):\n        \"\"\"\n        Returns a list clone of the mappings contained in this map.\n\n        **Warning:\n        The list is NOT backed by the map, so changes to the map are NOT reflected in the list, and vice-versa.**\n\n        :param predicate: (Predicate), predicate for the map to filter entries (optional).\n        :return: (Sequence), the list of key-value tuples in the map.\n\n        .. seealso:: :class:`~hazelcast.serialization.predicate.Predicate` for more info about predicates.\n        \"\"\"\n        if predicate:\n            predicate_data = self._to_data(predicate)\n            return self._encode_invoke(map_entries_with_predicate_codec, predicate=predicate_data)\n        else:\n            return self._encode_invoke(map_entry_set_codec)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef evict(self, key):\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._evict_internal(key_data)", "response": "Evicts the specified key from this map."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying the user defined EntryProcessor to all entries in the map or entries in the map which satisfies the predicate if provided. Returns the results mapped by each key in the map.", "response": "def execute_on_entries(self, entry_processor, predicate=None):\n        \"\"\"\n        Applies the user defined EntryProcessor to all the entries in the map or entries in the map which satisfies\n        the predicate if provided. Returns the results mapped by each key in the map.\n\n        :param entry_processor: (object), A stateful serializable object which represents the EntryProcessor defined on\n            server side.\n            This object must have a serializable EntryProcessor counter part registered on server side with the actual\n            ``org.hazelcast.map.EntryProcessor`` implementation.\n        :param predicate: (Predicate), predicate for filtering the entries (optional).\n        :return: (Sequence), list of map entries which includes the keys and the results of the entry process.\n\n        .. seealso:: :class:`~hazelcast.serialization.predicate.Predicate` for more info about predicates.\n        \"\"\"\n        if predicate:\n            return self._encode_invoke(map_execute_with_predicate_codec, entry_processor=self._to_data(entry_processor),\n                                       predicate=self._to_data(predicate))\n        return self._encode_invoke(map_execute_on_all_keys_codec, entry_processor=self._to_data(entry_processor))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying the user defined EntryProcessor to the entry mapped by the key. Returns the object which is the result of the entry process.", "response": "def execute_on_key(self, key, entry_processor):\n        \"\"\"\n        Applies the user defined EntryProcessor to the entry mapped by the key. Returns the object which is the result\n        of EntryProcessor's process method.\n\n        :param key: (object), specified key for the entry to be processed.\n        :param entry_processor: (object), A stateful serializable object which represents the EntryProcessor defined on\n            server side.\n            This object must have a serializable EntryProcessor counter part registered on server side with the actual\n            ``org.hazelcast.map.EntryProcessor`` implementation.\n        :return: (object), result of entry process.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._execute_on_key_internal(key_data, entry_processor)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying the user defined EntryProcessor to the entries mapped by the given keys. Returns the results of the entry process.", "response": "def execute_on_keys(self, keys, entry_processor):\n        \"\"\"\n        Applies the user defined EntryProcessor to the entries mapped by the collection of keys. Returns the results\n        mapped by each key in the collection.\n\n        :param keys: (Collection), collection of the keys for the entries to be processed.\n        :param entry_processor: (object), A stateful serializable object which represents the EntryProcessor defined on\n            server side.\n            This object must have a serializable EntryProcessor counter part registered on server side with the actual\n            ``org.hazelcast.map.EntryProcessor`` implementation.\n        :return: (Sequence), list of map entries which includes the keys and the results of the entry process.\n        \"\"\"\n        key_list = []\n        for key in keys:\n            check_not_none(key, \"key can't be None\")\n            key_list.append(self._to_data(key))\n\n        if len(keys) == 0:\n            return ImmediateFuture([])\n\n        return self._encode_invoke(map_execute_on_keys_codec, entry_processor=self._to_data(entry_processor),\n                                   keys=key_list)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef force_unlock(self, key):\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(map_force_unlock_codec, key_data, key=key_data,\n                                          reference_id=self.reference_id_generator.get_and_increment())", "response": "Force unlocks the lock for the specified key regardless of the lock owner."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the value for the specified key in this map or None if the key is not present.", "response": "def get(self, key):\n        \"\"\"\n        Returns the value for the specified key, or ``None`` if this map does not contain this key.\n\n        **Warning:\n        This method returns a clone of original value, modifying the returned value does not change the actual value in\n        the map. One should put modified value back to make changes visible to all nodes.**\n            >>> value = map.get(key)\n            >>> value.update_some_property()\n            >>> map.put(key,value)\n\n        **Warning 2: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        :param key: (object), the specified key.\n        :return: (object), the value for the specified key.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._get_internal(key_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_all(self, keys):\n        check_not_none(keys, \"keys can't be None\")\n        if not keys:\n            return ImmediateFuture({})\n\n        partition_service = self._client.partition_service\n        partition_to_keys = {}\n\n        for key in keys:\n            check_not_none(key, \"key can't be None\")\n            key_data = self._to_data(key)\n            partition_id = partition_service.get_partition_id(key_data)\n            try:\n                partition_to_keys[partition_id][key] = key_data\n            except KeyError:\n                partition_to_keys[partition_id] = {key: key_data}\n\n        return self._get_all_internal(partition_to_keys)", "response": "Get all entries for the given keys."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the EntryView for the specified key.", "response": "def get_entry_view(self, key):\n        \"\"\"\n        Returns the EntryView for the specified key.\n\n        **Warning:\n        This method returns a clone of original mapping, modifying the returned value does not change the actual value\n        in the map. One should put modified value back to make changes visible to all nodes.**\n\n        **Warning 2: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        :param key: (object), the key of the entry.\n        :return: (EntryView), EntryView of the specified key.\n\n        .. seealso:: :class:`~hazelcast.core.EntryView` for more info about EntryView.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(map_get_entry_view_codec, key_data, key=key_data, thread_id=thread_id())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_locked(self, key):\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(map_is_locked_codec, key_data, key=key_data)", "response": "Checks the lock for the specified key and returns true if it is acquired otherwise false."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef key_set(self, predicate=None):\n        if predicate:\n            predicate_data = self._to_data(predicate)\n            return self._encode_invoke(map_key_set_with_predicate_codec, predicate=predicate_data)\n        else:\n            return self._encode_invoke(map_key_set_codec)", "response": "Returns a list of the keys contained in this map or the keys of the entries filtered with the predicate if provided."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_all(self, keys=None, replace_existing_values=True):\n        if keys:\n            key_data_list = list(map(self._to_data, keys))\n            return self._load_all_internal(key_data_list, replace_existing_values)\n        else:\n            return self._encode_invoke(map_load_all_codec, replace_existing_values=replace_existing_values)", "response": "Loads all entries from the store at server side or loads the given keys if provided."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nacquire the lock for the specified key infinitely or for the specified lease time. If the lock is not available the current thread is disabled for thread scheduling purposes and lieson until the lock is released.", "response": "def lock(self, key, ttl=-1):\n        \"\"\"\n        Acquires the lock for the specified key infinitely or for the specified lease time if provided.\n\n        If the lock is not available, the current thread becomes disabled for thread scheduling purposes and lies\n        dormant until the lock has been acquired.\n\n        You get a lock whether the value is present in the map or not. Other threads (possibly on other systems) would\n        block on their invoke of lock() until the non-existent key is unlocked. If the lock holder introduces the key to\n        the map, the put() operation is not blocked. If a thread not holding a lock on the non-existent key tries to\n        introduce the key while a lock exists on the non-existent key, the put() operation blocks until it is unlocked.\n\n        Scope of the lock is this map only. Acquired lock is only for the key in this map.\n\n        Locks are re-entrant; so, if the key is locked N times, it should be unlocked N times before another thread can\n        acquire it.\n\n        **Warning: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        :param key: (object), the key to lock.\n        :param ttl: (int), time in seconds to wait before releasing the lock (optional).\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._encode_invoke_on_key(map_lock_codec, key_data, invocation_timeout=MAX_SIZE, key=key_data,\n                                          thread_id=thread_id(), ttl=to_millis(ttl),\n                                          reference_id=self.reference_id_generator.get_and_increment())"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds all of the mappings from the specified map to this map.", "response": "def put_all(self, map):\n        \"\"\"\n        Copies all of the mappings from the specified map to this map. No atomicity guarantees are\n        given. In the case of a failure, some of the key-value tuples may get written, while others are not.\n\n        :param map: (dict), map which includes mappings to be stored in this map.\n        \"\"\"\n        check_not_none(map, \"map can't be None\")\n        if not map:\n            return ImmediateFuture(None)\n\n        partition_service = self._client.partition_service\n        partition_map = {}\n\n        for key, value in six.iteritems(map):\n            check_not_none(key, \"key can't be None\")\n            check_not_none(value, \"value can't be None\")\n            entry = (self._to_data(key), self._to_data(value))\n            partition_id = partition_service.get_partition_id(entry[0])\n            try:\n                partition_map[partition_id].append(entry)\n            except KeyError:\n                partition_map[partition_id] = [entry]\n\n        futures = []\n        for partition_id, entry_list in six.iteritems(partition_map):\n            future = self._encode_invoke_on_partition(map_put_all_codec, partition_id, entries=dict(entry_list))\n            futures.append(future)\n\n        return combine_futures(*futures)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nputs a transient entry in the MapStore.", "response": "def put_transient(self, key, value, ttl=-1):\n        \"\"\"\n        Same as put(TKey, TValue, Ttl), but MapStore defined at the server side will not be called.\n\n        **Warning: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        :param key: (object), key of the entry.\n        :param value: (object), value of the entry.\n        :param ttl: (int), maximum time in seconds for this entry to stay in the map, if not provided, the value\n            configured on server side configuration will be used (optional).\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        check_not_none(value, \"value can't be None\")\n\n        key_data = self._to_data(key)\n        value_data = self._to_data(value)\n        return self._put_transient_internal(key_data, value_data, ttl)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove(self, key):\n        check_not_none(key, \"key can't be None\")\n        key_data = self._to_data(key)\n        return self._remove_internal(key_data)", "response": "Removes the mapping for a key from this map if it is present. Returns None if the key is not present."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the entry for a key only if it is currently mapped to a given value. Returns True if the value was removed otherwise False.", "response": "def remove_if_same(self, key, value):\n        \"\"\"\n        Removes the entry for a key only if it is currently mapped to a given value.\n\n        This is equivalent to:\n            >>> if map.contains_key(key) and map.get(key).equals(value):\n            >>>     map.remove(key)\n            >>>     return true\n            >>> else:\n            >>>     return false\n        except that the action is performed atomically.\n\n        **Warning: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        :param key: (object), the specified key.\n        :param value: (object), remove the key if it has this value.\n        :return: (bool), ``true`` if the value was removed.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        check_not_none(value, \"value can't be None\")\n\n        key_data = self._to_data(key)\n        value_data = self._to_data(value)\n        return self._remove_if_same_internal_(key_data, value_data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the specified entry listener. Returns silently if there is no such listener added before.", "response": "def remove_entry_listener(self, registration_id):\n        \"\"\"\n        Removes the specified entry listener. Returns silently if there is no such listener added before.\n\n        :param registration_id: (str), id of registered listener.\n        :return: (bool), ``true`` if registration is removed, ``false`` otherwise.\n        \"\"\"\n        return self._stop_listening(registration_id,\n                                    lambda i: map_remove_entry_listener_codec.encode_request(self.name, i))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreplacing the entry for a key only if it is currently mapped to some value. Returns the original value or None if there is no such entry.", "response": "def replace(self, key, value):\n        \"\"\"\n        Replaces the entry for a key only if it is currently mapped to some value.\n\n        This is equivalent to:\n            >>> if map.contains_key(key):\n            >>>     return map.put(key,value)\n            >>> else:\n            >>>     return None\n        except that the action is performed atomically.\n\n        **Warning: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        **Warning 2:\n        This method returns a clone of the previous value, not the original (identically equal) value previously put\n        into the map.**\n\n        :param key: (object), the specified key.\n        :param value: (object), the value to replace the previous value.\n        :return: (object), previous value associated with key, or ``None`` if there was no mapping for key.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        check_not_none(value, \"value can't be None\")\n\n        key_data = self._to_data(key)\n        value_data = self._to_data(value)\n\n        return self._replace_internal(key_data, value_data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreplace the entry for a key only if it is currently mapped to a given value.", "response": "def replace_if_same(self, key, old_value, new_value):\n        \"\"\"\n        Replaces the entry for a key only if it is currently mapped to a given value.\n\n        This is equivalent to:\n            >>> if map.contains_key(key) and map.get(key).equals(old_value):\n            >>>     map.put(key, new_value)\n            >>>     return true\n            >>> else:\n            >>>     return false\n        except that the action is performed atomically.\n\n        **Warning: This method uses __hash__ and __eq__ methods of binary form of the key, not the actual implementations\n        of __hash__ and __eq__ defined in key's class.**\n\n        :param key: (object), the specified key.\n        :param old_value: (object), replace the key value if it is the old value.\n        :param new_value: (object), the new value to replace the old value.\n        :return: (bool), ``true`` if the value was replaced.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n        check_not_none(old_value, \"old_value can't be None\")\n        check_not_none(new_value, \"new_value can't be None\")\n\n        key_data = self._to_data(key)\n        old_value_data = self._to_data(old_value)\n        new_value_data = self._to_data(new_value)\n\n        return self._replace_if_same_internal(key_data, old_value_data, new_value_data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set(self, key, value, ttl=-1):\n        check_not_none(key, \"key can't be None\")\n        check_not_none(value, \"value can't be None\")\n        key_data = self._to_data(key)\n        value_data = self._to_data(value)\n        return self._set_internal(key_data, value_data, ttl)", "response": "Sets an entry into the cache."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntry to acquire the lock for the specified key. If the lock is not available returns False. If the lock is available returns True. If the lock is available returns False.", "response": "def try_lock(self, key, ttl=-1, timeout=0):\n        \"\"\"\n        Tries to acquire the lock for the specified key. When the lock is not available,\n\n            * If timeout is not provided, the current thread doesn't wait and returns ``false`` immediately.\n            * If a timeout is provided, the current thread becomes disabled for thread scheduling purposes and lies\n              dormant until one of the followings happens:\n                * the lock is acquired by the current thread, or\n                * the specified waiting time elapses.\n\n        If ttl is provided, lock will be released after this time elapses.\n\n        :param key: (object), key to lock in this map.\n        :param ttl: (int), time in seconds to wait before releasing the lock (optional).\n        :param timeout: (int), maximum time in seconds to wait for the lock (optional).\n        :return: (bool), ``true`` if the lock was acquired and otherwise, ``false``.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n\n        key_data = self._to_data(key)\n\n        return self._encode_invoke_on_key(map_try_lock_codec, key_data, invocation_timeout=MAX_SIZE, key=key_data,\n                                          thread_id=thread_id(), lease=to_millis(ttl), timeout=to_millis(timeout),\n                                          reference_id=self.reference_id_generator.get_and_increment())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrelease the lock for the specified key. If the lock is already held it returns immediately.", "response": "def unlock(self, key):\n        \"\"\"\n        Releases the lock for the specified key. It never blocks and returns immediately. If the current thread is the\n        holder of this lock, then the hold count is decremented. If the hold count is zero, then the lock is released.\n\n        :param key: (object), the key to lock.\n        \"\"\"\n        check_not_none(key, \"key can't be None\")\n\n        key_data = self._to_data(key)\n\n        return self._encode_invoke_on_key(map_unlock_codec, key_data, key=key_data, thread_id=thread_id(),\n                                          reference_id=self.reference_id_generator.get_and_increment())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef values(self, predicate=None):\n        if predicate:\n            predicate_data = self._to_data(predicate)\n            return self._encode_invoke(map_values_with_predicate_codec, predicate=predicate_data)\n        else:\n            return self._encode_invoke(map_values_codec)", "response": "Returns a list of values contained in this map or values of the entries which are filtered with the predicate if provided."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef new_transaction(self, timeout, durability, transaction_type):\n        connection = self._connect()\n        return Transaction(self._client, connection, timeout, durability, transaction_type)", "response": "Creates a new Transaction object with given timeout durability and transaction type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart a new transaction.", "response": "def begin(self):\n        \"\"\"\n        Begins this transaction.\n        \"\"\"\n        if hasattr(self._locals, 'transaction_exists') and self._locals.transaction_exists:\n            raise TransactionError(\"Nested transactions are not allowed.\")\n        if self.state != _STATE_NOT_STARTED:\n            raise TransactionError(\"Transaction has already been started.\")\n        self._locals.transaction_exists = True\n        self.start_time = time.time()\n        self.thread_id = thread_id()\n        try:\n            request = transaction_create_codec.encode_request(timeout=int(self.timeout * 1000), durability=self.durability,\n                                                              transaction_type=self.transaction_type,\n                                                              thread_id=self.thread_id)\n            response = self.client.invoker.invoke_on_connection(request, self.connection).result()\n            self.id = transaction_create_codec.decode_response(response)[\"response\"]\n            self.state = _STATE_ACTIVE\n        except:\n            self._locals.transaction_exists = False\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rollback(self):\n        self._check_thread()\n        if self.state not in (_STATE_ACTIVE, _STATE_PARTIAL_COMMIT):\n            raise TransactionError(\"Transaction is not active.\")\n        try:\n            if self.state != _STATE_PARTIAL_COMMIT:\n                request = transaction_rollback_codec.encode_request(self.id, self.thread_id)\n                self.client.invoker.invoke_on_connection(request, self.connection).result()\n            self.state = _STATE_ROLLED_BACK\n        finally:\n            self._locals.transaction_exists = False", "response": "Rolls back the current transaction."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the size of the request payload.", "response": "def calculate_size(transaction_id, thread_id):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(transaction_id)\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_addresses(self):\n        try:\n            return list(self.cloud_discovery.discover_nodes().keys())\n        except Exception as ex:\n            self.logger.warning(\"Failed to load addresses from Hazelcast.cloud: {}\".format(ex.args[0]),\n                                extra=self._logger_extras)\n        return []", "response": "Loads the list of possible member addresses from Hazelcast. cloud endpoint."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef translate(self, address):\n        if address is None:\n            return None\n\n        public_address = self._private_to_public.get(address)\n        if public_address:\n            return public_address\n\n        self.refresh()\n\n        return self._private_to_public.get(address)", "response": "Translate the given address to another address specific to network or service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef refresh(self):\n        try:\n            self._private_to_public = self.cloud_discovery.discover_nodes()\n        except Exception as ex:\n            self.logger.warning(\"Failed to load addresses from Hazelcast.cloud: {}\".format(ex.args[0]),\n                                extra=self._logger_extras)", "response": "Refreshes the internal lookup table if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_host_and_url(properties, cloud_token):\n        host = properties.get(HazelcastCloudDiscovery.CLOUD_URL_BASE_PROPERTY.name,\n                              HazelcastCloudDiscovery.CLOUD_URL_BASE_PROPERTY.default_value)\n        host = host.replace(\"https://\", \"\")\n        host = host.replace(\"http://\", \"\")\n        return host, HazelcastCloudDiscovery._CLOUD_URL_PATH + cloud_token", "response": "Helper method to get host and url for HazelcastCloudDiscovery."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the size of the request payload.", "response": "def calculate_size(name, message):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_data(message)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle(client_message, handle_event_partition_lost=None, to_object=None):\n    message_type = client_message.get_message_type()\n    if message_type == EVENT_PARTITIONLOST and handle_event_partition_lost is not None:\n        partition_id = client_message.read_int()\n        lost_backup_count = client_message.read_int()\n        source = None\n        if not client_message.read_bool():\n            source = AddressCodec.decode(client_message, to_object)\n        handle_event_partition_lost(partition_id=partition_id, lost_backup_count=lost_backup_count, source=source)", "response": "Handle an event from the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calculate_size(name, timeout_millis):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate the size of the data payload.", "response": "def calculate_size(name, txn_id, thread_id, key, old_value, new_value):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_str(txn_id)\n    data_size += LONG_SIZE_IN_BYTES\n    data_size += calculate_size_data(key)\n    data_size += calculate_size_data(old_value)\n    data_size += calculate_size_data(new_value)\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the size of the request payload.", "response": "def calculate_size(name, thread_id):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calculate_size(uuid, address, interrupt):\n    data_size = 0\n    data_size += calculate_size_str(uuid)\n    data_size += calculate_size_address(address)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nencoding a request into a client_message.", "response": "def encode_request(uuid, address, interrupt):\n    \"\"\" Encode request into client_message\"\"\"\n    client_message = ClientMessage(payload_size=calculate_size(uuid, address, interrupt))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(uuid)\n    AddressCodec.encode(client_message, address)\n    client_message.append_bool(interrupt)\n    client_message.update_frame_length()\n    return client_message"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntries to set the count to the given value. If the current count is zero this method does nothing.", "response": "def try_set_count(self, count):\n        \"\"\"\n        Sets the count to the given value if the current count is zero. If count is not zero, this method does nothing\n        and returns ``false``.\n\n        :param count: (int), the number of times count_down() must be invoked before threads can pass through await().\n        :return: (bool), ``true`` if the new count was set, ``false`` if the current count is not zero.\n        \"\"\"\n        check_not_negative(count, \"count can't be negative\")\n        return self._encode_invoke(count_down_latch_try_set_count_codec, count=count)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef destroy(self):\n        self._on_destroy()\n        return self._client.proxy.destroy_proxy(self.service_name, self.name)", "response": "Destroys this proxy.\n\n        :return: (bool), ``true`` if this proxy is deleted successfully, ``false`` otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculate_size(name, delta):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_listener(self, member_added=None, member_removed=None, fire_for_existing=False):\n        registration_id = str(uuid.uuid4())\n        self.listeners[registration_id] = (member_added, member_removed)\n\n        if fire_for_existing:\n            for member in self.get_member_list():\n                member_added(member)\n\n        return registration_id", "response": "Adds a membership listener to listen for membership updates."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_listener(self, registration_id):\n        try:\n            self.listeners.pop(registration_id)\n            return True\n        except KeyError:\n            return False", "response": "Removes the specified membership listener from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the member with the specified uuid.", "response": "def get_member_by_uuid(self, member_uuid):\n        \"\"\"\n        Returns the member with specified member uuid.\n\n        :param member_uuid: (int), uuid of the desired member.\n        :return: (:class:`~hazelcast.core.Member`), the corresponding member.\n        \"\"\"\n        for member in self.get_member_list():\n            if member.uuid == member_uuid:\n                return member"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the members that satisfy the given selector.", "response": "def get_members(self, selector):\n        \"\"\"\n        Returns the members that satisfy the given selector.\n\n        :param selector: (:class:`~hazelcast.core.MemberSelector`), Selector to be applied to the members.\n        :return: (List), List of members.\n        \"\"\"\n        members = []\n        for member in self.get_member_list():\n            if selector.select(member):\n                members.append(member)\n\n        return members"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning true if this vector clock is causally strictly after the provided vector clock.", "response": "def is_after(self, other):\n        \"\"\"\n        Returns true if this vector clock is causally strictly after the\n        provided vector clock. This means that it the provided clock is neither\n        equal to, greater than or concurrent to this vector clock.\n\n        :param other: (:class:`~hazelcast.cluster.VectorClock`), Vector clock to be compared\n        :return: (bool), True if this vector clock is strictly after the other vector clock, False otherwise\n        \"\"\"\n        any_timestamp_greater = False\n        for replica_id, other_timestamp in other.entry_set():\n            local_timestamp = self._replica_timestamps.get(replica_id)\n\n            if local_timestamp is None or local_timestamp < other_timestamp:\n                return False\n            elif local_timestamp > other_timestamp:\n                any_timestamp_greater = True\n\n        # there is at least one local timestamp greater or local vector clock has additional timestamps\n        return any_timestamp_greater or other.size() < self.size()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetermining whether the specified item exists in this set or not.", "response": "def contains(self, item):\n        \"\"\"\n        Determines whether this set contains the specified item or not.\n\n        :param item: (object), the specified item to be searched.\n        :return: (bool), ``true`` if the specified item exists in this set, ``false`` otherwise.\n        \"\"\"\n        check_not_none(item, \"Value can't be None\")\n        item_data = self._to_data(item)\n        return self._encode_invoke(set_contains_codec, value=item_data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine whether this set contains all of the specified items in the specified collection or not.", "response": "def contains_all(self, items):\n        \"\"\"\n        Determines whether this set contains all of the items in the specified collection or not.\n\n        :param items: (Collection), the specified collection which includes the items to be searched.\n        :return: (bool), ``true`` if all of the items in the specified collection exist in this set, ``false`` otherwise.\n        \"\"\"\n        check_not_none(items, \"Value can't be None\")\n        data_items = []\n        for item in items:\n            check_not_none(item, \"Value can't be None\")\n            data_items.append(self._to_data(item))\n        return self._encode_invoke(set_contains_all_codec, items=data_items)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the specified listener from the specified item. Returns silently if the specified listener was not added before.", "response": "def remove_listener(self, registration_id):\n        \"\"\"\n        Removes the specified item listener. Returns silently if the specified listener was not added before.\n\n        :param registration_id: (str), id of the listener to be deleted.\n        :return: (bool), ``true`` if the item listener is removed, ``false`` otherwise.\n        \"\"\"\n        return self._stop_listening(registration_id, lambda i: set_remove_listener_codec.encode_request(self.name, i))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the size of the request payload.", "response": "def calculate_size(name, expected, updated):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += LONG_SIZE_IN_BYTES\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nencodes a request into a client_message.", "response": "def encode_request(name, expected, updated):\n    \"\"\" Encode request into client_message\"\"\"\n    client_message = ClientMessage(payload_size=calculate_size(name, expected, updated))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_long(expected)\n    client_message.append_long(updated)\n    client_message.update_frame_length()\n    return client_message"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calculate_size(name, interceptor):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_data(interceptor)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the size of the data payload.", "response": "def calculate_size(name, uuid, callable, partition_id):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_str(uuid)\n    data_size += calculate_size_data(callable)\n    data_size += INT_SIZE_IN_BYTES\n    return data_size"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef encode_request(name, uuid, callable, partition_id):\n    client_message = ClientMessage(payload_size=calculate_size(name, uuid, callable, partition_id))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_str(uuid)\n    client_message.append_data(callable)\n    client_message.append_int(partition_id)\n    client_message.update_frame_length()\n    return client_message", "response": "Encode a request into a client_message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef alter(self, function):\n        check_not_none(function, \"function can't be None\")\n        return self._encode_invoke(atomic_long_alter_codec, function=self._to_data(function))", "response": "Alters the currently stored value by applying a function on it."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef alter_and_get(self, function):\n        check_not_none(function, \"function can't be None\")\n        return self._encode_invoke(atomic_long_alter_and_get_codec, function=self._to_data(function))", "response": "Alters the currently stored value by applying a function on it and gets the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apply(self, function):\n        check_not_none(function, \"function can't be None\")\n        return self._encode_invoke(atomic_long_apply_codec, function=self._to_data(function))", "response": "Applies a function on the value the actual stored value will not change."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naltering the currently stored value by applying a function on it on and gets the old value.", "response": "def get_and_alter(self, function):\n        \"\"\"\n        Alters the currently stored value by applying a function on it on and gets the old value.\n\n        :param function: (Function), A stateful serializable object which represents the Function defined on\n            server side.\n            This object must have a serializable Function counter part registered on server side with the actual\n            ``org.hazelcast.core.IFunction`` implementation.\n        :return: (long), the old value.\n        \"\"\"\n        check_not_none(function, \"function can't be None\")\n        return self._encode_invoke(atomic_long_get_and_alter_codec, function=self._to_data(function))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculate_size(name, key):\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_data(key)\n    return data_size", "response": "Calculates the size of the request payload."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main(jlink_serial, device):\n    buf = StringIO.StringIO()\n    jlink = pylink.JLink(log=buf.write, detailed_log=buf.write)\n    jlink.open(serial_no=jlink_serial)\n\n    # Use Serial Wire Debug as the target interface.\n    jlink.set_tif(pylink.enums.JLinkInterfaces.SWD)\n    jlink.connect(device, verbose=True)\n\n    sys.stdout.write('ARM Id: %d\\n' % jlink.core_id())\n    sys.stdout.write('CPU Id: %d\\n' % jlink.core_cpu())\n    sys.stdout.write('Core Name: %s\\n' % jlink.core_name())\n    sys.stdout.write('Device Family: %d\\n' % jlink.device_family())", "response": "Prints the core s information."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef acquire(self):\n        if os.path.exists(self.path):\n            try:\n                pid = None\n\n                with open(self.path, 'r') as f:\n                    line = f.readline().strip()\n                    pid = int(line)\n\n                # In the case that the lockfile exists, but the pid does not\n                # correspond to a valid process, remove the file.\n                if not psutil.pid_exists(pid):\n                    os.remove(self.path)\n\n            except ValueError as e:\n                # Pidfile is invalid, so just delete it.\n                os.remove(self.path)\n\n            except IOError as e:\n                # Something happened while trying to read/remove the file, so\n                # skip trying to read/remove it.\n                pass\n\n        try:\n            self.fd = os.open(self.path, os.O_CREAT | os.O_EXCL | os.O_RDWR)\n\n            # PID is written to the file, so that if a process exits wtihout\n            # cleaning up the lockfile, we can still acquire the lock.\n            to_write = '%s%s' % (os.getpid(), os.linesep)\n            os.write(self.fd, to_write.encode())\n\n        except OSError as e:\n            if not os.path.exists(self.path):\n                raise\n            return False\n\n        self.acquired = True\n        return True", "response": "Attempts to acquire a lock for the J - Link lockfile."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef release(self):\n        if not self.acquired:\n            return False\n\n        os.close(self.fd)\n\n        if os.path.exists(self.path):\n            os.remove(self.path)\n\n        self.acquired = False\n        return True", "response": "Cleans up the lockfile if it was acquired."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart the SWD transaction and returns a Response instance.", "response": "def send(self, jlink):\n        \"\"\"Starts the SWD transaction.\n\n        Steps for a Read Transaction:\n          1.  First phase in which the request is sent.\n          2.  Second phase in which an ACK is received.  This phase consists of\n              three bits. An OK response has the value ``1``.\n          3.  Once the ACK is received, the data phase can begin.  Consists of\n              ``32`` data bits followed by ``1`` parity bit calclulated based\n              on all ``32`` data bits.\n          4.  After the data phase, the interface must be clocked for at least\n              eight cycles to clock the transaction through the SW-DP; this is\n              done by reading an additional eight bits (eight clocks).\n\n        Args:\n          self (ReadRequest): the ``ReadRequest`` instance\n          jlink (JLink): the ``JLink`` instance to use for write/read\n\n        Returns:\n          An ``Response`` instance.\n        \"\"\"\n        ack = super(ReadRequest, self).send(jlink)\n\n        # Write the read command, then read the data and status.\n        jlink.swd_write32(0x0, 0x0)\n        jlink.swd_write8(0xFC, 0x0)\n        status = jlink.swd_read8(ack) & 7\n        data = jlink.swd_read32(ack + 3)\n\n        if status == Response.STATUS_ACK:\n            # Check the parity\n            parity = jlink.swd_read8(ack + 35) & 1\n            if util.calculate_parity(data) != parity:\n                return Response(-1, data)\n\n        return Response(status, data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send(self, jlink):\n        ack = super(WriteRequest, self).send(jlink)\n\n        # Turnaround phase for write.\n        jlink.swd_write(0x0, 0x0, 2)\n\n        # Write the data and the parity bits.\n        jlink.swd_write32(0xFFFFFFFF, self.data)\n        jlink.swd_write8(0xFF, util.calculate_parity(self.data))\n        return Response(jlink.swd_read8(ack) & 7)", "response": "Starts the SWD IO write transaction."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef progress_bar(iteration,\n                 total,\n                 prefix=None,\n                 suffix=None,\n                 decs=1,\n                 length=100):\n    \"\"\"Creates a console progress bar.\n\n    This should be called in a loop to create a progress bar.\n\n    See `StackOverflow <http://stackoverflow.com/questions/3173320/>`__.\n\n    Args:\n      iteration (int): current iteration\n      total (int): total iterations\n      prefix (str): prefix string\n      suffix (str): suffix string\n      decs (int): positive number of decimals in percent complete\n      length (int): character length of the bar\n\n    Returns:\n      ``None``\n\n    Note:\n      This function assumes that nothing else is printed to the console in the\n      interim.\n    \"\"\"\n    if prefix is None:\n        prefix = ''\n\n    if suffix is None:\n        suffix = ''\n\n    format_str = '{0:.' + str(decs) + 'f}'\n    percents = format_str.format(100 * (iteration / float(total)))\n    filled_length = int(round(length * iteration / float(total)))\n    bar = '\u2588' * filled_length + '-' * (length - filled_length)\n\n    prefix, suffix = prefix.strip(), suffix.strip()\n\n    sys.stdout.write('\\r%s |%s| %s%s %s' % (prefix, bar, percents, '%', suffix))\n    sys.stdout.flush()\n\n    if iteration == total:\n        sys.stdout.write('\\n')\n        sys.stdout.flush()\n\n    return None", "response": "Creates a console progress bar."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates and returns the parity of a number.", "response": "def calculate_parity(n):\n    \"\"\"Calculates and returns the parity of a number.\n\n    The parity of a number is ``1`` if the number has an odd number of ones\n    in its binary representation, otherwise ``0``.\n\n    Args:\n      n (int): the number whose parity to calculate\n\n    Returns:\n      ``1`` if the number has an odd number of ones, otherwise ``0``.\n\n    Raises:\n      ValueError: if ``n`` is less than ``0``.\n    \"\"\"\n    if not is_natural(n):\n        raise ValueError('Expected n to be a positive integer.')\n\n    y = 0\n    n = abs(n)\n    while n:\n        y += n & 1\n        n = n >> 1\n    return y & 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serial_wire_viewer(jlink_serial, device):\n    buf = StringIO.StringIO()\n    jlink = pylink.JLink(log=buf.write, detailed_log=buf.write)\n    jlink.open(serial_no=jlink_serial)\n\n    # Use Serial Wire Debug as the target interface.  Need this in order to use\n    # Serial Wire Output.\n    jlink.set_tif(pylink.enums.JLinkInterfaces.SWD)\n    jlink.connect(device, verbose=True)\n    jlink.coresight_configure()\n    jlink.set_reset_strategy(pylink.enums.JLinkResetStrategyCortexM3.RESETPIN)\n\n    # Have to halt the CPU before getitng its speed.\n    jlink.reset()\n    jlink.halt()\n\n    # Output the information about the program.\n    sys.stdout.write('Serial Wire Viewer\\n')\n    sys.stdout.write('Press Ctrl-C to Exit\\n')\n    sys.stdout.write('Reading data from port 0:\\n\\n')\n\n    # Reset the core without halting so that it runs.\n    jlink.reset(ms=10, halt=False)\n\n    # Use the `try` loop to catch a keyboard interrupt in order to stop logging\n    # serial wire output.\n    try:\n        while True:\n            # Check the vector catch.\n            if jlink.register_read(0x0) != 0x05:\n                continue\n\n            offset = jlink.register_read(0x1)\n            handle, ptr, num_bytes = jlink.memory_read32(offset, 3)\n            read = ''.join(map(chr, jlink.memory_read8(ptr, num_bytes)))\n\n            if num_bytes == 0:\n                # If no bytes exist, sleep for a bit before trying again.\n                time.sleep(1)\n                continue\n\n            jlink.register_write(0x0, 0)\n            jlink.step(thumb=True)\n            jlink.restart(2, skip_breakpoints=True)\n\n            sys.stdout.write(read)\n            sys.stdout.flush()\n    except KeyboardInterrupt:\n        pass\n\n    sys.stdout.write('\\n')\n\n    return 0", "response": "A function that implements a serial wire viewer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pack(value, nbits=None):\n    if nbits is None:\n        nbits = pack_size(value) * BITS_PER_BYTE\n    elif nbits <= 0:\n        raise ValueError('Given number of bits must be greater than 0.')\n\n    buf_size = int(math.ceil(nbits / float(BITS_PER_BYTE)))\n    buf = (ctypes.c_uint8 * buf_size)()\n\n    for (idx, _) in enumerate(buf):\n        buf[idx] = (value >> (idx * BITS_PER_BYTE)) & 0xFF\n\n    return buf", "response": "Packs a given value into an array of 8 - bit unsigned integers."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads and returns the contents of the README. md file. On failure returns the project long description.", "response": "def long_description():\n    \"\"\"Reads and returns the contents of the README.\n\n    On failure, returns the project long description.\n\n    Returns:\n      The project's long description.\n    \"\"\"\n    cwd = os.path.abspath(os.path.dirname(__file__))\n    readme_path = os.path.join(cwd, 'README.md')\n    if not os.path.exists(readme_path):\n        return pylink.__long_description__\n\n    try:\n        import pypandoc\n        return pypandoc.convert(readme_path, 'rst')\n    except (IOError, ImportError):\n        pass\n\n    return open(readme_path, 'r').read()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npopulate the attributes. and self. build_dirs.", "response": "def finalize_options(self):\n        \"\"\"Populate the attributes.\n\n        Args:\n          self (CleanCommand): the ``CleanCommand`` instance\n\n        Returns:\n          ``None``\n        \"\"\"\n        self.cwd = os.path.abspath(os.path.dirname(__file__))\n        self.build_dirs = [\n            os.path.join(self.cwd, 'build'),\n            os.path.join(self.cwd, 'htmlcov'),\n            os.path.join(self.cwd, 'dist'),\n            os.path.join(self.cwd, 'pylink_square.egg-info')\n        ]\n        self.build_artifacts = ['.pyc', '.o', '.elf', '.bin']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self):\n        for build_dir in self.build_dirs:\n            if os.path.isdir(build_dir):\n                sys.stdout.write('Removing %s%s' % (build_dir, os.linesep))\n                shutil.rmtree(build_dir)\n\n        for (root, dirs, files) in os.walk(self.cwd):\n            for name in files:\n                fullpath = os.path.join(root, name)\n                if any(fullpath.endswith(ext) for ext in self.build_artifacts):\n                    sys.stdout.write('Removing %s%s' % (fullpath, os.linesep))\n                    os.remove(fullpath)", "response": "Runs the command.\n\n        Args:\n          self (CleanCommand): the ``CleanCommand`` instance\n\n        Returns:\n          ``None``"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef finalize_options(self):\n        self.cwd = os.path.abspath(os.path.dirname(__file__))\n        self.test_dir = os.path.join(self.cwd, 'tests')", "response": "Finalizes the command s options."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert the given error code to a string.", "response": "def to_string(cls, error_code):\n        \"\"\"Returns the string message for the given ``error_code``.\n\n        Args:\n          cls (JlinkGlobalErrors): the ``JLinkGlobalErrors`` class\n          error_code (int): error code to convert\n\n        Returns:\n          An error string corresponding to the error code.\n\n        Raises:\n          ValueError: if the error code is invalid.\n        \"\"\"\n        if error_code == cls.EMU_NO_CONNECTION:\n            return 'No connection to emulator.'\n        elif error_code == cls.EMU_COMM_ERROR:\n            return 'Emulator connection error.'\n        elif error_code == cls.DLL_NOT_OPEN:\n            return 'DLL has not been opened.  Did you call \\'.connect()\\'?'\n        elif error_code == cls.VCC_FAILURE:\n            return 'Target system has no power.'\n        elif error_code == cls.INVALID_HANDLE:\n            return 'Given file / memory handle is invalid.'\n        elif error_code == cls.NO_CPU_FOUND:\n            return 'Could not find supported CPU.'\n        elif error_code == cls.EMU_FEATURE_UNSUPPORTED:\n            return 'Emulator does not support the selected feature.'\n        elif error_code == cls.EMU_NO_MEMORY:\n            return 'Emulator out of memory.'\n        elif error_code == cls.TIF_STATUS_ERROR:\n            return 'Target interface error.'\n        elif error_code == cls.FLASH_PROG_COMPARE_FAILED:\n            return 'Programmed data differs from source data.'\n        elif error_code == cls.FLASH_PROG_PROGRAM_FAILED:\n            return 'Programming error occured.'\n        elif error_code == cls.FLASH_PROG_VERIFY_FAILED:\n            return 'Error while verifying programmed data.'\n        elif error_code == cls.OPEN_FILE_FAILED:\n            return 'Specified file could not be opened.'\n        elif error_code == cls.UNKNOWN_FILE_FORMAT:\n            return 'File format of selected file is not supported.'\n        elif error_code == cls.WRITE_TARGET_MEMORY_FAILED:\n            return 'Could not write target memory.'\n        elif error_code == cls.DEVICE_FEATURE_NOT_SUPPORTED:\n            return 'Feature not supported by connected device.'\n        elif error_code == cls.WRONG_USER_CONFIG:\n            return 'User configured DLL parameters incorrectly.'\n        elif error_code == cls.NO_TARGET_DEVICE_SELECTED:\n            return 'User did not specify core to connect to.'\n        elif error_code == cls.CPU_IN_LOW_POWER_MODE:\n            return 'Target CPU is in low power mode.'\n        elif error_code == cls.UNSPECIFIED_ERROR:\n            return 'Unspecified error.'\n        raise ValueError('Invalid error code: %d' % error_code)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the string message corresponding to the given error code.", "response": "def to_string(cls, error_code):\n        \"\"\"Returns the string message for the given ``error_code``.\n\n        Args:\n          cls (JLinkEraseErrors): the ``JLinkEraseErrors`` class\n          error_code (int): error code to convert\n\n        Returns:\n          An error string corresponding to the error code.\n\n        Raises:\n          ValueError: if the error code is invalid.\n        \"\"\"\n        if error_code == cls.ILLEGAL_COMMAND:\n            return 'Failed to erase sector.'\n        return super(JLinkEraseErrors, cls).to_string(error_code)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_string(cls, error_code):\n        if error_code == cls.COMPARE_ERROR:\n            return 'Error comparing flash content to programming data.'\n        elif error_code == cls.PROGRAM_ERASE_ERROR:\n            return 'Error during program/erase phase.'\n        elif error_code == cls.VERIFICATION_ERROR:\n            return 'Error verifying programmed data.'\n        return super(JLinkFlashErrors, cls).to_string(error_code)", "response": "Returns the string message corresponding to the given error code."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_string(cls, error_code):\n        if error_code == cls.ZONE_NOT_FOUND_ERROR:\n            return 'Zone not found'\n        return super(JLinkWriteErrors, cls).to_string(error_code)", "response": "Returns the string message corresponding to the given error code."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_string(cls, error_code):\n        if error_code == cls.ZONE_NOT_FOUND_ERROR:\n            return 'Zone not found'\n        return super(JLinkReadErrors, cls).to_string(error_code)", "response": "Returns the string message corresponding to the given error code."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the string message corresponding to the given error code.", "response": "def to_string(cls, error_code):\n        \"\"\"Returns the string message for the given error code.\n\n        Args:\n          cls (JLinkDataErrors): the ``JLinkDataErrors`` class\n          error_code (int): error code to convert\n\n        Returns:\n          An error string corresponding to the error code.\n\n        Raises:\n          ValueError: if the error code is invalid.\n        \"\"\"\n        if error_code == cls.ERROR_UNKNOWN:\n            return 'Unknown error.'\n        elif error_code == cls.ERROR_NO_MORE_EVENTS:\n            return 'There are no more available watchpoint units.'\n        elif error_code == cls.ERROR_NO_MORE_ADDR_COMP:\n            return 'No more address comparisons can be set.'\n        elif error_code == cls.ERROR_NO_MORE_DATA_COMP:\n            return 'No more data comparisons can be set.'\n        elif error_code == cls.ERROR_INVALID_ADDR_MASK:\n            return 'Invalid flags passed for the address mask.'\n        elif error_code == cls.ERROR_INVALID_DATA_MASK:\n            return 'Invalid flags passed for the data mask.'\n        elif error_code == cls.ERROR_INVALID_ACCESS_MASK:\n            return 'Invalid flags passed for the access mask.'\n        return super(JLinkDataErrors, cls).to_string(error_code)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_string(cls, error_code):\n        if error_code == cls.RTT_ERROR_CONTROL_BLOCK_NOT_FOUND:\n            return 'The RTT Control Block has not yet been found (wait?)'\n        return super(JLinkRTTErrors, cls).to_string(error_code)", "response": "Returns the string message corresponding to the given error code."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking whether the given flags are a valid identity.", "response": "def unlock_kinetis_identified(identity, flags):\n    \"\"\"Checks whether the given flags are a valid identity.\n\n    Args:\n      identity (Identity): the identity to validate against\n      flags (register.IDCodeRegisterFlags): the set idcode flags\n\n    Returns:\n      ``True`` if the given ``flags`` correctly identify the the debug\n      interface, otherwise ``False``.\n    \"\"\"\n    if flags.version_code != identity.version_code:\n        return False\n\n    if flags.part_no != identity.part_no:\n        return False\n\n    return flags.valid"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unlock_kinetis_abort_clear():\n    flags = registers.AbortRegisterFlags()\n    flags.STKCMPCLR = 1\n    flags.STKERRCLR = 1\n    flags.WDERRCLR = 1\n    flags.ORUNERRCLR = 1\n    return flags.value", "response": "Returns the abort register clear code."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unlock_kinetis_read_until_ack(jlink, address):\n    request = swd.ReadRequest(address, ap=True)\n    response = None\n    while True:\n        response = request.send(jlink)\n        if response.ack():\n            break\n        elif response.wait():\n            continue\n        raise KinetisException('Read exited with status: %s', response.status)\n\n    return response", "response": "Polls the device until the request is acknowledged."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nunlocks a Kinetis device over SWD.", "response": "def unlock_kinetis_swd(jlink):\n    \"\"\"Unlocks a Kinetis device over SWD.\n\n    Steps Involved in Unlocking:\n      1.  Verify that the device is configured to read/write from the CoreSight\n          registers; this is done by reading the Identification Code Register\n          and checking its validity.  This register is always at 0x0 on reads.\n      2.  Check for errors in the status register.  If there are any errors,\n          they must be cleared by writing to the Abort Register (this is always\n          0x0 on writes).\n      3.  Turn on the device power and debug power so that the target is\n          powered by the J-Link as more power is required during an unlock.\n      4.  Assert the ``RESET`` pin to force the target to hold in a reset-state\n          as to avoid interrupts and other potentially breaking behaviour.\n      5.  At this point, SWD is configured, so send a request to clear the\n          errors, if any, that may currently be set.\n      6.  Our next SWD request selects the MDM-AP register so that we can start\n          sending unlock instructions.  ``SELECT[31:24] = 0x01`` selects it.\n      7.  Poll the MDM-AP Status Register (AP[1] bank 0, register 0) until the\n          flash ready bit is set to indicate we can flash.\n      8.  Write to the MDM-AP Control Register (AP[1] bank 0, register 1) to\n          request a flash mass erase.\n      9.  Poll the system until the flash mass erase bit is acknowledged in the\n          MDM-AP Status Register.\n      10. Poll the control register until it clears it's mass erase bit to\n          indicate that it finished mass erasing, and therefore the system is\n          now unsecure.\n\n    Args:\n      jlink (JLink): the connected J-Link\n\n    Returns:\n      ``True`` if the device was unlocked successfully, otherwise ``False``.\n\n    Raises:\n      KinetisException: when the device cannot be unlocked or fails to unlock.\n\n    See Also:\n      `NXP Forum <https://community.nxp.com/thread/317167>`_.\n\n    See Also:\n      `Kinetis Docs <nxp.com/files/32bit/doc/ref_manual/K12P48M50SF4RM.pdf>`\n    \"\"\"\n    SWDIdentity = Identity(0x2, 0xBA01)\n    jlink.power_on()\n    jlink.coresight_configure()\n\n    # 1. Verify that the device is configured properly.\n    flags = registers.IDCodeRegisterFlags()\n    flags.value = jlink.coresight_read(0x0, False)\n    if not unlock_kinetis_identified(SWDIdentity, flags):\n        return False\n\n    # 2. Check for errors.\n    flags = registers.ControlStatusRegisterFlags()\n    flags.value = jlink.coresight_read(0x01, False)\n    if flags.STICKYORUN or flags.STICKYCMP or flags.STICKYERR or flags.WDATAERR:\n        jlink.coresight_write(0x0, unlock_kinetis_abort_clear(), False)\n\n    # 3. Turn on device power and debug.\n    flags = registers.ControlStatusRegisterFlags()\n    flags.value = 0\n    flags.CSYSPWRUPREQ = 1  # System power-up request\n    flags.CDBGPWRUPREQ = 1  # Debug power-up request\n    jlink.coresight_write(0x01, flags.value, False)\n\n    # 4. Assert the reset pin.\n    jlink.set_reset_pin_low()\n    time.sleep(1)\n\n    # 5. Send a SWD Request to clear any errors.\n    request = swd.WriteRequest(0x0, False, unlock_kinetis_abort_clear())\n    request.send(jlink)\n\n    # 6. Send a SWD Request to select the MDM-AP register, SELECT[31:24] = 0x01\n    request = swd.WriteRequest(0x2, False, (1 << 24))\n    request.send(jlink)\n\n    try:\n        # 7. Poll until the Flash-ready bit is set in the status register flags.\n        #    Have to read first to ensure the data is valid.\n        unlock_kinetis_read_until_ack(jlink, 0x0)\n        flags = registers.MDMAPStatusRegisterFlags()\n        flags.flash_ready = 0\n        while not flags.flash_ready:\n            flags.value = unlock_kinetis_read_until_ack(jlink, 0x0).data\n\n        # 8. System may still be secure at this point, so request a mass erase.\n        #    AP[1] bank 0, register 1 is the MDM-AP Control Register.\n        flags = registers.MDMAPControlRegisterFlags()\n        flags.flash_mass_erase = 1\n        request = swd.WriteRequest(0x1, True, flags.value)\n        request.send(jlink)\n\n        # 9. Poll the status register until the mass erase command has been\n        #    accepted.\n        unlock_kinetis_read_until_ack(jlink, 0x0)\n        flags = registers.MDMAPStatusRegisterFlags()\n        flags.flash_mass_erase_ack = 0\n        while not flags.flash_mass_erase_ack:\n            flags.value = unlock_kinetis_read_until_ack(jlink, 0x0).data\n\n        # 10. Poll the control register until the ``flash_mass_erase`` bit is\n        #     cleared, which is done automatically when the mass erase\n        #     finishes.\n        unlock_kinetis_read_until_ack(jlink, 0x1)\n        flags = registers.MDMAPControlRegisterFlags()\n        flags.flash_mass_erase = 1\n        while flags.flash_mass_erase:\n            flags.value = unlock_kinetis_read_until_ack(jlink, 0x1).data\n\n    except KinetisException as e:\n        jlink.set_reset_pin_high()\n        return False\n\n    jlink.set_reset_pin_high()\n    time.sleep(1)\n\n    jlink.reset()\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unlock_kinetis(jlink):\n    if not jlink.connected():\n        raise ValueError('No target to unlock.')\n\n    method = UNLOCK_METHODS.get(jlink.tif, None)\n    if method is None:\n        raise NotImplementedError('Unsupported target interface for unlock.')\n\n    return method(jlink)", "response": "Unlock for Freescale Kinetis K40 or K60 device."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serial_wire_viewer(jlink_serial, device):\n    buf = StringIO.StringIO()\n    jlink = pylink.JLink(log=buf.write, detailed_log=buf.write)\n    jlink.open(serial_no=jlink_serial)\n\n    # Use Serial Wire Debug as the target interface.  Need this in order to use\n    # Serial Wire Output.\n    jlink.set_tif(pylink.enums.JLinkInterfaces.SWD)\n    jlink.connect(device, verbose=True)\n    jlink.coresight_configure()\n    jlink.set_reset_strategy(pylink.enums.JLinkResetStrategyCortexM3.RESETPIN)\n\n    # Have to halt the CPU before getitng its speed.\n    jlink.reset()\n    jlink.halt()\n\n    cpu_speed = jlink.cpu_speed()\n    swo_speed = jlink.swo_supported_speeds(cpu_speed, 10)[0]\n\n    # Start logging serial wire output.\n    jlink.swo_start(swo_speed)\n    jlink.swo_flush()\n\n    # Output the information about the program.\n    sys.stdout.write('Serial Wire Viewer\\n')\n    sys.stdout.write('Press Ctrl-C to Exit\\n')\n    sys.stdout.write('Reading data from port 0:\\n\\n')\n\n    # Reset the core without halting so that it runs.\n    jlink.reset(ms=10, halt=False)\n\n    # Use the `try` loop to catch a keyboard interrupt in order to stop logging\n    # serial wire output.\n    try:\n        while True:\n            # Check for any bytes in the stream.\n            num_bytes = jlink.swo_num_bytes()\n\n            if num_bytes == 0:\n                # If no bytes exist, sleep for a bit before trying again.\n                time.sleep(1)\n                continue\n\n            data = jlink.swo_read_stimulus(0, num_bytes)\n            sys.stdout.write(''.join(map(chr, data)))\n            sys.stdout.flush()\n    except KeyboardInterrupt:\n        pass\n\n    sys.stdout.write('\\n')\n\n    # Stop logging serial wire output.\n    jlink.swo_stop()\n\n    return 0", "response": "A function that opens a serial wire viewer and returns a new object that can be used to display the information about the program."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef minimum_required(version):\n        def _minimum_required(func):\n            \"\"\"Internal decorator that wraps around the given function.\n\n            Args:\n              func (function): function being decorated\n\n            Returns:\n              The wrapper unction.\n            \"\"\"\n            @functools.wraps(func)\n            def wrapper(self, *args, **kwargs):\n                \"\"\"Wrapper function to compare the DLL's SDK version.\n\n                Args:\n                  self (JLink): the ``JLink`` instance\n                  args (list): list of arguments to pass to ``func``\n                  kwargs (dict): key-word arguments dict to pass to ``func``\n\n                Returns:\n                  The return value of the wrapped function.\n\n                Raises:\n                  JLinkException: if the DLL's version is less than ``version``.\n                \"\"\"\n                if list(self.version) < list(version):\n                    raise errors.JLinkException('Version %s required.' % version)\n                return func(self, *args, **kwargs)\n            return wrapper\n        return _minimum_required", "response": "Decorator to specify the minimum SDK version required."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef open_required(func):\n        @functools.wraps(func)\n        def wrapper(self, *args, **kwargs):\n            \"\"\"Wrapper function to check that the given ``JLink`` has been\n            opened.\n\n            Args:\n              self (JLink): the ``JLink`` instance\n              args: list of arguments to pass to the wrapped function\n              kwargs: key-word arguments dict to pass to the wrapped function\n\n            Returns:\n              The return value of the wrapped function.\n\n            Raises:\n              JLinkException: if the J-Link DLL is not open or the J-Link is\n                  disconnected.\n            \"\"\"\n            if not self.opened():\n                raise errors.JLinkException('J-Link DLL is not open.')\n            elif not self.connected():\n                raise errors.JLinkException('J-Link connection has been lost.')\n            return func(self, *args, **kwargs)\n        return wrapper", "response": "Decorator to specify that the J - Link DLL is open and that the connection is established."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef log_handler(self, handler):\n        if not self.opened():\n            handler = handler or util.noop\n            self._log_handler = enums.JLinkFunctions.LOG_PROTOTYPE(handler)\n            self._dll.JLINKARM_EnableLog(self._log_handler)", "response": "Setter for the log handler function."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef detailed_log_handler(self, handler):\n        if not self.opened():\n            handler = handler or util.noop\n            self._detailed_log_handler = enums.JLinkFunctions.LOG_PROTOTYPE(handler)\n            self._dll.JLINKARM_EnableLogCom(self._detailed_log_handler)", "response": "Setter for the detailed log handler function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef error_handler(self, handler):\n        if not self.opened():\n            handler = handler or util.noop\n            self._error_handler = enums.JLinkFunctions.LOG_PROTOTYPE(handler)\n            self._dll.JLINKARM_SetErrorOutHandler(self._error_handler)", "response": "Setter for the error handler function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef warning_handler(self, handler):\n        if not self.opened():\n            handler = handler or util.noop\n            self._warning_handler = enums.JLinkFunctions.LOG_PROTOTYPE(handler)\n            self._dll.JLINKARM_SetWarnOutHandler(self._warning_handler)", "response": "Setter for the warning handler function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connected_emulators(self, host=enums.JLinkHost.USB):\n        res = self._dll.JLINKARM_EMU_GetList(host, 0, 0)\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        num_devices = res\n        info = (structs.JLinkConnectInfo * num_devices)()\n        num_found = self._dll.JLINKARM_EMU_GetList(host, info, num_devices)\n        if num_found < 0:\n            raise errors.JLinkException(num_found)\n\n        return list(info)[:num_found]", "response": "Returns a list of all the connected emulators."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving the information about the requested device.", "response": "def supported_device(self, index=0):\n        \"\"\"Gets the device at the given ``index``.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          index (int): the index of the device whose information to get\n\n        Returns:\n          A ``JLinkDeviceInfo`` describing the requested device.\n\n        Raises:\n          ValueError: if index is less than 0 or >= supported device count.\n        \"\"\"\n        if not util.is_natural(index) or index >= self.num_supported_devices():\n            raise ValueError('Invalid index.')\n\n        info = structs.JLinkDeviceInfo()\n\n        result = self._dll.JLINKARM_DEVICE_GetInfo(index, ctypes.byref(info))\n        return info"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconnecting to the J - Link emulator and returns a new instance of the class.", "response": "def open(self, serial_no=None, ip_addr=None):\n        \"\"\"Connects to the J-Link emulator (defaults to USB).\n\n        If ``serial_no`` and ``ip_addr`` are both given, this function will\n        connect to the J-Link over TCP/IP.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          serial_no (int): serial number of the J-Link\n          ip_addr (str): IP address and port of the J-Link (e.g. 192.168.1.1:80)\n\n        Returns:\n          ``None``\n\n        Raises:\n          JLinkException: if fails to open (i.e. if device is unplugged)\n          TypeError: if ``serial_no`` is present, but not ``int`` coercible.\n          AttributeError: if ``serial_no`` and ``ip_addr`` are both ``None``.\n        \"\"\"\n\n        # For some reason, the J-Link driver complains if this isn't called\n        # first (may have something to do with it trying to establish a\n        # connection).  Without this call, it will log an error stating\n        #        NET_WriteRead(): USB communication not locked\n        #        PID0017A8C (): Lock count error (decrement)\n        self.close()\n\n        if ip_addr is not None:\n            addr, port = ip_addr.rsplit(':', 1)\n            if serial_no is None:\n                result = self._dll.JLINKARM_SelectIP(addr.encode(), int(port))\n                if result == 1:\n                    raise errors.JLinkException('Could not connect to emulator at %s.' % ip_addr)\n            else:\n                # Note: No return code when selecting IP by serial number.\n                self._dll.JLINKARM_EMU_SelectIPBySN(int(serial_no))\n\n        elif serial_no is not None:\n            result = self._dll.JLINKARM_EMU_SelectByUSBSN(int(serial_no))\n            if result < 0:\n                raise errors.JLinkException('No emulator with serial number %s found.' % serial_no)\n\n        else:\n            # The original method of connecting to USB0-3 via\n            # JLINKARM_SelectUSB has been obsolesced, however its use is\n            # preserved here to simplify workflows using one emulator:\n            result = self._dll.JLINKARM_SelectUSB(0)\n            if result != 0:\n                raise errors.JlinkException('Could not connect to default emulator.')\n\n        # Acquire the lock for the J-Link being opened only if the serial\n        # number was passed in, otherwise skip it here.  Note that the lock\n        # must be acquired before calling 'JLINKARM_OpenEx()', otherwise the\n        # call will fail on Windows.\n        if serial_no is not None:\n            self._lock = jlock.JLock(serial_no)\n            if not self._lock.acquire():\n                raise errors.JLinkException('J-Link is already open.')\n\n        result = self._dll.JLINKARM_OpenEx(self.log_handler, self.error_handler)\n        result = ctypes.cast(result, ctypes.c_char_p).value\n        if result is not None:\n            raise errors.JLinkException(result.decode())\n\n        # Configuration of the J-Link DLL.  These are configuration steps that\n        # have to be done after 'open()'.  The unsecure hook is only supported\n        # on versions greater than V4.98a.\n        unsecure_hook = self._unsecure_hook\n        if unsecure_hook is not None and hasattr(self._dll, 'JLINK_SetHookUnsecureDialog'):\n            func = enums.JLinkFunctions.UNSECURE_HOOK_PROTOTYPE(unsecure_hook)\n            self._dll.JLINK_SetHookUnsecureDialog(func)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconnect to the J - Link emulator over SEGGER tunnel.", "response": "def open_tunnel(self, serial_no, port=19020):\n        \"\"\"Connects to the J-Link emulator (over SEGGER tunnel).\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          serial_no (int): serial number of the J-Link\n          port (int): optional port number (default to 19020).\n\n        Returns:\n          ``None``\n        \"\"\"\n        return self.open(ip_addr='tunnel:' + str(serial_no) + ':' + str(port))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclose the open J - Link.", "response": "def close(self):\n        \"\"\"Closes the open J-Link.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          ``None``\n\n        Raises:\n          JLinkException: if there is no connected JLink.\n        \"\"\"\n        self._dll.JLINKARM_Close()\n\n        if self._lock is not None:\n            del self._lock\n            self._lock = None\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sync_firmware(self):\n        serial_no = self.serial_number\n\n        if self.firmware_newer():\n            # The J-Link's firmware is newer than the one compatible with the\n            # DLL (though there are promises of backwards compatibility), so\n            # perform a downgrade.\n            try:\n                # This may throw an exception on older versions of the J-Link\n                # software due to the software timing out after a firmware\n                # upgrade.\n                self.invalidate_firmware()\n                self.update_firmware()\n            except errors.JLinkException as e:\n                pass\n\n            res = self.open(serial_no=serial_no)\n\n            if self.firmware_newer():\n                raise errors.JLinkException('Failed to sync firmware version.')\n\n            return res\n\n        elif self.firmware_outdated():\n            # The J-Link's firmware is older than the one compatible with the\n            # DLL, so perform a firmware upgrade.\n            try:\n                # This may throw an exception on older versions of the J-Link\n                # software due to the software timing out after a firmware\n                # upgrade.\n                self.update_firmware()\n            except errors.JLinkException as e:\n                pass\n\n            if self.firmware_outdated():\n                raise errors.JLinkException('Failed to sync firmware version.')\n\n            return self.open(serial_no=serial_no)\n\n        return None", "response": "Syncs the emulator s firmware version and the DLL s firmware."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exec_command(self, cmd):\n        err_buf = (ctypes.c_char * self.MAX_BUF_SIZE)()\n        res = self._dll.JLINKARM_ExecCommand(cmd.encode(), err_buf, self.MAX_BUF_SIZE)\n        err_buf = ctypes.string_at(err_buf).decode()\n\n        if len(err_buf) > 0:\n            # This is how they check for error in the documentation, so check\n            # this way as well.\n            raise errors.JLinkException(err_buf.strip())\n\n        return res", "response": "Executes the given command and returns the return code."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef jtag_configure(self, instr_regs=0, data_bits=0):\n        if not util.is_natural(instr_regs):\n            raise ValueError('IR value is not a natural number.')\n\n        if not util.is_natural(data_bits):\n            raise ValueError('Data bits is not a natural number.')\n\n        self._dll.JLINKARM_ConfigJTAG(instr_regs, data_bits)\n        return None", "response": "Configures the JTAG scan chain to determine which CPU to address."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprepare target and J - Link for CoreSight function usage.", "response": "def coresight_configure(self,\n                            ir_pre=0,\n                            dr_pre=0,\n                            ir_post=0,\n                            dr_post=0,\n                            ir_len=0,\n                            perform_tif_init=True):\n        \"\"\"Prepares target and J-Link for CoreSight function usage.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          ir_pre (int): sum of instruction register length of all JTAG devices\n            in the JTAG chain, close to TDO than the actual one, that J-Link\n            shall communicate with\n          dr_pre (int): number of JTAG devices in the JTAG chain, closer to TDO\n            than the actual one, that J-Link shall communicate with\n          ir_post (int): sum of instruction register length of all JTAG devices\n            in the JTAG chain, following the actual one, that J-Link shall\n            communicate with\n          dr_post (int): Number of JTAG devices in the JTAG chain, following\n            the actual one, J-Link shall communicate with\n          ir_len (int): instruction register length of the actual device that\n            J-Link shall communicate with\n          perform_tif_init (bool): if ``False``, then do not output switching\n            sequence on completion\n\n        Returns:\n          ``None``\n\n        Note:\n          This must be called before calling ``coresight_read()`` or\n          ``coresight_write()``.\n        \"\"\"\n        if self.tif == enums.JLinkInterfaces.SWD:\n            # No special setup is needed for SWD, just need to output the\n            # switching sequence.\n            res = self._dll.JLINKARM_CORESIGHT_Configure('')\n            if res < 0:\n                raise errors.JLinkException(res)\n\n            return None\n\n        # JTAG requires more setup than SWD.\n        config_string = 'IRPre=%s;DRPre=%s;IRPost=%s;DRPost=%s;IRLenDevice=%s;'\n        config_string = config_string % (ir_pre, dr_pre, ir_post, dr_post, ir_len)\n\n        if not perform_tif_init:\n            config_string = config_string + ('PerformTIFInit=0;')\n\n        res = self._dll.JLINKARM_CORESIGHT_Configure(config_string.encode())\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconnecting the J - Link to its target.", "response": "def connect(self, chip_name, speed='auto', verbose=False):\n        \"\"\"Connects the J-Link to its target.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          chip_name (str): target chip name\n          speed (int): connection speed, one of ``{5-12000, 'auto', 'adaptive'}``\n          verbose (bool): boolean indicating if connection should be verbose in logging\n\n        Returns:\n          ``None``\n\n        Raises:\n          JLinkException: if connection fails to establish.\n          TypeError: if given speed is invalid\n        \"\"\"\n\n        if verbose:\n            self.exec_command('EnableRemarks = 1')\n\n        # This is weird but is currently the only way to specify what the\n        # target is to the J-Link.\n        self.exec_command('Device = %s' % chip_name)\n\n        # Need to select target interface speed here, so the J-Link knows what\n        # speed to use to establish target communication.\n        if speed == 'auto':\n            self.set_speed(auto=True)\n        elif speed == 'adaptive':\n            self.set_speed(adaptive=True)\n        else:\n            self.set_speed(speed)\n\n        result = self._dll.JLINKARM_Connect()\n        if result < 0:\n            raise errors.JLinkException(result)\n\n        try:\n            # Issue a no-op command after connect. This has to be in a try-catch.\n            self.halted()\n        except errors.JLinkException:\n            pass\n\n        # Determine which device we are.  This is essential for using methods\n        # like 'unlock' or 'lock'.\n        for index in range(self.num_supported_devices()):\n            device = self.supported_device(index)\n            if device.name.lower() == chip_name.lower():\n                self._device = device\n                break\n        else:\n            raise errors.JLinkException('Unsupported device was connected to.')\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compile_date(self):\n        result = self._dll.JLINKARM_GetCompileDateTime()\n        return ctypes.cast(result, ctypes.c_char_p).value.decode()", "response": "Returns a string specifying the date and time at which the DLL was compiled."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef version(self):\n        version = int(self._dll.JLINKARM_GetDLLVersion())\n        major = version / 10000\n        minor = (version / 100) % 100\n        rev = version % 100\n        rev = '' if rev == 0 else chr(rev + ord('a') - 1)\n        return '%d.%02d%s' % (major, minor, rev)", "response": "Returns the device s version as a string of the format M. mr where M is major number m is minor number r is revision number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the DLL s compatible J - Link firmware version.", "response": "def compatible_firmware_version(self):\n        \"\"\"Returns the DLL's compatible J-Link firmware version.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          The firmware version of the J-Link that the DLL is compatible\n          with.\n\n        Raises:\n          JLinkException: on error.\n        \"\"\"\n        identifier = self.firmware_version.split('compiled')[0]\n        buf_size = self.MAX_BUF_SIZE\n        buf = (ctypes.c_char * buf_size)()\n        res = self._dll.JLINKARM_GetEmbeddedFWString(identifier.encode(), buf, buf_size)\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return ctypes.string_at(buf).decode()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if the J - Link s firmware version is older than the one supported by the DLL.", "response": "def firmware_outdated(self):\n        \"\"\"Returns whether the J-Link's firmware version is older than the one\n        that the DLL is compatible with.\n\n        Note:\n          This is not the same as calling ``not jlink.firmware_newer()``.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          ``True`` if the J-Link's firmware is older than the one supported by\n          the DLL, otherwise ``False``.\n        \"\"\"\n        datefmt = ' %b %d %Y %H:%M:%S'\n\n        compat_date = self.compatible_firmware_version.split('compiled')[1]\n        compat_date = datetime.datetime.strptime(compat_date, datefmt)\n\n        fw_date = self.firmware_version.split('compiled')[1]\n        fw_date = datetime.datetime.strptime(fw_date, datefmt)\n        return (compat_date > fw_date)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of 32 integer values corresponding to the bitfields that are set in the target.", "response": "def hardware_info(self, mask=0xFFFFFFFF):\n        \"\"\"Returns a list of 32 integer values corresponding to the bitfields\n        specifying the power consumption of the target.\n\n        The values returned by this function only have significance if the\n        J-Link is powering the target.\n\n        The words, indexed, have the following significance:\n          0. If ``1``, target is powered via J-Link.\n          1. Overcurrent bitfield:\n             0: No overcurrent.\n             1: Overcurrent happened.  2ms @ 3000mA\n             2: Overcurrent happened.  10ms @ 1000mA\n             3: Overcurrent happened.  40ms @ 400mA\n          2. Power consumption of target (mA).\n          3. Peak of target power consumption (mA).\n          4. Peak of target power consumption during J-Link operation (mA).\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          mask (int): bit mask to decide which hardware information words are\n            returned (defaults to all the words).\n\n        Returns:\n          List of bitfields specifying different states based on their index\n          within the list and their value.\n\n        Raises:\n          JLinkException: on hardware error.\n        \"\"\"\n        buf = (ctypes.c_uint32 * 32)()\n        res = self._dll.JLINKARM_GetHWInfo(mask, ctypes.byref(buf))\n        if res != 0:\n            raise errors.JLinkException(res)\n        return list(buf)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving and returns the hardware status of the specified instance.", "response": "def hardware_status(self):\n        \"\"\"Retrieves and returns the hardware status.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          A ``JLinkHardwareStatus`` describing the J-Link hardware.\n        \"\"\"\n        stat = structs.JLinkHardwareStatus()\n        res = self._dll.JLINKARM_GetHWStatus(ctypes.byref(stat))\n        if res == 1:\n            raise errors.JLinkException('Error in reading hardware status.')\n        return stat"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the hardware version of the connected J - Link as a string.", "response": "def hardware_version(self):\n        \"\"\"Returns the hardware version of the connected J-Link as a\n        major.minor string.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          Hardware version string.\n        \"\"\"\n        version = self._dll.JLINKARM_GetHardwareVersion()\n        major = version / 10000 % 100\n        minor = version / 100 % 100\n        return '%d.%02d' % (major, minor)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a string that contains the current connected J - Link s firmware version.", "response": "def firmware_version(self):\n        \"\"\"Returns a firmware identification string of the connected J-Link.\n\n        It consists of the following:\n          - Product Name (e.g. J-Link)\n          - The string: compiled\n          - Compile data and time.\n          - Optional additional information.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          Firmware identification string.\n        \"\"\"\n        buf = (ctypes.c_char * self.MAX_BUF_SIZE)()\n        self._dll.JLINKARM_GetFirmwareString(buf, self.MAX_BUF_SIZE)\n        return ctypes.string_at(buf).decode()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the extended capabilities of the connected emulator as a list.", "response": "def extended_capabilities(self):\n        \"\"\"Gets the capabilities of the connected emulator as a list.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          List of 32 integers which define the extended capabilities based on\n          their value and index within the list.\n        \"\"\"\n        buf = (ctypes.c_uint8 * 32)()\n        self._dll.JLINKARM_GetEmuCapsEx(buf, 32)\n        return list(buf)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of the J - Link embedded features.", "response": "def features(self):\n        \"\"\"Returns a list of the J-Link embedded features.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          A list of strings, each a feature.  Example:\n          ``[ 'RDI', 'FlashBP', 'FlashDL', 'JFlash', 'GDB' ]``\n        \"\"\"\n        buf = (ctypes.c_char * self.MAX_BUF_SIZE)()\n        self._dll.JLINKARM_GetFeatureString(buf)\n\n        result = ctypes.string_at(buf).decode().strip()\n        if len(result) == 0:\n            return list()\n\n        return result.split(', ')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef product_name(self):\n        buf = (ctypes.c_char * self.MAX_BUF_SIZE)()\n        self._dll.JLINKARM_EMU_GetProductName(buf, self.MAX_BUF_SIZE)\n        return ctypes.string_at(buf).decode()", "response": "Returns the product name of the connected J - Link."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves and returns the OEM string of the connected J - Link.", "response": "def oem(self):\n        \"\"\"Retrieves and returns the OEM string of the connected J-Link.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          The string of the OEM.  If this is an original SEGGER product, then\n          ``None`` is returned instead.\n\n        Raises:\n          JLinkException: on hardware error.\n        \"\"\"\n        buf = (ctypes.c_char * self.MAX_BUF_SIZE)()\n        res = self._dll.JLINKARM_GetOEMString(ctypes.byref(buf))\n        if res != 0:\n            raise errors.JLinkException('Failed to grab OEM string.')\n\n        oem = ctypes.string_at(buf).decode()\n        if len(oem) == 0:\n            # In the case that the product is an original SEGGER product, then\n            # the OEM string is the empty string, so there is no OEM.\n            return None\n\n        return oem"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the speed of the JTAG communication with the ARM core.", "response": "def set_speed(self, speed=None, auto=False, adaptive=False):\n        \"\"\"Sets the speed of the JTAG communication with the ARM core.\n\n        If no arguments are present, automatically detects speed.\n\n        If a ``speed`` is provided, the speed must be no larger than\n        ``JLink.MAX_JTAG_SPEED`` and no smaller than ``JLink.MIN_JTAG_SPEED``.\n        The given ``speed`` can also not be ``JLink.INVALID_JTAG_SPEED``.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          speed (int): the speed in kHz to set the communication at\n          auto (bool): automatically detect correct speed\n          adaptive (bool): select adaptive clocking as JTAG speed\n\n        Returns:\n          ``None``\n\n        Raises:\n          TypeError: if given speed is not a natural number.\n          ValueError: if given speed is too high, too low, or invalid.\n        \"\"\"\n        if speed is None:\n            speed = 0\n        elif not util.is_natural(speed):\n            raise TypeError('Expected positive number for speed, given %s.' % speed)\n        elif speed > self.MAX_JTAG_SPEED:\n            raise ValueError('Given speed exceeds max speed of %d.' % self.MAX_JTAG_SPEED)\n        elif speed < self.MIN_JTAG_SPEED:\n            raise ValueError('Given speed is too slow.  Minimum is %d.' % self.MIN_JTAG_SPEED)\n\n        if auto:\n            speed = speed | self.AUTO_JTAG_SPEED\n\n        if adaptive:\n            speed = speed | self.ADAPTIVE_JTAG_SPEED\n\n        self._dll.JLINKARM_SetSpeed(speed)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve information about the supported target interface speeds.", "response": "def speed_info(self):\n        \"\"\"Retrieves information about supported target interface speeds.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          The ``JLinkSpeedInfo`` instance describing the supported target\n          interface speeds.\n        \"\"\"\n        speed_info = structs.JLinkSpeedInfo()\n        self._dll.JLINKARM_GetSpeedInfo(ctypes.byref(speed_info))\n        return speed_info"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a string of the contents of the built - in licenses of the J - Link has.", "response": "def licenses(self):\n        \"\"\"Returns a string of the built-in licenses the J-Link has.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          String of the contents of the built-in licenses the J-Link has.\n        \"\"\"\n        buf_size = self.MAX_BUF_SIZE\n        buf = (ctypes.c_char * buf_size)()\n        res = self._dll.JLINK_GetAvailableLicense(buf, buf_size)\n        if res < 0:\n            raise errors.JLinkException(res)\n        return ctypes.string_at(buf).decode()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string of the contents of the custom licenses of the J - Link has.", "response": "def custom_licenses(self):\n        \"\"\"Returns a string of the installed licenses the J-Link has.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          String of the contents of the custom licenses the J-Link has.\n        \"\"\"\n        buf = (ctypes.c_char * self.MAX_BUF_SIZE)()\n        result = self._dll.JLINK_EMU_GetLicenses(buf, self.MAX_BUF_SIZE)\n        if result < 0:\n            raise errors.JLinkException(result)\n        return ctypes.string_at(buf).decode()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd the given contents as a new custom license to the J - Link.", "response": "def add_license(self, contents):\n        \"\"\"Adds the given ``contents`` as a new custom license to the J-Link.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          contents: the string contents of the new custom license\n\n        Returns:\n          ``True`` if license was added, ``False`` if license already existed.\n\n        Raises:\n          JLinkException: if the write fails.\n\n        Note:\n          J-Link V9 and J-Link ULTRA/PRO V4 have 336 Bytes of memory for\n          licenses, while older versions of 80 bytes.\n        \"\"\"\n        buf_size = len(contents)\n        buf = (ctypes.c_char * (buf_size + 1))(*contents.encode())\n\n        res = self._dll.JLINK_EMU_AddLicense(buf)\n\n        if res == -1:\n            raise errors.JLinkException('Unspecified error.')\n        elif res == -2:\n            raise errors.JLinkException('Failed to read/write license area.')\n        elif res == -3:\n            raise errors.JLinkException('J-Link out of space.')\n\n        return (res == 0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a bitmask of the target interfaces supported by this instance.", "response": "def supported_tifs(self):\n        \"\"\"Returns a bitmask of the supported target interfaces.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          Bitfield specifying which target interfaces are supported.\n        \"\"\"\n        buf = ctypes.c_uint32()\n        self._dll.JLINKARM_TIF_GetAvailable(ctypes.byref(buf))\n        return buf.value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_tif(self, interface):\n        if not ((1 << interface) & self.supported_tifs()):\n            raise errors.JLinkException('Unsupported target interface: %s' % interface)\n\n        # The return code here is actually *NOT* the previous set interface, it\n        # is ``0`` on success, otherwise ``1``.\n        res = self._dll.JLINKARM_TIF_Select(interface)\n        if res != 0:\n            return False\n\n        self._tif = interface\n        return True", "response": "Selects the specified target interface."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef gpio_properties(self):\n        res = self._dll.JLINK_EMU_GPIO_GetProps(0, 0)\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        num_props = res\n        buf = (structs.JLinkGPIODescriptor * num_props)()\n        res = self._dll.JLINK_EMU_GPIO_GetProps(ctypes.byref(buf), num_props)\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return list(buf)", "response": "Returns the properties of the user - controllable GPIOs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gpio_get(self, pins=None):\n        if pins is None:\n            pins = range(4)\n\n        size = len(pins)\n        indices = (ctypes.c_uint8 * size)(*pins)\n        statuses = (ctypes.c_uint8 * size)()\n        result = self._dll.JLINK_EMU_GPIO_GetState(ctypes.byref(indices),\n                                                   ctypes.byref(statuses),\n                                                   size)\n        if result < 0:\n            raise errors.JLinkException(result)\n\n        return list(statuses)", "response": "Returns a list of states for the given GPIO pins."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the state of one or more user - controllable GPIOs.", "response": "def gpio_set(self, pins, states):\n        \"\"\"Sets the state for one or more user-controllable GPIOs.\n\n        For each of the given pins, sets the the corresponding state based on\n        the index.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          pins (list): list of GPIO indices\n          states (list): list of states to set\n\n        Returns:\n          A list of updated states.\n\n        Raises:\n          JLinkException: on error.\n          ValueError: if ``len(pins) != len(states)``\n        \"\"\"\n        if len(pins) != len(states):\n            raise ValueError('Length mismatch between pins and states.')\n\n        size = len(pins)\n        indices = (ctypes.c_uint8 * size)(*pins)\n        states = (ctypes.c_uint8 * size)(*states)\n        result_states = (ctypes.c_uint8 * size)()\n        result = self._dll.JLINK_EMU_GPIO_SetState(ctypes.byref(indices),\n                                                   ctypes.byref(states),\n                                                   ctypes.byref(result_states),\n                                                   size)\n        if result < 0:\n            raise errors.JLinkException(result)\n\n        return list(result_states)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nunlocks the device connected to the J - Link.", "response": "def unlock(self):\n        \"\"\"Unlocks the device connected to the J-Link.\n\n        Unlocking a device allows for access to read/writing memory, as well as\n        flash programming.\n\n        Note:\n          Unlock is not supported on all devices.\n\n        Supported Devices:\n          Kinetis\n\n        Returns:\n          ``True``.\n\n        Raises:\n          JLinkException: if the device fails to unlock.\n        \"\"\"\n        if not unlockers.unlock(self, self._device.manufacturer):\n            raise errors.JLinkException('Failed to unlock device.')\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef erase(self):\n        try:\n            # This has to be in a try-catch, as the device may not be in a\n            # state where it can halt, but we still want to try and erase.\n            if not self.halted():\n                self.halt()\n        except errors.JLinkException:\n            # Can't halt, so just continue to erasing.\n            pass\n\n        res = self._dll.JLINK_EraseChip()\n        if res < 0:\n            raise errors.JLinkEraseException(res)\n\n        return res", "response": "Erases the flash contents of the target device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flash(self, data, addr, on_progress=None, power_on=False, flags=0):\n        if flags != 0:\n            raise errors.JLinkException('Flags are reserved for future use.')\n\n        if on_progress is not None:\n            # Set the function to be called on flash programming progress.\n            func = enums.JLinkFunctions.FLASH_PROGRESS_PROTOTYPE(on_progress)\n            self._dll.JLINK_SetFlashProgProgressCallback(func)\n        else:\n            self._dll.JLINK_SetFlashProgProgressCallback(0)\n\n        # First power on the device.\n        if power_on:\n            self.power_on()\n\n        try:\n            # Stop the target before flashing.  This is required to be in a\n            # try-catch as the 'halted()' check may fail with an exception.\n            if not self.halted():\n                self.halt()\n        except errors.JLinkException:\n            pass\n\n        res = self.flash_write(addr, data, flags=flags)\n\n        return res", "response": "Writes the given data to the target device."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef flash_file(self, path, addr, on_progress=None, power_on=False):\n        if on_progress is not None:\n            # Set the function to be called on flash programming progress.\n            func = enums.JLinkFunctions.FLASH_PROGRESS_PROTOTYPE(on_progress)\n            self._dll.JLINK_SetFlashProgProgressCallback(func)\n        else:\n            self._dll.JLINK_SetFlashProgProgressCallback(0)\n\n        # First power on the device.\n        if power_on:\n            self.power_on()\n\n        try:\n            # Stop the target before flashing.  This is required to be in a\n            # try-catch as the 'halted()' check may fail with an exception.\n            if not self.halted():\n                self.halt()\n        except errors.JLinkException:\n            pass\n\n        # Program the target.\n        bytes_flashed = self._dll.JLINK_DownloadFile(path.encode(), addr)\n        if bytes_flashed < 0:\n            raise errors.JLinkFlashException(bytes_flashed)\n\n        return bytes_flashed", "response": "Writes the contents of a file to the target device."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresets the target and toggles the RESET and the TRST pins.", "response": "def reset(self, ms=0, halt=True):\n        \"\"\"Resets the target.\n\n        This method resets the target, and by default toggles the RESET and\n        TRST pins.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          ms (int): Amount of milliseconds to delay after reset (default: 0)\n          halt (bool): if the CPU should halt after reset (default: True)\n\n        Returns:\n          Number of bytes read.\n        \"\"\"\n        self._dll.JLINKARM_SetResetDelay(ms)\n\n        res = self._dll.JLINKARM_Reset()\n        if res < 0:\n            raise errors.JLinkException(res)\n        elif not halt:\n            self._dll.JLINKARM_Go()\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrestart the CPU core and simulates instructions.", "response": "def restart(self, num_instructions=0, skip_breakpoints=False):\n        \"\"\"Restarts the CPU core and simulates/emulates instructions.\n\n        Note:\n          This is a no-op if the CPU isn't halted.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          num_instructions (int): number of instructions to simulate, defaults\n            to zero\n          skip_breakpoints (bool): skip current breakpoint (default: ``False``)\n\n        Returns:\n          ``True`` if device was restarted, otherwise ``False``.\n\n        Raises:\n          ValueError: if instruction count is not a natural number.\n        \"\"\"\n        if not util.is_natural(num_instructions):\n            raise ValueError('Invalid instruction count: %s.' % num_instructions)\n\n        if not self.halted():\n            return False\n\n        flags = 0\n        if skip_breakpoints:\n            flags = flags | enums.JLinkFlags.GO_OVERSTEP_BP\n\n        self._dll.JLINKARM_GoEx(num_instructions, flags)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef halt(self):\n        res = int(self._dll.JLINKARM_Halt())\n        if res == 0:\n            time.sleep(1)\n            return True\n        return False", "response": "Halts the CPU Core."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the CPU core was halted.", "response": "def halted(self):\n        \"\"\"Returns whether the CPU core was halted.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          ``True`` if the CPU core is halted, otherwise ``False``.\n\n        Raises:\n          JLinkException: on device errors.\n        \"\"\"\n        result = int(self._dll.JLINKARM_IsHalted())\n        if result < 0:\n            raise errors.JLinkException(result)\n\n        return (result > 0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef core_name(self):\n        buf_size = self.MAX_BUF_SIZE\n        buf = (ctypes.c_char * buf_size)()\n        self._dll.JLINKARM_Core2CoreName(self.core_cpu(), buf, buf_size)\n        return ctypes.string_at(buf).decode()", "response": "Returns the name of the target ARM core."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scan_chain_len(self, scan_chain):\n        res = self._dll.JLINKARM_MeasureSCLen(scan_chain)\n        if res < 0:\n            raise errors.JLinkException(res)\n        return res", "response": "Retrieves and returns the number of bits in the specified scan chain."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of the indices for the CPU registers.", "response": "def register_list(self):\n        \"\"\"Returns a list of the indices for the CPU registers.\n\n        The returned indices can be used to read the register content or grab\n        the register name.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          List of registers.\n        \"\"\"\n        num_items = self.MAX_NUM_CPU_REGISTERS\n        buf = (ctypes.c_uint32 * num_items)()\n        num_regs = self._dll.JLINKARM_GetRegisterList(buf, num_items)\n        return buf[:num_regs]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_name(self, register_index):\n        result = self._dll.JLINKARM_GetRegisterName(register_index)\n        return ctypes.cast(result, ctypes.c_char_p).value.decode()", "response": "Retrives and returns the name of an ARM CPU register."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cpu_speed(self, silent=False):\n        res = self._dll.JLINKARM_MeasureCPUSpeedEx(-1, 1, int(silent))\n        if res < 0:\n            raise errors.JLinkException(res)\n        return res", "response": "Retrieves the CPU speed of the target."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the reasons that the CPU was halted.", "response": "def cpu_halt_reasons(self):\n        \"\"\"Retrives the reasons that the CPU was halted.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          A list of ``JLInkMOEInfo`` instances specifying the reasons for which\n          the CPU was halted.  This list may be empty in the case that the CPU\n          is not halted.\n\n        Raises:\n          JLinkException: on hardware error.\n        \"\"\"\n        buf_size = self.MAX_NUM_MOES\n        buf = (structs.JLinkMOEInfo * buf_size)()\n        num_reasons = self._dll.JLINKARM_GetMOEs(buf, buf_size)\n        if num_reasons < 0:\n            raise errors.JLinkException(num_reasons)\n\n        return list(buf)[:num_reasons]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends data via JTAG.", "response": "def jtag_send(self, tms, tdi, num_bits):\n        \"\"\"Sends data via JTAG.\n\n        Sends data via JTAG on the rising clock edge, TCK.  At on each rising\n        clock edge, on bit is transferred in from TDI and out to TDO.  The\n        clock uses the TMS to step through the standard JTAG state machine.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          tms (int): used to determine the state transitions for the Test\n            Access Port (TAP) controller from its current state\n          tdi (int): input data to be transferred in from TDI to TDO\n          num_bits (int): a number in the range ``[1, 32]`` inclusively\n            specifying the number of meaningful bits in the ``tms`` and\n            ``tdi`` parameters for the purpose of extracting state and data\n            information\n\n        Returns:\n          ``None``\n\n        Raises:\n          ValueError: if ``num_bits < 1`` or ``num_bits > 32``.\n\n        See Also:\n          `JTAG Technical Overview <https://www.xjtag.com/about-jtag/jtag-a-technical-overview>`_.\n        \"\"\"\n        if not util.is_natural(num_bits) or num_bits <= 0 or num_bits > 32:\n            raise ValueError('Number of bits must be >= 1 and <= 32.')\n        self._dll.JLINKARM_StoreBits(tms, tdi, num_bits)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading a unit of 8 bits from the input buffer.", "response": "def swd_read8(self, offset):\n        \"\"\"Gets a unit of ``8`` bits from the input buffer.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          offset (int): the offset (in bits) from which to start reading\n\n        Returns:\n          The integer read from the input buffer.\n        \"\"\"\n        value = self._dll.JLINK_SWD_GetU8(offset)\n        return ctypes.c_uint8(value).value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads a unit of 16 bits from the input buffer.", "response": "def swd_read16(self, offset):\n        \"\"\"Gets a unit of ``16`` bits from the input buffer.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          offset (int): the offset (in bits) from which to start reading\n\n        Returns:\n          The integer read from the input buffer.\n        \"\"\"\n        value = self._dll.JLINK_SWD_GetU16(offset)\n        return ctypes.c_uint16(value).value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a unit of 32 bits from the input buffer.", "response": "def swd_read32(self, offset):\n        \"\"\"Gets a unit of ``32`` bits from the input buffer.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          offset (int): the offset (in bits) from which to start reading\n\n        Returns:\n          The integer read from the input buffer.\n        \"\"\"\n        value = self._dll.JLINK_SWD_GetU32(offset)\n        return ctypes.c_uint32(value).value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting bytes over the SWD.", "response": "def swd_write(self, output, value, nbits):\n        \"\"\"Writes bytes over SWD (Serial Wire Debug).\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          output (int): the output buffer offset to write to\n          value (int): the value to write to the output buffer\n          nbits (int): the number of bits needed to represent the ``output`` and\n            ``value``\n\n        Returns:\n          The bit position of the response in the input buffer.\n        \"\"\"\n        pDir = binpacker.pack(output, nbits)\n        pIn = binpacker.pack(value, nbits)\n        bitpos = self._dll.JLINK_SWD_StoreRaw(pDir, pIn, nbits)\n        if bitpos < 0:\n            raise errors.JLinkException(bitpos)\n\n        return bitpos"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef swd_sync(self, pad=False):\n        if pad:\n            self._dll.JLINK_SWD_SyncBytes()\n        else:\n            self._dll.JLINK_SWD_SyncBits()\n        return None", "response": "Allows a flush to write all data remaining in output buffers to SWD\n        device."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite data to the flash region of a device.", "response": "def flash_write(self, addr, data, nbits=None, flags=0):\n        \"\"\"Writes data to the flash region of a device.\n\n        The given number of bits, if provided, must be either ``8``, ``16``, or\n        ``32``.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          addr (int): starting flash address to write to\n          data (list): list of data units to write\n          nbits (int): number of bits to use for each unit\n\n        Returns:\n          Number of bytes written to flash.\n        \"\"\"\n        # This indicates that all data written from this point on will go into\n        # the buffer of the flashloader of the DLL.\n        self._dll.JLINKARM_BeginDownload(flags)\n\n        self.memory_write(addr, data, nbits=nbits)\n\n        # Start downloading the data into the flash memory.\n        bytes_flashed = self._dll.JLINKARM_EndDownload()\n        if bytes_flashed < 0:\n            raise errors.JLinkFlashException(bytes_flashed)\n\n        return bytes_flashed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread bytes from code memory.", "response": "def code_memory_read(self, addr, num_bytes):\n        \"\"\"Reads bytes from code memory.\n\n        Note:\n          This is similar to calling ``memory_read`` or ``memory_read8``,\n          except that this uses a cache and reads ahead.  This should be used\n          in instances where you want to read a small amount of bytes at a\n          time, and expect to always read ahead.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          addr (int): starting address from which to read\n          num_bytes (int): number of bytes to read\n\n        Returns:\n          A list of bytes read from the target.\n\n        Raises:\n          JLinkException: if memory could not be read.\n        \"\"\"\n        buf_size = num_bytes\n        buf = (ctypes.c_uint8 * buf_size)()\n        res = self._dll.JLINKARM_ReadCodeMem(addr, buf_size, buf)\n        if res < 0:\n            raise errors.JLinkException(res)\n        return list(buf)[:res]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef num_memory_zones(self):\n        count = self._dll.JLINK_GetMemZones(0, 0)\n        if count < 0:\n            raise errors.JLinkException(count)\n        return count", "response": "Returns the number of memory zones supported by the target."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of all memory zones supported by the current target.", "response": "def memory_zones(self):\n        \"\"\"Gets all memory zones supported by the current target.\n\n        Some targets support multiple memory zones.  This function provides the\n        ability to get a list of all the memory zones to facilate using the\n        memory zone routing functions.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          A list of all the memory zones as ``JLinkMemoryZone`` structures.\n\n        Raises:\n          JLinkException: on hardware errors.\n        \"\"\"\n        count = self.num_memory_zones()\n        if count == 0:\n            return list()\n\n        buf = (structs.JLinkMemoryZone * count)()\n        res = self._dll.JLINK_GetMemZones(buf, count)\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return list(buf)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads memory from a target system or specific memory zone.", "response": "def memory_read(self, addr, num_units, zone=None, nbits=None):\n        \"\"\"Reads memory from a target system or specific memory zone.\n\n        The optional ``zone`` specifies a memory zone to access to read from,\n        e.g. ``IDATA``, ``DDATA``, or ``CODE``.\n\n        The given number of bits, if provided, must be either ``8``, ``16``, or\n        ``32``.  If not provided, always reads ``num_units`` bytes.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          addr (int): start address to read from\n          num_units (int): number of units to read\n          zone (str): optional memory zone name to access\n          nbits (int): number of bits to use for each unit\n\n        Returns:\n          List of units read from the target system.\n\n        Raises:\n          JLinkException: if memory could not be read.\n          ValueError: if ``nbits`` is not ``None``, and not in ``8``, ``16``,\n            or ``32``.\n        \"\"\"\n        buf_size = num_units\n        buf = None\n        access = 0\n\n        if nbits is None:\n            buf = (ctypes.c_uint8 * buf_size)()\n            access = 0\n        elif nbits == 8:\n            buf = (ctypes.c_uint8 * buf_size)()\n            access = 1\n        elif nbits == 16:\n            buf = (ctypes.c_uint16 * buf_size)()\n            access = 2\n            buf_size = buf_size * access\n        elif nbits == 32:\n            buf = (ctypes.c_uint32 * buf_size)()\n            access = 4\n            buf_size = buf_size * access\n        else:\n            raise ValueError('Given bit size is invalid: %s' % nbits)\n\n        args = [addr, buf_size, buf, access]\n\n        method = self._dll.JLINKARM_ReadMemEx\n        if zone is not None:\n            method = self._dll.JLINKARM_ReadMemZonedEx\n            args.append(zone.encode())\n\n        units_read = method(*args)\n        if units_read < 0:\n            raise errors.JLinkReadException(units_read)\n\n        return buf[:units_read]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef memory_read8(self, addr, num_bytes, zone=None):\n        return self.memory_read(addr, num_bytes, zone=zone, nbits=8)", "response": "Reads memory from the target system in units of bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef memory_read16(self, addr, num_halfwords, zone=None):\n        return self.memory_read(addr, num_halfwords, zone=zone, nbits=16)", "response": "Reads memory from the target system in units of 16 - bits."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading memory from the target system in units of 32 - bits.", "response": "def memory_read32(self, addr, num_words, zone=None):\n        \"\"\"Reads memory from the target system in units of 32-bits.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          addr (int): start address to read from\n          num_words (int): number of words to read\n          zone (str): memory zone to read from\n\n        Returns:\n          List of words read from the target system.\n\n        Raises:\n          JLinkException: if memory could not be read\n        \"\"\"\n        return self.memory_read(addr, num_words, zone=zone, nbits=32)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef memory_read64(self, addr, num_long_words):\n        buf_size = num_long_words\n        buf = (ctypes.c_ulonglong * buf_size)()\n        units_read = self._dll.JLINKARM_ReadMemU64(addr, buf_size, buf, 0)\n        if units_read < 0:\n            raise errors.JLinkException(units_read)\n\n        return buf[:units_read]", "response": "Reads memory from the target system in units of 64 - bits."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites memory to a target system or specific memory zone.", "response": "def memory_write(self, addr, data, zone=None, nbits=None):\n        \"\"\"Writes memory to a target system or specific memory zone.\n\n        The optional ``zone`` specifies a memory zone to access to write to,\n        e.g. ``IDATA``, ``DDATA``, or ``CODE``.\n\n        The given number of bits, if provided, must be either ``8``, ``16``, or\n        ``32``.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          addr (int): start address to write to\n          data (list): list of data units to write\n          zone (str): optional memory zone name to access\n          nbits (int): number of bits to use for each unit\n\n        Returns:\n          Number of units written.\n\n        Raises:\n          JLinkException: on write hardware failure.\n          ValueError: if ``nbits`` is not ``None``, and not in ``8``, ``16`` or\n            ``32``.\n        \"\"\"\n        buf_size = len(data)\n        buf = None\n        access = 0\n\n        if nbits is None:\n            # Pack the given data into an array of 8-bit unsigned integers in\n            # order to write it successfully\n            packed_data = map(lambda d: reversed(binpacker.pack(d)), data)\n            packed_data = list(itertools.chain(*packed_data))\n\n            buf_size = len(packed_data)\n            buf = (ctypes.c_uint8 * buf_size)(*packed_data)\n\n            # Allow the access width to be chosen for us.\n            access = 0\n        elif nbits == 8:\n            buf = (ctypes.c_uint8 * buf_size)(*data)\n            access = 1\n        elif nbits == 16:\n            buf = (ctypes.c_uint16 * buf_size)(*data)\n            access = 2\n            buf_size = buf_size * access\n        elif nbits == 32:\n            buf = (ctypes.c_uint32 * buf_size)(*data)\n            access = 4\n            buf_size = buf_size * access\n        else:\n            raise ValueError('Given bit size is invalid: %s' % nbits)\n\n        args = [addr, buf_size, buf, access]\n\n        method = self._dll.JLINKARM_WriteMemEx\n        if zone is not None:\n            method = self._dll.JLINKARM_WriteMemZonedEx\n            args.append(zone.encode())\n\n        units_written = method(*args)\n        if units_written < 0:\n            raise errors.JLinkWriteException(units_written)\n\n        return units_written"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef memory_write8(self, addr, data, zone=None):\n        return self.memory_write(addr, data, zone, 8)", "response": "Writes bytes to memory of a target system."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef memory_write16(self, addr, data, zone=None):\n        return self.memory_write(addr, data, zone, 16)", "response": "Writes half - words to memory of a target system."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting words to memory of a target system.", "response": "def memory_write32(self, addr, data, zone=None):\n        \"\"\"Writes words to memory of a target system.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          addr (int): start address to write to\n          data (list): list of words to write\n          zone (str): optional memory zone to access\n\n        Returns:\n          Number of words written to target.\n\n        Raises:\n          JLinkException: on memory access error.\n        \"\"\"\n        return self.memory_write(addr, data, zone, 32)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef memory_write64(self, addr, data, zone=None):\n        words = []\n        bitmask = 0xFFFFFFFF\n        for long_word in data:\n            words.append(long_word & bitmask)          # Last 32-bits\n            words.append((long_word >> 32) & bitmask)  # First 32-bits\n        return self.memory_write32(addr, words, zone=zone)", "response": "Writes a list of 64 - bit long words to memory of a target system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_read_multiple(self, register_indices):\n        num_regs = len(register_indices)\n        buf = (ctypes.c_uint32 * num_regs)(*register_indices)\n        data = (ctypes.c_uint32 * num_regs)(0)\n\n        # TODO: For some reason, these statuses are wonky, not sure why, might\n        # be bad documentation, but they cannot be trusted at all.\n        statuses = (ctypes.c_uint8 * num_regs)(0)\n\n        res = self._dll.JLINKARM_ReadRegs(buf, data, statuses, num_regs)\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return list(data)", "response": "Retrieves the values from the registers specified in the instance\n ArcGIS instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_write(self, reg_index, value):\n        res = self._dll.JLINKARM_WriteReg(reg_index, value)\n        if res != 0:\n            raise errors.JLinkException('Error writing to register %d' % reg_index)\n        return value", "response": "Writes to an ARM register."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_write_multiple(self, register_indices, values):\n        if len(register_indices) != len(values):\n            raise ValueError('Must be an equal number of registers and values')\n\n        num_regs = len(register_indices)\n        buf = (ctypes.c_uint32 * num_regs)(*register_indices)\n        data = (ctypes.c_uint32 * num_regs)(*values)\n\n        # TODO: For some reason, these statuses are wonky, not sure why, might\n        # be bad documentation, but they cannot be trusted at all.\n        statuses = (ctypes.c_uint8 * num_regs)(0)\n\n        res = self._dll.JLINKARM_WriteRegs(buf, data, statuses, num_regs)\n        if res != 0:\n            raise errors.JLinkException(res)\n\n        return None", "response": "Writes the values to the given CPU registers."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ice_register_write(self, register_index, value, delay=False):\n        self._dll.JLINKARM_WriteICEReg(register_index, int(value), int(delay))\n        return None", "response": "Writes a value to an ARM ICE register."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef etm_supported(self):\n        res = self._dll.JLINKARM_ETM_IsPresent()\n        if (res == 1):\n            return True\n\n        # JLINKARM_ETM_IsPresent() only works on ARM 7/9 devices.  This\n        # fallback checks if ETM is present by checking the Cortex ROM table\n        # for debugging information for ETM.\n        info = ctypes.c_uint32(0)\n        index = enums.JLinkROMTable.ETM\n        res = self._dll.JLINKARM_GetDebugInfo(index, ctypes.byref(info))\n        if (res == 1):\n            return False\n\n        return True", "response": "Returns True if the CPU core supports ETM."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef etm_register_write(self, register_index, value, delay=False):\n        self._dll.JLINKARM_ETM_WriteReg(int(register_index), int(value), int(delay))\n        return None", "response": "Writes a value to an ETM register."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef coresight_read(self, reg, ap=True):\n        data = ctypes.c_uint32()\n        ap = 1 if ap else 0\n        res = self._dll.JLINKARM_CORESIGHT_ReadAPDPReg(reg, ap, ctypes.byref(data))\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return data.value", "response": "Reads an Ap or DP register on a CoreSight DAP."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef coresight_write(self, reg, data, ap=True):\n        ap = 1 if ap else 0\n        res = self._dll.JLINKARM_CORESIGHT_WriteAPDPReg(reg, ap, data)\n        if res < 0:\n            raise errors.JLinkException(res)\n        return res", "response": "Writes an Ap or DP register to a CoreSight DAP."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the vector catch bits of the processor.", "response": "def set_vector_catch(self, flags):\n        \"\"\"Sets vector catch bits of the processor.\n\n        The CPU will jump to a vector if the given vector catch is active, and\n        will enter a debug state.  This has the effect of halting the CPU as\n        well, meaning the CPU must be explicitly restarted.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          ``None``\n\n        Raises:\n          JLinkException: on error.\n        \"\"\"\n        res = self._dll.JLINKARM_WriteVectorCatch(flags)\n        if res < 0:\n            raise errors.JLinkException(res)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef step(self, thumb=False):\n        method = self._dll.JLINKARM_Step\n        if thumb:\n            method = self._dll.JLINKARM_StepComposite\n\n        res = method()\n        if res != 0:\n            raise errors.JLinkException(\"Failed to step over instruction.\")\n\n        return None", "response": "Executes a single step."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the number of available breakpoint units of the specified type.", "response": "def num_available_breakpoints(self, arm=False, thumb=False, ram=False, flash=False, hw=False):\n        \"\"\"Returns the number of available breakpoints of the specified type.\n\n        If ``arm`` is set, gets the number of available ARM breakpoint units.\n        If ``thumb`` is set, gets the number of available THUMB breakpoint\n        units.  If ``ram`` is set, gets the number of available software RAM\n        breakpoint units.  If ``flash`` is set, gets the number of available\n        software flash breakpoint units.  If ``hw`` is set, gets the number of\n        available hardware breakpoint units.\n\n        If a combination of the flags is given, then\n        ``num_available_breakpoints()`` returns the number of breakpoints\n        specified by the given flags.  If no flags are specified, then the\n        count of available breakpoint units is returned.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          arm (bool): Boolean indicating to get number of ARM breakpoints.\n          thumb (bool): Boolean indicating to get number of THUMB breakpoints.\n          ram (bool): Boolean indicating to get number of SW RAM breakpoints.\n          flash (bool): Boolean indicating to get number of Flash breakpoints.\n          hw (bool): Boolean indicating to get number of Hardware breakpoints.\n\n        Returns:\n          The number of available breakpoint units of the specified type.\n        \"\"\"\n        flags = [\n            enums.JLinkBreakpoint.ARM,\n            enums.JLinkBreakpoint.THUMB,\n            enums.JLinkBreakpoint.SW_RAM,\n            enums.JLinkBreakpoint.SW_FLASH,\n            enums.JLinkBreakpoint.HW\n        ]\n\n        set_flags = [\n            arm,\n            thumb,\n            ram,\n            flash,\n            hw\n        ]\n\n        if not any(set_flags):\n            flags = enums.JLinkBreakpoint.ANY\n        else:\n            flags = list(f for i, f in enumerate(flags) if set_flags[i])\n            flags = functools.reduce(operator.__or__, flags, 0)\n\n        return self._dll.JLINKARM_GetNumBPUnits(flags)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef breakpoint_info(self, handle=0, index=-1):\n        if index < 0 and handle == 0:\n            raise ValueError('Handle must be provided if index is not set.')\n\n        bp = structs.JLinkBreakpointInfo()\n        bp.Handle = int(handle)\n        res = self._dll.JLINKARM_GetBPInfoEx(index, ctypes.byref(bp))\n        if res < 0:\n            raise errors.JLinkException('Failed to get breakpoint info.')\n\n        return bp", "response": "Returns the information about a set breakpoint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset a breakpoint at the specified address.", "response": "def breakpoint_set(self, addr, thumb=False, arm=False):\n        \"\"\"Sets a breakpoint at the specified address.\n\n        If ``thumb`` is ``True``, the breakpoint is set in THUMB-mode, while if\n        ``arm`` is ``True``, the breakpoint is set in ARM-mode, otherwise a\n        normal breakpoint is set.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          addr (int): the address where the breakpoint will be set\n          thumb (bool): boolean indicating to set the breakpoint in THUMB mode\n          arm (bool): boolean indicating to set the breakpoint in ARM mode\n\n        Returns:\n          An integer specifying the breakpoint handle.  This handle should be\n          retained for future breakpoint operations.\n\n        Raises:\n          TypeError: if the given address is not an integer.\n          JLinkException: if the breakpoint could not be set.\n        \"\"\"\n        flags = enums.JLinkBreakpoint.ANY\n\n        if thumb:\n            flags = flags | enums.JLinkBreakpoint.THUMB\n        elif arm:\n            flags = flags | enums.JLinkBreakpoint.ARM\n\n        handle = self._dll.JLINKARM_SetBPEx(int(addr), flags)\n        if handle <= 0:\n            raise errors.JLinkException('Breakpoint could not be set.')\n\n        return handle"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets a software breakpoint at the given address.", "response": "def software_breakpoint_set(self, addr, thumb=False, arm=False, flash=False, ram=False):\n        \"\"\"Sets a software breakpoint at the specified address.\n\n        If ``thumb`` is ``True``, the breakpoint is set in THUMB-mode, while if\n        ``arm`` is ``True``, the breakpoint is set in ARM-mode, otherwise a\n        normal breakpoint is set.\n\n        If ``flash`` is ``True``, the breakpoint is set in flash, otherwise if\n        ``ram`` is ``True``, the breakpoint is set in RAM.  If both are\n        ``True`` or both are ``False``, then the best option is chosen for\n        setting the breakpoint in software.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          addr (int): the address where the breakpoint will be set\n          thumb (bool): boolean indicating to set the breakpoint in THUMB mode\n          arm (bool): boolean indicating to set the breakpoint in ARM mode\n          flash (bool): boolean indicating to set the breakpoint in flash\n          ram (bool): boolean indicating to set the breakpoint in RAM\n\n        Returns:\n          An integer specifying the breakpoint handle.  This handle should sbe\n          retained for future breakpoint operations.\n\n        Raises:\n          TypeError: if the given address is not an integer.\n          JLinkException: if the breakpoint could not be set.\n        \"\"\"\n        if flash and not ram:\n            flags = enums.JLinkBreakpoint.SW_FLASH\n        elif not flash and ram:\n            flags = enums.JLinkBreakpoint.SW_RAM\n        else:\n            flags = enums.JLinkBreakpoint.SW\n\n        if thumb:\n            flags = flags | enums.JLinkBreakpoint.THUMB\n        elif arm:\n            flags = flags | enums.JLinkBreakpoint.ARM\n\n        handle = self._dll.JLINKARM_SetBPEx(int(addr), flags)\n        if handle <= 0:\n            raise errors.JLinkException('Software breakpoint could not be set.')\n\n        return handle"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef watchpoint_info(self, handle=0, index=-1):\n        if index < 0 and handle == 0:\n            raise ValueError('Handle must be provided if index is not set.')\n\n        wp = structs.JLinkWatchpointInfo()\n        res = self._dll.JLINKARM_GetWPInfoEx(index, ctypes.byref(wp))\n        if res < 0:\n            raise errors.JLinkException('Failed to get watchpoint info.')\n\n        for i in range(res):\n            res = self._dll.JLINKARM_GetWPInfoEx(i, ctypes.byref(wp))\n            if res < 0:\n                raise errors.JLinkException('Failed to get watchpoint info.')\n            elif wp.Handle == handle or wp.WPUnit == index:\n                return wp\n\n        return None", "response": "Returns information about the specified watchpoint."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets a watchpoint at the given address. This method allows for a watchpoint to be set on an given address or range of addresses. The watchpoint can then be triggered if the data at the given address matches the specified ``data`` or range of data as determined by ``data_mask``, on specific access size events, reads, writes, or privileged accesses. Both ``addr_mask`` and ``data_mask`` are used to specify ranges. Bits set to ``1`` are masked out and not taken into consideration when comparison against an address or data value. E.g. an ``addr_mask`` with a value of ``0x1`` and ``addr`` with value ``0xdeadbeef`` means that the watchpoint will be set on addresses ``0xdeadbeef`` and ``0xdeadbeee``. If the ``data`` was ``0x11223340`` and the given ``data_mask`` has a value of ``0x0000000F``, then the watchpoint would trigger for data matching ``0x11223340 - 0x1122334F``. Note: If both ``read`` and ``write`` are specified, then the watchpoint will trigger on both read and write events to the given address. Args: self (JLink): the ``JLink`` instance addr_mask (int): optional mask to use for determining which address the watchpoint should be set on data (int): optional data to set the watchpoint on in order to have the watchpoint triggered when the value at the specified address matches the given ``data`` data_mask (int): optional mask to use for determining the range of data on which the watchpoint should be triggered access_size (int): if specified, this must be one of ``{8, 16, 32}`` and determines the access size for which the watchpoint should trigger read (bool): if ``True``, triggers the watchpoint on read events write (bool): if ``True``, triggers the watchpoint on write events privileged (bool): if ``True``, triggers the watchpoint on privileged accesses Returns: The handle of the created watchpoint. Raises: ValueError: if an invalid access size is given. JLinkException: if the watchpoint fails to be set.", "response": "def watchpoint_set(self,\n                       addr,\n                       addr_mask=0x0,\n                       data=0x0,\n                       data_mask=0x0,\n                       access_size=None,\n                       read=False,\n                       write=False,\n                       privileged=False):\n        \"\"\"Sets a watchpoint at the given address.\n\n        This method allows for a watchpoint to be set on an given address or\n        range of addresses.  The watchpoint can then be triggered if the data\n        at the given address matches the specified ``data`` or range of data as\n        determined by ``data_mask``, on specific access size events, reads,\n        writes, or privileged accesses.\n\n        Both ``addr_mask`` and ``data_mask`` are used to specify ranges.  Bits\n        set to ``1`` are masked out and not taken into consideration when\n        comparison against an address or data value.  E.g. an ``addr_mask``\n        with a value of ``0x1`` and ``addr`` with value ``0xdeadbeef`` means\n        that the watchpoint will be set on addresses ``0xdeadbeef`` and\n        ``0xdeadbeee``.  If the ``data`` was ``0x11223340`` and the given\n        ``data_mask`` has a value of ``0x0000000F``, then the watchpoint would\n        trigger for data matching ``0x11223340 - 0x1122334F``.\n\n        Note:\n          If both ``read`` and ``write`` are specified, then the watchpoint\n          will trigger on both read and write events to the given address.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          addr_mask (int): optional mask to use for determining which address\n            the watchpoint should be set on\n          data (int): optional data to set the watchpoint on in order to have\n            the watchpoint triggered when the value at the specified address\n            matches the given ``data``\n          data_mask (int): optional mask to use for determining the range of\n            data on which the watchpoint should be triggered\n          access_size (int): if specified, this must be one of ``{8, 16, 32}``\n            and determines the access size for which the watchpoint should\n            trigger\n          read (bool): if ``True``, triggers the watchpoint on read events\n          write (bool): if ``True``, triggers the watchpoint on write events\n          privileged (bool): if ``True``, triggers the watchpoint on privileged\n            accesses\n\n        Returns:\n          The handle of the created watchpoint.\n\n        Raises:\n          ValueError: if an invalid access size is given.\n          JLinkException: if the watchpoint fails to be set.\n        \"\"\"\n        access_flags = 0x0\n        access_mask_flags = 0x0\n\n        # If an access size is not specified, we must specify that the size of\n        # the access does not matter by specifying the access mask flags.\n        if access_size is None:\n            access_mask_flags = access_mask_flags | enums.JLinkAccessMaskFlags.SIZE\n        elif access_size == 8:\n            access_flags = access_flags | enums.JLinkAccessFlags.SIZE_8BIT\n        elif access_size == 16:\n            access_flags = access_flags | enums.JLinkAccessFlags.SIZE_16BIT\n        elif access_size == 32:\n            access_flags = access_flags | enums.JLinkAccessFlags.SIZE_32BIT\n        else:\n            raise ValueError('Invalid access size given: %d' % access_size)\n\n        # The read and write access flags cannot be specified together, so if\n        # the user specifies that they want read and write access, then the\n        # access mask flag must be set.\n        if read and write:\n            access_mask_flags = access_mask_flags | enums.JLinkAccessMaskFlags.DIR\n        elif read:\n            access_flags = access_flags | enums.JLinkAccessFlags.READ\n        elif write:\n            access_flags = access_flags | enums.JLinkAccessFlags.WRITE\n\n        # If privileged is not specified, then there is no specification level\n        # on which kinds of writes should be accessed, in which case we must\n        # specify that flag.\n        if privileged:\n            access_flags = access_flags | enums.JLinkAccessFlags.PRIV\n        else:\n            access_mask_flags = access_mask_flags | enums.JLinkAccessMaskFlags.PRIV\n\n        # Populate the Data event to configure how the watchpoint is triggered.\n        wp = structs.JLinkDataEvent()\n        wp.Addr = addr\n        wp.AddrMask = addr_mask\n        wp.Data = data\n        wp.DataMask = data_mask\n        wp.Access = access_flags\n        wp.AccessMask = access_mask_flags\n\n        # Return value of the function is <= 0 in the event of an error,\n        # otherwise the watchpoint was set successfully.\n        handle = ctypes.c_uint32()\n        res = self._dll.JLINKARM_SetDataEvent(ctypes.pointer(wp), ctypes.pointer(handle))\n        if res < 0:\n            raise errors.JLinkDataException(res)\n\n        return handle.value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisassemble and returns the assembly instruction string at the given instruction address.", "response": "def disassemble_instruction(self, instruction):\n        \"\"\"Disassembles and returns the assembly instruction string.\n\n        Args:\n          self (JLink): the ``JLink`` instance.\n          instruction (int): the instruction address.\n\n        Returns:\n          A string corresponding to the assembly instruction string at the\n          given instruction address.\n\n        Raises:\n          JLinkException: on error.\n          TypeError: if ``instruction`` is not a number.\n        \"\"\"\n        if not util.is_integer(instruction):\n            raise TypeError('Expected instruction to be an integer.')\n\n        buf_size = self.MAX_BUF_SIZE\n        buf = (ctypes.c_char * buf_size)()\n        res = self._dll.JLINKARM_DisassembleInst(ctypes.byref(buf), buf_size, instruction)\n        if res < 0:\n            raise errors.JLinkException('Failed to disassemble instruction.')\n\n        return ctypes.string_at(buf).decode()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef strace_configure(self, port_width):\n        if port_width not in [1, 2, 4]:\n            raise ValueError('Invalid port width: %s' % str(port_width))\n\n        config_string = 'PortWidth=%d' % port_width\n        res = self._dll.JLINK_STRACE_Config(config_string.encode())\n        if res < 0:\n            raise errors.JLinkException('Failed to configure STRACE port')\n\n        return None", "response": "Configures the trace port width for tracing."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef strace_read(self, num_instructions):\n        if num_instructions < 0 or num_instructions > 0x10000:\n            raise ValueError('Invalid instruction count.')\n\n        buf = (ctypes.c_uint32 * num_instructions)()\n        buf_size = num_instructions\n        res = self._dll.JLINK_STRACE_Read(ctypes.byref(buf), buf_size)\n        if res < 0:\n            raise errors.JLinkException('Failed to read from STRACE buffer.')\n\n        return list(buf)[:res]", "response": "Reads and returns a number of instructions captured by STRACE."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef strace_data_access_event(self,\n                                 operation,\n                                 address,\n                                 data,\n                                 data_mask=None,\n                                 access_width=4,\n                                 address_range=0):\n        \"\"\"Sets an event to trigger trace logic when data access is made.\n\n        Data access corresponds to either a read or write.\n\n        Args:\n          self (JLink): the ``JLink`` instance.\n          operation (int): one of the operations in ``JLinkStraceOperation``.\n          address (int): the address of the load/store data.\n          data (int): the data to be compared the event data to.\n          data_mask (int): optional bitmask specifying bits to ignore in\n            comparison.\n          acess_width (int): optional access width for the data.\n          address_range (int): optional range of address to trigger event on.\n\n        Returns:\n          An integer specifying the trace event handle.  This handle should be\n          retained in order to clear the event at a later time.\n\n        Raises:\n          JLinkException: on error.\n        \"\"\"\n        cmd = enums.JLinkStraceCommand.TRACE_EVENT_SET\n        event_info = structs.JLinkStraceEventInfo()\n        event_info.Type = enums.JLinkStraceEvent.DATA_ACCESS\n        event_info.Op = operation\n        event_info.AccessSize = int(access_width)\n        event_info.Addr = int(address)\n        event_info.Data = int(data)\n        event_info.DataMask = int(data_mask or 0)\n        event_info.AddrRangeSize = int(address_range)\n        handle = self._dll.JLINK_STRACE_Control(cmd, ctypes.byref(event_info))\n        if handle < 0:\n            raise errors.JLinkException(handle)\n\n        return handle", "response": "Sets an event to trigger trace logic when data access is made."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset an event to trigger trace logic when data write access is made.", "response": "def strace_data_store_event(self, operation, address, address_range=0):\n        \"\"\"Sets an event to trigger trace logic when data write access is made.\n\n        Args:\n          self (JLink): the ``JLink`` instance.\n          operation (int): one of the operations in ``JLinkStraceOperation``.\n          address (int): the address of the store data.\n          address_range (int): optional range of address to trigger event on.\n\n        Returns:\n          An integer specifying the trace event handle.  This handle should be\n          retained in order to clear the event at a later time.\n\n        Raises:\n          JLinkException: on error.\n        \"\"\"\n        cmd = enums.JLinkStraceCommand.TRACE_EVENT_SET\n        event_info = structs.JLinkStraceEventInfo()\n        event_info.Type = enums.JLinkStraceEvent.DATA_STORE\n        event_info.Op = operation\n        event_info.Addr = int(address)\n        event_info.AddrRangeSize = int(address_range)\n        handle = self._dll.JLINK_STRACE_Control(cmd, ctypes.byref(event_info))\n        if handle < 0:\n            raise errors.JLinkException(handle)\n\n        return handle"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef strace_clear(self, handle):\n        data = ctypes.c_int(handle)\n        res = self._dll.JLINK_STRACE_Control(enums.JLinkStraceCommand.TRACE_EVENT_CLR, ctypes.byref(data))\n        if res < 0:\n            raise errors.JLinkException('Failed to clear STRACE event.')\n\n        return None", "response": "Clears the trace event specified by the given handle."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclears all STRACE events.", "response": "def strace_clear_all(self):\n        \"\"\"Clears all STRACE events.\n\n        Args:\n          self (JLink): the ``JLink`` instance.\n\n        Returns:\n          ``None``\n\n        Raises:\n          JLinkException: on error.\n        \"\"\"\n        data = 0\n        res = self._dll.JLINK_STRACE_Control(enums.JLinkStraceCommand.TRACE_EVENT_CLR_ALL, data)\n        if res < 0:\n            raise errors.JLinkException('Failed to clear all STRACE events.')\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef strace_set_buffer_size(self, size):\n        size = ctypes.c_uint32(size)\n        res = self._dll.JLINK_STRACE_Control(enums.JLinkStraceCommand.SET_BUFFER_SIZE, size)\n        if res < 0:\n            raise errors.JLinkException('Failed to set the STRACE buffer size.')\n\n        return None", "response": "Sets the STRACE buffer size."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef trace_start(self):\n        cmd = enums.JLinkTraceCommand.START\n        res = self._dll.JLINKARM_TRACE_Control(cmd, 0)\n        if (res == 1):\n            raise errors.JLinkException('Failed to start trace.')\n        return None", "response": "Starts collecting trace data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trace_stop(self):\n        cmd = enums.JLinkTraceCommand.STOP\n        res = self._dll.JLINKARM_TRACE_Control(cmd, 0)\n        if (res == 1):\n            raise errors.JLinkException('Failed to stop trace.')\n        return None", "response": "Stops collecting trace data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef trace_flush(self):\n        cmd = enums.JLinkTraceCommand.FLUSH\n        res = self._dll.JLINKARM_TRACE_Control(cmd, 0)\n        if (res == 1):\n            raise errors.JLinkException('Failed to flush the trace buffer.')\n        return None", "response": "Flushes the trace buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef trace_buffer_capacity(self):\n        cmd = enums.JLinkTraceCommand.GET_CONF_CAPACITY\n        data = ctypes.c_uint32(0)\n        res = self._dll.JLINKARM_TRACE_Control(cmd, ctypes.byref(data))\n        if (res == 1):\n            raise errors.JLinkException('Failed to get trace buffer size.')\n        return data.value", "response": "Retrieves the current capacity of the trace buffer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef trace_set_buffer_capacity(self, size):\n        cmd = enums.JLinkTraceCommand.SET_CAPACITY\n        data = ctypes.c_uint32(size)\n        res = self._dll.JLINKARM_TRACE_Control(cmd, ctypes.byref(data))\n        if (res == 1):\n            raise errors.JLinkException('Failed to set trace buffer size.')\n        return None", "response": "Sets the capacity for the trace buffer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve the minimum capacity the trace buffer can be configured with.", "response": "def trace_min_buffer_capacity(self):\n        \"\"\"Retrieves the minimum capacity the trace buffer can be configured with.\n\n        Args:\n          self (JLink): the ``JLink`` instance.\n\n        Returns:\n          The minimum configurable capacity for the trace buffer.\n        \"\"\"\n        cmd = enums.JLinkTraceCommand.GET_MIN_CAPACITY\n        data = ctypes.c_uint32(0)\n        res = self._dll.JLINKARM_TRACE_Control(cmd, ctypes.byref(data))\n        if (res == 1):\n            raise errors.JLinkException('Failed to get min trace buffer size.')\n        return data.value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve the maximum size the trace buffer can be configured with.", "response": "def trace_max_buffer_capacity(self):\n        \"\"\"Retrieves the maximum size the trace buffer can be configured with.\n\n        Args:\n          self (JLink): the ``JLink`` instance.\n\n        Returns:\n          The maximum configurable capacity for the trace buffer.\n        \"\"\"\n        cmd = enums.JLinkTraceCommand.GET_MAX_CAPACITY\n        data = ctypes.c_uint32(0)\n        res = self._dll.JLINKARM_TRACE_Control(cmd, ctypes.byref(data))\n        if (res == 1):\n            raise errors.JLinkException('Failed to get max trace buffer size.')\n        return data.value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the format for the trace buffer.", "response": "def trace_set_format(self, fmt):\n        \"\"\"Sets the format for the trace buffer to use.\n\n        Args:\n          self (JLink): the ``JLink`` instance.\n          fmt (int): format for the trace buffer; this is one of the attributes\n            of ``JLinkTraceFormat``.\n\n        Returns:\n          ``None``\n        \"\"\"\n        cmd = enums.JLinkTraceCommand.SET_FORMAT\n        data = ctypes.c_uint32(fmt)\n        res = self._dll.JLINKARM_TRACE_Control(cmd, ctypes.byref(data))\n        if (res == 1):\n            raise errors.JLinkException('Failed to set trace format.')\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve the current format of the trace buffer.", "response": "def trace_format(self):\n        \"\"\"Retrieves the current format the trace buffer is using.\n\n        Args:\n          self (JLink): the ``JLink`` instance.\n\n        Returns:\n          The current format the trace buffer is using.  This is one of the\n          attributes of ``JLinkTraceFormat``.\n        \"\"\"\n        cmd = enums.JLinkTraceCommand.GET_FORMAT\n        data = ctypes.c_uint32(0)\n        res = self._dll.JLINKARM_TRACE_Control(cmd, ctypes.byref(data))\n        if (res == 1):\n            raise errors.JLinkException('Failed to get trace format.')\n        return data.value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving a count of the number of available trace regions.", "response": "def trace_region_count(self):\n        \"\"\"Retrieves a count of the number of available trace regions.\n\n        Args:\n          self (JLink): the ``JLink`` instance.\n\n        Returns:\n          Count of the number of available trace regions.\n        \"\"\"\n        cmd = enums.JLinkTraceCommand.GET_NUM_REGIONS\n        data = ctypes.c_uint32(0)\n        res = self._dll.JLINKARM_TRACE_Control(cmd, ctypes.byref(data))\n        if (res == 1):\n            raise errors.JLinkException('Failed to get trace region count.')\n        return data.value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef trace_region(self, region_index):\n        cmd = enums.JLinkTraceCommand.GET_REGION_PROPS_EX\n        region = structs.JLinkTraceRegion()\n        region.RegionIndex = int(region_index)\n        res = self._dll.JLINKARM_TRACE_Control(cmd, ctypes.byref(region))\n        if (res == 1):\n            raise errors.JLinkException('Failed to get trace region.')\n        return region", "response": "Retrieves the properties of a trace region."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading data from the trace buffer and returns it.", "response": "def trace_read(self, offset, num_items):\n        \"\"\"Reads data from the trace buffer and returns it.\n\n        Args:\n          self (JLink): the ``JLink`` instance.\n          offset (int): the offset from which to start reading from the trace\n            buffer.\n          num_items (int): number of items to read from the trace buffer.\n\n        Returns:\n          A list of ``JLinkTraceData`` instances corresponding to the items\n          read from the trace buffer.  Note that this list may have size less\n          than ``num_items`` in the event that there are not ``num_items``\n          items in the trace buffer.\n\n        Raises:\n          JLinkException: on error.\n        \"\"\"\n        buf_size = ctypes.c_uint32(num_items)\n        buf = (structs.JLinkTraceData * num_items)()\n        res = self._dll.JLINKARM_TRACE_Read(buf, int(offset), ctypes.byref(buf_size))\n        if (res == 1):\n            raise errors.JLinkException('Failed to read from trace buffer.')\n        return list(buf)[:int(buf_size.value)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef swo_start(self, swo_speed=9600):\n        if self.swo_enabled():\n            self.swo_stop()\n\n        info = structs.JLinkSWOStartInfo()\n        info.Speed = swo_speed\n        res = self._dll.JLINKARM_SWO_Control(enums.JLinkSWOCommands.START,\n                                             ctypes.byref(info))\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        self._swo_enabled = True\n\n        return None", "response": "Starts collecting SWO data for the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstop collecting SWO data.", "response": "def swo_stop(self):\n        \"\"\"Stops collecting SWO data.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          ``None``\n\n        Raises:\n          JLinkException: on error\n        \"\"\"\n        res = self._dll.JLINKARM_SWO_Control(enums.JLinkSWOCommands.STOP, 0)\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef swo_enable(self, cpu_speed, swo_speed=9600, port_mask=0x01):\n        if self.swo_enabled():\n            self.swo_stop()\n\n        res = self._dll.JLINKARM_SWO_EnableTarget(cpu_speed,\n                                                  swo_speed,\n                                                  enums.JLinkSWOInterfaces.UART,\n                                                  port_mask)\n        if res != 0:\n            raise errors.JLinkException(res)\n\n        self._swo_enabled = True\n\n        return None", "response": "Enables SWO output on the target device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisable ITM & Stimulus ports.", "response": "def swo_disable(self, port_mask):\n        \"\"\"Disables ITM & Stimulus ports.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          port_mask (int): mask specifying which ports to disable\n\n        Returns:\n          ``None``\n\n        Raises:\n          JLinkException: on error\n        \"\"\"\n        res = self._dll.JLINKARM_SWO_DisableTarget(port_mask)\n        if res != 0:\n            raise errors.JLinkException(res)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef swo_flush(self, num_bytes=None):\n        if num_bytes is None:\n            num_bytes = self.swo_num_bytes()\n\n        buf = ctypes.c_uint32(num_bytes)\n        res = self._dll.JLINKARM_SWO_Control(enums.JLinkSWOCommands.FLUSH,\n                                             ctypes.byref(buf))\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return None", "response": "Flushes data from the SWO buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef swo_speed_info(self):\n        info = structs.JLinkSWOSpeedInfo()\n        res = self._dll.JLINKARM_SWO_Control(enums.JLinkSWOCommands.GET_SPEED_INFO,\n                                             ctypes.byref(info))\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return info", "response": "Retrieves information about the supported SWO speeds."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef swo_num_bytes(self):\n        res = self._dll.JLINKARM_SWO_Control(enums.JLinkSWOCommands.GET_NUM_BYTES,\n                                             0)\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return res", "response": "Returns the number of bytes in the SWO buffer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef swo_set_host_buffer_size(self, buf_size):\n        buf = ctypes.c_uint32(buf_size)\n        res = self._dll.JLINKARM_SWO_Control(enums.JLinkSWOCommands.SET_BUFFERSIZE_HOST,\n                                             ctypes.byref(buf))\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return None", "response": "Sets the size of the buffer used by the host to collect SWO data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the size of the buffer used by the J - Link to collect SWO data.", "response": "def swo_set_emu_buffer_size(self, buf_size):\n        \"\"\"Sets the size of the buffer used by the J-Link to collect SWO data.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          buf_size (int): the new size of the emulator buffer\n\n        Returns:\n          ``None``\n\n        Raises:\n          JLinkException: on error\n        \"\"\"\n        buf = ctypes.c_uint32(buf_size)\n        res = self._dll.JLINKARM_SWO_Control(enums.JLinkSWOCommands.SET_BUFFERSIZE_EMU,\n                                             ctypes.byref(buf))\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef swo_supported_speeds(self, cpu_speed, num_speeds=3):\n        buf_size = num_speeds\n        buf = (ctypes.c_uint32 * buf_size)()\n        res = self._dll.JLINKARM_SWO_GetCompatibleSpeeds(cpu_speed, 0, buf, buf_size)\n        if res < 0:\n            raise errors.JLinkException(res)\n\n        return list(buf)[:res]", "response": "Returns a list of SWO speeds supported by both the target and the connected J - Link."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread data from the SWO buffer.", "response": "def swo_read(self, offset, num_bytes, remove=False):\n        \"\"\"Reads data from the SWO buffer.\n\n        The data read is not automatically removed from the SWO buffer after\n        reading unless ``remove`` is ``True``.  Otherwise the callee must\n        explicitly remove the data by calling ``.swo_flush()``.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          offset (int): offset of first byte to be retrieved\n          num_bytes (int): number of bytes to read\n          remove (bool): if data should be removed from buffer after read\n\n        Returns:\n          A list of bytes read from the SWO buffer.\n        \"\"\"\n        buf_size = ctypes.c_uint32(num_bytes)\n        buf = (ctypes.c_uint8 * num_bytes)(0)\n\n        self._dll.JLINKARM_SWO_Read(buf, offset, ctypes.byref(buf_size))\n\n        # After the call, ``buf_size`` has been modified to be the actual\n        # number of bytes that was read.\n        buf_size = buf_size.value\n\n        if remove:\n            self.swo_flush(buf_size)\n\n        return list(buf)[:buf_size]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread the printable data via SWO.", "response": "def swo_read_stimulus(self, port, num_bytes):\n        \"\"\"Reads the printable data via SWO.\n\n        This method reads SWO for one stimulus port, which is all printable\n        data.\n\n        Note:\n          Stimulus port ``0`` is used for ``printf`` debugging.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          port (int): the stimulus port to read from, ``0 - 31``\n          num_bytes (int): number of bytes to read\n\n        Returns:\n          A list of bytes read via SWO.\n\n        Raises:\n          ValueError: if ``port < 0`` or ``port > 31``\n        \"\"\"\n        if port < 0 or port > 31:\n            raise ValueError('Invalid port number: %s' % port)\n\n        buf_size = num_bytes\n        buf = (ctypes.c_uint8 * buf_size)()\n        bytes_read = self._dll.JLINKARM_SWO_ReadStimulus(port, buf, buf_size)\n\n        return list(buf)[:bytes_read]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rtt_get_num_up_buffers(self):\n        cmd = enums.JLinkRTTCommand.GETNUMBUF\n        dir = ctypes.c_int(enums.JLinkRTTDirection.UP)\n        return self.rtt_control(cmd, dir)", "response": "After starting RTT get the number of up buffers on the target."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rtt_read(self, buffer_index, num_bytes):\n        buf = (ctypes.c_ubyte * num_bytes)()\n        bytes_read = self._dll.JLINK_RTTERMINAL_Read(buffer_index, buf, num_bytes)\n\n        if bytes_read < 0:\n            raise errors.JLinkRTTException(bytes_read)\n\n        return list(buf)[:bytes_read]", "response": "Reads data from the specified RTT buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rtt_write(self, buffer_index, data):\n        buf_size = len(data)\n        buf = (ctypes.c_ubyte * buf_size)(*bytearray(data))\n        bytes_written = self._dll.JLINK_RTTERMINAL_Write(buffer_index, buf, buf_size)\n\n        if bytes_written < 0:\n            raise errors.JLinkRTTException(bytes_written)\n\n        return bytes_written", "response": "Writes data to the specified RTT buffer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nissuing an RTT Control command.", "response": "def rtt_control(self, command, config):\n        \"\"\"Issues an RTT Control command.\n\n        All RTT control is done through a single API call which expects\n        specifically laid-out configuration structures.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n          command (int): the command to issue (see enums.JLinkRTTCommand)\n          config (ctypes type): the configuration to pass by reference.\n\n        Returns:\n          An integer containing the result of the command.\n        \"\"\"\n        config_byref = ctypes.byref(config) if config is not None else None\n        res = self._dll.JLINK_RTTERMINAL_Control(command, config_byref)\n\n        if res < 0:\n            raise errors.JLinkRTTException(res)\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_rtt(jlink):\n    try:\n        while jlink.connected():\n            terminal_bytes = jlink.rtt_read(0, 1024)\n            if terminal_bytes:\n                sys.stdout.write(\"\".join(map(chr, terminal_bytes)))\n                sys.stdout.flush()\n            time.sleep(0.1)\n    except Exception:\n        print(\"IO read thread exception, exiting...\")\n        thread.interrupt_main()\n        raise", "response": "Reads the RTT buffer of the target JLink unit and prints it to stdout."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite input to the RTT buffer.", "response": "def write_rtt(jlink):\n    \"\"\"Writes kayboard input to JLink RTT buffer #0.\n\n    This method is a loop that blocks waiting on stdin. When enter is pressed,\n    LF and NUL bytes are added to the input and transmitted as a byte list.\n    If the JLink is disconnected, it will exit gracefully. If any other\n    exceptions are raised, they will be caught and re-raised after interrupting\n    the main thread.\n\n    Args:\n      jlink (pylink.JLink): The JLink to write to.\n\n    Raises:\n      Exception on error.\n    \"\"\"\n    try:\n        while jlink.connected():\n            bytes = list(bytearray(input(), \"utf-8\") + b\"\\x0A\\x00\")\n            bytes_written = jlink.rtt_write(0, bytes)\n    except Exception:\n        print(\"IO write thread exception, exiting...\")\n        thread.interrupt_main()\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main(target_device):\n    jlink = pylink.JLink()\n    print(\"connecting to JLink...\")\n    jlink.open()\n    print(\"connecting to %s...\" % target_device)\n    jlink.set_tif(pylink.enums.JLinkInterfaces.SWD)\n    jlink.connect(target_device)\n    print(\"connected, starting RTT...\")\n    jlink.rtt_start()\n\n    while True:\n        try:\n            num_up = jlink.rtt_get_num_up_buffers()\n            num_down = jlink.rtt_get_num_down_buffers()\n            print(\"RTT started, %d up bufs, %d down bufs.\" % (num_up, num_down))\n            break\n        except pylink.errors.JLinkRTTException:\n            time.sleep(0.1)\n\n    try:\n        thread.start_new_thread(read_rtt, (jlink,))\n        thread.start_new_thread(write_rtt, (jlink,))\n        while jlink.connected():\n            time.sleep(1)\n        print(\"JLink disconnected, exiting...\")\n    except KeyboardInterrupt:\n        print(\"ctrl-c detected, exiting...\")\n        pass", "response": "This function creates an interactive terminal to the target CPU."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the thread. ArcGIS thread.", "response": "def run(self):\n        \"\"\"Runs the thread.\n\n        Args:\n          self (ThreadReturn): the ``ThreadReturn`` instance\n\n        Returns:\n          ``None``\n        \"\"\"\n        target = getattr(self, '_Thread__target', getattr(self, '_target', None))\n        args = getattr(self, '_Thread__args', getattr(self, '_args', None))\n        kwargs = getattr(self, '_Thread__kwargs', getattr(self, '_kwargs', None))\n        if target is not None:\n            self._return = target(*args, **kwargs)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\njoins the thread. ArcGIS thread.", "response": "def join(self, *args, **kwargs):\n        \"\"\"Joins the thread.\n\n        Args:\n          self (ThreadReturn): the ``ThreadReturn`` instance\n          args: optional list of arguments\n          kwargs: optional key-word arguments\n\n        Returns:\n          The return value of the exited thread.\n        \"\"\"\n        super(ThreadReturn, self).join(*args, **kwargs)\n        return self._return"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupgrades the firmware of the J - Link connected to a Windows device.", "response": "def main():\n    \"\"\"Upgrades the firmware of the J-Links connected to a Windows device.\n\n    Returns:\n      None.\n\n    Raises:\n      OSError: if there are no J-Link software packages.\n    \"\"\"\n    windows_libraries = list(pylink.Library.find_library_windows())\n    latest_library = None\n    for lib in windows_libraries:\n        if os.path.dirname(lib).endswith('JLinkARM'):\n            # Always use the one pointed to by the 'JLinkARM' directory.\n            latest_library = lib\n            break\n        elif latest_library is None:\n            latest_library = lib\n        elif os.path.dirname(lib) > os.path.dirname(latest_library):\n            latest_library = lib\n\n    if latest_library is None:\n        raise OSError('No J-Link library found.')\n\n    library = pylink.Library(latest_library)\n    jlink = pylink.JLink(lib=library)\n\n    print('Found version: %s' % jlink.version)\n\n    for emu in jlink.connected_emulators():\n        jlink.disable_dialog_boxes()\n        jlink.open(serial_no=emu.SerialNumber)\n        jlink.sync_firmware()\n        print('Updated emulator with serial number %s' % emu.SerialNumber)\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef async_decorator(func):\n\n    @functools.wraps(func)\n    def async_wrapper(*args, **kwargs):\n        \"\"\"Wraps up the call to ``func``, so that it is called from a separate\n        thread.\n\n        The callback, if given, will be called with two parameters,\n        ``exception`` and ``result`` as ``callback(exception, result)``.  If\n        the thread ran to completion without error, ``exception`` will be\n        ``None``, otherwise ``exception`` will be the generated exception that\n        stopped the thread.  Result is the result of the exected function.\n\n        Args:\n          callback (function): the callback to ultimately be called\n          args: list of arguments to pass to ``func``\n          kwargs: key-word arguments dictionary to pass to ``func``\n\n        Returns:\n          A thread if the call is asynchronous, otherwise the the return value\n          of the wrapped function.\n\n        Raises:\n          TypeError: if ``callback`` is not callable or is missing\n        \"\"\"\n        if 'callback' not in kwargs or not kwargs['callback']:\n            return func(*args, **kwargs)\n\n        callback = kwargs.pop('callback')\n\n        if not callable(callback):\n            raise TypeError('Expected \\'callback\\' is not callable.')\n\n        def thread_func(*args, **kwargs):\n            \"\"\"Thread function on which the given ``func`` and ``callback``\n            are executed.\n\n            Args:\n              args: list of arguments to pass to ``func``\n              kwargs: key-word arguments dictionary to pass to ``func``\n\n            Returns:\n              Return value of the wrapped function.\n            \"\"\"\n            exception, res = None, None\n            try:\n                res = func(*args, **kwargs)\n            except Exception as e:\n                exception = e\n            return callback(exception, res)\n\n        thread = threads.ThreadReturn(target=thread_func,\n                                      args=args,\n                                      kwargs=kwargs)\n        thread.daemon = True\n        thread.start()\n        return thread\n\n    return async_wrapper", "response": "Asynchronous function decorator.  Interprets the function as being\n    asynchronous, so returns a function that will handle calling the\n    Function asynchronously.\n\n    Args:\n      func (function): function to be called asynchronously\n\n    Returns:\n      The wrapped function.\n\n    Raises:\n      AttributeError: if ``func`` is not callable"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef strace(device, trace_address, breakpoint_address):\n    jlink = pylink.JLink()\n    jlink.open()\n\n    # Do the initial connection sequence.\n    jlink.power_on()\n    jlink.set_tif(pylink.JLinkInterfaces.SWD)\n    jlink.connect(device)\n    jlink.reset()\n\n    # Clear any breakpoints that may exist as of now.\n    jlink.breakpoint_clear_all()\n\n    # Start the simple trace.\n    op = pylink.JLinkStraceOperation.TRACE_START\n    jlink.strace_clear_all()\n    jlink.strace_start()\n\n    # Set the breakpoint and trace events, then restart the CPU so that it\n    # will execute.\n    bphandle = jlink.breakpoint_set(breakpoint_address, thumb=True)\n    trhandle = jlink.strace_code_fetch_event(op, address=trace_address)\n    jlink.restart()\n    time.sleep(1)\n\n    # Run until the CPU halts due to the breakpoint being hit.\n    while True:\n        if jlink.halted():\n            break\n\n    # Print out all instructions that were captured by the trace.\n    while True:\n        instructions = jlink.strace_read(1)\n        if len(instructions) == 0:\n            break\n        instruction = instructions[0]\n        print(jlink.disassemble_instruction(instruction))\n\n    jlink.power_off()\n    jlink.close()", "response": "Implements simple trace using the STrace API."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds the command parser.", "response": "def create_parser():\n    \"\"\"Builds the command parser.\n\n    This needs to be exported in order for Sphinx to document it correctly.\n\n    Returns:\n      An instance of an ``argparse.ArgumentParser`` that parses all the\n      commands supported by the PyLink CLI.\n    \"\"\"\n    parser = argparse.ArgumentParser(prog=pylink.__title__,\n                                     description=pylink.__description__,\n                                     epilog=pylink.__copyright__)\n    parser.add_argument('--version', action='version',\n                        version='%(prog)s ' + pylink.__version__)\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n                        help='increase output verbosity')\n\n    kwargs = {}\n    kwargs['title'] = 'command'\n    kwargs['description'] = 'specify subcommand to run'\n    kwargs['help'] = 'subcommands'\n    subparsers = parser.add_subparsers(**kwargs)\n\n    for command in commands():\n        kwargs = {}\n        kwargs['name'] = command.name\n        kwargs['description'] = command.description\n        kwargs['help'] = command.help\n        subparser = subparsers.add_parser(**kwargs)\n        subparser.set_defaults(command=command.run)\n        command.add_arguments(subparser)\n\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate an instance of a J - Link from the given arguments.", "response": "def create_jlink(self, args):\n        \"\"\"Creates an instance of a J-Link from the given arguments.\n\n        Args:\n          self (Command): the ``Command`` instance\n          args (Namespace): arguments to construct the ``JLink`` instance from\n\n        Returns:\n          An instance of a ``JLink``.\n        \"\"\"\n        jlink = pylink.JLink()\n        jlink.open(args.serial_no, args.ip_addr)\n\n        if hasattr(args, 'tif') and args.tif is not None:\n            if args.tif.lower() == 'swd':\n                jlink.set_tif(pylink.JLinkInterfaces.SWD)\n            else:\n                jlink.set_tif(pylink.JLinkInterfaces.JTAG)\n\n        if hasattr(args, 'device') and args.device is not None:\n            jlink.connect(args.device)\n\n        return jlink"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds common arguments to the given parser.", "response": "def add_common_arguments(self, parser, has_device=False):\n        \"\"\"Adds common arguments to the given parser.\n\n        Common arguments for a J-Link command are the target interface, and\n        J-Link serial number or IP address.\n\n        Args:\n          self (Command): the ``Command`` instance\n          parser (argparse.ArgumentParser): the parser to add the arguments to\n          has_device (bool): boolean indicating if it has the device argument\n\n        Returns:\n          ``None``\n        \"\"\"\n        if has_device:\n            parser.add_argument('-t', '--tif', required=True,\n                                type=str.lower, choices=['jtag', 'swd'],\n                                help='target interface (JTAG | SWD)')\n            parser.add_argument('-d', '--device', required=True,\n                                help='specify the target device name')\n\n        group = parser.add_mutually_exclusive_group(required=False)\n        group.add_argument('-s', '--serial', dest='serial_no',\n                           help='specify the J-Link serial number')\n        group.add_argument('-i', '--ip_addr', dest='ip_addr',\n                           help='J-Link IP address')\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self, args):\n        jlink = self.create_jlink(args)\n        erased = jlink.erase()\n        print('Bytes Erased: %d' % erased)", "response": "Erases the device connected to the J - Link."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nflashing the device connected to the J - Link.", "response": "def run(self, args):\n        \"\"\"Flashes the device connected to the J-Link.\n\n        Args:\n          self (FlashCommand): the ``FlashCommand`` instance\n          args (Namespace): the arguments passed on the command-line\n\n        Returns:\n          ``None``\n        \"\"\"\n        kwargs = {}\n        kwargs['path'] = args.file[0]\n        kwargs['addr'] = args.addr\n        kwargs['on_progress'] = pylink.util.flash_progress_callback\n\n        jlink = self.create_jlink(args)\n        _ = jlink.flash_file(**kwargs)\n        print('Flashed device successfully.')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the unlock command arguments to the argument parser.", "response": "def add_arguments(self, parser):\n        \"\"\"Adds the unlock command arguments to the parser.\n\n        Args:\n          self (UnlockCommand): the ``UnlockCommand`` instance\n          parser (argparse.ArgumentParser): the parser to add the arguments to\n\n        Returns:\n          ``None``\n        \"\"\"\n        parser.add_argument('name', nargs=1, choices=['kinetis'],\n                            help='name of MCU to unlock')\n        return self.add_common_arguments(parser, True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nunlocking the target device.", "response": "def run(self, args):\n        \"\"\"Unlocks the target device.\n\n        Args:\n          self (UnlockCommand): the ``UnlockCommand`` instance\n          args (Namespace): the arguments passed on the command-line\n\n        Returns:\n          ``None``\n        \"\"\"\n        jlink = self.create_jlink(args)\n        mcu = args.name[0].lower()\n        if pylink.unlock(jlink, mcu):\n            print('Successfully unlocked device!')\n        else:\n            print('Failed to unlock device!')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self, args):\n        jlink = self.create_jlink(args)\n        if args.list:\n            print('Built-in Licenses: %s' % ', '.join(jlink.licenses.split(',')))\n            print('Custom Licenses: %s' % ', '.join(jlink.custom_licenses.split(',')))\n        elif args.add is not None:\n            if jlink.add_license(args.add):\n                print('Successfully added license.')\n            else:\n                print('License already exists.')\n        elif args.erase:\n            if jlink.erase_licenses():\n                print('Successfully erased all custom licenses.')\n            else:\n                print('Failed to erase custom licenses.')", "response": "Runs the license command."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the arguments to the argument parser.", "response": "def add_arguments(self, parser):\n        \"\"\"Adds the information commands to the parser.\n\n        Args:\n          self (InfoCommand): the ``InfoCommand`` instance\n          parser (argparse.ArgumentParser): the parser to add the arguments to\n\n        Returns:\n          ``None``\n        \"\"\"\n        parser.add_argument('-p', '--product', action='store_true',\n                            help='print the production information')\n        parser.add_argument('-j', '--jtag', action='store_true',\n                            help='print the JTAG pin status')\n        return self.add_common_arguments(parser, False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns the information command.", "response": "def run(self, args):\n        \"\"\"Runs the information command.\n\n        Args:\n          self (InfoCommand): the ``InfoCommand`` instance\n          args (Namespace): the arguments passed on the command-line\n\n        Returns:\n          ``None``\n        \"\"\"\n        jlink = self.create_jlink(args)\n        if args.product:\n            print('Product: %s' % jlink.product_name)\n\n            manufacturer = 'SEGGER' if jlink.oem is None else jlink.oem\n            print('Manufacturer: %s' % manufacturer)\n\n            print('Hardware Version: %s' % jlink.hardware_version)\n            print('Firmware: %s' % jlink.firmware_version)\n            print('DLL Version: %s' % jlink.version)\n            print('Features: %s' % ', '.join(jlink.features))\n        elif args.jtag:\n            status = jlink.hardware_status\n            print('TCK Pin Status: %d' % status.tck)\n            print('TDI Pin Status: %d' % status.tdi)\n            print('TDO Pin Status: %d' % status.tdo)\n            print('TMS Pin Status: %d' % status.tms)\n            print('TRES Pin Status: %d' % status.tres)\n            print('TRST Pin Status: %d' % status.trst)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the arguments for the emulator command to the argument parser.", "response": "def add_arguments(self, parser):\n        \"\"\"Adds the arguments for the emulator command.\n\n        Args:\n          self (EmulatorCommand): the ``EmulatorCommand`` instance\n          parser (argparse.ArgumentParser): parser to add the commands to\n\n        Returns:\n          ``None``\n        \"\"\"\n        group = parser.add_mutually_exclusive_group(required=True)\n        group.add_argument('-l', '--list', nargs='?',\n                           type=str.lower, default='_',\n                           choices=['usb', 'ip'],\n                           help='list all the connected emulators')\n        group.add_argument('-s', '--supported', nargs=1,\n                           help='query whether a device is supported')\n        group.add_argument('-t', '--test', action='store_true',\n                           help='perform a self-test')\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the emulator command.", "response": "def run(self, args):\n        \"\"\"Runs the emulator command.\n\n        Args:\n          self (EmulatorCommand): the ``EmulatorCommand`` instance\n          args (Namespace): arguments to parse\n\n        Returns:\n          ``None``\n        \"\"\"\n        jlink = pylink.JLink()\n\n        if args.test:\n            if jlink.test():\n                print('Self-test succeeded.')\n            else:\n                print('Self-test failed.')\n        elif args.list is None or args.list in ['usb', 'ip']:\n            host = pylink.JLinkHost.USB_OR_IP\n            if args.list == 'usb':\n                host = pylink.JLinkHost.USB\n            elif args.list == 'ip':\n                host = pylink.JLinkHost.IP\n\n            emulators = jlink.connected_emulators(host)\n            for (index, emulator) in enumerate(emulators):\n                if index > 0:\n                    print('')\n\n                print('Product Name: %s' % emulator.acProduct.decode())\n                print('Serial Number: %s' % emulator.SerialNumber)\n\n                usb = bool(emulator.Connection)\n                if not usb:\n                    print('Nickname: %s' % emulator.acNickname.decode())\n                    print('Firmware: %s' % emulator.acFWString.decode())\n\n                print('Connection: %s' % ('USB' if usb else 'IP'))\n\n                if not usb:\n                    print('IP Address: %s' % emulator.aIPAddr)\n        elif args.supported is not None:\n            device = args.supported[0]\n            num_supported_devices = jlink.num_supported_devices()\n            for i in range(num_supported_devices):\n                found_device = jlink.supported_device(i)\n                if device.lower() == found_device.name.lower():\n                    print('Device Name: %s' % device)\n                    print('Core ID: %s' % found_device.CoreId)\n                    print('Flash Address: %s' % found_device.FlashAddr)\n                    print('Flash Size: %s bytes' % found_device.FlashSize)\n                    print('RAM Address: %s' % found_device.RAMAddr)\n                    print('RAM Size: %s bytes' % found_device.RAMSize)\n                    print('Manufacturer: %s' % found_device.manufacturer)\n                    break\n            else:\n                print('%s is not supported :(' % device)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_arguments(self, parser):\n        group = parser.add_mutually_exclusive_group(required=True)\n        group.add_argument('-d', '--downgrade', action='store_true',\n                           help='downgrade the J-Link firmware')\n        group.add_argument('-u', '--upgrade', action='store_true',\n                           help='upgrade the J-Link firmware')\n        return self.add_common_arguments(parser, False)", "response": "Adds the arguments for the firmware command to the argument parser."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the firmware command.", "response": "def run(self, args):\n        \"\"\"Runs the firmware command.\n\n        Args:\n          self (FirmwareCommand): the ``FirmwareCommand`` instance\n          args (Namespace): arguments to parse\n\n        Returns:\n          ``None``\n        \"\"\"\n        jlink = self.create_jlink(args)\n        if args.downgrade:\n            if not jlink.firmware_newer():\n                print('DLL firmware is not older than J-Link firmware.')\n            else:\n                jlink.invalidate_firmware()\n\n                try:\n                    # Change to the firmware of the connected DLL.\n                    jlink.update_firmware()\n                except pylink.JLinkException as e:\n                    # On J-Link versions < 5.0.0, an exception will be thrown as\n                    # the connection will be lost, so we have to re-establish.\n                    jlink = self.create_jlink(args)\n\n                print('Firmware Downgraded: %s' % jlink.firmware_version)\n        elif args.upgrade:\n            if not jlink.firmware_outdated():\n                print('DLL firmware is not newer than J-Link firmware.')\n            else:\n                try:\n                    # Upgrade the firmware.\n                    jlink.update_firmware()\n                except pylink.JLinkException as e:\n                    # On J-Link versions < 5.0.0, an exception will be thrown as\n                    # the connection will be lost, so we have to re-establish.\n                    jlink = self.create_jlink(args)\n                print('Firmware Updated: %s' % jlink.firmware_version)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef name(self):\n        return ctypes.cast(self.sName, ctypes.c_char_p).value.decode()", "response": "Returns the name of the device."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the name of the manufacturer of the device.", "response": "def manufacturer(self):\n        \"\"\"Returns the name of the manufacturer of the device.\n\n        Args:\n          self (JLinkDeviceInfo): the ``JLinkDeviceInfo`` instance\n\n        Returns:\n          Manufacturer name.\n        \"\"\"\n        buf = ctypes.cast(self.sManu, ctypes.c_char_p).value\n        return buf.decode() if buf else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if this breakpoint is a software breakpoint otherwise False.", "response": "def software_breakpoint(self):\n        \"\"\"Returns whether this is a software breakpoint.\n\n        Args:\n          self (JLinkBreakpointInfo): the ``JLinkBreakpointInfo`` instance\n\n        Returns:\n          ``True`` if the breakpoint is a software breakpoint, otherwise\n          ``False``.\n        \"\"\"\n        software_types = [\n            enums.JLinkBreakpoint.SW_RAM,\n            enums.JLinkBreakpoint.SW_FLASH,\n            enums.JLinkBreakpoint.SW\n        ]\n        return any(self.Type & stype for stype in software_types)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload the SEGGER DLL from the Windows installation directory.", "response": "def find_library_windows(cls):\n        \"\"\"Loads the SEGGER DLL from the windows installation directory.\n\n        On Windows, these are found either under:\n          - ``C:\\\\Program Files\\\\SEGGER\\\\JLink``\n          - ``C:\\\\Program Files (x86)\\\\SEGGER\\\\JLink``.\n\n        Args:\n          cls (Library): the ``Library`` class\n\n        Returns:\n          The paths to the J-Link library files in the order that they are\n          found.\n        \"\"\"\n        dll = cls.get_appropriate_windows_sdk_name() + '.dll'\n        root = 'C:\\\\'\n        for d in os.listdir(root):\n            dir_path = os.path.join(root, d)\n\n            # Have to account for the different Program Files directories.\n            if d.startswith('Program Files') and os.path.isdir(dir_path):\n                dir_path = os.path.join(dir_path, 'SEGGER')\n                if not os.path.isdir(dir_path):\n                    continue\n\n                # Find all the versioned J-Link directories.\n                ds = filter(lambda x: x.startswith('JLink'), os.listdir(dir_path))\n                for jlink_dir in ds:\n                    # The DLL always has the same name, so if it is found, just\n                    # return it.\n                    lib_path = os.path.join(dir_path, jlink_dir, dll)\n                    if os.path.isfile(lib_path):\n                        yield lib_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the SEGGER DLL from the root directory. On Linux the SEGGER DLL is loaded from the root directory with the suffix _VERSION.", "response": "def find_library_linux(cls):\n        \"\"\"Loads the SEGGER DLL from the root directory.\n\n        On Linux, the SEGGER tools are installed under the ``/opt/SEGGER``\n        directory with versioned directories having the suffix ``_VERSION``.\n\n        Args:\n          cls (Library): the ``Library`` class\n\n        Returns:\n          The paths to the J-Link library files in the order that they are\n          found.\n        \"\"\"\n        dll = Library.JLINK_SDK_NAME\n        root = os.path.join('/', 'opt', 'SEGGER')\n\n        for (directory_name, subdirs, files) in os.walk(root):\n            fnames = []\n            x86_found = False\n            for f in files:\n                path = os.path.join(directory_name, f)\n                if os.path.isfile(path) and f.startswith(dll):\n                    fnames.append(f)\n                    if '_x86' in path:\n                        x86_found = True\n\n            for fname in fnames:\n                fpath = os.path.join(directory_name, fname)\n                if util.is_os_64bit():\n                    if '_x86' not in fname:\n                        yield fpath\n                elif x86_found:\n                    if '_x86' in fname:\n                        yield fpath\n                else:\n                    yield fpath"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_library_darwin(cls):\n        dll = Library.JLINK_SDK_NAME\n        root = os.path.join('/', 'Applications', 'SEGGER')\n        if not os.path.isdir(root):\n            return\n\n        for d in os.listdir(root):\n            dir_path = os.path.join(root, d)\n\n            # Navigate through each JLink directory.\n            if os.path.isdir(dir_path) and d.startswith('JLink'):\n                files = list(f for f in os.listdir(dir_path) if\n                             os.path.isfile(os.path.join(dir_path, f)))\n\n                # For versions >= 6.0.0 and < 5.0.0, this file will exist, so\n                # we want to use this one instead of the versioned one.\n                if (dll + '.dylib') in files:\n                    yield os.path.join(dir_path, dll + '.dylib')\n\n                # For versions >= 5.0.0 and < 6.0.0, there is no strictly\n                # linked library file, so try and find the versioned one.\n                for f in files:\n                    if f.startswith(dll):\n                        yield os.path.join(dir_path, f)", "response": "This method loads the SEGGER DLL from the installed applications."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload the default J - Link SDK DLL.", "response": "def load_default(self):\n        \"\"\"Loads the default J-Link SDK DLL.\n\n        The default J-Link SDK is determined by first checking if ``ctypes``\n        can find the DLL, then by searching the platform-specific paths.\n\n        Args:\n          self (Library): the ``Library`` instance\n\n        Returns:\n          ``True`` if the DLL was loaded, otherwise ``False``.\n        \"\"\"\n        path = ctypes_util.find_library(self._sdk)\n        if path is None:\n            # Couldn't find it the standard way.  Fallback to the non-standard\n            # way of finding the J-Link library.  These methods are operating\n            # system specific.\n            if self._windows or self._cygwin:\n                path = next(self.find_library_windows(), None)\n            elif sys.platform.startswith('linux'):\n                path = next(self.find_library_linux(), None)\n            elif sys.platform.startswith('darwin'):\n                path = next(self.find_library_darwin(), None)\n\n        if path is not None:\n            return self.load(path)\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load(self, path=None):\n        self.unload()\n\n        self._path = path or self._path\n\n        # Windows requires a proper suffix in order to load the library file,\n        # so it must be set here.\n        if self._windows or self._cygwin:\n            suffix = '.dll'\n        elif sys.platform.startswith('darwin'):\n            suffix = '.dylib'\n        else:\n            suffix = '.so'\n\n        # Copy the J-Link DLL to a temporary file.  This will be cleaned up the\n        # next time we load a DLL using this library or if this library is\n        # cleaned up.\n        tf = tempfile.NamedTemporaryFile(delete=False, suffix=suffix)\n        with open(tf.name, 'wb') as outputfile:\n            with open(self._path, 'rb') as inputfile:\n                outputfile.write(inputfile.read())\n\n        # This is needed to work around a WindowsError where the file is not\n        # being properly cleaned up after exiting the with statement.\n        tf.close()\n\n        self._temp = tf\n        self._lib = ctypes.cdll.LoadLibrary(tf.name)\n\n        if self._windows:\n            # The J-Link library uses a mix of __cdecl and __stdcall function\n            # calls.  While this is fine on a nix platform or in cygwin, this\n            # causes issues with Windows, where it expects the __stdcall\n            # methods to follow the standard calling convention.  As a result,\n            # we have to convert them to windows function calls.\n            self._winlib = ctypes.windll.LoadLibrary(tf.name)\n            for stdcall in self._standard_calls_:\n                if hasattr(self._winlib, stdcall):\n                    # Backwards compatibility.  Some methods do not exist on\n                    # older versions of the J-Link firmware, so ignore them in\n                    # these cases.\n                    setattr(self._lib, stdcall, getattr(self._winlib, stdcall))\n        return True", "response": "Loads the specified J - Link SDK DLL at the given path if any otherwise re - loads the current DLL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unload(self):\n        unloaded = False\n\n        if self._lib is not None:\n            if self._winlib is not None:\n                # ctypes passes integers as 32-bit C integer types, which will\n                # truncate the value of a 64-bit pointer in 64-bit python, so\n                # we have to change the FreeLibrary method to take a pointer\n                # instead of an integer handle.\n                ctypes.windll.kernel32.FreeLibrary.argtypes = (\n                    ctypes.c_void_p,\n                )\n\n                # On Windows we must free both loaded libraries before the\n                # temporary file can be cleaned up.\n                ctypes.windll.kernel32.FreeLibrary(self._lib._handle)\n                ctypes.windll.kernel32.FreeLibrary(self._winlib._handle)\n\n                self._lib = None\n                self._winlib = None\n\n                unloaded = True\n            else:\n                # On OSX and Linux, just release the library; it's not safe\n                # to close a dll that ctypes is using.\n                del self._lib\n                self._lib = None\n                unloaded = True\n\n        if self._temp is not None:\n            os.remove(self._temp.name)\n            self._temp = None\n\n        return unloaded", "response": "Unloads the library s DLL if it has been loaded."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _open(filename=None, mode='r'):\n    if not filename or filename == '-':\n        if not mode or 'r' in mode:\n            file = sys.stdin\n        elif 'w' in mode:\n            file = sys.stdout\n        else:\n            raise ValueError('Invalid mode for file: {}'.format(mode))\n    else:\n        file = open(filename, mode)\n\n    try:\n        yield file\n    finally:\n        if file not in (sys.stdin, sys.stdout):\n            file.close()", "response": "Open a file or sys. stdin depending on the provided filename."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_pkg_names(pkgs):\n    result = set()\n    with open(join(\"mapping\"), \"r\") as f:\n        data = dict(x.strip().split(\":\") for x in f)\n    for pkg in pkgs:\n        # Look up the mapped requirement. If a mapping isn't found,\n        # simply use the package name.\n        result.add(data.get(pkg, pkg))\n    # Return a sorted list for backward compatibility.\n    return sorted(result, key=lambda s: s.lower())", "response": "Get PyPI package names from a list of imports."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_font(prefix, ttf_filename, charmap_filename, directory=None):\n    return _instance().load_font(prefix, ttf_filename, charmap_filename, directory)", "response": "Loads a font file and the associated charmap."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the character map used for a given font.", "response": "def charmap(prefixed_name):\n    \"\"\"\n    Return the character map used for a given font.\n\n    Returns\n    -------\n    return_value: dict\n        The dictionary mapping the icon names to the corresponding unicode character.\n\n    \"\"\"\n    prefix, name = prefixed_name.split('.')\n    return _instance().charmap[prefix][name]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_global_defaults(**kwargs):\n\n    valid_options = [\n        'active', 'selected', 'disabled', 'on', 'off',\n        'on_active', 'on_selected', 'on_disabled',\n        'off_active', 'off_selected', 'off_disabled',\n        'color', 'color_on', 'color_off',\n        'color_active', 'color_selected', 'color_disabled',\n        'color_on_selected', 'color_on_active', 'color_on_disabled',\n        'color_off_selected', 'color_off_active', 'color_off_disabled',\n        'animation', 'offset', 'scale_factor',\n        ]\n\n    for kw in kwargs:\n        if kw in valid_options:\n            _default_options[kw] = kwargs[kw]\n        else:\n            error = \"Invalid option '{0}'\".format(kw)\n            raise KeyError(error)", "response": "Set global defaults for the options passed to the icon painter."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npaint a single icon.", "response": "def _paint_icon(self, iconic, painter, rect, mode, state, options):\n        \"\"\"Paint a single icon.\"\"\"\n        painter.save()\n        color = options['color']\n        char = options['char']\n\n        color_options = {\n            QIcon.On: {\n                QIcon.Normal: (options['color_on'], options['on']),\n                QIcon.Disabled: (options['color_on_disabled'],\n                                 options['on_disabled']),\n                QIcon.Active: (options['color_on_active'],\n                               options['on_active']),\n                QIcon.Selected: (options['color_on_selected'],\n                                 options['on_selected']) \n            },\n\n            QIcon.Off: {\n                QIcon.Normal: (options['color_off'], options['off']),\n                QIcon.Disabled: (options['color_off_disabled'],\n                                 options['off_disabled']),\n                QIcon.Active: (options['color_off_active'],\n                               options['off_active']),\n                QIcon.Selected: (options['color_off_selected'],\n                                 options['off_selected']) \n            }\n        }\n\n        color, char = color_options[state][mode]\n\n        painter.setPen(QColor(color))\n\n        # A 16 pixel-high icon yields a font size of 14, which is pixel perfect\n        # for font-awesome. 16 * 0.875 = 14\n        # The reason why the glyph size is smaller than the icon size is to\n        # account for font bearing.\n\n        draw_size = 0.875 * round(rect.height() * options['scale_factor'])\n        prefix = options['prefix']\n\n        # Animation setup hook\n        animation = options.get('animation')\n        if animation is not None:\n            animation.setup(self, painter, rect)\n\n        painter.setFont(iconic.font(prefix, draw_size))\n        if 'offset' in options:\n            rect = QRect(rect)\n            rect.translate(options['offset'][0] * rect.width(),\n                           options['offset'][1] * rect.height())\n\n        painter.setOpacity(options.get('opacity', 1.0))\n\n        painter.drawText(rect, Qt.AlignCenter | Qt.AlignVCenter, char)\n        painter.restore()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_font(self, prefix, ttf_filename, charmap_filename, directory=None):\n\n        def hook(obj):\n            result = {}\n            for key in obj:\n                result[key] = unichr(int(obj[key], 16))\n            return result\n\n        if directory is None:\n            directory = os.path.join(\n                os.path.dirname(os.path.realpath(__file__)), 'fonts')\n\n        # Load font\n        if QApplication.instance() is not None:\n            id_ = QFontDatabase.addApplicationFont(os.path.join(directory,\n                                                                ttf_filename))\n            loadedFontFamilies = QFontDatabase.applicationFontFamilies(id_)\n            if(loadedFontFamilies):\n                self.fontname[prefix] = loadedFontFamilies[0]\n            else:\n                raise FontError(u\"Font at '{0}' appears to be empty. \"\n                                \"If you are on Windows 10, please read \"\n                                \"https://support.microsoft.com/\"\n                                \"en-us/kb/3053676 \"\n                                \"to know how to prevent Windows from blocking \"\n                                \"the fonts that come with QtAwesome.\".format(\n                                        os.path.join(directory, ttf_filename)))\n\n            with open(os.path.join(directory, charmap_filename), 'r') as codes:\n                self.charmap[prefix] = json.load(codes, object_hook=hook)\n\n            # Verify that vendorized fonts are not corrupt\n            if not SYSTEM_FONTS:\n                ttf_hash = MD5_HASHES.get(ttf_filename, None)\n                if ttf_hash is not None:\n                    hasher = hashlib.md5()\n                    with open(os.path.join(directory, ttf_filename),\n                              'rb') as f:\n                        content = f.read()\n                        hasher.update(content)\n                    ttf_calculated_hash_code = hasher.hexdigest()\n                    if ttf_calculated_hash_code != ttf_hash:\n                        raise FontError(u\"Font is corrupt at: '{0}'\".format(\n                                        os.path.join(directory, ttf_filename)))", "response": "Loads a font file and the associated charmap."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef icon(self, *names, **kwargs):\n        cache_key = '{}{}'.format(names,kwargs)\n        if cache_key not in self.icon_cache:\n            options_list = kwargs.pop('options', [{}] * len(names))\n            general_options = kwargs\n\n            if len(options_list) != len(names):\n                error = '\"options\" must be a list of size {0}'.format(len(names))\n                raise Exception(error)\n\n            if QApplication.instance() is not None:\n                parsed_options = []\n                for i in range(len(options_list)):\n                    specific_options = options_list[i]\n                    parsed_options.append(self._parse_options(specific_options,\n                                                              general_options,\n                                                              names[i]))\n\n                # Process high level API\n                api_options = parsed_options\n\n                self.icon_cache[cache_key] = self._icon_by_painter(self.painter, api_options)\n            else:\n                warnings.warn(\"You need to have a running \"\n                              \"QApplication to use QtAwesome!\")\n                return QIcon()\n        return self.icon_cache[cache_key]", "response": "Return a QIcon object corresponding to the provided icon name."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a QFont corresponding to the given prefix and size.", "response": "def font(self, prefix, size):\n        \"\"\"Return a QFont corresponding to the given prefix and size.\"\"\"\n        font = QFont(self.fontname[prefix])\n        font.setPixelSize(size)\n        if prefix[-1] == 's':  # solid style\n            font.setStyleName('Solid')\n        return font"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the custom icon corresponding to the given name.", "response": "def _custom_icon(self, name, **kwargs):\n        \"\"\"Return the custom icon corresponding to the given name.\"\"\"\n        options = dict(_default_options, **kwargs)\n        if name in self.painters:\n            painter = self.painters[name]\n            return self._icon_by_painter(painter, options)\n        else:\n            return QIcon()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the icon corresponding to the given painter.", "response": "def _icon_by_painter(self, painter, options):\n        \"\"\"Return the icon corresponding to the given painter.\"\"\"\n        engine = CharIconEngine(self, painter, options)\n        return QIcon(engine)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rename_font(font_path, font_name):\n    tt = ttLib.TTFont(font_path)\n    namerecord_list = tt[\"name\"].names\n    variant = \"\"\n\n    # determine font variant for this file path from name record nameID 2\n    for record in namerecord_list:\n        if record.nameID == 2:\n            variant = (\n                record.toUnicode()\n            )  # cast to str type in Py 3, unicode type in Py 2\n            break\n\n    # test that a variant name was found in the OpenType tables of the font\n    if len(variant) == 0:\n        raise ValueError(\n            \"Unable to detect the font variant from the OpenType name table in: %s\" % font_path)\n\n    # used for the Postscript name in the name table (no spaces allowed)\n    postscript_font_name = font_name.replace(\" \", \"\")\n    # font family name\n    nameID1_string = font_name\n    # full font name\n    nameID4_string = font_name + \" \" + variant\n    # Postscript name\n    # - no spaces allowed in family name or the PostScript suffix. should be dash delimited\n    nameID6_string = postscript_font_name + \"-\" + variant.replace(\" \", \"\")\n\n    # modify the opentype table data in memory with updated values\n    for record in namerecord_list:\n        if record.nameID == 1:\n            record.string = nameID1_string\n        elif record.nameID == 4:\n            record.string = nameID4_string\n        elif record.nameID == 6:\n            record.string = nameID6_string\n\n    # write changes to the font file\n    try:\n        tt.save(font_path)\n    except:\n        raise RuntimeError(\n            \"ERROR: unable to write new name to OpenType tables for: %s\" % font_path)", "response": "Rename a font in OpenType tables."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef finalize_options(self):\n        assert bool(self.fa_version), 'FA version is mandatory for this command.'\n        if self.zip_path:\n            assert os.path.exists(self.zip_path), (\n                'Local zipfile does not exist: %s' % self.zip_path)", "response": "Validate the command options."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __print(self, msg):\n        self.announce(msg, level=distutils.log.INFO)", "response": "Shortcut for printing with the distutils logger."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a file object of the FA zip file.", "response": "def __zip_file(self):\n        \"\"\"Get a file object of the FA zip file.\"\"\"\n        if self.zip_path:\n            # If using a local file, just open it:\n            self.__print('Opening local zipfile: %s' % self.zip_path)\n            return open(self.zip_path, 'rb')\n\n        # Otherwise, download it and make a file object in-memory:\n        url = self.__release_url\n        self.__print('Downloading from URL: %s' % url)\n        response = urlopen(url)\n        return io.BytesIO(response.read())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __zipped_files_data(self):\n        files = {}\n        with zipfile.ZipFile(self.__zip_file) as thezip:\n            for zipinfo in thezip.infolist():\n                if zipinfo.filename.endswith('metadata/icons.json'):\n                    with thezip.open(zipinfo) as compressed_file:\n                        files['icons.json'] = compressed_file.read()\n                elif zipinfo.filename.endswith('.ttf'):\n                    # For the record, the paths usually look like this:\n                    # webfonts/fa-brands-400.ttf\n                    # webfonts/fa-regular-400.ttf\n                    # webfonts/fa-solid-900.ttf\n                    name = os.path.basename(zipinfo.filename)\n                    tokens = name.split('-')\n                    style = tokens[1]\n                    if style in self.FA_STYLES:\n                        with thezip.open(zipinfo) as compressed_file:\n                            files[style] = compressed_file.read()\n\n        # Safety checks:\n        assert all(style in files for style in self.FA_STYLES), \\\n            'Not all FA styles found! Update code is broken.'\n        assert 'icons.json' in files, 'icons.json not found! Update code is broken.'\n\n        return files", "response": "Get a dict of all files of interest from the FA release zipfile."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntraverse a path to find the Protobuf compiler", "response": "def find_protoc(path=os.environ['PATH']):\r\n    '''\r\n    Traverse a path ($PATH by default) to find the protoc compiler\r\n    '''\r\n    protoc_filename = 'protoc'\r\n\r\n    bin_search_paths = path.split(':') or []\r\n    for search_path in bin_search_paths:\r\n        bin_path = os.path.join(search_path, protoc_filename)\r\n        if os.path.isfile(bin_path) and os.access(bin_path, os.X_OK):\r\n            return bin_path\r\n\r\n    raise ProtocNotFound(\"Protobuf compiler not found\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nproduce a Protobuf module from a string description.", "response": "def from_string(proto_str):\r\n    '''\r\n    Produce a Protobuf module from a string description.\r\n\r\n    Return the module if successfully compiled, otherwise raise a BadProtobuf\r\n    exception.\r\n    '''\r\n    _, proto_file = tempfile.mkstemp(suffix='.proto')\r\n\r\n    with open(proto_file, 'w+') as proto_f:\r\n        proto_f.write(proto_str)\r\n\r\n    return from_file(proto_file)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load_module(path):\r\n    'Helper to load a Python file at path and return as a module'\r\n\r\n    module_name = os.path.splitext(os.path.basename(path))[0]\r\n\r\n    module = None\r\n    if sys.version_info.minor < 5:\r\n        loader = importlib.machinery.SourceFileLoader(module_name, path)\r\n        module = loader.load_module()\r\n    else:\r\n        spec = importlib.util.spec_from_file_location(module_name, path)\r\n        module = importlib.util.module_from_spec(spec)\r\n        spec.loader.exec_module(module)\r\n\r\n    return module", "response": "Helper to load a Python file at path and return as a module"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_file(proto_file):\r\n    '''\r\n    Take a filename |protoc_file|, compile it via the Protobuf\r\n    compiler, and import the module.\r\n\r\n    Return the module if successfully compiled, otherwise raise either\r\n    a ProtocNotFound or BadProtobuf exception.\r\n    '''\r\n    if not proto_file.endswith('.proto'):\r\n        raise BadProtobuf()\r\n\r\n    dest = tempfile.mkdtemp()\r\n    full_path = os.path.abspath(proto_file)\r\n    _compile_proto(full_path, dest)\r\n\r\n    filename = os.path.split(full_path)[-1]\r\n    name = re.search(r'^(.*)\\.proto$', filename).group(1)\r\n    target = os.path.join(dest, name+'_pb2.py')\r\n\r\n    return _load_module(target)", "response": "Returns a new instance of the class from a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns protobuf class types from an imported generated module.", "response": "def types_from_module(pb_module):\r\n    '''\r\n    Return protobuf class types from an imported generated module.\r\n    '''\r\n    types = pb_module.DESCRIPTOR.message_types_by_name\r\n    return [getattr(pb_module, name) for name in types]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log(self, obj):\n        '''\n        Commit an arbitrary (picklable) object to the log\n        '''\n        entries = self.get()\n        entries.append(obj)\n        # Only log the last |n| entries if set\n        if self._size > 0:\n            entries = entries[-self._size:]\n        self._write_entries(entries)", "response": "Commit an arbitrary ( picklable ) object to the log\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _resolve_child(self, path):\n        'Return a member generator by a dot-delimited path'\n        obj = self\n\n        for component in path.split('.'):\n            ptr = obj\n            if not isinstance(ptr, Permuter):\n                raise self.MessageNotFound(\"Bad element path [wrong type]\")\n\n            # pylint: disable=protected-access\n            found_gen = (_ for _ in ptr._generators if _.name() == component)\n\n            obj = next(found_gen, None)\n\n            if not obj:\n                raise self.MessageNotFound(\"Path '{}' unresolved to member.\"\n                                           .format(path))\n        return ptr, obj", "response": "Return a member generator by a dot - delimited path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a dependency between source and target via the action callable action.", "response": "def make_dependent(self, source, target, action):\n        '''\n        Create a dependency between path 'source' and path 'target' via the\n        callable 'action'.\n\n        >>> permuter._generators\n        [IterValueGenerator(one), IterValueGenerator(two)]\n        >>> permuter.make_dependent('one', 'two', lambda x: x + 1)\n\n        Going forward, 'two' will only contain values that are (one+1)\n        '''\n        if not self._generators:\n            return\n\n        src_permuter, src = self._resolve_child(source)\n        dest = self._resolve_child(target)[1]\n\n        # pylint: disable=protected-access\n        container = src_permuter._generators\n        idx = container.index(src)\n        container[idx] = DependentValueGenerator(src.name(), dest, action)\n\n        self._update_independent_generators()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self):\n        'Retrieve the most recent value generated'\n        # If you attempt to use a generator comprehension below, it will\n        # consume the StopIteration exception and just return an empty tuple,\n        # instead of stopping iteration normally\n        return tuple([(x.name(), x.get()) for x in self._generators])", "response": "Retrieve the most recent value generated"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _fuzzdb_integers(limit=0):\n    'Helper to grab some integers from fuzzdb'\n    path = os.path.join(BASE_PATH, 'integer-overflow/integer-overflows.txt')\n    stream = _open_fuzzdb_file(path)\n    for line in _limit_helper(stream, limit):\n        yield int(line.decode('utf-8'), 0)", "response": "Helper to grab some integers from fuzzdb"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _fuzzdb_get_strings(max_len=0):\n    'Helper to get all the strings from fuzzdb'\n\n    ignored = ['integer-overflow']\n\n    for subdir in pkg_resources.resource_listdir('protofuzz', BASE_PATH):\n        if subdir in ignored:\n            continue\n\n        path = '{}/{}'.format(BASE_PATH, subdir)\n        listing = pkg_resources.resource_listdir('protofuzz', path)\n        for filename in listing:\n            if not filename.endswith('.txt'):\n                continue\n\n            path = '{}/{}/{}'.format(BASE_PATH, subdir, filename)\n            source = _open_fuzzdb_file(path)\n            for line in source:\n                string = line.decode('utf-8').strip()\n                if not string or string.startswith('#'):\n                    continue\n                if max_len != 0 and len(line) > max_len:\n                    continue\n\n                yield string", "response": "Helper to get all the strings from fuzzdb"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting integers from fuzzdb database and return them as a generator", "response": "def get_integers(bitwidth, unsigned, limit=0):\n    '''\n    Get integers from fuzzdb database\n\n      bitwidth - The bitwidth that has to contain the integer\n      unsigned - Whether the type is unsigned\n      limit - Limit to |limit| results\n    '''\n    if unsigned:\n        start, stop = 0, ((1 << bitwidth) - 1)\n    else:\n        start, stop = (-(1 << bitwidth-1)), (1 << (bitwidth-1)-1)\n\n    for num in _fuzzdb_integers(limit):\n        if num >= start and num <= stop:\n            yield num"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_floats(bitwidth, limit=0):\n    '''\n    Return a number of interesting floating point values\n    '''\n    assert bitwidth in (32, 64, 80)\n\n    values = [0.0, -1.0, 1.0, -1231231231231.0123, 123123123123123.123]\n    for val in _limit_helper(values, limit):\n        yield val", "response": "Yields a number of interesting floating point values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _int_generator(descriptor, bitwidth, unsigned):\n    'Helper to create a basic integer value generator'\n    vals = list(values.get_integers(bitwidth, unsigned))\n    return gen.IterValueGenerator(descriptor.name, vals)", "response": "Helper to create a basic integer value generator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _string_generator(descriptor, max_length=0, limit=0):\n    'Helper to create a string generator'\n    vals = list(values.get_strings(max_length, limit))\n    return gen.IterValueGenerator(descriptor.name, vals)", "response": "Helper to create a string generator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _float_generator(descriptor, bitwidth):\n    'Helper to create floating point values'\n    return gen.IterValueGenerator(descriptor.name, values.get_floats(bitwidth))", "response": "Helper to create floating point values"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _enum_generator(descriptor):\n    'Helper to create protobuf enums'\n    vals = descriptor.enum_type.values_by_number.keys()\n    return gen.IterValueGenerator(descriptor.name, vals)", "response": "Helper to create protobuf enums"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef descriptor_to_generator(cls_descriptor, cls, limit=0):\n    'Convert a protobuf descriptor to a protofuzz generator for same type'\n\n    generators = []\n    for descriptor in cls_descriptor.fields_by_name.values():\n        generator = _prototype_to_generator(descriptor, cls)\n\n        if limit != 0:\n            generator.set_limit(limit)\n\n        generators.append(generator)\n\n    obj = cls(cls_descriptor.name, *generators)\n    return obj", "response": "Convert a protobuf descriptor to a protofuzz generator for same type"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a protobuf module to a dict of generators.", "response": "def _module_to_generators(pb_module):\n    '''\n    Convert a protobuf module to a dict of generators.\n\n    This is typically used with modules that contain multiple type definitions.\n    '''\n    if not pb_module:\n        return None\n    message_types = pb_module.DESCRIPTOR.message_types_by_name\n    return {k: ProtobufGenerator(v) for k, v in message_types.items()}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a dependency between source and target via callable action.", "response": "def add_dependency(self, source, target, action):\n        '''\n        Create a dependency between fields source and target via callable\n        action.\n\n        >>> permuter = protofuzz.from_description_string(\"\"\"\n        ...   message Address {\n        ...       required uint32 one = 1;\n        ...       required uint32 two = 2;\n        ...   }\"\"\")['Address']\n        >>> permuter.add_dependency('one', 'two', lambda val: max(0,val-1))\n        >>> for obj in permuter.linear():\n        ...   print(\"obj = {}\".format(obj))\n        ...\n        obj = one: 0\n        two: 1\n\n        obj = one: 256\n        two: 257\n\n        obj = one: 4096\n        two: 4097\n\n        obj = one: 1073741823\n        two: 1073741824\n\n\n        '''\n        self._dependencies.append((source, target, action))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint Compare report. :return: None", "response": "def print_report(self):\n        \"\"\"\n        Print Compare report.\n\n        :return: None\n        \"\"\"\n        report = compare_report_print(\n            self.sorted, self.scores, self.best_name)\n        print(report)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_report(\n            self,\n            name,\n            address=True):\n        \"\"\"\n        Save Compare report in .comp (flat file format).\n\n        :param name: filename\n        :type name : str\n        :param address: flag for address return\n        :type address : bool\n        :return: saving Status as dict {\"Status\":bool , \"Message\":str}\n        \"\"\"\n        try:\n            message = None\n            file = open(name + \".comp\", \"w\")\n            report = compare_report_print(\n                self.sorted, self.scores, self.best_name)\n            file.write(report)\n            file.close()\n            if address:\n                message = os.path.join(os.getcwd(), name + \".comp\")\n            return {\"Status\": True, \"Message\": message}\n        except Exception as e:\n            return {\"Status\": False, \"Message\": str(e)}", "response": "Save Compare report in. comp format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ACC_calc(TP, TN, FP, FN):\n    try:\n        result = (TP + TN) / (TP + TN + FN + FP)\n        return result\n    except ZeroDivisionError:\n        return \"None\"", "response": "Calculate accuracy of a node in a cluster."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef F_calc(TP, FP, FN, beta):\n    try:\n        result = ((1 + (beta)**2) * TP) / \\\n            ((1 + (beta)**2) * TP + FP + (beta**2) * FN)\n        return result\n    except ZeroDivisionError:\n        return \"None\"", "response": "Calculate F - score."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates MCC for a given TN FP and FN.", "response": "def MCC_calc(TP, TN, FP, FN):\n    \"\"\"\n    Calculate MCC (Matthews correlation coefficient).\n\n    :param TP: true positive\n    :type TP : int\n    :param TN: true negative\n    :type TN : int\n    :param FP: false positive\n    :type FP : int\n    :param FN: false negative\n    :type FN : int\n    :return: MCC as float\n    \"\"\"\n    try:\n        result = (TP * TN - FP * FN) / \\\n            (math.sqrt((TP + FP) * (TP + FN) * (TN + FP) * (TN + FN)))\n        return result\n    except ZeroDivisionError:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef G_calc(item1, item2):\n    try:\n        result = math.sqrt(item1 * item2)\n        return result\n    except Exception:\n        return \"None\"", "response": "Calculate G - measure & G - mean."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef RACC_calc(TOP, P, POP):\n    try:\n        result = (TOP * P) / ((POP) ** 2)\n        return result\n    except Exception:\n        return \"None\"", "response": "Calculate random accuracy.\n\n    :param TOP: test outcome positive\n    :type TOP : int\n    :param P:  condition positive\n    :type P : int\n    :param POP: population\n    :type POP:int\n    :return: RACC as float"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef RACCU_calc(TOP, P, POP):\n    try:\n        result = ((TOP + P) / (2 * POP))**2\n        return result\n    except Exception:\n        return \"None\"", "response": "Calculate RACCU for a single node."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef IS_calc(TP, FP, FN, POP):\n    try:\n        result = -math.log(((TP + FN) / POP), 2) + \\\n            math.log((TP / (TP + FP)), 2)\n        return result\n    except Exception:\n        return \"None\"", "response": "Calculate IS ( Information score."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the misclassification probability of classifying a single object.", "response": "def CEN_misclassification_calc(\n        table,\n        TOP,\n        P,\n        i,\n        j,\n        subject_class,\n        modified=False):\n    \"\"\"\n    Calculate misclassification probability of classifying.\n\n    :param table: input matrix\n    :type table : dict\n    :param TOP: test outcome positive\n    :type TOP : int\n    :param P: condition positive\n    :type P : int\n    :param i: table row index (class name)\n    :type i : any valid type\n    :param j: table col index (class name)\n    :type j : any valid type\n    :param subject_class: subject to class (class name)\n    :type subject_class: any valid type\n    :param modified : modified mode flag\n    :type modified : bool\n    :return: misclassification probability of classifying as float\n    \"\"\"\n    try:\n        result = TOP + P\n        if modified:\n            result -= table[subject_class][subject_class]\n        result = table[i][j] / result\n        return result\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef CEN_calc(classes, table, TOP, P, class_name, modified=False):\n    try:\n        result = 0\n        class_number = len(classes)\n        for k in classes:\n            if k != class_name:\n                P_j_k = CEN_misclassification_calc(\n                    table, TOP, P, class_name, k, class_name, modified)\n                P_k_j = CEN_misclassification_calc(\n                    table, TOP, P, k, class_name, class_name, modified)\n                if P_j_k != 0:\n                    result += P_j_k * math.log(P_j_k, 2 * (class_number - 1))\n                if P_k_j != 0:\n                    result += P_k_j * math.log(P_k_j, 2 * (class_number - 1))\n        if result != 0:\n            result = result * (-1)\n        return result\n    except Exception:\n        return \"None\"", "response": "Calculate the CEN of a single class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dInd_calc(TNR, TPR):\n    try:\n        result = math.sqrt(((1 - TNR)**2) + ((1 - TPR)**2))\n        return result\n    except Exception:\n        return \"None\"", "response": "Calculate dInd of a specificity or true positive rate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef DP_calc(TPR, TNR):\n    try:\n        X = TPR / (1 - TPR)\n        Y = TNR / (1 - TNR)\n        return (math.sqrt(3) / math.pi) * (math.log(X, 10) + math.log(Y, 10))\n    except Exception:\n        return \"None\"", "response": "Calculate the DP of a single resource in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef OP_calc(ACC, TPR, TNR):\n    try:\n        RI = abs(TNR - TPR) / (TPR + TNR)\n        return ACC - RI\n    except Exception:\n        return \"None\"", "response": "Calculate OP for a specificity."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate IBA for a given TPR and TNR.", "response": "def IBA_calc(TPR, TNR, alpha=1):\n    \"\"\"\n    Calculate IBA (Index of balanced accuracy).\n\n    :param TNR: specificity or true negative rate\n    :type TNR : float\n    :param TPR: sensitivity, recall, hit rate, or true positive rate\n    :type TPR : float\n    :param alpha : alpha coefficient\n    :type alpha : float\n    :return: IBA as float\n    \"\"\"\n    try:\n        IBA = (1 + alpha * (TPR - TNR)) * TPR * TNR\n        return IBA\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate BCD for a set of test outcomes.", "response": "def BCD_calc(TOP, P, AM):\n    \"\"\"\n    Calculate BCD (Bray-Curtis dissimilarity).\n\n    :param TOP: test outcome positive\n    :type TOP : dict\n    :param P: condition positive\n    :type P : dict\n    :param AM: Automatic/Manual\n    :type AM : int\n    :return: BCD as float\n    \"\"\"\n    try:\n        TOP_sum = sum(TOP.values())\n        P_sum = sum(P.values())\n        return abs(AM) / (P_sum + TOP_sum)\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns all class statistics for a single object.", "response": "def class_statistics(TP, TN, FP, FN, classes, table):\n    \"\"\"\n    Return all class statistics.\n\n    :param TP: true positive dict for all classes\n    :type TP : dict\n    :param TN: true negative dict for all classes\n    :type TN : dict\n    :param FP: false positive dict for all classes\n    :type FP : dict\n    :param FN: false negative dict for all classes\n    :type FN : dict\n    :param classes: classes\n    :type classes : list\n    :param table: input matrix\n    :type table : dict\n    :return: result as dict\n    \"\"\"\n    TPR = {}\n    TNR = {}\n    PPV = {}\n    NPV = {}\n    FNR = {}\n    FPR = {}\n    FDR = {}\n    FOR = {}\n    ACC = {}\n    F1_SCORE = {}\n    MCC = {}\n    BM = {}\n    MK = {}\n    PLR = {}\n    NLR = {}\n    DOR = {}\n    POP = {}\n    P = {}\n    N = {}\n    TOP = {}\n    TON = {}\n    PRE = {}\n    G = {}\n    RACC = {}\n    F05_Score = {}\n    F2_Score = {}\n    ERR = {}\n    RACCU = {}\n    Jaccrd_Index = {}\n    IS = {}\n    CEN = {}\n    MCEN = {}\n    AUC = {}\n    dInd = {}\n    sInd = {}\n    DP = {}\n    Y = {}\n    PLRI = {}\n    DPI = {}\n    AUCI = {}\n    GI = {}\n    LS = {}\n    AM = {}\n    BCD = {}\n    OP = {}\n    IBA = {}\n    GM = {}\n    for i in TP.keys():\n        POP[i] = TP[i] + TN[i] + FP[i] + FN[i]\n        P[i] = TP[i] + FN[i]\n        N[i] = TN[i] + FP[i]\n        TOP[i] = TP[i] + FP[i]\n        TON[i] = TN[i] + FN[i]\n        TPR[i] = TTPN_calc(TP[i], FN[i])\n        TNR[i] = TTPN_calc(TN[i], FP[i])\n        PPV[i] = TTPN_calc(TP[i], FP[i])\n        NPV[i] = TTPN_calc(TN[i], FN[i])\n        FNR[i] = FXR_calc(TPR[i])\n        FPR[i] = FXR_calc(TNR[i])\n        FDR[i] = FXR_calc(PPV[i])\n        FOR[i] = FXR_calc(NPV[i])\n        ACC[i] = ACC_calc(TP[i], TN[i], FP[i], FN[i])\n        F1_SCORE[i] = F_calc(TP[i], FP[i], FN[i], 1)\n        F05_Score[i] = F_calc(TP[i], FP[i], FN[i], 0.5)\n        F2_Score[i] = F_calc(TP[i], FP[i], FN[i], 2)\n        MCC[i] = MCC_calc(TP[i], TN[i], FP[i], FN[i])\n        BM[i] = MK_BM_calc(TPR[i], TNR[i])\n        MK[i] = MK_BM_calc(PPV[i], NPV[i])\n        PLR[i] = LR_calc(TPR[i], FPR[i])\n        NLR[i] = LR_calc(FNR[i], TNR[i])\n        DOR[i] = LR_calc(PLR[i], NLR[i])\n        PRE[i] = PRE_calc(P[i], POP[i])\n        G[i] = G_calc(PPV[i], TPR[i])\n        RACC[i] = RACC_calc(TOP[i], P[i], POP[i])\n        ERR[i] = ERR_calc(ACC[i])\n        RACCU[i] = RACCU_calc(TOP[i], P[i], POP[i])\n        Jaccrd_Index[i] = jaccard_index_calc(TP[i], TOP[i], P[i])\n        IS[i] = IS_calc(TP[i], FP[i], FN[i], POP[i])\n        CEN[i] = CEN_calc(classes, table, TOP[i], P[i], i)\n        MCEN[i] = CEN_calc(classes, table, TOP[i], P[i], i, True)\n        AUC[i] = AUC_calc(TNR[i], TPR[i])\n        dInd[i] = dInd_calc(TNR[i], TPR[i])\n        sInd[i] = sInd_calc(dInd[i])\n        DP[i] = DP_calc(TPR[i], TNR[i])\n        Y[i] = BM[i]\n        PLRI[i] = PLR_analysis(PLR[i])\n        DPI[i] = DP_analysis(DP[i])\n        AUCI[i] = AUC_analysis(AUC[i])\n        GI[i] = GI_calc(AUC[i])\n        LS[i] = lift_calc(PPV[i], PRE[i])\n        AM[i] = AM_calc(TOP[i], P[i])\n        OP[i] = OP_calc(ACC[i], TPR[i], TNR[i])\n        IBA[i] = IBA_calc(TPR[i], TNR[i])\n        GM[i] = G_calc(TNR[i], TPR[i])\n    for i in TP.keys():\n        BCD[i] = BCD_calc(TOP, P, AM[i])\n    result = {\n        \"TPR\": TPR,\n        \"TNR\": TNR,\n        \"PPV\": PPV,\n        \"NPV\": NPV,\n        \"FNR\": FNR,\n        \"FPR\": FPR,\n        \"FDR\": FDR,\n        \"FOR\": FOR,\n        \"ACC\": ACC,\n        \"F1\": F1_SCORE,\n        \"MCC\": MCC,\n        \"BM\": BM,\n        \"MK\": MK,\n        \"PLR\": PLR,\n        \"NLR\": NLR,\n        \"DOR\": DOR,\n        \"TP\": TP,\n        \"TN\": TN,\n        \"FP\": FP,\n        \"FN\": FN,\n        \"POP\": POP,\n        \"P\": P,\n        \"N\": N,\n        \"TOP\": TOP,\n        \"TON\": TON,\n        \"PRE\": PRE,\n        \"G\": G,\n        \"RACC\": RACC,\n        \"F0.5\": F05_Score,\n        \"F2\": F2_Score,\n        \"ERR\": ERR,\n        \"RACCU\": RACCU,\n        \"J\": Jaccrd_Index,\n        \"IS\": IS,\n        \"CEN\": CEN,\n        \"MCEN\": MCEN,\n        \"AUC\": AUC,\n        \"sInd\": sInd,\n        \"dInd\": dInd,\n        \"DP\": DP,\n        \"Y\": Y,\n        \"PLRI\": PLRI,\n        \"DPI\": DPI,\n        \"AUCI\": AUCI,\n        \"GI\": GI,\n        \"LS\": LS,\n        \"AM\": AM,\n        \"BCD\": BCD,\n        \"OP\": OP,\n        \"IBA\": IBA,\n        \"GM\": GM}\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn HTML report file first lines.", "response": "def html_init(name):\n    \"\"\"\n    Return HTML report file first lines.\n\n    :param name: name of file\n    :type name : str\n    :return: html_init as str\n    \"\"\"\n    result = \"\"\n    result += \"<html>\\n\"\n    result += \"<head>\\n\"\n    result += \"<title>\" + str(name) + \"</title>\\n\"\n    result += \"</head>\\n\"\n    result += \"<body>\\n\"\n    result += '<h1 style=\"border-bottom:1px solid ' \\\n              'black;text-align:center;\">PyCM Report</h1>'\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef html_dataset_type(is_binary, is_imbalanced):\n    result = \"<h2>Dataset Type : </h2>\\n\"\n    balance_type = \"Balanced\"\n    class_type = \"Binary Classification\"\n    if is_imbalanced:\n        balance_type = \"Imbalanced\"\n    if not is_binary:\n        class_type = \"Multi-Class Classification\"\n    result += \"<ul>\\n\\n<li>{0}</li>\\n\\n<li>{1}</li>\\n</ul>\\n\".format(\n        class_type, balance_type)\n    result += \"<p>{0}</p>\\n\".format(RECOMMEND_HTML_MESSAGE)\n    result += \"<p>{0}</p>\\n\".format(RECOMMEND_HTML_MESSAGE2)\n\n    return result", "response": "Return HTML report file dataset type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck input color format.", "response": "def color_check(color):\n    \"\"\"\n    Check input color format.\n\n    :param color: input color\n    :type color : tuple\n    :return: color as list\n    \"\"\"\n    if isinstance(color, (tuple, list)):\n        if all(map(lambda x: isinstance(x, int), color)):\n            if all(map(lambda x: x < 256, color)):\n                return list(color)\n    if isinstance(color, str):\n        color_lower = color.lower()\n        if color_lower in TABLE_COLOR.keys():\n            return TABLE_COLOR[color_lower]\n    return [0, 0, 0]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn background color of each cell of table.", "response": "def html_table_color(row, item, color=(0, 0, 0)):\n    \"\"\"\n    Return background color of each cell of table.\n\n    :param row: row dictionary\n    :type row : dict\n    :param item: cell number\n    :type item : int\n    :param color : input color\n    :type color : tuple\n    :return: background color as list [R,G,B]\n    \"\"\"\n    result = [0, 0, 0]\n    color_list = color_check(color)\n    max_color = max(color_list)\n    back_color_index = 255 - int((item / (sum(list(row.values())) + 1)) * 255)\n    for i in range(3):\n        result[i] = back_color_index - (max_color - color_list[i])\n        if result[i] < 0:\n            result[i] = 0\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef html_table(classes, table, rgb_color, normalize=False):\n    result = \"\"\n    result += \"<h2>Confusion Matrix \"\n    if normalize:\n        result += \"(Normalized)\"\n    result += \": </h2>\\n\"\n    result += '<table>\\n'\n    result += '<tr  align=\"center\">' + \"\\n\"\n    result += '<td>Actual</td>\\n'\n    result += '<td>Predict\\n'\n    table_size = str((len(classes) + 1) * 7) + \"em\"\n    result += '<table style=\"border:1px solid black;border-collapse: collapse;height:{0};width:{0};\">\\n'\\\n        .format(table_size)\n    classes.sort()\n    result += '<tr align=\"center\">\\n<td></td>\\n'\n    part_2 = \"\"\n    for i in classes:\n        class_name = str(i)\n        if len(class_name) > 6:\n            class_name = class_name[:4] + \"...\"\n        result += '<td style=\"border:1px solid ' \\\n                  'black;padding:10px;height:7em;width:7em;\">' + \\\n            class_name + '</td>\\n'\n        part_2 += '<tr align=\"center\">\\n'\n        part_2 += '<td style=\"border:1px solid ' \\\n                  'black;padding:10px;height:7em;width:7em;\">' + \\\n            class_name + '</td>\\n'\n        for j in classes:\n            item = table[i][j]\n            color = \"black;\"\n            back_color = html_table_color(table[i], item, rgb_color)\n            if min(back_color) < 128:\n                color = \"white\"\n            part_2 += '<td style=\"background-color:\trgb({0},{1},{2});color:{3};padding:10px;height:7em;width:7em;\">'.format(\n                str(back_color[0]), str(back_color[1]), str(back_color[2]), color) + str(item) + '</td>\\n'\n        part_2 += \"</tr>\\n\"\n    result += '</tr>\\n'\n    part_2 += \"</table>\\n</td>\\n</tr>\\n</table>\\n\"\n    result += part_2\n    return result", "response": "Return HTML report file confusion matrix."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef html_overall_stat(\n        overall_stat,\n        digit=5,\n        overall_param=None,\n        recommended_list=()):\n    \"\"\"\n    Return HTML report file overall stat.\n\n    :param overall_stat: overall stat\n    :type overall_stat : dict\n    :param digit: scale (the number of digits to the right of the decimal point in a number.)\n    :type digit : int\n    :param overall_param : Overall parameters list for print, Example : [\"Kappa\",\"Scott PI]\n    :type overall_param : list\n    :param recommended_list: recommended statistics list\n    :type recommended_list : list or tuple\n    :return: html_overall_stat as str\n    \"\"\"\n    result = \"\"\n    result += \"<h2>Overall Statistics : </h2>\\n\"\n    result += '<table style=\"border:1px solid black;border-collapse: collapse;\">\\n'\n    overall_stat_keys = sorted(overall_stat.keys())\n    if isinstance(overall_param, list):\n        if set(overall_param) <= set(overall_stat_keys):\n            overall_stat_keys = sorted(overall_param)\n    if len(overall_stat_keys) < 1:\n        return \"\"\n    for i in overall_stat_keys:\n        background_color = DEFAULT_BACKGROUND_COLOR\n        if i in recommended_list:\n            background_color = RECOMMEND_BACKGROUND_COLOR\n        result += '<tr align=\"center\">\\n'\n        result += '<td style=\"border:1px solid black;padding:4px;text-align:left;background-color:{};\"><a href=\"'.format(\n            background_color) + DOCUMENT_ADR + PARAMS_LINK[i] + '\" style=\"text-decoration:None;\">' + str(i) + '</a></td>\\n'\n        if i in BENCHMARK_LIST:\n            background_color = BENCHMARK_COLOR[overall_stat[i]]\n            result += '<td style=\"border:1px solid black;padding:4px;background-color:{};\">'.format(\n                background_color)\n        else:\n            result += '<td style=\"border:1px solid black;padding:4px;\">'\n        result += rounder(overall_stat[i], digit) + '</td>\\n'\n        result += \"</tr>\\n\"\n    result += \"</table>\\n\"\n    return result", "response": "Return HTML report file overall stat."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn HTML report file class_stat.", "response": "def html_class_stat(\n        classes,\n        class_stat,\n        digit=5,\n        class_param=None,\n        recommended_list=()):\n    \"\"\"\n    Return HTML report file class_stat.\n\n    :param classes: matrix classes\n    :type classes: list\n    :param class_stat: class stat\n    :type class_stat:dict\n    :param digit: scale (the number of digits to the right of the decimal point in a number.)\n    :type digit : int\n    :param class_param : Class parameters list for print, Example : [\"TPR\",\"TNR\",\"AUC\"]\n    :type class_param : list\n    :param recommended_list: recommended statistics list\n    :type recommended_list : list or tuple\n    :return: html_class_stat as str\n    \"\"\"\n    result = \"\"\n    result += \"<h2>Class Statistics : </h2>\\n\"\n    result += '<table style=\"border:1px solid black;border-collapse: collapse;\">\\n'\n    result += '<tr align=\"center\">\\n<td>Class</td>\\n'\n    for i in classes:\n        result += '<td style=\"border:1px solid black;padding:4px;border-collapse: collapse;\">' + \\\n            str(i) + '</td>\\n'\n    result += '<td>Description</td>\\n'\n    result += '</tr>\\n'\n    class_stat_keys = sorted(class_stat.keys())\n    if isinstance(class_param, list):\n        if set(class_param) <= set(class_stat_keys):\n            class_stat_keys = class_param\n    classes.sort()\n    if len(classes) < 1 or len(class_stat_keys) < 1:\n        return \"\"\n    for i in class_stat_keys:\n        background_color = DEFAULT_BACKGROUND_COLOR\n        if i in recommended_list:\n            background_color = RECOMMEND_BACKGROUND_COLOR\n        result += '<tr align=\"center\" style=\"border:1px solid black;border-collapse: collapse;\">\\n'\n        result += '<td style=\"border:1px solid black;padding:4px;border-collapse: collapse;background-color:{};\"><a href=\"'.format(\n            background_color) + DOCUMENT_ADR + PARAMS_LINK[i] + '\" style=\"text-decoration:None;\">' + str(i) + '</a></td>\\n'\n        for j in classes:\n            if i in BENCHMARK_LIST:\n                background_color = BENCHMARK_COLOR[class_stat[i][j]]\n                result += '<td style=\"border:1px solid black;padding:4px;border-collapse: collapse;background-color:{};\">'.format(\n                    background_color)\n            else:\n                result += '<td style=\"border:1px solid black;padding:4px;border-collapse: collapse;\">'\n            result += rounder(class_stat[i][j], digit) + '</td>\\n'\n        params_text = PARAMS_DESCRIPTION[i]\n        if i not in CAPITALIZE_FILTER:\n            params_text = params_text.capitalize()\n        result += '<td style=\"border:1px solid black;padding:4px;border-collapse: collapse;text-align:left;\">' + \\\n                  params_text + '</td>\\n'\n        result += \"</tr>\\n\"\n    result += \"</table>\\n\"\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef table_print(classes, table):\n    classes_len = len(classes)\n    table_list = []\n    for key in classes:\n        table_list.extend(list(table[key].values()))\n    table_list.extend(classes)\n    table_max_length = max(map(len, map(str, table_list)))\n    shift = \"%-\" + str(7 + table_max_length) + \"s\"\n    result = shift % \"Predict\" + shift * \\\n        classes_len % tuple(map(str, classes)) + \"\\n\"\n    result = result + \"Actual\\n\"\n    classes.sort()\n    for key in classes:\n        row = [table[key][i] for i in classes]\n        result += shift % str(key) + \\\n            shift * classes_len % tuple(map(str, row)) + \"\\n\\n\"\n    if classes_len >= CLASS_NUMBER_THRESHOLD:\n        result += \"\\n\" + \"Warning : \" + CLASS_NUMBER_WARNING + \"\\n\"\n    return result", "response": "Print a confusion matrix."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn matrix as csv data.", "response": "def csv_matrix_print(classes, table):\n    \"\"\"\n    Return matrix as csv data.\n\n    :param classes: classes list\n    :type classes:list\n    :param table: table\n    :type table:dict\n    :return:\n    \"\"\"\n    result = \"\"\n    classes.sort()\n    for i in classes:\n        for j in classes:\n            result += str(table[i][j]) + \",\"\n        result = result[:-1] + \"\\n\"\n    return result[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a csv file data for each class.", "response": "def csv_print(classes, class_stat, digit=5, class_param=None):\n    \"\"\"\n    Return csv file data.\n\n    :param classes: classes list\n    :type classes:list\n    :param class_stat: statistic result for each class\n    :type class_stat:dict\n    :param digit: scale (the number of digits to the right of the decimal point in a number.)\n    :type digit : int\n    :param class_param : class parameters list for print, Example : [\"TPR\",\"TNR\",\"AUC\"]\n    :type class_param : list\n    :return: csv file data as str\n    \"\"\"\n    result = \"Class\"\n    classes.sort()\n    for item in classes:\n        result += ',\"' + str(item) + '\"'\n    result += \"\\n\"\n    class_stat_keys = sorted(class_stat.keys())\n    if isinstance(class_param, list):\n        if set(class_param) <= set(class_stat_keys):\n            class_stat_keys = class_param\n    if len(class_stat_keys) < 1 or len(classes) < 1:\n        return \"\"\n    for key in class_stat_keys:\n        row = [rounder(class_stat[key][i], digit) for i in classes]\n        result += key + \",\" + \",\".join(row)\n        result += \"\\n\"\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting a printable statistics table.", "response": "def stat_print(\n        classes,\n        class_stat,\n        overall_stat,\n        digit=5,\n        overall_param=None,\n        class_param=None):\n    \"\"\"\n    Return printable statistics table.\n\n    :param classes: classes list\n    :type classes:list\n    :param class_stat: statistic result for each class\n    :type class_stat:dict\n    :param overall_stat : overall statistic result\n    :type overall_stat:dict\n    :param digit: scale (the number of digits to the right of the decimal point in a number.)\n    :type digit : int\n    :param overall_param : overall parameters list for print, Example : [\"Kappa\",\"Scott PI]\n    :type overall_param : list\n    :param class_param : class parameters list for print, Example : [\"TPR\",\"TNR\",\"AUC\"]\n    :type class_param : list\n    :return: printable result as str\n    \"\"\"\n    shift = max(map(len, PARAMS_DESCRIPTION.values())) + 5\n    classes_len = len(classes)\n    overall_stat_keys = sorted(overall_stat.keys())\n    result = \"\"\n    if isinstance(overall_param, list):\n        if set(overall_param) <= set(overall_stat_keys):\n            overall_stat_keys = sorted(overall_param)\n    if len(overall_stat_keys) > 0:\n        result = \"Overall Statistics : \" + \"\\n\\n\"\n        for key in overall_stat_keys:\n            result += key + \" \" * (shift - len(key) + 7) + \\\n                rounder(overall_stat[key], digit) + \"\\n\"\n    class_stat_keys = sorted(class_stat.keys())\n    if isinstance(class_param, list):\n        if set(class_param) <= set(class_stat_keys):\n            class_stat_keys = sorted(class_param)\n    classes.sort()\n    if len(class_stat_keys) > 0 and len(classes) > 0:\n        class_shift = max(\n            max(map(lambda x: len(str(x)), classes)) + 5, digit + 6, 14)\n        class_shift_format = \"%-\" + str(class_shift) + \"s\"\n        result += \"\\nClass Statistics :\\n\\n\"\n        result += \"Classes\" + shift * \" \" + class_shift_format * \\\n            classes_len % tuple(map(str, classes)) + \"\\n\"\n        rounder_map = partial(rounder, digit=digit)\n        for key in class_stat_keys:\n            row = [class_stat[key][i] for i in classes]\n            params_text = PARAMS_DESCRIPTION[key]\n            if key not in CAPITALIZE_FILTER:\n                params_text = params_text.capitalize()\n            result += key + \"(\" + params_text + \")\" + \" \" * (\n                shift - len(key) - len(PARAMS_DESCRIPTION[key]) + 5) + class_shift_format * classes_len % tuple(\n                map(rounder_map, row)) + \"\\n\"\n    if classes_len >= CLASS_NUMBER_THRESHOLD:\n        result += \"\\n\" + \"Warning : \" + CLASS_NUMBER_WARNING + \"\\n\"\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning compare report. :param sorted_list: sorted list of cm's :type sorted_list: list :param scores: scores of cm's :type scores: dict :param best_name: best cm name :type best_name: str :return: printable result as str", "response": "def compare_report_print(sorted_list, scores, best_name):\n    \"\"\"\n    Return compare report.\n\n    :param sorted_list: sorted list of cm's\n    :type sorted_list: list\n    :param scores: scores of cm's\n    :type scores: dict\n    :param best_name: best cm name\n    :type best_name: str\n    :return: printable result as str\n    \"\"\"\n    title_items = [\"Rank\", \"Name\", \"Class-Score\", \"Overall-Score\"]\n    class_scores_len = map(lambda x: len(\n        str(x[\"class\"])), list(scores.values()))\n    shifts = [\"%-\" +\n              str(len(sorted_list) +\n                  4) +\n              \"s\", \"%-\" +\n              str(max(map(lambda x: len(str(x)), sorted_list)) +\n                  4) +\n              \"s\", \"%-\" +\n              str(max(class_scores_len) + 11) + \"s\"]\n    result = \"\"\n    result += \"Best : \" + str(best_name) + \"\\n\\n\"\n    result += (\"\".join(shifts)\n               ) % tuple(title_items[:-1]) + title_items[-1] + \"\\n\"\n    prev_rank = 0\n    for index, cm in enumerate(sorted_list):\n        rank = index\n        if scores[sorted_list[rank]] == scores[sorted_list[prev_rank]]:\n            rank = prev_rank\n        result += (\"\".join(shifts)) % (str(rank + 1), str(cm),\n                                       str(scores[cm][\"class\"])) + str(scores[cm][\"overall\"]) + \"\\n\"\n        prev_rank = rank\n    if best_name is None:\n        result += \"\\nWarning: \" + COMPARE_RESULT_WARNING\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef online_help(param=None):\n    try:\n        PARAMS_LINK_KEYS = sorted(PARAMS_LINK.keys())\n        if param in PARAMS_LINK_KEYS:\n            webbrowser.open_new_tab(DOCUMENT_ADR + PARAMS_LINK[param])\n        elif param in range(1, len(PARAMS_LINK_KEYS) + 1):\n            webbrowser.open_new_tab(\n                DOCUMENT_ADR + PARAMS_LINK[PARAMS_LINK_KEYS[param - 1]])\n        else:\n            print(\"Please choose one parameter : \\n\")\n            print('Example : online_help(\"J\") or online_help(2)\\n')\n            for index, item in enumerate(PARAMS_LINK_KEYS):\n                print(str(index + 1) + \"-\" + item)\n    except Exception:\n        print(\"Error in online help\")", "response": "Open online document in web browser."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nround input number and convert to str.", "response": "def rounder(input_number, digit=5):\n    \"\"\"\n    Round input number and convert to str.\n\n    :param input_number: input number\n    :type input_number : anything\n    :param digit: scale (the number of digits to the right of the decimal point in a number.)\n    :type digit : int\n    :return: round number as str\n    \"\"\"\n    if isinstance(input_number, tuple):\n        tuple_list = list(input_number)\n        tuple_str = []\n        for i in tuple_list:\n            if isfloat(i):\n                tuple_str.append(str(numpy.around(i, digit)))\n            else:\n                tuple_str.append(str(i))\n        return \"(\" + \",\".join(tuple_str) + \")\"\n    if isfloat(input_number):\n        return str(numpy.around(input_number, digit))\n    return str(input_number)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef class_filter(classes, class_name):\n    result_classes = classes\n    if isinstance(class_name, list):\n        if set(class_name) <= set(classes):\n            result_classes = class_name\n    return result_classes", "response": "Filter classes by comparing two lists."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck input vector items type.", "response": "def vector_check(vector):\n    \"\"\"\n    Check input vector items type.\n\n    :param vector: input vector\n    :type vector : list\n    :return: bool\n    \"\"\"\n    for i in vector:\n        if isinstance(i, int) is False:\n            return False\n        if i < 0:\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking input matrix format.", "response": "def matrix_check(table):\n    \"\"\"\n    Check input matrix format.\n\n    :param table: input matrix\n    :type table : dict\n    :return: bool\n    \"\"\"\n    try:\n        if len(table.keys()) == 0:\n            return False\n        for i in table.keys():\n            if table.keys() != table[i].keys() or vector_check(\n                    list(table[i].values())) is False:\n                return False\n        return True\n    except Exception:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting different types of items in vectors to str.", "response": "def vector_filter(actual_vector, predict_vector):\n    \"\"\"\n    Convert different type of items in vectors to str.\n\n    :param actual_vector: actual values\n    :type actual_vector : list\n    :param predict_vector: predict value\n    :type predict_vector : list\n    :return: new actual and predict vector\n    \"\"\"\n    temp = []\n    temp.extend(actual_vector)\n    temp.extend(predict_vector)\n    types = set(map(type, temp))\n    if len(types) > 1:\n        return [list(map(str, actual_vector)), list(map(str, predict_vector))]\n    return [actual_vector, predict_vector]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef class_check(vector):\n    for i in vector:\n        if not isinstance(i, type(vector[0])):\n            return False\n    return True", "response": "Check different items in matrix classes."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef one_vs_all_func(classes, table, TP, TN, FP, FN, class_name):\n    try:\n        report_classes = [str(class_name), \"~\"]\n        report_table = {str(class_name): {str(class_name): TP[class_name],\n                                          \"~\": FN[class_name]},\n                        \"~\": {str(class_name): FP[class_name],\n                              \"~\": TN[class_name]}}\n        return [report_classes, report_table]\n    except Exception:\n        return [classes, table]", "response": "One - Vs - All mode handler."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the confusion matrix for a list of classes.", "response": "def normalized_table_calc(classes, table):\n    \"\"\"\n    Return normalized confusion matrix.\n\n    :param classes: classes list\n    :type classes:list\n    :param table: table\n    :type table:dict\n    :return: normalized table as dict\n    \"\"\"\n    map_dict = {k: 0 for k in classes}\n    new_table = {k: map_dict.copy() for k in classes}\n    for key in classes:\n        div = sum(table[key].values())\n        if div == 0:\n            div = 1\n        for item in classes:\n            new_table[key][item] = numpy.around(table[key][item] / div, 5)\n    return new_table"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef transpose_func(classes, table):\n    transposed_table = table\n    for i, item1 in enumerate(classes):\n        for j, item2 in enumerate(classes):\n            if i > j:\n                temp = transposed_table[item1][item2]\n                transposed_table[item1][item2] = transposed_table[item2][item1]\n                transposed_table[item2][item1] = temp\n    return transposed_table", "response": "Transpose the classes and table in order to get the original order."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate TP TN FP FN from confusion matrix.", "response": "def matrix_params_from_table(table, transpose=False):\n    \"\"\"\n    Calculate TP,TN,FP,FN from confusion matrix.\n\n    :param table: input matrix\n    :type table : dict\n    :param transpose : transpose flag\n    :type transpose : bool\n    :return: [classes_list,table,TP,TN,FP,FN]\n    \"\"\"\n    classes = sorted(table.keys())\n    map_dict = {k: 0 for k in classes}\n    TP_dict = map_dict.copy()\n    TN_dict = map_dict.copy()\n    FP_dict = map_dict.copy()\n    FN_dict = map_dict.copy()\n    for i in classes:\n        TP_dict[i] = table[i][i]\n        sum_row = sum(list(table[i].values()))\n        for j in classes:\n            if j != i:\n                FN_dict[i] += table[i][j]\n                FP_dict[j] += table[i][j]\n                TN_dict[j] += sum_row - table[i][j]\n    if transpose:\n        temp = FN_dict\n        FN_dict = FP_dict\n        FP_dict = temp\n        table = transpose_func(classes, table)\n    return [classes, table, TP_dict, TN_dict, FP_dict, FN_dict]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates TP TN FP FN for each class.", "response": "def matrix_params_calc(actual_vector, predict_vector, sample_weight):\n    \"\"\"\n    Calculate TP,TN,FP,FN for each class.\n\n    :param actual_vector: actual values\n    :type actual_vector : list\n    :param predict_vector: predict value\n    :type predict_vector : list\n    :param sample_weight : sample weights list\n    :type sample_weight : list\n    :return: [classes_list,table,TP,TN,FP,FN]\n    \"\"\"\n    if isinstance(actual_vector, numpy.ndarray):\n        actual_vector = actual_vector.tolist()\n    if isinstance(predict_vector, numpy.ndarray):\n        predict_vector = predict_vector.tolist()\n    classes = set(actual_vector).union(set(predict_vector))\n    classes = sorted(classes)\n    map_dict = {k: 0 for k in classes}\n    table = {k: map_dict.copy() for k in classes}\n    weight_vector = [1] * len(actual_vector)\n    if isinstance(sample_weight, (list, numpy.ndarray)):\n        if len(sample_weight) == len(actual_vector):\n            weight_vector = sample_weight\n    for index, item in enumerate(actual_vector):\n        table[item][predict_vector[index]] += 1 * weight_vector[index]\n    [classes, table, TP_dict, TN_dict, FP_dict,\n        FN_dict] = matrix_params_from_table(table)\n    return [classes, table, TP_dict, TN_dict, FP_dict, FN_dict]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if the dataset is imbalanced.", "response": "def imbalance_check(P):\n    \"\"\"\n    Check if the dataset is imbalanced.\n\n    :param P: condition positive\n    :type P : dict\n    :return: is_imbalanced as bool\n    \"\"\"\n    p_list = list(P.values())\n    max_value = max(p_list)\n    min_value = min(p_list)\n    if min_value > 0:\n        balance_ratio = max_value / min_value\n    else:\n        balance_ratio = max_value\n    is_imbalanced = False\n    if balance_ratio > BALANCE_RATIO_THRESHOLD:\n        is_imbalanced = True\n    return is_imbalanced"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef binary_check(classes):\n    num_classes = len(classes)\n    is_binary = False\n    if num_classes == 2:\n        is_binary = True\n    return is_binary", "response": "Check if the problem is a binary classification."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef statistic_recommend(classes, P):\n    if imbalance_check(P):\n        return IMBALANCED_RECOMMEND\n    if binary_check(classes):\n        return BINARY_RECOMMEND\n    return MULTICLASS_RECOMMEND", "response": "Returns recommendations for the statistic dataset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting final result. :param failed: failed flag :type failed: bool :return: None", "response": "def print_result(failed=False):\n    \"\"\"\n    Print final result.\n\n    :param failed: failed flag\n    :type failed: bool\n    :return: None\n    \"\"\"\n    message = \"Version tag tests \"\n    if not failed:\n        print(\"\\n\" + message + \"passed!\")\n    else:\n        print(\"\\n\" + message + \"failed!\")\n    print(\"Passed : \" + str(TEST_NUMBER - Failed) + \"/\" + str(TEST_NUMBER))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating C ( Pearson s C.", "response": "def pearson_C_calc(chi_square, POP):\n    \"\"\"\n    Calculate C (Pearson's C).\n\n    :param chi_square: chi squared\n    :type chi_square : float\n    :param POP: population\n    :type POP : int\n    :return: C as float\n    \"\"\"\n    try:\n        C = math.sqrt(chi_square / (POP + chi_square))\n        return C\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef AUNP_calc(classes, P, POP, AUC_dict):\n    try:\n        result = 0\n        for i in classes:\n            result += (P[i] / POP[i]) * AUC_dict[i]\n        return result\n    except Exception:\n        return \"None\"", "response": "Calculate AUNP.\n\n    :param classes: classes\n    :type classes : list\n    :param P: condition positive\n    :type P : dict\n    :param POP: population\n    :type POP : dict\n    :param AUC_dict: AUC (Area under the ROC curve) for each class\n    :type AUC_dict : dict\n    :return: AUNP as float"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates CBA (Class balance accuracy). :param classes: classes :type classes : list :param table: input matrix :type table : dict :param TOP: test outcome positive :type TOP : dict :param P: condition positive :type P : dict :return: CBA as float", "response": "def CBA_calc(classes, table, TOP, P):\n    \"\"\"\n    Calculate CBA (Class balance accuracy).\n\n    :param classes: classes\n    :type classes : list\n    :param table: input matrix\n    :type table : dict\n    :param TOP: test outcome positive\n    :type TOP : dict\n    :param P: condition positive\n    :type P : dict\n    :return: CBA as float\n    \"\"\"\n    try:\n        result = 0\n        class_number = len(classes)\n        for i in classes:\n            result += ((table[i][i]) / (max(TOP[i], P[i])))\n        return result / class_number\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the RR value for the given classes and TOP.", "response": "def RR_calc(classes, TOP):\n    \"\"\"\n    Calculate RR (Global performance index).\n\n    :param classes: classes\n    :type classes : list\n    :param TOP: test outcome positive\n    :type TOP : dict\n    :return: RR as float\n    \"\"\"\n    try:\n        class_number = len(classes)\n        result = sum(list(TOP.values()))\n        return result / class_number\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates Overall_MCC. :param classes: classes :type classes : list :param table: input matrix :type table : dict :param TOP: test outcome positive :type TOP : dict :param P: condition positive :type P : dict :return: Overall_MCC as float", "response": "def overall_MCC_calc(classes, table, TOP, P):\n    \"\"\"\n    Calculate Overall_MCC.\n\n    :param classes: classes\n    :type classes : list\n    :param table: input matrix\n    :type table : dict\n    :param TOP: test outcome positive\n    :type TOP : dict\n    :param P: condition positive\n    :type P : dict\n    :return:  Overall_MCC as float\n    \"\"\"\n    try:\n        cov_x_y = 0\n        cov_x_x = 0\n        cov_y_y = 0\n        matrix_sum = sum(list(TOP.values()))\n        for i in classes:\n            cov_x_x += TOP[i] * (matrix_sum - TOP[i])\n            cov_y_y += P[i] * (matrix_sum - P[i])\n            cov_x_y += (table[i][i] * matrix_sum - P[i] * TOP[i])\n        return cov_x_y / (math.sqrt(cov_y_y * cov_x_x))\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convex_combination(classes, TP, TOP, P, class_name, modified=False):\n    try:\n        class_number = len(classes)\n        alpha = 1\n        if class_number == 2:\n            alpha = 0\n        matrix_sum = sum(list(TOP.values()))\n        TP_sum = sum(list(TP.values()))\n        up = TOP[class_name] + P[class_name]\n        down = 2 * matrix_sum\n        if modified:\n            down -= (alpha * TP_sum)\n            up -= TP[class_name]\n        return up / down\n    except Exception:\n        return \"None\"", "response": "Calculate the convex combinations of classes TP and P."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef overall_CEN_calc(classes, TP, TOP, P, CEN_dict, modified=False):\n    try:\n        result = 0\n        for i in classes:\n            result += (convex_combination(classes, TP, TOP, P, i, modified) *\n                       CEN_dict[i])\n        return result\n    except Exception:\n        return \"None\"", "response": "Calculate Overall_CEN for a list of classes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates n choose r.", "response": "def ncr(n, r):\n    \"\"\"\n    Calculate n choose r.\n\n    :param n: n\n    :type n : int\n    :param r: r\n    :type r :int\n    :return: n choose r as int\n    \"\"\"\n    r = min(r, n - r)\n    numer = reduce(op.mul, range(n, n - r, -1), 1)\n    denom = reduce(op.mul, range(1, r + 1), 1)\n    return numer // denom"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate p_value. :param TP: true positive :type TP : dict :param POP: population :type POP : int :param NIR: no information rate :type NIR : float :return: p_value as float", "response": "def p_value_calc(TP, POP, NIR):\n    \"\"\"\n    Calculate p_value.\n\n    :param TP: true positive\n    :type TP : dict\n    :param POP: population\n    :type POP : int\n    :param NIR: no information rate\n    :type NIR : float\n    :return: p_value as float\n    \"\"\"\n    try:\n        n = POP\n        x = sum(list(TP.values()))\n        p = NIR\n        result = 0\n        for j in range(x):\n            result += ncr(n, j) * (p ** j) * ((1 - p) ** (n - j))\n        return 1 - result\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating NIR ( No information rate.", "response": "def NIR_calc(P, POP):\n    \"\"\"\n    Calculate NIR (No information rate).\n\n    :param P: condition positive\n    :type P : dict\n    :param POP: population\n    :type POP : int\n    :return: NIR as float\n    \"\"\"\n    try:\n        max_P = max(list(P.values()))\n        length = POP\n        return max_P / length\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hamming_calc(TP, POP):\n    try:\n        length = POP\n        return (1 / length) * (length - sum(TP.values()))\n    except Exception:\n        return \"None\"", "response": "Calculate hamming loss.\n\n    :param TP: true positive\n    :type TP : dict\n    :param POP: population\n    :type POP : int\n    :return: hamming loss as float"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef zero_one_loss_calc(TP, POP):\n    try:\n        length = POP\n        return (length - sum(TP.values()))\n    except Exception:\n        return \"None\"", "response": "Calculate zero - one loss."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef entropy_calc(item, POP):\n    try:\n        result = 0\n        for i in item.keys():\n            likelihood = item[i] / POP[i]\n            if likelihood != 0:\n                result += likelihood * math.log(likelihood, 2)\n        return -result\n    except Exception:\n        return \"None\"", "response": "Calculate reference and response likelihood of a single item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cross_entropy_calc(TOP, P, POP):\n    try:\n        result = 0\n        for i in TOP.keys():\n            reference_likelihood = P[i] / POP[i]\n            response_likelihood = TOP[i] / POP[i]\n            if response_likelihood != 0 and reference_likelihood != 0:\n                result += reference_likelihood * \\\n                    math.log(response_likelihood, 2)\n        return -result\n    except Exception:\n        return \"None\"", "response": "Calculate cross entropy of a single node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating joint entropy. :param classes: confusion matrix classes :type classes : list :param table: confusion matrix table :type table : dict :param POP: population :type POP : dict :return: joint entropy as float", "response": "def joint_entropy_calc(classes, table, POP):\n    \"\"\"\n    Calculate joint entropy.\n\n    :param classes: confusion matrix classes\n    :type classes : list\n    :param table: confusion matrix table\n    :type table : dict\n    :param POP: population\n    :type POP : dict\n    :return: joint entropy as float\n    \"\"\"\n    try:\n        result = 0\n        for i in classes:\n            for index, j in enumerate(classes):\n                p_prime = table[i][j] / POP[i]\n                if p_prime != 0:\n                    result += p_prime * math.log(p_prime, 2)\n        return -result\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef conditional_entropy_calc(classes, table, P, POP):\n    try:\n        result = 0\n        for i in classes:\n            temp = 0\n            for index, j in enumerate(classes):\n                p_prime = 0\n                if P[i] != 0:\n                    p_prime = table[i][j] / P[i]\n                if p_prime != 0:\n                    temp += p_prime * math.log(p_prime, 2)\n            result += temp * (P[i] / POP[i])\n        return -result\n    except Exception:\n        return \"None\"", "response": "Calculate conditional entropy.\n\n    :param classes: confusion matrix classes\n    :type classes : list\n    :param table: confusion matrix table\n    :type table : dict\n    :param P: condition positive\n    :type P : dict\n    :param POP: population\n    :type POP : dict\n    :return: conditional entropy as float"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates Goodman and Kruskal s lambda B.", "response": "def lambda_B_calc(classes, table, TOP, POP):\n    \"\"\"\n    Calculate Goodman and Kruskal's lambda B.\n\n    :param classes: confusion matrix classes\n    :type classes : list\n    :param table: confusion matrix table\n    :type table : dict\n    :param TOP: test outcome positive\n    :type TOP : dict\n    :param POP: population\n    :type POP : int\n    :return: Goodman and Kruskal's lambda B as float\n    \"\"\"\n    try:\n        result = 0\n        length = POP\n        maxresponse = max(list(TOP.values()))\n        for i in classes:\n            result += max(list(table[i].values()))\n        result = (result - maxresponse) / (length - maxresponse)\n        return result\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates Goodman and Kruskal s lambda A.", "response": "def lambda_A_calc(classes, table, P, POP):\n    \"\"\"\n    Calculate Goodman and Kruskal's lambda A.\n\n    :param classes: confusion matrix classes\n    :type classes : list\n    :param table: confusion matrix table\n    :type table : dict\n    :param P: condition positive\n    :type P : dict\n    :param POP: population\n    :type POP : int\n    :return: Goodman and Kruskal's lambda A as float\n    \"\"\"\n    try:\n        result = 0\n        maxreference = max(list(P.values()))\n        length = POP\n        for i in classes:\n            col = []\n            for col_item in table.values():\n                col.append(col_item[i])\n            result += max(col)\n        result = (result - maxreference) / (length - maxreference)\n        return result\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate chi - squared.", "response": "def chi_square_calc(classes, table, TOP, P, POP):\n    \"\"\"\n    Calculate chi-squared.\n\n    :param classes: confusion matrix classes\n    :type classes : list\n    :param table: confusion matrix table\n    :type table : dict\n    :param TOP: test outcome positive\n    :type TOP : dict\n    :param P: condition positive\n    :type P : dict\n    :param POP: population\n    :type POP : dict\n    :return: chi-squared as float\n    \"\"\"\n    try:\n        result = 0\n        for i in classes:\n            for index, j in enumerate(classes):\n                expected = (TOP[j] * P[i]) / (POP[i])\n                result += ((table[i][j] - expected)**2) / expected\n        return result\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef kappa_se_calc(PA, PE, POP):\n    try:\n        result = math.sqrt((PA * (1 - PA)) / (POP * ((1 - PE)**2)))\n        return result\n    except Exception:\n        return \"None\"", "response": "Calculate kappa standard error."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates confidence interval of a node in the cluster.", "response": "def CI_calc(mean, SE, CV=1.96):\n    \"\"\"\n    Calculate confidence interval.\n\n    :param mean: mean of data\n    :type mean : float\n    :param SE: standard error of data\n    :type SE : float\n    :param CV: critical value\n    :type CV:float\n    :return: confidence interval as tuple\n    \"\"\"\n    try:\n        CI_down = mean - CV * SE\n        CI_up = mean + CV * SE\n        return (CI_down, CI_up)\n    except Exception:\n        return (\"None\", \"None\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating PPV_Micro and TPR_Micro.", "response": "def micro_calc(TP, item):\n    \"\"\"\n    Calculate PPV_Micro and TPR_Micro.\n\n    :param TP: true positive\n    :type TP:dict\n    :param item: FN or FP\n    :type item : dict\n    :return: PPV_Micro or TPR_Micro as float\n    \"\"\"\n    try:\n        TP_sum = sum(TP.values())\n        item_sum = sum(item.values())\n        return TP_sum / (TP_sum + item_sum)\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates PPV_Macro and TPR_Macro. is used to calculate PPV_Macro and TPR_Macro as float.", "response": "def macro_calc(item):\n    \"\"\"\n    Calculate PPV_Macro and TPR_Macro.\n\n    :param item: PPV or TPR\n    :type item:dict\n    :return: PPV_Macro or TPR_Macro as float\n    \"\"\"\n    try:\n        item_sum = sum(item.values())\n        item_len = len(item.values())\n        return item_sum / item_len\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate percent chance agreement for Scott s Pi.", "response": "def PC_PI_calc(P, TOP, POP):\n    \"\"\"\n    Calculate percent chance agreement for Scott's Pi.\n\n    :param P: condition positive\n    :type P : dict\n    :param TOP: test outcome positive\n    :type TOP : dict\n    :param POP: population\n    :type POP:dict\n    :return: percent chance agreement as float\n    \"\"\"\n    try:\n        result = 0\n        for i in P.keys():\n            result += ((P[i] + TOP[i]) / (2 * POP[i]))**2\n        return result\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef PC_AC1_calc(P, TOP, POP):\n    try:\n        result = 0\n        classes = list(P.keys())\n        for i in classes:\n            pi = ((P[i] + TOP[i]) / (2 * POP[i]))\n            result += pi * (1 - pi)\n        result = result / (len(classes) - 1)\n        return result\n    except Exception:\n        return \"None\"", "response": "Calculate percent chance agreement for Gwet s AC1."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates overall jaccard index.", "response": "def overall_jaccard_index_calc(jaccard_list):\n    \"\"\"\n    Calculate overall jaccard index.\n\n    :param jaccard_list : list of jaccard index for each class\n    :type jaccard_list : list\n    :return: (jaccard_sum , jaccard_mean) as tuple\n    \"\"\"\n    try:\n        jaccard_sum = sum(jaccard_list)\n        jaccard_mean = jaccard_sum / len(jaccard_list)\n        return (jaccard_sum, jaccard_mean)\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate overall accuracy. :param TP: true positive :type TP : dict :param POP: population :type POP:int :return: overall_accuracy as float", "response": "def overall_accuracy_calc(TP, POP):\n    \"\"\"\n    Calculate overall accuracy.\n\n    :param TP: true positive\n    :type TP : dict\n    :param POP: population\n    :type POP:int\n    :return: overall_accuracy as float\n    \"\"\"\n    try:\n        overall_accuracy = sum(TP.values()) / POP\n        return overall_accuracy\n    except Exception:\n        return \"None\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate overall statistics for a single object.", "response": "def overall_statistics(\n        RACC,\n        RACCU,\n        TPR,\n        PPV,\n        TP,\n        FN,\n        FP,\n        POP,\n        P,\n        TOP,\n        jaccard_list,\n        CEN_dict,\n        MCEN_dict,\n        AUC_dict,\n        classes,\n        table):\n    \"\"\"\n    Return overall statistics.\n\n    :param RACC: random accuracy\n    :type RACC : dict\n    :param TPR: sensitivity, recall, hit rate, or true positive rate\n    :type TPR : dict\n    :param PPV: precision or positive predictive value\n    :type PPV : dict\n    :param TP: true positive\n    :type TP : dict\n    :param FN: false negative\n    :type FN : dict\n    :param FP: false positive\n    :type FP: dict\n    :param POP: population\n    :type POP:dict\n    :param P: condition positive\n    :type P : dict\n    :param POP: population\n    :type POP:dict\n    :param TOP: test outcome positive\n    :type TOP : dict\n    :param jaccard_list : list of jaccard index for each class\n    :type jaccard_list : list\n    :param CEN_dict: CEN dictionary for each class\n    :type CEN_dict : dict\n    :param classes: confusion matrix classes\n    :type classes : list\n    :param table: input matrix\n    :type table : dict\n    :return: overall statistics as dict\n    \"\"\"\n    population = list(POP.values())[0]\n    overall_accuracy = overall_accuracy_calc(TP, population)\n    overall_random_accuracy_unbiased = overall_random_accuracy_calc(RACCU)\n    overall_random_accuracy = overall_random_accuracy_calc(RACC)\n    overall_kappa = reliability_calc(overall_random_accuracy, overall_accuracy)\n    PC_PI = PC_PI_calc(P, TOP, POP)\n    PC_AC1 = PC_AC1_calc(P, TOP, POP)\n    PC_S = PC_S_calc(classes)\n    PI = reliability_calc(PC_PI, overall_accuracy)\n    AC1 = reliability_calc(PC_AC1, overall_accuracy)\n    S = reliability_calc(PC_S, overall_accuracy)\n    kappa_SE = kappa_se_calc(\n        overall_accuracy,\n        overall_random_accuracy, population)\n    kappa_unbiased = reliability_calc(\n        overall_random_accuracy_unbiased,\n        overall_accuracy)\n    kappa_no_prevalence = kappa_no_prevalence_calc(overall_accuracy)\n    kappa_CI = CI_calc(overall_kappa, kappa_SE)\n    overall_accuracy_se = se_calc(overall_accuracy, population)\n    overall_accuracy_CI = CI_calc(overall_accuracy, overall_accuracy_se)\n    chi_squared = chi_square_calc(classes, table, TOP, P, POP)\n    phi_squared = phi_square_calc(chi_squared, population)\n    cramer_V = cramers_V_calc(phi_squared, classes)\n    response_entropy = entropy_calc(TOP, POP)\n    reference_entropy = entropy_calc(P, POP)\n    cross_entropy = cross_entropy_calc(TOP, P, POP)\n    join_entropy = joint_entropy_calc(classes, table, POP)\n    conditional_entropy = conditional_entropy_calc(classes, table, P, POP)\n    mutual_information = mutual_information_calc(\n        response_entropy, conditional_entropy)\n    kl_divergence = kl_divergence_calc(P, TOP, POP)\n    lambda_B = lambda_B_calc(classes, table, TOP, population)\n    lambda_A = lambda_A_calc(classes, table, P, population)\n    DF = DF_calc(classes)\n    overall_jaccard_index = overall_jaccard_index_calc(list(\n        jaccard_list.values()))\n    hamming_loss = hamming_calc(TP, population)\n    zero_one_loss = zero_one_loss_calc(TP, population)\n    NIR = NIR_calc(P, population)\n    p_value = p_value_calc(TP, population, NIR)\n    overall_CEN = overall_CEN_calc(classes, TP, TOP, P, CEN_dict)\n    overall_MCEN = overall_CEN_calc(classes, TP, TOP, P, MCEN_dict, True)\n    overall_MCC = overall_MCC_calc(classes, table, TOP, P)\n    RR = RR_calc(classes, TOP)\n    CBA = CBA_calc(classes, table, TOP, P)\n    AUNU = macro_calc(AUC_dict)\n    AUNP = AUNP_calc(classes, P, POP, AUC_dict)\n    RCI = RCI_calc(mutual_information, reference_entropy)\n    C = pearson_C_calc(chi_squared, population)\n    return {\n        \"Overall ACC\": overall_accuracy,\n        \"Kappa\": overall_kappa,\n        \"Overall RACC\": overall_random_accuracy,\n        \"SOA1(Landis & Koch)\": kappa_analysis_koch(overall_kappa),\n        \"SOA2(Fleiss)\": kappa_analysis_fleiss(overall_kappa),\n        \"SOA3(Altman)\": kappa_analysis_altman(overall_kappa),\n        \"SOA4(Cicchetti)\": kappa_analysis_cicchetti(overall_kappa),\n        \"TPR Macro\": macro_calc(TPR),\n        \"PPV Macro\": macro_calc(PPV),\n        \"TPR Micro\": micro_calc(\n            TP=TP,\n            item=FN),\n        \"PPV Micro\": micro_calc(\n            TP=TP,\n            item=FP),\n        \"Scott PI\": PI,\n        \"Gwet AC1\": AC1,\n        \"Bennett S\": S,\n        \"Kappa Standard Error\": kappa_SE,\n        \"Kappa 95% CI\": kappa_CI,\n        \"Chi-Squared\": chi_squared,\n        \"Phi-Squared\": phi_squared,\n        \"Cramer V\": cramer_V,\n        \"Chi-Squared DF\": DF,\n        \"95% CI\": overall_accuracy_CI,\n        \"Standard Error\": overall_accuracy_se,\n        \"Response Entropy\": response_entropy,\n        \"Reference Entropy\": reference_entropy,\n        \"Cross Entropy\": cross_entropy,\n        \"Joint Entropy\": join_entropy,\n        \"Conditional Entropy\": conditional_entropy,\n        \"KL Divergence\": kl_divergence,\n        \"Lambda B\": lambda_B,\n        \"Lambda A\": lambda_A,\n        \"Kappa Unbiased\": kappa_unbiased,\n        \"Overall RACCU\": overall_random_accuracy_unbiased,\n        \"Kappa No Prevalence\": kappa_no_prevalence,\n        \"Mutual Information\": mutual_information,\n        \"Overall J\": overall_jaccard_index,\n        \"Hamming Loss\": hamming_loss,\n        \"Zero-one Loss\": zero_one_loss,\n        \"NIR\": NIR,\n        \"P-Value\": p_value,\n        \"Overall CEN\": overall_CEN,\n        \"Overall MCEN\": overall_MCEN,\n        \"Overall MCC\": overall_MCC,\n        \"RR\": RR,\n        \"CBA\": CBA,\n        \"AUNU\": AUNU,\n        \"AUNP\": AUNP,\n        \"RCI\": RCI,\n        \"Pearson C\": C}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef AUC_analysis(AUC):\n    try:\n        if AUC == \"None\":\n            return \"None\"\n        if AUC < 0.6:\n            return \"Poor\"\n        if AUC >= 0.6 and AUC < 0.7:\n            return \"Fair\"\n        if AUC >= 0.7 and AUC < 0.8:\n            return \"Good\"\n        if AUC >= 0.8 and AUC < 0.9:\n            return \"Very Good\"\n        return \"Excellent\"\n    except Exception:  # pragma: no cover\n        return \"None\"", "response": "Analysis AUC with interpretation table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef kappa_analysis_altman(kappa):\n    try:\n        if kappa < 0.2:\n            return \"Poor\"\n        if kappa >= 0.20 and kappa < 0.4:\n            return \"Fair\"\n        if kappa >= 0.40 and kappa < 0.6:\n            return \"Moderate\"\n        if kappa >= 0.60 and kappa < 0.8:\n            return \"Good\"\n        if kappa >= 0.80 and kappa <= 1:\n            return \"Very Good\"\n        return \"None\"\n    except Exception:  # pragma: no cover\n        return \"None\"", "response": "Analysis kappa number with Altman benchmark."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_requires():\n    requirements = open(\"requirements.txt\", \"r\").read()\n    return list(filter(lambda x: x != \"\", requirements.split()))", "response": "Read requirements. txt and return a list of all the required files."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_description():\n    try:\n        with open(\"README.md\") as r:\n            description = \"\\n\"\n            description += r.read()\n        with open(\"CHANGELOG.md\") as c:\n            description += \"\\n\"\n            description += c.read()\n        return description\n    except Exception:\n        return '''\n   PyCM is a multi-class confusion matrix library written in Python that\n   supports both input data vectors and direct matrix, and a proper tool for\n   post-classification model evaluation that supports most classes and overall\n   statistics parameters.\n   PyCM is the swiss-army knife of confusion matrices, targeted mainly at\n   data scientists that need a broad array of metrics for predictive models\n   and an accurate evaluation of large variety of classifiers.'''", "response": "Read README. md and CHANGELOG. md and return a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting confusion matrix. :param one_vs_all : One-Vs-All mode flag :type one_vs_all : bool :param class_name : target class name for One-Vs-All mode :type class_name : any valid type :return: None", "response": "def print_matrix(self, one_vs_all=False, class_name=None):\n        \"\"\"\n        Print confusion matrix.\n\n        :param one_vs_all : One-Vs-All mode flag\n        :type one_vs_all : bool\n        :param class_name : target class name for One-Vs-All mode\n        :type class_name : any valid type\n        :return: None\n        \"\"\"\n        classes = self.classes\n        table = self.table\n        if one_vs_all:\n            [classes, table] = one_vs_all_func(\n                classes, table, self.TP, self.TN, self.FP, self.FN, class_name)\n        print(table_print(classes, table))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stat(self, overall_param=None, class_param=None, class_name=None):\n        classes = class_filter(self.classes, class_name)\n        print(\n            stat_print(\n                classes,\n                self.class_stat,\n                self.overall_stat,\n                self.digit, overall_param, class_param))", "response": "Print statistical measures table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_stat(\n            self,\n            name,\n            address=True,\n            overall_param=None,\n            class_param=None,\n            class_name=None):\n        \"\"\"\n        Save ConfusionMatrix in .pycm (flat file format).\n\n        :param name: filename\n        :type name : str\n        :param address: flag for address return\n        :type address : bool\n        :param overall_param : overall parameters list for save, Example : [\"Kappa\",\"Scott PI]\n        :type overall_param : list\n        :param class_param : class parameters list for save, Example : [\"TPR\",\"TNR\",\"AUC\"]\n        :type class_param : list\n        :param class_name : class name (sub set of classes), Example :[1,2,3]\n        :type class_name : list\n        :return: saving Status as dict {\"Status\":bool , \"Message\":str}\n        \"\"\"\n        try:\n            message = None\n            file = open(name + \".pycm\", \"w\")\n            matrix = \"Matrix : \\n\\n\" + table_print(self.classes,\n                                                   self.table) + \"\\n\\n\"\n            normalized_matrix = \"Normalized Matrix : \\n\\n\" + \\\n                                table_print(self.classes,\n                                            self.normalized_table) + \"\\n\\n\"\n            one_vs_all = \"\\nOne-Vs-All : \\n\\n\"\n            for c in self.classes:\n                one_vs_all += str(c) + \"-Vs-All : \\n\\n\"\n                [classes, table] = one_vs_all_func(self.classes, self.table,\n                                                   self.TP, self.TN, self.FP,\n                                                   self.FN, c)\n                one_vs_all += table_print(classes, table) + \"\\n\\n\"\n            classes = class_filter(self.classes, class_name)\n            stat = stat_print(\n                classes,\n                self.class_stat,\n                self.overall_stat,\n                self.digit, overall_param, class_param)\n            file.write(matrix + normalized_matrix + stat + one_vs_all)\n            file.close()\n            if address:\n                message = os.path.join(os.getcwd(), name + \".pycm\")\n            return {\"Status\": True, \"Message\": message}\n        except Exception as e:\n            return {\"Status\": False, \"Message\": str(e)}", "response": "Save ConfusionMatrix in. pycm format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_html(\n            self,\n            name,\n            address=True,\n            overall_param=None,\n            class_param=None,\n            class_name=None, color=(0, 0, 0), normalize=False):\n        \"\"\"\n        Save ConfusionMatrix in HTML file.\n\n        :param name: filename\n        :type name : str\n        :param address: flag for address return\n        :type address : bool\n        :param overall_param : overall parameters list for save, Example : [\"Kappa\",\"Scott PI]\n        :type overall_param : list\n        :param class_param : class parameters list for save, Example : [\"TPR\",\"TNR\",\"AUC\"]\n        :type class_param : list\n        :param class_name : class name (sub set of classes), Example :[1,2,3]\n        :type class_name : list\n        :param color : matrix color (R,G,B)\n        :type color : tuple\n        :param normalize : save normalize matrix flag\n        :type normalize : bool\n        :return: saving Status as dict {\"Status\":bool , \"Message\":str}\n        \"\"\"\n        try:\n            message = None\n            table = self.table\n            if normalize:\n                table = self.normalized_table\n            html_file = open(name + \".html\", \"w\")\n            html_file.write(html_init(name))\n            html_file.write(html_dataset_type(self.binary, self.imbalance))\n            html_file.write(html_table(self.classes, table, color, normalize))\n            html_file.write(\n                html_overall_stat(\n                    self.overall_stat,\n                    self.digit,\n                    overall_param,\n                    self.recommended_list))\n            class_stat_classes = class_filter(self.classes, class_name)\n            html_file.write(\n                html_class_stat(\n                    class_stat_classes,\n                    self.class_stat,\n                    self.digit,\n                    class_param,\n                    self.recommended_list))\n            html_file.write(html_end(VERSION))\n            html_file.close()\n            if address:\n                message = os.path.join(os.getcwd(), name + \".html\")\n            return {\"Status\": True, \"Message\": message}\n        except Exception as e:\n            return {\"Status\": False, \"Message\": str(e)}", "response": "Save ConfusionMatrix in HTML file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave ConfusionMatrix in CSV file.", "response": "def save_csv(\n            self,\n            name,\n            address=True,\n            class_param=None,\n            class_name=None,\n            matrix_save=True,\n            normalize=False):\n        \"\"\"\n        Save ConfusionMatrix in CSV file.\n\n        :param name: filename\n        :type name : str\n        :param address: flag for address return\n        :type address : bool\n        :param class_param : class parameters list for save, Example : [\"TPR\",\"TNR\",\"AUC\"]\n        :type class_param : list\n        :param class_name : class name (sub set of classes), Example :[1,2,3]\n        :type class_name : list\n        :param matrix_save : save matrix flag\n        :type matrix_save : bool\n        :param normalize : save normalize matrix flag\n        :type normalize : bool\n        :return: saving Status as dict {\"Status\":bool , \"Message\":str}\n        \"\"\"\n        try:\n            message = None\n            classes = class_filter(self.classes, class_name)\n            csv_file = open(name + \".csv\", \"w\")\n            csv_data = csv_print(\n                classes,\n                self.class_stat,\n                self.digit,\n                class_param)\n            csv_file.write(csv_data)\n            if matrix_save:\n                matrix = self.table\n                if normalize:\n                    matrix = self.normalized_table\n                csv_matrix_file = open(name + \"_matrix\" + \".csv\", \"w\")\n                csv_matrix_data = csv_matrix_print(self.classes, matrix)\n                csv_matrix_file.write(csv_matrix_data)\n            if address:\n                message = os.path.join(os.getcwd(), name + \".csv\")\n            return {\"Status\": True, \"Message\": message}\n        except Exception as e:\n            return {\"Status\": False, \"Message\": str(e)}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave ConfusionMatrix in. obj file.", "response": "def save_obj(self, name, address=True):\n        \"\"\"\n        Save ConfusionMatrix in .obj file.\n\n        :param name: filename\n        :type name : str\n        :param address: flag for address return\n        :type address : bool\n        :return: saving Status as dict {\"Status\":bool , \"Message\":str}\n        \"\"\"\n        try:\n            message = None\n            obj_file = open(name + \".obj\", \"w\")\n            actual_vector_temp = self.actual_vector\n            predict_vector_temp = self.predict_vector\n            matrix_temp = {k: self.table[k].copy() for k in self.classes}\n            matrix_items = []\n            for i in self.classes:\n                matrix_items.append((i, list(matrix_temp[i].items())))\n            if isinstance(actual_vector_temp, numpy.ndarray):\n                actual_vector_temp = actual_vector_temp.tolist()\n            if isinstance(predict_vector_temp, numpy.ndarray):\n                predict_vector_temp = predict_vector_temp.tolist()\n            json.dump({\"Actual-Vector\": actual_vector_temp,\n                       \"Predict-Vector\": predict_vector_temp,\n                       \"Matrix\": matrix_items,\n                       \"Digit\": self.digit,\n                       \"Sample-Weight\": self.weights,\n                       \"Transpose\": self.transpose}, obj_file)\n            if address:\n                message = os.path.join(os.getcwd(), name + \".obj\")\n            return {\"Status\": True, \"Message\": message}\n        except Exception as e:\n            return {\"Status\": False, \"Message\": str(e)}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef F_beta(self, beta):\n        try:\n            F_dict = {}\n            for i in self.TP.keys():\n                F_dict[i] = F_calc(\n                    TP=self.TP[i],\n                    FP=self.FP[i],\n                    FN=self.FN[i],\n                    beta=beta)\n            return F_dict\n        except Exception:\n            return {}", "response": "Calculate FBeta score for classes in a single object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef IBA_alpha(self, alpha):\n        try:\n            IBA_dict = {}\n            for i in self.classes:\n                IBA_dict[i] = IBA_calc(self.TPR[i], self.TNR[i], alpha=alpha)\n            return IBA_dict\n        except Exception:\n            return {}", "response": "Calculate IBA_alpha score.\n\n        :param alpha: alpha parameter\n        :type alpha: float\n        :return: IBA_alpha score for classes as dict"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef relabel(self, mapping):\n        if not isinstance(mapping, dict):\n            raise pycmMatrixError(MAPPING_FORMAT_ERROR)\n        if self.classes != list(mapping.keys()):\n            raise pycmMatrixError(MAPPING_CLASS_NAME_ERROR)\n        for row in self.classes:\n            temp_dict = {}\n            temp_dict_normalized = {}\n            for col in self.classes:\n                temp_dict[mapping[col]] = self.table[row][col]\n                temp_dict_normalized[mapping[col]\n                                     ] = self.normalized_table[row][col]\n            del self.table[row]\n            self.table[mapping[row]] = temp_dict\n            del self.normalized_table[row]\n            self.normalized_table[mapping[row]] = temp_dict_normalized\n        self.matrix = self.table\n        self.normalized_matrix = self.normalized_table\n        for param in self.class_stat.keys():\n            temp_dict = {}\n            for classname in self.classes:\n                temp_dict[mapping[classname]\n                          ] = self.class_stat[param][classname]\n            self.class_stat[param] = temp_dict\n        self.classes = list(mapping.values())\n        self.TP = self.class_stat[\"TP\"]\n        self.TN = self.class_stat[\"TN\"]\n        self.FP = self.class_stat[\"FP\"]\n        self.FN = self.class_stat[\"FN\"]\n        __class_stat_init__(self)", "response": "Rename ConfusionMatrix classes.\n\n        :param mapping: mapping dictionary\n        :type mapping : dict\n        :return: None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_client_cert(self, cert):\n        self.request[\"cert\"] = self._input_client_cert(cert)\n        return self.request[\"cert\"]", "response": "Sets the client cert for the requests."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_headers(self, headers):\n        self.request[\"headers\"].update(self._input_object(headers))\n        return self.request[\"headers\"]", "response": "Sets new request headers or updates the existing ones."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating the request properties of the current test case level and return the new schema.", "response": "def expect_request(self, schema, merge=False):\n        \"\"\"*Sets the schema to validate the request properties*\n\n        Expectations are effective for following requests in the test suite,\n        or until they are reset or updated by using expectation keywords again.\n        On the test suite level (suite setup), they are best used for expecting\n        the endpoint wide properties that are common regardless of the tested\n        HTTP method, and on the test case level (test setup) to merge in\n        the HTTP method specific properties.\n\n        `Expect Request` is intented to be used with tests that have some of the\n        request properties, e.g. body or query parameters, randomized (\"fuzzing\")\n        for validating that the sent values are within the expected scope.\n\n        If the keyword is used, following HTTP keywords will fail when\n        their request properties are not valid against the expected schema.\n\n        If the keyword is not used, a new schema is generated for each following\n        request for its ``body`` and ``query`` properties. Use `Output Schema` to output it and use it as an input to this keyword.\n\n        *Options*\n\n        ``merge``: Merges the new schema with the current instead of replacing it\n\n        *Examples*\n\n        | `Expect Request` | ${CURDIR}/valid_payload.json | | # See `Output Schema` |\n        | `Expect Request` | { \"body\": { \"required\": [\"id\"] } } | merge=true |\n        \"\"\"\n        schema = self._input_object(schema)\n        if \"properties\" not in schema:\n            schema = {\"properties\": schema}\n        if self._input_boolean(merge):\n            new_schema = SchemaBuilder(schema_uri=False)\n            new_schema.add_schema(self.schema[\"properties\"][\"request\"])\n            new_schema.add_schema(schema)\n            self.schema[\"properties\"][\"request\"] = new_schema.to_schema()\n        else:\n            self.schema[\"properties\"][\"request\"] = schema\n        return self.schema[\"properties\"][\"request\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates the response body of a specific resource.", "response": "def expect_response_body(self, schema):\n        \"\"\"*Updates the schema to validate the response body properties.*\n\n        Expectations are effective for following requests in the test suite,\n        or until they are reset or updated by using expectation keywords again.\n        On the test suite level (suite setup), they are best used for expecting\n        the endpoint wide properties that are common regardless of the tested\n        HTTP method, and on the test case level (test setup) to merge in\n        the HTTP method specific properties.\n\n        `Expect Response Body` is intented to be used on the test case level,\n        to validate that the response body has the expected properties for\n        the particular HTTP method. Note that if something about response body\n        has been already expected with `Expected Response`, using this keyword\n        updates the expectations in terms of given response body properties.\n\n        If the keyword is used, following HTTP keywords will fail if\n        their response body is not valid against the expected schema.\n\n        If the keyword is not used, and no schema is already expected with\n        `Expect Response` for response ``body``, a new schema is inferred for it.\n        Use `Output Schema` to output it and use it as an input to this keyword.\n\n        *Tips*\n\n        Regardless whether the HTTP method returns one (an object) or many\n        (an array of objects), the validation of the object property types and features can usually be done to some extent on the test suite level\n        with `Expect Response`, then extended on the test case level using this\n        keyword. This helps in ensuring that the data model is unified between\n        the different HTTP methods.\n\n        *Examples*\n\n        | `Expect Response Body` | ${CURDIR}/user_properties.json | # See `Output Schema` |\n        | `Expect Response Body` | { \"required\": [\"id\", \"token\"] } | # Only these are required from this method |\n        | `Expect Response Body` | { \"additionalProperties\": false } | # Nothing extra should be responded by this method |\n        \"\"\"\n        response_properties = self.schema[\"properties\"][\"response\"][\n            \"properties\"\n        ]\n        if \"body\" in response_properties:\n            response_properties[\"body\"].update(self._input_object(schema))\n        else:\n            response_properties[\"body\"] = self._input_object(schema)\n        return response_properties[\"body\"]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending a GET request to the given endpoint.", "response": "def get(\n        self,\n        endpoint,\n        query=None,\n        timeout=None,\n        allow_redirects=None,\n        validate=True,\n        headers=None,\n    ):\n        \"\"\"*Sends a GET request to the endpoint.*\n\n        The endpoint is joined with the URL given on library init (if any).\n        If endpoint starts with ``http://`` or ``https://``, it is assumed\n        an URL outside the tested API (which may affect logging).\n\n        *Options*\n\n        ``query``: Request query parameters as a JSON object or a dictionary.\n        Alternatively, query parameters can be given as part of endpoint as well.\n\n        ``timeout``: A number of seconds to wait for the response before failing the keyword.\n\n        ``allow_redirects``: If false, do not follow any redirects.\n\n        ``validate``: If false, skips any request and response validations set\n        by expectation keywords and a spec given on library init.\n\n        ``headers``: Headers as a JSON object to add or override for the request.\n\n        *Examples*\n\n        | `GET` | /users/1 |\n        | `GET` | /users | timeout=2.5 |\n        | `GET` | /users?_limit=2 |\n        | `GET` | /users | _limit=2 |\n        | `GET` | /users | { \"_limit\": \"2\" } |\n        | `GET` | https://jsonplaceholder.typicode.com/users | headers={ \"Authentication\": \"\" } |\n        \"\"\"\n        endpoint = self._input_string(endpoint)\n        request = deepcopy(self.request)\n        request[\"method\"] = \"GET\"\n        request[\"query\"] = OrderedDict()\n        query_in_url = OrderedDict(parse_qsl(urlparse(endpoint).query))\n        if query_in_url:\n            request[\"query\"].update(query_in_url)\n            endpoint = endpoint.rsplit(\"?\", 1)[0]\n        if query:\n            request[\"query\"].update(self._input_object(query))\n        if allow_redirects is not None:\n            request[\"allowRedirects\"] = self._input_boolean(allow_redirects)\n        if timeout is not None:\n            request[\"timeout\"] = self._input_timeout(timeout)\n        validate = self._input_boolean(validate)\n        if headers:\n            request[\"headers\"].update(self._input_object(headers))\n        return self._request(endpoint, request, validate)[\"response\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef post(\n        self,\n        endpoint,\n        body=None,\n        timeout=None,\n        allow_redirects=None,\n        validate=True,\n        headers=None,\n    ):\n        \"\"\"*Sends a POST request to the endpoint.*\n\n        The endpoint is joined with the URL given on library init (if any).\n        If endpoint starts with ``http://`` or ``https://``, it is assumed\n        an URL outside the tested API (which may affect logging).\n\n        *Options*\n\n        ``body``: Request body parameters as a JSON object, file or a dictionary.\n\n        ``timeout``: A number of seconds to wait for the response before failing the keyword.\n\n        ``allow_redirects``: If false, do not follow any redirects.\n\n        ``validate``: If false, skips any request and response validations set\n        by expectation keywords and a spec given on library init.\n\n        ``headers``: Headers as a JSON object to add or override for the request.\n\n        *Examples*\n\n        | `POST` | /users | { \"id\": 11, \"name\": \"Gil Alexander\" } |\n        | `POST` | /users | ${CURDIR}/new_user.json |\n        \"\"\"\n        endpoint = self._input_string(endpoint)\n        request = deepcopy(self.request)\n        request[\"method\"] = \"POST\"\n        request[\"body\"] = self.input(body)\n        if allow_redirects is not None:\n            request[\"allowRedirects\"] = self._input_boolean(allow_redirects)\n        if timeout is not None:\n            request[\"timeout\"] = self._input_timeout(timeout)\n        validate = self._input_boolean(validate)\n        if headers:\n            request[\"headers\"].update(self._input_object(headers))\n        return self._request(endpoint, request, validate)[\"response\"]", "response": "Sends a POST request to the given endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(\n        self,\n        endpoint,\n        timeout=None,\n        allow_redirects=None,\n        validate=True,\n        headers=None,\n    ):\n        \"\"\"*Sends a DELETE request to the endpoint.*\n\n        The endpoint is joined with the URL given on library init (if any).\n        If endpoint starts with ``http://`` or ``https://``, it is assumed\n        an URL outside the tested API (which may affect logging).\n\n        *Options*\n\n        ``timeout``: A number of seconds to wait for the response before failing the keyword.\n\n        ``allow_redirects``: If false, do not follow any redirects.\n\n        ``validate``: If false, skips any request and response validations set\n        by expectation keywords and a spec given on library init.\n\n        ``headers``: Headers as a JSON object to add or override for the request.\n\n        *Examples*\n\n        | `DELETE` | /users/6 |\n        | `DELETE` | http://localhost:8273/state | validate=false |\n        \"\"\"\n        endpoint = self._input_string(endpoint)\n        request = deepcopy(self.request)\n        request[\"method\"] = \"DELETE\"\n        if allow_redirects is not None:\n            request[\"allowRedirects\"] = self._input_boolean(allow_redirects)\n        if timeout is not None:\n            request[\"timeout\"] = self._input_timeout(timeout)\n        validate = self._input_boolean(validate)\n        if headers:\n            request[\"headers\"].update(self._input_object(headers))\n        return self._request(endpoint, request, validate)[\"response\"]", "response": "Sends a DELETE request to the given endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef missing(self, field):\n        try:\n            matches = self._find_by_field(field, print_found=False)\n        except AssertionError:\n            return\n        for found in matches:\n            self.log_json(\n                found[\"reality\"],\n                \"\\n\\nExpected '%s' to not exist, but it is:\" % (field),\n            )\n        raise AssertionError(\n            \"Expected '%s' to not exist, but it does.\" % (field)\n        )", "response": "Assert that a field does not exist."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nasserts the field as JSON null.", "response": "def null(self, field, **validations):\n        \"\"\"*Asserts the field as JSON null.*\n\n        The field consists of parts separated by spaces, the parts being\n        object property names or array indices starting from 0, and the root\n        being the instance created by the last request (see `Output` for it).\n\n        For asserting deeply nested properties or multiple objects at once,\n        [http://goessner.net/articles/JsonPath|JSONPath] can be used with\n        [https://github.com/h2non/jsonpath-ng#jsonpath-syntax|supported JSONPath expressions],\n        the root being the response body.\n\n        *Validations*\n\n        The JSON Schema validation keywords\n        [https://json-schema.org/understanding-json-schema/reference/generic.html|common for all types]\n        can be used. Validations are optional but update the schema of\n        the property (more accurate) if given.\n        `Output Schema` can be used for the current schema of the field.\n\n        The keyword will fail if any of the given validations fail.\n        Given validations can be skipped altogether by adding ``skip=true``.\n        When skipped, the schema is updated but the validations are not ran.\n        Skip is intented mainly for debugging the updated schema before aborting.\n\n        *Examples*\n\n        | `PUT`  | /users/1 | { \"deactivated_at\": null } | # https://jsonplaceholder.typicode.com/users/1 |\n        | `Null` | response body deactivated_at | |\n        | `Null` | $.deactivated_at | | # JSONPath alternative |\n        \"\"\"\n        values = []\n        for found in self._find_by_field(field):\n            reality = found[\"reality\"]\n            schema = {\"type\": \"null\"}\n            skip = self._input_boolean(validations.pop(\"skip\", False))\n            if not skip:\n                self._assert_schema(schema, reality)\n            values.append(reality)\n        return values"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef boolean(self, field, value=None, **validations):\n        values = []\n        for found in self._find_by_field(field):\n            reality = found[\"reality\"]\n            schema = {\"type\": \"boolean\"}\n            if value is not None:\n                schema[\"enum\"] = [self._input_boolean(value)]\n            elif self._should_add_examples():\n                schema[\"examples\"] = [reality]\n            skip = self._input_boolean(validations.pop(\"skip\", False))\n            if not skip:\n                self._assert_schema(schema, reality)\n            values.append(reality)\n        return values", "response": "This method asserts the given field as JSON boolean."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts the input to JSON and returns it.", "response": "def input(self, what):\n        \"\"\"*Converts the input to JSON and returns it.*\n\n        Any of the following is accepted:\n\n        - The path to JSON file\n        - Any scalar that can be interpreted as JSON\n        - A dictionary or a list\n\n        *Examples*\n\n        | ${payload} | `Input` | ${CURDIR}/payload.json |\n\n        | ${object} | `Input` | { \"name\": \"Julie Langford\", \"username\": \"jlangfor\" } |\n        | ${object} | `Input` | ${dict} |\n\n        | ${array} | `Input` | [\"name\", \"username\"] |\n        | ${array} | `Input` | ${list} |\n\n        | ${boolean} | `Input` | true |\n        | ${boolean} | `Input` | ${True} |\n\n        | ${number} | `Input` | 2.0 |\n        | ${number} | `Input` | ${2.0} |\n\n        | ${string} | `Input` | Quotes are optional for strings |\n        \"\"\"\n        if what is None:\n            return None\n        if not isinstance(what, STRING_TYPES):\n            return self._input_json_from_non_string(what)\n        if path.isfile(what):\n            return self._input_json_from_file(what)\n        try:\n            return self._input_json_as_string(what)\n        except ValueError:\n            return self._input_string(what)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\noutputs the JSON Schema to terminal or a file.", "response": "def output_schema(\n        self, what=\"\", file_path=None, append=False, sort_keys=False\n    ):\n        \"\"\"*Outputs JSON Schema to terminal or a file.*\n\n        By default, the schema is output for the last request and response.\n\n        The output can be limited further by:\n\n        - The property of the last instance, e.g. ``request`` or ``response``\n        - Any nested property that exists, similarly as for assertion keywords\n\n        Also variables and values that can be converted to JSON are accepted,\n        in which case the schema is generated for those instead.\n\n        *Options*\n\n        ``file_path``: The JSON Schema is written to a file instead of terminal.\n        The file is created if it does not exist.\n\n        ``append``: If true, the JSON Schema is appended to the given file\n        instead of truncating it first.\n\n        ``sort_keys``: If true, the JSON Schema is sorted alphabetically by\n        property names before it is output.\n\n        *Examples*\n\n        | `Output Schema` | response | ${CURDIR}/response_schema.json | # Write a file to use with `Expect Response` |\n        | `Output Schema` | response body | ${CURDIR}/response_body_schema.json | # Write a file to use with `Expect Response Body` |\n\n        | `Output Schema` | $.email | # only the schema for one response body property |\n        | `Output Schema` | $..geo | # only the schema for the nested response body property |\n        \"\"\"\n        if isinstance(what, (STRING_TYPES)):\n            if what == \"\":\n                try:\n                    json = self._last_instance_or_error()[\"schema\"]\n                except IndexError:\n                    raise RuntimeError(no_instances_error)\n            elif what.startswith((\"request\", \"response\", \"$\")):\n                self._last_instance_or_error()\n                matches = self._find_by_field(what)\n                if len(matches) > 1:\n                    json = [found[\"schema\"] for found in matches]\n                else:\n                    json = matches[0][\"schema\"]\n            else:\n                try:\n                    json = self._new_schema(self._input_json_as_string(what))\n                except ValueError:\n                    json = self._new_schema(self._input_string(what))\n        else:\n            json = self._new_schema(self._input_json_from_non_string(what))\n        sort_keys = self._input_boolean(sort_keys)\n        if not file_path:\n            self.log_json(json, sort_keys=sort_keys)\n        else:\n            content = dumps(\n                json,\n                ensure_ascii=False,\n                indent=4,\n                separators=(\",\", \": \"),\n                sort_keys=sort_keys,\n            )\n            write_mode = \"a\" if self._input_boolean(append) else \"w\"\n            try:\n                with open(\n                    path.join(getcwd(), file_path), write_mode, encoding=\"utf-8\"\n                ) as file:\n                    if IS_PYTHON_2:\n                        content = unicode(content)\n                    file.write(content)\n            except IOError as e:\n                raise RuntimeError(\n                    \"Error outputting to file '%s':\\n%s\" % (file_path, e)\n                )\n        return json"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite the instances as JSON to a file.", "response": "def rest_instances(self, file_path=None, sort_keys=False):\n        \"\"\"*Writes the instances as JSON to a file.*\n\n        The instances are written to file as a JSON array of JSON objects,\n        each object representing a single instance, and having three properties:\n\n        - the request\n        - the response\n        - the schema for both, which have been updated according to the tests\n\n        The file is created if it does not exist, otherwise it is truncated.\n\n        *Options*\n\n        ``sort_keys``: If true, the instances are sorted alphabetically by\n        property names.\n\n        *Examples*\n\n        | `Rest Instances` | ${CURDIR}/log.json |\n        \"\"\"\n        if not file_path:\n            outputdir_path = BuiltIn().get_variable_value(\"${OUTPUTDIR}\")\n            if self.request[\"netloc\"]:\n                file_path = (\n                    path.join(outputdir_path, self.request[\"netloc\"]) + \".json\"\n                )\n            else:\n                file_path = path.join(outputdir_path, \"instances\") + \".json\"\n        sort_keys = self._input_boolean(sort_keys)\n        content = dumps(\n            self.instances,\n            ensure_ascii=False,\n            indent=4,\n            separators=(\",\", \": \"),\n            sort_keys=sort_keys,\n        )\n        try:\n            with open(file_path, \"w\", encoding=\"utf-8\") as file:\n                if IS_PYTHON_2:\n                    content = unicode(content)\n                file.write(content)\n        except IOError as e:\n            raise RuntimeError(\n                \"Error exporting instances \"\n                + \"to file '%s':\\n%s\" % (file_path, e)\n            )\n        return self.instances"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_tools(self):\n\n        for data in self.toolbardata:\n            # tool type is in data[0]\n\n            if data[0] == \"T\":\n                # Simple tool\n\n                _, msg_type, label, tool_tip = data\n                icon = icons[label]\n\n                self.label2id[label] = tool_id = wx.NewId()\n\n                self.AddSimpleTool(tool_id, label, icon,\n                                   short_help_string=tool_tip)\n\n                self.ids_msgs[tool_id] = msg_type\n\n                self.parent.Bind(wx.EVT_TOOL, self.OnTool, id=tool_id)\n\n            elif data[0] == \"S\":\n                # Separator\n\n                self.AddSeparator()\n\n            elif data[0] == \"C\":\n                # Control\n\n                _, control, tool_tip = data\n\n                self.AddControl(control, label=tool_tip)\n\n            elif data[0] == \"O\":\n                # Check tool / option button\n\n                _, label, tool_tip = data\n                icon = icons[label]\n\n                self.label2id[label] = tool_id = wx.NewId()\n\n                self.AddCheckTool(tool_id, label, icon, icon, tool_tip)\n\n            else:\n                raise ValueError(\"Unknown tooltype \" + str(data[0]))\n\n        self.SetCustomOverflowItems([], [])\n        self.Realize()\n\n        # Adjust Toolbar size\n        self.SetSize(self.DoGetBestSize())", "response": "Adds tools from self. toolbardata to self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef OnToggleTool(self, event):\n\n        config[\"check_spelling\"] = str(event.IsChecked())\n        toggle_id = self.parent.menubar.FindMenuItem(_(\"View\"),\n                                                     _(\"Check spelling\"))\n        if toggle_id != -1:\n            # Check may fail if translation is incomplete\n            toggle_item = self.parent.menubar.FindItemById(toggle_id)\n            toggle_item.Check(event.IsChecked())\n\n        self.parent.grid.grid_renderer.cell_cache.clear()\n        self.parent.grid.ForceRefresh()\n\n        event.Skip()", "response": "Toggle tool event handler"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef OnUpdate(self, event):\n\n        # Gray out undo and redo id not available\n\n        undo_toolid = self.label2id[\"Undo\"]\n        redo_toolid = self.label2id[\"Redo\"]\n\n        self.EnableTool(undo_toolid, undo.stack().canundo())\n        self.EnableTool(redo_toolid, undo.stack().canredo())\n\n        # Set ToolTip strings to potential next undo / redo action\n        undotext = undo.stack().undotext()\n        undo_tool = self.FindTool(undo_toolid)\n        if undotext is None:\n            undo_tool.SetShortHelp(_(\"No undo actions available\"))\n        else:\n            undo_tool.SetShortHelp(undotext)\n\n        redotext = undo.stack().redotext()\n        redo_tool = self.FindTool(redo_toolid)\n        if redotext is None:\n            redo_tool.SetShortHelp(_(\"No redo actions available\"))\n        else:\n            redo_tool.SetShortHelp(redotext)\n\n        self.Refresh()\n\n        event.Skip()", "response": "Updates the toolbar states"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_button_label(self):\n\n        dlg = wx.TextEntryDialog(self, _('Button label:'))\n\n        if dlg.ShowModal() == wx.ID_OK:\n            label = dlg.GetValue()\n        else:\n            label = \"\"\n\n        dlg.Destroy()\n\n        return label", "response": "Gets Button label from user and returns string"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef OnUpdate(self, event):\n\n        attributes = event.attr\n\n        self._update_buttoncell(attributes[\"button_cell\"])\n\n        self.Refresh()\n\n        event.Skip()", "response": "Updates the toolbar states"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate the search menu", "response": "def make_menu(self):\n        \"\"\"Creates the search menu\"\"\"\n\n        menu = wx.Menu()\n        item = menu.Append(-1, \"Recent Searches\")\n        item.Enable(False)\n\n        for __id, txt in enumerate(self.search_history):\n            menu.Append(__id, txt)\n        return menu"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef OnMenu(self, event):\n\n        __id = event.GetId()\n        try:\n            menuitem = event.GetEventObject().FindItemById(__id)\n            selected_text = menuitem.GetItemLabel()\n            self.search.SetValue(selected_text)\n        except AttributeError:\n            # Not called by menu\n            event.Skip()", "response": "Search history has been selected"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsearching event handler for starting the search", "response": "def OnSearch(self, event):\n        \"\"\"Event handler for starting the search\"\"\"\n\n        search_string = self.search.GetValue()\n\n        if search_string not in self.search_history:\n            self.search_history.append(search_string)\n        if len(self.search_history) > 10:\n            self.search_history.pop(0)\n\n        self.menu = self.make_menu()\n        self.search.SetMenu(self.menu)\n\n        search_flags = self.search_options + [\"FIND_NEXT\"]\n\n        post_command_event(self, self.FindMsg, text=search_string,\n                           flags=search_flags)\n\n        self.search.SetFocus()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef OnSearchFlag(self, event):\n\n        for label in self.search_options_buttons:\n            button_id = self.label2id[label]\n            if button_id == event.GetId():\n                if event.IsChecked():\n                    self.search_options.append(label)\n                else:\n                    flag_index = self.search_options.index(label)\n                    self.search_options.pop(flag_index)\n\n        event.Skip()", "response": "handler for search flag toggle buttons"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate font choice combo box", "response": "def _create_font_choice_combo(self):\n        \"\"\"Creates font choice combo box\"\"\"\n\n        self.fonts = get_font_list()\n        self.font_choice_combo = \\\n            _widgets.FontChoiceCombobox(self, choices=self.fonts,\n                                        style=wx.CB_READONLY, size=(125, -1))\n\n        self.font_choice_combo.SetToolTipString(_(u\"Text font\"))\n\n        self.AddControl(self.font_choice_combo)\n\n        self.Bind(wx.EVT_COMBOBOX, self.OnTextFont, self.font_choice_combo)\n        self.parent.Bind(self.EVT_CMD_TOOLBAR_UPDATE, self.OnUpdate)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_font_size_combo(self):\n\n        self.std_font_sizes = config[\"font_default_sizes\"]\n        font_size = str(get_default_font().GetPointSize())\n        self.font_size_combo = \\\n            wx.ComboBox(self, -1, value=font_size, size=(60, -1),\n                        choices=map(unicode, self.std_font_sizes),\n                        style=wx.CB_DROPDOWN | wx.TE_PROCESS_ENTER)\n\n        self.font_size_combo.SetToolTipString(_(u\"Text size\\n(points)\"))\n\n        self.AddControl(self.font_size_combo)\n        self.Bind(wx.EVT_COMBOBOX, self.OnTextSize, self.font_size_combo)\n        self.Bind(wx.EVT_TEXT_ENTER, self.OnTextSize, self.font_size_combo)", "response": "Creates font size combo box"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates font face buttons", "response": "def _create_font_face_buttons(self):\n        \"\"\"Creates font face buttons\"\"\"\n\n        font_face_buttons = [\n            (wx.FONTFLAG_BOLD, \"OnBold\", \"FormatTextBold\", _(\"Bold\")),\n            (wx.FONTFLAG_ITALIC, \"OnItalics\", \"FormatTextItalic\",\n             _(\"Italics\")),\n            (wx.FONTFLAG_UNDERLINED, \"OnUnderline\", \"FormatTextUnderline\",\n                _(\"Underline\")),\n            (wx.FONTFLAG_STRIKETHROUGH, \"OnStrikethrough\",\n                \"FormatTextStrikethrough\", _(\"Strikethrough\")),\n            (wx.FONTFLAG_MASK, \"OnFreeze\", \"Freeze\", _(\"Freeze\")),\n            (wx.FONTFLAG_NOT_ANTIALIASED, \"OnLock\", \"Lock\", _(\"Lock cell\")),\n            (wx.FONTFAMILY_DECORATIVE, \"OnMarkup\", \"Markup\", _(\"Markup\")),\n        ]\n\n        for __id, method, iconname, helpstring in font_face_buttons:\n            bmp = icons[iconname]\n            self.AddCheckTool(__id, iconname, bmp, bmp,\n                              short_help_string=helpstring)\n            self.Bind(wx.EVT_TOOL, getattr(self, method), id=__id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create_textrotation_button(self):\n\n        iconnames = [\"TextRotate270\", \"TextRotate0\", \"TextRotate90\",\n                     \"TextRotate180\"]\n        bmplist = [icons[iconname] for iconname in iconnames]\n\n        self.rotation_tb = _widgets.BitmapToggleButton(self, bmplist)\n        self.rotation_tb.SetToolTipString(_(u\"Cell text rotation\"))\n        self.Bind(wx.EVT_BUTTON, self.OnRotate, self.rotation_tb)\n        self.AddControl(self.rotation_tb)", "response": "Create text rotation toggle button"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _create_justification_button(self):\n\n        iconnames = [\"JustifyLeft\", \"JustifyCenter\", \"JustifyRight\"]\n        bmplist = [icons[iconname] for iconname in iconnames]\n        self.justify_tb = _widgets.BitmapToggleButton(self, bmplist)\n        self.justify_tb.SetToolTipString(_(u\"Justification\"))\n        self.Bind(wx.EVT_BUTTON, self.OnJustification, self.justify_tb)\n        self.AddControl(self.justify_tb)", "response": "Creates horizontal justification button"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _create_alignment_button(self):\n\n        iconnames = [\"AlignTop\", \"AlignCenter\", \"AlignBottom\"]\n        bmplist = [icons[iconname] for iconname in iconnames]\n\n        self.alignment_tb = _widgets.BitmapToggleButton(self, bmplist)\n        self.alignment_tb.SetToolTipString(_(u\"Alignment\"))\n        self.Bind(wx.EVT_BUTTON, self.OnAlignment, self.alignment_tb)\n        self.AddControl(self.alignment_tb)", "response": "Creates vertical alignment button"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _create_borderchoice_combo(self):\n\n        choices = [c[0] for c in self.border_toggles]\n        self.borderchoice_combo = \\\n            _widgets.BorderEditChoice(self, choices=choices,\n                                      style=wx.CB_READONLY, size=(50, -1))\n\n        self.borderchoice_combo.SetToolTipString(\n            _(u\"Choose borders for which attributes are changed\"))\n\n        self.borderstate = self.border_toggles[0][0]\n\n        self.AddControl(self.borderchoice_combo)\n\n        self.Bind(wx.EVT_COMBOBOX, self.OnBorderChoice,\n                  self.borderchoice_combo)\n\n        self.borderchoice_combo.SetValue(\"AllBorders\")", "response": "Create border choice combo box"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_penwidth_combo(self):\n\n        choices = map(unicode, xrange(12))\n        self.pen_width_combo = \\\n            _widgets.PenWidthComboBox(self, choices=choices,\n                                      style=wx.CB_READONLY, size=(50, -1))\n\n        self.pen_width_combo.SetToolTipString(_(u\"Border width\"))\n        self.AddControl(self.pen_width_combo)\n        self.Bind(wx.EVT_COMBOBOX, self.OnLineWidth, self.pen_width_combo)", "response": "Create pen width combo box"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _create_color_buttons(self):\n\n        button_size = (30, 30)\n        button_style = wx.NO_BORDER\n\n        try:\n            self.linecolor_choice = \\\n                csel.ColourSelect(self, -1, unichr(0x2500), (0, 0, 0),\n                                  size=button_size, style=button_style)\n        except UnicodeEncodeError:\n            # ANSI wxPython installed\n            self.linecolor_choice = \\\n                csel.ColourSelect(self, -1, \"-\", (0, 0, 0),\n                                  size=button_size, style=button_style)\n\n        self.bgcolor_choice = \\\n            csel.ColourSelect(self, -1, \"\", (255, 255, 255),\n                              size=button_size, style=button_style)\n        self.textcolor_choice = \\\n            csel.ColourSelect(self, -1, \"A\", (0, 0, 0),\n                              size=button_size, style=button_style)\n\n        self.linecolor_choice.SetToolTipString(_(u\"Border line color\"))\n        self.bgcolor_choice.SetToolTipString(_(u\"Cell background\"))\n        self.textcolor_choice.SetToolTipString(_(u\"Text color\"))\n\n        self.AddControl(self.linecolor_choice)\n        self.AddControl(self.bgcolor_choice)\n        self.AddControl(self.textcolor_choice)\n\n        self.linecolor_choice.Bind(csel.EVT_COLOURSELECT, self.OnLineColor)\n        self.bgcolor_choice.Bind(csel.EVT_COLOURSELECT, self.OnBGColor)\n        self.textcolor_choice.Bind(csel.EVT_COLOURSELECT, self.OnTextColor)", "response": "Create color choice buttons"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _update_font(self, textfont):\n\n        try:\n            fontface_id = self.fonts.index(textfont)\n        except ValueError:\n            fontface_id = 0\n\n        self.font_choice_combo.Select(fontface_id)", "response": "Updates text font widget with new font name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _update_font_weight(self, font_weight):\n\n        toggle_state = font_weight & wx.FONTWEIGHT_BOLD == wx.FONTWEIGHT_BOLD\n\n        self.ToggleTool(wx.FONTFLAG_BOLD, toggle_state)", "response": "Updates font weight widget"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _update_font_style(self, font_style):\n\n        toggle_state = font_style & wx.FONTSTYLE_ITALIC == wx.FONTSTYLE_ITALIC\n\n        self.ToggleTool(wx.FONTFLAG_ITALIC, toggle_state)", "response": "Updates font style widget"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the frozen cell widget", "response": "def _update_frozencell(self, frozen):\n        \"\"\"Updates frozen cell widget\n\n        Parameters\n        ----------\n\n        frozen: Bool or string\n        \\tUntoggled iif False\n\n        \"\"\"\n\n        toggle_state = frozen is not False\n\n        self.ToggleTool(wx.FONTFLAG_MASK, toggle_state)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _update_textrotation(self, angle):\n\n        states = {0: 0, -90: 1, 180: 2, 90: 3}\n\n        try:\n            self.rotation_tb.state = states[round(angle)]\n        except KeyError:\n            self.rotation_tb.state = 0\n\n        self.rotation_tb.toggle(None)\n        self.rotation_tb.Refresh()", "response": "Updates text rotation toggle button"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the horizontal text justification button", "response": "def _update_justification(self, justification):\n        \"\"\"Updates horizontal text justification button\n\n        Parameters\n        ----------\n\n        justification: String in [\"left\", \"center\", \"right\"]\n        \\tSwitches button to untoggled if False and toggled if True\n\n        \"\"\"\n\n        states = {\"left\": 2, \"center\": 0, \"right\": 1}\n\n        self.justify_tb.state = states[justification]\n\n        self.justify_tb.toggle(None)\n        self.justify_tb.Refresh()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the alignment button of the current locale.", "response": "def _update_alignment(self, alignment):\n        \"\"\"Updates vertical text alignment button\n\n        Parameters\n        ----------\n\n        alignment: String in [\"top\", \"middle\", \"right\"]\n        \\tSwitches button to untoggled if False and toggled if True\n\n        \"\"\"\n\n        states = {\"top\": 2, \"middle\": 0, \"bottom\": 1}\n\n        self.alignment_tb.state = states[alignment]\n\n        self.alignment_tb.toggle(None)\n        self.alignment_tb.Refresh()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates text font color button", "response": "def _update_fontcolor(self, fontcolor):\n        \"\"\"Updates text font color button\n\n        Parameters\n        ----------\n\n        fontcolor: Integer\n        \\tText color in integer RGB format\n\n        \"\"\"\n\n        textcolor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)\n        textcolor.SetRGB(fontcolor)\n\n        self.textcolor_choice.SetColour(textcolor)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the toolbar states", "response": "def OnUpdate(self, event):\n        \"\"\"Updates the toolbar states\"\"\"\n\n        attributes = event.attr\n\n        self._update_font(attributes[\"textfont\"])\n        self._update_pointsize(attributes[\"pointsize\"])\n        self._update_font_weight(attributes[\"fontweight\"])\n        self._update_font_style(attributes[\"fontstyle\"])\n        self._update_frozencell(attributes[\"frozen\"])\n        self._update_lockedcell(attributes[\"locked\"])\n        self._update_markupcell(attributes[\"markup\"])\n        self._update_underline(attributes[\"underline\"])\n        self._update_strikethrough(attributes[\"strikethrough\"])\n        self._update_justification(attributes[\"justification\"])\n        self._update_alignment(attributes[\"vertical_align\"])\n        self._update_fontcolor(attributes[\"textcolor\"])\n        self._update_merge(attributes[\"merge_area\"] is not None)\n        self._update_textrotation(attributes[\"angle\"])\n        self._update_bgbrush(attributes[\"bgcolor\"])\n        self._update_bordercolor(attributes[\"bordercolor_bottom\"])\n        self._update_borderwidth(attributes[\"borderwidth_bottom\"])\n\n        self.Refresh()\n\n        event.Skip()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging the borders that are affected by color and width changes", "response": "def OnBorderChoice(self, event):\n        \"\"\"Change the borders that are affected by color and width changes\"\"\"\n\n        choicelist = event.GetEventObject().GetItems()\n        self.borderstate = choicelist[event.GetInt()]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef OnLineColor(self, event):\n\n        color = event.GetValue().GetRGB()\n        borders = self.bordermap[self.borderstate]\n\n        post_command_event(self, self.BorderColorMsg, color=color,\n                           borders=borders)", "response": "Line color choice event handler"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef OnLineWidth(self, event):\n\n        linewidth_combobox = event.GetEventObject()\n        idx = event.GetInt()\n        width = int(linewidth_combobox.GetString(idx))\n        borders = self.bordermap[self.borderstate]\n\n        post_command_event(self, self.BorderWidthMsg, width=width,\n                           borders=borders)", "response": "Line width choice event handler"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef OnBGColor(self, event):\n\n        color = event.GetValue().GetRGB()\n\n        post_command_event(self, self.BackgroundColorMsg, color=color)", "response": "Background color choice event handler"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting code of cell key marks grid as changed", "response": "def set_code(self, key, code):\n        \"\"\"Sets code of cell key, marks grid as changed\"\"\"\n\n        old_code = self.grid.code_array(key)\n\n        try:\n            old_code = unicode(old_code, encoding=\"utf-8\")\n\n        except TypeError:\n            pass\n\n        if code == old_code:\n            return\n\n        if not (old_code is None and not code) and code != old_code:\n            # Mark content as changed\n            post_command_event(self.main_window, self.ContentChangedMsg)\n\n        # Set cell code\n        self.grid.code_array.__setitem__(key, code)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef quote_code(self, key):\n\n        code = self.grid.code_array(key)\n        quoted_code = quote(code)\n\n        if quoted_code is not None:\n            self.set_code(key, quoted_code)", "response": "Returns string quoted code"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_absolute_reference(self, ref_key):\n\n        key_str = u\", \".join(map(str, ref_key))\n        return u\"S[\" + key_str + u\"]\"", "response": "Returns absolute reference code for key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_relative_reference(self, cursor, ref_key):\n\n        magics = [\"X\", \"Y\", \"Z\"]\n\n        # mapper takes magic, key, ref_key to build string\n        def get_rel_key_ele(cursor_ele, ref_key_ele):\n            \"\"\"Returns relative key suffix for given key and reference key\"\"\"\n\n            # cursor is current cursor position\n            # ref_key is absolute target position\n\n            diff_key_ele = ref_key_ele - cursor_ele\n\n            if diff_key_ele == 0:\n                return u\"\"\n\n            elif diff_key_ele < 0:\n                return u\"-\" + str(abs(diff_key_ele))\n\n            elif diff_key_ele > 0:\n                return u\"+\" + str(diff_key_ele)\n\n            else:\n                msg = _(\"{key} seems to be no Integer\")\n                msg = msg.format(key=diff_key_ele)\n                raise ValueError(msg)\n\n        key_strings = []\n\n        for magic, cursor_ele, ref_key_ele in zip(magics, cursor, ref_key):\n            key_strings.append(magic +\n                               get_rel_key_ele(cursor_ele, ref_key_ele))\n\n        key_string = u\", \".join(key_strings)\n\n        return u\"S[\" + key_string + u\"]\"", "response": "Returns absolute reference code for given cursor and ref_key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nappending reference code to cell code.", "response": "def append_reference_code(self, key, ref_key, ref_type=\"absolute\"):\n        \"\"\"Appends reference code to cell code.\n\n        Replaces existing reference.\n\n        Parameters\n        ----------\n        key: 3-tuple of Integer\n        \\tKey of cell that gets the reference\n        ref_key: 3-tuple of Integer\n        \\tKey of cell that is referenced\n        ref_type: Sting in [\"absolute\", \"relative\"]\n        \\tAn absolute or a relative reference is added\n\n        \"\"\"\n\n        if ref_type == \"absolute\":\n            code = self._get_absolute_reference(ref_key)\n\n        elif ref_type == \"relative\":\n            code = self._get_relative_reference(key, ref_key)\n\n        else:\n            raise ValueError(_('ref_type has to be \"absolute\" or \"relative\".'))\n\n        old_code = self.grid.code_array(key)\n\n        if old_code is None:\n            old_code = u\"\"\n\n        if \"S\" in old_code and old_code[-1] == \"]\":\n            old_code_left, __ = old_code.rsplit(\"S\", 1)\n            new_code = old_code_left + code\n        else:\n            new_code = old_code + code\n\n        post_command_event(self.grid.main_window, self.EntryLineMsg,\n                           text=new_code)\n\n        return new_code"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_cell_attr(self, selection, table, attr):\n\n        # Mark content as changed\n        post_command_event(self.main_window, self.ContentChangedMsg)\n\n        if selection is not None:\n            self.code_array.cell_attributes.append((selection, table, attr))", "response": "Sets cell attributes for key cell and marks grid content as changed"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_attr(self, attr, value, selection=None):\n\n        if selection is None:\n            selection = self.grid.selection\n\n        if not selection:\n            # Add current cell to selection so that it gets changed\n            selection.cells.append(self.grid.actions.cursor[:2])\n\n        attrs = {attr: value}\n\n        table = self.grid.current_table\n\n        # Change model\n        self._set_cell_attr(selection, table, attrs)", "response": "Sets attr of current selection to value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_border_attr(self, attr, value, borders):\n\n        selection = self.grid.selection\n        if not selection:\n            selection.cells.append(self.grid.actions.cursor[:2])\n\n        # determine selection for core cells and selection for border cells\n        # Then apply according to inner and outer\n        # A cell is inner iif it is not at the edge of the selection bbox\n\n        if \"inner\" in borders:\n            if \"top\" in borders:\n                adj_selection = selection + (-1, 0)\n                self.set_attr(attr + \"_bottom\", value, adj_selection)\n\n            if \"bottom\" in borders:\n                self.set_attr(attr + \"_bottom\", value)\n\n            if \"left\" in borders:\n                adj_selection = selection + (0, -1)\n                self.set_attr(attr + \"_right\", value, adj_selection)\n\n            if \"right\" in borders:\n                self.set_attr(attr + \"_right\", value)\n\n        else:\n            # Adjust selection so that only bounding box edge is in selection\n            bbox_tl, bbox_lr = selection.get_bbox()\n            if \"top\" in borders:\n                adj_selection = Selection([bbox_tl],\n                                          [(bbox_tl[0], bbox_lr[1])],\n                                          [], [], []) + (-1, 0)\n                self.set_attr(attr + \"_bottom\", value, adj_selection)\n\n            if \"bottom\" in borders:\n                adj_selection = Selection([(bbox_lr[0], bbox_tl[1])],\n                                          [bbox_lr], [], [], [])\n                self.set_attr(attr + \"_bottom\", value, adj_selection)\n\n            if \"left\" in borders:\n                adj_selection = Selection([bbox_tl],\n                                          [(bbox_lr[0], bbox_tl[1])],\n                                          [], [], []) + (0, -1)\n                self.set_attr(attr + \"_right\", value, adj_selection)\n\n            if \"right\" in borders:\n                adj_selection = Selection([(bbox_tl[0], bbox_lr[1])],\n                                          [bbox_lr], [], [], [])\n                self.set_attr(attr + \"_right\", value, adj_selection)", "response": "Sets border attribute of the current node"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef toggle_attr(self, attr):\n\n        selection = self.grid.selection\n\n        # Selection or single cell access?\n\n        if selection:\n            value = self.get_new_selection_attr_state(selection, attr)\n\n        else:\n            value = self.get_new_cell_attr_state(self.grid.actions.cursor,\n                                                 attr)\n\n        # Set the toggled value\n\n        self.set_attr(attr, value)", "response": "Toggles an attribute attr for current selection"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef change_frozen_attr(self):\n\n        # Selections are not supported\n\n        if self.grid.selection:\n            statustext = _(\"Freezing selections is not supported.\")\n            post_command_event(self.main_window, self.StatusBarMsg,\n                               text=statustext)\n\n        cursor = self.grid.actions.cursor\n\n        frozen = self.grid.code_array.cell_attributes[cursor][\"frozen\"]\n\n        if frozen:\n            # We have an frozen cell that has to be unfrozen\n\n            # Delete frozen cache content\n            self.grid.code_array.frozen_cache.pop(repr(cursor))\n\n        else:\n            # We have an non-frozen cell that has to be frozen\n\n            # Add frozen cache content\n            res_obj = self.grid.code_array[cursor]\n            self.grid.code_array.frozen_cache[repr(cursor)] = res_obj\n\n        # Set the new frozen state / code\n        selection = Selection([], [], [], [], [cursor[:2]])\n        self.set_attr(\"frozen\", not frozen, selection=selection)", "response": "Changes frozen state of cell if there is no selection"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef merge(self, merge_area, tab):\n\n        top, left, bottom, right = merge_area\n\n        cursor = self.grid.actions.cursor\n        top_left_code = self.code_array((top, left, cursor[2]))\n\n        selection = Selection([(top, left)], [(bottom, right)], [], [], [])\n\n        # Check if the merge area overlaps another merge area\n\n        error_msg = _(\"Overlapping merge area at {} prevents merge.\")\n\n        for row in xrange(top, bottom + 1):\n            for col in xrange(left, right + 1):\n                key = row, col, tab\n                if self.code_array.cell_attributes[key][\"merge_area\"]:\n                    post_command_event(self.main_window, self.StatusBarMsg,\n                                       text=error_msg.format(str(key)))\n                    return\n\n        self.delete_selection(selection)\n        self.set_code((top, left, cursor[2]), top_left_code)\n\n        attr = {\"merge_area\": merge_area, \"locked\": True}\n\n        self._set_cell_attr(selection, tab, attr)\n\n        tl_selection = Selection([], [], [], [], [(top, left)])\n        attr = {\"locked\": False}\n\n        self._set_cell_attr(tl_selection, tab, attr)", "response": "Merges top left cell with all cells until bottom_right"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmerges or unmerges cells that are in the selection bounding box and returns the selected cell s attributes.", "response": "def merge_selected_cells(self, selection):\n        \"\"\"Merges or unmerges cells that are in the selection bounding box\n\n        Parameters\n        ----------\n        selection: Selection object\n        \\tSelection for which attr toggle shall be returned\n\n        \"\"\"\n\n        tab = self.grid.current_table\n\n        # Get the selection bounding box\n        bbox = selection.get_bbox()\n        if bbox is None:\n            row, col, tab = self.grid.actions.cursor\n            (bb_top, bb_left), (bb_bottom, bb_right) = (row, col), (row, col)\n        else:\n            (bb_top, bb_left), (bb_bottom, bb_right) = bbox\n        merge_area = bb_top, bb_left, bb_bottom, bb_right\n\n        # Check if top-left cell is already merged\n        cell_attributes = self.grid.code_array.cell_attributes\n        tl_merge_area = cell_attributes[(bb_top, bb_left, tab)][\"merge_area\"]\n\n        if tl_merge_area is not None and tl_merge_area[:2] == merge_area[:2]:\n            self.unmerge(tl_merge_area, tab)\n        else:\n            self.merge(merge_area, tab)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_new_cell_attr_state(self, key, attr_key):\n\n        cell_attributes = self.grid.code_array.cell_attributes\n        attr_values = self.attr_toggle_values[attr_key]\n\n        # Map attr_value to next attr_value\n        attr_map = dict(zip(attr_values, attr_values[1:] + attr_values[:1]))\n\n        # Return next value from attr_toggle_values value list\n\n        return attr_map[cell_attributes[key][attr_key]]", "response": "Returns new attr cell state for toggles\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntoggles new attr selection state and returns it", "response": "def get_new_selection_attr_state(self, selection, attr_key):\n        \"\"\"Toggles new attr selection state and returns it\n\n        Parameters\n        ----------\n        selection: Selection object\n        \\tSelection for which attr toggle shall be returned\n        attr_key: Hashable\n        \\tAttribute key\n\n        \"\"\"\n\n        cell_attributes = self.grid.code_array.cell_attributes\n        attr_values = self.attr_toggle_values[attr_key]\n\n        # Map attr_value to next attr_value\n        attr_map = dict(zip(attr_values, attr_values[1:] + attr_values[:1]))\n\n        selection_attrs = \\\n            (attr for attr in cell_attributes if attr[0] == selection)\n\n        attrs = {}\n        for selection_attr in selection_attrs:\n            attrs.update(selection_attr[2])\n\n        if attr_key in attrs:\n            return attr_map[attrs[attr_key]]\n\n        else:\n            # Default next value\n            return self.attr_toggle_values[attr_key][1]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef refresh_frozen_cell(self, key):\n\n        code = self.grid.code_array(key)\n        result = self.grid.code_array._eval_cell(key, code)\n        self.grid.code_array.frozen_cache[repr(key)] = result", "response": "Refreshes a frozen cell"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrefreshes content of frozen cells that are currently selected by the user.", "response": "def refresh_selected_frozen_cells(self, selection=None):\n        \"\"\"Refreshes content of frozen cells that are currently selected\n\n        If there is no selection, the cell at the cursor is updated.\n\n        Parameters\n        ----------\n        selection: Selection, defaults to None\n        \\tIf not None then use this selection instead of the grid selection\n\n        \"\"\"\n\n        if selection is None:\n            selection = self.grid.selection\n\n        # Add cursor to empty selection\n\n        if not selection:\n            selection.cells.append(self.grid.actions.cursor[:2])\n\n        cell_attributes = self.grid.code_array.cell_attributes\n\n        refreshed_keys = []\n\n        for attr_selection, tab, attr_dict in cell_attributes:\n            if tab == self.grid.actions.cursor[2] and \\\n               \"frozen\" in attr_dict and attr_dict[\"frozen\"]:\n                # Only single cells are allowed for freezing\n                skey = attr_selection.cells[0]\n                if skey in selection:\n                    key = tuple(list(skey) + [tab])\n                    if key not in refreshed_keys and \\\n                       cell_attributes[key][\"frozen\"]:\n                        self.refresh_frozen_cell(key)\n                        refreshed_keys.append(key)\n\n        cell_attributes._attr_cache.clear()\n        cell_attributes._table_cache.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef import_file(self, filepath, filterindex):\n\n        # Mark content as changed\n        post_command_event(self.main_window, self.ContentChangedMsg)\n\n        if filterindex == 0:\n            # CSV import option choice\n            return self._import_csv(filepath)\n        elif filterindex == 1:\n            # TXT import option choice\n            return self._import_txt(filepath)\n        else:\n            msg = _(\"Unknown import choice {choice}.\")\n            msg = msg.format(choice=filterindex)\n            short_msg = _('Error reading CSV file')\n\n            self.main_window.interfaces.display_warning(msg, short_msg)", "response": "Imports external file\n\n        Parameters\n        ----------\n\n        filepath: String\n        \\tPath of import file\n        filterindex: Integer\n        \\tIndex for type of file, 0: csv, 1: tab-delimited text file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _export_csv(self, filepath, data, preview_data):\n\n        # Get csv info\n\n        csv_info = \\\n            self.main_window.interfaces.get_csv_export_info(preview_data)\n\n        if csv_info is None:\n            return\n\n        try:\n            dialect, digest_types, has_header = csv_info\n        except TypeError:\n            return\n\n        # Export CSV file\n\n        csv_interface = CsvInterface(self.main_window, filepath, dialect,\n                                     digest_types, has_header)\n\n        try:\n            csv_interface.write(data)\n\n        except IOError, err:\n            msg = _(\"The file {filepath} could not be fully written\\n \\n\"\n                    \"Error message:\\n{msg}\")\n            msg = msg.format(filepath=filepath, msg=err)\n            short_msg = _('Error writing CSV file')\n            self.main_window.interfaces.display_warning(msg, short_msg)", "response": "Export the code array results to CSV file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _export_figure(self, filepath, data, format):\n\n        formats = [\"svg\", \"eps\", \"ps\", \"pdf\", \"png\"]\n        assert format in formats\n\n        data = fig2x(data, format)\n\n        try:\n            outfile = open(filepath, \"wb\")\n            outfile.write(data)\n\n        except IOError, err:\n            msg = _(\"The file {filepath} could not be fully written\\n \\n\"\n                    \"Error message:\\n{msg}\")\n            msg = msg.format(filepath=filepath, msg=err)\n            short_msg = _('Error writing SVG file')\n            self.main_window.interfaces.display_warning(msg, short_msg)\n\n        finally:\n            outfile.close()", "response": "Export of single cell that contains a matplotlib figure"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef export_file(self, filepath, __filter, data, preview_data=None):\n\n        if __filter.startswith(\"cell_\"):\n            self._export_figure(filepath, data, __filter[5:])\n\n        elif __filter == \"csv\":\n            self._export_csv(filepath, data, preview_data=preview_data)\n\n        elif __filter in [\"pdf\", \"svg\"]:\n            self.export_cairo(filepath, __filter)", "response": "Export data for other applications"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning wx. Rect that is correctly positioned on the print canvas", "response": "def get_print_rect(self, grid_rect):\n        \"\"\"Returns wx.Rect that is correctly positioned on the print canvas\"\"\"\n\n        grid = self.grid\n\n        rect_x = grid_rect.x - \\\n            grid.GetScrollPos(wx.HORIZONTAL) * grid.GetScrollLineX()\n        rect_y = grid_rect.y - \\\n            grid.GetScrollPos(wx.VERTICAL) * grid.GetScrollLineY()\n\n        return wx.Rect(rect_x, rect_y, grid_rect.width, grid_rect.height)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef export_cairo(self, filepath, filetype):\n\n        if cairo is None:\n            return\n\n        export_info = \\\n            self.main_window.interfaces.get_cairo_export_info(filetype)\n\n        if export_info is None:\n            # Dialog has been canceled\n            return\n\n        top_row = max(0, export_info[\"top_row\"])\n        bottom_row = min(self.grid.code_array.shape[0] - 1,\n                         export_info[\"bottom_row\"])\n        left_col = max(0, export_info[\"left_col\"])\n        right_col = min(self.grid.code_array.shape[1] - 1,\n                        export_info[\"right_col\"])\n        first_tab = max(0, export_info[\"first_tab\"])\n        last_tab = min(self.grid.code_array.shape[2] - 1,\n                       export_info[\"last_tab\"])\n        width = export_info[\"paper_width\"]\n        height = export_info[\"paper_height\"]\n        orientation = export_info[\"orientation\"]\n\n        if orientation == \"landscape\":\n            width, height = height, width\n\n        if filetype == \"pdf\":\n            surface = cairo.PDFSurface(filepath, width, height)\n        elif filetype == \"svg\":\n            surface = cairo.SVGSurface(filepath, width, height)\n        else:\n            msg = \"Export filetype {filtype} not supported.\".format(\n                filetype=filetype)\n            raise ValueError(msg)\n\n        context = cairo.Context(surface)\n\n        grid_cairo_renderer = GridCairoRenderer(\n            context,\n            self.code_array,\n            (top_row, bottom_row + 1),\n            (left_col, right_col + 1),\n            (first_tab, last_tab + 1),\n            width,\n            height,\n            orientation,\n            view_frozen=self.grid._view_frozen,\n        )\n\n        grid_cairo_renderer.draw()\n\n        # Finish is required for matplotlib figures\n        surface.finish()", "response": "Exports the grid to the PDF file filepath"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint out the print area", "response": "def printout(self, print_area, print_data):\n        \"\"\"Print out print area\n\n        See:\n        http://aspn.activestate.com/ASPN/Mail/Message/wxpython-users/3471083\n\n        \"\"\"\n\n        print_info = \\\n            self.main_window.interfaces.get_cairo_export_info(\"Print\")\n\n        if print_info is None:\n            # Dialog has been canceled\n            return\n\n        pdd = wx.PrintDialogData(print_data)\n        printer = wx.Printer(pdd)\n\n        printout = Printout(self.grid, print_data, print_info)\n\n        if printer.Print(self.main_window, printout, True):\n            self.print_data = \\\n                wx.PrintData(printer.GetPrintDialogData().GetPrintData())\n\n        printout.Destroy()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn code for given key", "response": "def _get_code(self, key):\n        \"\"\"Returns code for given key (one cell)\n\n        Parameters\n        ----------\n\n        key: 3-Tuple of Integer\n        \\t Cell key\n\n        \"\"\"\n\n        data = self.grid.code_array(key)\n        self.grid.code_array.result_cache.clear()\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy(self, selection, getter=None, delete=False):\n\n        if getter is None:\n            getter = self._get_code\n\n        tab = self.grid.current_table\n\n        selection_bbox = selection.get_bbox()\n\n        if not selection_bbox:\n            # There is no selection\n            bb_top, bb_left = self.grid.actions.cursor[:2]\n            bb_bottom, bb_right = bb_top, bb_left\n        else:\n            replace_none = self.main_window.grid.actions._replace_bbox_none\n            (bb_top, bb_left), (bb_bottom, bb_right) = \\\n                replace_none(selection.get_bbox())\n\n        data = []\n\n        for __row in xrange(bb_top, bb_bottom + 1):\n            data.append([])\n\n            for __col in xrange(bb_left, bb_right + 1):\n                # Only copy content if cell is in selection or\n                # if there is no selection\n\n                if (__row, __col) in selection or not selection_bbox:\n                    content = getter((__row, __col, tab))\n\n                    # Delete cell if delete flag is set\n\n                    if delete:\n                        try:\n                            self.grid.code_array.pop((__row, __col, tab))\n\n                        except KeyError:\n                            pass\n\n                    # Store data\n\n                    if content is None:\n                        data[-1].append(u\"\")\n\n                    else:\n                        data[-1].append(content)\n\n                else:\n                    data[-1].append(u\"\")\n\n        return \"\\n\".join(\"\\t\".join(line) for line in data)", "response": "Returns code from selection in a tab separated string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_result_string(self, key):\n\n        row, col, tab = key\n\n        result_obj = self.grid.code_array[row, col, tab]\n\n        try:\n            # Numpy object arrays are converted because of numpy repr bug\n            result_obj = result_obj.tolist()\n\n        except AttributeError:\n            pass\n\n        return unicode(result_obj)", "response": "Returns unicode string of result for given key"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef copy_result(self, selection):\n\n        bbox = selection.get_bbox()\n\n        if not bbox:\n            # There is no selection\n            bb_top, bb_left = self.grid.actions.cursor[:2]\n            bb_bottom, bb_right = bb_top, bb_left\n        else:\n            # Thereis a selection\n            (bb_top, bb_left), (bb_bottom, bb_right) = bbox\n\n        if bb_top == bb_bottom and bb_left == bb_right:\n            # We have  a single selection\n\n            tab = self.grid.current_table\n            result = self.grid.code_array[bb_top, bb_left, tab]\n\n            if isinstance(result, wx._gdi.Bitmap):\n                # The result is a wx.Bitmap. Return it.\n                return result\n\n            elif Figure is not None and isinstance(result, Figure):\n                # The result is a matplotlib figure\n                # Therefore, a wx.Bitmap is returned\n                key = bb_top, bb_left, tab\n                rect = self.grid.CellToRect(bb_top, bb_left)\n                merged_rect = self.grid.grid_renderer.get_merged_rect(\n                    self.grid, key, rect)\n                dpi = float(wx.ScreenDC().GetPPI()[0])\n                zoom = self.grid.grid_renderer.zoom\n\n                return fig2bmp(result, merged_rect.width, merged_rect.height,\n                               dpi, zoom)\n\n        # So we have result strings to be returned\n        getter = self._get_result_string\n\n        return self.copy(selection, getter=getter)", "response": "Returns a copy of the result for the given selection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef img2code(self, key, img):\n\n        code_template = \\\n            \"wx.ImageFromData({width}, {height}, \" + \\\n            \"bz2.decompress(base64.b64decode('{data}'))).ConvertToBitmap()\"\n\n        code_alpha_template = \\\n            \"wx.ImageFromDataWithAlpha({width}, {height}, \" + \\\n            \"bz2.decompress(base64.b64decode('{data}')), \" + \\\n            \"bz2.decompress(base64.b64decode('{alpha}'))).ConvertToBitmap()\"\n\n        data = base64.b64encode(bz2.compress(img.GetData(), 9))\n\n        if img.HasAlpha():\n            alpha = base64.b64encode(bz2.compress(img.GetAlphaData(), 9))\n            code_str = code_alpha_template.format(\n                width=img.GetWidth(), height=img.GetHeight(),\n                data=data, alpha=alpha)\n        else:\n            code_str = code_template.format(width=img.GetWidth(),\n                                            height=img.GetHeight(), data=data)\n\n        return code_str", "response": "Pastes wx. Image into single cell"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_paste_data_gen(self, key, data):\n\n        if type(data) is wx._gdi.Bitmap:\n            code_str = self.bmp2code(key, data)\n            return [[code_str]]\n        else:\n            return (line.split(\"\\t\") for line in data.split(\"\\n\"))", "response": "Generator for paste data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npaste data into grid", "response": "def paste(self, key, data):\n        \"\"\"Pastes data into grid\n\n        Parameters\n        ----------\n\n        key: 2-Tuple of Integer\n        \\tTop left cell\n        data: String or wx.Bitmap\n        \\tTab separated string of paste data\n        \\tor paste data image\n        \"\"\"\n\n        data_gen = self._get_paste_data_gen(key, data)\n\n        self.grid.actions.paste(key[:2], data_gen, freq=1000)\n\n        self.main_window.grid.ForceRefresh()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns list of lists of obj than has dimensionality dim", "response": "def _get_pasteas_data(self, dim, obj):\n        \"\"\"Returns list of lists of obj than has dimensionality dim\n\n        Parameters\n        ----------\n        dim: Integer\n        \\tDimensionality of obj\n        obj: Object\n        \\tIterable object of dimensionality dim\n\n        \"\"\"\n\n        if dim == 0:\n            return [[repr(obj)]]\n        elif dim == 1:\n            return [[repr(o)] for o in obj]\n        elif dim == 2:\n            return [map(repr, o) for o in obj]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef paste_as(self, key, data):\n\n        def error_msg(err):\n            msg = _(\"Error evaluating data: \") + str(err)\n            post_command_event(self.main_window, self.StatusBarMsg, text=msg)\n\n        interfaces = self.main_window.interfaces\n        key = self.main_window.grid.actions.cursor\n\n        try:\n            obj = ast.literal_eval(data)\n\n        except (SyntaxError, AttributeError):\n            # This is no Python code so te try to interpret it as paste data\n            try:\n                obj = [map(ast.literal_eval, line.split(\"\\t\"))\n                       for line in data.split(\"\\n\")]\n\n            except Exception, err:\n                # This must just be text.\n                try:\n                    obj = [line.split('\\t') for line in data.split('\\n')]\n                except Exception, err:\n                    # Now I really have no idea\n                    error_msg(err)\n                    return\n\n        except ValueError, err:\n            error_msg(err)\n            return\n\n        parameters = interfaces.get_pasteas_parameters_from_user(obj)\n\n        if parameters is None:\n            # Dialog aborted\n            return\n\n        paste_data = self._get_pasteas_data(parameters[\"dim\"], obj)\n\n        if parameters[\"transpose\"]:\n            paste_data = zip(*paste_data)\n\n        self.main_window.grid.actions.paste(key, paste_data, freq=1000)", "response": "Paste and transform data from user input data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute_macros(self):\n\n        # Mark content as changed\n        post_command_event(self.main_window, self.ContentChangedMsg)\n\n        (result, err) = self.grid.code_array.execute_macros()\n\n        # Post event to macro dialog\n        post_command_event(self.main_window, self.MacroErrorMsg,\n                           msg=result, err=err)", "response": "Executes macros and marks grid as changed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_macros(self, filepath):\n\n        try:\n            wx.BeginBusyCursor()\n            self.main_window.grid.Disable()\n\n            with open(filepath) as macro_infile:\n                # Enter safe mode\n                self.main_window.grid.actions.enter_safe_mode()\n                post_command_event(self.main_window, self.SafeModeEntryMsg)\n\n                # Mark content as changed\n                post_command_event(self.main_window, self.ContentChangedMsg)\n\n                macrocode = macro_infile.read()\n\n                self.grid.code_array.macros += \"\\n\" + macrocode.strip(\"\\n\")\n                self.grid.main_window.macro_panel.codetext_ctrl.SetText(\n                    self.grid.code_array.macros)\n\n        except IOError:\n            msg = _(\"Error opening file {filepath}.\").format(filepath=filepath)\n            post_command_event(self.main_window, self.StatusBarMsg, text=msg)\n\n            return False\n\n        finally:\n            self.main_window.grid.Enable()\n            wx.EndBusyCursor()\n\n        # Mark content as changed\n        try:\n            post_command_event(self.main_window, self.ContentChangedMsg)\n\n        except TypeError:\n            # The main window does not exist any more\n            pass", "response": "Loads macros from file and marks grid as changed\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_macros(self, filepath, macros):\n\n        io_error_text = _(\"Error writing to file {filepath}.\")\n        io_error_text = io_error_text.format(filepath=filepath)\n\n        # Make sure that old macro file does not get lost on abort save\n        tmpfile = filepath + \"~\"\n\n        try:\n            wx.BeginBusyCursor()\n            self.main_window.grid.Disable()\n            with open(tmpfile, \"w\") as macro_outfile:\n                macro_outfile.write(macros)\n\n            # Move save file from temp file to filepath\n            try:\n                os.rename(tmpfile, filepath)\n\n            except OSError:\n                # No tmp file present\n                pass\n\n        except IOError:\n            try:\n                post_command_event(self.main_window, self.StatusBarMsg,\n                                   text=io_error_text)\n            except TypeError:\n                # The main window does not exist any more\n                pass\n\n            return False\n\n        finally:\n            self.main_window.grid.Enable()\n            wx.EndBusyCursor()", "response": "Saves macros to file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef launch_help(self, helpname, filename):\n\n        # Set up window\n\n        position = config[\"help_window_position\"]\n        size = config[\"help_window_size\"]\n\n        self.help_window = wx.Frame(self.main_window, -1,\n                                    helpname, position, size)\n        self.help_htmlwindow = wx.html.HtmlWindow(self.help_window, -1,\n                                                  (0, 0), size)\n\n        self.help_window.Bind(wx.EVT_MOVE, self.OnHelpMove)\n        self.help_window.Bind(wx.EVT_SIZE, self.OnHelpSize)\n        self.help_htmlwindow.Bind(wx.EVT_RIGHT_DOWN, self.OnHelpBack)\n        self.help_htmlwindow.Bind(wx.html.EVT_HTML_LINK_CLICKED,\n                                  lambda e: self.open_external_links(e))\n        self.help_htmlwindow.Bind(wx.EVT_MOUSEWHEEL,\n                                  lambda e: self.zoom_html(e))\n\n        # Get help data\n        current_path = os.getcwd()\n        os.chdir(get_help_path())\n\n        try:\n            if os.path.isfile(filename):\n                self.help_htmlwindow.LoadFile(filename)\n\n            else:\n                self.help_htmlwindow.LoadPage(filename)\n\n        except IOError:\n            self.help_htmlwindow.LoadPage(filename)\n\n        # Show tutorial window\n\n        self.help_window.Show()\n\n        os.chdir(current_path)", "response": "Generic help launcher\n\n        Launches HTMLWindow that shows content of filename\n        or the Internet page with the filename url\n\n        Parameters\n        ----------\n\n        filename: String\n        \\thtml file or url"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhelps window move event handler stores position in config", "response": "def OnHelpMove(self, event):\n        \"\"\"Help window move event handler stores position in config\"\"\"\n\n        position = event.GetPosition()\n        config[\"help_window_position\"] = repr((position.x, position.y))\n\n        event.Skip()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef OnHelpSize(self, event):\n\n        size = event.GetSize()\n        config[\"help_window_size\"] = repr((size.width, size.height))\n\n        event.Skip()", "response": "Help window size event handler stores size in config"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef vlcpanel_factory(filepath, volume=None):\n\n    vlc_panel_cls = VLCPanel\n    VLCPanel.filepath = filepath\n    if volume is not None:\n        VLCPanel.volume = volume\n\n    return vlc_panel_cls", "response": "Returns a VLCPanel class based on filepath and volume"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef SetClientRect(self, rect):\n\n        panel_posx = rect[0] + self.grid.GetRowLabelSize()\n        panel_posy = rect[1] + self.grid.GetColLabelSize()\n\n        panel_scrolled_pos = self.grid.CalcScrolledPosition(panel_posx,\n                                                            panel_posy)\n        # If the scrolled position is inside the grid labels then hide\n        self.SetPosition(panel_scrolled_pos)\n        wx.Panel.SetClientRect(self, wx.Rect(0, 0, rect[2], rect[3]))\n\n        # Handle videos that are partly visible or that become invisible\n        row_label_size = self.grid.GetRowLabelSize()\n        col_label_size = self.grid.GetColLabelSize()\n\n        if panel_scrolled_pos[0] < row_label_size or \\\n           panel_scrolled_pos[1] < col_label_size:\n            self.Hide()\n        else:\n            self.Show()", "response": "Positions and resizes the video panel"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntoggling the video status between play and hold", "response": "def OnTogglePlay(self, event):\n        \"\"\"Toggles the video status between play and hold\"\"\"\n\n        if self.player.get_state() == vlc.State.Playing:\n            self.player.pause()\n        else:\n            self.player.play()\n\n        event.Skip()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshifting through the video", "response": "def OnShiftVideo(self, event):\n        \"\"\"Shifts through the video\"\"\"\n\n        length = self.player.get_length()\n        time = self.player.get_time()\n\n        if event.GetWheelRotation() < 0:\n            target_time = max(0, time-length/100.0)\n        elif event.GetWheelRotation() > 0:\n            target_time = min(length, time+length/100.0)\n\n        self.player.set_time(int(target_time))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load(self):\n\n        # Config files prior to 0.2.4 dor not have config version keys\n        old_config = not self.cfg_file.Exists(\"config_version\")\n\n        # Reset data\n        self.data.__dict__.update(self.defaults.__dict__)\n\n        for key in self.defaults.__dict__:\n            if self.cfg_file.Exists(key):\n                setattr(self.data, key, self.cfg_file.Read(key))\n\n        # Reset keys that should be reset on version upgrades\n        if old_config or self.version != self.data.config_version:\n            for key in self.reset_on_version_change:\n                setattr(self.data, key, getattr(DefaultConfig(), key))\n            self.data.config_version = self.version\n\n        # Delete gpg_key_uid and insert fingerprint key\n\n        if hasattr(self.data, \"gpg_key_uid\"):\n            oldkey = \"gpg_key_uid\"\n            delattr(self.data, oldkey)\n            newkey = \"gpg_key_fingerprint\"\n            setattr(self.data, newkey, getattr(DefaultConfig(), newkey))", "response": "Loads the configuration file and sets the data attribute to the default config values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _Cobject(cls, ctype):\n    o = object.__new__(cls)\n    o._as_parameter_ = ctype\n    return o", "response": "Internal method to create a new object from ctypes.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef string_result(result, func, arguments):\n    if result:\n        # make a python string copy\n        s = bytes_to_str(ctypes.string_at(result))\n        # free original string ptr\n        libvlc_free(result)\n        return s\n    return None", "response": "Errcheck function. Returns a string and frees original pointer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a TrackDescription linked list to a Python list.", "response": "def track_description_list(head):\n    \"\"\"Convert a TrackDescription linked list to a Python list (and release the former).\n    \"\"\"\n    r = []\n    if head:\n        item = head\n        while item:\n            item = item.contents\n            r.append((item.id, item.name))\n            item = item.next\n        try:\n            libvlc_track_description_release(head)\n        except NameError:\n            libvlc_track_description_list_release(head)\n\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef module_description_list(head):\n    r = []\n    if head:\n        item = head\n        while item:\n            item = item.contents\n            r.append((item.name, item.shortname, item.longname, item.help))\n            item = item.next\n        libvlc_module_description_list_release(head)\n    return r", "response": "Convert a ModuleDescription linked list to a Python list and release the former."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the LibVLC error status and message for the current thread.", "response": "def libvlc_vprinterr(fmt, ap):\n    '''Sets the LibVLC error status and message for the current thread.\n    Any previous error is overridden.\n    @param fmt: the format string.\n    @param ap: the arguments.\n    @return: a nul terminated string in any case.\n    '''\n    f = _Cfunctions.get('libvlc_vprinterr', None) or \\\n        _Cfunction('libvlc_vprinterr', ((1,), (1,),), None,\n                    ctypes.c_char_p, ctypes.c_char_p, ctypes.c_void_p)\n    return f(fmt, ap)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef libvlc_new(argc, argv):\n    '''Create and initialize a libvlc instance.\n    This functions accept a list of \"command line\" arguments similar to the\n    main(). These arguments affect the LibVLC instance default configuration.\n    @param argc: the number of arguments (should be 0).\n    @param argv: list of arguments (should be NULL).\n    @return: the libvlc instance or NULL in case of error.\n    @version Arguments are meant to be passed from the command line to LibVLC, just like VLC media player does. The list of valid arguments depends on the LibVLC version, the operating system and platform, and set of available LibVLC plugins. Invalid or unsupported arguments will cause the function to fail (i.e. return NULL). Also, some arguments may alter the behaviour or otherwise interfere with other LibVLC functions. @warning There is absolutely no warranty or promise of forward, backward and cross-platform compatibility with regards to L{libvlc_new}() arguments. We recommend that you do not use them, other than when debugging.\n    '''\n    f = _Cfunctions.get('libvlc_new', None) or \\\n        _Cfunction('libvlc_new', ((1,), (1,),), class_result(Instance),\n                    ctypes.c_void_p, ctypes.c_int, ListPOINTER(ctypes.c_char_p))\n    return f(argc, argv)", "response": "Create and initialize a libvlc instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef libvlc_add_intf(p_instance, name):\n    '''Try to start a user interface for the libvlc instance.\n    @param p_instance: the instance.\n    @param name: interface name, or NULL for default.\n    @return: 0 on success, -1 on error.\n    '''\n    f = _Cfunctions.get('libvlc_add_intf', None) or \\\n        _Cfunction('libvlc_add_intf', ((1,), (1,),), None,\n                    ctypes.c_int, Instance, ctypes.c_char_p)\n    return f(p_instance, name)", "response": "Try to start a user interface for the libvlc instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef libvlc_set_user_agent(p_instance, name, http):\n    '''Sets the application name. LibVLC passes this as the user agent string\n    when a protocol requires it.\n    @param p_instance: LibVLC instance.\n    @param name: human-readable application name, e.g. \"FooBar player 1.2.3\".\n    @param http: HTTP User Agent, e.g. \"FooBar/1.2.3 Python/2.6.0\".\n    @version: LibVLC 1.1.1 or later.\n    '''\n    f = _Cfunctions.get('libvlc_set_user_agent', None) or \\\n        _Cfunction('libvlc_set_user_agent', ((1,), (1,), (1,),), None,\n                    None, Instance, ctypes.c_char_p, ctypes.c_char_p)\n    return f(p_instance, name, http)", "response": "Sets the application name. LibVLC passes this as the user agent string\n    when a protocol requires it. LibVLC passes this as the user agent string\n    when a protocol requires it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef libvlc_set_app_id(p_instance, id, version, icon):\n    '''Sets some meta-information about the application.\n    See also L{libvlc_set_user_agent}().\n    @param p_instance: LibVLC instance.\n    @param id: Java-style application identifier, e.g. \"com.acme.foobar\".\n    @param version: application version numbers, e.g. \"1.2.3\".\n    @param icon: application icon name, e.g. \"foobar\".\n    @version: LibVLC 2.1.0 or later.\n    '''\n    f = _Cfunctions.get('libvlc_set_app_id', None) or \\\n        _Cfunction('libvlc_set_app_id', ((1,), (1,), (1,), (1,),), None,\n                    None, Instance, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p)\n    return f(p_instance, id, version, icon)", "response": "Sets some meta - information about the application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfreeing an heap allocation returned by a LibVLC function.", "response": "def libvlc_free(ptr):\n    '''Frees an heap allocation returned by a LibVLC function.\n    If you know you're using the same underlying C run-time as the LibVLC\n    implementation, then you can call ANSI C free() directly instead.\n    @param ptr: the pointer.\n    '''\n    f = _Cfunctions.get('libvlc_free', None) or \\\n        _Cfunction('libvlc_free', ((1,),), None,\n                    None, ctypes.c_void_p)\n    return f(ptr)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nregistering for an event notification.", "response": "def libvlc_event_attach(p_event_manager, i_event_type, f_callback, user_data):\n    '''Register for an event notification.\n    @param p_event_manager: the event manager to which you want to attach to. Generally it is obtained by vlc_my_object_event_manager() where my_object is the object you want to listen to.\n    @param i_event_type: the desired event to which we want to listen.\n    @param f_callback: the function to call when i_event_type occurs.\n    @param user_data: user provided data to carry with the event.\n    @return: 0 on success, ENOMEM on error.\n    '''\n    f = _Cfunctions.get('libvlc_event_attach', None) or \\\n        _Cfunction('libvlc_event_attach', ((1,), (1,), (1,), (1,),), None,\n                    ctypes.c_int, EventManager, ctypes.c_uint, Callback, ctypes.c_void_p)\n    return f(p_event_manager, i_event_type, f_callback, user_data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef libvlc_event_type_name(event_type):\n    '''Get an event's type name.\n    @param event_type: the desired event.\n    '''\n    f = _Cfunctions.get('libvlc_event_type_name', None) or \\\n        _Cfunction('libvlc_event_type_name', ((1,),), None,\n                    ctypes.c_char_p, ctypes.c_uint)\n    return f(event_type)", "response": "Get an event s type name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef libvlc_log_get_context(ctx):\n    '''Gets debugging information about a log message: the name of the VLC module\n    emitting the message and the message location within the source code.\n    The returned module name and file name will be NULL if unknown.\n    The returned line number will similarly be zero if unknown.\n    @param ctx: message context (as passed to the @ref libvlc_log_cb callback).\n    @return: module module name storage (or NULL), file source code file name storage (or NULL), line source code file line number storage (or NULL).\n    @version: LibVLC 2.1.0 or later.\n    '''\n    f = _Cfunctions.get('libvlc_log_get_context', None) or \\\n        _Cfunction('libvlc_log_get_context', ((1,), (2,), (2,), (2,),), None,\n                    None, Log_ptr, ListPOINTER(ctypes.c_char_p), ListPOINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_uint))\n    return f(ctx)", "response": "Gets debugging information about a log message."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets information about a log message.", "response": "def libvlc_log_get_object(ctx, id):\n    '''Gets VLC object information about a log message: the type name of the VLC\n    object emitting the message, the object header if any and a temporaly-unique\n    object identifier. This information is mainly meant for B{manual}\n    troubleshooting.\n    The returned type name may be \"generic\" if unknown, but it cannot be NULL.\n    The returned header will be NULL if unset; in current versions, the header\n    is used to distinguish for VLM inputs.\n    The returned object ID will be zero if the message is not associated with\n    any VLC object.\n    @param ctx: message context (as passed to the @ref libvlc_log_cb callback).\n    @return: name object name storage (or NULL), header object header (or NULL), line source code file line number storage (or NULL).\n    @version: LibVLC 2.1.0 or later.\n    '''\n    f = _Cfunctions.get('libvlc_log_get_object', None) or \\\n        _Cfunction('libvlc_log_get_object', ((1,), (2,), (2,), (1,),), None,\n                    None, Log_ptr, ListPOINTER(ctypes.c_char_p), ListPOINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_uint))\n    return f(ctx, id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef libvlc_log_set(cb, data, p_instance):\n    '''Sets the logging callback for a LibVLC instance.\n    This function is thread-safe: it will wait for any pending callbacks\n    invocation to complete.\n    @param cb: callback function pointer.\n    @param data: opaque data pointer for the callback function @note Some log messages (especially debug) are emitted by LibVLC while is being initialized. These messages cannot be captured with this interface. @warning A deadlock may occur if this function is called from the callback.\n    @param p_instance: libvlc instance.\n    @version: LibVLC 2.1.0 or later.\n    '''\n    f = _Cfunctions.get('libvlc_log_set', None) or \\\n        _Cfunction('libvlc_log_set', ((1,), (1,), (1,),), None,\n                    None, Instance, LogCb, ctypes.c_void_p)\n    return f(cb, data, p_instance)", "response": "Sets the logging callback for a LibVLC instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets up logging to a file.", "response": "def libvlc_log_set_file(p_instance, stream):\n    '''Sets up logging to a file.\n    @param p_instance: libvlc instance.\n    @param stream: FILE pointer opened for writing (the FILE pointer must remain valid until L{libvlc_log_unset}()).\n    @version: LibVLC 2.1.0 or later.\n    '''\n    f = _Cfunctions.get('libvlc_log_set_file', None) or \\\n        _Cfunction('libvlc_log_set_file', ((1,), (1,),), None,\n                    None, Instance, FILE_ptr)\n    return f(p_instance, stream)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef libvlc_module_description_list_release(p_list):\n    '''Release a list of module descriptions.\n    @param p_list: the list to be released.\n    '''\n    f = _Cfunctions.get('libvlc_module_description_list_release', None) or \\\n        _Cfunction('libvlc_module_description_list_release', ((1,),), None,\n                    None, ctypes.POINTER(ModuleDescription))\n    return f(p_list)", "response": "Release a list of module descriptions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of audio filters that are available.", "response": "def libvlc_audio_filter_list_get(p_instance):\n    '''Returns a list of audio filters that are available.\n    @param p_instance: libvlc instance.\n    @return: a list of module descriptions. It should be freed with L{libvlc_module_description_list_release}(). In case of an error, NULL is returned. See L{ModuleDescription} See L{libvlc_module_description_list_release}.\n    '''\n    f = _Cfunctions.get('libvlc_audio_filter_list_get', None) or \\\n        _Cfunction('libvlc_audio_filter_list_get', ((1,),), None,\n                    ctypes.POINTER(ModuleDescription), Instance)\n    return f(p_instance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef libvlc_media_new_location(p_instance, psz_mrl):\n    '''Create a media with a certain given media resource location,\n    for instance a valid URL.\n    @note: To refer to a local file with this function,\n    the file://... URI syntax B{must} be used (see IETF RFC3986).\n    We recommend using L{libvlc_media_new_path}() instead when dealing with\n    local files.\n    See L{libvlc_media_release}.\n    @param p_instance: the instance.\n    @param psz_mrl: the media location.\n    @return: the newly created media or NULL on error.\n    '''\n    f = _Cfunctions.get('libvlc_media_new_location', None) or \\\n        _Cfunction('libvlc_media_new_location', ((1,), (1,),), class_result(Media),\n                    ctypes.c_void_p, Instance, ctypes.c_char_p)\n    return f(p_instance, psz_mrl)", "response": "Create a new media with a certain given media resource location."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new media for a certain file path.", "response": "def libvlc_media_new_path(p_instance, path):\n    '''Create a media for a certain file path.\n    See L{libvlc_media_release}.\n    @param p_instance: the instance.\n    @param path: local filesystem path.\n    @return: the newly created media or NULL on error.\n    '''\n    f = _Cfunctions.get('libvlc_media_new_path', None) or \\\n        _Cfunction('libvlc_media_new_path', ((1,), (1,),), class_result(Media),\n                    ctypes.c_void_p, Instance, ctypes.c_char_p)\n    return f(p_instance, path)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new media for an already open file descriptor.", "response": "def libvlc_media_new_fd(p_instance, fd):\n    '''Create a media for an already open file descriptor.\n    The file descriptor shall be open for reading (or reading and writing).\n    Regular file descriptors, pipe read descriptors and character device\n    descriptors (including TTYs) are supported on all platforms.\n    Block device descriptors are supported where available.\n    Directory descriptors are supported on systems that provide fdopendir().\n    Sockets are supported on all platforms where they are file descriptors,\n    i.e. all except Windows.\n    @note: This library will B{not} automatically close the file descriptor\n    under any circumstance. Nevertheless, a file descriptor can usually only be\n    rendered once in a media player. To render it a second time, the file\n    descriptor should probably be rewound to the beginning with lseek().\n    See L{libvlc_media_release}.\n    @param p_instance: the instance.\n    @param fd: open file descriptor.\n    @return: the newly created media or NULL on error.\n    @version: LibVLC 1.1.5 and later.\n    '''\n    f = _Cfunctions.get('libvlc_media_new_fd', None) or \\\n        _Cfunction('libvlc_media_new_fd', ((1,), (1,),), class_result(Media),\n                    ctypes.c_void_p, Instance, ctypes.c_int)\n    return f(p_instance, fd)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef libvlc_media_new_callbacks(instance, open_cb, read_cb, seek_cb, close_cb, opaque):\n    '''Create a media with custom callbacks to read the data from.\n    @param instance: LibVLC instance.\n    @param open_cb: callback to open the custom bitstream input media.\n    @param read_cb: callback to read data (must not be NULL).\n    @param seek_cb: callback to seek, or NULL if seeking is not supported.\n    @param close_cb: callback to close the media, or NULL if unnecessary.\n    @param opaque: data pointer for the open callback.\n    @return: the newly created media or NULL on error @note If open_cb is NULL, the opaque pointer will be passed to read_cb, seek_cb and close_cb, and the stream size will be treated as unknown. @note The callbacks may be called asynchronously (from another thread). A single stream instance need not be reentrant. However the open_cb needs to be reentrant if the media is used by multiple player instances. @warning The callbacks may be used until all or any player instances that were supplied the media item are stopped. See L{libvlc_media_release}.\n    @version: LibVLC 3.0.0 and later.\n    '''\n    f = _Cfunctions.get('libvlc_media_new_callbacks', None) or \\\n        _Cfunction('libvlc_media_new_callbacks', ((1,), (1,), (1,), (1,), (1,), (1,),), class_result(Media),\n                    ctypes.c_void_p, Instance, MediaOpenCb, MediaReadCb, MediaSeekCb, MediaCloseCb, ctypes.c_void_p)\n    return f(instance, open_cb, read_cb, seek_cb, close_cb, opaque)", "response": "Create a new media with custom callbacks to read the data from."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef libvlc_media_new_as_node(p_instance, psz_name):\n    '''Create a media as an empty node with a given name.\n    See L{libvlc_media_release}.\n    @param p_instance: the instance.\n    @param psz_name: the name of the node.\n    @return: the new empty media or NULL on error.\n    '''\n    f = _Cfunctions.get('libvlc_media_new_as_node', None) or \\\n        _Cfunction('libvlc_media_new_as_node', ((1,), (1,),), class_result(Media),\n                    ctypes.c_void_p, Instance, ctypes.c_char_p)\n    return f(p_instance, psz_name)", "response": "Create a media as an empty node with a given name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef libvlc_media_add_option(p_md, psz_options):\n    '''Add an option to the media.\n    This option will be used to determine how the media_player will\n    read the media. This allows to use VLC's advanced\n    reading/streaming options on a per-media basis.\n    @note: The options are listed in 'vlc --long-help' from the command line,\n    e.g. \"-sout-all\". Keep in mind that available options and their semantics\n    vary across LibVLC versions and builds.\n    @warning: Not all options affects L{Media} objects:\n    Specifically, due to architectural issues most audio and video options,\n    such as text renderer options, have no effects on an individual media.\n    These options must be set through L{libvlc_new}() instead.\n    @param p_md: the media descriptor.\n    @param psz_options: the options (as a string).\n    '''\n    f = _Cfunctions.get('libvlc_media_add_option', None) or \\\n        _Cfunction('libvlc_media_add_option', ((1,), (1,),), None,\n                    None, Media, ctypes.c_char_p)\n    return f(p_md, psz_options)", "response": "Add an option to the media."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef libvlc_media_add_option_flag(p_md, psz_options, i_flags):\n    '''Add an option to the media with configurable flags.\n    This option will be used to determine how the media_player will\n    read the media. This allows to use VLC's advanced\n    reading/streaming options on a per-media basis.\n    The options are detailed in vlc --long-help, for instance\n    \"--sout-all\". Note that all options are not usable on medias:\n    specifically, due to architectural issues, video-related options\n    such as text renderer options cannot be set on a single media. They\n    must be set on the whole libvlc instance instead.\n    @param p_md: the media descriptor.\n    @param psz_options: the options (as a string).\n    @param i_flags: the flags for this option.\n    '''\n    f = _Cfunctions.get('libvlc_media_add_option_flag', None) or \\\n        _Cfunction('libvlc_media_add_option_flag', ((1,), (1,), (1,),), None,\n                    None, Media, ctypes.c_char_p, ctypes.c_uint)\n    return f(p_md, psz_options, i_flags)", "response": "Add an option to the media with configurable flags."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the media resource locator from a media descriptor object.", "response": "def libvlc_media_get_mrl(p_md):\n    '''Get the media resource locator (mrl) from a media descriptor object.\n    @param p_md: a media descriptor object.\n    @return: string with mrl of media descriptor object.\n    '''\n    f = _Cfunctions.get('libvlc_media_get_mrl', None) or \\\n        _Cfunction('libvlc_media_get_mrl', ((1,),), string_result,\n                    ctypes.c_void_p, Media)\n    return f(p_md)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nduplicating a media descriptor object.", "response": "def libvlc_media_duplicate(p_md):\n    '''Duplicate a media descriptor object.\n    @param p_md: a media descriptor object.\n    '''\n    f = _Cfunctions.get('libvlc_media_duplicate', None) or \\\n        _Cfunction('libvlc_media_duplicate', ((1,),), class_result(Media),\n                    ctypes.c_void_p, Media)\n    return f(p_md)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread the meta of the media.", "response": "def libvlc_media_get_meta(p_md, e_meta):\n    '''Read the meta of the media.\n    If the media has not yet been parsed this will return NULL.\n    This methods automatically calls L{libvlc_media_parse_async}(), so after calling\n    it you may receive a libvlc_MediaMetaChanged event. If you prefer a synchronous\n    version ensure that you call L{libvlc_media_parse}() before get_meta().\n    See L{libvlc_media_parse}\n    See L{libvlc_media_parse_async}\n    See libvlc_MediaMetaChanged.\n    @param p_md: the media descriptor.\n    @param e_meta: the meta to read.\n    @return: the media's meta.\n    '''\n    f = _Cfunctions.get('libvlc_media_get_meta', None) or \\\n        _Cfunction('libvlc_media_get_meta', ((1,), (1,),), string_result,\n                    ctypes.c_void_p, Media, Meta)\n    return f(p_md, e_meta)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef libvlc_media_set_meta(p_md, e_meta, psz_value):\n    '''Set the meta of the media (this function will not save the meta, call\n    L{libvlc_media_save_meta} in order to save the meta).\n    @param p_md: the media descriptor.\n    @param e_meta: the meta to write.\n    @param psz_value: the media's meta.\n    '''\n    f = _Cfunctions.get('libvlc_media_set_meta', None) or \\\n        _Cfunction('libvlc_media_set_meta', ((1,), (1,), (1,),), None,\n                    None, Media, Meta, ctypes.c_char_p)\n    return f(p_md, e_meta, psz_value)", "response": "Set the meta of the media."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef libvlc_media_save_meta(p_md):\n    '''Save the meta previously set.\n    @param p_md: the media desriptor.\n    @return: true if the write operation was successful.\n    '''\n    f = _Cfunctions.get('libvlc_media_save_meta', None) or \\\n        _Cfunction('libvlc_media_save_meta', ((1,),), None,\n                    ctypes.c_int, Media)\n    return f(p_md)", "response": "Save the meta previously set."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef libvlc_media_get_state(p_md):\n    '''Get current state of media descriptor object. Possible media states\n    are defined in libvlc_structures.c ( libvlc_NothingSpecial=0,\n    libvlc_Opening, libvlc_Buffering, libvlc_Playing, libvlc_Paused,\n    libvlc_Stopped, libvlc_Ended,\n    libvlc_Error).\n    See libvlc_state_t.\n    @param p_md: a media descriptor object.\n    @return: state of media descriptor object.\n    '''\n    f = _Cfunctions.get('libvlc_media_get_state', None) or \\\n        _Cfunction('libvlc_media_get_state', ((1,),), None,\n                    State, Media)\n    return f(p_md)", "response": "Get current state of a media descriptor object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef libvlc_media_get_stats(p_md, p_stats):\n    '''Get the current statistics about the media.\n    @param p_md:: media descriptor object.\n    @param p_stats:: structure that contain the statistics about the media (this structure must be allocated by the caller).\n    @return: true if the statistics are available, false otherwise \\libvlc_return_bool.\n    '''\n    f = _Cfunctions.get('libvlc_media_get_stats', None) or \\\n        _Cfunction('libvlc_media_get_stats', ((1,), (1,),), None,\n                    ctypes.c_int, Media, ctypes.POINTER(MediaStats))\n    return f(p_md, p_stats)", "response": "Get the current statistics about the media."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting subitems of media descriptor object. This will increment the reference count of supplied media descriptor object. Use libvlc_media_list_acquire to decrement the reference count of supplied media descriptor object.", "response": "def libvlc_media_subitems(p_md):\n    '''Get subitems of media descriptor object. This will increment\n    the reference count of supplied media descriptor object. Use\n    L{libvlc_media_list_release}() to decrement the reference counting.\n    @param p_md: media descriptor object.\n    @return: list of media descriptor subitems or NULL.\n    '''\n    f = _Cfunctions.get('libvlc_media_subitems', None) or \\\n        _Cfunction('libvlc_media_subitems', ((1,),), class_result(MediaList),\n                    ctypes.c_void_p, Media)\n    return f(p_md)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget event manager from media descriptor object.", "response": "def libvlc_media_event_manager(p_md):\n    '''Get event manager from media descriptor object.\n    NOTE: this function doesn't increment reference counting.\n    @param p_md: a media descriptor object.\n    @return: event manager object.\n    '''\n    f = _Cfunctions.get('libvlc_media_event_manager', None) or \\\n        _Cfunction('libvlc_media_event_manager', ((1,),), class_result(EventManager),\n                    ctypes.c_void_p, Media)\n    return f(p_md)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget duration of media item.", "response": "def libvlc_media_get_duration(p_md):\n    '''Get duration (in ms) of media descriptor object item.\n    @param p_md: media descriptor object.\n    @return: duration of media item or -1 on error.\n    '''\n    f = _Cfunctions.get('libvlc_media_get_duration', None) or \\\n        _Cfunction('libvlc_media_get_duration', ((1,),), None,\n                    ctypes.c_longlong, Media)\n    return f(p_md)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the media asynchronously with options.", "response": "def libvlc_media_parse_with_options(p_md, parse_flag):\n    '''Parse the media asynchronously with options.\n    This fetches (local or network) art, meta data and/or tracks information.\n    This method is the extended version of L{libvlc_media_parse_async}().\n    To track when this is over you can listen to libvlc_MediaParsedChanged\n    event. However if this functions returns an error, you will not receive this\n    event.\n    It uses a flag to specify parse options (see libvlc_media_parse_flag_t). All\n    these flags can be combined. By default, media is parsed if it's a local\n    file.\n    See libvlc_MediaParsedChanged\n    See L{libvlc_media_get_meta}\n    See L{libvlc_media_tracks_get}\n    See libvlc_media_parse_flag_t.\n    @param p_md: media descriptor object.\n    @param parse_flag: parse options:\n    @return: -1 in case of error, 0 otherwise.\n    @version: LibVLC 3.0.0 or later.\n    '''\n    f = _Cfunctions.get('libvlc_media_parse_with_options', None) or \\\n        _Cfunction('libvlc_media_parse_with_options', ((1,), (1,),), None,\n                    ctypes.c_int, Media, MediaParseFlag)\n    return f(p_md, parse_flag)"}
