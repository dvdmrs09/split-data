{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget attribute by name.", "response": "def get_attribute_by_name(el, name, default=None):\n        \"\"\"Get attribute by name.\"\"\"\n\n        value = default\n        if el._is_xml:\n            try:\n                value = el.attrs[name]\n            except KeyError:\n                pass\n        else:\n            for k, v in el.attrs.items():\n                if util.lower(k) == name:\n                    value = v\n                    break\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_text(self, el, no_iframe=False):\n\n        return ''.join(\n            [node for node in self.get_descendants(el, tags=False, no_iframe=no_iframe) if self.is_content_string(node)]\n        )", "response": "Get text from the element."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the input value.", "response": "def parse_value(cls, itype, value):\n        \"\"\"Parse the input value.\"\"\"\n\n        parsed = None\n        if itype == \"date\":\n            m = RE_DATE.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                day = int(m.group('day'), 10)\n                if cls.validate_year(year) and cls.validate_month(month) and cls.validate_day(year, month, day):\n                    parsed = (year, month, day)\n        elif itype == \"month\":\n            m = RE_MONTH.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                if cls.validate_year(year) and cls.validate_month(month):\n                    parsed = (year, month)\n        elif itype == \"week\":\n            m = RE_WEEK.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                week = int(m.group('week'), 10)\n                if cls.validate_year(year) and cls.validate_week(year, week):\n                    parsed = (year, week)\n        elif itype == \"time\":\n            m = RE_TIME.match(value)\n            if m:\n                hour = int(m.group('hour'), 10)\n                minutes = int(m.group('minutes'), 10)\n                if cls.validate_hour(hour) and cls.validate_minutes(minutes):\n                    parsed = (hour, minutes)\n        elif itype == \"datetime-local\":\n            m = RE_DATETIME.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                day = int(m.group('day'), 10)\n                hour = int(m.group('hour'), 10)\n                minutes = int(m.group('minutes'), 10)\n                if (\n                    cls.validate_year(year) and cls.validate_month(month) and cls.validate_day(year, month, day) and\n                    cls.validate_hour(hour) and cls.validate_minutes(minutes)\n                ):\n                    parsed = (year, month, day, hour, minutes)\n        elif itype in (\"number\", \"range\"):\n            m = RE_NUM.match(value)\n            if m:\n                parsed = float(m.group('value'))\n        return parsed"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_bidi(self, el):\n\n        for node in self.get_children(el, tags=False):\n\n            # Analyze child text nodes\n            if self.is_tag(node):\n\n                # Avoid analyzing certain elements specified in the specification.\n                direction = DIR_MAP.get(util.lower(self.get_attribute_by_name(node, 'dir', '')), None)\n                if (\n                    self.get_tag(node) in ('bdi', 'script', 'style', 'textarea', 'iframe') or\n                    not self.is_html_tag(node) or\n                    direction is not None\n                ):\n                    continue  # pragma: no cover\n\n                # Check directionality of this node's text\n                value = self.find_bidi(node)\n                if value is not None:\n                    return value\n\n                # Direction could not be determined\n                continue  # pragma: no cover\n\n            # Skip `doctype` comments, etc.\n            if self.is_special_string(node):\n                continue\n\n            # Analyze text nodes for directionality.\n            for c in node:\n                bidi = unicodedata.bidirectional(c)\n                if bidi in ('AL', 'R', 'L'):\n                    return ct.SEL_DIR_LTR if bidi == 'L' else ct.SEL_DIR_RTL\n        return None", "response": "Find the bidi of an element."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmatching attribute name and return value if it exists.", "response": "def match_attribute_name(self, el, attr, prefix):\n        \"\"\"Match attribute name and return value if it exists.\"\"\"\n\n        value = None\n        if self.supports_namespaces():\n            value = None\n            # If we have not defined namespaces, we can't very well find them, so don't bother trying.\n            if prefix:\n                ns = self.namespaces.get(prefix)\n                if ns is None and prefix != '*':\n                    return None\n            else:\n                ns = None\n\n            for k, v in self.iter_attributes(el):\n\n                # Get attribute parts\n                namespace, name = self.split_namespace(el, k)\n\n                # Can't match a prefix attribute as we haven't specified one to match\n                # Try to match it normally as a whole `p:a` as selector may be trying `p\\:a`.\n                if ns is None:\n                    if (self.is_xml and attr == k) or (not self.is_xml and util.lower(attr) == util.lower(k)):\n                        value = v\n                        break\n                    # Coverage is not finding this even though it is executed.\n                    # Adding a print statement before this (and erasing coverage) causes coverage to find the line.\n                    # Ignore the false positive message.\n                    continue  # pragma: no cover\n\n                # We can't match our desired prefix attribute as the attribute doesn't have a prefix\n                if namespace is None or ns != namespace and prefix != '*':\n                    continue\n\n                # The attribute doesn't match.\n                if (util.lower(attr) != util.lower(name)) if not self.is_xml else (attr != name):\n                    continue\n\n                value = v\n                break\n        else:\n            for k, v in self.iter_attributes(el):\n                if util.lower(attr) != util.lower(k):\n                    continue\n                value = v\n                break\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_namespace(self, el, tag):\n\n        match = True\n        namespace = self.get_tag_ns(el)\n        default_namespace = self.namespaces.get('')\n        tag_ns = '' if tag.prefix is None else self.namespaces.get(tag.prefix, None)\n        # We must match the default namespace if one is not provided\n        if tag.prefix is None and (default_namespace is not None and namespace != default_namespace):\n            match = False\n        # If we specified `|tag`, we must not have a namespace.\n        elif (tag.prefix is not None and tag.prefix == '' and namespace):\n            match = False\n        # Verify prefix matches\n        elif (\n            tag.prefix and\n            tag.prefix != '*' and (tag_ns is None or namespace != tag_ns)\n        ):\n            match = False\n        return match", "response": "Match the namespace of the element."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmatch relationship to other elements.", "response": "def match_relations(self, el, relation):\n        \"\"\"Match relationship to other elements.\"\"\"\n\n        found = False\n\n        if relation[0].rel_type.startswith(':'):\n            found = self.match_future_relations(el, relation)\n        else:\n            found = self.match_past_relations(el, relation)\n\n        return found"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef match_id(self, el, ids):\n\n        found = True\n        for i in ids:\n            if i != self.get_attribute_by_name(el, 'id', ''):\n                found = False\n                break\n        return found", "response": "Match element s ID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef match_classes(self, el, classes):\n\n        current_classes = self.get_classes(el)\n        found = True\n        for c in classes:\n            if c not in current_classes:\n                found = False\n                break\n        return found", "response": "Match element s classes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_nth_tag_type(self, el, child):\n\n        return(\n            (self.get_tag(child) == self.get_tag(el)) and\n            (self.get_tag_ns(child) == self.get_tag_ns(el))\n        )", "response": "Match tag type for nth matches."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef match_empty(self, el):\n\n        is_empty = True\n        for child in self.get_children(el, tags=False):\n            if self.is_tag(child):\n                is_empty = False\n                break\n            elif self.is_content_string(child) and RE_NOT_EMPTY.search(child):\n                is_empty = False\n                break\n        return is_empty", "response": "Check if element is empty."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match_contains(self, el, contains):\n\n        match = True\n        content = None\n        for contain_list in contains:\n            if content is None:\n                content = self.get_text(el, no_iframe=self.is_html)\n            found = False\n            for text in contain_list.text:\n                if text in content:\n                    found = True\n                    break\n            if not found:\n                match = False\n        return match", "response": "Match element if it contains text."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmatching the input element with the default form.", "response": "def match_default(self, el):\n        \"\"\"Match default.\"\"\"\n\n        match = False\n\n        # Find this input's form\n        form = None\n        parent = self.get_parent(el, no_iframe=True)\n        while parent and form is None:\n            if self.get_tag(parent) == 'form' and self.is_html_tag(parent):\n                form = parent\n            else:\n                parent = self.get_parent(parent, no_iframe=True)\n\n        # Look in form cache to see if we've already located its default button\n        found_form = False\n        for f, t in self.cached_default_forms:\n            if f is form:\n                found_form = True\n                if t is el:\n                    match = True\n                break\n\n        # We didn't have the form cached, so look for its default button\n        if not found_form:\n            for child in self.get_descendants(form, no_iframe=True):\n                name = self.get_tag(child)\n                # Can't do nested forms (haven't figured out why we never hit this)\n                if name == 'form':  # pragma: no cover\n                    break\n                if name in ('input', 'button'):\n                    v = self.get_attribute_by_name(child, 'type', '')\n                    if v and util.lower(v) == 'submit':\n                        self.cached_default_forms.append([form, child])\n                        if el is child:\n                            match = True\n                        break\n        return match"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef match_indeterminate(self, el):\n\n        match = False\n        name = self.get_attribute_by_name(el, 'name')\n\n        def get_parent_form(el):\n            \"\"\"Find this input's form.\"\"\"\n            form = None\n            parent = self.get_parent(el, no_iframe=True)\n            while form is None:\n                if self.get_tag(parent) == 'form' and self.is_html_tag(parent):\n                    form = parent\n                    break\n                last_parent = parent\n                parent = self.get_parent(parent, no_iframe=True)\n                if parent is None:\n                    form = last_parent\n                    break\n            return form\n\n        form = get_parent_form(el)\n\n        # Look in form cache to see if we've already evaluated that its fellow radio buttons are indeterminate\n        found_form = False\n        for f, n, i in self.cached_indeterminate_forms:\n            if f is form and n == name:\n                found_form = True\n                if i is True:\n                    match = True\n                break\n\n        # We didn't have the form cached, so validate that the radio button is indeterminate\n        if not found_form:\n            checked = False\n            for child in self.get_descendants(form, no_iframe=True):\n                if child is el:\n                    continue\n                tag_name = self.get_tag(child)\n                if tag_name == 'input':\n                    is_radio = False\n                    check = False\n                    has_name = False\n                    for k, v in self.iter_attributes(child):\n                        if util.lower(k) == 'type' and util.lower(v) == 'radio':\n                            is_radio = True\n                        elif util.lower(k) == 'name' and v == name:\n                            has_name = True\n                        elif util.lower(k) == 'checked':\n                            check = True\n                        if is_radio and check and has_name and get_parent_form(child) is form:\n                            checked = True\n                            break\n                if checked:\n                    break\n            if not checked:\n                match = True\n            self.cached_indeterminate_forms.append([form, name, match])\n\n        return match", "response": "Match an indeterminate form."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match_dir(self, el, directionality):\n\n        # If we have to match both left and right, we can't match either.\n        if directionality & ct.SEL_DIR_LTR and directionality & ct.SEL_DIR_RTL:\n            return False\n\n        if el is None or not self.is_html_tag(el):\n            return False\n\n        # Element has defined direction of left to right or right to left\n        direction = DIR_MAP.get(util.lower(self.get_attribute_by_name(el, 'dir', '')), None)\n        if direction not in (None, 0):\n            return direction == directionality\n\n        # Element is the document element (the root) and no direction assigned, assume left to right.\n        is_root = self.is_root(el)\n        if is_root and direction is None:\n            return ct.SEL_DIR_LTR == directionality\n\n        # If `input[type=telephone]` and no direction is assigned, assume left to right.\n        name = self.get_tag(el)\n        is_input = name == 'input'\n        is_textarea = name == 'textarea'\n        is_bdi = name == 'bdi'\n        itype = util.lower(self.get_attribute_by_name(el, 'type', '')) if is_input else ''\n        if is_input and itype == 'tel' and direction is None:\n            return ct.SEL_DIR_LTR == directionality\n\n        # Auto handling for text inputs\n        if ((is_input and itype in ('text', 'search', 'tel', 'url', 'email')) or is_textarea) and direction == 0:\n            if is_textarea:\n                value = []\n                for node in self.get_contents(el, no_iframe=True):\n                    if self.is_content_string(node):\n                        value.append(node)\n                value = ''.join(value)\n            else:\n                value = self.get_attribute_by_name(el, 'value', '')\n            if value:\n                for c in value:\n                    bidi = unicodedata.bidirectional(c)\n                    if bidi in ('AL', 'R', 'L'):\n                        direction = ct.SEL_DIR_LTR if bidi == 'L' else ct.SEL_DIR_RTL\n                        return direction == directionality\n                # Assume left to right\n                return ct.SEL_DIR_LTR == directionality\n            elif is_root:\n                return ct.SEL_DIR_LTR == directionality\n            return self.match_dir(self.get_parent(el, no_iframe=True), directionality)\n\n        # Auto handling for `bdi` and other non text inputs.\n        if (is_bdi and direction is None) or direction == 0:\n            direction = self.find_bidi(el)\n            if direction is not None:\n                return direction == directionality\n            elif is_root:\n                return ct.SEL_DIR_LTR == directionality\n            return self.match_dir(self.get_parent(el, no_iframe=True), directionality)\n\n        # Match parents direction\n        return self.match_dir(self.get_parent(el, no_iframe=True), directionality)", "response": "Check if the element is in the given directionality."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef match_range(self, el, condition):\n\n        out_of_range = False\n\n        itype = self.get_attribute_by_name(el, 'type').lower()\n        mn = self.get_attribute_by_name(el, 'min', None)\n        if mn is not None:\n            mn = Inputs.parse_value(itype, mn)\n        mx = self.get_attribute_by_name(el, 'max', None)\n        if mx is not None:\n            mx = Inputs.parse_value(itype, mx)\n\n        # There is no valid min or max, so we cannot evaluate a range\n        if mn is None and mx is None:\n            return False\n\n        value = self.get_attribute_by_name(el, 'value', None)\n        if value is not None:\n            value = Inputs.parse_value(itype, value)\n        if value is not None:\n            if itype in (\"date\", \"datetime-local\", \"month\", \"week\", \"number\", \"range\"):\n                if mn is not None and value < mn:\n                    out_of_range = True\n                if not out_of_range and mx is not None and value > mx:\n                    out_of_range = True\n            elif itype == \"time\":\n                if mn is not None and mx is not None and mn > mx:\n                    # Time is periodic, so this is a reversed/discontinuous range\n                    if value < mn and value > mx:\n                        out_of_range = True\n                else:\n                    if mn is not None and value < mn:\n                        out_of_range = True\n                    if not out_of_range and mx is not None and value > mx:\n                        out_of_range = True\n\n        return not out_of_range if condition & ct.SEL_IN_RANGE else out_of_range", "response": "Match the range of the elements in the element el."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef match_defined(self, el):\n\n        name = self.get_tag(el)\n        return (\n            name.find('-') == -1 or\n            name.find(':') != -1 or\n            self.get_prefix(el) is not None\n        )", "response": "Match defined.\n\n        `:defined` is related to custom elements in a browser.\n\n        - If the document is XML (not XHTML), all tags will match.\n        - Tags that are not custom (don't have a hyphen) are marked defined.\n        - If the tag has a prefix (without or without a namespace), it will not match.\n\n        This is of course requires the parser to provide us with the proper prefix and namespace info,\n        if it doesn't, there is nothing we can do."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_selectors(self, el, selectors):\n\n        match = False\n        is_not = selectors.is_not\n        is_html = selectors.is_html\n\n        # Internal selector lists that use the HTML flag, will automatically get the `html` namespace.\n        if is_html:\n            namespaces = self.namespaces\n            iframe_restrict = self.iframe_restrict\n            self.namespaces = {'html': NS_XHTML}\n            self.iframe_restrict = True\n\n        if not is_html or self.is_html:\n            for selector in selectors:\n                match = is_not\n                # We have a un-matchable situation (like `:focus` as you can focus an element in this environment)\n                if isinstance(selector, ct.SelectorNull):\n                    continue\n                # Verify tag matches\n                if not self.match_tag(el, selector.tag):\n                    continue\n                # Verify tag is defined\n                if selector.flags & ct.SEL_DEFINED and not self.match_defined(el):\n                    continue\n                # Verify element is root\n                if selector.flags & ct.SEL_ROOT and not self.match_root(el):\n                    continue\n                # Verify element is scope\n                if selector.flags & ct.SEL_SCOPE and not self.match_scope(el):\n                    continue\n                # Verify `nth` matches\n                if not self.match_nth(el, selector.nth):\n                    continue\n                if selector.flags & ct.SEL_EMPTY and not self.match_empty(el):\n                    continue\n                # Verify id matches\n                if selector.ids and not self.match_id(el, selector.ids):\n                    continue\n                # Verify classes match\n                if selector.classes and not self.match_classes(el, selector.classes):\n                    continue\n                # Verify attribute(s) match\n                if not self.match_attributes(el, selector.attributes):\n                    continue\n                # Verify ranges\n                if selector.flags & RANGES and not self.match_range(el, selector.flags & RANGES):\n                    continue\n                # Verify language patterns\n                if selector.lang and not self.match_lang(el, selector.lang):\n                    continue\n                # Verify pseudo selector patterns\n                if selector.selectors and not self.match_subselectors(el, selector.selectors):\n                    continue\n                # Verify relationship selectors\n                if selector.relation and not self.match_relations(el, selector.relation):\n                    continue\n                # Validate that the current default selector match corresponds to the first submit button in the form\n                if selector.flags & ct.SEL_DEFAULT and not self.match_default(el):\n                    continue\n                # Validate that the unset radio button is among radio buttons with the same name in a form that are\n                # also not set.\n                if selector.flags & ct.SEL_INDETERMINATE and not self.match_indeterminate(el):\n                    continue\n                # Validate element directionality\n                if selector.flags & DIR_FLAGS and not self.match_dir(el, selector.flags & DIR_FLAGS):\n                    continue\n                # Validate that the tag contains the specified text.\n                if not self.match_contains(el, selector.contains):\n                    continue\n                match = not is_not\n                break\n\n        # Restore actual namespaces being used for external selector lists\n        if is_html:\n            self.namespaces = namespaces\n            self.iframe_restrict = iframe_restrict\n\n        return match", "response": "Check if element matches one of the selectors."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmatch all tags under the targeted tag.", "response": "def select(self, limit=0):\n        \"\"\"Match all tags under the targeted tag.\"\"\"\n\n        if limit < 1:\n            limit = None\n\n        for child in self.get_descendants(self.tag):\n            if self.match(child):\n                yield child\n                if limit is not None:\n                    limit -= 1\n                    if limit < 1:\n                        break"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef filter(self):  # noqa A001\n\n        return [tag for tag in self.get_contents(self.tag) if not self.is_navigable_string(tag) and self.match(tag)]", "response": "Filter tag s children."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef match(self, tag):\n\n        return CSSMatch(self.selectors, tag, self.namespaces, self.flags).match(tag)", "response": "Match the given tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef closest(self, tag):\n\n        return CSSMatch(self.selectors, tag, self.namespaces, self.flags).closest()", "response": "Return the closest ancestor."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfiltering an iterable of nodes.", "response": "def filter(self, iterable):  # noqa A001\n        \"\"\"\n        Filter.\n\n        `CSSMatch` can cache certain searches for tags of the same document,\n        so if we are given a tag, all tags are from the same document,\n        and we can take advantage of the optimization.\n\n        Any other kind of iterable could have tags from different documents or detached tags,\n        so for those, we use a new `CSSMatch` for each item in the iterable.\n        \"\"\"\n\n        if CSSMatch.is_tag(iterable):\n            return CSSMatch(self.selectors, iterable, self.namespaces, self.flags).filter()\n        else:\n            return [node for node in iterable if not CSSMatch.is_navigable_string(node) and self.match(node)]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nselect a single tag.", "response": "def select_one(self, tag):\n        \"\"\"Select a single tag.\"\"\"\n\n        tags = self.select(tag, limit=1)\n        return tags[0] if tags else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate the specified tags.", "response": "def iselect(self, tag, limit=0):\n        \"\"\"Iterate the specified tags.\"\"\"\n\n        for el in CSSMatch(self.selectors, tag, self.namespaces, self.flags).select(limit):\n            yield el"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef deprecated(message, stacklevel=2):  # pragma: no cover\n\n    def _decorator(func):\n        @wraps(func)\n        def _func(*args, **kwargs):\n            warnings.warn(\n                \"'{}' is deprecated. {}\".format(func.__name__, message),\n                category=DeprecationWarning,\n                stacklevel=stacklevel\n            )\n            return func(*args, **kwargs)\n        return _func\n    return _decorator", "response": "A decorator that marks a function as deprecated."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the pattern context.", "response": "def get_pattern_context(pattern, index):\n    \"\"\"Get the pattern context.\"\"\"\n\n    last = 0\n    current_line = 1\n    col = 1\n    text = []\n    line = 1\n\n    # Split pattern by newline and handle the text before the newline\n    for m in RE_PATTERN_LINE_SPLIT.finditer(pattern):\n        linetext = pattern[last:m.start(0)]\n        if not len(m.group(0)) and not len(text):\n            indent = ''\n            offset = -1\n            col = index - last + 1\n        elif last <= index < m.end(0):\n            indent = '--> '\n            offset = (-1 if index > m.start(0) else 0) + 3\n            col = index - last + 1\n        else:\n            indent = '    '\n            offset = None\n        if len(text):\n            # Regardless of whether we are presented with `\\r\\n`, `\\r`, or `\\n`,\n            # we will render the output with just `\\n`. We will still log the column\n            # correctly though.\n            text.append('\\n')\n        text.append('{}{}'.format(indent, linetext))\n        if offset is not None:\n            text.append('\\n')\n            text.append(' ' * (col + offset) + '^')\n            line = current_line\n\n        current_line += 1\n        last = m.end(0)\n\n    return ''.join(text), line, col"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfilter list of nodes.", "response": "def filter(select, iterable, namespaces=None, flags=0, **kwargs):  # noqa: A001\n    \"\"\"Filter list of nodes.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).filter(iterable)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef select_one(select, tag, namespaces=None, flags=0, **kwargs):\n\n    return compile(select, namespaces, flags, **kwargs).select_one(tag)", "response": "Select a single tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nselects the specified tags.", "response": "def select(select, tag, namespaces=None, limit=0, flags=0, **kwargs):\n    \"\"\"Select the specified tags.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).select(tag, limit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iselect(select, tag, namespaces=None, limit=0, flags=0, **kwargs):\n\n    for el in compile(select, namespaces, flags, **kwargs).iselect(tag, limit):\n        yield el", "response": "Iterate the specified tags."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef all(cls, connection=None, **params):\n\n        request = cls._make_request('GET', cls._get_all_path(), connection, params=params)\n        return cls._create_object(request, connection=connection)", "response": "Returns a list of all the user s infrastructure."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iterall(cls, connection=None, **kwargs):\n\n        try:\n            limit = kwargs['limit']\n        except KeyError:\n            limit = None\n\n        try:\n            page = kwargs['page']\n        except KeyError:\n            page = None\n\n        def _all_responses():\n            page = 1  # one based\n            params = kwargs.copy()\n\n            while True:\n                params.update(page=page, limit=250)\n                rsp = cls._make_request('GET', cls._get_all_path(), connection, params=params)\n                if rsp:\n                    yield rsp\n                    page += 1\n                else:\n                    yield []  # needed for case where there is no objects\n                    break\n\n        if not (limit or page):\n            for rsp in _all_responses():\n                for obj in rsp:\n                    yield cls._create_object(obj, connection=connection)\n\n        else:\n            response = cls._make_request('GET', cls._get_all_path(), connection, params=kwargs)\n            for obj in cls._create_object(response, connection=connection):\n                yield obj", "response": "Returns an autopaging generator that yields each object returned one by one."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, resource=\"\", rid=None, **query):\n        if rid:\n            if resource[-1] != '/':\n                resource += '/'\n            resource += str(rid)\n        response = self._run_method('GET', resource, query=query)\n        return self._handle_response(resource, response)", "response": "Retrieves the resource with given id rid or all resources with given id rid or all resources with given id rid."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the resource with id rid with the given updates dictionary.", "response": "def update(self, resource, rid, updates):\n        \"\"\"\n        Updates the resource with id 'rid' with the given updates dictionary.\n        \"\"\"\n        if resource[-1] != '/':\n            resource += '/'\n        resource += str(rid)\n        return self.put(resource, data=updates)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete(self, resource, rid=None):  # note that rid can't be 0 - problem?\n        if rid:\n            if resource[-1] != '/':\n                resource += '/'\n            resource += str(rid)\n        response = self._run_method('DELETE', resource)\n        return self._handle_response(resource, response, suppress_empty=True)", "response": "Delete the resource with given id rid."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef put(self, url, data):\n        response = self._run_method('PUT', url, data=data)\n        log.debug(\"OUTPUT: %s\" % response.content)\n        return self._handle_response(url, response)", "response": "Make a PUT request to save data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef post(self, url, data, headers={}):\n        response = self._run_method('POST', url, data=data, headers=headers)\n        return self._handle_response(url, response)", "response": "POST request for creating new objects."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle the response from the server and returns the parsed JSON or raises an exception appropriately.", "response": "def _handle_response(self, url, res, suppress_empty=True):\n        \"\"\"\n        Returns parsed JSON or raises an exception appropriately.\n        \"\"\"\n        self._last_response = res\n        result = {}\n        if res.status_code in (200, 201, 202):\n            try:\n                result = res.json()\n            except Exception as e:  # json might be invalid, or store might be down\n                e.message += \" (_handle_response failed to decode JSON: \" + str(res.content) + \")\"\n                raise  # TODO better exception\n        elif res.status_code == 204 and not suppress_empty:\n            raise EmptyResponseWarning(\"%d %s @ %s: %s\" % (res.status_code, res.reason, url, res.content), res)\n        elif res.status_code >= 500:\n            raise ServerException(\"%d %s @ %s: %s\" % (res.status_code, res.reason, url, res.content), res)\n        elif res.status_code == 429:\n            raise RateLimitingException(\"%d %s @ %s: %s\" % (res.status_code, res.reason, url, res.content), res)\n        elif res.status_code >= 400:\n            raise ClientRequestException(\"%d %s @ %s: %s\" % (res.status_code, res.reason, url, res.content), res)\n        elif res.status_code >= 300:\n            raise RedirectionException(\"%d %s @ %s: %s\" % (res.status_code, res.reason, url, res.content), res)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nverifies that a signed payload is valid and return the user s data.", "response": "def verify_payload(signed_payload, client_secret):\n        \"\"\"\n        Given a signed payload (usually passed as parameter in a GET request to the app's load URL) and a client secret,\n        authenticates the payload and returns the user's data, or False on fail.\n\n        Uses constant-time str comparison to prevent vulnerability to timing attacks.\n        \"\"\"\n        encoded_json, encoded_hmac = signed_payload.split('.')\n        dc_json = base64.b64decode(encoded_json)\n        signature = base64.b64decode(encoded_hmac)\n        expected_sig = hmac.new(client_secret.encode(), base64.b64decode(encoded_json), hashlib.sha256).hexdigest()\n        authorised = hmac.compare_digest(signature, expected_sig.encode())\n        return json.loads(dc_json.decode()) if authorised else False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch a token from given token_url and sets session headers for the session.", "response": "def fetch_token(self, client_secret, code, context, scope, redirect_uri,\n                    token_url='https://login.bigcommerce.com/oauth2/token'):\n        \"\"\"\n        Fetches a token from given token_url, using given parameters, and sets up session headers for\n        future requests.\n        redirect_uri should be the same as your callback URL.\n        code, context, and scope should be passed as parameters to your callback URL on app installation.\n\n        Raises HttpException on failure (same as Connection methods).\n        \"\"\"\n        res = self.post(token_url, {'client_id': self.client_id,\n                                    'client_secret': client_secret,\n                                    'code': code,\n                                    'context': context,\n                                    'scope': scope,\n                                    'grant_type': 'authorization_code',\n                                    'redirect_uri': redirect_uri},\n                        headers={'Content-Type': 'application/x-www-form-urlencoded'})\n        self._session.headers.update(self._oauth_headers(self.client_id, res['access_token']))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _handle_response(self, url, res, suppress_empty=True):\n        result = Connection._handle_response(self, url, res, suppress_empty)\n        if 'X-Rate-Limit-Time-Reset-Ms' in res.headers:\n            self.rate_limit = dict(ms_until_reset=int(res.headers['X-Rate-Limit-Time-Reset-Ms']),\n                                   window_size_ms=int(res.headers['X-Rate-Limit-Time-Window-Ms']),\n                                   requests_remaining=int(res.headers['X-Rate-Limit-Requests-Left']),\n                                   requests_quota=int(res.headers['X-Rate-Limit-Requests-Quota']))\n            if self.rate_limiting_management:\n                if self.rate_limiting_management['min_requests_remaining'] >= self.rate_limit['requests_remaining']:\n                    if self.rate_limiting_management['wait']:\n                        sleep(ceil(float(self.rate_limit['ms_until_reset']) / 1000))\n                    if self.rate_limiting_management.get('callback_function'):\n                        callback = self.rate_limiting_management['callback_function']\n                        args_dict = self.rate_limiting_management.get('callback_args')\n                        if args_dict:\n                            callback(args_dict)\n                        else:\n                            callback()\n\n        return result", "response": "Handles the response from the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nescapes a string of HTML.", "response": "def escape_html(text, escape_slash=False):\n    \"\"\"\n    Binding for Hoedown's HTML escaping function.\n\n    The implementation is inspired by the OWASP XSS Prevention recommendations:\n\n    .. code-block:: none\n\n        & --> &amp;\n        < --> &lt;\n        > --> &gt;\n        \" --> &quot;\n        ' --> &#x27;\n        / --> &#x2F;  when escape_slash is set to True\n\n    .. versionadded:: 2.1.0\n    \"\"\"\n    byte_str = text.encode('utf-8')\n    ob = lib.hoedown_buffer_new(OUNIT)\n    lib.hoedown_escape_html(ob, byte_str, len(byte_str), int(escape_slash))\n\n    try:\n        return to_string(ob)\n    finally:\n        lib.hoedown_buffer_free(ob)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting markdown text to HTML.", "response": "def html(text, extensions=0, render_flags=0):\n    \"\"\"\n    Convert markdown text to HTML.\n\n    ``extensions`` can be a list or tuple of extensions (e.g.\n    ``('fenced-code', 'footnotes', 'strikethrough')``) or an integer\n    (e.g. ``EXT_FENCED_CODE | EXT_FOOTNOTES | EXT_STRIKETHROUGH``).\n\n    ``render_flags`` can be a list or tuple of flags (e.g.\n    ``('skip-html', 'hard-wrap')``) or an integer\n    (e.g. ``HTML_SKIP_HTML | HTML_HARD_WRAP``).\n    \"\"\"\n    extensions = args_to_int(extension_map, extensions)\n    render_flags = args_to_int(html_flag_map, render_flags)\n\n    ib = lib.hoedown_buffer_new(IUNIT)\n    ob = lib.hoedown_buffer_new(OUNIT)\n    renderer = lib.hoedown_html_renderer_new(render_flags, 0)\n    document = lib.hoedown_document_new(renderer, extensions, 16);\n\n    lib.hoedown_buffer_puts(ib, text.encode('utf-8'))\n    lib.hoedown_document_render(document, ob, ib.data, ib.size);\n    lib.hoedown_buffer_free(ib);\n    lib.hoedown_document_free(document);\n    lib.hoedown_html_renderer_free(renderer);\n\n    try:\n        return to_string(ob)\n    finally:\n        lib.hoedown_buffer_free(ob);"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef smartypants(text):\n    byte_str = text.encode('utf-8')\n    ob = lib.hoedown_buffer_new(OUNIT)\n    lib.hoedown_html_smartypants(ob, byte_str, len(byte_str))\n\n    try:\n        return to_string(ob)\n    finally:\n        lib.hoedown_buffer_free(ob);", "response": "Returns a new node that can be used to render a string of text into HTML entities."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters links generated by the autolink extension.", "response": "def autolink(self, raw_url, is_email):\n        \"\"\"\n        Filters links generated by the ``autolink`` extension.\n        \"\"\"\n        if self.check_url(raw_url):\n            url = self.rewrite_url(('mailto:' if is_email else '') + raw_url)\n            url = escape_html(url)\n            return '<a href=\"%s\">%s</a>' % (url, escape_html(raw_url))\n        else:\n            return escape_html('<%s>' % raw_url)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef image(self, raw_url, title='', alt=''):\n        if self.check_url(raw_url, is_image_src=True):\n            url = self.rewrite_url(raw_url, is_image_src=True)\n            maybe_alt = ' alt=\"%s\"' % escape_html(alt) if alt else ''\n            maybe_title = ' title=\"%s\"' % escape_html(title) if title else ''\n            url = escape_html(url)\n            return '<img src=\"%s\"%s%s />' % (url, maybe_alt, maybe_title)\n        else:\n            return escape_html(\"![%s](%s)\" % (alt, raw_url))", "response": "Returns an image tag with optional alt title and alt attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_url(self, url, is_image_src=False):\n        return bool(self._allowed_url_re.match(url))", "response": "Checks if the given URL is safe."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rewrite_url(self, url, is_image_src=False):\n        rewrite = self.img_src_rewrite if is_image_src else self.link_rewrite\n        if rewrite:\n            return rewrite.format(url=urlquote(url))\n        return url", "response": "This method is called to rewrite the URL. It returns the URL unchanged if the corresponding attribute is None."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef args_to_int(mapping, argument):\n    if isinstance(argument, int):\n        if argument == 0:\n            return 0\n        deprecation('passing extensions and flags as constants is deprecated')\n        return argument\n    elif isinstance(argument, (tuple, list)):\n        return reduce(op.or_, [mapping[n] for n in set(argument) if n in mapping], 0)\n    raise TypeError('argument must be a list of strings or an int')", "response": "Convert list of strings to an int using a mapping."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _pack3(obj, fp, **options):\n    global compatibility\n\n    ext_handlers = options.get(\"ext_handlers\")\n\n    if obj is None:\n        _pack_nil(obj, fp, options)\n    elif ext_handlers and obj.__class__ in ext_handlers:\n        _pack_ext(ext_handlers[obj.__class__](obj), fp, options)\n    elif isinstance(obj, bool):\n        _pack_boolean(obj, fp, options)\n    elif isinstance(obj, int):\n        _pack_integer(obj, fp, options)\n    elif isinstance(obj, float):\n        _pack_float(obj, fp, options)\n    elif compatibility and isinstance(obj, str):\n        _pack_oldspec_raw(obj.encode('utf-8'), fp, options)\n    elif compatibility and isinstance(obj, bytes):\n        _pack_oldspec_raw(obj, fp, options)\n    elif isinstance(obj, str):\n        _pack_string(obj, fp, options)\n    elif isinstance(obj, bytes):\n        _pack_binary(obj, fp, options)\n    elif isinstance(obj, (list, tuple)):\n        _pack_array(obj, fp, options)\n    elif isinstance(obj, dict):\n        _pack_map(obj, fp, options)\n    elif isinstance(obj, datetime.datetime):\n        _pack_ext_timestamp(obj, fp, options)\n    elif isinstance(obj, Ext):\n        _pack_ext(obj, fp, options)\n    elif ext_handlers:\n        # Linear search for superclass\n        t = next((t for t in ext_handlers.keys() if isinstance(obj, t)), None)\n        if t:\n            _pack_ext(ext_handlers[t](obj), fp, options)\n        else:\n            raise UnsupportedTypeException(\n                \"unsupported type: %s\" % str(type(obj)))\n    else:\n        raise UnsupportedTypeException(\n            \"unsupported type: %s\" % str(type(obj)))", "response": "Serializes a Python object into MessagePack bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_task_target():\n  # Break circular dependency.\n  # pylint: disable=g-import-not-at-top\n  import pipeline\n  if pipeline._TEST_MODE:\n    return None\n\n  # Further protect against test cases that doesn't set env vars\n  # propertly.\n  if (\"CURRENT_VERSION_ID\" not in os.environ or\n      \"CURRENT_MODULE_ID\" not in os.environ):\n    logging.warning(\"Running Pipeline in non TEST_MODE but important \"\n                    \"env vars are not set.\")\n    return None\n\n  version = os.environ[\"CURRENT_VERSION_ID\"].split(\".\")[0]\n  module = os.environ[\"CURRENT_MODULE_ID\"]\n  return \"%s.%s\" % (version, module)", "response": "Get the default target for a pipeline task."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef for_name(fq_name, recursive=False):\n  fq_name = str(fq_name)\n  module_name = __name__\n  short_name = fq_name\n\n  if fq_name.rfind(\".\") >= 0:\n    (module_name, short_name) = (fq_name[:fq_name.rfind(\".\")],\n                                 fq_name[fq_name.rfind(\".\") + 1:])\n\n  try:\n    result = __import__(module_name, None, None, [short_name])\n    return result.__dict__[short_name]\n  except KeyError:\n    # If we're recursively inside a for_name() chain, then we want to raise\n    # this error as a key error so we can report the actual source of the\n    # problem. If we're *not* recursively being called, that means the\n    # module was found and the specific item could not be loaded, and thus\n    # we want to raise an ImportError directly.\n    if recursive:\n      raise\n    else:\n      raise ImportError(\"Could not find '%s' on path '%s'\" % (\n                        short_name, module_name))\n  except ImportError, e:\n    # module_name is not actually a module. Try for_name for it to figure\n    # out what's this.\n    try:\n      module = for_name(module_name, recursive=True)\n      if hasattr(module, short_name):\n        return getattr(module, short_name)\n      else:\n        # The module was found, but the function component is missing.\n        raise KeyError()\n    except KeyError:\n      raise ImportError(\"Could not find '%s' on path '%s'\" % (\n                        short_name, module_name))\n    except ImportError:\n      # This means recursive import attempts failed, thus we will raise the\n      # first ImportError we encountered, since it's likely the most accurate.\n      pass\n    # Raise the original import error that caused all of this, since it is\n    # likely the real cause of the overall problem.\n    raise", "response": "Find class or function or method specified by its fully qualified name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if the object is a user - defined generator function.", "response": "def is_generator_function(obj):\n  \"\"\"Return true if the object is a user-defined generator function.\n\n  Generator function objects provides same attributes as functions.\n  See isfunction.__doc__ for attributes listing.\n\n  Adapted from Python 2.6.\n\n  Args:\n    obj: an object to test.\n\n  Returns:\n    true if the object is generator function.\n  \"\"\"\n  CO_GENERATOR = 0x20\n  return bool(((inspect.isfunction(obj) or inspect.ismethod(obj)) and\n               obj.func_code.co_flags & CO_GENERATOR))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _register_json_primitive(object_type, encoder, decoder):\n  global _TYPE_TO_ENCODER\n  global _TYPE_NAME_TO_DECODER\n  if object_type not in _TYPE_TO_ENCODER:\n    _TYPE_TO_ENCODER[object_type] = encoder\n    _TYPE_NAME_TO_DECODER[object_type.__name__] = decoder", "response": "Extend what Pipeline can serialize."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _dict_to_obj(self, d):\n    if JsonEncoder.TYPE_ID not in d:\n      return d\n\n    type_name = d.pop(JsonEncoder.TYPE_ID)\n    if type_name in _TYPE_NAME_TO_DECODER:\n      decoder = _TYPE_NAME_TO_DECODER[type_name]\n      return decoder(d)\n    else:\n      raise TypeError(\"Invalid type %s.\", type_name)", "response": "Converts a dictionary of json object to a Python object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _short_repr(obj):\n  stringified = pprint.saferepr(obj)\n  if len(stringified) > 200:\n    return '%s... (%d bytes)' % (stringified[:200], len(stringified))\n  return stringified", "response": "Helper function returns a truncated repr of an object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _write_json_blob(encoded_value, pipeline_id=None):\n\n  default_bucket = app_identity.get_default_gcs_bucket_name()\n  if default_bucket is None:\n    raise Exception(\n      \"No default cloud storage bucket has been set for this application. \"\n      \"This app was likely created before v1.9.0, please see: \"\n      \"https://cloud.google.com/appengine/docs/php/googlestorage/setup\")\n\n  path_components = ['/', default_bucket, \"appengine_pipeline\"]\n  if pipeline_id:\n    path_components.append(pipeline_id)\n  path_components.append(uuid.uuid4().hex)\n  # Use posixpath to get a / even if we're running on windows somehow\n  file_name = posixpath.join(*path_components)\n  with cloudstorage.open(file_name, 'w', content_type='application/json') as f:\n    for start_index in xrange(0, len(encoded_value), _MAX_JSON_SIZE):\n      end_index = start_index + _MAX_JSON_SIZE\n      f.write(encoded_value[start_index:end_index])\n\n  key_str = blobstore.create_gs_key(\"/gs\" + file_name)\n  logging.debug(\"Created blob for filename = %s gs_key = %s\", file_name, key_str)\n  return blobstore.BlobKey(key_str)", "response": "Writes a JSON encoded value to a Cloud Storage File."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _dereference_args(pipeline_name, args, kwargs):\n  lookup_slots = set()\n  for arg in itertools.chain(args, kwargs.itervalues()):\n    if arg['type'] == 'slot':\n      lookup_slots.add(db.Key(arg['slot_key']))\n\n  slot_dict = {}\n  for key, slot_record in zip(lookup_slots, db.get(lookup_slots)):\n    if slot_record is None or slot_record.status != _SlotRecord.FILLED:\n      raise SlotNotFilledError(\n          'Slot \"%s\" missing its value. From %s(*args=%s, **kwargs=%s)' %\n          (key, pipeline_name, _short_repr(args), _short_repr(kwargs)))\n    slot_dict[key] = slot_record.value\n\n  arg_list = []\n  for current_arg in args:\n    if current_arg['type'] == 'slot':\n      arg_list.append(slot_dict[db.Key(current_arg['slot_key'])])\n    elif current_arg['type'] == 'value':\n      arg_list.append(current_arg['value'])\n    else:\n      raise UnexpectedPipelineError('Unknown parameter type: %r' % current_arg)\n\n  kwarg_dict = {}\n  for key, current_arg in kwargs.iteritems():\n    if current_arg['type'] == 'slot':\n      kwarg_dict[key] = slot_dict[db.Key(current_arg['slot_key'])]\n    elif current_arg['type'] == 'value':\n      kwarg_dict[key] = current_arg['value']\n    else:\n      raise UnexpectedPipelineError('Unknown parameter type: %r' % current_arg)\n\n  return (arg_list, kwarg_dict)", "response": "Dereferences a Pipeline s arguments that are slots validating them."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _generate_args(pipeline, future, queue_name, base_path):\n  params = {\n      'args': [],\n      'kwargs': {},\n      'after_all': [],\n      'output_slots': {},\n      'class_path': pipeline._class_path,\n      'queue_name': queue_name,\n      'base_path': base_path,\n      'backoff_seconds': pipeline.backoff_seconds,\n      'backoff_factor': pipeline.backoff_factor,\n      'max_attempts': pipeline.max_attempts,\n      'task_retry': pipeline.task_retry,\n      'target': pipeline.target,\n  }\n  dependent_slots = set()\n\n  arg_list = params['args']\n  for current_arg in pipeline.args:\n    if isinstance(current_arg, PipelineFuture):\n      current_arg = current_arg.default\n    if isinstance(current_arg, Slot):\n      arg_list.append({'type': 'slot', 'slot_key': str(current_arg.key)})\n      dependent_slots.add(current_arg.key)\n    else:\n      arg_list.append({'type': 'value', 'value': current_arg})\n\n  kwarg_dict = params['kwargs']\n  for name, current_arg in pipeline.kwargs.iteritems():\n    if isinstance(current_arg, PipelineFuture):\n      current_arg = current_arg.default\n    if isinstance(current_arg, Slot):\n      kwarg_dict[name] = {'type': 'slot', 'slot_key': str(current_arg.key)}\n      dependent_slots.add(current_arg.key)\n    else:\n      kwarg_dict[name] = {'type': 'value', 'value': current_arg}\n\n  after_all = params['after_all']\n  for other_future in future._after_all_pipelines:\n    slot_key = other_future._output_dict['default'].key\n    after_all.append(str(slot_key))\n    dependent_slots.add(slot_key)\n\n  output_slots = params['output_slots']\n  output_slot_keys = set()\n  for name, slot in future._output_dict.iteritems():\n    output_slot_keys.add(slot.key)\n    output_slots[name] = str(slot.key)\n\n  params_encoded = json.dumps(params, cls=mr_util.JsonEncoder)\n  params_text = None\n  params_blob = None\n  if len(params_encoded) > _MAX_JSON_SIZE:\n    params_blob = _write_json_blob(params_encoded, pipeline.pipeline_id)\n  else:\n    params_text = params_encoded\n\n  return dependent_slots, output_slot_keys, params_text, params_blob", "response": "Generate the arguments needed to describe a Pipeline."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_timestamp_ms(when):\n  if when is None:\n    return None\n  ms_since_epoch = float(time.mktime(when.utctimetuple()) * 1000.0)\n  ms_since_epoch += when.microsecond / 1000.0\n  return int(ms_since_epoch)", "response": "Converts a datetime. datetime instance to integer milliseconds since the epoch."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_internal_status(pipeline_key=None,\n                         pipeline_dict=None,\n                         slot_dict=None,\n                         barrier_dict=None,\n                         status_dict=None):\n  \"\"\"Gets the UI dictionary of a pipeline from a set of status dictionaries.\n\n  Args:\n    pipeline_key: The key of the pipeline to lookup.\n    pipeline_dict: Dictionary mapping pipeline db.Key to _PipelineRecord.\n      Default is an empty dictionary.\n    slot_dict: Dictionary mapping slot db.Key to _SlotRecord.\n      Default is an empty dictionary.\n    barrier_dict: Dictionary mapping barrier db.Key to _BarrierRecord.\n      Default is an empty dictionary.\n    status_dict: Dictionary mapping status record db.Key to _StatusRecord.\n      Default is an empty dictionary.\n\n  Returns:\n    Dictionary with the keys:\n      classPath: The pipeline function being run.\n      args: List of positional argument slot dictionaries.\n      kwargs: Dictionary of keyword argument slot dictionaries.\n      outputs: Dictionary of output slot dictionaries.\n      children: List of child pipeline IDs.\n      queueName: Queue on which this pipeline is running.\n      afterSlotKeys: List of Slot Ids after which this pipeline runs.\n      currentAttempt: Number of the current attempt, starting at 1.\n      maxAttempts: Maximum number of attempts before aborting.\n      backoffSeconds: Constant factor for backoff before retrying.\n      backoffFactor: Exponential factor for backoff before retrying.\n      status: Current status of the pipeline.\n      startTimeMs: When this pipeline ran or will run due to retries, if present.\n      endTimeMs: When this pipeline finalized, if present.\n      lastRetryMessage: Why the pipeline failed during the last retry, if there\n        was a failure; may be empty.\n      abortMessage: For root pipelines, why the pipeline was aborted if it was\n        aborted; may be empty.\n\n    Dictionary will contain these keys if explicit status is set:\n      statusTimeMs: When the status was set as milliseconds since the epoch.\n      statusMessage: Status message, if present.\n      statusConsoleUrl: The relative URL for the console of this pipeline.\n      statusLinks: Dictionary mapping human-readable names to relative URLs\n        for related URLs to this pipeline.\n\n  Raises:\n    PipelineStatusError if any input is bad.\n  \"\"\"\n  if pipeline_dict is None:\n    pipeline_dict = {}\n  if slot_dict is None:\n    slot_dict = {}\n  if barrier_dict is None:\n    barrier_dict = {}\n  if status_dict is None:\n    status_dict = {}\n\n  pipeline_record = pipeline_dict.get(pipeline_key)\n  if pipeline_record is None:\n    raise PipelineStatusError(\n        'Could not find pipeline ID \"%s\"' % pipeline_key.name())\n\n  params = pipeline_record.params\n  root_pipeline_key = \\\n      _PipelineRecord.root_pipeline.get_value_for_datastore(pipeline_record)\n  default_slot_key = db.Key(params['output_slots']['default'])\n  start_barrier_key = db.Key.from_path(\n      _BarrierRecord.kind(), _BarrierRecord.START, parent=pipeline_key)\n  finalize_barrier_key = db.Key.from_path(\n      _BarrierRecord.kind(), _BarrierRecord.FINALIZE, parent=pipeline_key)\n  status_record_key = db.Key.from_path(\n      _StatusRecord.kind(), pipeline_key.name())\n\n  start_barrier = barrier_dict.get(start_barrier_key)\n  finalize_barrier = barrier_dict.get(finalize_barrier_key)\n  default_slot = slot_dict.get(default_slot_key)\n  status_record = status_dict.get(status_record_key)\n  if finalize_barrier is None:\n    raise PipelineStatusError(\n        'Finalization barrier missing for pipeline ID \"%s\"' %\n        pipeline_key.name())\n  if default_slot is None:\n    raise PipelineStatusError(\n        'Default output slot with key=%s missing for pipeline ID \"%s\"' % (\n        default_slot_key, pipeline_key.name()))\n\n  output = {\n    'classPath': pipeline_record.class_path,\n    'args': list(params['args']),\n    'kwargs': params['kwargs'].copy(),\n    'outputs': params['output_slots'].copy(),\n    'children': [key.name() for key in pipeline_record.fanned_out],\n    'queueName': params['queue_name'],\n    'afterSlotKeys': [str(key) for key in params['after_all']],\n    'currentAttempt': pipeline_record.current_attempt + 1,\n    'maxAttempts': pipeline_record.max_attempts,\n    'backoffSeconds': pipeline_record.params['backoff_seconds'],\n    'backoffFactor': pipeline_record.params['backoff_factor'],\n  }\n\n  # TODO(user): Truncate args, kwargs, and outputs to < 1MB each so we\n  # can reasonably return the whole tree of pipelines and their outputs.\n  # Coerce each value to a string to truncate if necessary. For now if the\n  # params are too big it will just cause the whole status page to break.\n\n  # Fix the key names in parameters to match JavaScript style.\n  for value_dict in itertools.chain(\n      output['args'], output['kwargs'].itervalues()):\n    if 'slot_key' in value_dict:\n      value_dict['slotKey'] = value_dict.pop('slot_key')\n\n  # Figure out the pipeline's status.\n  if pipeline_record.status in (_PipelineRecord.WAITING, _PipelineRecord.RUN):\n    if default_slot.status == _SlotRecord.FILLED:\n      status = 'finalizing'\n    elif (pipeline_record.status == _PipelineRecord.WAITING and\n          pipeline_record.next_retry_time is not None):\n      status = 'retry'\n    elif start_barrier and start_barrier.status == _BarrierRecord.WAITING:\n      # start_barrier will be missing for root pipelines\n      status = 'waiting'\n    else:\n      status = 'run'\n  elif pipeline_record.status == _PipelineRecord.DONE:\n    status = 'done'\n  elif pipeline_record.status == _PipelineRecord.ABORTED:\n    status = 'aborted'\n\n  output['status'] = status\n\n  if status_record:\n    output['statusTimeMs'] = _get_timestamp_ms(status_record.status_time)\n    if status_record.message:\n      output['statusMessage'] = status_record.message\n    if status_record.console_url:\n      output['statusConsoleUrl'] = status_record.console_url\n    if status_record.link_names:\n      output['statusLinks'] = dict(\n          zip(status_record.link_names, status_record.link_urls))\n\n  # Populate status-depenedent fields.\n  if status in ('run', 'finalizing', 'done', 'retry'):\n    if pipeline_record.next_retry_time is not None:\n      output['startTimeMs'] = _get_timestamp_ms(pipeline_record.next_retry_time)\n    elif start_barrier:\n      # start_barrier will be missing for root pipelines\n      output['startTimeMs'] = _get_timestamp_ms(start_barrier.trigger_time)\n    elif pipeline_record.start_time:\n      # Assume this pipeline ran immediately upon spawning with no\n      # start barrier or it's the root pipeline.\n      output['startTimeMs'] = _get_timestamp_ms(pipeline_record.start_time)\n\n  if status in ('finalizing',):\n    output['endTimeMs'] = _get_timestamp_ms(default_slot.fill_time)\n\n  if status in ('done',):\n    output['endTimeMs'] = _get_timestamp_ms(pipeline_record.finalized_time)\n\n  if pipeline_record.next_retry_time is not None:\n    output['lastRetryMessage'] = pipeline_record.retry_message\n\n  if pipeline_record.abort_message:\n    output['abortMessage'] = pipeline_record.abort_message\n\n  return output", "response": "Internal helper function for _get_pipeline_status."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_internal_slot(slot_key=None,\n                       filler_pipeline_key=None,\n                       slot_dict=None):\n  \"\"\"Gets information about a _SlotRecord for display in UI.\n\n  Args:\n    slot_key: The db.Key of the slot to fetch.\n    filler_pipeline_key: In the case the slot has not yet been filled, assume\n      that the given db.Key (for a _PipelineRecord) will be the filler of\n      the slot in the future.\n    slot_dict: The slot JSON dictionary.\n\n  Returns:\n    Dictionary with the keys:\n      status: Slot status: 'filled' or 'waiting'\n      fillTimeMs: Time in milliseconds since the epoch of when it was filled.\n      value: The current value of the slot, which is a slot's JSON dictionary.\n      fillerPipelineId: The pipeline ID of what stage has or should fill\n        this slot.\n\n  Raises:\n    PipelineStatusError if any input is bad.\n  \"\"\"\n  if slot_dict is None:\n    slot_dict = {}\n\n  slot_record = slot_dict.get(slot_key)\n  if slot_record is None:\n    raise PipelineStatusError(\n        'Could not find data for output slot key \"%s\".' % slot_key)\n\n  output = {}\n  if slot_record.status == _SlotRecord.FILLED:\n    output['status'] = 'filled'\n    output['fillTimeMs'] = _get_timestamp_ms(slot_record.fill_time)\n    output['value'] = slot_record.value\n    filler_pipeline_key = (\n        _SlotRecord.filler.get_value_for_datastore(slot_record))\n  else:\n    output['status'] = 'waiting'\n\n  if filler_pipeline_key:\n    output['fillerPipelineId'] = filler_pipeline_key.name()\n\n  return output", "response": "Returns a dictionary of _SlotRecord objects for display in UI."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_status_tree(root_pipeline_id):\n  root_pipeline_key = db.Key.from_path(_PipelineRecord.kind(), root_pipeline_id)\n  root_pipeline_record = db.get(root_pipeline_key)\n  if root_pipeline_record is None:\n    raise PipelineStatusError(\n        'Could not find pipeline ID \"%s\"' % root_pipeline_id)\n\n  # If the supplied root_pipeline_id is not actually the root pipeline that's\n  # okay. We'll find the real root and override the value they passed in.\n  actual_root_key = _PipelineRecord.root_pipeline.get_value_for_datastore(\n      root_pipeline_record)\n  if actual_root_key != root_pipeline_key:\n    root_pipeline_key = actual_root_key\n    root_pipeline_id = root_pipeline_key.id_or_name()\n    root_pipeline_record = db.get(root_pipeline_key)\n    if not root_pipeline_record:\n      raise PipelineStatusError(\n          'Could not find pipeline ID \"%s\"' % root_pipeline_id)\n\n  # Run all queries asynchronously.\n  queries = {}\n  for model in (_PipelineRecord, _SlotRecord, _BarrierRecord, _StatusRecord):\n    queries[model] = model.all().filter(\n        'root_pipeline =', root_pipeline_key).run(batch_size=1000)\n\n  found_pipeline_dict = dict(\n      (stage.key(), stage) for stage in queries[_PipelineRecord])\n  found_slot_dict = dict(\n      (slot.key(), slot) for slot in queries[_SlotRecord])\n  found_barrier_dict = dict(\n      (barrier.key(), barrier) for barrier in queries[_BarrierRecord])\n  found_status_dict = dict(\n      (status.key(), status) for status in queries[_StatusRecord])\n\n  # Breadth-first traversal of _PipelineRecord instances by following\n  # _PipelineRecord.fanned_out property values.\n  valid_pipeline_keys = set([root_pipeline_key])\n  slot_filler_dict = {}  # slot_key to pipeline_key\n  expand_stack = [root_pipeline_record]\n  while expand_stack:\n    old_stack = expand_stack\n    expand_stack = []\n    for pipeline_record in old_stack:\n      for child_pipeline_key in pipeline_record.fanned_out:\n        # This will let us prune off those pipelines which were allocated in\n        # the Datastore but were never run due to mid-flight task failures.\n        child_pipeline_record = found_pipeline_dict.get(child_pipeline_key)\n        if child_pipeline_record is None:\n          raise PipelineStatusError(\n              'Pipeline ID \"%s\" points to child ID \"%s\" which does not exist.'\n              % (pipeline_record.key().name(), child_pipeline_key.name()))\n        expand_stack.append(child_pipeline_record)\n        valid_pipeline_keys.add(child_pipeline_key)\n\n        # Figure out the deepest pipeline that's responsible for outputting to\n        # a particular _SlotRecord, so we can report which pipeline *should*\n        # be the filler.\n        child_outputs = child_pipeline_record.params['output_slots']\n        for output_slot_key in child_outputs.itervalues():\n          slot_filler_dict[db.Key(output_slot_key)] = child_pipeline_key\n\n  output = {\n    'rootPipelineId': root_pipeline_id,\n    'slots': {},\n    'pipelines': {},\n  }\n\n  for pipeline_key in found_pipeline_dict.keys():\n    if pipeline_key not in valid_pipeline_keys:\n      continue\n    output['pipelines'][pipeline_key.name()] = _get_internal_status(\n        pipeline_key=pipeline_key,\n        pipeline_dict=found_pipeline_dict,\n        slot_dict=found_slot_dict,\n        barrier_dict=found_barrier_dict,\n        status_dict=found_status_dict)\n\n  for slot_key, filler_pipeline_key in slot_filler_dict.iteritems():\n    output['slots'][str(slot_key)] = _get_internal_slot(\n        slot_key=slot_key,\n        filler_pipeline_key=filler_pipeline_key,\n        slot_dict=found_slot_dict)\n\n  return output", "response": "Gets the full status tree of a pipeline."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the class paths of all Pipelines defined in alphabetical order.", "response": "def get_pipeline_names():\n  \"\"\"Returns the class paths of all Pipelines defined in alphabetical order.\"\"\"\n  class_path_set = set()\n  for cls in _PipelineMeta._all_classes:\n      if cls.class_path is not None:\n        class_path_set.add(cls.class_path)\n  return sorted(class_path_set)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of Pipelines with the given class_path and cursor.", "response": "def get_root_list(class_path=None, cursor=None, count=50):\n  \"\"\"Gets a list root Pipelines.\n\n  Args:\n    class_path: Optional. If supplied, only return root Pipelines with the\n      given class_path. By default all root pipelines are returned.\n    cursor: Optional. When supplied, the cursor returned from the last call to\n      get_root_list which indicates where to pick up.\n    count: How many pipeline returns to return.\n\n  Returns:\n    Dictionary with the keys:\n      pipelines: The list of Pipeline records in the same format as\n        returned by get_status_tree, but with only the roots listed.\n      cursor: Cursor to pass back to this function to resume the query. Will\n        only be present if there is another page of results.\n\n  Raises:\n    PipelineStatusError if any input is bad.\n  \"\"\"\n  query = _PipelineRecord.all(cursor=cursor)\n  if class_path:\n    query.filter('class_path =', class_path)\n  query.filter('is_root_pipeline =', True)\n  query.order('-start_time')\n\n  root_list = query.fetch(count)\n\n  fetch_list = []\n  for pipeline_record in root_list:\n    fetch_list.append(db.Key(pipeline_record.params['output_slots']['default']))\n    fetch_list.append(db.Key.from_path(\n        _BarrierRecord.kind(), _BarrierRecord.FINALIZE,\n        parent=pipeline_record.key()))\n    fetch_list.append(db.Key.from_path(\n        _StatusRecord.kind(), pipeline_record.key().name()))\n\n  pipeline_dict = dict((stage.key(), stage) for stage in root_list)\n  slot_dict = {}\n  barrier_dict = {}\n  status_dict = {}\n  for entity in db.get(fetch_list):\n    if isinstance(entity, _BarrierRecord):\n      barrier_dict[entity.key()] = entity\n    elif isinstance(entity, _SlotRecord):\n      slot_dict[entity.key()] = entity\n    elif isinstance(entity, _StatusRecord):\n      status_dict[entity.key()] = entity\n\n  results = []\n  for pipeline_record in root_list:\n    try:\n      output = _get_internal_status(\n          pipeline_record.key(),\n          pipeline_dict=pipeline_dict,\n          slot_dict=slot_dict,\n          barrier_dict=barrier_dict,\n          status_dict=status_dict)\n      output['pipelineId'] = pipeline_record.key().name()\n      results.append(output)\n    except PipelineStatusError, e:\n      output = {'status': e.message}\n      output['classPath'] = ''\n      output['pipelineId'] = pipeline_record.key().name()\n      results.append(output)\n\n  result_dict = {}\n  cursor = query.cursor()\n  query.with_cursor(cursor)\n  if query.get(keys_only=True):\n    result_dict.update(cursor=cursor)\n  result_dict.update(pipelines=results)\n  return result_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_handlers_map(prefix='.*'):\n  return [\n      (prefix + '/output', _BarrierHandler),\n      (prefix + '/run', _PipelineHandler),\n      (prefix + '/finalized', _PipelineHandler),\n      (prefix + '/cleanup', _CleanupHandler),\n      (prefix + '/abort', _PipelineHandler),\n      (prefix + '/fanout', _FanoutHandler),\n      (prefix + '/fanout_abort', _FanoutAbortHandler),\n      (prefix + '/callback', _CallbackHandler),\n      (prefix + '/rpc/tree', status_ui._TreeStatusHandler),\n      (prefix + '/rpc/class_paths', status_ui._ClassPathListHandler),\n      (prefix + '/rpc/list', status_ui._RootListHandler),\n      (prefix + '(/.+)', status_ui._StatusUiHandler),\n      ]", "response": "Create a new handlers map."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the current value of this slot.", "response": "def value(self):\n    \"\"\"Returns the current value of this slot.\n\n    Returns:\n      The value of the slot (a serializable Python type).\n\n    Raises:\n      SlotNotFilledError if the value hasn't been filled yet.\n    \"\"\"\n    if not self.filled:\n      raise SlotNotFilledError('Slot with name \"%s\", key \"%s\" not yet filled.'\n                               % (self.name, self.key))\n    return self._value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the pipeline ID that filled this slot s value.", "response": "def filler(self):\n    \"\"\"Returns the pipeline ID that filled this slot's value.\n\n    Returns:\n      A string that is the pipeline ID.\n\n    Raises:\n      SlotNotFilledError if the value hasn't been filled yet.\n    \"\"\"\n    if not self.filled:\n      raise SlotNotFilledError('Slot with name \"%s\", key \"%s\" not yet filled.'\n                               % (self.name, self.key))\n    return self._filler_pipeline_key.name()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning when the slot was filled.", "response": "def fill_datetime(self):\n    \"\"\"Returns when the slot was filled.\n\n    Returns:\n      A datetime.datetime.\n\n    Raises:\n      SlotNotFilledError if the value hasn't been filled yet.\n    \"\"\"\n    if not self.filled:\n      raise SlotNotFilledError('Slot with name \"%s\", key \"%s\" not yet filled.'\n                               % (self.name, self.key))\n    return self._fill_datetime"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the value of this slot based on its corresponding _SlotRecord.", "response": "def _set_value(self, slot_record):\n    \"\"\"Sets the value of this slot based on its corresponding _SlotRecord.\n\n    Does nothing if the slot has not yet been filled.\n\n    Args:\n      slot_record: The _SlotRecord containing this Slot's value.\n    \"\"\"\n    if slot_record.status == _SlotRecord.FILLED:\n      self.filled = True\n      self._filler_pipeline_key = _SlotRecord.filler.get_value_for_datastore(\n          slot_record)\n      self._fill_datetime = slot_record.fill_time\n      self._value = slot_record.value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _inherit_outputs(self,\n                       pipeline_name,\n                       already_defined,\n                       resolve_outputs=False):\n    \"\"\"Inherits outputs from a calling Pipeline.\n\n    Args:\n      pipeline_name: The Pipeline class name (used for debugging).\n      already_defined: Maps output name to stringified db.Key (of _SlotRecords)\n        of any exiting output slots to be inherited by this future.\n      resolve_outputs: When True, this method will dereference all output slots\n        before returning back to the caller, making those output slots' values\n        available.\n\n    Raises:\n      UnexpectedPipelineError when resolve_outputs is True and any of the output\n      slots could not be retrived from the Datastore.\n    \"\"\"\n    for name, slot_key in already_defined.iteritems():\n      if not isinstance(slot_key, db.Key):\n        slot_key = db.Key(slot_key)\n\n      slot = self._output_dict.get(name)\n      if slot is None:\n        if self._strict:\n          raise UnexpectedPipelineError(\n              'Inherited output named \"%s\" must be filled but '\n              'not declared for pipeline class \"%s\"' % (name, pipeline_name))\n        else:\n          self._output_dict[name] = Slot(name=name, slot_key=slot_key)\n      else:\n        slot.key = slot_key\n        slot._exists = True\n\n    if resolve_outputs:\n      slot_key_dict = dict((s.key, s) for s in self._output_dict.itervalues())\n      all_slots = db.get(slot_key_dict.keys())\n      for slot, slot_record in zip(slot_key_dict.itervalues(), all_slots):\n        if slot_record is None:\n          raise UnexpectedPipelineError(\n              'Inherited output named \"%s\" for pipeline class \"%s\" is '\n              'missing its Slot in the datastore: \"%s\"' %\n              (slot.name, pipeline_name, slot.key))\n        slot = slot_key_dict[slot_record.key()]\n        slot._set_value(slot_record)", "response": "Inherits outputs from a calling Pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_id(cls, pipeline_id, resolve_outputs=True, _pipeline_record=None):\n    pipeline_record = _pipeline_record\n\n    # Support pipeline IDs and idempotence_keys that are not unicode.\n    if not isinstance(pipeline_id, unicode):\n      try:\n        pipeline_id = pipeline_id.encode('utf-8')\n      except UnicodeDecodeError:\n        pipeline_id = hashlib.sha1(pipeline_id).hexdigest()\n\n    pipeline_key = db.Key.from_path(_PipelineRecord.kind(), pipeline_id)\n\n    if pipeline_record is None:\n      pipeline_record = db.get(pipeline_key)\n    if pipeline_record is None:\n      return None\n\n    try:\n      pipeline_func_class = mr_util.for_name(pipeline_record.class_path)\n    except ImportError, e:\n      logging.warning('Tried to find Pipeline %s#%s, but class could '\n                      'not be found. Using default Pipeline class instead.',\n                      pipeline_record.class_path, pipeline_id)\n      pipeline_func_class = cls\n\n    params = pipeline_record.params\n    arg_list, kwarg_dict = _dereference_args(\n        pipeline_record.class_path, params['args'], params['kwargs'])\n    outputs = PipelineFuture(pipeline_func_class.output_names)\n    outputs._inherit_outputs(\n        pipeline_record.class_path,\n        params['output_slots'],\n        resolve_outputs=resolve_outputs)\n\n    stage = pipeline_func_class(*arg_list, **kwarg_dict)\n    stage.backoff_seconds = params['backoff_seconds']\n    stage.backoff_factor = params['backoff_factor']\n    stage.max_attempts = params['max_attempts']\n    stage.task_retry = params['task_retry']\n    stage.target = params.get('target')  # May not be defined for old Pipelines\n    stage._current_attempt = pipeline_record.current_attempt\n    stage._set_values_internal(\n        _PipelineContext('', params['queue_name'], params['base_path']),\n        pipeline_key,\n        _PipelineRecord.root_pipeline.get_value_for_datastore(pipeline_record),\n        outputs,\n        pipeline_record.status)\n    return stage", "response": "Returns an instance corresponding to a Pipeline with the given ID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start(self,\n            idempotence_key='',\n            queue_name='default',\n            base_path='/_ah/pipeline',\n            return_task=False,\n            countdown=None,\n            eta=None):\n    \"\"\"Starts a new instance of this pipeline.\n\n    Args:\n      idempotence_key: The ID to use for this Pipeline and throughout its\n        asynchronous workflow to ensure the operations are idempotent. If\n        empty a starting key will be automatically assigned.\n      queue_name: What queue this Pipeline's workflow should execute on.\n      base_path: The relative URL path to where the Pipeline API is\n        mounted for access by the taskqueue API or external requests.\n      return_task: When True, a task to start this pipeline will be returned\n        instead of submitted, allowing the caller to start off this pipeline\n        as part of a separate transaction (potentially leaving this newly\n        allocated pipeline's datastore entities in place if that separate\n        transaction fails for any reason).\n      countdown: Time in seconds into the future that this Task should execute.\n        Defaults to zero.\n      eta: A datetime.datetime specifying the absolute time at which the task\n        should be executed. Must not be specified if 'countdown' is specified.\n        This may be timezone-aware or timezone-naive. If None, defaults to now.\n        For pull tasks, no worker will be able to lease this task before the\n        time indicated by eta.\n\n    Returns:\n      A taskqueue.Task instance if return_task was True. This task will *not*\n      have a name, thus to ensure reliable execution of your pipeline you\n      should add() this task as part of a separate Datastore transaction.\n\n    Raises:\n      PipelineExistsError if the pipeline with the given idempotence key exists.\n      PipelineSetupError if the pipeline could not start for any other reason.\n    \"\"\"\n    if not idempotence_key:\n      idempotence_key = uuid.uuid4().hex\n    elif not isinstance(idempotence_key, unicode):\n      try:\n        idempotence_key.encode('utf-8')\n      except UnicodeDecodeError:\n        idempotence_key = hashlib.sha1(idempotence_key).hexdigest()\n\n    pipeline_key = db.Key.from_path(_PipelineRecord.kind(), idempotence_key)\n    context = _PipelineContext('', queue_name, base_path)\n    future = PipelineFuture(self.output_names, force_strict=True)\n    try:\n      self._set_values_internal(\n          context, pipeline_key, pipeline_key, future, _PipelineRecord.WAITING)\n      return context.start(\n          self, return_task=return_task, countdown=countdown, eta=eta)\n    except Error:\n      # Pass through exceptions that originate in this module.\n      raise\n    except Exception, e:\n      # Re-type any exceptions that were raised in dependent methods.\n      raise PipelineSetupError('Error starting %s#%s: %s' % (\n          self, idempotence_key, str(e)))", "response": "Starts a new taskqueue. Task instance for this pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef retry(self, retry_message=''):\n    if not self.async:\n      raise UnexpectedPipelineError(\n          'May only call retry() method for asynchronous pipelines.')\n    if self.try_cancel():\n      self._context.transition_retry(self._pipeline_key, retry_message)\n      return True\n    else:\n      return False", "response": "Forces a currently running asynchronous pipeline to retry."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef abort(self, abort_message=''):\n    # TODO: Use thread-local variable to enforce that this is not called\n    # while a pipeline is executing in the current thread.\n    if (self.async and self._root_pipeline_key == self._pipeline_key and\n        not self.try_cancel()):\n      # Handle the special case where the root pipeline is async and thus\n      # cannot be aborted outright.\n      return False\n    else:\n      return self._context.begin_abort(\n          self._root_pipeline_key, abort_message=abort_message)", "response": "Mark the entire pipeline up to the root as aborted."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfill an output slot required by this Pipeline.", "response": "def fill(self, name_or_slot, value):\n    \"\"\"Fills an output slot required by this Pipeline.\n\n    Args:\n      name_or_slot: The name of the slot (a string) or Slot record to fill.\n      value: The serializable value to assign to this slot.\n\n    Raises:\n      UnexpectedPipelineError if the Slot no longer exists. SlotNotDeclaredError\n      if trying to output to a slot that was not declared ahead of time.\n    \"\"\"\n    if isinstance(name_or_slot, basestring):\n      slot = getattr(self.outputs, name_or_slot)\n    elif isinstance(name_or_slot, Slot):\n      slot = name_or_slot\n    else:\n      raise UnexpectedPipelineError(\n          'Could not fill invalid output name: %r' % name_or_slot)\n\n    if not slot._exists:\n      raise SlotNotDeclaredError(\n          'Cannot fill output with name \"%s\" that was just '\n          'declared within the Pipeline context.' % slot.name)\n\n    self._context.fill_slot(self._pipeline_key, slot, value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the current status of this pipeline.", "response": "def set_status(self, message=None, console_url=None, status_links=None):\n    \"\"\"Sets the current status of this pipeline.\n\n    This method is purposefully non-transactional. Updates are written to the\n    datastore immediately and overwrite all existing statuses.\n\n    Args:\n      message: (optional) Overall status message.\n      console_url: (optional) Relative URL to use for the \"console\" of this\n        pipeline that displays current progress. When None, no console will\n        be displayed.\n      status_links: (optional) Dictionary of readable link names to relative\n        URLs that should be associated with this pipeline as it runs. These links\n        provide convenient access to other dashboards, consoles, etc associated\n        with the pipeline.\n\n    Raises:\n      PipelineRuntimeError if the status could not be set for any reason.\n    \"\"\"\n    if _TEST_MODE:\n      logging.info(\n          'New status for %s#%s: message=%r, console_url=%r, status_links=%r',\n          self, self.pipeline_id, message, console_url, status_links)\n      return\n\n    status_key = db.Key.from_path(_StatusRecord.kind(), self.pipeline_id)\n    root_pipeline_key = db.Key.from_path(\n        _PipelineRecord.kind(), self.root_pipeline_id)\n    status_record = _StatusRecord(\n        key=status_key, root_pipeline=root_pipeline_key)\n\n    try:\n      if message:\n        status_record.message = message\n      if console_url:\n        status_record.console_url = console_url\n      if status_links:\n        # Alphabeticalize the list.\n        status_record.link_names = sorted(\n            db.Text(s) for s in status_links.iterkeys())\n        status_record.link_urls = [\n            db.Text(status_links[name]) for name in status_record.link_names]\n\n      status_record.status_time = datetime.datetime.utcnow()\n\n      status_record.put()\n    except Exception, e:\n      raise PipelineRuntimeError('Could not set status for %s#%s: %s' %\n          (self, self.pipeline_id, str(e)))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmark this asynchronous Pipeline as complete.", "response": "def complete(self, default_output=None):\n    \"\"\"Marks this asynchronous Pipeline as complete.\n\n    Args:\n      default_output: What value the 'default' output slot should be assigned.\n\n    Raises:\n      UnexpectedPipelineError if the slot no longer exists or this method was\n      called for a pipeline that is not async.\n    \"\"\"\n    # TODO: Enforce that all outputs expected by this async pipeline were\n    # filled before this complete() function was called. May required all\n    # async functions to declare their outputs upfront.\n    if not self.async:\n      raise UnexpectedPipelineError(\n          'May only call complete() method for asynchronous pipelines.')\n    self._context.fill_slot(\n        self._pipeline_key, self.outputs.default, default_output)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_callback_url(self, **kwargs):\n    # TODO: Support positional parameters.\n    if not self.async:\n      raise UnexpectedPipelineError(\n          'May only call get_callback_url() method for asynchronous pipelines.')\n    kwargs['pipeline_id'] = self._pipeline_key.name()\n    params = urllib.urlencode(sorted(kwargs.items()))\n    return '%s/callback?%s' % (self.base_path, params)", "response": "Returns a relative URL for invoking this Pipeline s callback method."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a task that will be executed when this Pipeline is executed.", "response": "def get_callback_task(self, *args, **kwargs):\n    \"\"\"Returns a task for calling back this Pipeline.\n\n    Args:\n      params: Keyword argument containing a dictionary of key/value pairs\n        that will be passed to the callback when it is executed.\n      args, kwargs: Passed to the taskqueue.Task constructor. Use these\n        arguments to set the task name (for idempotence), etc.\n\n    Returns:\n      A taskqueue.Task instance that must be enqueued by the caller.\n    \"\"\"\n    if not self.async:\n      raise UnexpectedPipelineError(\n          'May only call get_callback_task() method for asynchronous pipelines.')\n\n    params = kwargs.get('params', {})\n    kwargs['params'] = params\n    params['pipeline_id'] = self._pipeline_key.name()\n    kwargs['url'] = self.base_path + '/callback'\n    kwargs['method'] = 'POST'\n    return taskqueue.Task(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend an email to admins that the pipeline has completed.", "response": "def send_result_email(self, sender=None):\n    \"\"\"Sends an email to admins indicating this Pipeline has completed.\n\n    For developer convenience. Automatically called from finalized for root\n    Pipelines that do not override the default action.\n\n    Args:\n      sender: (optional) Override the sender's email address.\n    \"\"\"\n    status = 'successful'\n    if self.was_aborted:\n      status = 'aborted'\n\n    app_id = os.environ['APPLICATION_ID']\n    shard_index = app_id.find('~')\n    if shard_index != -1:\n      app_id = app_id[shard_index+1:]\n\n    param_dict = {\n        'status': status,\n        'app_id': app_id,\n        'class_path': self._class_path,\n        'pipeline_id': self.root_pipeline_id,\n        'base_path': '%s.appspot.com%s' % (app_id, self.base_path),\n    }\n    subject = (\n        'Pipeline %(status)s: App \"%(app_id)s\", %(class_path)s'\n        '#%(pipeline_id)s' % param_dict)\n    body = \"\"\"View the pipeline results here:\n\nhttp://%(base_path)s/status?root=%(pipeline_id)s\n\nThanks,\n\nThe Pipeline API\n\"\"\" % param_dict\n\n    html = \"\"\"<html><body>\n<p>View the pipeline results here:</p>\n\n<p><a href=\"http://%(base_path)s/status?root=%(pipeline_id)s\"\n>http://%(base_path)s/status?root=%(pipeline_id)s</a></p>\n\n<p>\nThanks,\n<br>\nThe Pipeline API\n</p>\n</body></html>\n\"\"\" % param_dict\n\n    if sender is None:\n      sender = '%s@%s.appspotmail.com' % (app_id, app_id)\n    try:\n      self._send_mail(sender, subject, body, html=html)\n    except (mail.InvalidSenderError, mail.InvalidEmailError):\n      logging.warning('Could not send result email for '\n                      'root pipeline ID \"%s\" from sender \"%s\"',\n                      self.root_pipeline_id, sender)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclean up this Pipeline and all Datastore records used for coordination.", "response": "def cleanup(self):\n    \"\"\"Clean up this Pipeline and all Datastore records used for coordination.\n\n    Only works when called on a root pipeline. Child pipelines will ignore\n    calls to this method.\n\n    After this method is called, Pipeline.from_id() and related status\n    methods will return inconsistent or missing results. This method is\n    fire-and-forget and asynchronous.\n    \"\"\"\n    if self._root_pipeline_key is None:\n      raise UnexpectedPipelineError(\n          'Could not cleanup Pipeline with unknown root pipeline ID.')\n    if not self.is_root:\n      return\n    task = taskqueue.Task(\n        params=dict(root_pipeline_key=self._root_pipeline_key),\n        url=self.base_path + '/cleanup',\n        headers={'X-Ae-Pipeline-Key': self._root_pipeline_key})\n    taskqueue.Queue(self.queue_name).add(task)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef with_params(self, **kwargs):\n    if _TEST_MODE:\n      logging.info(\n          'Setting runtime parameters for %s#%s: %r',\n          self, self.pipeline_id, kwargs)\n      return self\n\n    if self.pipeline_id is not None:\n      raise UnexpectedPipelineError(\n          'May only call with_params() on a Pipeline that has not yet '\n          'been scheduled for execution.')\n\n    ALLOWED = ('backoff_seconds', 'backoff_factor', 'max_attempts', 'target')\n    for name, value in kwargs.iteritems():\n      if name not in ALLOWED:\n        raise TypeError('Unexpected keyword: %s=%r' % (name, value))\n      setattr(self, name, value)\n    return self", "response": "Modify the execution parameters of this Pipeline instance before it runs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the absolute path to this class as a string.", "response": "def _set_class_path(cls, module_dict=sys.modules):\n    \"\"\"Sets the absolute path to this class as a string.\n\n    Used by the Pipeline API to reconstruct the Pipeline sub-class object\n    at execution time instead of passing around a serialized function.\n\n    Args:\n      module_dict: Used for testing.\n    \"\"\"\n    # Do not traverse the class hierarchy fetching the class path attribute.\n    found = cls.__dict__.get('_class_path')\n    if found is not None:\n      return\n\n    # Do not set the _class_path for the base-class, otherwise all children's\n    # lookups for _class_path will fall through and return 'Pipeline' above.\n    # This situation can happen if users call the generic Pipeline.from_id\n    # to get the result of a Pipeline without knowing its specific class.\n    if cls is Pipeline:\n      return\n\n    class_path = '%s.%s' % (cls.__module__, cls.__name__)\n    # When a WSGI handler is invoked as an entry point, any Pipeline class\n    # defined in the same file as the handler will get __module__ set to\n    # __main__. Thus we need to find out its real fully qualified path.\n    if cls.__module__ == '__main__':\n      for name, module in module_dict.items():\n        if name == '__main__':\n          continue\n        found = getattr(module, cls.__name__, None)\n        if found is cls:\n          class_path = '%s.%s' % (name, cls.__name__)\n          break\n    cls._class_path = class_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the user - visible values provided as an API by this class.", "response": "def _set_values_internal(self,\n                           context,\n                           pipeline_key,\n                           root_pipeline_key,\n                           outputs,\n                           result_status):\n    \"\"\"Sets the user-visible values provided as an API by this class.\n\n    Args:\n      context: The _PipelineContext used for this Pipeline.\n      pipeline_key: The db.Key of this pipeline.\n      root_pipeline_key: The db.Key of the root pipeline.\n      outputs: The PipelineFuture for this pipeline.\n      result_status: The result status of this pipeline.\n    \"\"\"\n    self._context = context\n    self._pipeline_key = pipeline_key\n    self._root_pipeline_key = root_pipeline_key\n    self._result_status = result_status\n    self.outputs = outputs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _callback_internal(self, kwargs):\n    logging.debug('Callback %s(*%s, **%s)#%s with params: %r',\n                  self._class_path, _short_repr(self.args),\n                  _short_repr(self.kwargs), self._pipeline_key.name(), kwargs)\n    return self.callback(**kwargs)", "response": "Used to execute callbacks on asynchronous pipelines."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _run_internal(self,\n                    context,\n                    pipeline_key,\n                    root_pipeline_key,\n                    caller_output):\n    \"\"\"Used by the Pipeline evaluator to execute this Pipeline.\"\"\"\n    self._set_values_internal(\n        context, pipeline_key, root_pipeline_key, caller_output,\n        _PipelineRecord.RUN)\n    logging.debug('Running %s(*%s, **%s)#%s',\n                  self._class_path, _short_repr(self.args),\n                  _short_repr(self.kwargs), self._pipeline_key.name())\n    return self.run(*self.args, **self.kwargs)", "response": "Internal method to execute this Pipeline."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuses by the Pipeline evaluator to finalize this Pipeline.", "response": "def _finalized_internal(self,\n                          context,\n                          pipeline_key,\n                          root_pipeline_key,\n                          caller_output,\n                          aborted):\n    \"\"\"Used by the Pipeline evaluator to finalize this Pipeline.\"\"\"\n    result_status = _PipelineRecord.RUN\n    if aborted:\n      result_status = _PipelineRecord.ABORTED\n\n    self._set_values_internal(\n        context, pipeline_key, root_pipeline_key, caller_output, result_status)\n    logging.debug('Finalizing %s(*%r, **%r)#%s',\n                  self._class_path, _short_repr(self.args),\n                  _short_repr(self.kwargs), self._pipeline_key.name())\n    try:\n      self.finalized()\n    except NotImplementedError:\n      pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a future to the list of in - order futures thus far.", "response": "def _add_future(cls, future):\n    \"\"\"Adds a future to the list of in-order futures thus far.\n\n    Args:\n      future: The future to add to the list.\n    \"\"\"\n    if cls._local._activated:\n      cls._local._in_order_futures.add(future)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring thread local is initialized.", "response": "def _thread_init(cls):\n    \"\"\"Ensure thread local is initialized.\"\"\"\n    if not hasattr(cls._local, '_in_order_futures'):\n      cls._local._in_order_futures = set()\n      cls._local._activated = False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a _PipelineContext from the task queue environment.", "response": "def from_environ(cls, environ=os.environ):\n    \"\"\"Constructs a _PipelineContext from the task queue environment.\"\"\"\n    base_path, unused = (environ['PATH_INFO'].rsplit('/', 1) + [''])[:2]\n    return cls(\n        environ['HTTP_X_APPENGINE_TASKNAME'],\n        environ['HTTP_X_APPENGINE_QUEUENAME'],\n        base_path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fill_slot(self, filler_pipeline_key, slot, value):\n    if not isinstance(filler_pipeline_key, db.Key):\n      filler_pipeline_key = db.Key(filler_pipeline_key)\n\n    if _TEST_MODE:\n      slot._set_value_test(filler_pipeline_key, value)\n    else:\n      encoded_value = json.dumps(value,\n                                       sort_keys=True,\n                                       cls=mr_util.JsonEncoder)\n      value_text = None\n      value_blob = None\n      if len(encoded_value) <= _MAX_JSON_SIZE:\n        value_text = db.Text(encoded_value)\n      else:\n        # The encoded value is too big. Save it as a blob.\n        value_blob = _write_json_blob(encoded_value, filler_pipeline_key.name())\n\n      def txn():\n        slot_record = db.get(slot.key)\n        if slot_record is None:\n          raise UnexpectedPipelineError(\n              'Tried to fill missing slot \"%s\" '\n              'by pipeline ID \"%s\" with value: %r'\n              % (slot.key, filler_pipeline_key.name(), value))\n        # NOTE: Always take the override value here. If down-stream pipelines\n        # need a consitent view of all up-stream outputs (meaning, all of the\n        # outputs came from the same retry attempt of the upstream pipeline),\n        # the down-stream pipeline must also wait for the 'default' output\n        # of these up-stream pipelines.\n        slot_record.filler = filler_pipeline_key\n        slot_record.value_text = value_text\n        slot_record.value_blob = value_blob\n        slot_record.status = _SlotRecord.FILLED\n        slot_record.fill_time = self._gettime()\n        slot_record.put()\n        task = taskqueue.Task(\n            url=self.barrier_handler_path,\n            params=dict(\n                slot_key=slot.key,\n                use_barrier_indexes=True),\n            headers={'X-Ae-Slot-Key': slot.key,\n                     'X-Ae-Filler-Pipeline-Key': filler_pipeline_key})\n        task.add(queue_name=self.queue_name, transactional=True)\n      db.run_in_transaction_options(\n          db.create_transaction_options(propagation=db.ALLOWED), txn)\n\n    self.session_filled_output_names.add(slot.name)", "response": "Fills a slot with the given value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nnotify all barriers affected by a slot.", "response": "def notify_barriers(self,\n                      slot_key,\n                      cursor,\n                      use_barrier_indexes,\n                      max_to_notify=_MAX_BARRIERS_TO_NOTIFY):\n    \"\"\"Searches for barriers affected by a slot and triggers completed ones.\n\n    Args:\n      slot_key: db.Key or stringified key of the _SlotRecord that was filled.\n      cursor: Stringified Datastore cursor where the notification query\n        should pick up.\n      use_barrier_indexes: When True, use _BarrierIndex records to determine\n        which _Barriers to trigger by having this _SlotRecord filled. When\n        False, use the old method that queries for _BarrierRecords by\n        the blocking_slots parameter.\n      max_to_notify: Used for testing.\n\n    Raises:\n      PipelineStatusError: If any of the barriers are in a bad state.\n    \"\"\"\n    if not isinstance(slot_key, db.Key):\n      slot_key = db.Key(slot_key)\n    logging.debug('Notifying slot %r', slot_key)\n\n    if use_barrier_indexes:\n      # Please see models.py:_BarrierIndex to understand how _BarrierIndex\n      # entities relate to _BarrierRecord entities.\n      query = (\n          _BarrierIndex.all(cursor=cursor, keys_only=True)\n          .ancestor(slot_key))\n      barrier_index_list = query.fetch(max_to_notify)\n      barrier_key_list = [\n          _BarrierIndex.to_barrier_key(key) for key in barrier_index_list]\n\n      # If there are task and pipeline kickoff retries it's possible for a\n      # _BarrierIndex to exist for a _BarrierRecord that was not successfully\n      # written. It's safe to ignore this because the original task that wrote\n      # the _BarrierIndex and _BarrierRecord would not have made progress to\n      # kick off a real pipeline or child pipeline unless all of the writes for\n      # these dependent entities went through. We assume that the instigator\n      # retried from scratch and somehwere there exists a good _BarrierIndex and\n      # corresponding _BarrierRecord that tries to accomplish the same thing.\n      barriers = db.get(barrier_key_list)\n      results = []\n      for barrier_key, barrier in zip(barrier_key_list, barriers):\n        if barrier is None:\n          logging.debug('Ignoring that Barrier \"%r\" is missing, '\n                        'relies on Slot \"%r\"', barrier_key, slot_key)\n        else:\n          results.append(barrier)\n    else:\n      # TODO(user): Delete this backwards compatible codepath and\n      # make use_barrier_indexes the assumed default in all cases.\n      query = (\n          _BarrierRecord.all(cursor=cursor)\n          .filter('blocking_slots =', slot_key))\n      results = query.fetch(max_to_notify)\n\n    # Fetch all blocking _SlotRecords for any potentially triggered barriers.\n    blocking_slot_keys = []\n    for barrier in results:\n      blocking_slot_keys.extend(barrier.blocking_slots)\n\n    blocking_slot_dict = {}\n    for slot_record in db.get(blocking_slot_keys):\n      if slot_record is None:\n        continue\n      blocking_slot_dict[slot_record.key()] = slot_record\n\n    task_list = []\n    updated_barriers = []\n    for barrier in results:\n      ready_slots = []\n      for blocking_slot_key in barrier.blocking_slots:\n        slot_record = blocking_slot_dict.get(blocking_slot_key)\n        if slot_record is None:\n          raise UnexpectedPipelineError(\n              'Barrier \"%r\" relies on Slot \"%r\" which is missing.' %\n              (barrier.key(), blocking_slot_key))\n        if slot_record.status == _SlotRecord.FILLED:\n          ready_slots.append(blocking_slot_key)\n\n      # When all of the blocking_slots have been filled, consider the barrier\n      # ready to trigger. We'll trigger it regardless of the current\n      # _BarrierRecord status, since there could be task queue failures at any\n      # point in this flow; this rolls forward the state and de-dupes using\n      # the task name tombstones.\n      pending_slots = set(barrier.blocking_slots) - set(ready_slots)\n      if not pending_slots:\n        if barrier.status != _BarrierRecord.FIRED:\n          barrier.status = _BarrierRecord.FIRED\n          barrier.trigger_time = self._gettime()\n          updated_barriers.append(barrier)\n\n        purpose = barrier.key().name()\n        if purpose == _BarrierRecord.START:\n          path = self.pipeline_handler_path\n          countdown = None\n        else:\n          path = self.finalized_handler_path\n          # NOTE: Wait one second before finalization to prevent\n          # contention on the _PipelineRecord entity.\n          countdown = 1\n        pipeline_key = _BarrierRecord.target.get_value_for_datastore(barrier)\n        pipeline_record = db.get(pipeline_key)\n        logging.debug('Firing barrier %r', barrier.key())\n        task_list.append(taskqueue.Task(\n            url=path,\n            countdown=countdown,\n            name='ae-barrier-fire-%s-%s' % (pipeline_key.name(), purpose),\n            params=dict(pipeline_key=pipeline_key, purpose=purpose),\n            headers={'X-Ae-Pipeline-Key': pipeline_key},\n            target=pipeline_record.params['target']))\n      else:\n        logging.debug('Not firing barrier %r, Waiting for slots: %r',\n                      barrier.key(), pending_slots)\n\n    # Blindly overwrite _BarrierRecords that have an updated status. This is\n    # acceptable because by this point all finalization barriers for\n    # generator children should have already had their final outputs assigned.\n    if updated_barriers:\n      db.put(updated_barriers)\n\n    # Task continuation with sequence number to prevent fork-bombs.\n    if len(results) == max_to_notify:\n      the_match = re.match('(.*)-ae-barrier-notify-([0-9]+)', self.task_name)\n      if the_match:\n        prefix = the_match.group(1)\n        end = int(the_match.group(2)) + 1\n      else:\n        prefix = self.task_name\n        end = 0\n      task_list.append(taskqueue.Task(\n          name='%s-ae-barrier-notify-%d' % (prefix, end),\n          url=self.barrier_handler_path,\n          params=dict(\n              slot_key=slot_key,\n              cursor=query.cursor(),\n              use_barrier_indexes=use_barrier_indexes)))\n\n    if task_list:\n      try:\n        taskqueue.Queue(self.queue_name).add(task_list)\n      except (taskqueue.TombstonedTaskError, taskqueue.TaskAlreadyExistsError):\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef begin_abort(self, root_pipeline_key, abort_message):\n    def txn():\n      pipeline_record = db.get(root_pipeline_key)\n      if pipeline_record is None:\n        logging.warning(\n            'Tried to abort root pipeline ID \"%s\" but it does not exist.',\n            root_pipeline_key.name())\n        raise db.Rollback()\n      if pipeline_record.status == _PipelineRecord.ABORTED:\n        logging.warning(\n            'Tried to abort root pipeline ID \"%s\"; already in state: %s',\n            root_pipeline_key.name(), pipeline_record.status)\n        raise db.Rollback()\n      if pipeline_record.abort_requested:\n        logging.warning(\n            'Tried to abort root pipeline ID \"%s\"; abort signal already sent.',\n            root_pipeline_key.name())\n        raise db.Rollback()\n\n      pipeline_record.abort_requested = True\n      pipeline_record.abort_message = abort_message\n      pipeline_record.put()\n\n      task = taskqueue.Task(\n          url=self.fanout_abort_handler_path,\n          params=dict(root_pipeline_key=root_pipeline_key))\n      task.add(queue_name=self.queue_name, transactional=True)\n      return True\n\n    return db.run_in_transaction(txn)", "response": "Starts the abort process for a root pipeline and all its children."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends the abort signal to all child pipelines that are in the root pipeline.", "response": "def continue_abort(self,\n                     root_pipeline_key,\n                     cursor=None,\n                     max_to_notify=_MAX_ABORTS_TO_BEGIN):\n    \"\"\"Sends the abort signal to all children for a root pipeline.\n\n    Args:\n      root_pipeline_key: db.Key of the root pipeline to abort.\n      cursor: The query cursor for enumerating _PipelineRecords when inserting\n        tasks to cause child pipelines to terminate.\n      max_to_notify: Used for testing.\n    \"\"\"\n    if not isinstance(root_pipeline_key, db.Key):\n      root_pipeline_key = db.Key(root_pipeline_key)\n    # NOTE: The results of this query may include _PipelineRecord instances\n    # that are not actually \"reachable\", meaning you cannot get to them by\n    # starting at the root pipeline and following \"fanned_out\" onward. This\n    # is acceptable because even these defunct _PipelineRecords will properly\n    # set their status to ABORTED when the signal comes, regardless of any\n    # other status they may have had.\n    #\n    # The only gotcha here is if a Pipeline's finalize method somehow modifies\n    # its inputs (like deleting an input file). In the case there are\n    # unreachable child pipelines, it will appear as if two finalize methods\n    # have been called instead of just one. The saving grace here is that\n    # finalize must be idempotent, so this *should* be harmless.\n    query = (\n        _PipelineRecord.all(cursor=cursor)\n        .filter('root_pipeline =', root_pipeline_key))\n    results = query.fetch(max_to_notify)\n\n    task_list = []\n    for pipeline_record in results:\n      if pipeline_record.status not in (\n          _PipelineRecord.RUN, _PipelineRecord.WAITING):\n        continue\n\n      pipeline_key = pipeline_record.key()\n      task_list.append(taskqueue.Task(\n          name='%s-%s-abort' % (self.task_name, pipeline_key.name()),\n          url=self.abort_handler_path,\n          params=dict(pipeline_key=pipeline_key, purpose=_BarrierRecord.ABORT),\n          headers={'X-Ae-Pipeline-Key': pipeline_key}))\n\n    # Task continuation with sequence number to prevent fork-bombs.\n    if len(results) == max_to_notify:\n      the_match = re.match('(.*)-([0-9]+)', self.task_name)\n      if the_match:\n        prefix = the_match.group(1)\n        end = int(the_match.group(2)) + 1\n      else:\n        prefix = self.task_name\n        end = 0\n      task_list.append(taskqueue.Task(\n          name='%s-%d' % (prefix, end),\n          url=self.fanout_abort_handler_path,\n          params=dict(root_pipeline_key=root_pipeline_key,\n                      cursor=query.cursor())))\n\n    if task_list:\n      try:\n        taskqueue.Queue(self.queue_name).add(task_list)\n      except (taskqueue.TombstonedTaskError, taskqueue.TaskAlreadyExistsError):\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start(self, pipeline, return_task=True, countdown=None, eta=None):\n    # Adjust all pipeline output keys for this Pipeline to be children of\n    # the _PipelineRecord, that way we can write them all and submit in a\n    # single transaction.\n    for name, slot in pipeline.outputs._output_dict.iteritems():\n      slot.key = db.Key.from_path(\n          *slot.key.to_path(), **dict(parent=pipeline._pipeline_key))\n\n    _, output_slots, params_text, params_blob = _generate_args(\n        pipeline, pipeline.outputs, self.queue_name, self.base_path)\n\n    @db.transactional(propagation=db.INDEPENDENT)\n    def txn():\n      pipeline_record = db.get(pipeline._pipeline_key)\n      if pipeline_record is not None:\n        raise PipelineExistsError(\n            'Pipeline with idempotence key \"%s\" already exists; params=%s' %\n            (pipeline._pipeline_key.name(),\n             _short_repr(pipeline_record.params)))\n\n      entities_to_put = []\n      for name, slot in pipeline.outputs._output_dict.iteritems():\n        entities_to_put.append(_SlotRecord(\n            key=slot.key,\n            root_pipeline=pipeline._pipeline_key))\n\n      entities_to_put.append(_PipelineRecord(\n          key=pipeline._pipeline_key,\n          root_pipeline=pipeline._pipeline_key,\n          is_root_pipeline=True,\n          # Bug in DB means we need to use the storage name here,\n          # not the local property name.\n          params=params_text,\n          params_blob=params_blob,\n          start_time=self._gettime(),\n          class_path=pipeline._class_path,\n          max_attempts=pipeline.max_attempts))\n\n      entities_to_put.extend(_PipelineContext._create_barrier_entities(\n          pipeline._pipeline_key,\n          pipeline._pipeline_key,\n          _BarrierRecord.FINALIZE,\n          output_slots))\n\n      db.put(entities_to_put)\n\n      task = taskqueue.Task(\n          url=self.pipeline_handler_path,\n          params=dict(pipeline_key=pipeline._pipeline_key),\n          headers={'X-Ae-Pipeline-Key': pipeline._pipeline_key},\n          target=pipeline.target,\n          countdown=countdown,\n          eta=eta)\n      if return_task:\n        return task\n      task.add(queue_name=self.queue_name, transactional=True)\n\n    task = txn()\n    # Immediately mark the output slots as existing so they can be filled\n    # by asynchronous pipelines or used in test mode.\n    for output_slot in pipeline.outputs._output_dict.itervalues():\n      output_slot._exists = True\n    return task", "response": "Starts a new pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef evaluate(self, pipeline_key, purpose=None, attempt=0):\n    After._thread_init()\n    InOrder._thread_init()\n    InOrder._local._activated = False\n\n    if not isinstance(pipeline_key, db.Key):\n      pipeline_key = db.Key(pipeline_key)\n    pipeline_record = db.get(pipeline_key)\n    if pipeline_record is None:\n      logging.error('Pipeline ID \"%s\" does not exist.', pipeline_key.name())\n      return\n    if pipeline_record.status not in (\n        _PipelineRecord.WAITING, _PipelineRecord.RUN):\n\n      # If we're attempting to abort an already aborted pipeline,\n      # we silently advance. #50\n      if (pipeline_record.status == _PipelineRecord.ABORTED and\n            purpose == _BarrierRecord.ABORT):\n        return\n\n      logging.error('Pipeline ID \"%s\" in bad state for purpose \"%s\": \"%s\"',\n                    pipeline_key.name(), purpose or _BarrierRecord.START,\n                    pipeline_record.status)\n      return\n\n    params = pipeline_record.params\n    root_pipeline_key = \\\n        _PipelineRecord.root_pipeline.get_value_for_datastore(pipeline_record)\n    default_slot_key = db.Key(params['output_slots']['default'])\n\n    default_slot_record, root_pipeline_record = db.get([\n        default_slot_key, root_pipeline_key])\n    if default_slot_record is None:\n      logging.error('Pipeline ID \"%s\" default slot \"%s\" does not exist.',\n                    pipeline_key.name(), default_slot_key)\n      return\n    if root_pipeline_record is None:\n      logging.error('Pipeline ID \"%s\" root pipeline ID \"%s\" is missing.',\n                    pipeline_key.name(), root_pipeline_key.name())\n      return\n\n    # Always finalize if we're aborting so pipelines have a chance to cleanup\n    # before they terminate. Pipelines must access 'was_aborted' to find\n    # out how their finalization should work.\n    abort_signal = (\n        purpose == _BarrierRecord.ABORT or\n        root_pipeline_record.abort_requested == True)\n    finalize_signal = (\n        (default_slot_record.status == _SlotRecord.FILLED and\n         purpose == _BarrierRecord.FINALIZE) or abort_signal)\n\n    try:\n      pipeline_func_class = mr_util.for_name(pipeline_record.class_path)\n    except ImportError, e:\n      # This means something is wrong with the deployed code. Rely on the\n      # taskqueue system to do retries.\n      retry_message = '%s: %s' % (e.__class__.__name__, str(e))\n      logging.exception(\n          'Could not locate %s#%s. %s',\n          pipeline_record.class_path, pipeline_key.name(), retry_message)\n      raise\n\n    try:\n      pipeline_func = pipeline_func_class.from_id(\n          pipeline_key.name(),\n          resolve_outputs=finalize_signal,\n          _pipeline_record=pipeline_record)\n    except SlotNotFilledError, e:\n      logging.exception(\n          'Could not resolve arguments for %s#%s. Most likely this means there '\n          'is a bug in the Pipeline runtime or some intermediate data has been '\n          'deleted from the Datastore. Giving up.',\n          pipeline_record.class_path, pipeline_key.name())\n      self.transition_aborted(pipeline_key)\n      return\n    except Exception, e:\n      retry_message = '%s: %s' % (e.__class__.__name__, str(e))\n      logging.exception(\n          'Instantiating %s#%s raised exception. %s',\n          pipeline_record.class_path, pipeline_key.name(), retry_message)\n      self.transition_retry(pipeline_key, retry_message)\n      if pipeline_record.params['task_retry']:\n        raise\n      else:\n        return\n    else:\n      pipeline_generator = mr_util.is_generator_function(\n          pipeline_func_class.run)\n      caller_output = pipeline_func.outputs\n\n    if (abort_signal and pipeline_func.async and\n        pipeline_record.status == _PipelineRecord.RUN\n        and not pipeline_func.try_cancel()):\n      logging.warning(\n          'Could not cancel and abort mid-flight async pipeline: %r#%s',\n          pipeline_func, pipeline_key.name())\n      return\n\n    if finalize_signal:\n      try:\n        pipeline_func._finalized_internal(\n              self, pipeline_key, root_pipeline_key,\n              caller_output, abort_signal)\n      except Exception, e:\n        # This means something is wrong with the deployed finalization code.\n        # Rely on the taskqueue system to do retries.\n        retry_message = '%s: %s' % (e.__class__.__name__, str(e))\n        logging.exception('Finalizing %r#%s raised exception. %s',\n                          pipeline_func, pipeline_key.name(), retry_message)\n        raise\n      else:\n        if not abort_signal:\n          self.transition_complete(pipeline_key)\n          return\n\n    if abort_signal:\n      logging.debug('Marking as aborted %s#%s', pipeline_func,\n                    pipeline_key.name())\n      self.transition_aborted(pipeline_key)\n      return\n\n    if pipeline_record.current_attempt != attempt:\n      logging.error(\n          'Received evaluation task for pipeline ID \"%s\" attempt %d but '\n          'current pending attempt is %d', pipeline_key.name(), attempt,\n          pipeline_record.current_attempt)\n      return\n\n    if pipeline_record.current_attempt >= pipeline_record.max_attempts:\n      logging.error(\n          'Received evaluation task for pipeline ID \"%s\" on attempt %d '\n          'but that exceeds max attempts %d', pipeline_key.name(), attempt,\n          pipeline_record.max_attempts)\n      return\n\n    if pipeline_record.next_retry_time is not None:\n      retry_time = pipeline_record.next_retry_time - _RETRY_WIGGLE_TIMEDELTA\n      if self._gettime() <= retry_time:\n        detail_message = (\n            'Received evaluation task for pipeline ID \"%s\" on attempt %d, '\n            'which will not be ready until: %s' % (pipeline_key.name(),\n            pipeline_record.current_attempt, pipeline_record.next_retry_time))\n        logging.warning(detail_message)\n        raise UnexpectedPipelineError(detail_message)\n\n    if pipeline_record.status == _PipelineRecord.RUN and pipeline_generator:\n      if (default_slot_record.status == _SlotRecord.WAITING and\n          not pipeline_record.fanned_out):\n        # This properly handles the yield-less generator case when the\n        # RUN state transition worked properly but outputting to the default\n        # slot failed.\n        self.fill_slot(pipeline_key, caller_output.default, None)\n      return\n\n    if (pipeline_record.status == _PipelineRecord.WAITING and\n        pipeline_func.async):\n      self.transition_run(pipeline_key)\n\n    try:\n      result = pipeline_func._run_internal(\n          self, pipeline_key, root_pipeline_key, caller_output)\n    except Exception, e:\n      if self.handle_run_exception(pipeline_key, pipeline_func, e):\n        raise\n      else:\n        return\n\n    if pipeline_func.async:\n      return\n\n    if not pipeline_generator:\n      # Catch any exceptions that are thrown when the pipeline's return\n      # value is being serialized. This ensures that serialization errors\n      # will cause normal abort/retry behavior.\n      try:\n        self.fill_slot(pipeline_key, caller_output.default, result)\n      except Exception, e:\n        retry_message = 'Bad return value. %s: %s' % (\n            e.__class__.__name__, str(e))\n        logging.exception(\n            'Generator %r#%s caused exception while serializing return '\n            'value %r. %s', pipeline_func, pipeline_key.name(), result,\n            retry_message)\n        self.transition_retry(pipeline_key, retry_message)\n        if pipeline_func.task_retry:\n          raise\n        else:\n          return\n\n      expected_outputs = set(caller_output._output_dict.iterkeys())\n      found_outputs = self.session_filled_output_names\n      if expected_outputs != found_outputs:\n        exception = SlotNotFilledError(\n            'Outputs %r for pipeline ID \"%s\" were never filled by \"%s\".' % (\n            expected_outputs - found_outputs,\n            pipeline_key.name(), pipeline_func._class_path))\n        if self.handle_run_exception(pipeline_key, pipeline_func, exception):\n          raise exception\n      return\n\n    pipeline_iter = result\n    next_value = None\n    last_sub_stage = None\n    sub_stage = None\n    sub_stage_dict = {}\n    sub_stage_ordering = []\n\n    while True:\n      try:\n        yielded = pipeline_iter.send(next_value)\n      except StopIteration:\n        break\n      except Exception, e:\n        if self.handle_run_exception(pipeline_key, pipeline_func, e):\n          raise\n        else:\n          return\n\n      if isinstance(yielded, Pipeline):\n        if yielded in sub_stage_dict:\n          raise UnexpectedPipelineError(\n              'Already yielded pipeline object %r with pipeline ID %s' %\n              (yielded, yielded.pipeline_id))\n\n        last_sub_stage = yielded\n        next_value = PipelineFuture(yielded.output_names)\n        next_value._after_all_pipelines.update(After._local._after_all_futures)\n        next_value._after_all_pipelines.update(InOrder._local._in_order_futures)\n        sub_stage_dict[yielded] = next_value\n        sub_stage_ordering.append(yielded)\n        InOrder._add_future(next_value)\n\n        # To aid local testing, the task_retry flag (which instructs the\n        # evaluator to raise all exceptions back up to the task queue) is\n        # inherited by all children from the root down.\n        yielded.task_retry = pipeline_func.task_retry\n      else:\n        raise UnexpectedPipelineError(\n            'Yielded a disallowed value: %r' % yielded)\n\n    if last_sub_stage:\n      # Final yielded stage inherits outputs from calling pipeline that were not\n      # already filled during the generator's execution.\n      inherited_outputs = params['output_slots']\n      for slot_name in self.session_filled_output_names:\n        del inherited_outputs[slot_name]\n      sub_stage_dict[last_sub_stage]._inherit_outputs(\n          pipeline_record.class_path, inherited_outputs)\n    else:\n      # Here the generator has yielded nothing, and thus acts as a synchronous\n      # function. We can skip the rest of the generator steps completely and\n      # fill the default output slot to cause finalizing.\n      expected_outputs = set(caller_output._output_dict.iterkeys())\n      expected_outputs.remove('default')\n      found_outputs = self.session_filled_output_names\n      if expected_outputs != found_outputs:\n        exception = SlotNotFilledError(\n            'Outputs %r for pipeline ID \"%s\" were never filled by \"%s\".' % (\n            expected_outputs - found_outputs,\n            pipeline_key.name(), pipeline_func._class_path))\n        if self.handle_run_exception(pipeline_key, pipeline_func, exception):\n          raise exception\n      else:\n        self.fill_slot(pipeline_key, caller_output.default, None)\n        self.transition_run(pipeline_key)\n      return\n\n    # Allocate any SlotRecords that do not yet exist.\n    entities_to_put = []\n    for future in sub_stage_dict.itervalues():\n      for slot in future._output_dict.itervalues():\n        if not slot._exists:\n          entities_to_put.append(_SlotRecord(\n              key=slot.key, root_pipeline=root_pipeline_key))\n\n    # Allocate PipelineRecords and BarrierRecords for generator-run Pipelines.\n    pipelines_to_run = set()\n    all_children_keys = []\n    all_output_slots = set()\n    for sub_stage in sub_stage_ordering:\n      future = sub_stage_dict[sub_stage]\n\n      # Catch any exceptions that are thrown when the pipeline's parameters\n      # are being serialized. This ensures that serialization errors will\n      # cause normal retry/abort behavior.\n      try:\n        dependent_slots, output_slots, params_text, params_blob = \\\n            _generate_args(sub_stage, future, self.queue_name, self.base_path)\n      except Exception, e:\n        retry_message = 'Bad child arguments. %s: %s' % (\n            e.__class__.__name__, str(e))\n        logging.exception(\n            'Generator %r#%s caused exception while serializing args for '\n            'child pipeline %r. %s', pipeline_func, pipeline_key.name(),\n            sub_stage, retry_message)\n        self.transition_retry(pipeline_key, retry_message)\n        if pipeline_func.task_retry:\n          raise\n        else:\n          return\n\n      child_pipeline_key = db.Key.from_path(\n          _PipelineRecord.kind(), uuid.uuid4().hex)\n      all_output_slots.update(output_slots)\n      all_children_keys.append(child_pipeline_key)\n\n      child_pipeline = _PipelineRecord(\n          key=child_pipeline_key,\n          root_pipeline=root_pipeline_key,\n          # Bug in DB means we need to use the storage name here,\n          # not the local property name.\n          params=params_text,\n          params_blob=params_blob,\n          class_path=sub_stage._class_path,\n          max_attempts=sub_stage.max_attempts)\n      entities_to_put.append(child_pipeline)\n\n      if not dependent_slots:\n        # This child pipeline will run immediately.\n        pipelines_to_run.add(child_pipeline_key)\n        child_pipeline.start_time = self._gettime()\n      else:\n        entities_to_put.extend(_PipelineContext._create_barrier_entities(\n            root_pipeline_key,\n            child_pipeline_key,\n            _BarrierRecord.START,\n            dependent_slots))\n\n      entities_to_put.extend(_PipelineContext._create_barrier_entities(\n          root_pipeline_key,\n          child_pipeline_key,\n          _BarrierRecord.FINALIZE,\n          output_slots))\n\n    # This generator pipeline's finalization barrier must include all of the\n    # outputs of any child pipelines that it runs. This ensures the finalized\n    # calls will not happen until all child pipelines have completed.\n    #\n    # The transition_run() call below will update the FINALIZE _BarrierRecord\n    # for this generator pipeline to include all of these child outputs in\n    # its list of blocking_slots. That update is done transactionally to\n    # make sure the _BarrierRecord only lists the slots that matter.\n    #\n    # However, the notify_barriers() method doesn't find _BarrierRecords\n    # through the blocking_slots field. It finds them through _BarrierIndexes\n    # entities. Thus, before we update the FINALIZE _BarrierRecord in\n    # transition_run(), we need to write _BarrierIndexes for all child outputs.\n    barrier_entities = _PipelineContext._create_barrier_entities(\n        root_pipeline_key,\n        pipeline_key,\n        _BarrierRecord.FINALIZE,\n        all_output_slots)\n    # Ignore the first element which is the _BarrierRecord. That entity must\n    # have already been created and put in the datastore for the parent\n    # pipeline before this code generated child pipelines.\n    barrier_indexes = barrier_entities[1:]\n    entities_to_put.extend(barrier_indexes)\n\n    db.put(entities_to_put)\n\n    self.transition_run(pipeline_key,\n                        blocking_slot_keys=all_output_slots,\n                        fanned_out_pipelines=all_children_keys,\n                        pipelines_to_run=pipelines_to_run)", "response": "Evaluates the given Pipeline and enqueues sub - stages for execution."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _create_barrier_entities(root_pipeline_key,\n                               child_pipeline_key,\n                               purpose,\n                               blocking_slot_keys):\n    \"\"\"Creates all of the entities required for a _BarrierRecord.\n\n    Args:\n      root_pipeline_key: The root pipeline this is part of.\n      child_pipeline_key: The pipeline this barrier is for.\n      purpose: _BarrierRecord.START or _BarrierRecord.FINALIZE.\n      blocking_slot_keys: Set of db.Keys corresponding to _SlotRecords that\n        this barrier should wait on before firing.\n\n    Returns:\n      List of entities, starting with the _BarrierRecord entity, followed by\n      _BarrierIndexes used for firing when _SlotRecords are filled in the same\n      order as the blocking_slot_keys list provided. All of these entities\n      should be put in the Datastore to ensure the barrier fires properly.\n    \"\"\"\n    result = []\n\n    blocking_slot_keys = list(blocking_slot_keys)\n\n    barrier = _BarrierRecord(\n        parent=child_pipeline_key,\n        key_name=purpose,\n        target=child_pipeline_key,\n        root_pipeline=root_pipeline_key,\n        blocking_slots=blocking_slot_keys)\n\n    result.append(barrier)\n\n    for slot_key in blocking_slot_keys:\n      barrier_index_path = []\n      barrier_index_path.extend(slot_key.to_path())\n      barrier_index_path.extend(child_pipeline_key.to_path())\n      barrier_index_path.extend([_BarrierIndex.kind(), purpose])\n      barrier_index_key = db.Key.from_path(*barrier_index_path)\n      barrier_index = _BarrierIndex(\n          key=barrier_index_key,\n          root_pipeline=root_pipeline_key)\n      result.append(barrier_index)\n\n    return result", "response": "Creates all of the entities required for a _BarrierRecord."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle an exception raised by a Pipeline s user code.", "response": "def handle_run_exception(self, pipeline_key, pipeline_func, e):\n    \"\"\"Handles an exception raised by a Pipeline's user code.\n\n    Args:\n      pipeline_key: The pipeline that raised the error.\n      pipeline_func: The class path name of the Pipeline that was running.\n      e: The exception that was raised.\n\n    Returns:\n      True if the exception should be re-raised up through the calling stack\n      by the caller of this method.\n    \"\"\"\n    if isinstance(e, Retry):\n      retry_message = str(e)\n      logging.warning('User forced retry for pipeline ID \"%s\" of %r: %s',\n                      pipeline_key.name(), pipeline_func, retry_message)\n      self.transition_retry(pipeline_key, retry_message)\n    elif isinstance(e, Abort):\n      abort_message = str(e)\n      logging.warning('User forced abort for pipeline ID \"%s\" of %r: %s',\n                      pipeline_key.name(), pipeline_func, abort_message)\n      pipeline_func.abort(abort_message)\n    else:\n      retry_message = '%s: %s' % (e.__class__.__name__, str(e))\n      logging.exception('Generator %r#%s raised exception. %s',\n                        pipeline_func, pipeline_key.name(), retry_message)\n      self.transition_retry(pipeline_key, retry_message)\n\n    return pipeline_func.task_retry"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef transition_run(self,\n                     pipeline_key,\n                     blocking_slot_keys=None,\n                     fanned_out_pipelines=None,\n                     pipelines_to_run=None):\n    \"\"\"Marks an asynchronous or generator pipeline as running.\n\n    Does nothing if the pipeline is no longer in a runnable state.\n\n    Args:\n      pipeline_key: The db.Key of the _PipelineRecord to update.\n      blocking_slot_keys: List of db.Key instances that this pipeline's\n        finalization barrier should wait on in addition to the existing one.\n        This is used to update the barrier to include all child outputs. When\n        None, the barrier will not be updated.\n      fanned_out_pipelines: List of db.Key instances of _PipelineRecords that\n        were fanned out by this generator pipeline. This is distinct from the\n        'pipelines_to_run' list because not all of the pipelines listed here\n        will be immediately ready to execute. When None, then this generator\n        yielded no children.\n      pipelines_to_run: List of db.Key instances of _PipelineRecords that should\n        be kicked off (fan-out) transactionally as part of this transition.\n        When None, no child pipelines will run. All db.Keys in this list must\n        also be present in the fanned_out_pipelines list.\n\n    Raises:\n      UnexpectedPipelineError if blocking_slot_keys was not empty and the\n      _BarrierRecord has gone missing.\n    \"\"\"\n    def txn():\n      pipeline_record = db.get(pipeline_key)\n      if pipeline_record is None:\n        logging.warning('Pipeline ID \"%s\" cannot be marked as run. '\n                        'Does not exist.', pipeline_key.name())\n        raise db.Rollback()\n      if pipeline_record.status != _PipelineRecord.WAITING:\n        logging.warning('Pipeline ID \"%s\" in bad state to be marked as run: %s',\n                        pipeline_key.name(), pipeline_record.status)\n        raise db.Rollback()\n\n      pipeline_record.status = _PipelineRecord.RUN\n\n      if fanned_out_pipelines:\n        # NOTE: We must model the pipeline relationship in a top-down manner,\n        # meaning each pipeline must point forward to the pipelines that it\n        # fanned out to. The reason is race conditions. If evaluate()\n        # dies early, it may create many unused _PipelineRecord and _SlotRecord\n        # instances that never progress. The only way we know which of these\n        # are valid is by traversing the graph from the root, where the\n        # fanned_out property refers to those pipelines that were run using a\n        # transactional task.\n        child_pipeline_list = list(fanned_out_pipelines)\n        pipeline_record.fanned_out = child_pipeline_list\n\n        if pipelines_to_run:\n          child_indexes = [\n              child_pipeline_list.index(p) for p in pipelines_to_run]\n          child_indexes.sort()\n          task = taskqueue.Task(\n              url=self.fanout_handler_path,\n              params=dict(parent_key=str(pipeline_key),\n                          child_indexes=child_indexes))\n          task.add(queue_name=self.queue_name, transactional=True)\n\n      pipeline_record.put()\n\n      if blocking_slot_keys:\n        # NOTE: Always update a generator pipeline's finalization barrier to\n        # include all of the outputs of any pipelines that it runs, to ensure\n        # that finalized calls will not happen until all child pipelines have\n        # completed. This must happen transactionally with the enqueue of\n        # the fan-out kickoff task above to ensure the child output slots and\n        # the barrier blocking slots are the same.\n        barrier_key = db.Key.from_path(\n            _BarrierRecord.kind(), _BarrierRecord.FINALIZE,\n            parent=pipeline_key)\n        finalize_barrier = db.get(barrier_key)\n        if finalize_barrier is None:\n          raise UnexpectedPipelineError(\n              'Pipeline ID \"%s\" cannot update finalize barrier. '\n              'Does not exist.' % pipeline_key.name())\n        else:\n          finalize_barrier.blocking_slots = list(\n              blocking_slot_keys.union(set(finalize_barrier.blocking_slots)))\n          finalize_barrier.put()\n\n    db.run_in_transaction(txn)", "response": "Transition a generator pipeline to run."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmarks the given pipeline as complete.", "response": "def transition_complete(self, pipeline_key):\n    \"\"\"Marks the given pipeline as complete.\n\n    Does nothing if the pipeline is no longer in a state that can be completed.\n\n    Args:\n      pipeline_key: db.Key of the _PipelineRecord that has completed.\n    \"\"\"\n    def txn():\n      pipeline_record = db.get(pipeline_key)\n      if pipeline_record is None:\n        logging.warning(\n            'Tried to mark pipeline ID \"%s\" as complete but it does not exist.',\n            pipeline_key.name())\n        raise db.Rollback()\n      if pipeline_record.status not in (\n          _PipelineRecord.WAITING, _PipelineRecord.RUN):\n        logging.warning(\n            'Tried to mark pipeline ID \"%s\" as complete, found bad state: %s',\n            pipeline_key.name(), pipeline_record.status)\n        raise db.Rollback()\n\n      pipeline_record.status = _PipelineRecord.DONE\n      pipeline_record.finalized_time = self._gettime()\n      pipeline_record.put()\n\n    db.run_in_transaction(txn)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transition_retry(self, pipeline_key, retry_message):\n    def txn():\n      pipeline_record = db.get(pipeline_key)\n      if pipeline_record is None:\n        logging.warning(\n            'Tried to retry pipeline ID \"%s\" but it does not exist.',\n            pipeline_key.name())\n        raise db.Rollback()\n      if pipeline_record.status not in (\n          _PipelineRecord.WAITING, _PipelineRecord.RUN):\n        logging.warning(\n            'Tried to retry pipeline ID \"%s\", found bad state: %s',\n            pipeline_key.name(), pipeline_record.status)\n        raise db.Rollback()\n\n      params = pipeline_record.params\n      offset_seconds = (\n          params['backoff_seconds'] *\n          (params['backoff_factor'] ** pipeline_record.current_attempt))\n      pipeline_record.next_retry_time = (\n          self._gettime() + datetime.timedelta(seconds=offset_seconds))\n      pipeline_record.current_attempt += 1\n      pipeline_record.retry_message = retry_message\n      pipeline_record.status = _PipelineRecord.WAITING\n\n      if pipeline_record.current_attempt >= pipeline_record.max_attempts:\n        root_pipeline_key = (\n            _PipelineRecord.root_pipeline.get_value_for_datastore(\n                pipeline_record))\n        logging.warning(\n            'Giving up on pipeline ID \"%s\" after %d attempt(s); causing abort '\n            'all the way to the root pipeline ID \"%s\"', pipeline_key.name(),\n            pipeline_record.current_attempt, root_pipeline_key.name())\n        # NOTE: We do *not* set the status to aborted here to ensure that\n        # this pipeline will be finalized before it has been marked as aborted.\n        pipeline_record.abort_message = (\n            'Aborting after %d attempts' % pipeline_record.current_attempt)\n        task = taskqueue.Task(\n            url=self.fanout_abort_handler_path,\n            params=dict(root_pipeline_key=root_pipeline_key))\n        task.add(queue_name=self.queue_name, transactional=True)\n      else:\n        task = taskqueue.Task(\n            url=self.pipeline_handler_path,\n            eta=pipeline_record.next_retry_time,\n            params=dict(pipeline_key=pipeline_key,\n                        purpose=_BarrierRecord.START,\n                        attempt=pipeline_record.current_attempt),\n            headers={'X-Ae-Pipeline-Key': pipeline_key},\n            target=pipeline_record.params['target'])\n        task.add(queue_name=self.queue_name, transactional=True)\n\n      pipeline_record.put()\n\n    db.run_in_transaction(txn)", "response": "Transition the given pipeline to requiring another retry."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the callback for the pipeline specified in the request.", "response": "def run_callback(self):\n    \"\"\"Runs the callback for the pipeline specified in the request.\n\n    Raises:\n      _CallbackTaskError if something was wrong with the request parameters.\n    \"\"\"\n    pipeline_id = self.request.get('pipeline_id')\n    if not pipeline_id:\n      raise _CallbackTaskError('\"pipeline_id\" parameter missing.')\n\n    pipeline_key = db.Key.from_path(_PipelineRecord.kind(), pipeline_id)\n    pipeline_record = db.get(pipeline_key)\n    if pipeline_record is None:\n      raise _CallbackTaskError(\n          'Pipeline ID \"%s\" for callback does not exist.' % pipeline_id)\n\n    params = pipeline_record.params\n    real_class_path = params['class_path']\n    try:\n      pipeline_func_class = mr_util.for_name(real_class_path)\n    except ImportError, e:\n      raise _CallbackTaskError(\n          'Cannot load class named \"%s\" for pipeline ID \"%s\".'\n          % (real_class_path, pipeline_id))\n\n    if 'HTTP_X_APPENGINE_TASKNAME' not in self.request.environ:\n      if pipeline_func_class.public_callbacks:\n        pass\n      elif pipeline_func_class.admin_callbacks:\n        if not users.is_current_user_admin():\n          raise _CallbackTaskError(\n              'Unauthorized callback for admin-only pipeline ID \"%s\"'\n              % pipeline_id)\n      else:\n        raise _CallbackTaskError(\n            'External callback for internal-only pipeline ID \"%s\"'\n            % pipeline_id)\n\n    kwargs = {}\n    for key in self.request.arguments():\n      if key != 'pipeline_id':\n        kwargs[str(key)] = self.request.get(key)\n\n    def perform_callback():\n      stage = pipeline_func_class.from_id(pipeline_id)\n      if stage is None:\n        raise _CallbackTaskError(\n            'Pipeline ID \"%s\" deleted during callback' % pipeline_id)\n      return stage._callback_internal(kwargs)\n\n    # callback_xg_transaction is a 3-valued setting (None=no trans,\n    # False=1-eg-trans, True=xg-trans)\n    if pipeline_func_class._callback_xg_transaction is not None:\n      transaction_options = db.create_transaction_options(\n          xg=pipeline_func_class._callback_xg_transaction)\n      callback_result = db.run_in_transaction_options(transaction_options,\n                                                      perform_callback)\n    else:\n      callback_result = perform_callback()\n\n    if callback_result is not None:\n      status_code, content_type, content = callback_result\n      self.response.set_status(status_code)\n      self.response.headers['Content-Type'] = content_type\n      self.response.out.write(content)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind the google_appengine directory and fixes Python imports to use it.", "response": "def _fix_path():\n  \"\"\"Finds the google_appengine directory and fixes Python imports to use it.\"\"\"\n  import os\n  import sys\n  all_paths = os.environ.get('PYTHONPATH').split(os.pathsep)\n  for path_dir in all_paths:\n    dev_appserver_path = os.path.join(path_dir, 'dev_appserver.py')\n    if os.path.exists(dev_appserver_path):\n      logging.debug('Found appengine SDK on path!')\n      google_appengine = os.path.dirname(os.path.realpath(dev_appserver_path))\n      sys.path.append(google_appengine)\n      # Use the next import will fix up sys.path even further to bring in\n      # any dependent lib directories that the SDK needs.\n      dev_appserver = __import__('dev_appserver')\n      sys.path.extend(dev_appserver.EXTRA_PATHS)\n      return"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef params(self):\n    if hasattr(self, '_params_decoded'):\n      return self._params_decoded\n\n    if self.params_blob is not None:\n      value_encoded = self.params_blob.open().read()\n    else:\n      value_encoded = self.params_text\n\n    value = json.loads(value_encoded, cls=util.JsonDecoder)\n    if isinstance(value, dict):\n      kwargs = value.get('kwargs')\n      if kwargs:\n        adjusted_kwargs = {}\n        for arg_key, arg_value in kwargs.iteritems():\n          # Python only allows non-unicode strings as keyword arguments.\n          adjusted_kwargs[str(arg_key)] = arg_value\n        value['kwargs'] = adjusted_kwargs\n\n    self._params_decoded = value\n    return self._params_decoded", "response": "Returns the dictionary of parameters for this Pipeline."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the value of this Slot.", "response": "def value(self):\n    \"\"\"Returns the value of this Slot.\"\"\"\n    if hasattr(self, '_value_decoded'):\n      return self._value_decoded\n\n    if self.value_blob is not None:\n      encoded_value = self.value_blob.open().read()\n    else:\n      encoded_value = self.value_text\n\n    self._value_decoded = json.loads(encoded_value, cls=util.JsonDecoder)\n    return self._value_decoded"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_barrier_key(cls, barrier_index_key):\n    barrier_index_path = barrier_index_key.to_path()\n\n    # Pick out the items from the _BarrierIndex key path that we need to\n    # construct the _BarrierRecord key path.\n    (pipeline_kind, dependent_pipeline_id,\n     unused_kind, purpose) = barrier_index_path[-4:]\n\n    barrier_record_path = (\n        pipeline_kind, dependent_pipeline_id,\n        _BarrierRecord.kind(), purpose)\n\n    return db.Key.from_path(*barrier_record_path)", "response": "Converts a _BarrierIndex key to a _BarrierRecord key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef partial_page(self, page, used_labels):\n        # Check the page number is valid.\n        if page <= self.page_count:\n            raise ValueError(\"Page {0:d} has already started, cannot mark used labels now.\".format(page))\n\n        # Add these to any existing labels marked as used.\n        used = self._used.get(page, set())\n        for row, column in used_labels:\n            # Check the index is valid.\n            if row < 1 or row > self.specs.rows:\n                raise IndexError(\"Invalid row number: {0:d}.\".format(row))\n            if column < 1 or column > self.specs.columns:\n                raise IndexError(\"Invalid column number: {0:d}.\".format(column))\n\n            # Add it.\n            used.add((int(row), int(column)))\n\n        # Save the details.\n        self._used[page] = used", "response": "Allows a page to be marked as already partially used so you can print on the remaining labels."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _next_unused_label(self):\n        self._next_label()\n\n        # This label may be missing.\n        if self.page_count in self._used:\n            # Keep try while the label is missing.\n            missing = self._used.get(self.page_count, set())\n            while tuple(self._position) in missing:\n                # Throw the missing information away now we have used it. This\n                # allows the _shade_remaining_missing method to work.\n                missing.discard(tuple(self._position))\n\n                # Shade the missing label if desired.\n                if self.shade_missing:\n                    self._shade_missing_label()\n\n                # Try our luck with the next label.\n                self._next_label()\n                missing = self._used.get(self.page_count, set())\n\n        # Increment the count now we have found a suitable position.\n        self.label_count += 1", "response": "This method moves to the next unused label. Not intended for external use."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _calculate_edges(self):\n        # Calculate the left edge of the label.\n        left = self.specs.left_margin\n        left += (self.specs.label_width * (self._position[1] - 1))\n        if self.specs.column_gap:\n            left += (self.specs.column_gap * (self._position[1] - 1))\n        left *= mm\n\n        # And the bottom.\n        bottom = self.specs.sheet_height - self.specs.top_margin\n        bottom -= (self.specs.label_height * self._position[0])\n        if self.specs.row_gap:\n            bottom -= (self.specs.row_gap * (self._position[0] - 1))\n        bottom *= mm\n\n        # Done.\n        return float(left), float(bottom)", "response": "Calculate the edges of the current label. Not intended for external use."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _shade_remaining_missing(self):\n        # Sanity check.\n        if not self.shade_missing:\n            return\n\n        # Run through each missing label left in the current page and shade it.\n        missing = self._used.get(self.page_count, set())\n        for position in missing:\n            self._position = position\n            self._shade_missing_label()", "response": "Helper method to shade any missing labels left on the current\n        page."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _draw_label(self, obj, count):\n        # Start a drawing for the whole label.\n        label = Drawing(float(self._lw), float(self._lh))\n        label.add(self._clip_label)\n\n        # And one for the available area (i.e., after padding).\n        available = Drawing(float(self._dw), float(self._dh))\n        available.add(self._clip_drawing)\n\n        # Call the drawing function.\n        self.drawing_callable(available, float(self._dw), float(self._dh), obj)\n\n        # Render the contents on the label.\n        available.shift(float(self._lp), float(self._bp))\n        label.add(available)\n\n        # Draw the border if requested.\n        if self.border:\n            label.add(self._border)\n\n        # Add however many copies we need to.\n        for i in range(count):\n            # Find the next available label.\n            self._next_unused_label()\n\n            # Have we been told to skip this page?\n            if self.pages_to_draw and self.page_count not in self.pages_to_draw:\n                continue\n\n            # Add the label to the page. ReportLab stores the added drawing by\n            # reference so we have to copy it N times.\n            thislabel = copy(label)\n            thislabel.shift(*self._calculate_edges())\n            self._current_page.add(thislabel)", "response": "Draw the label on the current page."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_labels(self, objects, count=1):\n        # If we can convert it to an int, do so and use the itertools.repeat()\n        # method to create an infinite iterator from it. Otherwise, assume it\n        # is an iterable or sequence.\n        try:\n            count = int(count)\n        except TypeError:\n            pass\n        else:\n            count = repeat(count)\n\n        # If it is not an iterable (e.g., a list or range object),\n        # create an iterator over it.\n        if not hasattr(count, 'next') and not hasattr(count, '__next__'):\n            count = iter(count)\n\n        # Go through the objects.\n        for obj in objects:\n            # Check we have a count for this one.\n            try:\n                thiscount = next(count)\n            except StopIteration:\n                break\n\n            # Draw it.\n            self._draw_label(obj, thiscount)", "response": "Adds multiple labels to the sheet."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self, filelike):\n        # Shade any remaining missing labels if desired.\n        self._shade_remaining_missing()\n\n        # Create a canvas.\n        canvas = Canvas(filelike, pagesize=self._pagesize)\n\n        # Render each created page onto the canvas.\n        for page in self._pages:\n            renderPDF.draw(page, canvas, 0, 0)\n            canvas.showPage()\n\n        # Done.\n        canvas.save()", "response": "Save the file as a PDF."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef preview(self, page, filelike, format='png', dpi=72, background_colour=0xFFFFFF):\n        # Check the page number.\n        if page < 1 or page > self.page_count:\n            raise ValueError(\"Invalid page number; should be between 1 and {0:d}.\".format(self.page_count))\n\n        # Shade any remaining missing labels if desired.\n        self._shade_remaining_missing()\n\n        # Rendering to an image (as opposed to a PDF) requires any background\n        # to have an integer width and height if it is a ReportLab Image\n        # object. Drawing objects are exempt from this.\n        oldw, oldh = None, None\n        if isinstance(self._bgimage, Image):\n            oldw, oldh = self._bgimage.width, self._bgimage.height\n            self._bgimage.width = int(oldw) + 1\n            self._bgimage.height = int(oldh) + 1\n\n        # Let ReportLab do the heavy lifting.\n        renderPM.drawToFile(self._pages[page-1], filelike, format, dpi, background_colour)\n\n        # Restore the size of the background image if we changed it.\n        if oldw:\n            self._bgimage.width = oldw\n            self._bgimage.height = oldh", "response": "Render a preview image of a page."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrender a preview image of a page as a string.", "response": "def preview_string(self, page, format='png', dpi=72, background_colour=0xFFFFFF):\n        \"\"\"Render a preview image of a page as a string.\n\n        Parameters\n        ----------\n        page: positive integer\n            Which page to render. Must be in the range [1, page_count]\n        format: string\n            The image format to use for the preview. ReportLab uses the Python\n            Imaging Library (PIL) internally, so any PIL format should be\n            supported.\n        dpi: positive real\n            The dots-per-inch to use when rendering.\n        background_colour: Hex colour specification\n            What color background to use.\n\n        Notes\n        -----\n        If you are creating this sheet for a preview only, you can pass the\n        pages_to_draw parameter to the constructor to avoid the drawing function\n        being called for all the labels on pages you'll never look at. If you\n        preview a page you did not tell the sheet to draw, you will get a blank\n        image.\n\n        Raises\n        ------\n        ValueError:\n            If the page number is not valid.\n\n        \"\"\"\n        # Check the page number.\n        if page < 1 or page > self.page_count:\n            raise ValueError(\"Invalid page number; should be between 1 and {0:d}.\".format(self.page_count))\n\n        # Shade any remaining missing labels if desired.\n        self._shade_remaining_missing()\n\n        # Rendering to an image (as opposed to a PDF) requires any background\n        # to have an integer width and height if it is a ReportLab Image\n        # object. Drawing objects are exempt from this.\n        oldw, oldh = None, None\n        if isinstance(self._bgimage, Image):\n            oldw, oldh = self._bgimage.width, self._bgimage.height\n            self._bgimage.width = int(oldw) + 1\n            self._bgimage.height = int(oldh) + 1\n\n        # Let ReportLab do the heavy lifting.\n        s = renderPM.drawToString(self._pages[page-1], format, dpi, background_colour)\n\n        # Restore the size of the background image if we changed it.\n        if oldw:\n            self._bgimage.width = oldw\n            self._bgimage.height = oldh\n\n        # Done.\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the size of the current object and returns the size of the object.", "response": "def _calculate(self):\n        \"\"\"Checks the dimensions of the sheet are valid and consistent.\n\n        NB: this is called internally when needed; there should be no need for\n        user code to call it.\n\n        \"\"\"\n        # Check the dimensions are larger than zero.\n        for dimension in ('_sheet_width', '_sheet_height', '_columns', '_rows', '_label_width', '_label_height'):\n            if getattr(self, dimension) <= 0:\n                name = dimension.replace('_', ' ').strip().capitalize()\n                raise InvalidDimension(\"{0:s} must be greater than zero.\".format(name))\n\n        # Check margins / gaps are not smaller than zero if given.\n        # At the same time, force the values to decimals.\n        for margin in ('_left_margin', '_column_gap', '_right_margin', '_top_margin', '_row_gap', '_bottom_margin',\n                       '_left_padding', '_right_padding', '_top_padding', '_bottom_padding'):\n            val = getattr(self, margin)\n            if val is not None:\n                if margin in self._autoset:\n                    val = None\n                else:\n                    val = Decimal(val)\n                    if val < 0:\n                        name = margin.replace('_', ' ').strip().capitalize()\n                        raise InvalidDimension(\"{0:s} cannot be less than zero.\".format(name))\n                setattr(self, margin, val)\n            else:\n                self._autoset.add(margin)\n\n        # Check the corner radius.\n        if self._corner_radius < 0:\n            raise InvalidDimension(\"Corner radius cannot be less than zero.\")\n        if self._corner_radius > (self._label_width / 2):\n            raise InvalidDimension(\"Corner radius cannot be more than half the label width.\")\n        if self._corner_radius > (self._label_height / 2):\n            raise InvalidDimension(\"Corner radius cannot be more than half the label height.\")\n\n        # If there is no padding, we don't need the padding radius.\n        if (self._left_padding + self._right_padding + self._top_padding + self._bottom_padding) == 0:\n            if self._padding_radius != 0:\n                raise InvalidDimension(\"Padding radius must be zero if there is no padding.\")\n        else:\n            if (self._left_padding + self._right_padding) >= self._label_width:\n                raise InvalidDimension(\"Sum of horizontal padding must be less than the label width.\")\n            if (self._top_padding + self._bottom_padding) >= self._label_height:\n                raise InvalidDimension(\"Sum of vertical padding must be less than the label height.\")\n            if self._padding_radius < 0:\n                raise InvalidDimension(\"Padding radius cannot be less than zero.\")\n\n        # Calculate the amount of spare space.\n        hspace = self._sheet_width - (self._label_width * self._columns)\n        vspace = self._sheet_height - (self._label_height * self._rows)\n\n        # Cannot fit.\n        if hspace < 0:\n            raise InvalidDimension(\"Labels are too wide to fit on the sheet.\")\n        if vspace < 0:\n            raise InvalidDimension(\"Labels are too tall to fit on the sheet.\")\n\n        # Process the horizontal margins / gaps.\n        hcount = 1 + self._columns\n        if self._left_margin is not None:\n            hspace -= self._left_margin\n            if hspace < 0:\n                raise InvalidDimension(\"Left margin is too wide for the labels to fit on the sheet.\")\n            hcount -= 1\n        if self._column_gap is not None:\n            hspace -= ((self._columns - 1) * self._column_gap)\n            if hspace < 0:\n                raise InvalidDimension(\"Column gap is too wide for the labels to fit on the sheet.\")\n            hcount -= (self._columns - 1)\n        if self._right_margin is not None:\n            hspace -= self._right_margin\n            if hspace < 0.01 and hspace > -0.01:\n                self._right_margin += hspace\n                hspace = 0\n            if hspace < 0:\n                raise InvalidDimension(\"Right margin is too wide for the labels to fit on the sheet.\")\n            hcount -= 1\n\n        # Process the vertical margins / gaps.\n        vcount = 1 + self._rows\n        if self._top_margin is not None:\n            vspace -= self._top_margin\n            if vspace < 0:\n                raise InvalidDimension(\"Top margin is too tall for the labels to fit on the sheet.\")\n            vcount -= 1\n        if self._row_gap is not None:\n            vspace -= ((self._rows - 1) * self._row_gap)\n            if vspace < 0:\n                raise InvalidDimension(\"Row gap is too tall for the labels to fit on the sheet.\")\n            vcount -= (self._rows - 1)\n        if self._bottom_margin is not None:\n            vspace -= self._bottom_margin\n            if vspace < 0.01 and vspace > -0.01:\n                self._bottom_margin += vspace\n                vspace = 0\n            if vspace < 0:\n                raise InvalidDimension(\"Bottom margin is too tall for the labels to fit on the sheet.\")\n            vcount -= 1\n\n        # If all the margins are specified, they must use up all available space.\n        if hcount == 0 and hspace != 0:\n            raise InvalidDimension(\"Not all width used by manually specified margins/gaps; {}mm left.\".format(hspace))\n        if vcount == 0 and vspace != 0:\n            raise InvalidDimension(\"Not all height used by manually specified margins/gaps; {}mm left.\".format(vspace))\n\n        # Split any extra horizontal space and allocate it.\n        if hcount:\n            auto_margin = hspace / hcount\n            for margin in ('_left_margin', '_column_gap', '_right_margin'):\n                if getattr(self, margin) is None:\n                    setattr(self, margin, auto_margin)\n\n        # And allocate any extra vertical space.\n        if vcount:\n            auto_margin = vspace / vcount\n            for margin in ('_top_margin', '_row_gap', '_bottom_margin'):\n                if getattr(self, margin) is None:\n                    setattr(self, margin, auto_margin)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the bounding boxes of the labels on a page.", "response": "def bounding_boxes(self, mode='fraction', output='dict'):\n        \"\"\"Get the bounding boxes of the labels on a page.\n\n        Parameters\n        ----------\n        mode: 'fraction', 'actual'\n            If 'fraction', the bounding boxes are expressed as a fraction of the\n            height and width of the sheet. If 'actual', they are the actual\n            position of the labels in millimetres from the top-left of the\n            sheet.\n        output: 'dict', 'json'\n            If 'dict', a dictionary with label identifier tuples (row, column)\n            as keys and a dictionary with 'left', 'right', 'top', and 'bottom'\n            entries as the values.\n            If 'json', a JSON encoded string which represents a dictionary with\n            keys of the string format 'rowxcolumn' and each value being a\n            bounding box dictionary with 'left', 'right', 'top', and 'bottom'\n            entries.\n\n        Returns\n        -------\n        The bounding boxes in the format set by the output parameter.\n\n        \"\"\"\n        boxes = {}\n\n        # Check the parameters.\n        if mode not in ('fraction', 'actual'):\n            raise ValueError(\"Unknown mode {0}.\".format(mode))\n        if output not in ('dict', 'json'):\n            raise ValueError(\"Unknown output {0}.\".format(output))\n\n        # Iterate over the rows.\n        for row in range(1, self.rows + 1):\n            # Top and bottom of all labels in the row.\n            top = self.top_margin + ((row - 1) * (self.label_height + self.row_gap))\n            bottom = top + self.label_height\n\n            # Now iterate over all columns in this row.\n            for column in range(1, self.columns + 1):\n                # Left and right position of this column.\n                left = self.left_margin + ((column - 1) * (self.label_width + self.column_gap))\n                right = left + self.label_width\n\n                # Output in the appropriate mode format.\n                if mode == 'fraction':\n                    box = {\n                        'top': top / self.sheet_height,\n                        'bottom': bottom / self.sheet_height,\n                        'left': left / self.sheet_width,\n                        'right': right / self.sheet_width,\n                    }\n                elif mode == 'actual':\n                    box = {'top': top, 'bottom': bottom, 'left': left, 'right': right}\n\n                # Add to the collection.\n                if output == 'json':\n                    boxes['{0:d}x{1:d}'.format(row, column)] = box\n                    box['top'] = float(box['top'])\n                    box['bottom'] = float(box['bottom'])\n                    box['left'] = float(box['left'])\n                    box['right'] = float(box['right'])\n                else:\n                    boxes[(row, column)] = box\n\n        # Done.\n        if output == 'json':\n            return json.dumps(boxes)\n        return boxes"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef templatesCollector(text, open, close):\n    others = []\n    spans = [i for i in findBalanced(text, open, close)]\n    spanscopy = copy(spans)\n    for i in range(len(spans)):\n        start, end = spans[i]\n\n        o = text[start:end]\n        ol = o.lower()\n        if 'vaata|' in ol or 'wikitable' in ol:\n            spanscopy.remove(spans[i])\n            continue\n        others.append(o)\n    text = dropSpans(spanscopy, text)\n\n    return text, others", "response": "returns the text and the other templates that are in place"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef assert_legal_arguments(kwargs):\n    seen_layers = set()\n    for k, v in kwargs.items():\n        if k not in LEGAL_ARGUMENTS:\n            raise ValueError('Illegal argument <{0}>!'.format(k))\n        if k in AESTHETICS:\n            if v in seen_layers:\n                raise ValueError('Layer <{0}> mapped for more than a single aesthetic!'.format(v))\n            seen_layers.add(v)\n        if k in VALUES:\n            if not isinstance(v, six.string_types) and not isinstance(v, list):\n                raise ValueError('Value <{0}> must be either string or list'.format(k))\n            if isinstance(v, list):\n                if len(v) == 0:\n                    raise ValueError('Rules cannot be empty list')\n                for rule_matcher, rule_value in v:\n                    if not isinstance(rule_matcher, six.string_types) or not isinstance(rule_value, six.string_types):\n                        raise ValueError('Rule tuple elements must be strings')", "response": "Assert that PrettyPrinter arguments are correct."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_arguments(kwargs):\n    aesthetics = {}\n    values = {}\n    for aes in AESTHETICS:\n        if aes in kwargs:\n            aesthetics[aes] = kwargs[aes]\n            val_name = AES_VALUE_MAP[aes]\n            # map the user-provided CSS value or use the default\n            values[aes] = kwargs.get(val_name, DEFAULT_VALUE_MAP[aes])\n    return aesthetics, values", "response": "Function that parses the keyword arguments to get aesthetics and values from the PrettyPrinter output."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns ------- str The CSS.", "response": "def css(self):\n        \"\"\"Returns\n        -------\n        str\n            The CSS.\n        \"\"\"\n        css_list = [DEFAULT_MARK_CSS]\n        for aes in self.aesthetics:\n            css_list.extend(get_mark_css(aes, self.values[aes]))\n        #print('\\n'.join(css_list))\n        return '\\n'.join(css_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrendering the HTML. Parameters ---------- add_header: boolean (default: False) If True, add HTML5 header and footer. Returns ------- str The rendered HTML.", "response": "def render(self, text, add_header=False):\n        \"\"\"Render the HTML.\n\n        Parameters\n        ----------\n        add_header: boolean (default: False)\n            If True, add HTML5 header and footer.\n\n        Returns\n        -------\n        str\n            The rendered HTML.\n        \"\"\"\n\n        html = mark_text(text, self.aesthetics, self.rules)\n        html = html.replace('\\n', '<br/>')\n        if add_header:\n            html = '\\n'.join([HEADER, self.css, MIDDLE, html, FOOTER])\n        #print('\\n'.join((HEADER, self.css, MIDDLE, html, FOOTER)))\n        return html"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef train(self, nerdocs, mode_filename):\n\n        trainer = pycrfsuite.Trainer(algorithm=self.algorithm,\n                                     params={'c2': self.c2},\n                                     verbose=self.verbose)\n\n        for doc in nerdocs:\n            for snt in doc.sentences:\n                xseq = [t.feature_list() for t in snt]\n                yseq = [t.label for t in snt]\n                trainer.append(xseq, yseq)\n\n        trainer.train(mode_filename)", "response": "Train a CRF model using a list of nerdocs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tag(self, nerdoc):\n\n        labels = []\n        for snt in nerdoc.sentences:\n            xseq = [t.feature_list() for t in snt]\n            yseq = self.tagger.tag(xseq)\n            labels.append(yseq)\n        return labels", "response": "Tag the given document with the tagger."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef balancedSlicer(text, openDelim='[', closeDelim=']'):\n    openbr = 0\n    cur = 0\n    for char in text:\n        cur +=1\n        if char == openDelim:\n            openbr += 1\n        if char == closeDelim:\n            openbr -= 1\n        if openbr == 0:\n            break\n    return text[:cur], cur", "response": "Assuming that the text contains a properly balanced expression using\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a Wikipedia article to Text object.", "response": "def json_2_text(inp, out, verbose = False):\n    \"\"\"Convert a Wikipedia article to Text object.\n    Concatenates the sections in wikipedia file and rearranges other information so it\n    can be interpreted as a Text object.\n\n    Links and other elements with start and end positions are annotated\n    as layers.\n\n    Parameters\n    ----------\n    inp: directory of parsed et.wikipedia articles in json format\n\n    out: output directory of .txt files\n\n    verbose: if True, prints every article title and total count of converted files\n             if False prints every 50th count\n    Returns\n    -------\n    estnltk.text.Text\n        The Text object.\n    \"\"\"\n\n    for root, dirs, filenames in os.walk(inp):\n        for f in filenames:\n            log = codecs.open(os.path.join(root, f), 'r')\n            j_obj = json.load(log)\n            j_obj = json_format(j_obj)\n\n            #not needed, cause the json_format takes care of the right structuring\n            #text = Text(j_obj)\n\n            textWriter(j_obj, out, verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef concatenate_matches(a, b, text, name):\n    match = Match(a.start, b.end, text[a.start:b.end], name)\n    for k, v in a.matches.items():\n        match.matches[k] = v\n    for k, v in b.matches.items():\n        match.matches[k] = v\n    if a.name is not None:\n        aa = copy(a)\n        del aa[MATCHES]\n        match.matches[a.name] = aa\n    if b.name is not None:\n        bb = copy(b)\n        del bb[MATCHES]\n        match.matches[b.name] = bb\n    return match", "response": "Concatenate matches a and b.\n    All submatches will be copied to result."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef regex_from_markers(markers):\n    return re.compile('|'.join([re.escape(c) for c in markers]))", "response": "Given a string of characters construct a regular expression that matches them."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert(word):\n    if six.PY2:\n        if isinstance(word, unicode):\n            return word.encode('utf-8')\n        else:\n            return word.decode('utf-8').encode('utf-8') # make sure it is real utf8, otherwise complain\n    else: # ==> Py3\n        if isinstance(word, bytes):\n            return word.decode('utf-8') # bytes must be in utf8\n        return word", "response": "This method converts given word to UTF - 8 encoding and bytes type for the\n       SWIG wrapper."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef postprocess_result(morphresult, trim_phonetic, trim_compound):\n    word, analysis = morphresult\n    return {\n        'text': deconvert(word),\n        'analysis': [postprocess_analysis(a, trim_phonetic, trim_compound) for a in analysis]\n    }", "response": "Postprocess vabamorf wrapper output."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef trim_phonetics(root):\n    global phonetic_markers\n    global phonetic_regex\n    if root in phonetic_markers:\n        return root\n    else:\n        return phonetic_regex.sub('', root)", "response": "Function that trims phonetic markup from the root."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the root form without markers.", "response": "def get_root(root, phonetic, compound):\n    \"\"\"Get the root form without markers.\n\n    Parameters\n    ----------\n    root: str\n        The word root form.\n    phonetic: boolean\n        If True, add phonetic information to the root forms.\n    compound: boolean\n        if True, add compound word markers to root forms.\n    \"\"\"\n    global compound_regex\n    if not phonetic:\n        root = trim_phonetics(root)\n    if not compound:\n        root = trim_compounds(root)\n    return root"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_group_tokens(root):\n    global all_markers\n    if root in all_markers or root in ['-', '_']: # special case\n        return [[root]]\n    groups = []\n    for group in root.split('-'):\n        toks = [trim_phonetics(trim_compounds(tok)) for tok in group.split('_')]\n        groups.append(toks)\n    return groups", "response": "Function to extract tokens in hyphenated groups ( saunameheks - tallimeheks."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsynthesizes a single word based on given morphological attributes.", "response": "def synthesize(lemma, form, partofspeech='', hint='', guess=True, phonetic=False):\n    \"\"\"Synthesize a single word based on given morphological attributes.\n\n    Note that spellchecker does not respect pre-tokenized words and concatenates\n    token sequences such as \"New York\".\n\n    Parameters\n    ----------\n    lemma: str\n        The lemma of the word(s) to be synthesized.\n    form: str\n        The form of the word(s) to be synthesized.\n    partofspeech: str\n        Part-of-speech.\n    hint: str\n        Hint.\n    guess: boolean (default: True)\n        Use heuristics when synthesizing unknown words.\n    phonetic: boolean (default: False)\n        Add phonetic markup to synthesized words.\n\n    Returns\n    -------\n    list\n        List of synthesized words.\n    \"\"\"\n    return Vabamorf.instance().synthesize(lemma, form, partofspeech, hint, guess, phonetic)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef instance():\n        if not hasattr(Vabamorf, 'pid') or Vabamorf.pid != os.getpid():\n            Vabamorf.pid = os.getpid()\n            Vabamorf.morf = Vabamorf()\n        return Vabamorf.morf", "response": "Return an instance of PyVabamorf."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nperforming morphological analysis and disambiguation of given text.", "response": "def analyze(self, words, **kwargs):\n        \"\"\"Perform morphological analysis and disambiguation of given text.\n\n        Parameters\n        ----------\n        words: list of str or str\n            Either a list of pretokenized words or a string. In case of a string, it will be splitted using\n            default behaviour of string.split() function.\n        disambiguate: boolean (default: True)\n            Disambiguate the output and remove incosistent analysis.\n        guess: boolean (default: True)\n            Use guessing in case of unknown words\n        propername: boolean (default: True)\n            Perform additional analysis of proper names.\n        compound: boolean (default: True)\n            Add compound word markers to root forms.\n        phonetic: boolean (default: False)\n            Add phonetic information to root forms.\n\n        Returns\n        -------\n        list of (list of dict)\n            List of analysis for each word in input.\n        \"\"\"\n        # if input is a string, then tokenize it\n        if isinstance(words, six.string_types):\n            words = words.split()\n\n        # convert words to native strings\n        words = [convert(w) for w in words]\n\n        morfresults = self._morf.analyze(\n            vm.StringVector(words),\n            kwargs.get('disambiguate', True),\n            kwargs.get('guess', True),\n            True, # phonetic and compound information\n            kwargs.get('propername', True))\n        trim_phonetic = kwargs.get('phonetic', False)\n        trim_compound = kwargs.get('compound', True)\n\n        return [postprocess_result(mr, trim_phonetic, trim_compound) for mr in morfresults]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef disambiguate(self, words):\n        words = vm.SentenceAnalysis([as_wordanalysis(w) for w in words])\n        disambiguated = self._morf.disambiguate(words)\n        return [postprocess_result(mr, False, True) for mr in disambiguated]", "response": "Disambiguate previously analyzed words."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fix_spelling(self, words, join=True, joinstring=' '):\n\n        fixed_words = []\n        for word in self.spellcheck(words, suggestions=True):\n            if word['spelling']:\n                fixed_words.append(word['text'])\n            else:\n                suggestions = word['suggestions']\n                if len(suggestions) > 0:\n                    fixed_words.append(suggestions[0])\n                else:\n                    fixed_words.append(word['text'])\n        if join:\n            return joinstring.join(fixed_words)\n        else:\n            return fixed_words", "response": "Simple function for quickly correcting misspelled words."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsynthesizing a single word based on given morphological attributes.", "response": "def synthesize(self, lemma, form, partofspeech='', hint='', guess=True, phonetic=False):\n        \"\"\"Synthesize a single word based on given morphological attributes.\n\n        Note that spellchecker does not respect pre-tokenized words and concatenates\n        token sequences such as \"New York\".\n\n        Parameters\n        ----------\n        lemma: str\n            The lemma of the word(s) to be synthesized.\n        form: str\n            The form of the word(s) to be synthesized.\n        partofspeech: str\n            Part-of-speech.\n        hint: str\n            Hint.\n        guess: boolean (default: True)\n            Use heuristics when synthesizing unknown words.\n        phonetic: boolean (default: False)\n            Add phonetic markup to synthesized words.\n\n        Returns\n        -------\n        list\n            List of synthesized words.\n        \"\"\"\n        words = self._morf.synthesize(\n            convert(lemma.strip()),\n            convert(form.strip()),\n            convert(partofspeech.strip()),\n            convert(hint.strip()),\n            guess,\n            phonetic\n        )\n        return [deconvert(w) for w in words]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prepare_sentence(self, sentence):\n        # depending on how the morphological analysis was added, there may be\n        # phonetic markup. Remove it, if it exists.\n        for word in sentence:\n            for analysis in word[ANALYSIS]:\n                analysis[ROOT] = analysis[ROOT].replace('~', '')\n                analysis[ROOT] = re.sub('[?<\\]]([aioue\u00f6\u00e4\u00f5\u00fc])', '\\\\1', analysis[ROOT])\n        return json.dumps({WORDS: sentence})", "response": "Prepare the sentence for segment detection."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd clause indexes to already annotated sentence.", "response": "def annotate_indices(self, sentence):\n        \"\"\"Add clause indexes to already annotated sentence.\"\"\"\n        max_index = 0\n        max_depth = 1\n        stack_of_indexes = [ max_index ]\n        for token in sentence:\n            if CLAUSE_ANNOT not in token:\n                token[CLAUSE_IDX] = stack_of_indexes[-1]\n            else:\n                # Alustavad m\u00e4rgendused\n                for annotation in token[CLAUSE_ANNOT]:\n                    if annotation == \"KIILU_ALGUS\":\n                        # Liigume s\u00fcgavamale, alustame j\u00e4rgmist kiilu\n                        max_index += 1\n                        stack_of_indexes.append(max_index)\n                        if (len(stack_of_indexes) > max_depth):\n                            max_depth = len(stack_of_indexes)\n                token[CLAUSE_IDX] = stack_of_indexes[-1]\n                # L\u00f5petavad m\u00e4rgendused\n                for annotation in token[CLAUSE_ANNOT]:\n                    if annotation == \"KINDEL_PIIR\":\n                        # Liigume edasi samal tasandil, alustame j\u00e4rgmist osalauset\n                        max_index += 1\n                        stack_of_indexes[-1] = max_index\n                    elif annotation == \"KIILU_LOPP\":\n                        # Taandume s\u00fcgavusest, sulgeme \u00fche kiilu\n                        stack_of_indexes.pop()\n        return sentence"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction that renames and restructures clause information.", "response": "def rename_annotations(self, sentence):\n        \"\"\"Function that renames and restructures clause information.\"\"\"\n        annotations = []\n        for token in sentence:\n            data = {CLAUSE_IDX: token[CLAUSE_IDX]}\n            if CLAUSE_ANNOT in token:\n                if 'KINDEL_PIIR' in token[CLAUSE_ANNOT]:\n                    data[CLAUSE_ANNOTATION] = CLAUSE_BOUNDARY\n                elif 'KIILU_ALGUS' in token[CLAUSE_ANNOT]:\n                    data[CLAUSE_ANNOTATION] = EMBEDDED_CLAUSE_START\n                elif 'KIILU_LOPP' in token[CLAUSE_ANNOT]:\n                    data[CLAUSE_ANNOTATION] = EMBEDDED_CLAUSE_END\n            annotations.append(data)\n        return annotations"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsplit the text into smaller texts.", "response": "def split_Text( text, file_name, verbose = True ):\n    ''' Tokenizes the *text* (from *file_name*) into sentences, and if the number of \n        sentences exceeds *max_sentences*, splits the text into smaller texts.\n\n        Returns a list containing the original text (if no splitting was required),\n        or a list containing results of the splitting (smaller texts);\n    '''\n    if verbose:\n       print('  processing '+file_name+' ... ', end=\"\" )\n    # Tokenize text into sentences\n    start = timer()\n    text = text.tokenize_sentences()\n    all_sentences = len(text[SENTENCES])\n    end = timer()\n    if verbose:\n       print('  (tok time: '+format_time( end-start )+')', end=\"\" )\n    if all_sentences > max_sentences:\n       # Acquire spans of length *max_sentences* from the text\n       start = timer()\n       i = 0\n       spans = []\n       len_total = 0\n       while i < all_sentences:\n            startSent = text[SENTENCES][i]\n            endSent   = text[SENTENCES][min(i+(max_sentences-1), all_sentences-1)]\n            span = (startSent[START], endSent[END])\n            len_total += (span[1]-span[0])\n            spans.append(span)\n            i += max_sentences\n       # Divide the text into spans\n       text_spans = text.texts_from_spans(spans)\n       assert len(text.text) >= len_total, '(!) Total spans_len must be =< than text_len: '+str(len_total)+'/'+str(len(text.text))\n       new_texts  = []\n       for i, small_text in enumerate( text_spans ):\n           newText = Text( small_text )\n           for key in text.keys():\n               if key != TEXT and key != SENTENCES and key != PARAGRAPHS:\n                  newText[key] = text[key]\n           newText['_text_split_id']     = i\n           newText['_text_split_origin'] = str(spans[i])  #  Convert it to string; Otherwise, split_by(*) may mistakenly consider \n                                                          #  it a layer and may run into error while trying to split it;\n           newText['_text_split_file']   = file_name\n           #print( json.dumps(newText) )\n           new_texts.append( newText )\n       end = timer()\n       if verbose:\n           print('  (split time: '+format_time( end-start )+')', end=\"\" )\n           print('  (sents: '+str(all_sentences)+', new_texts:'+str(len(new_texts))+')', end=\"\")\n           print()\n       return new_texts\n    else:\n       if verbose:\n           print('  (sents: '+str(all_sentences)+', no_split)', end=\" \\n\")\n       return [text]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_Text_into_file( text, old_file_name, out_dir, suffix='__split', verbose=True ):\n    ''' Based on *old_file_name*, *suffix* and *out_dir*, constructs a new file name and \n        writes *text* (in the ascii normalised JSON format) into the new file.\n    ''' \n    name = os.path.basename( old_file_name )\n    if '.' in name:\n       new_name = re.sub('\\.([^.]+)$', suffix+'.\\\\1', name)\n    else:\n       new_name = name + suffix\n    new_path = os.path.join( out_dir, new_name )\n    start = timer()\n    #write_document( text, new_path )  # <--- this leaves indent=2 - takes too much extra space ...\n    o_f = codecs.open( new_path, mode='wb', encoding='ascii' )\n    o_f.write( json.dumps( text ) )\n    o_f.close()\n    end = timer()\n    timestamp = format_time( end-start )\n    if verbose:\n       print('  ==>  '+new_path+' (file writing time: '+timestamp+')' )", "response": "Writes text into a new file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_tei_corpora(root, prefix='', suffix='.xml', target=['artikkel'], encoding=None):\n    documents = []\n    for fnm in get_filenames(root, prefix, suffix):\n        path = os.path.join(root, fnm)\n        docs = parse_tei_corpus(path, target, encoding)\n        for doc in docs:\n            doc[FILE] = fnm\n        documents.extend(docs)\n    return documents", "response": "Parse TEI style XML files and return a list of Text objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse TEI style XML file into a list of text documents.", "response": "def parse_tei_corpus(path, target=['artikkel'], encoding=None):\n    \"\"\"Parse documents from a TEI style XML file.\n    \n    Parameters\n    ----------\n    path: str\n        The path of the XML file.\n    target: list of str\n        List of <div> types, that are considered documents in the XML files (default: [\"artikkel\"]).\n    encoding: str\n        Encoding to be used for decoding the content of the XML file. If not specified (default), \n        then no separate decoding step is applied.\n\n    Returns\n    -------\n    list of esnltk.text.Text\n    \"\"\"\n    with open(path, 'rb') as f:\n        html_doc = f.read()\n    if encoding:\n        html_doc = html_doc.decode( encoding )\n    soup = BeautifulSoup(html_doc, 'html5lib')\n    title = soup.find_all('title')[0].string\n    \n    documents = []\n    for div1 in soup.find_all('div1'):\n        documents.extend(parse_div(div1, dict(), target))\n    return tokenize_documents(documents)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_div(soup, metadata, target):\n    documents = []\n    div_type = soup.get('type', None)\n    div_title = list(soup.children)[0].string.strip()\n    \n    if div_type in target:\n        div_authors = soup.find_all('author')\n        document = {\n            'type': div_type,\n            'title': div_title,\n            'paragraphs': parse_paragraphs(soup)\n        }\n        # add author, if it exists\n        if len(div_authors) > 0:\n            div_author = div_authors[0].text.strip()\n            document['author'] = div_author\n        # add collected metadata\n        for k, v in metadata.items():\n            document[k] = v\n        documents.append(document)\n    else:\n        metadata[div_type] = div_title\n\n        # recurse subdivs\n        subdiv_name = get_subdiv(soup.name)\n        subdivs = []\n        if subdiv_name is not None:\n            subdivs = soup.find_all(subdiv_name)\n        if len(subdivs) > 0:\n            for subdiv in subdivs:\n                documents.extend(parse_div(subdiv, deepcopy(metadata), target))\n    return documents", "response": "Parses a div from the XML file and returns a list of dicts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing sentences and paragraphs in the section.", "response": "def parse_paragraphs(soup):\n    \"\"\"Parse sentences and paragraphs in the section.\n    \n    Parameters\n    ----------\n    soup: bs4.BeautifulSoup\n        The parsed XML data.\n        \n    Returns\n    -------\n    list of (list of str)\n        List of paragraphs given as list of sentences.\n    \"\"\"\n    paragraphs = []\n    for para in soup.find_all('p'):\n        sentences = []\n        for sent in para.find_all('s'):\n            sentence = sent.text.strip()\n            if len(sentence) > 0:\n                sentences.append(sentence)\n        if len(sentences) > 0:\n            paragraphs.append({'sentences': sentences})\n    return paragraphs"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert the imported documents to Text instances.", "response": "def tokenize_documents(docs):\n    \"\"\"Convert the imported documents to :py:class:'~estnltk.text.Text' instances.\"\"\"\n    sep = '\\n\\n'\n    texts = []\n    for doc in docs:\n        text = '\\n\\n'.join(['\\n'.join(para[SENTENCES]) for para in doc[PARAGRAPHS]])\n        doc[TEXT] = text\n        del doc[PARAGRAPHS]\n        texts.append(Text(doc))\n    return texts"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfunctions for training the default NER model.", "response": "def train_default_model():\n    \"\"\"Function for training the default NER model.\n\n    NB! It overwrites the default model, so do not use it unless\n    you know what are you doing.\n\n    The training data is in file estnltk/corpora/estner.json.bz2 .\n    The resulting model will be saved to estnltk/estner/models/default.bin\n    \"\"\"\n    docs = read_json_corpus(DEFAULT_NER_DATASET)\n    trainer = NerTrainer(default_nersettings)\n    trainer.train(docs, DEFAULT_NER_MODEL_DIR)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process_line(self, line):\r\n        assert isinstance(line, str)\r\n        try:\r\n            self._process.stdin.write(as_binary(line))\r\n            self._process.stdin.write(as_binary('\\n'))\r\n            self._process.stdin.flush()\r\n            result = as_unicode(self._process.stdout.readline())\r\n            if result == '':\r\n                stderr = as_unicode(self._process.stderr.read())\r\n                raise Exception('EOF encountered while reading stream. Stderr is {0}.'.format(stderr))\r\n            return result\r\n        except Exception:\r\n            self._process.terminate()\r\n            raise", "response": "Process a line of data and return the line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the offsets in the WordNet file for every synset index.", "response": "def _get_synset_offsets(synset_idxes):\n    \"\"\"Returs pointer offset in the WordNet file for every synset index.\n\n    Notes\n    -----\n    Internal function. Do not call directly.\n    Preserves order -- for [x,y,z] returns [offset(x),offset(y),offset(z)].\n\n    Parameters\n    ----------\n    synset_idxes : list of ints\n      Lists synset IDs, which need offset.\n      \n    Returns\n    -------\n    list of ints\n      Lists pointer offsets in Wordnet file.\n\n\n    \"\"\"\n    offsets = {}\n    current_seeked_offset_idx = 0\n\n    ordered_synset_idxes = sorted(synset_idxes)\n\n    with codecs.open(_SOI,'rb', 'utf-8') as fin:\n        for line in fin:\n            split_line = line.split(':')\n          \n            while current_seeked_offset_idx < len(ordered_synset_idxes) and split_line[0] == str(ordered_synset_idxes[current_seeked_offset_idx]):\n                # Looping on single line entries in case synset_indexes contains duplicates.\n                offsets[synset_idxes[current_seeked_offset_idx]] = int(split_line[1])\n                current_seeked_offset_idx += 1\n            if current_seeked_offset_idx >= len(synset_idxes):\n                break\n    return [offsets[synset_idx] for synset_idx in synset_idxes]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a list of offsets in the WordNet file parses each synset object for every offset and stores it in the global dictionary.", "response": "def _get_synsets(synset_offsets):\n    \"\"\"Given synset offsets in the WordNet file, parses synset object for every offset.\n\n    Notes\n    -----\n    Internal function. Do not call directly.\n    Stores every parsed synset into global synset dictionary under two keys:\n      synset's name lemma.pos.sense_no and synset's id (unique integer).\n\n    Parameters\n    ----------\n    synset_offsets : list of ints\n      Lists pointer offsets from which synset objects will be parsed.\n      \n    Returns\n    -------\n    list of Synsets\n      Lists synset objects which synset_offsets point to.\n\n    \"\"\"\n    global parser\n    if parser is None:\n        parser = Parser(_WN_FILE)\n    synsets = []\n\n    for offset in synset_offsets:\n        raw_synset = parser.parse_synset(offset)\n        synset = Synset(raw_synset)\n\n        SYNSETS_DICT[_get_key_from_raw_synset(raw_synset)] = synset\n        SYNSETS_DICT[synset.id] = synset\n\n        synsets.append(synset)\n\n    return synsets"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_key_from_raw_synset(raw_synset):\n    pos = raw_synset.pos\n    literal = raw_synset.variants[0].literal\n    sense = \"%02d\"%raw_synset.variants[0].sense\n    return '.'.join([literal,pos,sense])", "response": "Derives synset key from the provided eurown. py Synset object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef synset(synset_key):\n\n    if synset_key in SYNSETS_DICT:\n        return SYNSETS_DICT[synset_key]\n\n    def _get_synset_idx(synset_key):\n        \"\"\"Returns synset index for the provided key.\n\n        Note\n        ----\n          Internal function. Do not call directly.\n\n        \"\"\"\n        with codecs.open(_SENSE_FILE,'rb', 'utf-8') as fin:\n            for line in fin:\n                split_line = line.split(':')\n                if split_line[0] == synset_key:\n                    return int(split_line[1].strip())\n        return None\n\n    synset_idx = _get_synset_idx(synset_key)\n\n    if synset_idx == None:\n        return None\n\n    synset_offset = _get_synset_offsets([synset_idx])\n    synset = _get_synsets(synset_offset)\n\n    return synset[0]", "response": "Returns a synset object with the provided key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef synsets(lemma,pos=None):\n\n    def _get_synset_idxes(lemma,pos):\n        line_prefix_regexp = \"%s:%s:(.*)\"%(lemma,pos if pos else \"\\w+\") \n        line_prefix = re.compile(line_prefix_regexp)\n\n        idxes = []\n\n        with codecs.open(_LIT_POS_FILE,'rb', 'utf-8') as fin:\n            for line in fin:\n                result = line_prefix.match(line)\n                if result:\n                    res_indices = [int(x) for x in result.group(1).split(' ')]\n                    idxes.extend(res_indices)\n                    \n        LEM_POS_2_SS_IDX[lemma][pos].extend(idxes)\n        return sorted(idxes)\n\n    synset_idxes = None\n\n    if lemma in LEM_POS_2_SS_IDX:\n        if pos in LEM_POS_2_SS_IDX[lemma]:\n            synset_idxes = LEM_POS_2_SS_IDX[lemma][pos]\n        else:\n            synset_idxes = [idx for pos in LEM_POS_2_SS_IDX[lemma] for idx in LEM_POS_2_SS_IDX[lemma][pos]]\n    if not synset_idxes:\n        synset_idxes = _get_synset_idxes(lemma,pos)\n\n    if len(synset_idxes) == 0:\n        return []\n\n    stored_synsets = [SYNSETS_DICT[synset_idxes[i]] for i in range(len(synset_idxes)) if synset_idxes[i] in SYNSETS_DICT]\n    unstored_synset_idxes = [synset_idxes[i] for i in range(len(synset_idxes)) if synset_idxes[i] not in SYNSETS_DICT]\n\n    synset_offsets = _get_synset_offsets(unstored_synset_idxes)\n    synsets = _get_synsets(synset_offsets)\n    \n    return stored_synsets + synsets", "response": "Returns all synsets which have the given lemma and fixed pos."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning all the synsets which have the provided pos.", "response": "def all_synsets(pos=None):\n    \"\"\"Return all the synsets which have the provided pos.\n\n    Notes\n    -----\n    Returns thousands or tens of thousands of synsets - first time will take significant time.\n    Useful for initializing synsets as each returned synset is also stored in a global dictionary for fast retrieval the next time.\n\n    Parameters\n    ----------\n    pos : str\n      Part-of-speech of the sought synsets. Sensible alternatives are wn.ADJ, wn.ADV, wn.VERB, wn.NOUN and `*`.\n      If pos == `*`, all the synsets are retrieved and initialized for fast retrieval the next time.\n      \n    Returns\n    -------\n    list of Synsets\n      Lists the Synsets which have `pos` as part-of-speech.\n      Empty list, if `pos` not in [wn.ADJ, wn.ADV, wn.VERB, wn.NOUN, `*`].\n\n    \"\"\"\n    def _get_unique_synset_idxes(pos):\n        idxes = []\n\n        with codecs.open(_LIT_POS_FILE,'rb', 'utf-8') as fin:\n            if pos == None:\n                for line in fin:\n                  split_line = line.strip().split(':')\n                  idxes.extend([int(x) for x in split_line[2].split()])\n            else:\n                for line in fin:\n                    split_line = line.strip().split(':')\n                    if split_line[1] == pos:\n                        idxes.extend([int(x) for x in split_line[2].split()])\n        idxes = list(set(idxes))\n        idxes.sort()\n        return idxes\n\n    if pos in LOADED_POS:\n        return [SYNSETS_DICT[idx] for lemma in LEM_POS_2_SS_IDX for idx in LEM_POS_2_SS_IDX[lemma][pos]]\n    else:\n        synset_idxes = _get_unique_synset_idxes(pos)\n\n        if len(synset_idxes) == 0:\n            return []\n\n        stored_synsets = [SYNSETS_DICT[synset_idxes[i]] for i in range(len(synset_idxes)) if synset_idxes[i] in SYNSETS_DICT]\n        unstored_synset_idxes = [synset_idxes[i] for i in range(len(synset_idxes)) if synset_idxes[i] not in SYNSETS_DICT]\n        \n        synset_offsets = _get_synset_offsets(unstored_synset_idxes)\n        synsets = _get_synsets(synset_offsets)\n\n        for synset in synsets:\n            for variant in synset.get_variants():\n                LEM_POS_2_SS_IDX[variant.literal][synset.pos].append(synset.id)\n\n        LOADED_POS.add(pos)\n\n        return stored_synsets + synsets"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the Lemma object with the given key.", "response": "def lemma(lemma_key):\n    \"\"\"Returns the Lemma object with the given key.\n\n    Parameters\n    ----------\n    lemma_key : str\n      Key of the returned lemma.\n\n    Returns\n    -------\n    Lemma\n      Lemma matching the `lemma_key`.\n\n    \"\"\"\n    if lemma_key in LEMMAS_DICT:\n        return LEMMAS_DICT[lemma_key]\n    split_lemma_key = lemma_key.split('.')\n\n    synset_key = '.'.join(split_lemma_key[:3])\n    lemma_literal = split_lemma_key[3]\n\n    lemma_obj = Lemma(synset_key,lemma_literal)\n    LEMMAS_DICT[lemma_key] = lemma_obj\n    return lemma_obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all the Lemmas of which name is lemma and which have pos as part of speech.", "response": "def lemmas(lemma,pos=None):\n    \"\"\"Returns all the Lemma objects of which name is `lemma` and which have `pos` as part\n    of speech.\n\n    Parameters\n    ----------\n    lemma : str\n      Literal of the sought Lemma objects.\n    pos : str, optional\n      Part of speech of the sought Lemma objects. If None, matches any part of speech.\n      Defaults to None\n      \n    Returns\n    -------\n    list of Lemmas\n      Lists all the matched Lemmas.\n    \"\"\"\n    lemma = lemma.lower()\n    return [lemma_obj\n        for synset in synsets(lemma,pos)\n        for lemma_obj in synset.lemmas()\n        if lemma_obj.name.lower() == lemma]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind all the hypernyms of the synset transitively. Notes ----- Internal method. Do not call directly. Parameters ---------- hypernyms : set of Synsets An set of hypernyms met so far. Returns ------- set of Synsets Returns the input set.", "response": "def _recursive_hypernyms(self, hypernyms):   \n        \"\"\"Finds all the hypernyms of the synset transitively.\n\n        Notes\n        -----\n          Internal method. Do not call directly.\n\n        Parameters\n        ----------\n          hypernyms : set of Synsets\n        An set of hypernyms met so far.\n\n        Returns\n        -------\n          set of Synsets\n        Returns the input set.\n\n        \"\"\"\n        hypernyms |= set(self.hypernyms())\n\n        for synset in self.hypernyms():\n            hypernyms |= synset._recursive_hypernyms(hypernyms)\n        return hypernyms"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding minimum path length from the root. Returns 0 if no path length is found.", "response": "def _min_depth(self):\n        \"\"\"Finds minimum path length from the root.\n\n        Notes\n        -----\n          Internal method. Do not call directly.\n\n        Returns\n        -------\n          int\n        Minimum path length from the root.\n\n        \"\"\"\n        if \"min_depth\" in self.__dict__:\n            return self.__dict__[\"min_depth\"]\n\n        min_depth = 0\n        hypernyms = self.hypernyms()\n        if hypernyms:\n            min_depth = 1 + min(h._min_depth() for h in hypernyms)\n        self.__dict__[\"min_depth\"] = min_depth\n\n        return min_depth"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_related_synsets(self,relation):\n        results = []\n\n        for relation_candidate in self._raw_synset.internalLinks:\n            if relation_candidate.name == relation:\n                linked_synset = synset(_get_key_from_raw_synset(relation_candidate.target_concept))\n                relation_candidate.target_concept = linked_synset._raw_synset\n                results.append(linked_synset)\n        return results", "response": "Retrieves all the synsets which are related by given relation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind all the ancestors of the synset using the given relation.", "response": "def closure(self, relation, depth=float('inf')):   \n        \"\"\"Finds all the ancestors of the synset using provided relation.\n\n        Parameters\n        ----------\n          relation : str\n        Name of the relation which is recursively used to fetch the ancestors.\n\n        Returns\n        -------\n          list of Synsets\n        Returns the ancestors of the synset via given relations.\n\n        \"\"\"\n    \n        ancestors = []\n        unvisited_ancestors = [(synset,1) for synset in self.get_related_synsets(relation)]\n\n        while len(unvisited_ancestors) > 0:\n            ancestor_depth = unvisited_ancestors.pop()\n            if ancestor_depth[1] > depth:\n                continue    \n            unvisited_ancestors.extend([(synset,ancestor_depth[1]+1) for synset in ancestor_depth[0].get_related_synsets(relation)])\n            ancestors.append(ancestor_depth[0])\n\n        return list(set(ancestors))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef root_hypernyms(self):\n        visited = set()\n        hypernyms_next_level = set(self.hypernyms())\n        current_hypernyms = set(hypernyms_next_level)\n\n        while len(hypernyms_next_level) > 0:\n            current_hypernyms = set(hypernyms_next_level)\n            hypernyms_next_level = set()\n          \n            for synset in current_hypernyms:\n                if synset in visited:\n                    continue\n                visited.add(synset)\n                hypernyms_next_level |= set(synset.hypernyms())\n\n        return list(current_hypernyms)", "response": "Retrieves all the root hypernyms."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates Leacock and Chodorow s similarity between two synsets.", "response": "def lch_similarity(self, synset):\n        \"\"\"Calculates Leacock and Chodorow's similarity between the two synsets.\n\n        Notes\n        -----\n          Similarity is calculated using the formula -log( (dist(synset1,synset2)+1) / (2*maximum taxonomy depth) ).\n\n        Parameters\n        ----------\n          synset : Synset\n        Synset from which the similarity is calculated.    \n\n        Returns\n        -------\n          float\n        Leacock and Chodorow's from `synset`.\n        None, if synsets are not connected via hypernymy/hyponymy relations. Obvious, if part-of-speeches don't match.\n        \n        \"\"\"\n\n        if self._raw_synset.pos != synset._raw_synset.pos:\n            return None\n\n        depth = MAX_TAXONOMY_DEPTHS[self._raw_synset.pos] \n\n        distance = self._shortest_path_distance(synset)      \n\n        if distance >= 0: \n            return -math.log((distance + 1) / (2.0 * depth)) \n        else: \n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wup_similarity(self, target_synset):\n        lchs = self.lowest_common_hypernyms(target_synset)\n        lcs_depth = lchs[0]._min_depth() if lchs and len(lchs) else None\n        self_depth = self._min_depth() \n        other_depth = target_synset._min_depth()\n        if lcs_depth is None or self_depth is None or other_depth is None: \n            return None \n\n        return (2.0 * lcs_depth) / (self_depth + other_depth)", "response": "Calculates the Wu and Palmer s similarity between two synsets."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the definition of the synset as a new - line separated concatenated string from all its variants", "response": "def definition(self):\n        \"\"\"Returns the definition of the synset.\n        \n        Returns\n        -------\n          str\n        Definition of the synset as a new-line separated concatenated string from all its variants' definitions.\n        \n        \"\"\"\n        return '\\n'.join([variant.gloss for variant in self._raw_synset.variants if variant.gloss])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef examples(self):\n        examples = []\n        for example in [variant.examples for variant in self._raw_synset.variants if len(variant.examples)]:\n            examples.extend(example)\n        return examples", "response": "Returns the examples of the synset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the synset s lemmas as Lemmas as strings.", "response": "def lemmas(self):\n        \"\"\"Returns the synset's lemmas/variants' literal represantions.\n        \n        Returns\n        -------\n          list of Lemmas\n        List of its variations' literals as Lemma objects.\n        \n        \"\"\"\n        return [lemma(\"%s.%s\"%(self.name,variant.literal)) for variant in self._raw_synset.variants]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lowest_common_hypernyms(self,target_synset):\n        self_hypernyms = self._recursive_hypernyms(set())\n        other_hypernyms = target_synset._recursive_hypernyms(set())\n        common_hypernyms = self_hypernyms.intersection(other_hypernyms)\n        \n        annot_common_hypernyms = [(hypernym, hypernym._min_depth()) for hypernym in common_hypernyms]\n       \n        annot_common_hypernyms.sort(key = lambda annot_hypernym: annot_hypernym[1],reverse=True)\n       \n        max_depth = annot_common_hypernyms[0][1] if len(annot_common_hypernyms) > 0 else None\n        \n        if max_depth != None:\n            return [annot_common_hypernym[0] for annot_common_hypernym in annot_common_hypernyms if annot_common_hypernym[1] == max_depth]\n        else:\n            return None", "response": "Returns the lowest common hypernyms of the synset and the target synset."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a synset in which the given lemma belongs to.", "response": "def synset(self):\n        \"\"\"Returns synset into which the given lemma belongs to.\n        \n        Returns\n        -------\n          Synset\n        Synset into which the given lemma belongs to.\n        \n        \"\"\"    \n        return synset('%s.%s.%s.%s'%(self.synset_literal,self.synset_pos,self.synset_sense,self.literal))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_vm_json_to_mrf( vabamorf_json ):\n    ''' Converts from vabamorf's JSON output, given as dict, into pre-syntactic mrf\n        format, given as a list of lines, as in the output of etmrf. \n        The aimed format looks something like this:\n        <s>\n        Kolmandaks\n            kolmandaks+0 //_D_  //\n            kolmas+ks //_O_ sg tr //\n        kihutas\n            kihuta+s //_V_ s //\n        end\n            end+0 //_Y_ ? //\n            ise+0 //_P_ sg p //\n        soomlane\n            soomlane+0 //_S_ sg n //\n        </s>\n    '''\n    if not isinstance( vabamorf_json, dict ):\n       raise Exception(' Expected dict as an input argument! ')\n    json_sentences = []\n    # 1) flatten paragraphs\n    if 'paragraphs' in vabamorf_json:\n       for pr in vabamorf_json['paragraphs']:\n           if 'sentences' in pr:\n              for sent in pr['sentences']:\n                 json_sentences.append( sent )\n    # 2) flatten sentences\n    elif 'sentences' in vabamorf_json:\n       for sent in vabamorf_json['sentences']:\n           json_sentences.append( sent )\n    # 3) Iterate over sentences and perform conversion\n    results = []\n    for sentJson in json_sentences:\n        results.append('<s>')\n        for wordJson in sentJson['words']:\n            if wordJson['text'] == '<s>' or wordJson['text'] == '</s>':\n               continue\n            wordStr = wordJson['text']\n            # Escape double quotation marks\n            wordStr = _esc_double_quotes( wordStr )\n            results.append( wordStr )\n            for analysisJson in wordJson['analysis']:\n               root   = analysisJson['root']\n               root   = _esc_double_quotes( root )\n               #   NB! ending=\"0\" erineb ending=\"\"-st:\n               #     1) eestlane (ending=\"0\");\n               #     2) Rio (ending=\"\") de (ending=\"\") Jaineros;\n               ending = analysisJson[ENDING]\n               pos    = analysisJson['partofspeech']\n               clitic = analysisJson['clitic']\n               form   = analysisJson['form']\n               if pos == 'Z':\n                  results.append( ''.join(['    ',root,' //_Z_ //']) )\n               else:\n                  results.append( ''.join(['    ',root,'+',ending,clitic,' //', '_',pos,'_ ',form,' //']) )\n            if 'analysis' not in wordJson:\n               results.append( '    '+'####' )\n        results.append('</s>')\n    return results", "response": "Converts from JSON output into pre - syntactic mrf format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a Text object into a list of pre - syntactic mrf format given as a list of lines.", "response": "def convert_Text_to_mrf( text ):\n    ''' Converts from Text object into pre-syntactic mrf format, given as a list of \n        lines, as in the output of etmrf.\n        *) If the input Text has already been morphologically analysed, uses the existing\n            analysis;\n        *) If the input has not been analysed, performs the analysis with required settings:\n            word quessing is turned on, proper-name analyses are turned off;\n    '''\n    from estnltk.text import Text\n    if not isinstance( text, Text ):\n       raise Exception(' Expected estnltk\\'s Text as an input argument! ')\n    if not text.is_tagged( ANALYSIS ):\n       # If morphological analysis has not been performed yet, set the right arguments and \n       # perform the analysis \n       kwargs = text.get_kwargs()\n       kwargs['vabamorf']     = True\n       kwargs['guess']        = True\n       kwargs['propername']   = False\n       kwargs['disambiguate'] = False\n       text.__kwargs = kwargs\n       text = text.tag_analysis()\n    # Iterate over sentences and perform conversion\n    results = []\n    for sentence in text.divide( layer=WORDS, by=SENTENCES ):\n       results.append('<s>')\n       for i in range(len(sentence)):\n           wordJson = sentence[i]\n           wordStr  = wordJson[TEXT]\n           # Escape double quotation marks\n           wordStr = _esc_double_quotes( wordStr )\n           results.append( wordStr )\n           for analysisJson in wordJson[ANALYSIS]:\n               root   = analysisJson[ROOT]\n               root   = _esc_double_quotes( root )\n               #   NB! ending=\"0\" erineb ending=\"\"-st:\n               #     1) eestlane (ending=\"0\");\n               #     2) Rio (ending=\"\") de (ending=\"\") Jaineros;\n               ending = analysisJson[ENDING]\n               pos    = analysisJson[POSTAG]\n               clitic = analysisJson[CLITIC]\n               form   = analysisJson[FORM]\n               if pos == 'Z':\n                  results.append( ''.join(['    ',root,' //_Z_ //']) )\n               else:\n                  results.append( ''.join(['    ',root,'+',ending,clitic,' //', '_',pos,'_ ',form,' //']) )\n           if ANALYSIS not in wordJson:\n               results.append( '    '+'####' )\n       results.append('</s>')\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading rules that can be used to convert from Filosoft s mrf format to syntactic analyzer s format. Returns a dict containing rules that can be used to convert from Filosoft s mrf format to syntactic analyzer s format.", "response": "def load_fs_mrf_to_syntax_mrf_translation_rules( rulesFile ):\n    ''' Loads rules that can be used to convert from Filosoft's mrf format to \n        syntactic analyzer's format. Returns a dict containing rules.\n\n        Expects that each line in the input file contains a single rule, and that \n        different parts of the rule separated by @ symbols, e.g.\n        \n            1@_S_ ?@Substantiiv apellatiiv@_S_ com @Noun common@Nc@NCSX@kesk-\n            32@_H_ ?@Substantiiv prooprium@_S_ prop @Noun proper@Np@NPCSX@Kesk-\n            313@_A_@Adjektiiv positiiv@_A_ pos@Adjective positive@A-p@ASX@salkus\n        \n        Only 2nd element and 4th element are extracted from each line; 2nd element\n        will be the key of the dict entry, and 4th element will be added to the \n        value of the dict entry (the value is a list of strings);\n\n        A list is used for storing values because one Filosoft's analysis could\n        be mapped to multiple syntactic analyzer's analyses;\n        \n        Lines that have \u00a4 in the beginning of the line will be skipped;\n      \n    '''\n    rules = {}\n    in_f = codecs.open(rulesFile, mode='r', encoding='utf-8')\n    for line in in_f:\n        line = line.rstrip()\n        if line.startswith('\u00a4'):\n           continue\n        parts = line.split('@')\n        if len(parts) < 4:\n           raise Exception(' Unexpected format of the line: ', line)\n        if parts[1] not in rules:\n           rules[parts[1]] = []\n        rules[parts[1]].append( parts[3] )\n    in_f.close()\n    return rules"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _convert_punctuation( line ):\n    ''' Converts given analysis line if it describes punctuation; Uses the set \n        of predefined punctuation conversion rules from _punctConversions;\n        \n        _punctConversions should be a list of lists, where each outer list stands \n        for a single conversion rule and inner list contains a pair of elements:\n        first is the regexp pattern and the second is the replacement, used in\n           re.sub( pattern, replacement, line )\n        \n        Returns the converted line (same as input, if no conversion was \n        performed);\n    ''' \n    for [pattern, replacement] in _punctConversions:\n        lastline = line\n        line = re.sub(pattern, replacement, line)\n        if lastline != line:\n            break\n    return line", "response": "Converts given analysis line if it describes punctuation."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert given lines from Filosoft s mrf format to syntactic analyzer s equivalent MRF format.", "response": "def convert_mrf_to_syntax_mrf( mrf_lines, conversion_rules ):\n    ''' Converts given lines from Filosoft's mrf format to syntactic analyzer's \n        format, using the morph-category conversion rules from conversion_rules,\n        and punctuation via method _convert_punctuation();\n        As a result of conversion, the input list  mrf_lines  will be modified,\n        and also returned after a successful conversion;\n        \n        Morph-category conversion rules should be loaded via method \n            load_fs_mrf_to_syntax_mrf_translation_rules( rulesFile ),\n        usually from a file named 'tmorftrtabel.txt';\n        \n        Note that the resulting list of lines likely has more lines than the \n        original list had, because the conversion often requires that the \n        original Filosoft's analysis is expanded into multiple analyses \n        suitable for the syntactic analyzer;\n    ''' \n    i = 0\n    while ( i < len(mrf_lines) ):\n        line = mrf_lines[i]\n        if line.startswith('  '):  # only consider lines of analysis \n            # 1) Convert punctuation\n            if _punctOrAbbrev.search(line):\n                mrf_lines[i] = _convert_punctuation( line )\n                if '_Y_' not in line:\n                    i += 1\n                    continue\n            # 2) Convert morphological analyses that have a form specified\n            withFormMatch = _morfWithForm.search(line)\n            if withFormMatch:\n                root    = withFormMatch.group(1)\n                pos     = withFormMatch.group(2)\n                formStr = withFormMatch.group(3)\n                forms   = formStr.split(',')\n                all_new_lines = []\n                for form in forms:\n                    morphKey = pos+' '+form.strip()\n                    if morphKey in conversion_rules:\n                        newlines = [ '    '+root+' //'+_esc_que_mark(r)+' //' for r in conversion_rules[morphKey] ]\n                        all_new_lines.extend( newlines )\n                if all_new_lines:\n                    del mrf_lines[i] \n                    for newline in all_new_lines:\n                        mrf_lines.insert(i, newline)\n                    i += len(newlines)\n                    continue\n            else:\n                withoutFormMatch = _morfWithoutForm.search(line)\n                if withoutFormMatch:\n                    # 3) Convert morphological analyses that have only POS specified\n                    root = withoutFormMatch.group(1)\n                    pos  = withoutFormMatch.group(2)\n                    morphKey = pos\n                    all_new_lines = []\n                    if morphKey in conversion_rules:\n                        newlines = [ '    '+root+' //'+_esc_que_mark(r)+' //' for r in conversion_rules[morphKey] ]\n                        all_new_lines.extend( newlines )\n                    if all_new_lines:\n                        del mrf_lines[i] \n                        for newline in all_new_lines:\n                            mrf_lines.insert(i, newline)\n                        i += len(newlines)\n                        continue\n        i += 1\n    return mrf_lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts pronouns from Filosoft s mrf to", "response": "def convert_pronouns( mrf_lines ):\n    ''' Converts pronouns (analysis lines with '_P_') from Filosoft's mrf to \n        syntactic analyzer's mrf format;\n        Uses the set of predefined pronoun conversion rules from _pronConversions;\n        \n        _pronConversions should be a list of lists, where each outer list stands \n        for a single conversion rule and inner list contains a pair of elements:\n        first is the regexp pattern and the second is the replacement, used in\n           re.sub( pattern, replacement, line )\n        \n        Returns the input mrf list, with the lines converted from one format\n        to another;\n    ''' \n    i = 0\n    while ( i < len(mrf_lines) ):\n        line = mrf_lines[i]\n        if '_P_' in line:  # only consider lines containing pronoun analyses\n           for [pattern, replacement] in _pronConversions:\n               lastline = line\n               line = re.sub(pattern, replacement, line)\n               if lastline != line:\n                  mrf_lines[i] = line\n                  break\n        i += 1\n    return mrf_lines"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_duplicate_analyses( mrf_lines, allow_to_delete_all = True ):\n    ''' Removes duplicate analysis lines from mrf_lines. \n        \n        Uses special logic for handling adposition analyses ('_K_ pre' && '_K_ post')\n        that do not have subcategorization information:\n         *) If a word has both adposition analyses, removes '_K_ pre';\n         *) If a word has '_K_ post', removes it;\n        Note that '_K_ pre' and '_K_ post' with subcategorization information will\n        be kept.\n        \n        The parameter  allow_to_delete_all  specifies whether it is allowed to delete\n        all analysis or not. If allow_to_delete_all == False, then one last analysis\n        won't be deleted, regardless whether it should be deleted considering the \n        adposition-deletion rules;\n        The original implementation corresponds to the settings allow_to_delete_all=True \n        (and this is also the default value of the parameter);\n        \n        Returns the input list where the removals have been applied;\n    ''' \n    i = 0\n    seen_analyses  = []\n    analyses_count = 0\n    to_delete      = []\n    Kpre_index     = -1\n    Kpost_index    = -1\n    while ( i < len(mrf_lines) ):\n        line = mrf_lines[i]\n        if not line.startswith('  '): \n           if Kpre_index != -1 and Kpost_index != -1:\n              # If there was both _K_pre and _K_post, add _K_pre to removables;\n              to_delete.append( Kpre_index )\n           elif Kpost_index != -1:\n              # If there was only _K_post, add _K_post to removables;\n              to_delete.append( Kpost_index )\n           # Delete found duplicates\n           if to_delete:\n              for k, j in enumerate(sorted(to_delete, reverse=True)):\n                  # If we must preserve at least one analysis, and\n                  # it has been found that all should be deleted, then \n                  # keep the last one\n                  if not allow_to_delete_all and \\\n                     analyses_count == len(to_delete) and \\\n                     k == len(to_delete) - 1:\n                     continue\n                  # Delete the analysis line\n                  del mrf_lines[j]\n                  i -= 1\n           # Reset the memory for each new word/token\n           seen_analyses = []\n           analyses_count = 0\n           to_delete     = []\n           Kpre_index    = -1\n           Kpost_index   = -1\n        elif line.startswith('  '):   # the line of analysis \n           analyses_count += 1\n           if line in seen_analyses:\n              # Remember line that has been already seen as a duplicate\n              to_delete.append( i )\n           else:\n              # Remember '_K pre' and '_K_ post' indices\n              if re.search('/_K_\\s+pre\\s+//', line):\n                 Kpre_index  = i\n              elif re.search('/_K_\\s+post\\s+//', line):\n                 Kpost_index = i\n              # Remember that the line has already been seen\n              seen_analyses.append( line )\n        i += 1\n    return mrf_lines", "response": "Removes duplicate analyses from the input list."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_hashtag_info( mrf_lines ):\n    ''' Augments analysis lines with various hashtag information:\n          *) marks words with capital beginning with #cap;\n          *) marks finite verbs with #FinV;\n          *) marks nud/tud/mine/nu/tu/v/tav/mata/ja forms;\n        Hashtags are added at the end of the analysis content (just before the \n        last '//');\n\n        Returns the input list where the augmentation has been applied;\n    ''' \n    i   = 0\n    cap = False\n    while ( i < len(mrf_lines) ):\n        line = mrf_lines[i]\n        if not line.startswith('  ') and len(line) > 0:\n           cap = (line[0]).isupper()\n        elif line.startswith('  '): \n           if cap:\n              line = re.sub('(//.+\\S)\\s+//', '\\\\1 #cap //', line)\n           if _morfFinV.search( line ) and not _morfNotFinV.search( line ):\n              line = re.sub('(//.+\\S)\\s+//', '\\\\1 #FinV //', line)\n           for [pattern, replacement] in _mrfHashTagConversions:\n               line = re.sub(pattern, replacement, line)\n           mrf_lines[i] = line\n        i += 1\n    return mrf_lines", "response": "Adds hashtag information to the input list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_subcat_info( subcat_lex_file ):\n    ''' Loads subcategorization rules (for verbs and adpositions) from a text \n        file. \n        \n        It is expected that the rules are given as pairs, where the first item is \n        the lemma (of verb/adposition), followed on the next line by the \n        subcategorization rule, in the following form: \n           on the left side of '>' is the condition (POS-tag requirement for the \n           lemma), \n         and \n           on the right side is the listing of subcategorization settings (hashtag \n           items, e.g. names of morphological cases of nominals);\n        If there are multiple subcategorization rules to be associated with a\n        single lemma, different rules are separated by '&'.\n        \n        Example, an excerpt from the rules file:\n          l\u00e4bi\n          _V_ >#Part &_K_ post >#gen |#nom |#el &_K_ pre >#gen \n          l\u00e4bista\n          _V_ >#NGP-P \n          l\u00e4bistu\n          _V_ >#Intr \n\n        Returns a dict of lemma to a-list-of-subcatrules mappings.\n    '''\n    rules = {}\n    nonSpacePattern = re.compile('^\\S+$')\n    posTagPattern   = re.compile('_._')\n    in_f = codecs.open(subcat_lex_file, mode='r', encoding='utf-8')\n    lemma = ''\n    subcatRules = ''\n    for line in in_f:\n        line = line.rstrip()\n        if nonSpacePattern.match(line) and not posTagPattern.search(line):\n           lemma = line\n        elif posTagPattern.search(line):\n           subcatRules = line\n        if len(lemma) > 0 and len(subcatRules) > 0:\n           if lemma not in rules:\n              rules[lemma] = []\n           parts = subcatRules.split('&')\n           for part in parts:\n              part = part.strip()\n              rules[lemma].append( part )\n           lemma = ''\n           subcatRules = ''\n    in_f.close()\n    #print( len(rules.keys()) )   # 4484\n    return rules", "response": "Loads the subcategorization rules from a text \n        file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tag_subcat_info( mrf_lines, subcat_rules ):\n    ''' Adds subcategorization information (hashtags) to verbs and adpositions;\n        \n        Argument subcat_rules must be a dict containing subcategorization information,\n        loaded via method load_subcat_info();\n\n        Performs word lemma lookups in subcat_rules, and in case of a match, checks \n        word part-of-speech conditions. If the POS conditions match, adds subcategorization\n        information either to a single analysis line, or to multiple analysis lines \n        (depending on the exact conditions in the rule);\n\n        Returns the input list where verb/adposition analyses have been augmented \n        with available subcategorization information;\n    ''' \n    i = 0\n    while ( i < len(mrf_lines) ):\n        line = mrf_lines[i]\n        if line.startswith('  '):\n           lemma_match = analysisLemmaPat.match(line)\n           if lemma_match:\n              lemma = lemma_match.group(1)\n              # Find whether there is subcategorization info associated \n              # with the lemma\n              if lemma in subcat_rules:\n                 analysis_match = analysisPat.search(line)\n                 if not analysis_match:\n                    raise Exception(' Could not find analysis from the line:',line)\n                 analysis = analysis_match.group(1)\n                 for rule in subcat_rules[lemma]:\n                     condition, addition = rule.split('>')\n                     # Check the condition string; If there are multiple conditions, \n                     # all must be satisfied for the rule to fire\n                     condition  = condition.strip()\n                     conditions = condition.split()\n                     satisfied1 = [ _check_condition(c, analysis) for c in conditions ]\n                     if all( satisfied1 ):\n                        #\n                        # There can be multiple additions:\n                        #   1) additions without '|' must be added to a single analysis line;\n                        #   2) additions separated by '|' must be placed on separate analysis \n                        #      lines;\n                        #\n                        additions = addition.split('|')\n                        j = i\n                        # Add new line or lines\n                        for a in additions:\n                            line_copy = line if i == j else line[:] \n                            items_to_add = a.split()\n                            for item in items_to_add:\n                                if not _check_condition(item, analysis):\n                                   line_copy = \\\n                                       re.sub('(//.+\\S)\\s+//', '\\\\1 '+item+' //', line_copy)\n                            if j == i:\n                               # 1) replace the existing line\n                               mrf_lines[i] = line_copy\n                            else:\n                               # 2) add a new line \n                               mrf_lines.insert(i, line_copy)\n                            j += 1\n                        i = j - 1\n                        # No need to search forward\n                        break\n        i += 1\n    return mrf_lines", "response": "Given a list of lines and a dictionary of subcat rules returns a list of subcategorization information associated with the word - of - speech analyses."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert_to_cg3_input( mrf_lines ):\n    ''' Converts given mrf lines from syntax preprocessing format to cg3 input\n        format:\n          *) surrounds words/tokens with \"< and >\"\n          *) surrounds word lemmas with \" in analysis;\n          *) separates word endings from lemmas in analysis, and adds prefix 'L';\n          *) removes '//' and '//' from analysis;\n          *) converts hashtags to tags surrounded by < and >;\n          ... and provides other various fix-ups;\n\n        Returns the input list, where elements (tokens/analyses) have been converted\n        into the new format;\n    ''' \n    i = 0\n    while ( i < len(mrf_lines) ):\n        line = mrf_lines[i]\n        if not line.startswith('  ') and len(line) > 0:\n           #\n           # A line containing word/token\n           #\n           #  a. surround the word with \"< and >\"\n           line = re.sub('^(\\S.*)([\\n\\r]*)$','\"<\\\\1>\"\\\\2', line)\n           #  b. fix the sentence begin/end tags\n           line = re.sub('<<(s|/s)>>', '<\\\\1>', line)\n           mrf_lines[i] = line\n        elif line.startswith('  '):\n           #\n           # A line containing analysis\n           #\n           #  1. perform various fixes:\n           line = re.sub('#cap #cap','cap', line)\n           line = re.sub('#cap','cap', line)\n           line = re.sub('\\*\\*CLB','CLB', line)\n           line = re.sub('#Correct!','<Correct!>', line)\n           line = re.sub('####','', line)\n           line = re.sub('#(\\S+)','<\\\\1>', line)\n           line = re.sub('\\$([,.;!?:<]+)','\\\\1', line)\n           line = re.sub('_Y_\\s+\\? _Z_','_Z_', line)\n           line = re.sub('_Y_\\s+\\?\\s+_Z_','_Z_', line)\n           line = re.sub('_Y_\\s+_Z_','_Z_', line)\n           line = re.sub('_Z_\\s+\\?','_Z_', line)\n           #  2. convert analysis line \\w word ending\n           line = re.sub('^\\s+(\\S+)(.*)\\+(\\S+)\\s*//_(\\S)_ (.*)//(.*)$', \\\n                         '    \"\\\\1\\\\2\" L\\\\3 \\\\4 \\\\5 \\\\6', line)\n           #  3. convert analysis line \\wo word ending\n           line = re.sub('^\\s+(\\S+)(.*)\\s+//_(\\S)_ (.*)//(.*)$', \\\n                         '    \"\\\\1\\\\2\" \\\\3 \\\\4 \\\\5', line)\n           mrf_lines[i] = line\n        i += 1\n    return mrf_lines", "response": "Converts given mrf lines from syntax preprocessing format to cg3 input format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexecute the preprocessing pipeline on the JSON given as a dict ; returns a list of lines of analyses in the VISL CG3 input format ;", "response": "def process_vm_json( self, json_dict, **kwargs ):\n        ''' Executes the preprocessing pipeline on vabamorf's JSON, given as a dict;\n\n            Returns a list: lines of analyses in the VISL CG3 input format;\n        ''' \n        mrf_lines = convert_vm_json_to_mrf( json_dict )\n        return self.process_mrf_lines( mrf_lines, **kwargs )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute the preprocessing pipeline on the estnltk s Text object.", "response": "def process_Text( self, text, **kwargs ):\n        ''' Executes the preprocessing pipeline on estnltk's Text object.\n\n            Returns a list: lines of analyses in the VISL CG3 input format;\n        ''' \n        mrf_lines = convert_Text_to_mrf( text )\n        return self.process_mrf_lines( mrf_lines, **kwargs )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_mrf_lines( self, mrf_lines, **kwargs ):\n        ''' Executes the preprocessing pipeline on mrf_lines.\n\n            The input should be an analysis of the text in Filosoft's old mrf format;\n\n            Returns the input list, where elements (tokens/analyses) have been converted\n            into the new format;\n        '''\n        converted1 = convert_mrf_to_syntax_mrf( mrf_lines, self.fs_to_synt_rules )\n        converted2 = convert_pronouns( converted1 )\n        converted3 = remove_duplicate_analyses( converted2, allow_to_delete_all=self.allow_to_remove_all )\n        converted4 = add_hashtag_info( converted3 )\n        converted5 = tag_subcat_info( converted4, self.subcat_rules )\n        converted6 = remove_duplicate_analyses( converted5, allow_to_delete_all=self.allow_to_remove_all )\n        converted7 = convert_to_cg3_input( converted6 )\n        return converted7", "response": "Executes the preprocessing pipeline on mrf_lines."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfunctioning to get a list of files ending with ending in src_dir.", "response": "def get_sources(src_dir='src', ending='.cpp'):\n    \"\"\"Function to get a list of files ending with `ending` in `src_dir`.\"\"\"\n    return [os.path.join(src_dir, fnm) for fnm in os.listdir(src_dir) if fnm.endswith(ending)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning ANSI escape code corresponding to switching the font to given color.", "response": "def _get_ANSI_colored_font( color ):\r\n    ''' Returns an ANSI escape code (a string) corresponding to switching the font\r\n        to given color, or None, if the given color could not be associated with \r\n        the available colors.\r\n        \r\n        See also:\r\n          https://en.wikipedia.org/wiki/ANSI_escape_code#Colors\r\n          http://stackoverflow.com/questions/287871/print-in-terminal-with-colors-using-python\r\n    '''\r\n    color = (color.replace('-','')).lower()\r\n    #\r\n    #   Bright colors:\r\n    #\r\n    if color == 'white':\r\n        return '\\033[97m'\r\n    elif color in ['cyan', 'aqua']:\r\n        return '\\033[96m'\r\n    elif color in ['purple', 'magneta', 'fuchsia']:\r\n        return '\\033[95m'\r\n    elif color == 'blue':\r\n        return '\\033[94m'\r\n    elif color in ['yellow', 'gold']:\r\n        return '\\033[93m'\r\n    elif color in ['green', 'lime']:\r\n        return '\\033[92m'\r\n    elif color == 'red':\r\n        return '\\033[91m'\r\n    #\r\n    #   Dark colors:\r\n    #\r\n    elif color in ['grey', 'gray', 'silver']:\r\n        return '\\033[37m'\r\n    elif color in ['darkcyan', 'teal']:\r\n        return '\\033[36m'\r\n    elif color in ['darkpurple', 'darkmagneta']:\r\n        return '\\033[35m'\r\n    elif color in ['darkblue', 'navy']:\r\n        return '\\033[34m'\r\n    elif color in ['darkyellow', 'olive']:\r\n        return '\\033[33m'\r\n    elif color == 'darkgreen':\r\n        return '\\033[32m'\r\n    elif color in ['darkred', 'maroon']:\r\n        return '\\033[31m'\r\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct an index that stores all annotations starting from the given text layer and stores them into the given index.", "response": "def _construct_start_index(text, layer, markup_settings, spansStartingFrom=None):\r\n    ''' Creates an index which stores all annotations of given text layer,\r\n        indexed by the start position of the annotation (annotation[START]).\r\n        Alternatively, if the index spansStartingFrom is already provided\r\n        as an input argument, obtains annotation information from the given \r\n        text layer, and stores into the index;\r\n        \r\n        The method also creates an ( ANSI-terminal compatible ) mark-up of \r\n        the annotations (generates start and end tags), following the \r\n        specification in markup_settings. The markup_settings should be a\r\n        dict, setting at least one of the following visualisation options:\r\n          * 'bracket' : True -- annotations will be surrounded with brackets; \r\n                                This works in any terminal;\r\n          * 'underline' : True -- annotations will be underlined; This works in \r\n                                  an ANSI compatible terminal;\r\n          * 'color' : ('red', 'green', 'blue' etc. ) -- annotated text will be \r\n                                                        displayed in given color; \r\n                                                        this works in an ANSI \r\n                                                        compatible terminal;\r\n        \r\n        Each start position (in the index) is associated with a list of \r\n        annotation objects (annotations starting from that position).\r\n        An annotation object is a list containing the following information:\r\n         *) START position (of the annotation),\r\n         *) END position (of the annotation),\r\n         *) layer (name), \r\n         *) startTags -- graphic or textual formatting of the start tag, \r\n         *) endTags -- graphic or textual formatting of the end tag, \r\n         *) graphicFormatting -- boolean (whether graphic formatting was used?), \r\n         *) bracketing -- boolean (whether bracketing was used?), \r\n       \r\n        Multiple annotation objects starting from the same position are sorted by \r\n        their length: longer annotations preceding the shorter ones;\r\n       \r\n        The method returns created (or augmented) index (a dict object indexed \r\n        by START positions);\r\n    '''\r\n    if not markup_settings or not isinstance(markup_settings, dict):\r\n       raise Exception('Error: markup_settings should be a dict containing markup specification;')\r\n    # ----------------------------\r\n    # 1) Construct start and end tags, considering the formatting settings\r\n    startTags = ''\r\n    endTags   = ''\r\n    graphicFormatting = False\r\n    bracketing        = False\r\n    # -- Underlining\r\n    if ('u' in markup_settings and markup_settings['u']) or \\\r\n       ('underline' in markup_settings and markup_settings['underline']):\r\n       startTags += '\\033[4m'\r\n       endTags   += '\\033[0m'\r\n       graphicFormatting = True\r\n    colorName = markup_settings['c'] if 'c' in markup_settings else None\r\n    colorName = markup_settings['color'] if 'color' in markup_settings else colorName\r\n    # -- Coloring\r\n    if colorName:\r\n       color = _get_ANSI_colored_font( colorName )\r\n       if color:\r\n          startTags += color\r\n          endTags   += '\\033[0m'\r\n          graphicFormatting = True\r\n       else:\r\n          raise Exception('Unknown color:', colorName)\r\n    # -- Bracketing\r\n    if ('b' in markup_settings and markup_settings['b']) or \\\r\n       ('bracket' in markup_settings and markup_settings['bracket']):\r\n       startTags += '['\r\n       # Add ending bracket before graphics ends (otherwise the \r\n       # graphics have no effect on the ending bracket)\r\n       endTags    = ']'+endTags\r\n       bracketing = True\r\n    # Hack: if both bracketing and graphic formatting are used, add graphic\r\n    #       formatting before the closing bracket of the endTag (to ensure\r\n    #       that graphic formatting of the ending bracket is not overwritten\r\n    #       mistakenly);\r\n    if graphicFormatting and bracketing:\r\n       startTags2 = startTags.rstrip('[')\r\n       endTags    = startTags2+endTags\r\n\r\n    # ----------------------------\r\n    # 2) Get extractor for the elements of given layer\r\n    # >>> The following code borrows from estnltk.prettyprinter.marker :\r\n    # decide which extractor to use\r\n    # first just assume we need to use a multi layer text extractor\r\n    extractor = lambda t: texts_multi(t, layer)\r\n    # if user has specified his/her own callable, use it\r\n    if hasattr(layer, '__call__'):\r\n        extractor = layer\r\n    elif text.is_simple(layer):\r\n        # the given layer is simple, so use simple text extractor\r\n        extractor = lambda t: texts_simple(t, layer)\r\n    # >>>\r\n\r\n    # ----------------------------\r\n    # 3) Store an annotation for each span of given layer\r\n    if not spansStartingFrom:\r\n        spansStartingFrom = {}\r\n    for elem in extractor(text):\r\n        if elem[START] not in spansStartingFrom:\r\n           spansStartingFrom[elem[START]] = []\r\n        span1 = [elem[START], elem[END], layer, startTags, endTags, graphicFormatting, bracketing]\r\n        # Insert the span into the index\r\n        if not spansStartingFrom[elem[START]]:\r\n           spansStartingFrom[elem[START]].append( span1 )\r\n        else:\r\n           # Make sure that spans are inserted in the order of decreasing length: \r\n           #  longer spans preceding the shorter ones;\r\n           inserted = False\r\n           for i in range( len(spansStartingFrom[elem[START]]) ):\r\n               span2 = spansStartingFrom[elem[START]][i]\r\n               # If an existing span is shorter than the current span, insert the\r\n               # current span before the existing span ...\r\n               if span1[1] > span2[1]:\r\n                  spansStartingFrom[elem[START]].insert( i, span1 )\r\n                  inserted = True\r\n                  break\r\n               elif span1[1] == span2[1] and span1[2] < span2[2]:\r\n                  # If both spans have equal length, order the spans in the alphabetical\r\n                  # order of layer names:\r\n                  spansStartingFrom[elem[START]].insert( i, span1 )\r\n                  inserted = True\r\n                  break\r\n           if not inserted:\r\n               spansStartingFrom[elem[START]].append(span1)\r\n    return spansStartingFrom"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct an index that stores all the annotations ending at the given position.", "response": "def _construct_end_index( spansStartingFrom ):\r\n   ''' Creates an index which stores all annotations (from spansStartingFrom) \r\n       by their end position in text (annotation[END]).\r\n       \r\n       Each start position (in the index) is associated with a list of \r\n       annotation objects (annotations ending at that position).\r\n       An annotation object is also a list containing the following information:\r\n        *) endTags -- graphic or textual formatting of the end tag,\r\n        *) START position (of the annotation);\r\n        *) layer name;\r\n         \r\n       Multiple annotation objects ending at the same position are sorted by \r\n       their length: shorter annotations preceding the longer ones;\r\n   '''\r\n   endIndex = {}\r\n   for i in spansStartingFrom:\r\n       for span1 in spansStartingFrom[i]:\r\n           # keep the record of endTags, start positions (for determining the length)\r\n           # and layer names\r\n           endSpan1 = [ span1[4], span1[0], span1[2] ]\r\n           endLoc1 = span1[1]\r\n           if endLoc1 not in endIndex:\r\n              endIndex[endLoc1] = []\r\n              endIndex[endLoc1].append( endSpan1 )\r\n           else:\r\n              # Make sure that spans are inserted in the order of increasing length: \r\n              #   shorter spans preceding the longer ones;\r\n              inserted = False\r\n              for i in range( len(endIndex[endLoc1]) ):\r\n                  endSpan2 = endIndex[endLoc1][i]\r\n                  # If an existing span is longer than the current span, insert the\r\n                  # current span before the existing span ...\r\n                  if endSpan2[1] < endSpan1[1]:\r\n                     endIndex[endLoc1].insert( i, endSpan1 )\r\n                     inserted = True\r\n                     break\r\n                  elif endSpan2[1] == endSpan1[1] and endSpan2[2] < endSpan1[2]:\r\n                     # If both spans have equal length, order the spans in the \r\n                     # alphabetical order of layer names:\r\n                     endIndex[endLoc1].insert( i, endSpan1 )\r\n                     inserted = True\r\n                     break\r\n              if not inserted:\r\n                  endIndex[endLoc1].append( endSpan1 )\r\n   return endIndex"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _fix_overlapping_graphics( spansStartingFrom ):\r\n    ''' Provides a fix for overlapping annotations that are formatted graphically\r\n        (underlined or printed in non-default color).\r\n        \r\n        If two graphically formatted annotations overlap, and if one annotation,\r\n        say A, ends within another annotation, say B, then ending of graphics of A\r\n        also causes graphics of B to end, and so, the end of A should restart the\r\n        the graphics of B for a continuous visualisation;\r\n        This method modifies ending tags in a way that annotations ending within\r\n        other annotations will also contain restarts of the corresponding (super)-\r\n        annotations, so that a continuous formatting is ensured.\r\n    '''\r\n    for startIndex in sorted( spansStartingFrom.keys() ):\r\n        for span1 in spansStartingFrom[startIndex]:\r\n            # If the span is not graphic, we don't have no worries - we can just skip it\r\n            if not span1[5]:\r\n               continue\r\n            # Otherwise: check for other graphic spans that overlap with the given span\r\n            span1Start = span1[0]\r\n            span1End   = span1[1]\r\n            for i in range( span1Start, span1End ):\r\n                if i in spansStartingFrom:\r\n                   for span2 in spansStartingFrom[i]:\r\n                       span2Start = span2[0]\r\n                       span2End   = span2[1]\r\n                       # If the spans are not the same, and the span2 is graphic\r\n                       if span2 != span1 and span2[5]:\r\n                          # if the overlapping graphic span ends before the current span,\r\n                          # we have to restart the graphic formatting of given span after \r\n                          # the end of the overlapping span\r\n                          if span2End <= span1End:\r\n                             if not span1[6]:\r\n                                # If span1 is not bracketed, just add it at the end of\r\n                                # the overlapping span\r\n                                span2[4] += span1[3]\r\n                             else:\r\n                                # If span1 is bracketed, add it at the end of the \r\n                                # overlapping span without brackets\r\n                                wb = span1[3].rstrip('[')\r\n                                span2[4] += wb", "response": "Provides a fix for overlapping graphic annotations that are formatted graphically with non - default color."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _preformat( text, layers, markup_settings = None ):\r\n   ''' Formats given text, adding a special ( ANSI-terminal compatible ) markup\r\n       to the annotations of given layers, and returns formatted text as a\r\n       string.\r\n       *) layers is a list containing names of the layers to be preformatted in \r\n          the text (these layers must be present in Text);\r\n       *) markup_settings should be a list containing annotation options for each\r\n          layer: one dict with options per layer;\r\n          One dict can contain the following visualization options:\r\n          * 'bracket' : True -- annotations will be surrounded with brackets; This \r\n                                works in any terminal;\r\n          * 'underline' : True -- annotations will be underlined; This works in ANSI \r\n                                  compatible terminal;\r\n          * 'color' : ('red', 'green', 'blue' etc. ) -- annotated text will be \r\n                      displayed in given color; this works in ANSI compatible \r\n                      terminal;\r\n       *) Alternatively, if markup_settings is undefined, up to 12 layers can be \r\n          visualized following the default settings;\r\n        \r\n       Parameters\r\n       ----------\r\n       text: Text\r\n          a text object. Must contain given layers;\r\n       layer: list of str\r\n          list of layer names to be visualised;\r\n       markup_settings: list of dict\r\n          list of dictionaries containing user-defined visualization options;\r\n          (one dict per layer)\r\n        \r\n       Returns\r\n       -------\r\n       text: str\r\n          preformatted text, where elements of given layers have been marked up, using \r\n          an ANSI-terminal compatible markup;\r\n   '''\r\n   if markup_settings and len(layers) != len(markup_settings):\r\n       raise Exception(' Input arguments layers and markup_settings should be equal size lists.')\r\n   elif not markup_settings and len(layers) <= len(default_markup_settings):\r\n       # Use default markup settings\r\n       markup_settings = default_markup_settings[0:len(layers)]\r\n   elif not markup_settings:\r\n       raise Exception(' Input argument markup_settings not defined.')\r\n   #\r\n   # 1) Construct the index of annotations (for each layer); \r\n   #    Annotations are indexed by their start positions;\r\n   #    The index also contains start and end tags of each annotation;\r\n   spansStartingFrom = {}\r\n   for i in range( len(layers) ):\r\n       layer    = layers[i]\r\n       settings = markup_settings[i]\r\n       spansStartingFrom = _construct_start_index(text, layer, settings, spansStartingFrom)\r\n   #\r\n   # 2) Fix overlapping graphic annotations in the index\r\n   #    (to ensure continuous formatting of annotations)\r\n   _fix_overlapping_graphics( spansStartingFrom )\r\n   #\r\n   # 3) Index the annotations by their end positions\r\n   endTags = _construct_end_index( spansStartingFrom )\r\n   \r\n   #\r\n   # 4) Construct the output string\r\n   return_str = []\r\n   for i in range( len(text[TEXT]) ):\r\n       c = text[TEXT][i]\r\n       emptyTags = []\r\n       if i in endTags:\r\n          for tag in endTags[i]:\r\n              if tag[1] != i:\r\n                 # Non-empty tag\r\n                 return_str.append( tag[0] )\r\n              else:\r\n                 # Empty tag\r\n                 emptyTags.append( tag )\r\n       if i in spansStartingFrom:\r\n          for span in spansStartingFrom[i]:\r\n              return_str.append( span[3] )\r\n              if span[0] == span[1]:\r\n                 # Empty tag: Add the closing tag\r\n                 for emptyEndTag in emptyTags:\r\n                     if span[2] == emptyEndTag[2]:\r\n                        return_str.append( emptyEndTag[0] )\r\n       return_str.append( c )\r\n   if len(text[TEXT]) in spansStartingFrom:\r\n       for span in spansStartingFrom[len(text[TEXT])]:\r\n           return_str.append( span[3] )\r\n   if len(text[TEXT]) in endTags:\r\n       for tag in endTags[len(text[TEXT])]:\r\n           return_str.append( tag[0] )\r\n   # Hack: fix for a potential overflow / unclosed graphics\r\n   if return_str and '\\033' in return_str[-1] and \\\r\n      not return_str[-1].endswith('\\033[0m'):\r\n      return_str.append( '\\033[0m' )\r\n   return ''.join(return_str)", "response": "Formats given text with special markups."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats given text with special markups and prints the formatted text to the screen.", "response": "def tprint( text, layers, markup_settings = None ):\r\n    ''' Formats given text, adding a special ( ANSI-terminal compatible ) markup\r\n        to the annotations of given layers, and prints the formatted text to the \r\n        screen. \r\n        *) layers is a list containing names of the layers to be preformatted in \r\n           the text (these layers must be present in Text);\r\n        *) markup_settings should be a list containing annotation options for each\r\n           layer: one dict with options per layer;\r\n           One dict can contain the following visualization options:\r\n           * 'bracket' : True -- annotations will be surrounded with brackets; This \r\n                                 works in any terminal;\r\n           * 'underline' : True -- annotations will be underlined; This works in ANSI \r\n                                   compatible terminal;\r\n           * 'color' : ('red', 'green', 'blue' etc. ) -- annotated text will be \r\n                       displayed in given color; this works in ANSI compatible \r\n                       terminal;\r\n        *) Alternatively, if markup_settings is undefined, up to 12 layers can be \r\n           visualized following the default settings;\r\n        \r\n        Parameters\r\n        ----------\r\n        text: Text\r\n           a text object. Must contain given layers;\r\n        layer: list of str\r\n           list of layer names to be visualised;\r\n        markup_settings: list of dict\r\n           list of dictionaries containing user-defined visualization options;\r\n           (one dict per layer)\r\n    '''\r\n    if markup_settings and len(layers) != len(markup_settings):\r\n       raise Exception(' Input arguments layers and markup_settings should be equal size lists.')\r\n    elif not markup_settings and len(layers) <= len(default_markup_settings):\r\n       # Use a subset from default markup settings\r\n       markup_settings = default_markup_settings[0:len(layers)]\r\n    elif not markup_settings:\r\n       raise Exception(' Input argument markup_settings not defined.')\r\n    print( _preformat(text, layers, markup_settings=markup_settings) )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate CSS class for a mark tag.", "response": "def get_mark_css(aes_name, css_value):\n    \"\"\"Generate CSS class for <mark> tag.\n\n    Parameters\n    ----------\n    aes_name: str\n        The name of the class.\n    css_value: str\n        The value for the CSS property defined by aes_name.\n\n    Returns\n    -------\n    list of str\n        The CSS codeblocks\n    \"\"\"\n    css_prop = AES_CSS_MAP[aes_name]\n    if isinstance(css_value, list):\n        return get_mark_css_for_rules(aes_name, css_prop, css_value)\n    else:\n        return get_mark_simple_css(aes_name, css_prop, css_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads the relations from the input file into the instance attributes.", "response": "def _loadSubcatRelations( self, inputFile ):\r\n        ''' Laeb sisendfailist (inputFile) verb-nom/adv-vinf rektsiooniseoste mustrid.\r\n            Iga muster peab olema failis eraldi real, kujul:\r\n                (verbikirjeldus)\\TAB(nom/adv-kirjeldus)\\TAB(vinfkirjeldus)\r\n            nt\r\n                leid NEG\taeg;S;((sg|pl) (p)|adt)\tda\r\n                leid POS\tv\u00f5imalus;S;(sg|pl) (n|p|g)\tda\r\n            Salvestab laetud tulemused klassimuutujatesse nomAdvWordTemplates, verbRules\r\n            ja verbToVinf;\r\n        '''\r\n        self.nomAdvWordTemplates = dict()\r\n        self.verbRules  = dict()\r\n        self.verbToVinf = dict()\r\n        in_f = codecs.open(inputFile, mode='r', encoding='utf-8')\r\n        for line in in_f:\r\n            line = line.rstrip()\r\n            if len(line) > 0 and not re.match(\"^#.+$\", line):\r\n                items = line.split('\\t')\r\n                if len(items) == 3:\r\n                    verb    = items[0]\r\n                    nounAdv = items[1]\r\n                    vinf    = items[2]\r\n                    if nounAdv not in self.nomAdvWordTemplates:\r\n                        (root,pos,form) = nounAdv.split(';')\r\n                        if not root.startswith('^') and not root.endswith('$'):\r\n                            root = '^'+root+'$'\r\n                        constraints = {ROOT:root, POSTAG:pos}\r\n                        if form:\r\n                            constraints[FORM] = form\r\n                        self.nomAdvWordTemplates[nounAdv] = WordTemplate(constraints)\r\n                    if verb not in self.verbRules:\r\n                        self.verbRules[verb] = []\r\n                    if verb not in self.verbToVinf:\r\n                        self.verbToVinf[verb] = []\r\n                    self.verbRules[verb].append( (nounAdv, 'V_'+vinf) )\r\n                    if 'V_'+vinf not in self.verbToVinf[verb]:\r\n                        self.verbToVinf[verb].append( 'V_'+vinf )\r\n                else:\r\n                    raise Exception(' Unexpected number of items in the input lexicon line: '+line)\r\n        in_f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tokenMatchesNomAdvVinf( self, token, verb, vinf): \r\n        ''' Teeb kindlaks, kas etteantud token v6iks olla verb'i alluv ning vinf'i ylemus (st\r\n            paikneda nende vahel). Kui see nii on, tagastab j2rjendi vahele sobiva s6na morf \r\n            analyysidega (meetodi _getMatchingAnalysisIDs abil), vastasel juhul tagastab tyhja \r\n            j2rjendi;\r\n        '''\r\n        if verb in self.verbRules:\r\n            for (nounAdv, vinf1) in self.verbRules[verb]:\r\n                if vinf == vinf1 and (self.nomAdvWordTemplates[nounAdv]).matches(token):\r\n                    return _getMatchingAnalysisIDs( token, self.nomAdvWordTemplates[nounAdv] )\r\n        return []", "response": "Returns a list of analysis IDs that match the given token and the given verb and vinf."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextends verb chains in a sentence.", "response": "def extendChainsInSentence( self, sentence, foundChains ):\r\n        ''' Rakendab meetodit self.extendChainsInClause() antud lause igal osalausel.\r\n        '''\r\n        # 1) Preprocessing\r\n        clauses = getClausesByClauseIDs( sentence )\r\n\r\n        # 2) Extend verb chains in each clause\r\n        allDetectedVerbChains = []\r\n        for clauseID in clauses:\r\n            clause = clauses[clauseID]\r\n            self.extendChainsInClause(clause, clauseID, foundChains)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _isLikelyNotPhrase( self, headVerbRoot, headVerbWID, nomAdvWID, widToToken):\r\n        ''' Kontrollib, et nom/adv ei kuuluks mingi suurema fraasi kooseisu (poleks fraasi peas6na).\r\n            Tagastab True, kui:\r\n               *) nom/adv j2rgneb vahetult peaverbile\r\n               *) v\u00f5i nom/adv on vahetult osalause alguses\r\n               *) v\u00f5i nom-ile eelneb vahetult selline s6na, mis kindlasti ei saa olla\r\n                  eest\u00e4iendiks\r\n               *) v\u00f5i nom/adv puhul on tegemist olema-verbi adv-ga;\r\n        '''\r\n        minWID = min(widToToken.keys())\r\n        nomAdvToken = widToToken[nomAdvWID]\r\n        isNom = self.wtNom.matches(nomAdvToken)\r\n        if headVerbWID+1 == nomAdvWID:\r\n            #   1) Kui nom/adv j2rgneb vahetult verbile, siis on ysna turvaline arvata,\r\n            #      et need kuuluvad kokku, nt:\r\n            #             ja seda tunnet on_0 raske_0 millegi vastu vahetada_0 .\r\n            #             mida nad peavad_0 vajalikuks_0 l\u00e4\u00e4nde m\u00fc\u00fca_0\r\n            return True\r\n        elif minWID == nomAdvWID:\r\n            #   2) Kui nom/adv on vahetult osalause alguses, siis on samuti \u00fcsna turvaline\r\n            #      eeldada, et see kuulub verbiga kokku, nt:\r\n            #             Tarvis_0 on_0 muretseda_0 veel auhinnafond 250 000 dollarit .\r\n            #             Raske_0 on_0 temaga vaielda_0 .\r\n            return True\r\n        elif isNom and nomAdvWID-1 in widToToken:\r\n            prevToken = widToToken[nomAdvWID-1]\r\n            if self.wtNotSyntAttrib.matches(prevToken):\r\n                #\r\n                #   3.1) Kui nom-ile eelneb vahetult adverb, mis tavaliselt allub otse \r\n                #        verbile ning ei funktsioneeri eest2iendina (nt 'ju', 'ikka',\r\n                #        'vist', 'veel' jms), siis on ysna turvaline eeldada, et nom\r\n                #        ei ole mingi fraasi osa:\r\n                #             Kaudseid n\u00e4itajaid on_0 aga v\u00f5imalik_0 anal\u00fc\u00fcsida_0\r\n                #             Pole_0 ju m\u00f5tet_0 hakata_0 teile ette laduma asjaolusid\r\n                #             on_0 veel raske_0 kommenteerida_0\r\n                #\r\n                return True\r\n            elif self.wtNom.matches(prevToken):\r\n                if self.wtNomSemCase.matches(prevToken):\r\n                    if not self.wtNomSemCase.matches(nomAdvToken):\r\n                        #\r\n                        #   3.2) Kui nom-ile vahetult eelnev s6na on semantilises k22ndes, aga nom\r\n                        #        mitte, pole nad suure t6en2osusega seotud, nt:\r\n                        #             Siis j\u00e4\u00e4b_0 ootajal v\u00f5imalus_0 \u00f6elda_0 \r\n                        #             vahendajate juurdehindlust on_0 riigil v\u00f5imalik_0 kontrollida_0 .\r\n                        #             Ka \u00fc\u00fcrnikul on_0 selle seadusega \u00f5igus_0 maksta_0 v\u00e4hem \u00fc\u00fcri\r\n                        #\r\n                        return True\r\n                    else:\r\n                        #\r\n                        #   3.3) Kui nii nom kui vahetult eelnev s6na on m6lemad semantilises k22ndes, \r\n                        #        aga k22nded on erinevad, ei moodusta nad t6en2oliselt yhte fraasi, nt:\r\n                        #            pole_0 ettev\u00f5ttel plaanis_0 Tartus kaugk\u00fcttesooja hinda t\u00f5sta_0 .\r\n                        #            Ginrichi teatel on_0 vabariiklastel kavas_0 luua_0 erikomisjon ,\r\n                        #            et \u00fchegi parkimismaja rajamist pole_0 linnal kavas_0 toetada_0 .\r\n                        #\r\n                        analyses1 = self.wtNomSemCase.matchingAnalyses(prevToken)\r\n                        analyses2 = self.wtNomSemCase.matchingAnalyses(nomAdvToken)\r\n                        forms1 = set([a[FORM] for a in analyses1])\r\n                        forms2 = set([a[FORM] for a in analyses2])\r\n                        if len(forms1.intersection(forms2))==0:\r\n                            return True\r\n        elif not isNom and headVerbRoot.startswith('ole '):\r\n            #\r\n            #   X) Kui tegemist on olema-ga liituva adv-ga, eeldame, et see on suurema t6en2osusega yksik, \r\n            #      st pole mingi fraasi koosseisus:\r\n            #            Theresel polnud_0 raskeid seas\u00f6\u00f6gi\u00e4mbreid tarvis_0 ubida_0 .\r\n            #            Seep\u00e4rast pole_0 meil ka h\u00e4bi vaja_0 tunda_0\r\n            #\r\n            #      NB! Alati see siiski nii ei ole, st v\u00f5ib liituda t\u00e4hendust intensiivistav 'v\u00e4ga',\r\n            #      'pisut', 'palju' jms adverb, nt:\r\n            #            Meil pole_0 siin palju vaja_0 pingutada_0\r\n            #\r\n            return True\r\n        return False", "response": "Returns True if the given head verb is not phrase."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _canBeExpanded( self, headVerbRoot, headVerbWID, suitableNomAdvExpansions, expansionVerbs, widToToken ):\r\n        ''' Teeb kindlaks, kas kontekst on verbiahela laiendamiseks piisavalt selge/yhene:\r\n              1) Nii 'nom/adv' kandidaate kui ka Vinf kandidaate on t\u00e4pselt \u00fcks;\r\n              2) Nom/adv ei kuulu mingi suurema fraasi kooseisu (meetodi _isLikelyNotPhrase() abil);\r\n            Kui tingimused t\u00e4idetud, tagastab lisatava verbi listist expansionVerbs, vastasel juhul\r\n            tagastab None;\r\n        '''\r\n        if len(suitableNomAdvExpansions)==1 and expansionVerbs:\r\n            # Kontrollime, kas leidub t2pselt yks laiendiks sobiv verb (kui leidub\r\n            # rohkem, on kontekst kahtlane ja raske otsustada, kas tasub laiendada \r\n            # v6i mitte)\r\n            suitableExpansionVerbs = \\\r\n                [expVerb for expVerb in expansionVerbs if expVerb[2] == suitableNomAdvExpansions[0][2]]\r\n            if len( suitableExpansionVerbs ) == 1:\r\n                # Kontrollime, et nom/adv ei kuuluks mingi suurema fraasi kooseisu (ei oleks fraasi\r\n                # peas6na);\r\n                nomAdvWID = suitableNomAdvExpansions[0][0]\r\n                if self._isLikelyNotPhrase( headVerbRoot, headVerbWID, nomAdvWID, widToToken ):\r\n                    return suitableExpansionVerbs[0]\r\n        return None", "response": "Returns whether or not the given tag is able to be expanded."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextending the list of foundChains with the ones in the given clause.", "response": "def extendChainsInClause( self, clause, clauseID, foundChains ):\r\n        '''  Proovime etteantud osalauses leiduvaid verbiahelaid t\u00e4iendada 'verb-nom/adv-vinf' \r\n            rektsiooniseostega, nt:\r\n                andma + v\u00f5imalus + Vda :  talle anti_0 v\u00f5imalus_0 olukorda parandada_0\r\n                olema + vaja + Vda    :   n\u00fc\u00fcd on_0 k\u00fcll vaja_0 asi l\u00f5petada_0\r\n             Teeme seda kahel moel:\r\n            1) kui mingi olemasoleva verbiahela keskelt on puudu 'nom/adv' (nt 'andma', 'j\u00e4tma'\r\n               verbide vinf rektsiooniseoste leidmisel v\u00f5ib tekkida selliseid l\u00fcnki), siis\r\n               lisame ahela keskele 'nom/adv' s\u00f5na.\r\n            2) kui verbiahela l\u00f5pus on verb, mis on sageli \u00fclemuseks 'nom/adv' s\u00f5nale, millest\r\n               omakorda s\u00f5ltub mingi Vinf verb (Vma, Vda), ning need on osalausekontekstis olemas,\r\n               lisame need verbiahela l\u00f5ppu;\r\n        '''\r\n        expansionPerformed = False\r\n        # J22dvustame s6nad, mis kuuluvad juba mingi tuvastatud verbifraasi koosseisu\r\n        annotatedWords = []\r\n        for verbObj in foundChains:\r\n            if clauseID == verbObj[CLAUSE_IDX] and (len(verbObj[PATTERN])==1 and \\\r\n               re.match('^(ei|\u00e4ra|ega)$', verbObj[PATTERN][0])):\r\n                # V2lja j22vad yksikuna esinevad ei/\u00e4ra/ega, kuna need t\u00f5en\u00e4oliselt ei sega\r\n                continue\r\n            annotatedWords.extend( verbObj[PHRASE] )\r\n        widToToken = { token[WORD_ID] : token for token in clause }\r\n        verbDaMa   = WordTemplate({POSTAG:'V', FORM:'^(da|ma)$'})\r\n        verbOle    = WordTemplate({ROOT:'^ole$',POSTAG:'V'})\r\n        #\r\n        #   1) Yritame leida, millised juba tuvastatud verbiahelatest on sellised, kust on\r\n        #      vahelt puudu nom/adv s6na, nt:\r\n        #            annab_0 kunstnik j\u00e4lle p\u00f5hjuse endast kirjutada_0\r\n        #            see annab_0 v\u00f5imaluse laua tagant t\u00f5usta_0 ja_0 minema jalutada_0\r\n        #      Kui leiame ahelast puuduoleva s6na ja lisame selle ahelasse ...\r\n        #\r\n        for verbObj in foundChains:\r\n            if clauseID == verbObj[CLAUSE_IDX]:\r\n                headVerb      = ''\r\n                headVerbWID   = -1\r\n                dependentVerb = ''\r\n                dependentVerbWIDs = []\r\n                firstDependentVerbID = -1\r\n                #  Leiame ahela l6pust ylemus-verbi ja sellele alluva verbi\r\n                if len(verbObj[PATTERN]) > 3 and verbObj[PATTERN][-2] == '&':\r\n                    headVerb = verbObj[ROOTS][-4]+\" \"+verbObj[POLARITY]\r\n                    dependentVerb = verbObj[MORPH][-3]\r\n                    headVerbWID = verbObj[PHRASE][-4]\r\n                    dependentVerbWIDs.append( verbObj[PHRASE][-3] )\r\n                    dependentVerbWIDs.append( verbObj[PHRASE][-1] )\r\n                    firstDependentVerbID = len(verbObj[PHRASE])-3\r\n                elif len(verbObj[PATTERN]) > 1 and verbObj[PATTERN][-2]=='verb':\r\n                    headVerb = verbObj[ROOTS][-2]+\" \"+verbObj[POLARITY]\r\n                    dependentVerb = verbObj[MORPH][-1]\r\n                    headVerbWID = verbObj[PHRASE][-2]\r\n                    dependentVerbWIDs.append(verbObj[PHRASE][-1])\r\n                    firstDependentVerbID = len(verbObj[PHRASE])-1\r\n                # Kontrollime, kas ylemusverb ja sellele alluv verb v6iksid olla yhendatud\r\n                # mingi nom/adv s6na kaudu\r\n                if headVerb in self.verbRules and headVerb in self.verbToVinf and \\\r\n                   dependentVerb in self.verbToVinf[headVerb]:\r\n                    # Teeme kindlaks, kas s6nade vahele j22b puuduolev nom/adv\r\n                    minInd = min(min(dependentVerbWIDs), headVerbWID-1)\r\n                    maxInd = max(max(dependentVerbWIDs)-1, headVerbWID)\r\n                    if minInd < maxInd:\r\n                        for i in range(minInd, maxInd+1):\r\n                            if i in widToToken and i not in annotatedWords:\r\n                                token = widToToken[i]\r\n                                matchingAnalyses = self.tokenMatchesNomAdvVinf( token, headVerb, dependentVerb )\r\n                                if matchingAnalyses and not expansionPerformed:\r\n                                    #   Kontrollime, kas vaheletorgatav s\u00f5na paikneb nii, et see on suure\r\n                                    #  t\u00f5en\u00e4osusega \u00fcksiks\u00f5na, mitte fraas.\r\n                                    if self._isLikelyNotPhrase( headVerb, headVerbWID, token[WORD_ID], widToToken ):\r\n                                        # Torkame nimis6na/adverbi vahele\r\n                                        verbObj[PHRASE].insert( firstDependentVerbID, token[WORD_ID] )\r\n                                        verbObj[PATTERN].insert( firstDependentVerbID, 'nom/adv' )\r\n                                        verbObj[ANALYSIS_IDS].insert( firstDependentVerbID, matchingAnalyses )\r\n                                        annotatedWords.append( token[WORD_ID] )\r\n                                        expansionPerformed = True\r\n                                    else:\r\n                                        # Kui me ei saa olla kindlad, et vaheletorgatav s\u00f5na pole fraas, paneme\r\n                                        # k\u00fcsim\u00e4rgi, n\u00e4itamaks, et verbiahelast on suure t\u00f5en\u00e4osusega midagi\r\n                                        # puudu ...\r\n                                        verbObj[OTHER_VERBS] = True\r\n                                        #_debugPrint( ' '+('+'.join(verbObj[PATTERN]))+' | '+_getJsonAsTextString(clause, markTokens = [ verbObj[PHRASE] ] ))\r\n\r\n        #\r\n        #   2) Yritame luua uusi ahelaid, laiendades verbe olemasolevate ahelate l6pus:\r\n        #\r\n        #          millega antakse_0 v\u00f5imalus_1 s\u00f5lmida_1 uus kokkulepe .\r\n        #          puudub_0 v\u00f5imalus_1 spetsialiste t\u00e4ist\u00f6\u00f6ajaga rakendada_1 .\r\n        #          kui on_0 v\u00f5imalus_1 rahulikult vooluga kaasa minna_1\r\n        #\r\n        clauseMaxWID = max( list(widToToken.keys()) )\r\n        for verbObj in foundChains:\r\n            if clauseID == verbObj[CLAUSE_IDX] and verbObj[OTHER_VERBS]:\r\n                if (len(verbObj[PATTERN])==1 or (len(verbObj[PATTERN])>1 and \\\r\n                   verbObj[PATTERN][-2] != '&')):\r\n                    headVerb = verbObj[ROOTS][-1]+\" \"+verbObj[POLARITY]\r\n                    headVerbWID = verbObj[PHRASE][-1]\r\n                    #\r\n                    #   2.1) Esimeses l2henduses vaatame tavalisi verbe (mitte-olema);\r\n                    #\r\n                    if headVerb in self.verbRules and not headVerb.startswith('ole '):\r\n                        minInd = headVerbWID-1 if verbObj[PATTERN][0]!='ega' else headVerbWID\r\n                        suitableNomAdvExpansions = []\r\n                        expansionVerbs = []\r\n                        for i in range(minInd, clauseMaxWID+1):\r\n                            if i in widToToken and i not in annotatedWords:\r\n                                token = widToToken[i]\r\n                                if _isFollowedByComma( i, clause ):\r\n                                    #  Katkestame, kui satume koma otsa (kuna ei saa kindel olla,\r\n                                    # et teisel pool koma on olevad jupid kuuluvad ikka verbi \r\n                                    # juurde)\r\n                                    break\r\n                                if verbDaMa.matches( token ):\r\n                                    analysisIDs = _getMatchingAnalysisIDs( token, verbDaMa )\r\n                                    form = token[ANALYSIS][analysisIDs[0]][FORM]\r\n                                    expansionVerbs.append( [i, token, \"V_\"+form ] )\r\n                                else:\r\n                                    for (nounAdv, vinf1) in self.verbRules[headVerb]:\r\n                                        if (self.nomAdvWordTemplates[nounAdv]).matches(token):\r\n                                            suitableNomAdvExpansions.append( [i, token, vinf1, \\\r\n                                                (self.nomAdvWordTemplates[nounAdv]), nounAdv ] )\r\n                        # Teeme kindlaks, kas kontekst on laiendamiseks piisavalt yhene/selge ...\r\n                        suitableExpansionVerb = \\\r\n                            self._canBeExpanded( headVerb, headVerbWID, suitableNomAdvExpansions, \\\r\n                                expansionVerbs, widToToken )\r\n                        if suitableExpansionVerb:\r\n                            phraseExt  = [suitableNomAdvExpansions[0][0], suitableExpansionVerb[0]]\r\n                            expIsOle   = verbOle.matches(suitableExpansionVerb[1])\r\n                            patternExt = ['nom/adv', 'ole' if expIsOle else 'verb']\r\n                            analysisIDsExt = [ \\\r\n                                    _getMatchingAnalysisIDs( suitableNomAdvExpansions[0][1], \\\r\n                                    suitableNomAdvExpansions[0][3] ), \\\r\n                                    _getMatchingAnalysisIDs( suitableExpansionVerb[1], verbDaMa ) ]\r\n                            # Lisame ahelale pikendused\r\n                            verbObj[PHRASE].extend( phraseExt )\r\n                            verbObj[PATTERN].extend( patternExt )\r\n                            verbObj[ANALYSIS_IDS].extend( analysisIDsExt )\r\n                            annotatedWords.extend( phraseExt )\r\n                            expansionPerformed = True\r\n                            #if headVerb.startswith('and '):\r\n                            #    _debugPrint( ('+'.join(verbObj[PATTERN]))+' | '+getJsonAsTextString(clause, markTokens = [ verbObj[PHRASE] ] ))\r\n                            #_debugPrint( ('+'.join(verbObj[PATTERN]))+' | '+getJsonAsTextString(clause, markTokens = [ verbObj[PHRASE] ] ))\r\n                    elif headVerb in self.verbRules and headVerb.startswith('ole '):\r\n                    #\r\n                    #   2.2) Vaatame olema-verbi rektsiooniseoseid;\r\n                    #\r\n                        minInd = headVerbWID-1 if verbObj[PATTERN][0]!='ega' else headVerbWID\r\n                        suitableNomAdvExpansions = []\r\n                        expansionVerbs = []\r\n                        for i in range(minInd, clauseMaxWID+1):\r\n                            if i in widToToken and i not in annotatedWords:\r\n                                token = widToToken[i]\r\n                                if verbDaMa.matches( token ):\r\n                                    analysisIDs = _getMatchingAnalysisIDs( token, verbDaMa )\r\n                                    form = token[ANALYSIS][analysisIDs[0]][FORM]\r\n                                    expansionVerbs.append( [i, token, \"V_\"+form ] )\r\n                                else:\r\n                                    for (nounAdv, vinf1) in self.verbRules[headVerb]:\r\n                                        if (self.nomAdvWordTemplates[nounAdv]).matches(token):\r\n                                            suitableNomAdvExpansions.append( [i, token, vinf1, \\\r\n                                                (self.nomAdvWordTemplates[nounAdv]), nounAdv] )\r\n                                if _isFollowedByComma( i, clause ):\r\n                                    #  Katkestame, kui satume koma otsa (kuna ei saa kindel olla,\r\n                                    # et teisel pool koma on olevad jupid kuuluvad ikka verbi \r\n                                    # juurde)\r\n                                    break\r\n                        # Teeme kindlaks, kas kontekst on laiendamiseks piisavalt yhene/selge ...\r\n                        suitableExpansionVerb = \\\r\n                            self._canBeExpanded( headVerb, headVerbWID, suitableNomAdvExpansions, \\\r\n                                expansionVerbs, widToToken )\r\n                        if suitableExpansionVerb:\r\n                            phraseExt  = [suitableNomAdvExpansions[0][0], suitableExpansionVerb[0]]\r\n                            expIsOle   = verbOle.matches(suitableExpansionVerb[1])\r\n                            patternExt = ['nom/adv', 'ole' if expIsOle else 'verb']\r\n                            analysisIDsExt = [ \\\r\n                                _getMatchingAnalysisIDs( suitableNomAdvExpansions[0][1], \\\r\n                                suitableNomAdvExpansions[0][3] ), \\\r\n                                _getMatchingAnalysisIDs( suitableExpansionVerb[1], verbDaMa ) ]\r\n                            # Lisame ahelale pikendused\r\n                            verbObj[PHRASE].extend( phraseExt )\r\n                            verbObj[PATTERN].extend( patternExt )\r\n                            verbObj[ANALYSIS_IDS].extend( analysisIDsExt )\r\n                            annotatedWords.extend( phraseExt )\r\n                            expansionPerformed = True\r\n                            #_debugPrint( ('+'.join(verbObj[PATTERN]))+' | '+getJsonAsTextString(clause, markTokens = [ verbObj[PHRASE] ] ))\r\n                            #if suitableNomAdvExpansions[0][4].startswith('aeg;'):\r\n                            #    _debugPrint( ('+'.join(verbObj[PATTERN]))+' | '+_getJsonAsTextString(clause, markTokens = [ verbObj[PHRASE] ] ))\r\n        return expansionPerformed"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sectionsParser(text):\n\n    textStart = 0\n\n    #Split the text in sections. Hackish part, but seems to work fine.\n    entries = re.split(\"\\n=\", text[textStart:])\n    stack = [[]]\n    intro = {}\n    sectionTitleRegEx = re.compile(r'={1,}.+={2,}')\n    section = {}\n    section['text'] = entries[0]\n    counts = []\n\n    #Presumes the first section is always marked with 2 =\n    #First count is always 3. (\\n=)= First Section of an Article ==\n    #Parens is omitted. Leaves three = marks.\n\n    counts.append(3)\n    sections = []\n    sections.append(section)\n    for i in entries[1:]:\n        section = {}\n        title = re.match(sectionTitleRegEx, i)\n        if title:\n            titleEnd = title.end()\n            title = title.group()\n            text = i[titleEnd:]\n            level =  title.count('=')\n            section['title']=title.strip('= ')\n            section['text']=text\n\n            sections.append(section.copy())\n            counts.append(level)\n\n    #add images, links, references, tables\n\n    for section in sections:\n        text = section['text']\n        if 'wikitable' in text or '</table>' in text.lower():\n            section['text'], section['tables'] = tableCollector(text)\n\n        section = relatedArticles(section)\n\n        if '<ref' in text:\n            section = reffinder(section)\n\n        if imageRegEx.search(text):\n            section = imageParser(section)\n\n        section['text'] = section['text'].strip()\n\n        if ExtLinkBracketedRegex.search(text):\n            section = addExternalLinks(section)\n\n\n        if '[[' in text:\n            section = addIntLinks(section)\n\n        #clean uneven brackets and whatnot\n\n        #take extlink start:end w regex.\n        el = 'external_links'\n        if el in section.keys():\n\n            #section['text'] = section['text'].replace('[', '').replace(']', '')\n            text = section['text']\n\n            for link in section[el]:\n\n                label = link['label']\n                label = re.compile(re.escape(label))\n                m = label.search(text)\n                #if there are unbalanced brackets in the external\n                #links label inside text then it fails to mark the start and end\n                try:\n                    link['start'] = m.start()\n                    link['end'] = m.end()\n                except AttributeError:\n                    print('Problem with external links start:end position!')\n                    print(label)\n                    print(text)\n\n\n\n\n\n    #datastructure nesting thanks to Timo!\n    if counts:\n        assert len(counts) == len(sections)\n\n        n = len(sections)\n        pos = 0\n\n        levels = [counts[0]]\n\n        while pos < n:\n            count = counts[pos]\n            elem = sections[pos]\n            level = levels[-1]\n            if count == level:\n                stack[-1].append(elem)\n            elif count >= level:\n                stack.append([elem])\n                levels.append(count)\n            else:\n                group = stack.pop()\n                stack[-1][-1]['sections'] = group\n                levels.pop()\n                continue\n\n            pos += 1\n\n        while len(stack) > 1:\n            group = stack.pop()\n            stack[-1][-1]['sections'] = group\n\n    stack = stack[0]\n\n\n    return stack", "response": "Parses the whole text of an wikipedia article into nested sections."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving all unwanted characters from text.", "response": "def clean(self, text):\n        \"\"\"Remove all unwanted characters from text.\"\"\"\n        return ''.join([c for c in text if c in self.alphabet])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef invalid_characters(self, text):\n        return ''.join(sorted(set([c for c in text if c not in self.alphabet])))", "response": "Give simple list of invalid characters present in text."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind invalid characters in text and store information about them.", "response": "def find_invalid_chars(self, text, context_size=20):\n        \"\"\"Find invalid characters in text and store information about\n        the findings.\n\n        Parameters\n        ----------\n        context_size: int\n            How many characters to return as the context.\n\n        \"\"\"\n        result = defaultdict(list)\n        for idx, char in enumerate(text):\n            if char not in self.alphabet:\n                start = max(0, idx-context_size)\n                end   = min(len(text), idx+context_size)\n                result[char].append(text[start:end])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing statistics of invalid characters on given texts.", "response": "def compute_report(self, texts, context_size=10):\n        \"\"\"Compute statistics of invalid characters on given texts.\n\n        Parameters\n        ----------\n        texts: list of str\n            The texts to search for invalid characters.\n        context_size: int\n            How many characters to return as the context.\n\n        Returns\n        -------\n        dict of (char -> list of tuple (index, context))\n            Returns a dictionary, where keys are invalid characters.\n            Values are lists containign tuples with character indices\n            and context strings.\n        \"\"\"\n        result = defaultdict(list)\n        for text in texts:\n            for char, examples in self.find_invalid_chars(text, context_size).items():\n                result[char].extend(examples)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes statistics of invalid characters and print them.", "response": "def report(self, texts, n_examples=10, context_size=10, f=sys.stdout):\n        \"\"\"Compute statistics of invalid characters and print them.\n\n        Parameters\n        ----------\n        texts: list of str\n            The texts to search for invalid characters.\n        n_examples: int\n            How many examples to display per invalid character.\n        context_size: int\n            How many characters to return as the context.\n        f: file\n            The file to print the report (default is sys.stdout)\n        \"\"\"\n\n        result = list(self.compute_report(texts, context_size).items())\n        result.sort(key=lambda x: (len(x[1]), x[0]), reverse=True)\n        s = 'Analyzed {0} texts.\\n'.format(len(texts))\n        if (len(texts)) == 0:\n            f.write(s)\n            return\n        if len(result) > 0:\n            s += 'Invalid characters and their counts:\\n'\n            for c, examples in result:\n                s += '\"{0}\"\\t{1}\\n'.format(c, len(examples))\n            s += '\\n'\n            for c, examples in result:\n                s += 'For character \"{0}\", found {1} occurrences.\\nExamples:\\n'.format(c, len(examples))\n                examples = sample(examples, min(len(examples), n_examples))\n                for idx, example in enumerate(examples):\n                    s += 'example {0}: {1}\\n'.format(idx+1, example)\n                s += '\\n'\n            f.write(s)\n        else:\n            f.write('All OK\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_text(self, text, **kwargs):\n        # a) get the configuration:\n        apply_tag_analysis = False\n        augment_words      = False\n        all_return_types = [\"text\",\"vislcg3\",\"trees\",\"dep_graphs\"]\n        return_type      = all_return_types[0]\n        for argName, argVal in kwargs.items():\n            if argName.lower() == 'return_type':\n                if argVal.lower() in all_return_types:\n                    return_type = argVal.lower()\n                else:\n                    raise Exception(' Unexpected return type: ', argVal)\n            elif argName.lower() == 'augment_words':\n                augment_words = bool(argVal)\n            elif argName.lower() == 'apply_tag_analysis':\n                apply_tag_analysis = bool(argVal)\n        kwargs['split_result']  = True\n        kwargs['clean_up']      = True\n        kwargs['remove_clo']    = kwargs.get('remove_clo', True)\n        kwargs['remove_cap']    = kwargs.get('remove_cap', True)\n        kwargs['keep_old']      = kwargs.get('keep_old',  False)\n        kwargs['double_quotes'] = 'unesc'\n        \n        # b) process:\n        if apply_tag_analysis:\n            text = text.tag_analysis()\n        result_lines1 = \\\n            self.preprocessor.process_Text(text, **kwargs)\n        result_lines2 = \\\n            self.vislcg3_processor.process_lines(result_lines1, **kwargs)\n        alignments = \\\n            align_cg3_with_Text(result_lines2, text, **kwargs)\n        alignments = \\\n            normalise_alignments( alignments, data_type=VISLCG3_DATA, **kwargs )\n        \n        # c) attach & return results\n        text[LAYER_VISLCG3] = alignments\n        if augment_words:\n            self._augment_text_w_syntactic_info( text, text[LAYER_VISLCG3] )\n        if return_type   == \"vislcg3\":\n            return result_lines2\n        elif return_type == \"trees\":\n            return build_trees_from_text( text, layer=LAYER_VISLCG3, **kwargs )\n        elif return_type == \"dep_graphs\":\n            trees = build_trees_from_text( text, layer=LAYER_VISLCG3, **kwargs )\n            graphs = [tree.as_dependencygraph() for tree in trees]\n            return graphs\n        else:\n            return text", "response": "Parses given text with VISLCG3 based syntactic analyzer and returns a new Text object containing the parsed text."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters the dict of kwargs that are in keep_list and discards all other arguments.", "response": "def _filter_kwargs(self, keep_list, **kwargs):\n        ''' Filters the dict of *kwargs*, keeping only arguments \n            whose keys are in *keep_list* and discarding all other\n            arguments.\n            \n            Based on the filtring, constructs and returns a new \n            dict.\n        '''\n        new_kwargs = {}\n        for argName, argVal in kwargs.items():\n            if argName.lower() in keep_list:\n                new_kwargs[argName.lower()] = argVal\n        return new_kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\naugments given Text object with the syntactic information about each token in the text_layer. More specifically adds information about SYNTAX_LABEL SYNTAX_HEAD and DEPREL to each token in the text_layer. More specifically adds information about SYNTAX_HEAD and DEPREL to each token in the Text object.", "response": "def _augment_text_w_syntactic_info( self, text, text_layer ):\n        ''' Augments given Text object with the syntactic information \n            from the *text_layer*. More specifically, adds information \n            about SYNTAX_LABEL, SYNTAX_HEAD and DEPREL to each token \n            in the Text object;\n            \n            (!) Note: this method is added to provide some initial\n            consistency with MaltParser based syntactic parsing;\n            If a better syntactic parsing interface is achieved in\n            the future, this method will be deprecated ...\n        '''\n        j = 0\n        for sentence in text.divide( layer=WORDS, by=SENTENCES ):\n            for i in range(len(sentence)):\n                estnltkToken = sentence[i]\n                vislcg3Token = text_layer[j]\n                parse_found = False\n                if PARSER_OUT in vislcg3Token:\n                    if len( vislcg3Token[PARSER_OUT] ) > 0:\n                        firstParse = vislcg3Token[PARSER_OUT][0]\n                        # Fetch information about the syntactic relation:\n                        estnltkToken['s_label'] = str(i)\n                        estnltkToken['s_head']  = str(firstParse[1])\n                        # Fetch the name of the surface syntactic relation\n                        deprels = '|'.join( [p[0] for p in vislcg3Token[PARSER_OUT]] )\n                        estnltkToken['s_rel']       = deprels\n                        parse_found = True\n                if not parse_found:\n                    raise Exception(\"(!) Unable to retrieve syntactic analysis for the \",\\\n                                    estnltkToken, ' from ', vislcg3Token )\n                j += 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates dependency links from sentence - based linking to clause - based linking.", "response": "def _create_clause_based_dep_links( orig_text, layer=LAYER_CONLL ):\n    '''  Rewrites dependency links in the text from sentence-based linking to clause-\n        based linking: \n          *) words which have their parent outside-the-clause will become root \n             nodes (will obtain link value -1), and \n          *) words which have their parent inside-the-clause will have parent index\n             according to word indices inside the clause;\n         \n    '''\n    sent_start_index = 0\n    for sent_text in orig_text.split_by( SENTENCES ):\n        # 1) Create a mapping: from sentence-based dependency links to clause-based dependency links\n        mapping = dict()\n        cl_ind  = sent_text.clause_indices\n        for wid, word in enumerate(sent_text[WORDS]):\n            firstSyntaxRel = sent_text[layer][wid][PARSER_OUT][0]\n            parentIndex    = firstSyntaxRel[1]\n            if parentIndex != -1:\n                if cl_ind[parentIndex] != cl_ind[wid]:\n                    # Parent of the word is outside the current clause: make root \n                    # node from the current node \n                    mapping[wid] = -1\n                else:\n                    # Find the beginning of the clause \n                    clause_start = cl_ind.index( cl_ind[wid] )\n                    # Find the index of parent label in the clause\n                    j = 0\n                    k = 0\n                    while clause_start + j < len(cl_ind):\n                        if clause_start + j == parentIndex:\n                            break\n                        if cl_ind[clause_start + j] == cl_ind[wid]:\n                            k += 1\n                        j += 1\n                    assert clause_start + j < len(cl_ind), '(!) Parent index not found for: '+str(parentIndex)\n                    mapping[wid] = k\n            else:\n                mapping[wid] = -1\n        # 2) Overwrite old links with new ones\n        for local_wid in mapping.keys():\n            global_wid = sent_start_index + local_wid\n            for syntax_rel in orig_text[layer][global_wid][PARSER_OUT]:\n                syntax_rel[1] = mapping[local_wid]\n        # 3) Advance the index for processing the next sentence\n        sent_start_index += len(cl_ind)\n    return orig_text"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsorting all the analyses in the sentence.", "response": "def __sort_analyses(sentence):\n    ''' Sorts analysis of all the words in the sentence. \n        This is required for consistency, because by default, analyses are \n        listed in arbitrary order; '''\n    for word in sentence:\n        if ANALYSIS not in word:\n            raise Exception( '(!) Error: no analysis found from word: '+str(word) )\n        else:\n            word[ANALYSIS] = sorted(word[ANALYSIS], \\\n                key=lambda x : \"_\".join( [x[ROOT],x[POSTAG],x[FORM],x[CLITIC]] ))\n    return sentence"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert given estnltk Text object into CONLL format and returns as a string.", "response": "def convert_text_to_CONLL( text, feature_generator ):\n    ''' Converts given estnltk Text object into CONLL format and returns as a \n        string.\n        Uses given *feature_generator* to produce fields ID, FORM, LEMMA, CPOSTAG, \n        POSTAG, FEATS for each token.\n        Fields to predict (HEAD, DEPREL) will be left empty.\n        This method is used in preparing parsing & testing data for MaltParser.\n        \n        Parameters\n        -----------\n        text : estnltk.text.Text\n            Morphologically analysed text from which the CONLL file is generated;\n            \n        feature_generator : CONLLFeatGenerator\n            An instance of CONLLFeatGenerator, which has method *generate_features()* \n            for generating morphological features for a single token;\n        \n        The aimed format looks something like this:\n        1\t\u00d6\u00f6\t\u00f6\u00f6\tS\tS\tsg|nom\t_\txxx\t_\t_\n        2\toli\tole\tV\tV\tindic|impf|ps3|sg\t_\txxx\t_\t_\n        3\tt\u00e4iesti\tt\u00e4iesti\tD\tD\t_\t_\txxx\t_\t_\n        4\ttuuletu\ttuuletu\tA\tA\tsg|nom\t_\txxx\t_\t_\n        5\t.\t.\tZ\tZ\tFst\t_\txxx\t_\t_\n    '''\n    from estnltk.text import Text\n    if not isinstance( text, Text ):\n        raise Exception('(!) Unexpected type of input argument! Expected EstNLTK\\'s Text. ')\n    try:\n        granularity = feature_generator.parseScope\n    except AttributeError:\n        granularity = SENTENCES\n    assert granularity in [SENTENCES, CLAUSES], '(!) Unsupported granularity: \"'+str(granularity)+'\"!'\n    sentenceStrs = []\n    for sentence_text in text.split_by( granularity ):\n        sentence_text[WORDS] = __sort_analyses( sentence_text[WORDS] )\n        for i in range(len( sentence_text[WORDS] )):\n            # Generate features  ID, FORM, LEMMA, CPOSTAG, POSTAG, FEATS\n            strForm = feature_generator.generate_features( sentence_text, i )\n            # *** HEAD  (syntactic parent)\n            strForm.append( '_' )\n            strForm.append( '\\t' )\n            # *** DEPREL  (label of the syntactic relation)\n            strForm.append( 'xxx' )\n            strForm.append( '\\t' )\n            # *** PHEAD\n            strForm.append( '_' )\n            strForm.append( '\\t' )\n            # *** PDEPREL\n            strForm.append( '_' )\n            sentenceStrs.append( ''.join( strForm ) )\n        sentenceStrs.append( '' )\n    return '\\n'.join( sentenceStrs )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert_text_w_syntax_to_CONLL( text, feature_generator, layer=LAYER_CONLL ):\n    ''' Converts given estnltk Text object into CONLL format and returns as a \n        string.\n        Uses given *feature_generator* to produce fields ID, FORM, LEMMA, CPOSTAG, \n        POSTAG, FEATS for each token.\n        Fills fields to predict (HEAD, DEPREL) with the syntactic information from\n        given *layer* (default: LAYER_CONLL).\n        This method is used in preparing training data for MaltParser.\n        \n        Parameters\n        -----------\n        text : estnltk.text.Text\n            Morphologically analysed text from which the CONLL file is generated;\n            \n        feature_generator : CONLLFeatGenerator\n            An instance of CONLLFeatGenerator, which has method *generate_features()* \n            for generating morphological features for a single token;\n        \n        layer : str\n            Name of the *text* layer from which syntactic information is to be taken.\n            Defaults to LAYER_CONLL.\n        \n        The aimed format looks something like this:\n        1\t\u00d6\u00f6\t\u00f6\u00f6\tS\tS\tsg|n\t2\t@SUBJ\t_\t_\n        2\toli\tole\tV\tV\ts\t0\tROOT\t_\t_\n        3\tt\u00e4iesti\tt\u00e4iesti\tD\tD\t_\t4\t@ADVL\t_\t_\n        4\ttuuletu\ttuuletu\tA\tA\tsg|n\t2\t@PRD\t_\t_\n        5\t.\t.\tZ\tZ\t_\t4\txxx\t_\t_\n    '''\n    from estnltk.text import Text\n    if not isinstance( text, Text ):\n        raise Exception('(!) Unexpected type of input argument! Expected EstNLTK\\'s Text. ')\n    assert layer in text, ' (!) The layer \"'+layer+'\" is missing form the Text object.'\n    try:\n        granularity = feature_generator.parseScope\n    except AttributeError:\n        granularity = SENTENCES\n    assert granularity in [SENTENCES, CLAUSES], '(!) Unsupported granularity: \"'+str(granularity)+'\"!'\n    sentenceStrs = []\n    if granularity == CLAUSES:\n        _create_clause_based_dep_links( text, layer )\n    for sentence_text in text.split_by( granularity ):\n        sentence_text[WORDS] = __sort_analyses( sentence_text[WORDS] )\n        for i in range(len( sentence_text[WORDS] )):\n            # Generate features  ID, FORM, LEMMA, CPOSTAG, POSTAG, FEATS\n            strForm = feature_generator.generate_features( sentence_text, i )\n            # Get syntactic analysis of the token\n            syntaxToken    = sentence_text[layer][i]\n            firstSyntaxRel = syntaxToken[PARSER_OUT][0]\n            # *** HEAD  (syntactic parent)\n            parentLabel = str( firstSyntaxRel[1] + 1 )\n            strForm.append( parentLabel )\n            strForm.append( '\\t' )\n            # *** DEPREL  (label of the syntactic relation)\n            if parentLabel == '0':\n                strForm.append( 'ROOT' )\n                strForm.append( '\\t' )\n            else:\n                strForm.append( firstSyntaxRel[0] )\n                strForm.append( '\\t' )\n            # *** PHEAD\n            strForm.append( '_' )\n            strForm.append( '\\t' )\n            # *** PDEPREL\n            strForm.append( '_' )\n            sentenceStrs.append( ''.join( strForm ) )\n        sentenceStrs.append( '' )\n    return '\\n'.join( sentenceStrs )", "response": "Converts given estnltk Text object into CONLL format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute Maltparser on given input string and returns the result.", "response": "def _executeMaltparser( input_string, maltparser_dir, maltparser_jar, model_name ):\n    ''' Executes Maltparser on given (CONLL-style) input string, and \n        returns the result. The result is an array of lines from Maltparser's \n        output.\n        \n        Parameters\n        ----------\n        input_string: string\n              input text in CONLL format;\n        maltparser_jar: string\n              name of the Maltparser's jar file that should be executed;\n        model_name: string\n              name of the model that should be used;\n        maltparser_dir: string\n              the directory containing Maltparser's jar and the model file; \n        \n        Few of the ideas were also borrowed from NLTK's MaltParser class,\n        see  http://www.nltk.org/_modules/nltk/parse/malt.html   for the reference;\n    '''\n\n    temp_input_file = \\\n      tempfile.NamedTemporaryFile(prefix='malt_in.', mode='w', delete=False)\n    temp_input_file.close()\n    # We have to open separately here for writing, because Py 2.7 does not support\n    # passing parameter   encoding='utf-8'    to the NamedTemporaryFile;\n    out_f = codecs.open(temp_input_file.name, mode='w', encoding='utf-8')\n    out_f.write( input_string )\n    out_f.close()\n\n    temp_output_file = tempfile.NamedTemporaryFile(prefix='malt_out.', mode='w', delete=False)\n    temp_output_file.close()\n    \n    current_dir = os.getcwd()\n    os.chdir(maltparser_dir)\n    cmd = ['java', '-jar', os.path.join(maltparser_dir, maltparser_jar), \\\n           '-c', model_name, \\\n           '-i', temp_input_file.name, \\\n           '-o', temp_output_file.name, \\\n           '-m', 'parse' ]\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    if p.wait() != 0: \n        raise Exception(' Error on running Maltparser: ', p.stderr.read() )\n    os.chdir(current_dir)\n    \n    results = []\n    in_f = codecs.open(temp_output_file.name, mode='r', encoding='utf-8')\n    for line in in_f:\n        results.append( line.rstrip() )\n    in_f.close()\n\n    if not temp_input_file.closed:\n        raise Exception('Temp input file unclosed!')\n    if not temp_output_file.closed:\n        raise Exception('Temp input file unclosed!')\n    if not out_f.closed:\n        raise Exception('Output file unclosed!')\n    if not in_f.closed:\n        raise Exception('Input file unclosed!')\n    # TODO: For some reason, the method gives \"ResourceWarning: unclosed file\"\n    # in Python 3.4, although, apparently, all file handles seem to be closed;\n    # Nothing seems to be wrong in Python 2.7;\n\n    os.remove(temp_input_file.name)\n    os.remove(temp_output_file.name)\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef loadCONLLannotations( in_file, addDepRels = False, splitIntoSentences = True ):\n    ''' Loads syntactically annotated text from CONLL format input file and \n        returns as an array of tokens, where each token is represented as \n        an array in the format:\n           [sentenceID, wordID, tokenString, morphInfo, selfID, parentID]\n        If addDepRels == True, then the dependency relation label is also extracted\n        and added to the end of the array:\n           [sentenceID, wordID, tokenString, morphInfo, selfID, parentID, depRel]\n        If splitIntoSentences == True, the array of tokens is further divided\n        into subarrays representing sentences.\n        \n         Example input:\n        2\tMonstrumteleskoobid\tMonstrum_tele_skoop\tS\tS\tprop|pl|nom\t0\tROOT\t_\t_\n        3\t(\t(\tZ\tZ\tOpr\t4\txxx\t_\t_\n        4\tmosaiik-\tmosaiik\tA\tA\tpos|sg|nom\t2\t@<AN\t_\t_\n        5\tja\tja\tJ\tJ\tcrd\t6\t@J\t_\t_\n        6\tmitmepeeglilised\tmitme_peegli=line\tA\tA\tpos|pl|nom\t4\t@<NN\t_\t_\n        7\t)\t)\tZ\tZ\tCpr\t6\txxx\t_\t_\n        8\t.\t.\tZ\tZ\tFst\t7\txxx\t_\t_\n        \n    '''\n    sentenceCount   = 0\n    wordCountInSent = 0\n    tokens = []\n    in_f = codecs.open(in_file, mode='r', encoding='utf-8')\n    for line in in_f:\n        line = line.rstrip()\n        if len(line) == 0 or re.match('^\\s+$', line):\n            sentenceCount += 1\n            wordCountInSent = 0\n            continue\n        features = line.split('\\t')\n        if len(features) != 10:\n            raise Exception(' In file '+in_file+', line with unexpected format: \"'+line+'\" ')\n        selfLabel   = features[0]\n        token       = features[1]\n        lemma       = features[2]\n        cpos        = features[3]\n        pos         = features[4]\n        form        = features[5]\n        parentLabel = features[6]\n        tokens.append( [ str(sentenceCount), str(wordCountInSent), \\\n                         token, lemma+\" \"+pos+\" \"+form, selfLabel, parentLabel ] )\n        if addDepRels:\n            tokens[-1].append( features[7] )\n        wordCountInSent += 1\n    in_f.close()\n    if not splitIntoSentences:\n        return tokens\n    else:\n        sentences = []\n        lastSentID = ''\n        for tok in tokens:\n            if tok[0] != lastSentID:\n                sentences.append([])\n            sentences[-1].append(tok)\n            lastSentID = tok[0]\n        return sentences", "response": "Loads syntactically annotated text from CONLL format input file and returns as an array of tokens where each token is represented as a single word and each parent is represented as a single parent."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convertCONLLtoText( in_file, addDepRels = False, verbose = False, **kwargs ):\n    ''' Loads CONLL format data from given input file, and creates\n        estnltk Text objects from the data, one Text per each \n        sentence. Returns a list of Text objects.\n        \n        By default, applies estnltk's morphological analysis, clause \n        detection, and verb chain detection to each input sentence.\n        \n        If addDepRels == True, in addition to SYNTAX_LABEL and SYNTAX_HEAD,\n        surface syntactic function (DEPREL) is also attributed to each \n        token;\n    '''\n    from estnltk.text import Text\n    sentences = loadCONLLannotations( in_file, addDepRels = addDepRels, \\\n                                               splitIntoSentences = True )\n    if verbose:\n        print( str(len(sentences))+' sentences loaded. ')\n    estnltkSentTexts = []\n    for i in range(len(sentences)):\n        s  = sentences[i]\n        sentenceString = \" \".join( [ t[2] for t in s ] )\n        sentText = Text(sentenceString, **kwargs)\n        sentText.tag_analysis()\n        sentText.tag_clauses()\n        sentText.tag_verb_chains()\n        sentText = dict(sentText)\n        if len(sentText[WORDS]) == len(s):\n            # Add the dependency syntactic information\n            for j in range(len(sentText[WORDS])):\n                estnltkWord   = sentText[WORDS][j]\n                depSyntaxWord = s[j]\n                estnltkWord[SYNTAX_LABEL] = depSyntaxWord[4]\n                estnltkWord[SYNTAX_HEAD]  = depSyntaxWord[5]\n                if addDepRels:\n                   estnltkWord[DEPREL] = depSyntaxWord[6]\n            estnltkSentTexts.append( sentText )\n            if verbose:\n                print ('*', end = '')\n        else:\n            if verbose:\n                print(\"The sentence segmentation of dependency syntax differs from the estnltk's sentence segmentation:\", len(sentText[WORDS]), ' vs ',len(s))\n    return estnltkSentTexts", "response": "Load a CONLL file and create a list of estnltk Text objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naugmenting given Text object with the information from Maltparser s output.", "response": "def augmentTextWithCONLLstr( conll_str_array, text ):\n    ''' Augments given Text object with the information from Maltparser's output.\n        More specifically, adds information about SYNTAX_LABEL, SYNTAX_HEAD and\n        DEPREL to each token in the Text object;\n    '''\n    j = 0\n    for sentence in text.divide( layer=WORDS, by=SENTENCES ):\n        sentence = __sort_analyses(sentence)\n        for i in range(len(sentence)):\n            estnltkToken    = sentence[i]\n            maltparserToken = conll_str_array[j]\n            if len( maltparserToken ) > 1:\n                maltParserAnalysis = maltparserToken.split('\\t')\n                if estnltkToken[TEXT] == maltParserAnalysis[1]:\n                    # Fetch information about the syntactic relation:\n                    estnltkToken[SYNTAX_LABEL] = maltParserAnalysis[0]\n                    estnltkToken[SYNTAX_HEAD]  = maltParserAnalysis[6]\n                    # Fetch the name of the surface syntactic relation\n                    estnltkToken[DEPREL]       = maltParserAnalysis[7]\n                else:\n                    raise Exception(\"A misalignment between Text and Maltparser's output: \",\\\n                        estnltkToken, maltparserToken )\n            j += 1\n        j += 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef align_CONLL_with_Text( lines, text, feature_generator, **kwargs ):\n    ''' Aligns CONLL format syntactic analysis (a list of strings) with given EstNLTK's Text \n        object.\n        Basically, for each word position in the Text object, finds corresponding line(s) in\n        the CONLL format output;\n        Returns a list of dicts, where each dict has following attributes:\n          'start'   -- start index of the word in Text;\n          'end'     -- end index of the word in Text;\n          'sent_id' -- index of the sentence in Text, starting from 0;\n          'parser_out' -- list of analyses from the output of the syntactic parser;\n\n        Parameters\n        -----------\n        lines : list of str\n            The input text for the pipeline; Should be the CONLL format syntactic analysis;\n        text : Text\n            EstNLTK Text object containing the original text that was analysed with\n            MaltParser;\n        feature_generator : CONLLFeatGenerator\n            The instance of CONLLFeatGenerator, which was used for generating the input of \n            the MaltParser; If None, assumes a default feature-generator with the scope set\n            to 'sentences';\n        \n        check_tokens : bool\n            Optional argument specifying whether tokens should be checked for match \n            during the alignment. In case of a mismatch, an exception is raised.\n            Default:False\n            \n        add_word_ids : bool\n            Optional argument specifying whether each alignment should include attributes:\n            * 'text_word_id' - current word index in the whole Text, starting from 0;\n            * 'sent_word_id' - index of the current word in the sentence, starting from 0;\n            Default:False\n        \n    ''' \n    from estnltk.text import Text\n    if not isinstance( text, Text ):\n        raise Exception('(!) Unexpected type of input argument! Expected EstNLTK\\'s Text. ')\n    if not isinstance( lines, list ):\n        raise Exception('(!) Unexpected type of input argument! Expected a list of strings.')\n    try:\n        granularity = feature_generator.parseScope\n    except (AttributeError, NameError):\n        granularity = SENTENCES\n    assert granularity in [SENTENCES, CLAUSES], '(!) Unsupported granularity: \"'+str(granularity)+'\"!'\n    check_tokens = False\n    add_word_ids = False\n    for argName, argVal in kwargs.items() :\n        if argName in ['check_tokens', 'check'] and argVal in [True, False]:\n           check_tokens = argVal\n        if argName in ['add_word_ids', 'word_ids'] and argVal in [True, False]:\n           add_word_ids = argVal\n    generalWID = 0\n    sentenceID = 0\n    # Collect clause indices for each sentence (if required)\n    clause_indices = None\n    if granularity == CLAUSES:\n        c = 0\n        all_clause_indices = text.clause_indices\n        clause_indices = []\n        for sentence_words in text.divide( layer=WORDS, by=SENTENCES ):\n            clause_indices.append([])\n            for wid, estnltkToken in enumerate( sentence_words ):\n                clause_indices[-1].append( all_clause_indices[c] )\n                c += 1\n    # Iterate over the sentences and perform the alignment\n    results = []\n    j = 0\n    for sentence_words in text.divide( layer=WORDS, by=SENTENCES ):\n        tokens_to_collect = len( sentence_words )\n        tokens_collected  = 0\n        chunks      = [[]]\n        while j < len(lines):\n            maltparserToken = lines[j]\n            if len( maltparserToken ) > 1 and '\\t' in maltparserToken:\n                # extend the existing clause chunk\n                token_dict = { 't':maltparserToken, \\\n                               'w':(maltparserToken.split('\\t'))[1] }\n                chunks[-1].append( token_dict )\n                tokens_collected += 1\n            else:\n                # create a new clause chunk\n                if len(chunks[-1]) != 0:\n                    chunks.append( [] )\n            j += 1\n            if tokens_to_collect == tokens_collected:\n                break\n        if tokens_to_collect != tokens_collected:  # a sanity check \n            raise Exception('(!) Unable to collect the following sentence from the output of MaltParser: \"'+\\\n                                 str(sentence_words)+'\"')\n        # 2) Put the sentence back together\n        if granularity == SENTENCES:\n            # A. The easy case: sentence-wise splitting was used\n            for wid, estnltkToken in enumerate( sentence_words ):\n                maltparserToken = chunks[0][wid]['t']\n                if check_tokens and estnltkToken[TEXT] != chunks[0][wid]['w']:\n                    raise Exception(\"(!) A misalignment between Text and CONLL: \",\\\n                                    estnltkToken, maltparserToken )\n                # Populate the alignment\n                result_dict = { START:estnltkToken[START], END:estnltkToken[END], \\\n                                SENT_ID:sentenceID, PARSER_OUT: [maltparserToken] }\n                if add_word_ids:\n                    result_dict['text_word_id'] = generalWID # word id in the text\n                    result_dict['sent_word_id'] = wid        # word id in the sentence\n                results.append( result_dict )\n                generalWID += 1\n        elif granularity == CLAUSES:\n            # B. The tricky case: clause-wise splitting was used\n            results_by_wid = {}\n            # B.1  Try to find the location of each chunk in the original text\n            cl_ind = clause_indices[sentenceID]\n            for chunk_id, chunk in enumerate(chunks):\n                firstWord = chunk[0]['w']\n                chunkLen  = len(chunk)\n                estnltk_token_ids = []\n                seen_clause_ids   = {}\n                for wid, estnltkToken in enumerate( sentence_words ):\n                    # Try to recollect tokens of the clause starting from location wid\n                    if estnltkToken[TEXT] == firstWord and \\\n                       wid+chunkLen <= len(sentence_words) and cl_ind[wid] not in seen_clause_ids:\n                        clause_index = cl_ind[wid]\n                        i = wid\n                        while i < len(sentence_words):\n                            if cl_ind[i] == clause_index:\n                                estnltk_token_ids.append( i )\n                            i += 1\n                    # Remember that we have already seen this clause \n                    # (in order to avoid start collecting from the middle of the clause)\n                    seen_clause_ids[cl_ind[wid]] = 1\n                    if len(estnltk_token_ids) == chunkLen:\n                        break\n                    else:\n                        estnltk_token_ids = []\n                if len(estnltk_token_ids) == chunkLen:\n                    # Align the CONLL clause with the clause from the original estnltk Text\n                    for wid, estnltk_wid in enumerate(estnltk_token_ids):\n                        estnltkToken    = sentence_words[estnltk_wid]\n                        maltparserToken = chunk[wid]['t']\n                        if check_tokens and estnltkToken[TEXT] != chunk[wid]['w']:\n                            raise Exception(\"(!) A misalignment between Text and CONLL: \",\\\n                                                 estnltkToken, maltparserToken )\n                        # Convert indices: from clause indices to sentence indices\n                        tokenFields = maltparserToken.split('\\t')\n                        if tokenFields[6] != '0':\n                            in_clause_index = int(tokenFields[6])-1\n                            assert in_clause_index in range(0, len(estnltk_token_ids)), \\\n                                   '(!) Unexpected clause index from CONLL: '+str(in_clause_index)+\\\n                                   ' \\ '+str(len(estnltk_token_ids))\n                            in_sent_index   = estnltk_token_ids[in_clause_index]+1\n                            tokenFields[6]  = str(in_sent_index)\n                        tokenFields[0] = str(estnltk_wid+1)\n                        maltparserToken = '\\t'.join(tokenFields)\n                        # Populate the alignment\n                        result_dict = { START:estnltkToken[START], END:estnltkToken[END], \\\n                                        SENT_ID:sentenceID, PARSER_OUT: [maltparserToken] }\n                        results_by_wid[estnltk_wid] = result_dict\n                else:\n                    raise Exception('(!) Unable to locate the clause in the original input: '+str(chunk))\n            if len(results_by_wid.keys()) != len(sentence_words):\n                raise Exception('(!) Error in aligning Text and CONLL - token counts not matching:'+\\\n                                str(len(results_by_wid.keys()))+ ' vs '+str(len(sentence_words)) )\n            # B.2  Put the sentence back together\n            for wid in sorted(results_by_wid.keys()):\n                if add_word_ids:\n                    results_by_wid[wid]['text_word_id'] = generalWID # word id in the text\n                    results_by_wid[wid]['sent_word_id'] = wid        # word id in the sentence\n                results.append( results_by_wid[wid] )\n                generalWID += 1\n        sentenceID += 1\n    return results", "response": "Aligns a list of lines with a given EstNLTK s Text object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncollect clause with index clause_id from given sentence_text.", "response": "def _get_clause_words( sentence_text, clause_id ):\n    ''' Collects clause with index *clause_id* from given *sentence_text*.\n        Returns a pair (clause, isEmbedded), where:\n         *clause* is a list of word tokens in the clause;\n         *isEmbedded* is a bool indicating whether the clause is embedded;\n    '''\n    clause = []\n    isEmbedded = False\n    indices = sentence_text.clause_indices\n    clause_anno = sentence_text.clause_annotations\n    for wid, token in enumerate(sentence_text[WORDS]):\n        if indices[wid] == clause_id:\n            if not clause and clause_anno[wid] == EMBEDDED_CLAUSE_START:\n                isEmbedded = True\n            clause.append((wid, token))\n    return clause, isEmbedded"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _detect_quotes( sentence_text, wid, fromRight = True ):\n    ''' Searches for quotation marks (both opening and closing) closest to \n        given location in sentence (given as word index *wid*);\n        \n        If *fromRight == True* (default), searches from the right (all the \n        words having index greater than *wid*), otherwise, searches from the \n        left (all the words having index smaller than *wid*);\n        \n        Returns index of the closest quotation mark found, or -1, if none was\n        found;\n    '''\n    i = wid\n    while (i > -1 and i < len(sentence_text[WORDS])):\n        token = sentence_text[WORDS][i]\n        if _pat_starting_quote.match(token[TEXT]) or \\\n           _pat_ending_quote.match(token[TEXT]):\n            return i\n        i += 1 if fromRight else -1\n    return -1", "response": "Detects the quotation marks in a sentence."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef detect_sentence_ending_saying_verbs( edt_sent_text ):\n    ''' Detects cases where a saying verb (potential root of the sentence) ends the sentence.\n\n        We use a simple heuristic: if the given sentence has multiple clauses, and the last main \n        verb in the sentence is preceded by \", but is not followed by \", then the main verb is \n        most likely a saying verb.\n        \n        Examples:\n            \" See oli ainult unes , \" [vaidles] Jan .\n            \" Ma ei maga enam Joogaga ! \" [protesteerisin] .\n            \" Mis m\u00f5ttega te jama suust v\u00e4lja ajate ? \" [l\u00e4ks] Janil n\u00fc\u00fcd juba hari punaseks .\n            \n        Note that the class of saying verbs is open, so we try not rely on a listing of verbs,\n        but rather on the conventional usage patterns of reported speech, indicated by quotation \n        marks.\n        \n        Returns a dict containing word indexes of saying verbs;\n    '''\n    from estnltk.mw_verbs.utils import WordTemplate\n    \n    if not edt_sent_text.is_tagged( VERB_CHAINS ):\n        edt_sent_text.tag_verb_chains()\n\n    saying_verbs = {}\n    if len(edt_sent_text[VERB_CHAINS]) < 2:\n        # Skip sentences that do not have any chains, or \n        #                have only a single verb chain\n        return saying_verbs\n\n    patColon = WordTemplate({'partofspeech':'^[Z]$', 'text': '^:$'})\n        \n    for vid, vc in enumerate( edt_sent_text[VERB_CHAINS] ):\n        #  \n        #  Look only multi-clause sentences, where the last verb chain has length 1\n        # \n        if len(vc['phrase']) == 1 and vid == len(edt_sent_text[VERB_CHAINS])-1:\n            wid   = vc['phrase'][0]\n            token = edt_sent_text[WORDS][wid]\n            clause_id = vc[CLAUSE_IDX]\n            # Find corresponding clause and locations of quotation marks\n            clause, insideEmbeddedCl = _get_clause_words( edt_sent_text, clause_id )\n            quoteLeft  = _detect_quotes( edt_sent_text, wid, fromRight = False )\n            quoteRight = _detect_quotes( edt_sent_text, wid, fromRight = True )\n            #\n            #  Exclude cases, where there are double quotes within the same clause:\n            #     ... ootab iga\u00fcks ,] [kuidas aga k\u00e4hku tagasi \" varrastusse \" <saaks> .]\n            #     ... miljon\u00e4re on ka nende seas ,] [kes oma \u201c papi \u201d mustas \u00e4ris <teenivad>  .]\n            #\n            quotes_in_clause = []\n            for (wid2, token2) in clause:\n                if _pat_starting_quote.match(token2[TEXT]) or \\\n                    _pat_ending_quote.match(token2[TEXT]):\n                    quotes_in_clause.append(wid2)\n            multipleQuotes = len(quotes_in_clause) > 1 and quotes_in_clause[-1]==quoteLeft\n            #    \n            #  If the preceding double quotes are not within the same clause, and\n            #     the verb is not within an embedded clause, and a quotation mark strictly\n            #     precedes, but none follows, then we have most likely a saying verb:\n            #         \" Ma ei tea , \" [kehitan] \u00f5lga .\n            #         \" Miks jumal meid karistab ? \" [m\u00f5tles] sir Galahad .\n            #         \" Kaarsild pole teatavastki elusolend , \" [l\u00f5petasin] arutelu .\n            #\n            if not multipleQuotes and \\\n               not insideEmbeddedCl and \\\n               (quoteLeft != -1 and quoteLeft+1 == wid and quoteRight == -1):\n                saying_verbs[wid] = 'se_saying_verb'\n    return saying_verbs", "response": "Detects cases where a given sentence ends the given text."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads k - sub - category relations from a file.", "response": "def _loadKSubcatRelations( inputFile ):\n    ''' Laeb sisendfailist (inputFile) kaass\u00f5nade rektsiooniseoste mustrid.\n        Iga muster peab olema failis eraldi real, kujul:\n        (s\u00f5nalemma);(s\u00f5naliik);(post|pre);(n\u00f5utud_k\u00e4\u00e4nete_regexp)\n        nt\n            ees;_K_;post;g\n            eest;_K_;post;g\n            enne;_K_;pre;p\n        Tagastab laetud andmed s\u00f5nastikuna;\n    '''\n    kSubCatRelations = dict()\n    in_f = codecs.open(inputFile, mode='r', encoding='utf-8')\n    for line in in_f:\n        line = line.rstrip()\n        if len(line) > 0 and not re.match(\"^#.+$\", line):\n            items = line.split(';')\n            if len(items) == 4:\n                root         = items[0]\n                partofspeech = items[1]\n                postPre      = items[2]\n                morphPattern = items[3]\n                fpattern = '(sg|pl)\\s'+morphPattern\n                if root not in kSubCatRelations:\n                    kSubCatRelations[root] = []\n                kSubCatRelations[root].append( [postPre, fpattern] )\n                root_clean = root.replace('_', '')\n                if root != root_clean:\n                    if root_clean not in kSubCatRelations:\n                        kSubCatRelations[root_clean] = []\n                    kSubCatRelations[root_clean].append( [postPre, fpattern] )\n            else:\n                raise Exception(' Unexpected number of items in the input lexicon line: '+line)\n    in_f.close()\n    return kSubCatRelations"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _detectKsubcatRelType( sentence, i, kSubCatRelsLexicon ):\n    ''' Given the adposition appearing in the sentence at the location i,\n        checks whether the adposition appears in the kSubCatRelsLexicon, \n        and if so, attempts to further detect whether the adposition is a \n        preposition or a postposition;\n         Returns a tuple (string, int), where the first item indicates the\n        type of adposition ('pre', 'post', '_'), and the second item points\n        to its possible child (index of the word in sentence, or -1, if \n        possible child was not detected from close range);\n    ''' \n    curToken = sentence[i]\n    root = curToken[ANALYSIS][0][ROOT]\n    if root in kSubCatRelsLexicon:\n        for [postPre, fpattern] in kSubCatRelsLexicon[root]:\n            if postPre == 'post' and i-1 > -1:\n                lastTokenAnalysis = sentence[i-1][ANALYSIS][0]\n                if re.match(fpattern, lastTokenAnalysis[FORM]):\n                    return ('post', i-1)\n            elif postPre == 'pre' and i+1 < len(sentence):\n                nextTokenAnalysis = sentence[i+1][ANALYSIS][0]\n                if re.match(fpattern, nextTokenAnalysis[FORM]):\n                    return ('pre', i+1)\n        # If the word is not ambiguous between pre and post, but\n        # the possible child was not detected, return only the\n        # post/pre label:\n        if len(kSubCatRelsLexicon[root]) == 1:\n            return (kSubCatRelsLexicon[root][0][0], -1)\n    return ('_', -1)", "response": "Detects the type of the kSubcatRels in the word at the location i."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nattempting to detect all possible K subcategorization relations from a given sentence.", "response": "def _detectPossibleKsubcatRelsFromSent( sentence, kSubCatRelsLexicon, reverseMapping = False ):\n    ''' Attempts to detect all possible K subcategorization relations from\n        given sentence, using the heuristic method _detectKsubcatRelType();\n        \n        Returns a dictionary of relations where the key corresponds to the\n        index of its parent node (the K node) and the value corresponds to \n        index of its child.\n        \n        If reverseMapping = True, the mapping is reversed: keys correspond\n        to children and values correspond to parent nodes (K-s);\n    '''\n    relationIndex = dict()\n    relationType  = dict()\n    for i in range(len(sentence)):\n        estnltkWord = sentence[i]\n        # Pick the first analysis\n        firstAnalysis = estnltkWord[ANALYSIS][0]\n        if firstAnalysis[POSTAG] == 'K':\n            (grammCats, kChild) = _detectKsubcatRelType( sentence, i, kSubCatRelsLexicon )\n            if kChild != -1:\n                if reverseMapping:\n                    relationIndex[ kChild ] = i\n                    relationType[ kChild ]  = grammCats\n                else:\n                    relationIndex[ i ] = kChild\n                    relationType[ i ]  = grammCats\n    return relationIndex, relationType"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds all possible K subcategorization relations from a given sentence and returns a dictionary where the keys correspond to the indices of the tokens that are relevant to the K subcat relations.", "response": "def _findKsubcatFeatures( sentence, kSubCatRelsLexicon, addFeaturesToK = True ):\n    ''' Attempts to detect all possible K subcategorization relations from\n        given sentence, using the heuristic methods _detectKsubcatRelType() \n        and _detectPossibleKsubcatRelsFromSent();\n        \n        Returns a dictionary where the keys correspond to token indices,\n        and values are grammatical features related to K subcat relations.\n        Not all tokens in the sentence are indexed, but only tokens relevant\n        to K subcat relations;\n        \n        If addFeaturesToK == True, grammatical features are added to K-s,\n        otherwise, grammatical features are added to K's child tokens.\n    '''\n    features = dict()\n    # Add features to the K (adposition)\n    if addFeaturesToK:\n        for i in range(len(sentence)):\n            estnltkWord = sentence[i]\n            # Pick the first analysis\n            firstAnalysis = estnltkWord[ANALYSIS][0]\n            if firstAnalysis[POSTAG] == 'K':\n                (grammCats, kChild) = _detectKsubcatRelType( sentence, i, kSubCatRelsLexicon )\n                features[i] = grammCats\n    # Add features to the noun governed by K\n    else:\n        relationIndex, relationType = \\\n            _detectPossibleKsubcatRelsFromSent( sentence, kSubCatRelsLexicon, reverseMapping = True )\n        for i in relationIndex:\n            features[i] = relationType[i]\n    return features"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_features( self, sentence_text, wid ):\n        ''' Generates and returns a list of strings, containing tab-separated\n            features ID, FORM, LEMMA, CPOSTAG, POSTAG, FEATS of the word\n            (the word with index *wid* from the given *sentence_text*).\n\n            Parameters\n            -----------\n            sentence_text : estnltk.text.Text\n                Text object corresponding to a single sentence.\n                Words of the sentence, along with their morphological analyses,\n                should be accessible via the layer WORDS.\n                And each word should be a dict, containing morphological features\n                in ANALYSIS part;\n\n            wid : int\n                Index of the word/token, whose features need to be generated;\n\n        '''\n        assert WORDS in sentence_text and len(sentence_text[WORDS])>0, \\\n               \" (!) 'words' layer missing or empty in given Text!\"\n        sentence = sentence_text[WORDS]\n        assert -1 < wid and wid < len(sentence), ' (!) Invalid word id: '+str(wid)\n\n        # 1) Pre-process (if required)\n        if wid == 0:\n            #  *** Add adposition (_K_) type\n            if self.kSubCatRelsLex:\n                self.kFeatures = \\\n                    _findKsubcatFeatures( sentence, self.kSubCatRelsLex, addFeaturesToK = True )\n            #  *** Add verb chain info\n            if self.addVerbcGramm or self.addNomAdvVinf:\n                self.vcFeatures = generate_verb_chain_features( sentence_text, \\\n                                                                addGrammPred=self.addVerbcGramm, \\\n                                                                addNomAdvVinf=self.addNomAdvVinf )\n            #  *** Add sentence ending saying verbs\n            if self.addSeSayingVerbs:\n                self.sayingverbs = detect_sentence_ending_saying_verbs( sentence_text )\n            #  *** Add clause boundary info\n            if self.addClauseBound:\n                self.clbFeatures = []\n                for tag in sentence_text.clause_annotations:\n                    if not tag:\n                        self.clbFeatures.append( [] )\n                    elif tag == EMBEDDED_CLAUSE_START:\n                        self.clbFeatures.append( ['emb_cl_start'] )\n                    elif tag == EMBEDDED_CLAUSE_END:\n                        self.clbFeatures.append( ['emb_cl_end'] )\n                    elif tag == CLAUSE_BOUNDARY:\n                        self.clbFeatures.append (['clb'] )\n\n        # 2) Generate the features\n        estnltkWord = sentence[wid]\n        # Pick the first analysis\n        firstAnalysis = estnltkWord[ANALYSIS][0]\n        strForm = []\n        # *** ID\n        strForm.append( str(wid+1) )\n        strForm.append( '\\t' )\n        # *** FORM\n        word_text = estnltkWord[TEXT]\n        word_text = word_text.replace(' ', '_')\n        strForm.append( word_text )\n        strForm.append( '\\t' )\n        # *** LEMMA\n        word_root = firstAnalysis[ROOT]\n        word_root = word_root.replace(' ', '_')\n        if len(word_root) == 0:\n            word_root = \"??\"\n        strForm.append( word_root )\n        strForm.append( '\\t' )\n        # *** CPOSTAG\n        strForm.append( firstAnalysis[POSTAG] )\n        strForm.append( '\\t' )\n        # *** POSTAG\n        finePos = firstAnalysis[POSTAG]\n        if self.addAmbiguousPos and len(estnltkWord[ANALYSIS]) > 1:\n            pos_tags = sorted(list(set([ a[POSTAG] for a in estnltkWord[ANALYSIS] ])))\n            finePos  = '_'.join(pos_tags)\n        #if self.kFeatures and wid in self.kFeatures:\n        #    finePos += '_'+self.kFeatures[wid]\n        strForm.append( finePos )\n        strForm.append( '\\t' )\n        # *** FEATS  (grammatical categories)\n        grammCats = []\n        if len(firstAnalysis[FORM]) != 0:\n            forms = firstAnalysis[FORM].split()\n            grammCats.extend( forms )\n        # add features from verb chains:\n        if self.vcFeatures and self.vcFeatures[wid]:\n            grammCats.extend( self.vcFeatures[wid] )\n        # add features from clause boundaries:\n        if self.addClauseBound and self.clbFeatures[wid]:\n            grammCats.extend( self.clbFeatures[wid] )\n        # add adposition type (\"post\" or \"pre\")\n        if self.kFeatures and wid in self.kFeatures:\n            grammCats.extend( [self.kFeatures[wid]] )\n        # add saying verb features\n        if self.sayingverbs and wid in self.sayingverbs:\n            grammCats.extend( [self.sayingverbs[wid]] )\n        # wrap up\n        if not grammCats:\n            grammCats = '_'\n        else:\n            grammCats = '|'.join( grammCats )\n        strForm.append( grammCats )\n        strForm.append( '\\t' )\n        return strForm", "response": "Generates and returns a list of strings containing tab - separated features ID FORM LEMMA CPOSTAG POSTAG FEATS of the word with index wid."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_rules(aes, value):\n    if isinstance(value, six.string_types):\n        return Rules(aes)\n    else:\n        rules = Rules()\n        for idx, (pattern, css_value) in enumerate(value):\n            rules.add_rule(pattern, '{0}_{1}'.format(aes, idx))\n        return rules", "response": "Create a Rules instance for a single aesthetic value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_rule(self, pattern, css_class):\n        #print('adding rule <{0}> <{1}>'.format(pattern, css_class))\n        self.__patterns.append(re.compile(pattern, flags=re.U | re.M))\n        self.__css_classes.append(css_class)", "response": "Adds a new rule to the internal list of patterns and css classes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_css_class(self, value):\n        #print ('get_css_class for {0}'.format(value))\n        for idx, pattern in enumerate(self.__patterns):\n            if pattern.match(value) is not None:\n                #print ('matched rule {0} and returning {1}'.format(idx, self.__css_classes[idx]))\n                return self.__css_classes[idx]\n        return self.__default", "response": "Return the css class of first pattern that matches given value."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_index(index_name, **kwargs):\n    es = elasticsearch.Elasticsearch(**kwargs)\n    es.indices.create(index=index_name, body=mapping)\n    return connect(index_name, **kwargs)", "response": "Creates an index in Elasticsearch and returns it"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_indexable_sentences(document):\n\n        def unroll_lists(list_of_lists):\n            for i in itertools.product(*[set(j) for j in list_of_lists]):\n                yield ' '.join(i)\n\n        sents = document.split_by_sentences()\n        for order, sent in enumerate(sents):\n            postags = list(unroll_lists(sent.postag_lists))\n            lemmas = list(unroll_lists(sent.lemma_lists))\n            text = sent.text\n            words = copy.deepcopy(sent.words)\n            for i in words:\n                del i['start']\n                del i['end']\n\n            sentence = {\n                'estnltk_text_object': json.dumps(sent),\n                'meta': {\n                    'order_in_parent': order\n                },\n                'text': text,\n                'words': words,\n                'postags': postags,\n                'lemmas': lemmas\n            }\n            yield json.dumps(sentence)", "response": "Yields a list of all the indexable sentences in the document."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef apply_templates(toks, templates):\n    for template in templates:\n        name = '|'.join(['%s[%d]' % (f, o) for f, o in template])\n        for t in range(len(toks)):\n            values_list = []\n            for field, offset in template:\n                p = t + offset\n                if p < 0 or p >= len(toks):\n                    values_list = []\n                    break\n                if field in toks[p]:\n                    value = toks[p][field]\n                    values_list.append(value if isinstance(value, (set, list)) else [value])\n            if len(template) == len(values_list):\n                for values in product(*values_list):\n                    toks[t]['F'].append('%s=%s' % (name, '|'.join(values)))", "response": "Generates features for an item sequence by applying feature templates."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts an estnltk JSON - style document to an estner document.", "response": "def json_document_to_estner_document(jsondoc):\n    \"\"\"Convert an estnltk document to an estner document.\n\n    Parameters\n    ----------\n    jsondoc: dict\n        Estnltk JSON-style document.\n\n    Returns\n    -------\n    estnltk.estner.ner.Document\n        A ner document.\n    \"\"\"\n    sentences = []\n    for json_sent in jsondoc.split_by_sentences():\n        snt = Sentence()\n        zipped = list(zip(\n            json_sent.word_texts,\n            json_sent.lemmas,\n            json_sent.root_tokens,\n            json_sent.forms,\n            json_sent.endings,\n            json_sent.postags))\n        json_toks = [{TEXT: text, LEMMA: lemma, ROOT_TOKENS: root_tokens, FORM: form, ENDING: ending, POSTAG: postag}\n                     for text, lemma, root_tokens, form, ending, postag in zipped]\n        # add labels, if they are present\n        for tok, word in zip(json_toks, json_sent.words):\n            if LABEL in word:\n                tok[LABEL] = word[LABEL]\n        for json_tok in json_toks:\n            token = json_token_to_estner_token(json_tok)\n            snt.append(token)\n        if snt:\n            for i in range(1, len(snt)):\n                snt[i - 1].next = snt[i]\n                snt[i].prew = snt[i - 1]\n            sentences.append(snt)\n    return Document(sentences=sentences)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef json_token_to_estner_token(json_token):\n    token = Token()\n    word = json_token[TEXT]\n    lemma = word\n    morph = ''\n    label = 'O'\n    ending = json_token[ENDING]\n    root_toks = json_token[ROOT_TOKENS]\n    if isinstance(root_toks[0], list):\n        root_toks = root_toks[0]\n    lemma = '_'.join(root_toks) + ('+' + ending if ending else '')\n    if not lemma:\n        lemma = word\n    morph = '_%s_' % json_token[POSTAG]\n    morph += ' ' + json_token[FORM]\n    if LABEL in json_token:\n        label = json_token[LABEL]\n    return Token(word, lemma, morph, label)", "response": "Convert a JSON - style word token to an estner token."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_settings(self, settings_module):\n        source = inspect.getsourcefile(settings_module)\n        dest = os.path.join(self.model_dir, 'settings.py')\n        shutil.copyfile(source, dest)", "response": "Copy the settings module to the model_dir directory"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload settings module from the model_dir directory.", "response": "def load_settings(self):\n        \"\"\"Load settings module from the model_dir directory.\"\"\"\n        mname = 'loaded_module'\n        if six.PY2:\n            import imp\n            return imp.load_source(mname, self.settings_filename)\n        else:\n            import importlib.machinery\n            loader = importlib.machinery.SourceFileLoader(mname, self.settings_filename)\n        return loader.load_module(mname)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef train(self, jsondocs, model_dir):\n        modelUtil = ModelStorageUtil(model_dir)\n        modelUtil.makedir()\n        modelUtil.copy_settings(self.settings)\n\n        # Convert json documents to ner documents\n        nerdocs = [json_document_to_estner_document(jsondoc)\n                   for jsondoc in jsondocs]\n\n        self.fex.prepare(nerdocs)\n        self.fex.process(nerdocs)\n\n        self.trainer.train(nerdocs, modelUtil.model_filename)", "response": "Train a NER model using a list of JSON - style documents."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cleanup_lines( lines, **kwargs ):\n    ''' Cleans up annotation after syntactic pre-processing and processing:\n        -- Removes embedded clause boundaries \"<{>\" and \"<}>\";\n        -- Removes CLBC markings from analysis;\n        -- Removes additional information between < and > from analysis;\n        -- Removes additional information between \" and \" from analysis;\n        -- If remove_caps==True , removes 'cap' annotations from analysis;\n        -- If remove_clo==True , removes CLO CLC CLB markings from analysis;\n        -- If double_quotes=='esc'   then \"   will be overwritten with \\\\\";\n           and \n           if double_quotes=='unesc' then \\\\\" will be overwritten with \";\n        -- If fix_sent_tags=True, then sentence tags (<s> and </s>) will be\n           checked for mistakenly added analysis, and found analysis will be\n           removed;\n        \n        Returns the input list, which has been cleaned from additional information;\n    '''\n    if not isinstance( lines, list ):\n        raise Exception('(!) Unexpected type of input argument! Expected a list of strings.')\n    remove_caps   = False\n    remove_clo    = False\n    double_quotes = None\n    fix_sent_tags = False\n    for argName, argVal in kwargs.items() :\n        if argName in ['remove_caps', 'remove_cap']:\n           remove_caps = bool(argVal)\n        if argName == 'remove_clo':\n           remove_clo = bool(argVal)\n        if argName == 'fix_sent_tags':\n           fix_sent_tags = bool(argVal)\n        if argName in ['double_quotes', 'quotes'] and argVal and \\\n           argVal.lower() in ['esc', 'escape', 'unesc', 'unescape']:\n           double_quotes = argVal.lower()\n    pat_token_line     = re.compile('^\"<(.+)>\"\\s*$')\n    pat_analysis_start = re.compile('^(\\s+)\"(.+)\"(\\s[LZT].*)$')\n    i = 0\n    to_delete = []\n    while ( i < len(lines) ):\n        line = lines[i]\n        isAnalysisLine = line.startswith('  ') or line.startswith('\\t')\n        if not isAnalysisLine:\n           removeCurrentTokenAndAnalysis = False\n           #  1) Remove embedded clause boundaries \"<{>\" and \"<}>\"\n           if line.startswith('\"<{>\"'):\n              if i+1 == len(lines) or (i+1 < len(lines) and not '\"{\"' in lines[i+1]):\n                 removeCurrentTokenAndAnalysis = True\n           if line.startswith('\"<}>\"'):\n              if i+1 == len(lines) or (i+1 < len(lines) and not '\"}\"' in lines[i+1]):\n                 removeCurrentTokenAndAnalysis = True\n           if removeCurrentTokenAndAnalysis:\n              # Remove the current token and all the subsequent analyses\n              del lines[i]\n              j=i\n              while ( j < len(lines) ):\n                 line2 = lines[j]\n                 if line2.startswith('  ') or line2.startswith('\\t'):\n                    del lines[j]\n                 else:\n                    break\n              continue\n           #  2) Convert double quotes (if required)\n           if double_quotes:\n              #  '^\"<(.+)>\"\\s*$'\n              if pat_token_line.match( lines[i] ):\n                 token_cleaned = (pat_token_line.match(lines[i])).group(1)\n                 # Escape or unescape double quotes\n                 if double_quotes in ['esc', 'escape']:\n                    token_cleaned = token_cleaned.replace('\"', '\\\\\"')\n                    lines[i] = '\"<'+token_cleaned+'>\"'\n                 elif double_quotes in ['unesc', 'unescape']:\n                    token_cleaned = token_cleaned.replace('\\\\\"', '\"')\n                    lines[i] = '\"<'+token_cleaned+'>\"'\n        else:\n           #  Normalize analysis line\n           lines[i] = re.sub('^\\s{4,}', '\\t', lines[i])\n           #  Remove clause boundary markings\n           lines[i] = re.sub('(.*)\" ([LZT].*) CLBC (.*)', '\\\\1\" \\\\2 \\\\3', lines[i])\n           #  Remove additional information that was added during the analysis\n           lines[i] = re.sub('(.*)\" L([^\"<]*) [\"<]([^@]*) (@.*)', '\\\\1\" L\\\\2 \\\\4', lines[i]) \n           #  Remove 'cap' tags\n           if remove_caps:\n              lines[i] = lines[i].replace(' cap ', ' ')\n           #  Convert double quotes (if required)\n           if double_quotes and double_quotes in ['unesc', 'unescape']:\n              lines[i] = lines[i].replace('\\\\\"', '\"')\n           elif double_quotes and double_quotes in ['esc', 'escape']:\n              m = pat_analysis_start.match( lines[i] )\n              if m:\n                 # '^(\\s+)\"(.+)\"(\\s[LZT].*)$'\n                 start   = m.group(1)\n                 content = m.group(2)\n                 end     = m.group(3)\n                 content = content.replace('\"', '\\\\\"')\n                 lines[i] = ''.join([start, '\"', content, '\"', end])\n           #  Remove CLO CLC CLB markings\n           if remove_clo and 'CL' in lines[i]:\n              lines[i] = re.sub('\\sCL[OCB]', ' ', lines[i])\n              lines[i] = re.sub('\\s{2,}', ' ', lines[i])\n           #  Fix sentence tags that mistakenly could have analysis (in EDT corpus)\n           if fix_sent_tags:\n              if i-1 > -1 and ('\"</s>\"' in lines[i-1] or '\"<s>\"' in lines[i-1]):\n                 lines[i] = ''\n        i += 1\n    return lines", "response": "Removes additional information between CLBC and CLO CLC markings from analysis and returns the input list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naligning a list of lines with a given EstNLTK s Text object.", "response": "def align_cg3_with_Text( lines, text, **kwargs ):\n    ''' Aligns VISLCG3's output (a list of strings) with given EstNLTK\\'s Text object.\n        Basically, for each word position in the Text object, finds corresponding VISLCG3's\n        analyses;\n\n        Returns a list of dicts, where each dict has following attributes:\n          'start'   -- start index of the word in Text;\n          'end'     -- end index of the word in Text;\n          'sent_id' -- index of the sentence in Text, starting from 0;\n          'parser_out' -- list of analyses from the output of the syntactic parser;\n\n        Parameters\n        -----------\n        lines : list of str\n            The input text for the pipeline; Should be in same format as the output\n            of VISLCG3Pipeline;\n\n        text : Text\n            EstNLTK Text object containing the original text that was analysed via \n            VISLCG3Pipeline;\n\n        check_tokens : bool\n            Optional argument specifying whether tokens should be checked for match \n            during the alignment. In case of a mismatch, an exception is raised.\n            Default:False\n        \n        add_word_ids : bool\n            Optional argument specifying whether each alignment should include attributes:\n            * 'text_word_id' - current word index in the whole Text, starting from 0;\n            * 'sent_word_id' - index of the current word in the sentence, starting from 0;\n            Default:False\n\n\n        Example output (for text 'Jah . \u00d6\u00f6 oli t\u00e4iesti tuuletu .'):\n        -----------------------------------------------------------\n        {'sent_id': 0, 'start': 0, 'end': 3, 'parser_out': ['\\t\"jah\" L0 D @ADVL #1->0\\r']}\n        {'sent_id': 0, 'start': 4, 'end': 5, 'parser_out': ['\\t\".\" Z Fst CLB #2->2\\r']}\n        {'sent_id': 1, 'start': 6, 'end': 8, 'parser_out': ['\\t\"\u00f6\u00f6\" L0 S com sg nom @SUBJ #1->2\\r']}\n        {'sent_id': 1, 'start': 9, 'end': 12, 'parser_out': ['\\t\"ole\" Li V main indic impf ps3 sg ps af @FMV #2->0\\r']}\n        {'sent_id': 1, 'start': 13, 'end': 20, 'parser_out': ['\\t\"t\u00e4iesti\" L0 D @ADVL #3->4\\r']}\n        {'sent_id': 1, 'start': 21, 'end': 28, 'parser_out': ['\\t\"tuuletu\" L0 A pos sg nom @PRD #4->2\\r']}\n        {'sent_id': 1, 'start': 29, 'end': 30, 'parser_out': ['\\t\".\" Z Fst CLB #5->5\\r']}\n\n    '''\n    from estnltk.text import Text\n    if not isinstance( text, Text ):\n        raise Exception('(!) Unexpected type of input argument! Expected EstNLTK\\'s Text. ')\n    if not isinstance( lines, list ):\n        raise Exception('(!) Unexpected type of input argument! Expected a list of strings.')\n    check_tokens = False\n    add_word_ids = False\n    for argName, argVal in kwargs.items() :\n        if argName in ['check_tokens', 'check'] and argVal in [True, False]:\n           check_tokens = argVal\n        if argName in ['add_word_ids', 'word_ids'] and argVal in [True, False]:\n           add_word_ids = argVal\n    pat_empty_line     = re.compile('^\\s+$')\n    pat_token_line     = re.compile('^\"<(.+)>\"$')\n    pat_analysis_start = re.compile('^(\\s+)\"(.+)\"(\\s[LZTS].*)$')\n    pat_sent_bound     = re.compile('^(\"<s>\"|\"</s>\"|<s>|</s>)\\s*$')\n    generalWID  = 0\n    sentWID     = 0\n    sentenceID  = 0\n    j = 0\n    # Iterate over the sentences and perform the alignment\n    results = []\n    for sentence in text.divide( layer=WORDS, by=SENTENCES ):\n        sentWID = 0\n        for i in range(len(sentence)):\n            # 1) take the next word in Text\n            wordJson = sentence[i]\n            wordStr  = wordJson[TEXT]\n            cg3word     = None\n            cg3analyses = []\n            # 2) find next word in the VISLCG3's output\n            while (j < len(lines)):\n                # a) a sentence boundary: skip it entirely\n                if pat_sent_bound.match( lines[j] ) and j+1 < len(lines) and \\\n                   (len(lines[j+1])==0 or pat_empty_line.match(lines[j+1])):\n                    j += 2\n                    continue\n                # b) a word token: collect the analyses\n                token_match = pat_token_line.match( lines[j].rstrip() )\n                if token_match:\n                    cg3word = token_match.group(1)\n                    j += 1\n                    while (j < len(lines)):\n                        if pat_analysis_start.match(lines[j]):\n                            cg3analyses.append(lines[j])\n                        else:\n                            break\n                        j += 1\n                    break\n                j += 1\n            # 3) Check whether two tokens match (if requested)\n            if cg3word:\n                if check_tokens and wordStr != cg3word: \n                    raise Exception('(!) Unable to align EstNLTK\\'s token nr ',generalWID,\\\n                                    ':',wordStr,' vs ',cg3word)\n                # Populate the alignment\n                result_dict = { START:wordJson[START], END:wordJson[END], \\\n                                SENT_ID:sentenceID, PARSER_OUT: cg3analyses }\n                if add_word_ids:\n                    result_dict['text_word_id'] = generalWID # word id in the text\n                    result_dict['sent_word_id'] = sentWID    # word id in the sentence\n                results.append( result_dict )\n            else:\n                if j >= len(lines):\n                    print('(!) End of VISLCG3 analysis reached: '+str(j)+' '+str(len(lines)),\\\n                          file = sys.stderr)\n                raise Exception ('(!) Unable to find matching syntactic analysis ',\\\n                                 'for EstNLTK\\'s token nr ', generalWID, ':', wordStr)\n            sentWID    += 1\n            generalWID += 1\n        sentenceID += 1\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the output of a VISL_CG3 based syntactic parsing into CONLL format.", "response": "def convert_cg3_to_conll( lines, **kwargs ):\n    ''' Converts the output of VISL_CG3 based syntactic parsing into CONLL format.\n        Expects that the output has been cleaned ( via method cleanup_lines() ).\n        Returns a list of CONLL format lines;\n        \n        Parameters\n        -----------\n        lines : list of str\n            The input text for the pipeline; Should be in same format as the output\n            of VISLCG3Pipeline;\n\n        fix_selfrefs : bool\n            Optional argument specifying  whether  self-references  in  syntactic \n            dependencies should be fixed;\n            Default:True\n        \n        fix_open_punct : bool\n            Optional argument specifying  whether  opening punctuation marks should \n            be made dependents of the following token;\n            Default:True\n        \n        unesc_quotes : bool\n            Optional argument specifying  whether double quotes should be unescaped\n            in the output, i.e.  converted from '\\\"' to '\"';\n            Default:True\n        \n        rep_spaces : bool\n            Optional argument specifying  whether spaces in a multiword token (e.g. \n            'Rio de Janeiro') should be replaced with underscores ('Rio_de_Janeiro');\n            Default:False\n            \n        error_on_unexp : bool\n            Optional argument specifying  whether an exception should be raised in \n            case of missing or unexpected analysis line; if not, only prints warnings \n            in case of such lines;\n            Default:False\n\n        Example input\n        --------------\n        \"<s>\"\n\n        \"<\u00d6\u00f6>\"\n                \"\u00f6\u00f6\" L0 S com sg nom @SUBJ #1->2\n        \"<oli>\"\n                \"ole\" Li V main indic impf ps3 sg ps af @FMV #2->0\n        \"<t\u00e4iesti>\"\n                \"t\u00e4iesti\" L0 D @ADVL #3->4\n        \"<tuuletu>\"\n                \"tuuletu\" L0 A pos sg nom @PRD #4->2\n        \"<.>\"\n                \".\" Z Fst CLB #5->5\n        \"</s>\"\n\n\n        Example output\n        ---------------\n        1       \u00d6\u00f6      \u00f6\u00f6      S       S       com|sg|nom      2       @SUBJ   _       _\n        2       oli     ole     V       V       main|indic|impf|ps3|sg|ps|af    0       @FMV    _       _\n        3       t\u00e4iesti t\u00e4iesti D       D       _       4       @ADVL   _       _\n        4       tuuletu tuuletu A       A       pos|sg|nom      2       @PRD    _       _\n        5       .       .       Z       Z       Fst|CLB 4       xxx     _       _\n\n\n    '''\n    if not isinstance( lines, list ):\n        raise Exception('(!) Unexpected type of input argument! Expected a list of strings.')\n    fix_selfrefs   = True\n    fix_open_punct = True\n    unesc_quotes   = True\n    rep_spaces     = False\n    error_on_unexp = False\n    for argName, argVal in kwargs.items() :\n        if argName in ['selfrefs', 'fix_selfrefs'] and argVal in [True, False]:\n           fix_selfrefs = argVal\n        if argName in ['fix_open_punct'] and argVal in [True, False]:\n           fix_open_punct = argVal\n        if argName in ['error_on_unexp'] and argVal in [True, False]:\n           error_on_unexp = argVal\n        if argName in ['unesc_quotes'] and argVal in [True, False]:\n           unesc_quotes = argVal\n        if argName in ['rep_spaces'] and argVal in [True, False]:\n           rep_spaces = argVal\n    pat_empty_line    = re.compile('^\\s+$')\n    pat_token_line    = re.compile('^\"<(.+)>\"$')\n    pat_analysis_line = re.compile('^\\s+\"(.+)\"\\s([^\"]+)$')\n    # 3 types of analyses: \n    pat_ending_pos_form = re.compile('^L\\S+\\s+\\S\\s+([^#@]+).+$')\n    pat_pos_form        = re.compile('^\\S\\s+([^#@]+).+$')\n    pat_ending_pos      = re.compile('^(L\\S+\\s+)?\\S\\s+[#@].+$')\n    pat_opening_punct   = re.compile('.+\\s(Opr|Oqu|Quo)\\s')\n    analyses_added = 0\n    conll_lines = []\n    word_id = 1\n    i = 0\n    while ( i < len(lines) ):\n        line = lines[i]\n        # Check, whether it is an analysis line or not\n        if not (line.startswith('  ') or line.startswith('\\t')):\n            # ******  TOKEN\n            if len(line)>0 and not (line.startswith('\"<s>\"') or \\\n               line.startswith('\"</s>\"')) and not pat_empty_line.match(line):\n               # Convert double quotes back to normal form (if requested)\n               if unesc_quotes:\n                  line = line.replace( '\\\\\"', '\"' )\n               # Broken stuff: if previous word was without analysis\n               if analyses_added == 0 and word_id > 1:\n                  # Missing analysis line\n                  if error_on_unexp:\n                      raise Exception('(!) Analysis missing at line '+str(i)+': '+\\\n                                      '\\n'+lines[i-1])\n                  else:\n                      print('(!) Analysis missing at line '+str(i)+': '+\\\n                            '\\n'+lines[i-1], file=sys.stderr)\n                  # Add an empty analysis\n                  conll_lines[-1] += '\\t_'\n                  conll_lines[-1] += '\\tX'\n                  conll_lines[-1] += '\\tX'\n                  conll_lines[-1] += '\\t_'\n                  conll_lines[-1] += '\\t'+str(word_id-2)\n                  conll_lines[-1] += '\\txxx'\n                  conll_lines[-1] += '\\t_'\n                  conll_lines[-1] += '\\t_'\n               # Start of a new token/word\n               token_match = pat_token_line.match( line.rstrip() )\n               if token_match:\n                  word = token_match.group(1)\n               else:\n                  raise Exception('(!) Unexpected token format: ', line)\n               if rep_spaces and re.search('\\s', word):\n                  # Replace spaces in the token with '_' symbols\n                  word = re.sub('\\s+', '_', word)\n               conll_lines.append( str(word_id) + '\\t' + word )\n               analyses_added = 0\n               word_id += 1\n            # End of a sentence\n            if line.startswith('\"</s>\"'):\n                conll_lines.append('')\n                word_id = 1\n        else:\n            # ******  ANALYSIS\n            # If there is more than one pair of \"\", we have some kind of\n            # inconsistency: try to remove extra quotation marks from the \n            # end of the analysis line ...\n            if line.count('\"') > 2:\n                new_line = []\n                q_count = 0\n                for j in range( len(line) ):\n                    if line[j]=='\"' and (j==0 or line[j-1]!='\\\\'):\n                        q_count += 1\n                        if q_count < 3:\n                            new_line.append(line[j])\n                    else:\n                        new_line.append(line[j])\n                line = ''.join( new_line )\n            # Convert double quotes back to normal form (if requested)\n            if unesc_quotes:\n                line = line.replace( '\\\\\"', '\"' )\n            analysis_match = pat_analysis_line.match( line )\n            # Analysis line; in case of multiple analyses, pick the first one;\n            if analysis_match and analyses_added==0:\n                lemma = analysis_match.group(1)\n                cats  = analysis_match.group(2)\n                if cats.startswith('Z '):\n                    postag = 'Z'\n                else:\n                    postag = (cats.split())[1] if len(cats.split())>1 else 'X'\n                deprels = re.findall( '(@\\S+)', cats )\n                deprel  = deprels[0] if deprels else 'xxx'\n                heads   = re.findall( '#\\d+\\s*->\\s*(\\d+)', cats )\n                head    = heads[0] if heads else str(word_id-2)\n                m1 = pat_ending_pos_form.match(cats)\n                m2 = pat_pos_form.match(cats)\n                m3 = pat_ending_pos.match(cats)\n                if m1:\n                    forms = (m1.group(1)).split()\n                elif m2:\n                    forms = (m2.group(1)).split()\n                elif m3:\n                    forms = ['_']  # no form (in case of adpositions and adverbs)\n                else:\n                    # Unexpected format of analysis line\n                    if error_on_unexp:\n                        raise Exception('(!) Unexpected format of analysis line: '+line)\n                    else:\n                        postag = 'X'\n                        forms = ['_']\n                        print('(!) Unexpected format of analysis line: '+line, file=sys.stderr)\n                # If required, fix self-references (in punctuation):\n                if fix_selfrefs and int(head) == word_id-1 and word_id-2>0:\n                    head = str(word_id-2) # add link to the previous word\n                # Fix opening punctuation\n                if fix_open_punct and pat_opening_punct.match(line):\n                    head = str(word_id)   # add link to the following word\n                conll_lines[-1] += '\\t'+lemma\n                conll_lines[-1] += '\\t'+postag\n                conll_lines[-1] += '\\t'+postag\n                conll_lines[-1] += '\\t'+('|'.join(forms))\n                conll_lines[-1] += '\\t'+head\n                conll_lines[-1] += '\\t'+deprel\n                conll_lines[-1] += '\\t_'\n                conll_lines[-1] += '\\t_'\n                analyses_added += 1\n        i += 1\n    return conll_lines"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck whether given vislcg_cmd1 is in system s PATH. Returns True if there is a file named vislcg_cmd1 in the system s PATH otherwise returns False.", "response": "def check_if_vislcg_is_in_path( self, vislcg_cmd1 ):\n        ''' Checks whether given vislcg_cmd1 is in system's PATH. Returns True, there is \n            a file named  vislcg_cmd1  in the path, otherwise returns False;\n\n            The idea borrows from:  http://stackoverflow.com/a/377028\n        '''\n        for path in os.environ[\"PATH\"].split( os.pathsep ):\n            path1 = path.strip('\"')\n            file1 = os.path.join(path1, vislcg_cmd1)\n            if os.path.isfile(file1) or os.path.isfile(file1+'.exe'):\n               return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes the pipeline of subsequent VISL_CG3 commands.", "response": "def process_lines( self, input_lines, **kwargs ):\n        ''' Executes the pipeline of subsequent VISL_CG3 commands. The first process\n            in pipeline gets input_lines as an input, and each subsequent process gets\n            the output of the previous process as an input.\n            \n            The idea of how to construct the pipeline borrows from:\n              https://github.com/estnltk/estnltk/blob/1.4.0/estnltk/syntax/tagger.py\n            \n            Returns the result of the last process in the pipeline, either as a string \n            or, alternatively, as a list of strings (if split_result == True);\n \n            Parameters\n            -----------\n            input_lines : list of str\n                 The input text for the pipeline; Should be in same format as the output\n                 of SyntaxPreprocessing;\n\n            split_result : bool\n                 Optional argument specifying whether the result should be split by \n                 newlines, and returned as a list of strings/lines instead;\n                 Default:False\n\n            remove_info : bool\n                 Optional argument specifying whether the additional information added \n                 during the preprocessing and syntactic processing should be removed\n                 from the results;\n                 Default:True;\n                 The method  cleanup_lines()  will be used for removing additional info,\n                 and all the parameters passed to this method will be also forwarded to \n                 the cleanup method;\n\n        '''\n        split_result_lines = False\n        remove_info = True\n        for argName, argVal in kwargs.items() :\n            if argName in ['split_result_lines', 'split_result'] and argVal in [True, False]:\n               split_result_lines = argVal\n            if argName in ['remove_info', 'info_remover', 'clean_up'] and argVal in [True, False]:\n               remove_info = argVal\n\n        # 1) Construct the input file for the first process in the pipeline\n        temp_input_file = \\\n            tempfile.NamedTemporaryFile(prefix='vislcg3_in.', mode='w', delete=False)\n        temp_input_file.close()\n        # We have to open separately here for writing, because Py 2.7 does not support\n        # passing parameter   encoding='utf-8'    to the NamedTemporaryFile;\n        out_f = codecs.open(temp_input_file.name, mode='w', encoding='utf-8')\n        for line in input_lines:\n            out_f.write( line.rstrip() )\n            out_f.write( '\\n' )\n        out_f.close()\n        # TODO: tempfile is currently used to ensure that the input is in 'utf-8',\n        #       but perhaps we can somehow ensure it without using tempfile ??\n\n\n        # 2) Dynamically construct the pipeline and open processes\n        pipeline = []\n        for i in range( len(self.rules_pipeline) ):\n            rule_file = self.rules_pipeline[i]\n            process_cmd = [self.vislcg_cmd, '-o', '-g', os.path.join(self.rules_dir, rule_file)]\n            process = None\n            if i == 0:\n               # The first process takes input from the file\n               process_cmd.extend( ['-I', temp_input_file.name] )\n               process = Popen(process_cmd, stdin=PIPE, stdout=PIPE)\n            else:\n               # A subsequent process takes output of the last process as an input\n               process = Popen(process_cmd, stdin=pipeline[-1]['process'].stdout, stdout=PIPE)\n            # Record the process\n            process_dict = {'process':process, 'cmd':process_cmd}\n            pipeline.append( process_dict )\n        \n        # 3) Close all stdout streams, except the last one\n        for i in range( len(pipeline) ):\n           if i != len(pipeline) - 1:\n              pipeline[i]['process'].stdout.close()\n\n        # 4) Communicate results form the last item in the pipeline\n        result = as_unicode( pipeline[-1]['process'].communicate()[0] )\n        pipeline[-1]['process'].stdout.close() # Close the last process\n\n        # Clean-up\n        # 1) remove temp file\n        os.remove(temp_input_file.name)\n\n        # 2) remove additional info, if required\n        if remove_info:\n              result = '\\n'.join( cleanup_lines( result.split('\\n'), **kwargs ))\n\n        return result if not split_result_lines else result.split('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a copy from given analysis dict.", "response": "def copy_analysis_dict( analysis ):\n    ''' Creates a copy from given analysis dict. '''\n    assert isinstance(analysis, dict), \"(!) Input 'analysis' should be a dict!\"\n    new_dict = { POSTAG: analysis[POSTAG],\\\n                 ROOT: analysis[ROOT],\\\n                 FORM: analysis[FORM],\\\n                 CLITIC: analysis[CLITIC],\\\n                 ENDING: analysis[ENDING] }\n    if LEMMA in analysis:\n       new_dict[LEMMA] = analysis[LEMMA]\n    if ROOT_TOKENS in analysis:\n       new_dict[ROOT_TOKENS] = analysis[ROOT_TOKENS]\n    return new_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of clause indices for the whole text.", "response": "def get_unique_clause_indices( text ):\n    ''' Returns a list of clause indices for the whole text. For each token in text, \n        the list contains index of the clause the word belongs to, and the indices\n        are unique over the whole text. '''\n    # Add clause boundary annotation (if missing)\n    if not text.is_tagged( CLAUSES ):\n        text.tag_clauses()\n    # Collect (unique) clause indices over the whole text\n    clause_indices = []\n    sent_id = 0\n    for sub_text in text.split_by( SENTENCES ):\n        for word, cl_index in zip( sub_text.words, sub_text.clause_indices ):\n            clause_indices.append( sent_id+cl_index )\n        nr_of_clauses = len(set(sub_text.clause_indices))\n        sent_id += nr_of_clauses\n    assert len(clause_indices) == len(text.words), '(!) Number of clause indices should match nr of words!'\n    return clause_indices"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of unique sentence indices for the whole text.", "response": "def get_unique_sentence_indices( text ):\n    ''' Returns a list of sentence indices for the whole text. For each token in text, \n        the list contains index of the sentence the word belongs to, and the indices\n        are unique over the whole text. '''\n    # Add sentence annotation (if missing)\n    if not text.is_tagged( SENTENCES ):\n        text.tokenize_sentences()\n    # Collect (unique) sent indices over the whole text\n    sent_indices = []\n    sent_id = 0\n    for sub_text in text.split_by( SENTENCES ):\n        for word in sub_text.words:\n            sent_indices.append( sent_id )\n        sent_id += 1\n    assert len(sent_indices) == len(text.words), '(!) Number of sent indices should match nr of words!'\n    return sent_indices"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting nominal categories of the input analysis.", "response": "def _convert_nominal_form( analysis ):\n    ''' Converts nominal categories of the input analysis. \n        Performs one-to-one conversions only. '''\n    assert FORM in analysis, '(!) The input analysis does not contain \"'+FORM+'\" key.'\n    for idx, pattern_items in enumerate(_noun_conversion_rules):\n        pattern_str, replacement = pattern_items\n        if pattern_str in analysis[FORM]:\n           analysis[FORM] = analysis[FORM].replace( pattern_str, replacement )\n    return analysis"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _convert_amb_verbal_form( analysis ):\n    ''' Converts ambiguous verbal categories of the input analysis. \n        Performs one-to-many conversions. '''\n    assert FORM in analysis, '(!) The input analysis does not contain \"'+FORM+'\" key.'\n    results = []\n    for root_pat, pos, form_pat, replacements in _amb_verb_conversion_rules:\n        if analysis[POSTAG] == pos and re.match(root_pat, analysis[ROOT]) and \\\n           re.match(form_pat, analysis[FORM]):\n           for replacement in replacements:\n               new_analysis = copy_analysis_dict( analysis )\n               new_form = re.sub(form_pat, replacement, analysis[FORM])\n               new_analysis[FORM] = new_form\n               results.append( new_analysis )\n           # break after the replacement has been made\n           # ( to avoid over-generation )\n           break\n    if not results:\n       results.append( analysis )\n    return results", "response": "Converts ambiguous verbal form to one - to - many."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts ordinary verbal categories of the input analysis.", "response": "def _convert_verbal_form( analysis ):\n    ''' Converts ordinary verbal categories of the input analysis. \n        Performs one-to-one conversions. '''\n    assert FORM in analysis, '(!) The input analysis does not contain \"'+FORM+'\" key.'\n    for form, replacement in _verb_conversion_rules:\n        # Exact match\n        if analysis[FORM] == form:\n           assert analysis[POSTAG] == 'V', \\\n               '(!) Expected analysis of verb, but got analysis of \"'+str(analysis[POSTAG])+'\" instead.'\n           analysis[FORM] = replacement\n        # Inclusion :   the case of some_prefix+' '+form ;\n        elif analysis[FORM].endswith(' '+form):\n           parts  = analysis[FORM].split()\n           prefix = ' '.join( parts[:len(parts)-1] )\n           analysis[FORM] = prefix+' '+replacement\n    return analysis"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _make_postfixes_1( analysis ):\n    ''' Provides some post-fixes. '''\n    assert FORM in analysis, '(!) The input analysis does not contain \"'+FORM+'\" key.'\n    if 'neg' in analysis[FORM]:\n        analysis[FORM] = re.sub( '^\\s*neg ([^,]*)$',  '\\\\1 Neg',  analysis[FORM] )\n    analysis[FORM] = re.sub( ' Neg Neg$',  ' Neg',  analysis[FORM] )\n    analysis[FORM] = re.sub( ' Aff Neg$',  ' Neg',  analysis[FORM] )\n    analysis[FORM] = re.sub( 'neg',  'Neg',  analysis[FORM] )\n    analysis[FORM] = analysis[FORM].rstrip().lstrip()\n    assert 'neg' not in analysis[FORM], \\\n                 '(!) The label \"neg\" should be removed by now.'\n    assert 'Neg' not in analysis[FORM] or ('Neg' in analysis[FORM] and analysis[FORM].endswith('Neg')), \\\n                 '(!) The label \"Neg\" should end the analysis line: '+str(analysis[FORM])\n    return analysis", "response": "Provides some post - fixes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _keep_analyses( analyses, keep_forms, target_forms ):\n    ''' Filters the given list of *analyses* by morphological forms: \n        deletes analyses that are listed in *target_forms*, but not in \n        *keep_forms*. '''\n    to_delete = []\n    for aid, analysis in enumerate(analyses):\n        delete = False\n        for target in target_forms:\n            if (target == analysis[FORM] and not analysis[FORM] in keep_forms):\n               delete = True\n        if delete:\n            to_delete.append( aid )\n    if to_delete:\n       to_delete.reverse()\n       for aid in to_delete:\n           del analyses[aid]", "response": "Filters the given list of analyses by morphological forms and deletes analyses that are not listed in target_forms but not in keep_forms."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisambiguate forms ambiguous between multiword negation and some other form ;", "response": "def _disambiguate_neg( words_layer ):\n    ''' Disambiguates forms ambiguous between multiword negation and some \n        other form;\n    '''\n    prev_word_lemma = ''\n    for word_dict in words_layer:\n        forms = [ a[FORM] for a in word_dict[ANALYSIS] ]\n        if ('Pers Prs Imprt Sg2' in forms and 'Pers Prs Ind Neg' in forms):\n           if (prev_word_lemma == \"ei\" or prev_word_lemma == \"ega\"):\n               # ei saa, ei tee\n               _keep_analyses( word_dict[ANALYSIS], ['Pers Prs Ind Neg'], ['Pers Prs Imprt Sg2', 'Pers Prs Ind Neg'] )\n           else:\n               # saa! tee! \n               _keep_analyses( word_dict[ANALYSIS], ['Pers Prs Imprt Sg2'], ['Pers Prs Imprt Sg2', 'Pers Prs Ind Neg'] )\n        if ('Pers Prt Imprt' in forms and 'Pers Prt Ind Neg' in forms and 'Pers Prt Prc' in forms):\n           if (prev_word_lemma == \"ei\" or prev_word_lemma == \"ega\"):\n               # ei saanud, ei teinud\n               _keep_analyses( word_dict[ANALYSIS], ['Pers Prt Ind Neg'], ['Pers Prt Imprt','Pers Prt Ind Neg','Pers Prt Prc'] )\n           else:\n               # on, oli saanud teinud; kukkunud \u00f5un; ...\n               _keep_analyses( word_dict[ANALYSIS], ['Pers Prt Prc'], ['Pers Prt Imprt','Pers Prt Ind Neg','Pers Prt Prc'] )\n        if ('Impers Prt Ind Neg' in forms and 'Impers Prt Prc' in forms):\n           if (prev_word_lemma == \"ei\" or prev_word_lemma == \"ega\"):\n               # ei saadud, ei tehtud\n               _keep_analyses( word_dict[ANALYSIS], ['Impers Prt Ind Neg'], ['Impers Prt Ind Neg','Impers Prt Prc'] )\n           else:\n               # on, oli saadud tehtud; saadud \u00f5un; ...\n               _keep_analyses( word_dict[ANALYSIS], ['Impers Prt Prc'], ['Impers Prt Ind Neg','Impers Prt Prc'] )\n        prev_word_lemma = word_dict[ANALYSIS][0][ROOT]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _disambiguate_sid_ksid( words_layer, text, scope=CLAUSES ):\n    ''' Disambiguates verb forms based on existence of 2nd person pronoun ('sina') in given scope.\n        The scope could be either CLAUSES or SENTENCES.\n    '''\n    assert scope in [CLAUSES, SENTENCES], '(!) The scope should be either \"clauses\" or \"sentences\".'\n    group_indices = get_unique_clause_indices( text ) if scope==CLAUSES else get_unique_sentence_indices( text )\n    i = 0\n    gr_2nd_person_pron = {}\n    while i < len( words_layer ):\n        gr_index = group_indices[i]\n        if gr_index not in gr_2nd_person_pron:\n            # 1) Find out whether the current group (clause or sentence) contains \"sina\"\n            j = i\n            gr_2nd_person_pron_found = False\n            while j < len( words_layer ):\n                 if group_indices[j] == gr_index:\n                     forms  = [ a[FORM] for a in words_layer[j][ANALYSIS] ]\n                     lemmas = [ a[ROOT] for a in words_layer[j][ANALYSIS] ]\n                     if 'sina' in lemmas and 'Sg Nom' in forms:\n                        gr_2nd_person_pron_found = True\n                        break\n                 if group_indices[j] >= gr_index+10:  # do not venture too far ...\n                     break\n                 j += 1\n            gr_2nd_person_pron[gr_index] = gr_2nd_person_pron_found\n        forms = [ a[FORM] for a in words_layer[i][ANALYSIS] ]\n        # 2) Disambiguate verb forms based on existence of 'sina' in the clause\n        if ('Pers Prt Ind Pl3 Aff' in forms and 'Pers Prt Ind Sg2 Aff' in forms):    # -sid\n           if not gr_2nd_person_pron[ gr_index ]:\n               _keep_analyses( words_layer[i][ANALYSIS], ['Pers Prt Ind Pl3 Aff'], ['Pers Prt Ind Pl3 Aff', 'Pers Prt Ind Sg2 Aff'] )\n           else:\n               _keep_analyses( words_layer[i][ANALYSIS], ['Pers Prt Ind Sg2 Aff'], ['Pers Prt Ind Pl3 Aff', 'Pers Prt Ind Sg2 Aff'] )\n        if ('Pers Prs Cond Pl3 Aff' in forms and 'Pers Prs Cond Sg2 Aff' in forms):  # -ksid\n           if not gr_2nd_person_pron[ gr_index ]:\n               _keep_analyses( words_layer[i][ANALYSIS], ['Pers Prs Cond Pl3 Aff'], ['Pers Prs Cond Pl3 Aff', 'Pers Prs Cond Sg2 Aff'] )\n           else:\n               _keep_analyses( words_layer[i][ANALYSIS], ['Pers Prs Cond Sg2 Aff'], ['Pers Prs Cond Pl3 Aff', 'Pers Prs Cond Sg2 Aff'] )\n        if ('Pers Prt Cond Pl3 Aff' in forms and 'Pers Prt Cond Sg2 Aff' in forms):  # -nuksid\n           if not gr_2nd_person_pron[ gr_index ]:\n               _keep_analyses( words_layer[i][ANALYSIS], ['Pers Prt Cond Pl3 Aff'], ['Pers Prt Cond Pl3 Aff', 'Pers Prt Cond Sg2 Aff'] )\n           else:\n               _keep_analyses( words_layer[i][ANALYSIS], ['Pers Prt Cond Sg2 Aff'], ['Pers Prt Cond Pl3 Aff', 'Pers Prt Cond Sg2 Aff'] )\n        i += 1", "response": "Disambiguates verb forms based on existence of 2nd person pronoun."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprovide some post - fixes after the disambiguation.", "response": "def _make_postfixes_2( words_layer ):\n    ''' Provides some post-fixes after the disambiguation. '''\n    for word_dict in words_layer:\n        for analysis in word_dict[ANALYSIS]:\n          analysis[FORM] = re.sub( '(Sg|Pl)([123])', '\\\\1 \\\\2', analysis[FORM] )\n    return words_layer"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef convert_analysis( analyses ):\n    ''' Converts a list of analyses (list of dict objects) from FS's vabamorf format to \n        giellatekno (GT) format. \n        Due to one-to-many conversion rules, the number of analyses returned by this method\n        can be greater than the number of analyses in the input list.\n    '''\n    resulting_analyses = []\n    for analysis in analyses:\n        # Make a copy of the analysis\n        new_analyses = [ copy_analysis_dict( analysis ) ]\n        # Convert noun categories\n        new_analyses[0] = _convert_nominal_form( new_analyses[0] )\n        # Convert ambiguous verb categories\n        new_analyses = _convert_amb_verbal_form( new_analyses[0] )\n        # Convert remaining verbal categories\n        new_analyses = [_convert_verbal_form( a ) for a in new_analyses]\n        # Make postfixes\n        new_analyses = [_make_postfixes_1( a ) for a in new_analyses]\n        resulting_analyses.extend( new_analyses )\n    return resulting_analyses", "response": "Converts a list of analyses from FS s vabamorf format to \n        giellatekno ( GT format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef convert_to_gt( text, layer_name=GT_WORDS ):\n    ''' Converts all words in a morphologically analysed Text from FS format to \n        giellatekno (GT) format, and stores in a new layer named GT_WORDS. \n        If the keyword argument *layer_name=='words'* , overwrites the old 'words' \n        layer with the new layer containing GT format annotations. \n\n        Parameters\n        -----------\n        text : estnltk.text.Text\n            Morphologically annotated text that needs to be converted from FS format \n            to GT format;\n        \n        layer_name : str\n            Name of the Text's layer in which GT format morphological annotations \n            are stored; \n            Defaults to GT_WORDS;\n    '''\n    assert WORDS in text, \\\n        '(!) The input text should contain \"'+str(WORDS)+'\" layer.'\n    assert len(text[WORDS])==0 or (len(text[WORDS])>0 and ANALYSIS in text[WORDS][0]), \\\n        '(!) Words in the input text should contain \"'+str(ANALYSIS)+'\" layer.'\n    new_words_layer = []\n    # 1) Perform the conversion\n    for word in text[WORDS]:\n        new_analysis = []\n        new_analysis.extend( convert_analysis( word[ANALYSIS] ) )\n        new_words_layer.append( {TEXT:word[TEXT], ANALYSIS:new_analysis, START:word[START], END:word[END]} )\n    # 2) Perform some context-specific disambiguation\n    _disambiguate_neg( new_words_layer )\n    _disambiguate_sid_ksid( new_words_layer, text, scope=CLAUSES )\n    _disambiguate_sid_ksid( new_words_layer, text, scope=SENTENCES )\n    _make_postfixes_2( new_words_layer )\n    # 3) Attach the layer\n    if layer_name != WORDS:\n        #  Simply attach the new layer\n        text[layer_name] = new_words_layer\n    else:\n        #  Perform word-by-word replacements\n        # (because simple attaching won't work here)\n        for wid, new_word in enumerate( new_words_layer ):\n            text[WORDS][wid] = new_word\n    return text", "response": "Converts all words in a morphologically analysed Text from FS format to GT format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the analysis dict from the input root pos and form.", "response": "def get_analysis_dict( root, pos, form ):\n    '''  Takes *root*, *pos* and *form* from Filosoft's mrf input and reformats as \n         EstNLTK's analysis dict:\n          {\n             \"clitic\":       string,\n             \"ending\":       string,\n             \"form\":         string,\n             \"partofspeech\": string,\n             \"root\":         string\n          },\n         Returns the dict;\n    ''' \n    import sys\n    result = { CLITIC:\"\", ENDING:\"\", FORM:form, POSTAG:pos, ROOT:\"\" }\n    breakpoint = -1\n    for i in range(len(root)-1, -1, -1):\n        if root[i] == '+':\n            breakpoint = i\n            break\n    if breakpoint == -1:\n        result[ROOT]   = root\n        result[ENDING] = \"0\"\n        if not re.match(\"^\\W+$\", root):\n            try:\n                print( \" No breakpoint found from: \", root, pos, form, file=sys.stderr )\n            except UnicodeEncodeError:\n                print( \" No breakpoint found from input *root*!\",  file=sys.stderr )\n    else:\n        result[ROOT]   = root[0:breakpoint]\n        result[ENDING] = root[breakpoint+1:]\n    if result[ENDING].endswith('ki') and len(result[ENDING]) > 2:\n        result[CLITIC] = 'ki'\n        result[ENDING] = re.sub('ki$', '', result[ENDING])\n    if result[ENDING].endswith('gi') and len(result[ENDING]) > 2:\n        result[CLITIC] = 'gi'\n        result[ENDING] = re.sub('gi$', '', result[ENDING])\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_text_from_idx_file( file_name, layer_name=WORDS, keep_init_lines=False ):\n    ''' Reads IDX format morphological annotations from given file, and returns as a Text \n        object.\n        \n        The Text object will be tokenized for paragraphs, sentences, words, and it will\n        contain morphological annotations in the layer *layer_name* (by default: WORDS);\n        \n        Parameters\n        -----------\n        file_name : str\n            Name of the input file; Should contain IDX format text segmentation and \n            morphological annotation;\n        \n        keep_init_lines : bool\n            Optional argument specifying whether the lines from the file should also be\n            preserved on a special layer named 'init_lines';\n            Default: False\n        \n        layer_name : str\n            Name of the Text's layer in which morphological annotations from text are \n            stored; \n            Defaults to WORDS;\n    \n        Example: expected format of the input:\n          129\t1\t1\t\"\t\"\t\"\tZ\t\n          129\t2\t1\tMul\tmina\tmina+l\tP\tsg ad\n          129\t3\t1\ton\tolema\tole+0\tV\tb\n          129\t3\t1\ton\tolema\tole+0\tV\tvad\n          129\t4\t1\tpalju\tpalju\tpalju+0\tD\t\n          129\t5\t1\tigasugust\tigasugune\tiga_sugune+t\tP\tsg p\n          129\t6\t1\tinformatsiooni\tinformatsioon\tinformatsioon+0\tS\tsg p\n          129\t7\t1\t.\t.\t.\tZ\t\n        \n    '''\n    from nltk.tokenize.simple import LineTokenizer\n    from nltk.tokenize.regexp import RegexpTokenizer\n    from estnltk import Text\n    # 1) Collect the text along with morphological analyses from the input IDX file\n    init_lines = []\n    words      = []\n    sentence   = []\n    sentences  = []\n    prev_sent_id = -1\n    prev_word_id = -1\n    in_f = codecs.open(file_name, mode='r', encoding='utf-8')\n    for line in in_f:\n        fields = line.split('\\t')\n        assert len(fields) == 8, '(!) Unexpected number of fields in the line: '+str(len(fields))\n        sent_id   = fields[0]\n        word_id   = fields[1]\n        clause_id = fields[2]\n        token     = fields[3]\n        if prev_sent_id != sent_id:\n            # Record the old sentence, start a new \n            if sentence:\n               sentences.append( '  '.join(sentence) )\n            sentence = []\n        if prev_word_id != word_id:\n            # Record a new token\n            sentence.append( token )\n            word = { TEXT:token, ANALYSIS:[] }\n            words.append(word)\n        # Augment the last word in the list with new analysis\n        lemma  = fields[4]\n        root   = fields[5]\n        pos    = fields[6]\n        form   = fields[7].rstrip()\n        ending = ''\n        clitic = ''\n        analysis = get_analysis_dict( root, pos, form )\n        analysis[LEMMA] = lemma\n        words[-1][ANALYSIS].append( analysis )\n        prev_sent_id = sent_id\n        prev_word_id = word_id\n        if keep_init_lines:\n            init_lines.append( [sent_id+' '+word_id, line] )\n    in_f.close()\n    if sentence:\n        # Record the last sentence\n        sentences.append( '  '.join(sentence) )\n\n    # 2) Construct the estnltk's Text\n    kwargs4text = {\n      # Use custom tokenization utils in order to preserve exactly the same \n      # tokenization as was in the input;\n      \"word_tokenizer\":     RegexpTokenizer(\"  \", gaps=True),\n      \"sentence_tokenizer\": LineTokenizer()\n    }\n    from estnltk.text import Text\n    text = Text( '\\n'.join(sentences), **kwargs4text )\n    # Tokenize up to the words layer\n    text.tokenize_words()\n\n    # 3) Create a new layer with morphological analyses, or \n    #    populate the old layer with morphological analyses;\n    assert len(text[WORDS]) == len(words), \\\n        '(!) Number of words from input does not match with the number of words in EstNLTK Text: '+\\\n             str(len(text[WORDS]) )+' != '+str(len(words))\n    if layer_name != WORDS:\n        # If necessary, create a new layer duplicating the WORDS layer\n        text[layer_name] = []\n        for word in text[WORDS]:\n            text[layer_name].append({START:word[START], END:word[END], TEXT:word[TEXT]})\n    # Copy morphological analyses to the new layer / populate the old layer\n    for wid, word in enumerate( text[WORDS] ):\n        text[layer_name][wid][ANALYSIS] = words[wid][ANALYSIS]\n    if layer_name == WORDS:    \n        assert text.is_tagged(ANALYSIS), '(!) The layer of analysis should exist by now!'\n    \n    if keep_init_lines:\n        # Preserve the initial lines from file in a separate layer\n        text['init_lines'] = []\n        i = 0\n        for wid, word in enumerate( text[layer_name] ):\n            words_lines = []\n            # collect lines associated with the word\n            while i < len(init_lines):\n                [lid, line] = init_lines[i]\n                if not words_lines or words_lines[-1][0]==lid:\n                    words_lines.append([lid, line])\n                else:\n                    break\n                i += 1\n            # record lines\n            text['init_lines'].append( \\\n                {START:word[START], END:word[END], 'lines':[l[1] for l in words_lines]} )\n        assert len(text['init_lines']) == len(text[layer_name]), \\\n            '(!) The number of initial lines should match the number of words in text!'\n    return text", "response": "Reads the text from an IDX file and returns as a Text object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_original_vs_converted_diff( original ,converted ):\n    '''  Compares the *original* text to *converted* text, and detects changes/differences in \n        morphological annotations. \n\n        The method constructs line-by-line comparison string, where lines are separated by \n        newline, and '***' at the beginning of the line indicates the difference.\n\n        Returns a pair: results of the line-by-line comparison as a string, and boolean value\n        indicating whether there were any differences.\n    '''\n    from estnltk.syntax.syntax_preprocessing import convert_Text_to_mrf\n    old_layer_mrf = convert_Text_to_mrf( original )\n    new_layer_mrf = convert_Text_to_mrf( converted )\n    max_len_1 = max([len(l) for l in old_layer_mrf ])\n    max_len_2 = max([len(l) for l in new_layer_mrf ])\n    max_len   = max( max_len_1, max_len_2 )\n    format_str = '{:<'+str(max_len+1)+'}'\n    i = 0\n    j = 0\n    comp_lines = []\n    diff_found = False\n    while(i < len(old_layer_mrf) or j < len(new_layer_mrf)):\n         l1 = old_layer_mrf[i]\n         l2 = new_layer_mrf[j]\n         # 1) Output line containing tokens\n         if not l1.startswith(' ') and not l2.startswith(' '):\n            diff = '*** ' if format_str.format(l1) != format_str.format(l2) else '    '\n            comp_lines.append( diff+format_str.format(l1)+format_str.format(l2) )\n            if diff == '*** ':\n                 diff_found = True\n            i += 1\n            j += 1\n         else:\n            # 2) Output analysis line(s)\n            while(i < len(old_layer_mrf) or j < len(new_layer_mrf)):\n                 l1 = old_layer_mrf[i]\n                 l2 = new_layer_mrf[j]\n                 if l1.startswith(' ') and l2.startswith(' '):\n                    diff = '*** ' if format_str.format(l1) != format_str.format(l2) else '    '\n                    comp_lines.append( diff+format_str.format(l1)+format_str.format(l2) )\n                    if diff == '*** ':\n                       diff_found = True\n                    i += 1\n                    j += 1\n                 elif l1.startswith(' ') and not l2.startswith(' '):\n                    diff = '*** '\n                    comp_lines.append( diff+format_str.format(l1)+format_str.format(' ') )\n                    diff_found = True\n                    i += 1\n                 elif not l1.startswith(' ') and l2.startswith(' '):\n                    diff = '*** '\n                    comp_lines.append( diff+format_str.format(' ')+format_str.format(l2) )\n                    diff_found = True\n                    j += 1\n                 else:\n                    break\n    return '\\n'.join( comp_lines ), diff_found", "response": "Returns a string that contains the differences between the original and converted text."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves redundant verb chains from the given list of found verbs.", "response": "def removeRedundantVerbChains( foundChains, removeOverlapping = True, removeSingleAraAndEi = False ):\r\n    ''' Eemaldab yleliigsed verbiahelad: ahelad, mis katavad osaliselt v6i t2ielikult \r\n        teisi ahelaid (removeOverlapping == True), yhes6nalised 'ei' ja '\u00e4ra' ahelad (kui \r\n        removeSingleAraAndEi == True);\r\n        \r\n         Yldiselt on nii, et ylekattuvaid ei tohiks palju olla, kuna fraaside laiendamisel\r\n        pyytakse alati kontrollida, et laiendus ei kattuks m6ne olemasoleva fraasiga;\r\n        Peamiselt tekivad ylekattuvused siis, kui morf analyysi on sattunud valed \r\n        finiitverbi analyysid (v6i analyysid on j22nud mitmesteks) ja seega tuvastatakse \r\n        osalausest rohkem finiitverbe, kui oleks vaja.\r\n         Heuristik: kahe ylekattuva puhul j2tame alles fraasi, mis algab eespool ning \r\n        m2rgime sellel OTHER_VERBS v22rtuseks True, mis m2rgib, et kontekstis on mingi\r\n        segadus teiste verbidega.\r\n    '''\r\n    toDelete = []\r\n    for i in range(len(foundChains)):\r\n        matchObj1 = foundChains[i]\r\n        if removeOverlapping:\r\n            for j in range(i+1, len(foundChains)):\r\n                matchObj2 = foundChains[j]\r\n                if matchObj1 != matchObj2 and matchObj1[CLAUSE_IDX] == matchObj2[CLAUSE_IDX]:\r\n                    phrase1 = set(matchObj1[PHRASE])\r\n                    phrase2 = set(matchObj2[PHRASE])\r\n                    intersect = phrase1.intersection(phrase2)\r\n                    if len(intersect) > 0:\r\n                        #  Yldiselt on nii, et ylekattuvaid ei tohiks olla, kuna fraaside laiendamisel\r\n                        # pyytakse alati kontrollida, et laiendus ei kattuks m6ne olemasoleva fraasiga;\r\n                        #  Peamiselt tekivad ylekattuvused siis, kui morf analyysil on finiitverbi \r\n                        # analyysidesse j22nud sisse mitmesused (v6i on sattunud valed analyysid) ja \r\n                        # seega tuvastatakse osalausest rohkem finiitverbe, kui oleks vaja.\r\n                        #  Heuristik: j2tame alles fraasi, mis algab eespool ning lisame selle otsa\r\n                        # kysim2rgi (kuna pole kindel, et asjad on korras)\r\n                        minWid1 = min(matchObj1[PHRASE])\r\n                        minWid2 = min(matchObj2[PHRASE])\r\n                        if minWid1 < minWid2:\r\n                            matchObj1[OTHER_VERBS] = True\r\n                            toDelete.append(j)\r\n                        else:\r\n                            matchObj2[OTHER_VERBS] = True\r\n                            toDelete.append(i)\r\n        if removeSingleAraAndEi:\r\n            if ( len(matchObj1[PATTERN])==1 and re.match('^(ei|\u00e4ra)$', matchObj1[PATTERN][0]) ):\r\n                toDelete.append(i)\r\n    if toDelete:\r\n        if len(set(toDelete)) != len(toDelete):\r\n            toDelete = list(set(toDelete))  # Eemaldame duplikaadid\r\n        toDelete = [ foundChains[i] for i in toDelete ]\r\n        for verbObj in toDelete:\r\n            foundChains.remove(verbObj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addGrammaticalFeatsAndRoots( sentence, foundChains ):\r\n    ''' T\u00e4iendab leitud verbiahelaid, lisades iga ahela kylge selle s6nade lemmad (ROOT \r\n        v2ljad morf analyysist) ning morfoloogilised tunnused (POSTAG+FORM: eraldajaks \r\n        '_' ning kui on mitu varianti, siis tuuakse k6ik variandid, eraldajaks '/');\r\n        Atribuudid ROOTS ja MORPH sisaldavad tunnuste loetelusid (iga ahela liikme jaoks \r\n        yks tunnus:\r\n         Nt.  \r\n           ** 'p\u00fc\u00fcab kodeerida' puhul tuleb MORPH v\u00e4\u00e4rtuseks ['V_b', 'V_da'] ning\r\n              ROOTS v\u00e4\u00e4rtuseks ['p\u00fc\u00fcd', 'kodeeri'];\r\n           ** 'on tulnud' puhul tuleb MORPH v\u00e4\u00e4rtuseks ['V_vad/b', 'V_nud'] ning\r\n              ROOTS v\u00e4\u00e4rtuseks ['ole', 'tule'];\r\n\r\n         Lisaks leiatakse ahela p6hiverbi (esimese verbi) grammatilised tunnused: \r\n           ** aeg (TENSE):       present, imperfect, perfect, pluperfect, past, ??\r\n           ** k6neviis (MOOD):   indic, imper, condit, quotat, ??\r\n           ** tegumood (VOICE):  personal, impersonal, ??\r\n    '''\r\n    _indicPresent     = ['n','d','b','me','te','vad']\r\n    _indicImperfect   = ['sin', 'sid', 's', 'sime', 'site', 'sid']\r\n    _imperatPlural    = ['gem', 'ge', 'gu']\r\n    _conditPreesens   = ['ksin', 'ksid', 'ks', 'ksime', 'ksite', 'ksid']\r\n    _conditPreteerium = ['nuksin', 'nuksid', 'nuks', 'nuksime', 'nuksite', 'nuksid']\r\n    for i in range(len(foundChains)):\r\n        matchObj1 = foundChains[i]\r\n        roots = []\r\n        grammFeats = []\r\n        grammPosAndForms = []\r\n        #\r\n        # 1) Leiame kogu ahela morfoloogilised tunnused ja lemmad\r\n        #\r\n        for j in range(len( matchObj1[PHRASE] )):\r\n            wid = matchObj1[PHRASE][j]\r\n            token = [token for token in sentence if token[WORD_ID]==wid][0]\r\n            analysisIDs = matchObj1[ANALYSIS_IDS][j]\r\n            analyses = [ token[ANALYSIS][k] for k in range(len( token[ANALYSIS] )) if k in analysisIDs ]\r\n            pos  = set( [a[POSTAG] for a in analyses] )\r\n            form = set( [a[FORM] for a in analyses] )\r\n            root = [a[ROOT] for a in analyses][0]\r\n            grammatical = (\"/\".join(list(pos))) + '_' + (\"/\".join(list(form)))\r\n            grammPosAndForms.append( (pos, form) )\r\n            #  Yhtlustame m6ningaid mustreid (st kohendame nende morf analyysi selliseks, nagu\r\n            # mustri poolt on eeldatud) ...\r\n            if root == 'ei' and len(matchObj1[PHRASE])>1:\r\n                grammatical = 'V_neg'\r\n            if matchObj1[PATTERN][j] == '&':\r\n                grammatical = 'J_'\r\n            roots.append( root )\r\n            grammFeats.append( grammatical )\r\n        matchObj1[ROOTS] = roots\r\n        matchObj1[MORPH] = grammFeats\r\n        #\r\n        # 2) Leiame eelneva p\u00f5hjal ahela p\u00f5hiverbi tunnused:  grammatilise aja (tense),  \r\n        #      k\u00f5neviisi (mood),  tegumoe (voice)\r\n        #\r\n        tense = \"??\"\r\n        mood  = \"??\"\r\n        voice = \"??\"\r\n        if matchObj1[POLARITY] == 'POS':\r\n            #\r\n            #   Jaatuse tunnused\r\n            #\r\n            (pos, form) = grammPosAndForms[0]\r\n            if 'V' in pos:\r\n                #\r\n                #  Indikatiiv e kindel k\u00f5neviis\r\n                #\r\n                if len(form.intersection( _indicPresent )) > 0:\r\n                    tense = \"present\"\r\n                    mood  = \"indic\"\r\n                    voice = \"personal\"\r\n                elif len(form.intersection( _indicImperfect )) > 0:\r\n                    tense = \"imperfect\"\r\n                    mood = \"indic\"\r\n                    voice = \"personal\"\r\n                elif 'takse' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"indic\"\r\n                    voice = \"impersonal\"\r\n                elif 'ti' in form:\r\n                    tense = \"imperfect\"\r\n                    mood  = \"indic\"\r\n                    voice = \"impersonal\"\r\n                #\r\n                #  Imperatiiv e k\u00e4skiv k\u00f5neviis\r\n                #\r\n                elif 'o' in form or 'gu' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"imper\"\r\n                    voice = \"personal\"\r\n                elif len(form.intersection( _imperatPlural )) > 0:\r\n                    tense = \"present\"\r\n                    mood  = \"imper\"\r\n                    voice = \"personal\"\r\n                elif 'tagu' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"imper\"\r\n                    voice = \"impersonal\"\r\n                #\r\n                #  Konditsionaal e tingiv k\u00f5neviis\r\n                #\r\n                elif len(form.intersection( _conditPreesens )) > 0:\r\n                    tense = \"present\"\r\n                    mood  = \"condit\"\r\n                    voice = \"personal\"\r\n                elif 'taks' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"condit\"\r\n                    voice = \"impersonal\"\r\n                elif len(form.intersection( _conditPreteerium )) > 0:\r\n                    tense = \"past\"\r\n                    mood  = \"condit\"\r\n                    voice = \"personal\"\r\n                elif 'tuks' in form:\r\n                    tense = \"past\"\r\n                    mood  = \"condit\"\r\n                    voice = \"impersonal\"\r\n                #\r\n                #  Kvotatiiv e kaudne k\u00f5neviis\r\n                #\r\n                elif 'vat' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"quotat\"\r\n                    voice = \"personal\"\r\n                elif 'tavat' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"quotat\"\r\n                    voice = \"impersonal\"\r\n                elif 'nuvat' in form:\r\n                    tense = \"past\"\r\n                    mood  = \"quotat\"\r\n                    voice = \"personal\"\r\n                elif 'tuvat' in form:\r\n                    tense = \"past\"\r\n                    mood  = \"quotat\"\r\n                    voice = \"impersonal\"\r\n                #\r\n                #  Liitaeg: olema + nud (personaal), olema + tud (impersonaal)\r\n                #\r\n                if len(matchObj1[PATTERN]) > 1 and matchObj1[PATTERN][0] == 'ole':\r\n                    # Kindla k\u00f5neviisi liitaeg\r\n                    if mood == \"indic\" and (grammFeats[1] == \"V_nud\" or grammFeats[1] == \"V_tud\"):\r\n                        if tense == \"present\":\r\n                            #  T\u00e4isminevik\r\n                            tense = \"perfect\"\r\n                            if grammFeats[1] == \"V_tud\":\r\n                                voice = \"impersonal\"\r\n                        elif tense == \"imperfect\":\r\n                            #  Enneminevik\r\n                            tense = \"pluperfect\"\r\n                            if grammFeats[1] == \"V_tud\":\r\n                                voice = \"impersonal\"\r\n                    # Tingiva ja kaudse k\u00f5neviisi liitaeg (nn \u00fcldminevik)\r\n                    elif mood in [\"quotat\", \"condit\"] and tense == \"present\" and \\\r\n                         voice == \"personal\":\r\n                            if grammFeats[1] == \"V_nud\":\r\n                                tense = \"past\"\r\n                            elif grammFeats[1] == \"V_tud\":\r\n                                if mood == \"quotat\":\r\n                                    tense = \"past\"\r\n                                    voice = \"impersonal\"\r\n                                else:\r\n                                    # tingiv + tud j\u00e4\u00e4b esialgu lahtiseks\r\n                                    tense = \"??\"\r\n                                    voice = \"??\"\r\n        elif matchObj1[POLARITY] == 'NEG':\r\n            #\r\n            #   Eituse tunnused\r\n            #\r\n            if len(matchObj1[PATTERN]) > 1 and \\\r\n               (matchObj1[PATTERN][0] == 'ei' or matchObj1[PATTERN][0] == 'ega'):\r\n                (pos, form) = grammPosAndForms[1]\r\n                # Indikatiiv\r\n                if 'o' in form or 'neg o' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"indic\"\r\n                    voice = \"personal\"\r\n                elif 'ta' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"indic\"\r\n                    voice = \"impersonal\"\r\n                elif 'nud' in form:\r\n                    tense = \"imperfect\"\r\n                    mood  = \"indic\"\r\n                    voice = \"personal\"\r\n                elif 'tud' in form:\r\n                    tense = \"imperfect\"\r\n                    mood  = \"indic\"\r\n                    voice = \"impersonal\"\r\n                # Konditsionaal\r\n                elif 'ks' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"condit\"\r\n                    voice = \"personal\"\r\n                elif 'taks' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"condit\"\r\n                    voice = \"impersonal\"\r\n                elif 'nuks' in form:\r\n                    tense = \"past\"\r\n                    mood  = \"condit\"\r\n                    voice = \"personal\"\r\n                elif 'tuks' in form:\r\n                    tense = \"past\"\r\n                    mood  = \"condit\"\r\n                    voice = \"impersonal\"\r\n                # Kvotatiiv\r\n                elif 'vat' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"quotat\"\r\n                    voice = \"personal\"\r\n                elif 'tavat' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"quotat\"\r\n                    voice = \"impersonal\"\r\n                elif 'nuvat' in form:\r\n                    tense = \"past\"\r\n                    mood  = \"quotat\"\r\n                    voice = \"personal\"\r\n                elif 'tuvat' in form:\r\n                    tense = \"past\"\r\n                    mood  = \"quotat\"\r\n                    voice = \"impersonal\"\r\n                #\r\n                #  Liitaeg: ei + olema + nud (personaal), ei + olema + tud (impersonaal)\r\n                #\r\n                if len(matchObj1[PATTERN]) > 2 and matchObj1[PATTERN][1] == 'ole':\r\n                    # Kindla k\u00f5neviisi liitaeg\r\n                    if mood == \"indic\" and (grammFeats[2] == \"V_nud\" or grammFeats[2] == \"V_tud\"):\r\n                        if tense == \"present\":\r\n                            #  T\u00e4isminevik\r\n                            tense = \"perfect\"\r\n                            if grammFeats[2] == \"V_tud\":\r\n                                voice = \"impersonal\"\r\n                        elif tense == \"imperfect\":\r\n                            #  Enneminevik\r\n                            tense = \"pluperfect\"\r\n                            if grammFeats[2] == \"V_tud\":\r\n                                voice = \"impersonal\"\r\n                    # Tingiva ja kaudse k\u00f5neviisi liitaeg (nn \u00fcldminevik)\r\n                    elif mood in [\"quotat\", \"condit\"] and tense == \"present\" and \\\r\n                         voice == \"personal\":\r\n                            if grammFeats[2] == \"V_nud\":\r\n                                tense = \"past\"\r\n                            elif grammFeats[2] == \"V_tud\":\r\n                                if mood == \"quotat\":\r\n                                    tense = \"past\"\r\n                                    voice = \"impersonal\"\r\n                                else:\r\n                                    # tingiv + tud j\u00e4\u00e4b esialgu lahtiseks\r\n                                    tense = \"??\"\r\n                                    voice = \"??\"\r\n            elif len(matchObj1[PATTERN]) > 1 and matchObj1[PATTERN][0] == '\u00e4ra':\r\n                (pos, form) = grammPosAndForms[1]\r\n                # Imperatiiv\r\n                if 'tagu' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"imper\"\r\n                    voice = \"impersonal\"\r\n                else:\r\n                    tense = \"present\"\r\n                    mood  = \"imper\"\r\n                    voice = \"personal\"\r\n            elif matchObj1[PATTERN][0] == 'pole':\r\n                (pos, form) = grammPosAndForms[0]\r\n                # Indikatiiv\r\n                if 'neg o' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"indic\"\r\n                    voice = \"personal\"\r\n                elif 'neg nud' in form:\r\n                    tense = \"imperfect\"\r\n                    mood  = \"indic\"\r\n                    voice = \"personal\"\r\n                elif 'neg tud' in form:\r\n                    tense = \"imperfect\"\r\n                    mood  = \"indic\"\r\n                    voice = \"impersonal\"\r\n                # Konditsionaal\r\n                elif 'neg ks' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"condit\"\r\n                    voice = \"personal\"\r\n                elif 'neg nuks' in form:\r\n                    tense = \"past\"\r\n                    mood  = \"condit\"\r\n                    voice = \"personal\"\r\n                # Kvotatiiv\r\n                elif 'neg vat' in form:\r\n                    tense = \"present\"\r\n                    mood  = \"quotat\"\r\n                    voice = \"personal\"\r\n                #\r\n                #  Liitaeg: pole + nud (personaal), pole + tud (impersonaal)\r\n                #\r\n                if len(matchObj1[PATTERN]) > 1:\r\n                    # Kindla k\u00f5neviisi liitaeg\r\n                    if mood == \"indic\" and (grammFeats[1] == \"V_nud\" or grammFeats[1] == \"V_tud\"):\r\n                        if tense == \"present\":\r\n                            #  T\u00e4isminevik\r\n                            tense = \"perfect\"\r\n                            if grammFeats[1] == \"V_tud\":\r\n                                voice = \"impersonal\"\r\n                        elif tense == \"imperfect\":\r\n                            #  Enneminevik\r\n                            tense = \"pluperfect\"\r\n                            if grammFeats[1] == \"V_tud\":\r\n                                voice = \"impersonal\"\r\n                    # Tingiva ja kaudse k\u00f5neviisi liitaeg (nn \u00fcldminevik)\r\n                    elif mood in [\"quotat\", \"condit\"] and tense == \"present\" and \\\r\n                         voice == \"personal\":\r\n                            if grammFeats[1] == \"V_nud\":\r\n                                tense = \"past\"\r\n                            elif grammFeats[1] == \"V_tud\":\r\n                                if mood == \"quotat\":\r\n                                    tense = \"past\"\r\n                                    voice = \"impersonal\"\r\n                                else:\r\n                                    # tingiv + tud j\u00e4\u00e4b esialgu lahtiseks\r\n                                    tense = \"??\"\r\n                                    voice = \"??\"\r\n        matchObj1[MOOD] = mood\r\n        matchObj1[TENSE] = tense\r\n        matchObj1[VOICE] = voice", "response": "Add grammatical feats and roots to the sentence."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetecting verb chains from a given sentence.", "response": "def detectVerbChainsFromSent( self, sentence, **kwargs):\r\n        ''' Detect verb chains from given sentence.\r\n\r\n        Parameters\r\n        ----------\r\n        sentence:  list of dict\r\n            A list of sentence words, each word in form of a dictionary containing \r\n            morphological analysis and clause boundary annotations (must have CLAUSE_IDX);\r\n        \r\n        Keyword parameters\r\n        ------------------\r\n        expand2ndTime: boolean\r\n            If True, regular verb chains (chains not ending with 'olema') are expanded twice.\r\n            (default: False)\r\n        breakOnPunctuation: boolean\r\n            If True, expansion of regular verb chains will be broken in case of intervening punctuation.\r\n            (default: False)\r\n        removeSingleAraEi: boolean\r\n            if True, verb chains consisting of a single word, '\u00e4ra' or 'ei', will be removed.\r\n            (default: True)\r\n        removeOverlapping: boolean\r\n            If True, overlapping verb chains will be removed.\r\n            (default: True)\r\n\r\n        Returns\r\n        -------\r\n        list of dict\r\n            List of detected verb chains, each verb chain has following attributes (keys):\r\n             PHRASE      -- list of int : indexes pointing to elements in sentence that belong \r\n                                            to the chain;\r\n             PATTERN     -- list of str : for each word in phrase, marks whether it is 'ega', 'ei', \r\n                                            '\u00e4ra', 'pole', 'ole', '&' (conjunction: ja/ning/ega/v\u00f5i) \r\n                                            'verb' (verb different than 'ole') or 'nom/adv';\r\n             ANALYSIS_IDS -- list of (list of int) : for each word in phrase, points to index(es) of \r\n                                                      morphological analyses that correspond to words\r\n                                                      in the verb chains;\r\n             ROOTS       -- list of str : for each word in phrase, lists its corresponding ROOT \r\n                                            value from the morphological analysis; e.g. for the verb\r\n                                            chain 'p\u00fc\u00fcab kodeerida', the ROOT will be ['p\u00fc\u00fcd', \r\n                                            'kodeeri'];\r\n             MORPH       -- list of str : for each word in phrase, lists its part-of-speech value \r\n                                            and morphological form (in one string, separated by '_',\r\n                                            and multiple variants of the pos/form separated by '/'); \r\n                                            e.g. for the verb chain 'on tulnud', the MORPH value \r\n                                            will be ['V_vad/b', 'V_nud'];\r\n             OTHER_VERBS  -- bool : whether there are other verbs in the context, potentially being \r\n                                     part of the verb chain; if this is True, it is uncertain whether \r\n                                     the chain is complete or not;\r\n             \r\n             POLARITY     -- 'POS', 'NEG' or '??' : grammatical polarity of the verb chain; Negative\r\n                                                    polarity indicates that the verb phrase begins \r\n                                                    with 'ei', 'ega', '\u00e4ra' or 'pole'; \r\n             TENSE        -- tense of the main verb:  'present', 'imperfect', 'perfect', \r\n                                                              'pluperfect', 'past', '??';\r\n             MOOD         -- mood of the main verb:   'indic', 'imper', 'condit', 'quotat', '??';\r\n             VOICE        -- voice of the main verb:  'personal', 'impersonal', '??';\r\n\r\n        '''\r\n        # 0) Parse given arguments\r\n        expand2ndTime = False\r\n        removeOverlapping  = True\r\n        removeSingleAraEi  = True\r\n        breakOnPunctuation = False\r\n        for argName, argVal in kwargs.items():\r\n            if argName == 'expand2ndTime':\r\n                expand2ndTime = bool(argVal)\r\n            elif argName == 'removeOverlapping':\r\n                removeOverlapping = bool(argVal)\r\n            elif argName == 'removeSingleAraEi':\r\n                removeSingleAraEi = bool(argVal)\r\n            elif argName == 'breakOnPunctuation':\r\n                breakOnPunctuation = bool(argVal)\r\n            else:\r\n                raise Exception(' Unsupported argument given: '+argName)\r\n\r\n        # 1) Preprocessing\r\n        sentence = addWordIDs( sentence )\r\n        clauses  = getClausesByClauseIDs( sentence )\r\n\r\n        # 2) Extract predicate-centric verb chains within each clause\r\n        allDetectedVerbChains = []\r\n        for clauseID in clauses:\r\n            clause   = clauses[clauseID]\r\n\r\n            # 2.1) Extract predicate-centric verb chains within each clause\r\n            detectedBasicChains = _extractBasicPredicateFromClause(clause, clauseID)\r\n            allDetectedVerbChains.extend( detectedBasicChains )\r\n            \r\n            # 2.2) Extract 'saama' + 'tud' verb phrases (typically rare)\r\n            _expandSaamaWithTud( clause, clauseID, allDetectedVerbChains )\r\n\r\n            # 2.3) Extend 'olema' chains with 'nud/tud/mas/mata' verbs (if possible)\r\n            _expandOlemaVerbChains( clause, clauseID, allDetectedVerbChains )\r\n            \r\n            # 2.4) Expand non-olema verb chains inside the clause where possible (verb+verb chains)\r\n            _expandVerbChainsBySubcat( clause, clauseID, allDetectedVerbChains, self.verbInfSubcatLexicon, False, breakOnPunctuation)\r\n\r\n            # 2.5) Determine for which verb chains the context should be clear\r\n            #    (no additional verbs can be added to the phrase)\r\n            _determineVerbChainContextualAmbiguity( clause, clauseID, allDetectedVerbChains)\r\n            \r\n            # 2.6) Expand non-olema verb chains inside the clause 2nd time (verb+verb+verb chains)\r\n            #      (Note that while verb+verb+verb+verb+...  chains are also possible, three verbs \r\n            #       seems to be a critical length: longer chains are rare and thus making longer \r\n            #       chains will likely lead to errors);\r\n            if expand2ndTime:\r\n                _expandVerbChainsBySubcat( clause, clauseID, allDetectedVerbChains, self.verbInfSubcatLexicon, False, breakOnPunctuation)\r\n            \r\n        # 3) Extract 'ega' negations (considering the whole sentence context)\r\n        expandableEgaFound = _extractEgaNegFromSent( sentence, clauses, allDetectedVerbChains )\r\n\r\n        if expandableEgaFound:\r\n            for clauseID in clauses:\r\n                clause = clauses[clauseID]\r\n                # 3.1) Expand non-olema 'ega' verb chains inside the clause, if possible;\r\n                _expandVerbChainsBySubcat( clause, clauseID, allDetectedVerbChains, self.verbInfSubcatLexicon, False, breakOnPunctuation)\r\n            \r\n            #_debugPrint(' | '+getJsonAsTextString(sentence, markTokens = [ verbObj[PHRASE] for verbObj in allDetectedVerbChains ]))\r\n\r\n        # 4) Extend chains with nom/adv + Vinf relations\r\n        if self.verbNomAdvVinfExtender:\r\n            addGrammaticalFeatsAndRoots( sentence, allDetectedVerbChains )\r\n            for clauseID in clauses:\r\n                clause = clauses[clauseID]\r\n                expansionPerformed = \\\r\n                    self.verbNomAdvVinfExtender.extendChainsInClause( clause, clauseID, allDetectedVerbChains )\r\n                if expansionPerformed:\r\n                    _determineVerbChainContextualAmbiguity( clause, clauseID, allDetectedVerbChains)\r\n        \r\n        # ) Remove redundant and overlapping verb phrases\r\n        removeRedundantVerbChains( allDetectedVerbChains, removeOverlapping = removeOverlapping, removeSingleAraAndEi = removeSingleAraEi )\r\n\r\n        # ) Add grammatical features (in the end)\r\n        addGrammaticalFeatsAndRoots( sentence, allDetectedVerbChains )\r\n\r\n        return allDetectedVerbChains"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding balanced expression in text.", "response": "def findBalanced(text, openDelim, closeDelim):\n    \"\"\"\n    Assuming that text contains a properly balanced expression\n    :param openDelim: as opening delimiters and\n    :param closeDelim: as closing delimiters.\n    :return: an iterator producing pairs (start, end) of start and end\n    positions in text containing a balanced expression.\n    \"\"\"\n    openPat = '|'.join([re.escape(x) for x in openDelim])\n    # pattern for delimiters expected after each opening delimiter\n    afterPat = {o: re.compile(openPat+'|'+c, re.DOTALL) for o,c in zip(openDelim, closeDelim)}\n    stack = []\n    start = 0\n    cur = 0\n    end = len(text)\n    startSet = False\n    startPat = re.compile(openPat)\n    nextPat = startPat\n    while True:\n        next = nextPat.search(text, cur)\n        if not next:\n            return\n        if not startSet:\n            start = next.start()\n            startSet = True\n        delim = next.group(0)\n        if delim in openDelim:\n            stack.append(delim)\n            nextPat = afterPat[delim]\n        else:\n            opening = stack.pop()\n            # assert opening == openDelim[closeDelim.index(next.group(0))]\n            if stack:\n                nextPat = afterPat[stack[-1]]\n            else:\n                yield start, next.end()\n                nextPat = startPat\n                start = next.end()\n                startSet = False\n        cur = next.end()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nforces conversion of given string to unicode type.", "response": "def as_unicode(s, encoding='utf-8'):\n    \"\"\"Force conversion of given string to unicode type.\n    Unicode is ``str`` type for Python 3.x and ``unicode`` for Python 2.x .\n\n    If the string is already in unicode, then no conversion is done and the same string is returned.\n\n    Parameters\n    ----------\n    s: str or bytes (Python3), str or unicode (Python2)\n        The string to convert to unicode.\n    encoding: str\n        The encoding of the input string (default: utf-8)\n\n    Raises\n    ------\n    ValueError\n        In case an input of invalid type was passed to the function.\n\n    Returns\n    -------\n    ``str`` for Python3 or ``unicode`` for Python 2.\n    \"\"\"\n    if isinstance(s, six.text_type):\n        return s\n    elif isinstance(s, six.binary_type):\n        return s.decode(encoding)\n    else:\n        raise ValueError('Can only convert types {0} and {1}'.format(six.text_type, six.binary_type))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef as_binary(s, encoding='utf-8'):\n    if isinstance(s, six.text_type):\n        return s.encode(encoding)\n    elif isinstance(s, six.binary_type):\n        # make sure the binary is in required encoding\n        return s.decode(encoding).encode(encoding)\n    else:\n        raise ValueError('Can only convert types {0} and {1}'.format(six.text_type, six.binary_type))", "response": "Force conversion of given string to binary type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfunction for listing filenames with given prefix and suffix in the root directory.", "response": "def get_filenames(root, prefix=u'', suffix=u''):\n    \"\"\"Function for listing filenames with given prefix and suffix in the root directory.\n    \n    Parameters\n    ----------\n    \n    prefix: str\n        The prefix of the required files.\n    suffix: str\n        The suffix of the required files\n        \n    Returns\n    -------\n    list of str\n        List of filenames matching the prefix and suffix criteria.\n    \"\"\"\n    return [fnm for fnm in os.listdir(root) if fnm.startswith(prefix) and fnm.endswith(suffix)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tag(self, text):\n        if self.search_method == 'ahocorasick':\n            events = self._find_keywords_ahocorasick(text.text)\n        elif self.search_method == 'naive':\n            events = self._find_keywords_naive(text.text)\n\n        events = self._resolve_conflicts(events)\n        if self.mapping:\n            for item in events:\n                item['type'] = self.map[\n                    text.text[item['start']:item['end']]\n                ]\n\n        if self.return_layer:\n            return events\n        else:\n            text[self.layer_name] = events", "response": "Returns list of keywords in text."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of regex_matches in text.", "response": "def tag(self, text):\n        \"\"\"Retrieves list of regex_matches in text.\n\n        Parameters\n        ----------\n        text: Text\n            The estnltk text object to search for events.\n\n        Returns\n        -------\n        list of matches\n        \"\"\"\n        matches = self._match(text.text)\n        matches = self._resolve_conflicts(matches)\n\n        if self.return_layer:\n            return matches\n        else:\n            text[self.layer_name] = matches"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tag(self, text):\n        if self.search_method == 'ahocorasick':\n            events = self._find_events_ahocorasick(text.text)\n        elif self.search_method == 'naive':\n            events = self._find_events_naive(text.text)\n\n        events = self._resolve_conflicts(events)\n\n        self._event_intervals(events, text)\n\n        if self.return_layer:\n            return events\n        else:\n            text[self.layer_name] = events", "response": "Returns the list of events in the text."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting the lemmas from the found match", "response": "def __extract_lemmas(self, doc, m, phrase):\n        \"\"\"\n        :param sent: sentence from which the match was found\n        :param m: the found match\n        :phrase: name of the phrase\n        :return: tuple of the lemmas in the match\n        \"\"\"\n\n        ph_start = m['start']\n        ph_end = m['end']\n        start_index = None\n        for ind, word in enumerate(doc['words']):\n            if word['start'] == ph_start:\n                start_index = ind\n                break\n        end_index = None\n        for ind, word in enumerate(doc['words']):\n            if word['end'] == ph_end:\n                end_index = ind\n                break\n        if start_index is not None and end_index is not None:\n            \n            lem = []\n                \n            for i in doc['words'][start_index:end_index + 1]:\n                word_lem = []\n                for idx, j in enumerate(i['analysis']):\n                    if i['analysis'][idx]['partofspeech'] in ['A', 'D', 'C', 'J']:\n                        if i['analysis'][idx]['lemma'] not in word_lem:\n                            word_lem.append(i['analysis'][idx]['lemma'])\n                word_lem_str = '|'.join(word_lem)          \n                lem.append(word_lem_str)\n\n        else:\n            raise Exception('Something went really wrong')\n        return lem"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef yield_json_corpus(fnm):\n    with codecs.open(fnm, 'rb', 'ascii') as f:\n        line = f.readline()\n        while line != '':\n            yield Text(json.loads(line))\n            line = f.readline()", "response": "Function to read a JSON corpus from a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_json_corpus(documents, fnm):\n    with codecs.open(fnm, 'wb', 'ascii') as f:\n        for document in documents:\n            f.write(json.dumps(document) + '\\n')\n    return documents", "response": "Writes a list of Text instances as JSON corpus on disk."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_document(fnm):\n    with codecs.open(fnm, 'rb', 'ascii') as f:\n        return Text(json.loads(f.read()))", "response": "Read a document that is stored in a text file as JSON."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting a Text document to file.", "response": "def write_document(doc, fnm):\n    \"\"\"Write a Text document to file.\n\n    Parameters\n    ----------\n    doc: Text\n        The document to save.\n    fnm: str\n        The filename to save the document\n    \"\"\"\n    with codecs.open(fnm, 'wb', 'ascii') as f:\n        f.write(json.dumps(doc, indent=2))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a relation to the sourceSynset.", "response": "def addRelation(sourceSynset,relationName,targetSynset):\n    \"\"\"\n    Adds relation with name <relationName> to\n    <targetSynset>.\n\n    \"\"\"\n    if not isinstance(sourceSynset, Synset):\n        raise TypeError(\"sourceSynset not Synset instance\")\n    elif not isinstance(targetSynset, Synset):\n        raise TypeError(\"targetSynset not Synset instance\")\n    elif relationName not in RELATION_NAMES:\n        raise TypeError(\"relationName not in RELATION_NAMES\")\n    else:\n        sourceSynset.addRelation(\n            Relation(relationName,targetSynset)\n            )\n        return sourceSynset"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nappend a feature to the internal list of features.", "response": "def addFeature(self, feature):\n        '''Appends Feature'''\n        \n        if isinstance(feature, Feature):\n            self.features.append(feature)\n        else:\n            raise TypeError(\n                'feature Type should be Feature, not %s' % type(feature))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addSourceId(self, value):\n        '''Adds SourceId to External_Info\n        '''\n        if isinstance(value, Source_Id):\n            self.source_ids.append(value)\n        else:\n            raise (TypeError,\n                   'source_id Type should be Source_Id, not %s' % type(source_id))", "response": "Adds SourceId to External_Info\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd SourceId to External_Info", "response": "def addCorpusId(self, value):\n        '''Adds SourceId to External_Info\n        '''\n        if isinstance(value, Corpus_Id):\n            self.corpus_ids.append(value)\n        else:\n            raise (TypeError,\n                   'source_id Type should be Source_Id, not %s' % type(source_id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the line of an ewn file into the properties self. levelNumber self. DRN self. fieldValue and self. noQuotes.", "response": "def parse_line(self,iStr):\n        \"\"\"Parses ewn file line\n        \"\"\"\n        self.levelNumber = None\n        self.DRN = None\n        self.fieldTag = None\n        self.fieldValue = None\n        self.noQuotes = None\n        if iStr and not(iStr.strip().startswith('#')):\n            iList = iStr.strip().split(' ')\n            self.levelNumber = int(iList.pop(0))\n            if iList[0].startswith('@') and self.levelNumber != 3:\n                self.DRN = int(iList.pop(0).strip('@'))\n            else:\n                self.DRN = None\n            self.fieldTag = iList.pop(0)\n            if iList and (\n                iList[0].startswith('\"') or\n                iList[0].startswith('@')\n                ):\n                fv = ' '.join(iList)\n                self.fieldValue = fv[1:-1]\n            elif iList:\n                if len(iList) == 1:\n                    self.fieldValue = iList.pop(0)\n                else:\n                    self.fieldValue = ' '.join(iList)\n                try:\n                    self.fieldValue = int(self.fieldValue)\n                except ValueError:\n                    self.noQuotes = True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a Synset from a file.", "response": "def parse_synset(self, offset=None, debug=False):\n        \"\"\"Parses Synset from file\n        \"\"\"\n        if False:\n            pass\n        else:\n            # WORD_INSTANCE\n            def _word_instance():\n                _synset(True)\n\n            # WORD_MEANING\n            def _synset(pn=False):\n                if not pn:\n                    self.synset = Synset()\n                    self.pn = False\n                else:\n                    self.synset = WordInstance()\n                    self.pn = True\n                if self.DRN:\n                    self.synset.number = self.DRN\n                self.targetType = None\n\n            def _variants():\n                self.synset.variants = Variants()\n\n            def _literal():\n                a = Variant()\n                self.synset.variants.append(a)\n                self.synset.variants[-1].literal = self.fieldValue\n\n            def _target_literal():\n                    self.target_synset.variants.append(Variant())\n                    self.target_synset.variants[-1].literal = self.fieldValue\n\n            def _sense():\n                self.synset.variants[-1].sense = self.fieldValue\n\n            def _status():\n                self.noQuotes = True\n                try:\n                    self.synset.variants[-1].status = as_unicode(self.fieldValue)\n                except:\n                    self.synset.variants[-1].status = as_unicode(str(self.fieldValue))\n                self.noQuotes = False\n\n            def _target_sense():\n                self.target_synset.variants[-1].sense = self.fieldValue\n                if self.targetType == 'internal':\n                    self.synset.internalLinks[\n                        -1].target_concept = self.target_synset\n                elif self.targetType == 'ili':\n                    self.synset.eqLinks[-1].target_concept = self.target_synset\n                elif self.targetType == 'pv':\n                    self.synset.propertyValues[-1].value = self.target_synset\n                else:\n                    print ('BOOOOOOOOO!!') # Error TODO\n\n            def _gloss():\n                self.synset.variants[-1].gloss = self.fieldValue\n                self.synset.definition = self.fieldValue                            # ADDED BY KOM\n\n            def _translations():\n                self.synset.variants[-1].translations = Translations()\n\n            def _translation():\n                self.synset.variants[-1].translations.append(\n                    Translation(\n                        language=self.fieldValue.split(':')[0],\n                        translation_value = self.fieldValue.split(':')[1])\n                    )\n\n            def _examples():\n                self.synset.variants[-1].examples = Examples()\n            def _usage_labels():\n                self.synset.variants[-1].usage_labels = Usage_Labels()\n\n            def _external_info():\n                self.synset.variants[-1].externalInfo = External_Info()\n\n            def _example():\n                self.synset.variants[-1].examples.append(\n                    Example(self.fieldValue)\n                    )\n\n            def _usage_label():\n                self.synset.variants[\n                    -1].usage_labels.append(\n                    Usage_Label(name=self.fieldValue)\n                    )\n\n            def _usage_label_value():\n                self.synset.variants[\n                    -1].usage_labels[-1].usage_label_value = self.fieldValue\n\n            def _source_id():\n                if self.targetType == 'internal':\n                    self.synset.internalLinks[-1].source_id = self.fieldValue\n                    # self.synset.internalLinks[-1].source_ids.append(\n                    #     Relation_Source_Id(number=self.fieldValue))\n                elif self.targetType == 'ili':\n                    self.synset.eqLinks[-1].source_id = self.fieldValue\n                    # self.synset.eqLinks[-1].source_ids.append(\n                    #     Relation_Source_Id(number=self.fieldValue))\n\n                else:\n                    if self.synset.variants[-1].external_info:\n                        self.synset.variants[\n                            -1].external_info.source_ids.append(\n                            Source_Id(number=self.fieldValue)\n                            )\n                    else:\n                        self.synset.variants[-1].external_info = External_Info()\n                        self.synset.variants[\n                            -1].external_info.source_ids.append(\n                            Source_Id(number=self.fieldValue)\n                            )\n\n            def _corpus_id():\n                if self.targetType == 'internal': # not needed\n                    self.synset.internalLinks[-1].corpus_ids.append(\n                        Relation_Corpus_Id(number=self.fieldValue))\n                else:\n                    if self.synset.variants[-1].external_info:\n                        self.synset.variants[\n                            -1].external_info.corpus_ids.append(\n                            Corpus_Id(number=self.fieldValue)\n                            )\n                    else:\n                        self.synset.variants[-1].external_info = External_Info()\n                        self.synset.variants[\n                            -1].external_info.corpus_ids.append(\n                            Corpus_Id(number=self.fieldValue)\n                            )\n\n            def _frequency():\n                self.synset.variants[\n                    -1].external_info.corpus_ids[-1].frequency = self.fieldValue\n\n            def _text_key():\n                self.synset.variants[\n                    -1].external_info.source_ids[-1].text_key = self.fieldValue\n\n            def _number_key():\n                self.synset.variants[\n                    -1].external_info.source_ids[\n                    -1].number_key = self.fieldValue\n            def _pos():\n                self.synset.pos = self.fieldValue\n\n            # INTERNAL_LINKS\n            def _target_concept():\n                self.target_synset = Synset()\n                self.target_synset.variants = Variants()\n                if self.levelNumber == 3: # and self.fieldValue:\n                    self.target_synset.number = int(self.fieldValue or 0)\n\n            def _target_pos():\n                self.target_synset.pos = self.fieldValue\n\n            def _internal_links():\n                self.synset.internalLinks = InternalLinks()\n                self.targetType = 'internal'\n\n            def _relation():\n                if self.targetType == 'internal':\n                    self.synset.internalLinks.append(Relation())\n                    self.synset.internalLinks[-1].name = self.fieldValue\n                elif self.targetType == 'ili':\n                    self.synset.eqLinks.append(EqLink())\n                    self.synset.eqLinks[-1].name = self.fieldValue\n                else:\n                    print ('BOOOOOOOOO!!') # Error TODO\n\n            def _features():\n                if self.targetType == 'internal':\n                    self.synset.internalLinks[-1].features = Features()\n                else:\n                    self.synset.variants[-1].features = Features()\n                    self.synset.variants[-1].features.append(Feature())\n\n            def _feature():\n                self.synset.variants[-1].features[-1].name = self.fieldValue\n\n            def _feature_value():\n                self.synset.variants[\n                    -1].features[-1].featureValue = self.fieldValue\n\n            def _reversed():\n                self.synset.internalLinks[-1].features.append(Feature())\n                self.synset.internalLinks[-1].features[-1].name = self.fieldTag\n                self.synset.internalLinks[-1].features[-1].featureValue = True\n\n            def _variant_to_variant():\n                self.synset.internalLinks[-1].features.append(Feature())\n                self.synset.internalLinks[-1].features[-1].name = self.fieldTag\n\n            def _source_variant():\n                self.variant_to_variant_source = self.fieldValue\n\n            def _target_variant():\n                self.variant_to_variant_target = self.fieldValue\n                self.synset.internalLinks[\n                    -1].features[-1].featureValue = (\n                    self.variant_to_variant_source,\n                    self.variant_to_variant_target)\n\n            # EQ_LINKS\n            def _eq_links():\n                self.synset.eqLinks = EqLinks()\n                self.targetType = 'ili'\n\n            def _wn_offset():\n                self.target_synset.wordnet_offset = self.fieldValue\n                self.synset.eqLinks[-1].target_concept = self.target_synset\n\n            def _add_on_id():\n                self.target_synset.add_on_id = self.fieldValue\n                self.synset.eqLinks[-1].target_concept = self.target_synset\n\n            # PROPERTIES\n            def _properties():\n                self.synset.properties = Properties()\n\n            def _name():\n                if self.pn:\n                    self.synset.propertyValues.append(\n                        PropertyValue(name=self.fieldValue))\n                else:\n                    self.synset.properties.append(Property(self.fieldValue))\n\n            # PROPERTY_VALUES\n            def _property_values():\n                self.synset.propertyValues = PropertyValues()\n\n            def _property_value():\n                self.synset.propertyValues[-1].value = self.fieldValue\n                self.targetType = 'pv'\n\n            def _property_wm():\n                pass\n\n            rulez = {\n                (0,'WORD_MEANING'): _synset,\n                (0,'WORD_INSTANCE'): _word_instance,\n                (1,'PART_OF_SPEECH'): _pos,\n                (1,'VARIANTS'): _variants,\n                (2,'LITERAL'): _literal,\n                (3,'SENSE'): _sense,\n                (3,'STATUS'): _status,\n                (3,'DEFINITION'): _gloss,\n                (3,'EXAMPLES'): _examples,\n                (3,'USAGE_LABELS'): _usage_labels,\n                (4,'USAGE_LABEL'): _usage_label,\n                (5,'USAGE_LABEL_VALUE'): _usage_label_value,\n                (4,'EXAMPLE'): _example,\n                (3,'TRANSLATIONS'): _translations,\n                (4,'TRANSLATION'): _translation,\n                (3,'EXTERNAL_INFO'): _external_info,\n                (4,'SOURCE_ID'): _source_id,\n                (4,'CORPUS_ID'): _corpus_id,\n                (5,'FREQUENCY'): _frequency,\n                (5,'TEXT_KEY'): _text_key,\n                (5,'NUMBER_KEY'): _number_key,\n                (1,'INTERNAL_LINKS'): _internal_links,\n                (2,'RELATION'): _relation,\n                (3,'TARGET_CONCEPT'): _target_concept,\n                (4,'PART_OF_SPEECH'): _target_pos,\n                (4,'LITERAL'): _target_literal,\n                (5,'SENSE'): _target_sense,\n                (3,'FEATURES'): _features,\n                (4,'FEATURE'): _feature,\n                (5,'FEATURE_VALUE'): _feature_value,\n                (4,'REVERSED'): _reversed,\n                (4,'VARIANT_TO_VARIANT'): _variant_to_variant,\n                (5,'SOURCE_VARIANT'): _source_variant,\n                (5,'TARGET_VARIANT'): _target_variant,\n                (3,'SOURCE_ID'): _source_id,\n                (1,'EQ_LINKS'): _eq_links,\n                (2,'EQ_RELATION'): _relation,\n                (3,'TARGET_ILI'): _target_concept,\n                (4,'WORDNET_OFFSET'): _wn_offset,\n                (4,'ADD_ON_ID'): _add_on_id,\n                (1,'PROPERTIES'): _properties,\n                (1,'PROPERTY_VALUES'): _property_values,\n                (2,'NAME'): _name,\n                (3,'VALUE'): _property_value,\n                (3,'VALUE_AS_TEXT'): _property_value,\n                (3,'VALUE_AS_WORD_MEANING'): _target_concept,\n                }\n\n            if not offset:\n                offset = self.milestone\n            else:\n                self.milestone=offset\n            if self.file:\n                self.file.seek(offset,0)\n\n            line = 'X'\n            ili = False\n            var = False\n            while line.strip():\n\n                offset = self.file.tell()\n                self.file.seek(offset,0)\n\n                line = as_unicode(self.file.readline(), self.encoding).strip()\n                if debug:\n                    print (line.encode('utf-8'))\n\n\n                self.parse_line(line)\n                self.noQuotes = None\n\n                select = (self.levelNumber,self.fieldTag)\n\n                if select in rulez.keys():\n                    rulez[select]()\n                else:\n                    if line:\n                        print (self.synset.polarisText)\n                        raise ParseError(\"No parsing rule for '%s'\" % line)\n        return self.synset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_wordnet(self,debug=False):\n        '''Parses wordnet from \n        <self.file>\n        '''\n        synList = []\n        self.milestone = 0 # to start from beginning of file\n        while self.milestone < os.path.getsize(self.fileName) - 5:\n            if debug:\n                print ('self.milestone', self.milestone)\n            a = self.parse_synset(offset=self.milestone)\n            synList.append(a)\n            self.milestone = self.file.tell()\n        return synList", "response": "Parses wordnet from \n        <self. file >\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nappends one Translation to translations AttributeNames", "response": "def addTranslation(self,translation):\n        '''Appends one Translation to translations\n        '''\n        if isinstance(translation, Translation):\n            self.translations.append(translation)\n        else:\n            raise(TranslationError,\n                   'translation Type should be Translation, not %s' % type(\n                    translation)\n                   )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nappending one VariantFeature to variantFeatures AttributeNames", "response": "def addVariantFeature(self,variantFeature):\n        '''Appends one VariantFeature to variantFeatures\n        '''\n        if isinstance(variantFeature, Feature):\n            self.features.append(variantFeature)\n        else:\n            raise(TypeError,\n                  'variantFeature Type should be Feature, not %s' % type(\n                    variantFeature)\n                  )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addUsage_Label(self,usage_label):\n        '''Appends one Usage_Label to usage_labels\n        '''\n        if isinstance(usage_label, Usage_Label):\n            self.usage_labels.append(usage_label)\n        else:\n            raise (Usage_LabelError,\n                   'usage_label Type should be Usage_Label, not %s' % type(\n                    usage_label)\n                   )", "response": "Appends one Usage_Label to usage_labels\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nappends one Example to examples AttributeNames", "response": "def addExample(self,example):\n        '''Appends one Example to examples\n        '''\n        if isinstance(example, Example):\n            self.examples.append(example)\n        else:\n            raise (ExampleError,\n                   'example Type should be Example, not %s' % type(example)\n                   )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the first variant of Variants AttributeNames Read - only", "response": "def firstVariant():\n        \"\"\"first variant of Variants\n        Read-only\n        \n        \"\"\"\n        def fget(self):\n            if self.variants:\n                return self.variants[0]\n            else:\n                variant = Variant()\n                return variant\n\n        return locals()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef literals():\n        '''Returns a list of literals\n        in the Synset\n        read-only\n        '''\n        def fget(self):\n            if self.variants:\n                return map(lambda x: x.literal,\n                           self.variants)\n            else:\n                return None\n \n        return locals()", "response": "Returns a list of literals\n        in the Synset\n        read - only\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addVariantOld(self,\n                      literal='',\n                      sense=0,\n                      gloss='',\n                      examples=[]):\n        '''Appends variant\n        sth to do that it would be possible\n        to add Variant object\n\n        '''\n        var = Variant(literal=literal,\n                      sense=sense,\n                      gloss=gloss,\n                      examples=examples)\n        self.variants.append(var)", "response": "Appends a Variant object to the internal list of variants."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addVariant(self,variant):\n        '''Appends one Variant to variants\n\n        '''\n        if isinstance(variant, Variant):\n            self.variants.append(variant)\n        else:\n            raise (VariantError,\n                   'variant Type should be Variant, not %s' % type(variant))", "response": "Appends one Variant to the internal list of variants\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addInternalLink(self, link):\n        '''Appends InternalLink\n        \n        '''\n        if isinstance(link, InternalLink):\n            self.internalLinks.append(link)\n        else:\n            raise InternalLinkError( \n                'link Type should be InternalLink, not %s' % type(link))", "response": "Appends an internal link to the internalLinks list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nappending a relation to the internalLinks list", "response": "def addRelation(self, link):\n        '''Appends Relation\n        \n        '''\n        if isinstance(link, Relation):\n            self.internalLinks.append(link)\n        else:\n            raise TypeError(\n                'link Type should be InternalLink, not %s' % type(link))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addEqLink(self, link):\n        '''Appends EqLink\n\n        '''\n        if isinstance(link, EqLink):\n            self.eqLinks.append(link)\n        else:\n            raise TypeError(\n                'link Type should be InternalLink, not %s' % type(link))", "response": "Appends an internal link to the internal link list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn list of named Relations. <name > may be string or list.", "response": "def named_relations(self, name, neg=False):\n        '''Returns list of named Relations.\n        \n        <name> may be string or list.\n        '''\n        if self.internalLinks and not neg:\n\n            if isinstance(name, six.string_types):\n                return filter(lambda x: x.name == name,\n                              self.internalLinks)\n\n            elif isinstance(name, list):\n                return filter(lambda x: x.name in name,\n                              self.internalLinks)\n            else:\n                return None #should rise error\n\n        elif self.internalLinks and neg:\n\n            if isinstance(name, six.string_types):\n                return filter(lambda x: x.name != name,\n                              self.internalLinks)\n\n            elif isinstance(name, list):\n                return filter(lambda x: x.name not in name,\n                              self.internalLinks)\n            else:\n                return None #should rise error\n      \n        else:\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef named_eq_relations(self, name, neg=False):\n        '''Returns list of named eqLinks.\n\n        <name> may be string or list.\n        '''\n        if self.eqLinks and not neg:\n\n            if isinstance(name, six.string_types):\n                return filter(lambda x: x.relation.name == name,\n                              self.eqLinks)\n\n            elif isinstance(name, list):\n                return filter(lambda x: x.relation.name in name,\n                              self.eqLinks)\n            else:\n                return None #should rise error\n\n        elif self.eqLinks and neg:\n\n            if isinstance(name, six.string_types):\n                return filter(lambda x: x.relation.name != name,\n                              self.eqLinks)\n\n            elif isinstance(name, list):\n                return filter(lambda x: x.relation.name not in name,\n                              self.eqLinks)\n            else:\n                return None #should rise error\n        else:\n            return None", "response": "Returns list of named eqLinks.\n\n            <name > may be string or list.\n            <name > may be list.\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse synset from file <fileName > from offset offset", "response": "def parse(self,fileName,offset):\n        '''Parses synset from file <fileName>\n        from offset <offset>\n        '''\n        p = Parser()\n        p.file = open(fileName, 'rb')\n        a = p.parse_synset(offset=offset)\n        p.file.close()\n        self.__dict__.update(a.__dict__)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending synset to Polaris IO file <fileName >", "response": "def write(self,fileName):\n        '''Appends synset to Polaris IO file <fileName>\n        '''\n        f = open(fileName, 'ab')\n        f.write('%s%s' % (self.polarisText,\n                          Synset.linebreak)\n                )\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfixing out - of - the - sentence links in the given sentence.", "response": "def _fix_out_of_sentence_links( alignments, sent_start, sent_end ):\n    ''' Fixes out-of-the-sentence links in the given sentence.\n        The sentence is a sublist of *alignments*, starting from \n        *sent_start* and ending one token before *sent_end*;\n    ''' \n    sent_len = sent_end - sent_start\n    j = sent_start\n    while j < sent_start + sent_len:\n        for rel_id, rel in enumerate( alignments[j][PARSER_OUT] ):\n            if int( rel[1] ) >= sent_len:\n                # If the link points out-of-the-sentence, fix\n                # the link so that it points inside the sentence\n                # boundaries:\n                wid = j - sent_start\n                if sent_len == 1:\n                    # a single word becomes a root\n                    rel[1] = -1\n                elif wid-1 > -1:\n                    # word at the middle/end is linked to the previous\n                    rel[1] = wid - 1\n                elif wid-1 == -1:\n                    # word at the beginning is linked to the next\n                    rel[1] = wid + 1\n                alignments[j][PARSER_OUT][rel_id] = rel\n        j += 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nnormalizes dependency syntactic information in a given list of alignments.", "response": "def normalise_alignments( alignments, data_type=VISLCG3_DATA, **kwargs ):\n    ''' Normalises dependency syntactic information in the given list of alignments.\n        *) Translates tree node indices from the syntax format (indices starting \n           from 1), to EstNLTK format (indices starting from 0);\n        *) Removes redundant information (morphological analyses) and keeps only \n           syntactic information, in the most compact format;\n        *) Brings MaltParser and VISLCG3 info into common format;\n        \n        Expects that the list of alignments contains dicts, where each dict has \n        following attributes (at minimum):\n          'start'   -- start index of the word in Text;\n          'end'     -- end index of the word in Text;\n          'sent_id' -- index of the sentence in Text, starting from 0;\n          'parser_out' -- list of analyses from the output of the syntactic parser;\n        Assumes that dicts are listed in the order of words appearance in the text;\n        ( basically, assumes the output of methods align_CONLL_with_Text() and \n          align_cg3_with_Text() )\n        \n        Returns the input list (alignments), where old analysis lines ('parser_out') have \n        been replaced with the new compact form of analyses (if keep_old == False), or where \n        old analysis lines ('parser_out') have been replaced the new compact form of analyses,\n        and the old analysis lines are preserved under a separate key: 'init_parser_out' (if \n        keep_old == True);\n\n        In the compact list of analyses, each item has the following structure:\n           [ syntactic_label, index_of_the_head ]\n         *) syntactic_label\n                surface syntactic label of the word, e.g. '@SUBJ', '@OBJ', '@ADVL'\n         *) index_of_the_head\n                index of the head; -1 if the current token is root;\n\n\n        Parameters\n        -----------\n        alignments : list of items\n            A list of dicts, where each item/dict has following attributes:\n            'start', 'end', 'sent_id', 'parser_out'\n\n        data_type : str\n            Type of data in list_of_analysis_lines; Possible types: 'vislcg3'\n            (default), and 'conll';\n\n        rep_miss_w_dummy : bool\n            Optional argument specifying whether missing analyses should be replaced\n            with dummy analyses ( in the form ['xxx', link_to_self] ); If False,\n            an Exception is raised in case of a missing analysis;\n            Default:True\n            \n        fix_selfrefs : bool\n            Optional argument specifying  whether  self-references  in  syntactic \n            dependencies should be fixed;\n            A self-reference link is firstly re-oriented as a link to the previous word\n            in the sentence, and if the previous word does  not  exist,  the  link  is \n            re-oriented to the next word in the sentence; If the self-linked word is\n            the only word in the sentence, it is made the root of the sentence;\n            Default:True\n        \n        fix_out_of_sent : bool\n            Optional argument specifying whether references pointing out of the sentence\n            (the parent index exceeds the sentence boundaries) should be fixed; \n            The logic used in fixing out-of-sentence links is the same as the logic for \n            fix_selfrefs;\n            Default:False\n        \n        keep_old : bool\n            Optional argument specifying  whether the old analysis lines should be \n            preserved after overwriting 'parser_out' with new analysis lines;\n            If True, each dict will be augmented with key 'init_parser_out' which\n            contains the initial/old analysis lines;\n            Default:False\n        \n        mark_root : bool\n            Optional argument specifying whether the root node in the dependency tree \n            (the node pointing to -1) should be assigned the label 'ROOT' (regardless\n            its current label).\n            This might be required, if one wants to make MaltParser's and VISLCG3 out-\n            puts more similar, as MaltParser currently uses 'ROOT' labels, while VISLCG3 \n            does not;\n            Default:False\n\n\n        (Example text: 'Millega pitsat tellida ? Hea k\u00fcsimus .')\n        Example input (VISLC3):\n        -----------------------\n        {'end': 7, 'sent_id': 0, 'start': 0, 'parser_out': ['\\t\"mis\" Lga P inter rel sg kom @NN> @ADVL #1->3\\r']}\n        {'end': 14, 'sent_id': 0, 'start': 8, 'parser_out': ['\\t\"pitsa\" Lt S com sg part @OBJ #2->3\\r']}\n        {'end': 22, 'sent_id': 0, 'start': 15, 'parser_out': ['\\t\"telli\" Lda V main inf @IMV #3->0\\r']}\n        {'end': 23, 'sent_id': 0, 'start': 22, 'parser_out': ['\\t\"?\" Z Int CLB #4->4\\r']}\n        {'end': 27, 'sent_id': 1, 'start': 24, 'parser_out': ['\\t\"hea\" L0 A pos sg nom @AN> #1->2\\r']}\n        {'end': 35, 'sent_id': 1, 'start': 28, 'parser_out': ['\\t\"k\u00fcsimus\" L0 S com sg nom @SUBJ #2->0\\r']}\n        {'end': 36, 'sent_id': 1, 'start': 35, 'parser_out': ['\\t\".\" Z Fst CLB #3->3\\r']}\n\n        Example output:\n        ---------------\n        {'sent_id': 0, 'start': 0, 'end': 7, 'parser_out': [['@NN>', 2], ['@ADVL', 2]]}\n        {'sent_id': 0, 'start': 8, 'end': 14, 'parser_out': [['@OBJ', 2]]}\n        {'sent_id': 0, 'start': 15, 'end': 22, 'parser_out': [['@IMV', -1]]}\n        {'sent_id': 0, 'start': 22, 'end': 23, 'parser_out': [['xxx', 2]]}\n        {'sent_id': 1, 'start': 24, 'end': 27, 'parser_out': [['@AN>', 1]]}\n        {'sent_id': 1, 'start': 28, 'end': 35, 'parser_out': [['@SUBJ', -1]]}\n        {'sent_id': 1, 'start': 35, 'end': 36, 'parser_out': [['xxx', 1]]}\n\n    '''\n    if not isinstance( alignments, list ):\n        raise Exception('(!) Unexpected type of input argument! Expected a list of strings.')\n    if data_type.lower() == VISLCG3_DATA:\n       data_type = VISLCG3_DATA\n    elif data_type.lower() == CONLL_DATA:\n       data_type = CONLL_DATA\n    else: \n       raise Exception('(!) Unexpected type of data: ', data_type)\n    keep_old         = False\n    rep_miss_w_dummy = True\n    mark_root        = False\n    fix_selfrefs     = True\n    fix_out_of_sent  = False\n    for argName, argVal in kwargs.items():\n        if argName in ['selfrefs', 'fix_selfrefs'] and argVal in [True, False]:\n           #  Fix self-references\n           fix_selfrefs = argVal\n        if argName in ['keep_old'] and argVal in [True, False]:\n           #  After the normalisation, keep also the original analyses;\n           keep_old = argVal\n        if argName in ['rep_miss_w_dummy', 'rep_miss'] and argVal in [True, False]:\n           #  Replace missing analyses with dummy analyses;\n           rep_miss_w_dummy = argVal\n        if argName in ['mark_root', 'root'] and argVal in [True, False]:\n           #  Mark the root node in the syntactic tree with the label ROOT;\n           mark_root = argVal\n        if argName in ['fix_out_of_sent']:\n           #  Fix links pointing out of the sentence;\n           fix_out_of_sent = bool(argVal)\n    # Iterate over the alignments and normalise information\n    prev_sent_id = -1\n    wordID       = 0\n    sentStart    = -1\n    for i in range(len(alignments)):\n        alignment = alignments[i]\n        if prev_sent_id != alignment[SENT_ID]:\n            # Detect and fix out-of-the-sentence links in the previous sentence (if required)\n            if fix_out_of_sent and sentStart > -1:\n                _fix_out_of_sentence_links( alignments, sentStart, i )\n            # Start of a new sentence: reset word id\n            wordID = 0\n            sentStart = i\n        # 1) Extract syntactic information\n        foundRelations = []\n        if data_type == VISLCG3_DATA:\n            # *****************  VISLCG3 format\n            for line in alignment[PARSER_OUT]:\n                # Extract info from VISLCG3 format analysis:\n                sfuncs  = pat_cg3_surface_rel.findall( line )\n                deprels = pat_cg3_dep_rel.findall( line )\n                # If sfuncs is empty, generate an empty syntactic function (e.g. for \n                # punctuation)\n                sfuncs = ['xxx'] if not sfuncs else sfuncs\n                # Generate all pairs of labels vs dependency\n                for func in sfuncs:\n                    for (relS,relT) in deprels:\n                        relS = int(relS)-1\n                        relT = int(relT)-1\n                        foundRelations.append( [func, relT] )\n        elif data_type == CONLL_DATA:\n            # *****************  CONLL format\n            for line in alignment[PARSER_OUT]:\n                parts = line.split('\\t')\n                if len(parts) != 10:\n                    raise Exception('(!) Unexpected line format for CONLL data:', line)\n                relT = int( parts[6] ) - 1\n                func = parts[7]\n                foundRelations.append( [func, relT] )\n        # Handle missing relations (VISLCG3 specific problem)\n        if not foundRelations:\n            # If no alignments were found (probably due to an error in analysis)\n            if rep_miss_w_dummy:\n                # Replace missing analysis with a dummy analysis, with dep link \n                # pointing to self;\n                foundRelations.append( ['xxx', wordID] )\n            else:\n                raise Exception('(!) Analysis missing for the word nr.', alignment[0])\n        # Fix self references ( if requested )\n        if fix_selfrefs:\n            for r in range(len(foundRelations)):\n                if foundRelations[r][1] == wordID:\n                    # Make it to point to the previous word in the sentence,\n                    # and if the previous one does not exist, make it to point\n                    # to the next word;\n                    foundRelations[r][1] = \\\n                        wordID-1 if wordID-1 > -1 else wordID+1\n                    # If the self-linked token is the only token in the sentence, \n                    # mark it as the root of the sentence:\n                    if wordID-1 == -1 and (i+1 == len(alignments) or \\\n                       alignments[i][SENT_ID] != alignments[i+1][SENT_ID]):\n                        foundRelations[r][1] = -1\n        # Mark the root node in the syntactic tree with the label ROOT ( if requested )\n        if mark_root:\n            for r in range(len(foundRelations)):\n                if foundRelations[r][1] == -1:\n                    foundRelations[r][0] = 'ROOT'\n        # 2) Replace existing syntactic info with more compact info\n        if not keep_old:\n            # Overwrite old info\n            alignment[PARSER_OUT] = foundRelations\n        else: \n            # or preserve the initial information, and add new compact information\n            alignment[INIT_PARSER_OUT] = alignment[PARSER_OUT]\n            alignment[PARSER_OUT]      = foundRelations\n        alignments[i] = alignment\n        prev_sent_id = alignment[SENT_ID]\n        # Increase word id \n        wordID += 1\n    # Detect and fix out-of-the-sentence links in the last sentence (if required)\n    if fix_out_of_sent and sentStart > -1:\n        _fix_out_of_sentence_links( alignments, sentStart, len(alignments) )\n    return alignments"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the output of VISLCG3 syntactic analysis from a given file and returns as a Text object.", "response": "def read_text_from_cg3_file( file_name, layer_name=LAYER_VISLCG3, **kwargs ):\n    ''' Reads the output of VISLCG3 syntactic analysis from given file, and \n        returns as a Text object.\n        \n        The Text object has been tokenized for paragraphs, sentences, words, and it \n        contains syntactic analyses aligned with word spans, in the layer *layer_name* \n        (by default: LAYER_VISLCG3);\n        \n        Attached syntactic analyses are in the format as is the output of \n          utils.normalise_alignments();\n        \n        Note: when loading data from  https://github.com/EstSyntax/EDT  corpus,\n        it  is  advisable  to  add  flags:  clean_up=True,  fix_sent_tags=True, \n        fix_out_of_sent=True  in order to ensure that well-formed data will be\n        read from the corpus;\n        \n        Parameters\n        -----------\n        file_name : str\n            Name of the input file; Should contain syntactically analysed text,\n            following the format of the output of VISLCG3 syntactic analyser;\n        \n        clean_up : bool\n            Optional argument specifying whether the vislcg3_syntax.cleanup_lines()\n            should be applied in the lines of syntactic analyses read from the \n            file;\n            Default: False\n        \n        layer_name : str\n            Name of the Text's layer in which syntactic analyses are stored; \n            Defaults to 'vislcg3_syntax';\n        \n            For other parameters, see optional parameters of the methods:\n            \n             utils.normalise_alignments():          \"rep_miss_w_dummy\", \"fix_selfrefs\",\n                                                    \"keep_old\", \"mark_root\";\n             vislcg3_syntax.align_cg3_with_Text():  \"check_tokens\", \"add_word_ids\";\n             vislcg3_syntax.cleanup_lines():        \"remove_caps\", \"remove_clo\",\n                                                    \"double_quotes\", \"fix_sent_tags\"\n        \n        \n    '''\n    clean_up = False\n    for argName, argVal in kwargs.items():\n        if argName in ['clean_up', 'cleanup'] and argVal in [True, False]:\n           #  Clean up lines\n           clean_up = argVal\n    # 1) Load vislcg3 analysed text from file\n    cg3_lines = []\n    in_f = codecs.open(file_name, mode='r', encoding='utf-8')\n    for line in in_f:\n        # Skip comment lines\n        if line.startswith('#'):\n            continue\n        cg3_lines.append( line.rstrip() )\n    in_f.close()\n    # Clean up lines of syntactic analyses (if requested)\n    if clean_up:\n        cg3_lines = cleanup_lines( cg3_lines, **kwargs )\n\n    # 2) Extract sentences and word tokens\n    sentences = []\n    sentence  = []\n    for i, line in enumerate( cg3_lines ):\n        if line == '\"<s>\"':\n            if sentence:\n                print('(!) Sentence begins before previous ends at line: '+str(i), \\\n                      file=sys.stderr)\n            sentence  = []\n        elif pat_double_quoted.match( line ) and line != '\"<s>\"' and line != '\"</s>\"':\n            token_match = pat_cg3_word_token.match( line )\n            if token_match:\n                line = token_match.group(1)\n            else:\n                raise Exception('(!) Unexpected token format: ', line)\n            sentence.append( line )\n        elif line == '\"</s>\"':\n            if not sentence:\n                print('(!) Empty sentence at line: '+str(i), \\\n                      file=sys.stderr)\n            # (!) Use double space instead of single space in order to distinguish\n            #     word-tokenizing space from the single space in the multiwords\n            #     (e.g. 'Rio de Janeiro' as a single word);\n            sentences.append( '  '.join(sentence) )\n            sentence = []\n\n    # 3) Construct the estnltk's Text\n    kwargs4text = {\n      # Use custom tokenization utils in order to preserve exactly the same \n      # tokenization as was in the input;\n      \"word_tokenizer\": RegexpTokenizer(\"  \", gaps=True),\n      \"sentence_tokenizer\": LineTokenizer()\n    }\n    from estnltk.text import Text\n    text = Text( '\\n'.join(sentences), **kwargs4text )\n    # Tokenize up to the words layer\n    text.tokenize_words()\n    \n    # 4) Align syntactic analyses with the Text\n    alignments = align_cg3_with_Text( cg3_lines, text, **kwargs )\n    normalise_alignments( alignments, data_type=VISLCG3_DATA, **kwargs )\n    # Attach alignments to the text\n    text[ layer_name ] = alignments\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_text_from_conll_file( file_name, layer_name=LAYER_CONLL, **kwargs ):\n    ''' Reads the CONLL format syntactic analysis from given file, and returns as \n        a Text object.\n        \n        The Text object has been tokenized for paragraphs, sentences, words, and it \n        contains syntactic analyses aligned with word spans, in the layer *layer_name* \n        (by default: LAYER_CONLL);\n        \n        Attached syntactic analyses are in the format as is the output of \n          utils.normalise_alignments();\n        \n        Parameters\n        -----------\n        file_name : str\n            Name of the input file; Should contain syntactically analysed text,\n            following the CONLL format;\n        \n        layer_name : str\n            Name of the Text's layer in which syntactic analyses are stored; \n            Defaults to 'conll_syntax';\n        \n            For other parameters, see optional parameters of the methods:\n            \n             utils.normalise_alignments():          \"rep_miss_w_dummy\", \"fix_selfrefs\",\n                                                    \"keep_old\", \"mark_root\";\n             maltparser_support.align_CONLL_with_Text():  \"check_tokens\", \"add_word_ids\";\n\n    '''\n    # 1) Load conll analysed text from file\n    conll_lines = []\n    in_f = codecs.open(file_name, mode='r', encoding='utf-8')\n    for line in in_f:\n        # Skip comment lines\n        if line.startswith('#'):\n            continue\n        conll_lines.append( line.rstrip() )\n    in_f.close()\n    \n    # 2) Extract sentences and word tokens\n    sentences = []\n    sentence  = []\n    for i, line in enumerate( conll_lines ):\n        if len(line) > 0 and '\\t' in line:\n            features = line.split('\\t')\n            if len(features) != 10:\n                raise Exception(' In file '+in_file+', line '+str(i)+\\\n                                ' with unexpected format: \"'+line+'\" ')\n            word_id = features[0]\n            token   = features[1]\n            sentence.append( token )\n        elif len(line)==0 or re.match('^\\s+$', line):\n            # End of a sentence \n            if sentence:\n               # (!) Use double space instead of single space in order to distinguish\n               #     word-tokenizing space from the single space in the multiwords\n               #     (e.g. 'Rio de Janeiro' as a single word);\n               sentences.append( '  '.join(sentence) )\n            sentence = []\n    if sentence:\n        sentences.append( '  '.join(sentence) )\n    \n    # 3) Construct the estnltk's Text\n    kwargs4text = {\n      # Use custom tokenization utils in order to preserve exactly the same \n      # tokenization as was in the input;\n      \"word_tokenizer\": RegexpTokenizer(\"  \", gaps=True),\n      \"sentence_tokenizer\": LineTokenizer()\n    }\n    from estnltk.text import Text\n    text = Text( '\\n'.join(sentences), **kwargs4text )\n    # Tokenize up to the words layer\n    text.tokenize_words()\n    \n    # 4) Align syntactic analyses with the Text\n    alignments = align_CONLL_with_Text( conll_lines, text, None, **kwargs )\n    normalise_alignments( alignments, data_type=CONLL_DATA, **kwargs )\n    # Attach alignments to the text\n    text[ layer_name ] = alignments\n    return text", "response": "Reads the CONLL format syntactic analysis from a file and returns as a Text object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a list of word tokens and a list of dependency syntactic relations build a list of trees from the given sentence.", "response": "def build_trees_from_sentence( sentence, syntactic_relations, layer=LAYER_VISLCG3, \\\n                               sentence_id=0, **kwargs ):\n    ''' Given a sentence ( a list of EstNLTK's word tokens ), and a list of \n        dependency syntactic relations ( output of normalise_alignments() ),\n        builds trees ( estnltk.syntax.utils.Tree objects ) from the sentence,\n        and returns as a list of Trees (roots of trees).\n        \n        Note that  there  is  one-to-many  correspondence  between  EstNLTK's \n        sentences and dependency syntactic trees, so the resulting list can \n        contain more than one tree (root);\n    '''\n    trees_of_sentence = []\n    nodes = [ -1 ]\n    while( len(nodes) > 0 ):\n        node = nodes.pop(0)\n        # Find tokens in the sentence that take this node as their parent\n        for i, syntax_token in enumerate( syntactic_relations ):\n            parents = [ o[1] for o in syntax_token[PARSER_OUT] ]\n            # There should be only one parent node; If there is more than one, take the \n            # first node;\n            parent = parents[0]\n            if parent == node:\n                labels  = [ o[0] for o in syntax_token[PARSER_OUT] ]\n                estnltk_token = sentence[i]\n                tree1 = Tree( estnltk_token, i, sentence_id, labels, parser=layer )\n                if INIT_PARSER_OUT in syntax_token:\n                    tree1.parser_output = syntax_token[INIT_PARSER_OUT]\n                tree1.syntax_token = syntax_token\n                if parent == -1:\n                    # Add the root node\n                    trees_of_sentence.append( tree1 )\n                elif parent == i:\n                    # If, for some strange reason, the node is unnormalised and is still \n                    # linked to itself, add it as a singleton tree\n                    trees_of_sentence.append( tree1 )\n                else:\n                    # For each root node, attempt to add the child\n                    for root_node in trees_of_sentence:\n                        root_node.add_child_to_subtree( parent, tree1 )\n                if parent != i:\n                   # Add the current node as a future parent to be examined\n                   nodes.append( i )\n    return trees_of_sentence"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a text object and the name of the layer where dependency syntactic Relations are stored builds trees from all the sentences of the text and returns as a list of Trees.", "response": "def build_trees_from_text( text, layer, **kwargs ):\n    ''' Given a text object and the name of the layer where dependency syntactic \n        relations are stored, builds trees ( estnltk.syntax.utils.Tree objects )\n        from all the sentences of the text and returns as a list of Trees.\n        \n        Uses the method  build_trees_from_sentence()  for acquiring trees of each\n        sentence;\n        \n        Note that there is one-to-many correspondence between EstNLTK's sentences\n        and dependency syntactic trees: one sentence can evoke multiple trees;\n    '''\n    from estnltk.text import Text\n    assert isinstance(text, Text), \\\n           '(!) Unexpected text argument! Should be Estnltk\\'s Text object.'\n    assert layer in text, \\\n           '(!) The layer '+str(layer)+' is missing from the input text.'\n    text_sentences = list( text.divide( layer=WORDS, by=SENTENCES ) )\n    all_sentence_trees = []  # Collected sentence trees\n    prev_sent_id       = -1\n    #  (!) Note: if the Text object has been split into smaller Texts with split_by(),\n    #      SENT_ID-s still refer to old text, and thus are not useful as indices\n    #      anymore; \n    #      Therefore, we also use another variable -- norm_prev_sent_id -- that always\n    #      counts sentences starting from 0, and use  SENT_ID / prev_sent_id  only for \n    #      deciding whether one sentence ends and another begins;\n    norm_prev_sent_id  = -1\n    current_sentence   = []\n    k = 0\n    while k < len( text[layer] ):\n        node_desc = text[layer][k]\n        if prev_sent_id != node_desc[SENT_ID] and current_sentence:\n            norm_prev_sent_id += 1\n            # If the index of the sentence has changed, and we have collected a sentence, \n            # then build tree(s) from this sentence\n            assert norm_prev_sent_id<len(text_sentences), '(!) Sentence with the index '+str(norm_prev_sent_id)+\\\n                                                          ' not found from the input text.'\n            sentence = text_sentences[norm_prev_sent_id]\n            trees_of_sentence = \\\n                build_trees_from_sentence( sentence, current_sentence, layer, sentence_id=norm_prev_sent_id, \\\n                                           **kwargs )\n            # Record trees constructed from this sentence\n            all_sentence_trees.extend( trees_of_sentence )\n            # Reset the sentence collector\n            current_sentence = []\n        # Collect sentence\n        current_sentence.append( node_desc )\n        prev_sent_id = node_desc[SENT_ID]\n        k += 1\n    if current_sentence:\n        norm_prev_sent_id += 1\n        assert norm_prev_sent_id<len(text_sentences), '(!) Sentence with the index '+str(norm_prev_sent_id)+\\\n                                                      ' not found from the input text.'\n        sentence = text_sentences[norm_prev_sent_id]\n        # If we have collected a sentence, then build tree(s) from this sentence\n        trees_of_sentence = \\\n            build_trees_from_sentence( sentence, current_sentence, layer, sentence_id=norm_prev_sent_id, \\\n                                       **kwargs )\n        # Record trees constructed from this sentence\n        all_sentence_trees.extend( trees_of_sentence )\n    return all_sentence_trees"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_child_to_self( self, tree ):\n        ''' Adds given *tree* as a child of the current tree. '''\n        assert isinstance(tree, Tree), \\\n               '(!) Unexpected type of argument for '+argName+'! Should be Tree.'\n        if (not self.children):\n            self.children = []\n        tree.parent = self\n        self.children.append(tree)", "response": "Adds given tree as a child of the current tree."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_child_to_subtree( self, parent_word_id, tree ):\n        ''' Searches for the tree with *parent_word_id* from the current subtree \n            (from this tree and from all of its subtrees). If the parent tree is \n            found, attaches the given *tree* as its child. If the parent tree is\n            not found, the current tree is not changed.\n        '''\n        if (self.word_id == parent_word_id):\n            self.add_child_to_self( tree )\n        elif (self.children):\n            for child in self.children:\n                child.add_child_to_subtree(parent_word_id, tree)", "response": "Searches for the tree with parent_word_id from the current subtree \n            and adds it as a child of the given tree."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_root( self, **kwargs ):\n        ''' Returns this tree if it has no parents, or, alternatively, moves\n            up via the parent links of this tree until reaching the tree with\n            no parents, and returnes the parentless tree as the root.\n        '''\n        if self.parent == None:\n            return self\n        else:\n            return self.parent.get_root( **kwargs )", "response": "Returns this tree if it has no parents or returns the parentless tree if it has no parents."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _satisfies_conditions( self, tree_node, **kwargs ):\n        ''' Check whether given *tree_node* satisfies the conditions given\n            as arguments in *kwargs*.\n            \n            By default (if no conditions are given in *kwargs*), returns \n            True.\n            \n            If there are multiple conditions listed  (e.g.  'label_regexp'\n            and 'word_template'),  *True*  is returned only when the node \n            satisfies all the conditions.\n            \n            Following conditions are supported:\n            -----------------------------------\n            label : str\n                Syntactic label (e.g. '@SUBJ', '@OBJ' etc.) that the node \n                must have within its analysis; If the node does not have the\n                label, the node will be discarded;\n                \n            label_regexp : str\n                A regular expression pattern (as string) describing the \n                syntactic label (e.g. '@SUBJ', '@OBJ' etc.) that the node \n                must have within its analysis; \n                If none of the node's labels matches the pattern, the node\n                will be discarded;\n            \n            word_template : estnltk.mw_verbs.utils.WordTemplate\n                A WordTemplate describing morphological constraints imposed\n                to the word of the node;\n                If the word's morphological features do not match the template, \n                the node will be discarded;\n            \n        '''\n        matches = []\n        # A) Check syntactic label by matching a string\n        syntactic_label = kwargs.get('label', None)\n        if syntactic_label:\n            matches.append( bool(tree_node.labels and syntactic_label in tree_node.labels) )\n\n        # B) Check syntactic label by matching a regular expression\n        synt_label_regexp = kwargs.get('label_regexp', None)\n        if synt_label_regexp:\n            if isinstance(synt_label_regexp, basestring):\n                # Compile the regexp (if it hasn't been compiled yet)\n                synt_label_regexp = re.compile(synt_label_regexp)\n                kwargs['label_regexp'] = synt_label_regexp\n            if isinstance(synt_label_regexp, RE_TYPE):\n                # Apply the pre-compiled regexp\n                if tree_node.labels:\n                    matches.append( any([synt_label_regexp.match(label) != None for label in tree_node.labels]) )\n                else:\n                    matches.append( False )\n\n        # C) Check whether the word token of the node matches a word template\n        word_template = kwargs.get('word_template', None)\n        if word_template:\n            if isinstance(word_template, WordTemplate):\n                matches.append( word_template.matches( tree_node.token ) )\n            else:\n                raise Exception('(!) Unexpected word_template. Should be from class WordTemplate.')\n        return len(matches) == 0 or all(matches)", "response": "Returns True if given tree_node satisfies the conditions given by kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_children( self, **kwargs ):\n        ''' Recursively collects and returns all subtrees of given tree (if no \n            arguments are given), or, alternatively, collects and returns subtrees \n            satisfying some specific criteria (pre-specified in the arguments);\n            \n            Parameters\n            -----------\n            depth_limit : int\n                Specifies how deep into the subtrees of this tree the search goes;\n                Examples:\n                 depth_limit=2 -- children of this node, and also children's\n                                  direct children are considered as collectibles;\n                 depth_limit=1 -- only children of this node are considered;\n                 depth_limit=0 -- the end of search (only this node is considered);\n                Default: unbounded ( the search is not limited by depth )\n            \n            include_self : bool \n                Specifies whether this tree should also be included as a collectible\n                subtree. If this tree is includes, it still must satisfy all the \n                criteria before it is included in the collection;\n                Default: False\n            \n            sorted : bool\n                Specifies returned trees should be sorted in the ascending order of \n                word_ids (basically: by the order of words in the text);\n                If sorting is not applied, there is no guarantee that resulting trees\n                follow the order of words in text;\n                Default: False\n                \n            Following parameters can be used to set conditions for subtrees:\n            -----------------------------------------------------------------\n            label : str\n                Syntactic label (e.g. '@SUBJ', '@OBJ' etc.) that the node \n                must have within its analysis; If the node does not have the\n                label, the node will be discarded;\n            \n            label_regexp : str\n                A regular expression pattern (as string) describing the \n                syntactic label (e.g. '@SUBJ', '@OBJ' etc.) that the node \n                must have within its analysis; \n                If none of the node's labels matches the pattern, the node\n                will be discarded;\n            \n            word_template : estnltk.mw_verbs.utils.WordTemplate\n                A WordTemplate describing morphological constraints imposed\n                to the word of the node;\n                If the word's morphological features do not match the template, \n                the node will be discarded;\n            \n        '''\n        depth_limit  = kwargs.get('depth_limit', 922337203685477580) # Just a nice big number to\n                                                                     # assure that by default, \n                                                                     # there is no depth limit ...\n        include_self = kwargs.get('include_self', False)\n        sorted_by_word_ids = kwargs.get('sorted', False)\n        subtrees = []\n        if include_self:\n            if self._satisfies_conditions( self, **kwargs ):\n                subtrees.append( self )\n        if depth_limit >= 1 and self.children:\n            # 1) Add children of given tree\n            for child in self.children:\n                if self._satisfies_conditions( child, **kwargs ):\n                    subtrees.append(child)\n            # 2) Collect children of given tree's children\n            kwargs['include_self'] = False\n            kwargs['depth_limit']  = depth_limit - 1 \n            for child in self.children:\n                childs_results = child.get_children( **kwargs )\n                if childs_results:\n                    subtrees.extend(childs_results)\n        if sorted_by_word_ids:\n            # Sort by word_id-s, in ascending order\n            subtrees = sorted(subtrees, key=lambda x: x.word_id)\n        return subtrees", "response": "Returns a list of all children of a node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef as_dependencygraph( self, keep_dummy_root=False, add_morph=True ):\n        ''' Returns this tree as NLTK's DependencyGraph object.\n            \n            Note that this method constructs 'zero_based' graph,\n            where counting of the words starts from 0 and the \n            root index is -1 (not 0, as in Malt-TAB format);\n            \n            Parameters\n            -----------\n            add_morph : bool\n                Specifies whether the morphological information \n                (information about word lemmas, part-of-speech, and \n                features) should be added to graph nodes.\n                Note that even if **add_morph==True**, morphological\n                information is only added if it is available via\n                estnltk's layer  token['analysis'];\n                Default: True\n            keep_dummy_root : bool\n                Specifies whether the graph should include a dummy\n                TOP / ROOT node, which does not refer to any word,\n                and yet is the topmost node of the tree.\n                If the dummy root node is not used, then the root \n                node is the word node headed by -1;\n                Default: False\n            \n            For more information about NLTK's DependencyGraph, see:\n             http://www.nltk.org/_modules/nltk/parse/dependencygraph.html\n        '''\n        from nltk.parse.dependencygraph import DependencyGraph\n        graph = DependencyGraph( zero_based = True )\n        all_tree_nodes = [self] + self.get_children()\n        #\n        # 0) Fix the root\n        #\n        if keep_dummy_root:\n            #  Note: we have to re-construct  the root node manually, \n            #  as DependencyGraph's current interface seems to provide\n            #  no easy/convenient means for fixing the root node;\n            graph.nodes[-1] = graph.nodes[0]\n            graph.nodes[-1].update( { 'address': -1 } )\n            graph.root = graph.nodes[-1]\n        del graph.nodes[0]\n        #\n        # 1) Update / Add nodes of the graph \n        #\n        for child in all_tree_nodes:\n            rel  = 'xxx' if not child.labels else '|'.join(child.labels)\n            address = child.word_id\n            word    = child.text\n            graph.nodes[address].update(\n            {\n                'address': address,\n                'word':  child.text,\n                'rel':   rel,\n            } )\n            if not keep_dummy_root and child == self:\n                # If we do not keep the dummy root node, set this tree\n                # as the root node\n                graph.root = graph.nodes[address]\n            if add_morph and child.morph:\n                # Add morphological information, if possible\n                lemmas  = set([analysis[LEMMA] for analysis in child.morph])\n                postags = set([analysis[POSTAG] for analysis in child.morph])\n                feats   = set([analysis[FORM] for analysis in child.morph])\n                lemma  = ('|'.join( list(lemmas)  )).replace(' ','_')\n                postag = ('|'.join( list(postags) )).replace(' ','_')\n                feats  = ('|'.join( list(feats) )).replace(' ','_')\n                graph.nodes[address].update(\n                {\n                    'tag  ': postag,\n                    'ctag' : postag,\n                    'feats': feats,\n                    'lemma': lemma\n                } )\n\n        #\n        # 2) Update / Add arcs of the graph \n        #\n        for child in all_tree_nodes:\n            #  Connect children of given word\n            deps = [] if not child.children else [c.word_id for c in child.children]\n            head_address = child.word_id\n            for dep in deps:\n                graph.add_arc( head_address, dep )\n            if child.parent == None and keep_dummy_root:\n                graph.add_arc( -1, head_address )\n            #  Connect the parent of given node\n            head = -1 if not child.parent else child.parent.word_id\n            graph.nodes[head_address].update(\n            {\n                'head':  head,\n            } )\n        return graph", "response": "Returns this tree as a DependencyGraph object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_tree_depth( self ):\n        ''' Finds depth of this tree. '''\n        if (self.children):\n            depth = 1\n            childDepths = []\n            for child in self.children:\n                childDepths.append( child.get_tree_depth() )\n            return depth + max(childDepths)\n        else:\n            return 0", "response": "Returns the depth of this tree."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef debug_print_tree( self, spacing='' ):\n        ''' *Debug only* method for outputting the tree. '''\n        print (spacing+\" \"+str(self.word_id)+\" \"+str(self.text))\n        if (self.children):\n            spacing=spacing+\"  \"\n            for child in self.children:\n                child.debug_print_tree(spacing)", "response": "Debug only method for outputting the tree."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addRule(self, field, regExpPattern):\r\n        '''Adds new rule for checking whether a value of the field matches given regular \r\n           expression regExpPattern;\r\n        \r\n           Parameters\r\n           ----------\r\n           field: str\r\n                keyword, e.g. 'partofspeech', 'root', 'text' etc\r\n           regExpPattern: str\r\n                a regular expression that the value of the field must match (using method \r\n                re.match( regExpPattern, token[field]) ).\r\n        '''\r\n        compiled = re.compile( regExpPattern )\r\n        if field in self.analysisFields:\r\n            if self.analysisRules == None:\r\n                self.analysisRules = dict()\r\n            self.analysisRules[field] = compiled\r\n        else:\r\n            if self.otherRules == None:\r\n                self.otherRules = dict()\r\n            self.otherRules[field] = compiled", "response": "Adds a new rule for checking whether a value of the field matches given regular expression regExpPattern."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetermining whether the given token is in the WordTemplate.", "response": "def matches(self, tokenJson):\r\n        '''Determines whether given token (tokenJson) satisfies all the rules listed \r\n           in the WordTemplate. If the rules describe tokenJson[ANALYSIS], it is \r\n           required that at least one item in the list tokenJson[ANALYSIS] satisfies \r\n           all the rules (but it is not required that all the items should satisfy). \r\n           Returns a boolean value.\r\n        \r\n           Parameters\r\n           ----------\r\n           tokenJson: pyvabamorf's analysis of a single word token;\r\n        '''\r\n        if self.otherRules != None:\r\n            otherMatches = []\r\n            for field in self.otherRules:\r\n                match = field in tokenJson and ((self.otherRules[field]).match(tokenJson[field]) != None)\r\n                otherMatches.append( match )\r\n            if not otherMatches or not all(otherMatches):\r\n                return False\r\n            elif self.analysisRules == None and all(otherMatches):\r\n                return True\r\n        if self.analysisRules != None:\r\n            assert ANALYSIS in tokenJson, \"No ANALYSIS found within token: \"+str(tokenJson)\r\n            totalMatches = []\r\n            for analysis in tokenJson[ANALYSIS]:\r\n                # Check whether this analysis satisfies all the rules \r\n                # (if not, discard the analysis)\r\n                matches = []\r\n                for field in self.analysisRules:\r\n                    value = analysis[field] if field in analysis else \"\"\r\n                    match = (self.analysisRules[field]).match(value) != None\r\n                    matches.append( match )\r\n                    if not match:\r\n                        break\r\n                totalMatches.append( all(matches) )\r\n            #  Return True iff there was at least one analysis that \r\n            # satisfied all the rules;\r\n            return any(totalMatches)\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef matchingAnalyseIndexes(self, tokenJson):\r\n        '''Determines whether given token (tokenJson) satisfies all the rules listed \r\n           in the WordTemplate and returns a list of analyse indexes that correspond \r\n           to tokenJson[ANALYSIS] elements that are matching all the rules. \r\n           An empty list is returned if none of the analyses match (all the rules), \r\n           or (!) if none of the rules are describing the ANALYSIS part of the \r\n           token;\r\n\r\n           Parameters\r\n           ----------\r\n           tokenJson: pyvabamorf's analysis of a single word token;\r\n        '''\r\n        matchingResults = self.matchingAnalyses(tokenJson)\r\n        if matchingResults:\r\n            indexes = [ tokenJson[ANALYSIS].index(analysis) for analysis in matchingResults ]\r\n            return indexes\r\n        return matchingResults", "response": "Determines whether given token is in the WordTemplate and returns a list of analyse indexes that correspond to the analysis of the given token. Returns an empty list if no analysis of the given token is found."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of positions in the tokenArray where this WordTemplate matches. Returns an empty list if no matching tokens appear in the input list.", "response": "def matchingPositions(self, tokenArray):\r\n        '''Returns a list of positions (indexes) in the tokenArray where this WordTemplate\r\n           matches (the method self.matches(token) returns True). Returns an empty list if\r\n           no matching tokens appear in the input list.\r\n\r\n           Parameters\r\n           ----------\r\n           tokenArray: list of word tokens;\r\n                A list of word tokens along with their pyvabamorf's analyses;\r\n        '''\r\n        assert isinstance(tokenArray, list), \"tokenArray should be list \"+str(tokenArray)\r\n        matchingPos = []\r\n        for i in range( len(tokenArray) ):\r\n            token = tokenArray[i]\r\n            if self.matches(token):\r\n                matchingPos.append( i )\r\n        return matchingPos"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of tokens in the tokenArray that match this WordTemplate. Returns an empty list if no matching tokens appear in the input list.", "response": "def matchingTokens(self, tokenArray):\r\n        '''Returns a list of tokens in the tokenArray that match this WordTemplate (the \r\n           method self.matches(token) returns True). Returns an empty list if no matching \r\n           tokens appear in the input list.\r\n\r\n           Parameters\r\n           ----------\r\n           tokenArray: list of word tokens;\r\n                A list of word tokens along with their pyvabamorf's analyses;\r\n        '''\r\n        assert isinstance(tokenArray, list), \"tokenArray should be list \"+str(tokenArray)\r\n        matchingTok = []\r\n        for i in range( len(tokenArray) ):\r\n            token = tokenArray[i]\r\n            if self.matches(token):\r\n                matchingTok.append( token )\r\n        return matchingTok"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying this WordTemplate to all words of given text and adds results of the matching to the given layer.", "response": "def annotateText(self, text, layer, addEmptyAnnotations = True):\r\n        ''' Applies this WordTemplate ( more specifically: its method self.matchingTokens() )\r\n            on all words of given text, and adds results of the matching to the text as \r\n            a new annotation layer. Returns the input text (which is augmented with a new \r\n            layer).\r\n\r\n            Parameters\r\n            ----------\r\n            text: Text;\r\n                 A text where matching should be performed;\r\n            layer: str;\r\n                 name of the new layer;\r\n            addEmptyAnnotations: boolean, optional\r\n                 Whether the new layer should be added, if no match has been found?\r\n                 default: True\r\n        '''\r\n        from estnltk.text import Text\r\n        assert isinstance(text, Text), \"the input should be Text, but it is: \"+str(text)\r\n        #  1) Find words in text that match the given pattern\r\n        tokens = self.matchingTokens( text[WORDS] )\r\n        if not addEmptyAnnotations and not tokens:\r\n             # if we are not interested in empty annotations\r\n             return text\r\n        #  2) Annotated given text with found matches\r\n        if tokens:\r\n            # Matches found: add to the layer\r\n            text[layer] = [{START: t[START], END: t[END], TEXT:t[TEXT]} for t in tokens]\r\n        else:\r\n            # No matches found: add an empty layer\r\n            text[layer] = []\r\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the matches of the symbol on given text.", "response": "def get_matches(self, text, cache=None, conflict_resolver=resolve_using_maximal_coverage):\n        \"\"\"Get the matches of the symbol on given text.\"\"\"\n        is_root_node = False\n        if cache is None:\n            cache = {}\n            is_root_node = True\n        if id(self) in cache:\n            return cache[id(self)]\n        matches = self.get_matches_without_cache(text, cache=cache)\n        cache[id(self)] = matches\n\n        # if this is the root node, resolve the matches\n        if is_root_node and conflict_resolver is not None:\n            return conflict_resolver(matches)\n        return matches"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds all the ref tags in the text and adds them to the sectionObj s text field", "response": "def reffinder(sectionObj):\n    \"\"\"\n    add reference indeces to sectionobj['references']\n    :param sectionObj\n    :return: a section obj w references: field\n    \"\"\"\n    text = sectionObj['text']\n    reftags = [x for x in refTagRegEx.finditer(text)]\n    if reftags:\n        references = []\n        for tag in reftags:\n            references.append(int(tag.group(1)))\n\n        sectionObj['references'] = references\n\n        text = refTagRegEx.sub('', text)\n        sectionObj['text'] = text\n\n    return sectionObj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch for references in the text and returns the tagged text and a tag dictionary to be used in sectionParser", "response": "def referencesFinder(text):\n    \"\"\"\n    :param text: takes the whole text of an article, searches for references, cleans the text,\n    marks the reference indeces from zero inside the text.\n    :return: the tagged text and a tag:reference dictionary to be used in sectionParser\n    \"\"\"\n    references = referencesRegEx.finditer(text)\n    count = 0\n    refs = []\n    spans = []\n    for i in references:\n        refs.append(i.group())\n        spans.append(i.span())\n        count += 1\n    done = set()\n    nameRegEx = re.compile(r\"\"\"(name=[\"']*.*?[\"']*)(\\s|/|>)\"\"\")\n\n    for index, obj in enumerate(refs):\n\n        if obj.startswith('<ref name='):\n                nameTag = re.escape(nameRegEx.search(obj).group(1))\n\n                if nameTag not in done:\n                    nameTag = re.escape(nameRegEx.search(obj).group(1))\n                    indeces = [i for i, x in enumerate(refs) if re.search(nameTag, x)]\n                    matches = [refs[i] for i in indeces]\n                    full = max(matches, key=len)\n\n                    for i in indeces:\n                        refs[i] = full\n\n                    done.add(nameTag)\n\n    #eliminate <ref tag or other rudiments from the ref string\n\n    for i in range(len(refs)):\n        #print('SIIT', refs[i])\n        lastindex = refs[i].rindex('<')\n        firstindex = refs[i].index('>')+1\n        refs[i]=refs[i][firstindex:lastindex]\n\n    #Handle cite-references\n\n    for i in range(len(refs)):\n        if 'cite' in refs[i].lower():\n            newText = ''\n            values = refs[i].split('|')\n            for j in values:\n                if '=' in j:\n                    first = j.index('=')\n                    newText += j[first+1:].strip() + ';'\n            refs[i] = newText\n    #a ref string:position int dictionary\n    refspos = {}\n    c = 0\n    for i in refs:\n        if i not in refspos.keys():\n            refspos[i] = c\n            c +=1\n        else:\n            continue\n\n    #print(refspos)\n\n    #eliminate old, bad <ref> tags and insert clean  ones <ref 1..2..3/> to the same spot.\n    newText = ''\n    assert len(spans) == len(refs)\n    #Could happen... havent yet.\n    next = 0\n    for i in range(len(spans)):\n        start = spans[i][0]\n        newText+=text[next:start]+'<ref '+str(refspos[refs[i]])+'/>'\n        next = spans[i][1]\n\n    newText+=text[next:]\n\n    #switch keys:values in the dictionary for use in sectionsParser\n    #positiontag:ref\n    newDict  = {y:x for x,y in refspos.items()}\n\n    return newText, newDict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef imageParser(sectionObj):\n    text = ''\n    lastEnd = 0\n    ends = []\n    text = sectionObj['text']\n    imageStarts = [x.start() for x in imageRegEx.finditer(text)]\n    if imageStarts:\n        images =  []\n        for start in imageStarts:\n\n            imgText, end = balancedSlicer(text[start:])\n            end = start + end\n            ends.append(end)\n\n            #imgText = image.group(0).replace('[[', '').replace(']]', '')\n            img =  {'text':imgText}\n            imgText = imgText.split('|')\n\n            #t= imgText[-1].replace(']]', '')\n            t = imgText[-1][:-2]\n            url = urlBegin + imgText[0].replace(' ', '_').replace('[[', '')\n            img['text'] = t\n            img['url'] = url\n\n            if ExtLinkBracketedRegex.search(t):\n                img = addExternalLinks(img)\n\n            intlinks = [x for x in findBalanced(t, openDelim='[[', closeDelim=']]')]\n\n            if intlinks:\n                img = addIntLinks(img)\n\n            images.append(img)\n\n\n        sectionObj['images'] = images\n        spans = []\n        for i, j in zip(imageStarts, ends):\n            spans.append((i, j))\n\n        sectionObj['text'] = dropSpans(spans, text)\n    return sectionObj", "response": "parse image data into a single section"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_tagged(self, layer):\n        # we have a number of special names that are not layers but instead\n        # attributes of \"words\" layer\n        if layer == ANALYSIS:\n            if WORDS in self and len(self[WORDS]) > 0:\n                return ANALYSIS in self[WORDS][0]\n        elif layer == LAYER_CONLL:\n            if LAYER_CONLL in self and len(self[LAYER_CONLL]) > 0:\n                return PARSER_OUT in self[LAYER_CONLL][0]\n        elif layer == LAYER_VISLCG3:\n            if LAYER_VISLCG3 in self and len(self[LAYER_VISLCG3]) > 0:\n                return PARSER_OUT in self[LAYER_VISLCG3][0]\n        elif layer == LABEL:\n            if WORDS in self and len(self[WORDS]) > 0:\n                return LABEL in self[WORDS][0]\n        elif layer == CLAUSE_ANNOTATION:\n            if WORDS in self and len(self[WORDS]) > 0:\n                return CLAUSE_ANNOTATION in self[WORDS][0]\n        elif layer == WORDNET:\n            if WORDS in self and len(self[WORDS]) > 0:\n                if ANALYSIS in self[WORDS][0] and len(self[WORDS][0][ANALYSIS]) > 0:\n                    return WORDNET in self[WORDS][0][ANALYSIS][0]\n        else:\n            return layer in self\n        return False", "response": "Is the given element tokenized?"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving texts for given layer.", "response": "def texts(self, layer, sep=' '):\n        \"\"\"Retrieve texts for given layer.\n\n        Parameters\n        ----------\n\n        sep: str\n            Separator for multilayer elements (default: ' ').\n\n        Returns\n        -------\n        list of str\n            List of strings that make up given layer.\n        \"\"\"\n        return self.texts_from_spans(self.spans(layer), sep)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef texts_from_spans(self, spans, sep=' '):\n        text = self.text\n        texts = []\n        for start, end in spans:\n            if isinstance(start, list):\n                texts.append(sep.join(text[s:e] for s, e in zip(start, end)))\n            else:\n                texts.append(text[start:end])\n        return texts", "response": "Retrieve texts from a list of start and end positions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving start end tuples denoting the spans of given layer elements.", "response": "def spans(self, layer):\n        \"\"\"Retrieve (start, end) tuples denoting the spans of given layer elements.\n\n        Returns\n        -------\n        list of (int, int)\n            List of (start, end) tuples.\n        \"\"\"\n        spans = []\n        for data in self[layer]:\n            spans.append((data[START], data[END]))\n        return spans"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving start positions of elements if given layer.", "response": "def starts(self, layer):\n        \"\"\"Retrieve start positions of elements if given layer.\"\"\"\n        starts = []\n        for data in self[layer]:\n            starts.append(data[START])\n        return starts"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves end positions of elements if given layer.", "response": "def ends(self, layer):\n        \"\"\"Retrieve end positions of elements if given layer.\"\"\"\n        ends = []\n        for data in self[layer]:\n            ends.append(data[END])\n        return ends"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef layer_tagger_mapping(self):\n        return {\n            PARAGRAPHS: self.tokenize_paragraphs,\n            SENTENCES: self.tokenize_sentences,\n            WORDS: self.tokenize_words,\n            ANALYSIS: self.tag_analysis,\n            TIMEXES: self.tag_timexes,\n            NAMED_ENTITIES: self.tag_named_entities,\n            CLAUSE_ANNOTATION: self.tag_clause_annotations,\n            CLAUSES: self.tag_clauses,\n            LAYER_CONLL:   self.tag_syntax_vislcg3,\n            LAYER_VISLCG3: self.tag_syntax_maltparser,\n            WORDNET: self.tag_wordnet\n        }", "response": "Dictionary that maps layer names to taggers that can create that layer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntagging the annotations of given layer.", "response": "def tag(self, layer):\n        \"\"\"Tag the annotations of given layer. It can automatically tag any built-in layer type.\"\"\"\n        mapping = self.layer_tagger_mapping\n        if layer in mapping:\n            mapping[layer]()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tokenize_paragraphs(self):\n        tok = self.__paragraph_tokenizer\n        spans = tok.span_tokenize(self.text)\n        dicts = []\n        for start, end in spans:\n            dicts.append({'start': start, 'end': end})\n        self[PARAGRAPHS] = dicts\n        return self", "response": "Apply paragraph tokenization to this Text instance. Creates paragraphs layer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef paragraph_texts(self):\n        if not self.is_tagged(PARAGRAPHS):\n            self.tokenize_paragraphs()\n        return self.texts(PARAGRAPHS)", "response": "The list of texts representing paragraphs layer elements."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\napplies sentence tokenization to this Text instance. Creates sentences layer.", "response": "def tokenize_sentences(self):\n        \"\"\"Apply sentence tokenization to this Text instance. Creates ``sentences`` layer.\n           Automatically tokenizes paragraphs, if they are not already tokenized.\n           Also, if word tokenization has already been performed, tries to fit \n           the sentence tokenization into the existing word tokenization;\n        \"\"\"\n        if not self.is_tagged(PARAGRAPHS):\n            self.tokenize_paragraphs()\n        tok  = self.__sentence_tokenizer\n        text = self.text\n        dicts = []\n        for paragraph in self[PARAGRAPHS]:\n            para_start, para_end = paragraph[START], paragraph[END]\n            para_text = text[para_start:para_end]\n            if not self.is_tagged(WORDS):\n                # Non-hack variant: word tokenization has not been applied yet,\n                # so we proceed in natural order (first sentences, then words)\n                spans = tok.span_tokenize(para_text)\n                for start, end in spans:\n                    dicts.append({'start': start+para_start, 'end': end+para_start})\n            else:\n                # A hack variant: word tokenization has already been made, so\n                # we try to use existing word tokenization (first words, then sentences)\n                para_words = \\\n                    [ w for w in self[WORDS] if w[START]>=para_start and w[END]<=para_end ]\n                para_word_texts = \\\n                    [ w[TEXT] for w in para_words ]\n                try:\n                    # Apply sentences_from_tokens method (if available)\n                    sents = tok.sentences_from_tokens( para_word_texts )\n                except AttributeError as e:\n                    raise\n                # Align result of the sentence tokenization with the initial word tokenization\n                # in order to determine the sentence boundaries\n                i = 0\n                for sentence in sents:\n                    j = 0\n                    firstToken = None\n                    lastToken  = None\n                    while i < len(para_words):\n                        if para_words[i][TEXT] != sentence[j]:\n                            raise Exception('Error on aligning: ', para_word_texts,' and ',sentence,' at positions ',i,j)\n                        if j == 0:\n                            firstToken = para_words[i]\n                        if j == len(sentence) - 1:\n                            lastToken = para_words[i]\n                            i+=1\n                            break\n                        j+=1\n                        i+=1\n                    sentenceDict = \\\n                        {'start': firstToken[START], 'end': lastToken[END]}\n                    dicts.append( sentenceDict )\n                # Note: We also need to invalidate the cached properties providing the\n                #       sentence information, as otherwise, if the properties have been\n                #       called already, new calls would return the old state of sentence \n                #       tokenization;\n                for sentence_attrib in ['sentences', 'sentence_texts', 'sentence_spans', \\\n                                        'sentence_starts', 'sentence_ends']:\n                    try:\n                        # invalidate the cache\n                        delattr(self, sentence_attrib)\n                    except AttributeError:\n                        # it's ok, if the cached property has not been called yet\n                        pass\n        self[SENTENCES] = dicts\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sentence_spans(self):\n        if not self.is_tagged(SENTENCES):\n            self.tokenize_sentences()\n        return self.spans(SENTENCES)", "response": "The list of spans representing sentences layer elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sentence_ends(self):\n        if not self.is_tagged(SENTENCES):\n            self.tokenize_sentences()\n        return self.ends(SENTENCES)", "response": "The list of end positions representing sentences layer elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\napplies word tokenization and create words layer.", "response": "def tokenize_words(self):\n        \"\"\"Apply word tokenization and create ``words`` layer.\n\n        Automatically creates ``paragraphs`` and ``sentences`` layers.\n        \"\"\"\n        if not self.is_tagged(SENTENCES):\n            self.tokenize_sentences()\n        tok = self.__word_tokenizer\n        text = self.text\n        dicts = []\n        for sentence in self[SENTENCES]:\n            sent_start, sent_end = sentence[START], sentence[END]\n            sent_text = text[sent_start:sent_end]\n            spans = tok.span_tokenize(sent_text)\n            for start, end in spans:\n                dicts.append({START: start+sent_start, END: end+sent_start, TEXT: sent_text[start:end]})\n        self[WORDS] = dicts\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntag words layer with morphological analysis attributes.", "response": "def tag_analysis(self):\n        \"\"\"Tag ``words`` layer with morphological analysis attributes.\"\"\"\n        if not self.is_tagged(WORDS):\n            self.tokenize_words()\n        sentences = self.divide(WORDS, SENTENCES)\n        for sentence in sentences:\n            texts = [word[TEXT] for word in sentence]\n            all_analysis = vabamorf.analyze(texts, **self.__kwargs)\n            for word, analysis in zip(sentence, all_analysis):\n                word[ANALYSIS] = analysis[ANALYSIS]\n                word[TEXT] = analysis[TEXT]\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef word_texts(self):\n        if not self.is_tagged(WORDS):\n            self.tokenize_words()\n        return [word[TEXT] for word in self[WORDS]]", "response": "The list of words representing words layer elements."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the list of analysis elements of words layer.", "response": "def get_analysis_element(self, element, sep='|'):\n        \"\"\"The list of analysis elements of ``words`` layer.\n\n        Parameters\n        ----------\n        element: str\n            The name of the element, for example \"lemma\", \"postag\".\n        sep: str\n            The separator for ambiguous analysis (default: \"|\").\n            As morphological analysis cannot always yield unambiguous results, we\n            return ambiguous values separated by the pipe character as default.\n        \"\"\"\n        return [self.__get_key(word[ANALYSIS], element, sep) for word in self.words]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lemmas(self):\n        if not self.is_tagged(ANALYSIS):\n            self.tag_analysis()\n        return self.get_analysis_element(LEMMA)", "response": "The list of lemmas."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lemma_lists(self):\n        if not self.is_tagged(ANALYSIS):\n            self.tag_analysis()\n        return [[an[LEMMA] for an in word[ANALYSIS]] for word in self[WORDS]]", "response": "A list of lemma lists."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef endings(self):\n        if not self.is_tagged(ANALYSIS):\n            self.tag_analysis()\n        return self.get_analysis_element(ENDING)", "response": "The list of word endings."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef forms(self):\n        if not self.is_tagged(ANALYSIS):\n            self.tag_analysis()\n        return self.get_analysis_element(FORM)", "response": "Tthe list of word forms."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef postags(self):\n        if not self.is_tagged(ANALYSIS):\n            self.tag_analysis()\n        return self.get_analysis_element(POSTAG)", "response": "The list of word part - of - speech tags."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef postag_descriptions(self):\n        if not self.is_tagged(ANALYSIS):\n            self.tag_analysis()\n        return [POSTAG_DESCRIPTIONS.get(tag, '') for tag in self.get_analysis_element(POSTAG)]", "response": "Human - readable POS - tag descriptions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef root_tokens(self):\n        if not self.is_tagged(ANALYSIS):\n            self.tag_analysis()\n        return self.get_analysis_element(ROOT_TOKENS)", "response": "Root tokens of word roots."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tag_syntax_vislcg3(self):\n        if not self.__syntactic_parser or not isinstance(self.__syntactic_parser, VISLCG3Parser):\n            self.__syntactic_parser = VISLCG3Parser()\n        return self.tag_syntax()", "response": "Sets the default syntactic parser to VISLCG3Parser performs syntactic analysis and stores the results in the layer named LAYER_VISLCG3."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tag_syntax_maltparser(self):\n        if not self.__syntactic_parser or not isinstance(self.__syntactic_parser, MaltParser):\n            self.__syntactic_parser = MaltParser()\n        return self.tag_syntax()", "response": "Changes default syntactic parser to MaltParser performs syntactic analysis and stores the results in the layer named LAYER_CONLL."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing this text with the syntactic analyzer and stores the found syntactic analyses into the layer LAYER_CONLL or LAYER_VISLCG3.", "response": "def tag_syntax(self):\n        \"\"\" Parses this text with the syntactic analyzer (``self.__syntactic_parser``), \n            and stores the found syntactic analyses: into the layer LAYER_CONLL (if MaltParser \n            is used, default), or into the layer LAYER_VISLCG3 (if VISLCG3Parser is used).\n        \"\"\"\n        # Load default Syntactic tagger:\n        if self.__syntactic_parser is None:\n            self.__syntactic_parser = load_default_syntactic_parser()\n        if not self.is_tagged(ANALYSIS):\n            if isinstance(self.__syntactic_parser, MaltParser):\n                # By default: Use disambiguation for MaltParser's input\n                if 'disambiguate' not in self.__kwargs:\n                    self.__kwargs['disambiguate'] = True\n                self.tag_analysis()\n            elif isinstance(self.__syntactic_parser, VISLCG3Parser):\n                # By default: Do not use disambiguation for VISLCG3Parser's input\n                #   (VISLCG3 already does its own rule-based disambiguation)\n                if 'disambiguate' not in self.__kwargs:\n                    self.__kwargs['disambiguate'] = False\n                self.tag_analysis()\n        return self.__syntactic_parser.parse_text( self, **self.__kwargs )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild a list of syntax trees from the given syntactic annotations and returns as a list. The list is a list of Tree objects.", "response": "def syntax_trees( self, layer=None ):\n        \"\"\" Builds syntactic trees (estnltk.syntax.utils.Tree objects) from \n            syntactic annotations and returns as a list. \n            \n            If the input argument *layer* is not specified, the type of the\n            syntactic parser is used to decide, which syntactic analysis layer \n            should be produced and taken as basis for building syntactic trees;\n            If a syntactic parser is not available, then a missing *layer* name \n            is replaced by the first syntactic layer available (1st LAYER_CONLL,\n            then LAYER_VISLCG3);\n            Otherwise, the *layer* must be provided by the user and it must be \n            either LAYER_CONLL or LAYER_VISLCG3. \n        \"\"\"\n        # If no layer specified, decide the layer based on the type of syntactic\n        # analyzer used:\n        if not layer and self.__syntactic_parser:\n            if isinstance(self.__syntactic_parser, MaltParser):\n                layer = LAYER_CONLL\n            elif isinstance(self.__syntactic_parser, VISLCG3Parser):\n                layer = LAYER_VISLCG3\n        # If no syntactic analyzer available, pick the layer as the first syntactic\n        # layer available:\n        if not layer and self.is_tagged(LAYER_CONLL):\n            layer = LAYER_CONLL\n        elif not layer and self.is_tagged(LAYER_VISLCG3):\n            layer = LAYER_VISLCG3\n        # Based on the chosen layer, perform the syntactic analysis (if necessary)\n        # and return the results packaged as tree objects;\n        if layer:\n            if layer==LAYER_CONLL:\n                if not self.is_tagged(layer):\n                    self.tag_syntax_maltparser()\n                return self.syntax_trees_conll\n            elif layer==LAYER_VISLCG3:\n                if not self.is_tagged(layer):\n                    self.tag_syntax_vislcg3()\n                return self.syntax_trees_vislcg3\n            else:\n                raise ValueError('(!) Unexpected layer name: '+str(layer))\n        else:\n            raise ValueError('(!) Missing layer name! ')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tag_labels(self):\n        if not self.is_tagged(ANALYSIS):\n            self.tag_analysis()\n        if self.__ner_tagger is None:\n            self.__ner_tagger = load_default_ner_tagger()\n        self.__ner_tagger.tag_document(self)\n        return self", "response": "Tag named entity labels in the words layer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntagging ``named_entities`` layer. This automatically performs morphological analysis along with all dependencies.", "response": "def tag_named_entities(self):\n        \"\"\"Tag ``named_entities`` layer.\n\n        This automatically performs morphological analysis along with all dependencies.\n        \"\"\"\n        if not self.is_tagged(LABEL):\n            self.tag_labels()\n        nes = []\n        word_start = -1\n        labels = self.labels + ['O'] # last is sentinel\n        words = self.words\n        label = 'O'\n        for i, l in enumerate(labels):\n            if l.startswith('B-') or l == 'O':\n                if word_start != -1:\n                    nes.append({START: words[word_start][START],\n                                END: words[i-1][END],\n                                LABEL: label})\n                if l.startswith('B-'):\n                    word_start = i\n                    label = l[2:]\n                else:\n                    word_start = -1\n        self[NAMED_ENTITIES] = nes\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef named_entity_labels(self):\n        if not self.is_tagged(NAMED_ENTITIES):\n            self.tag_named_entities()\n        return [ne[LABEL] for ne in self[NAMED_ENTITIES]]", "response": "The named entity labels without BIO prefixes."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tag_timexes(self):\n        if not self.is_tagged(ANALYSIS):\n            self.tag_analysis()\n        if not self.is_tagged(TIMEXES):\n            if self.__timex_tagger is None:\n                self.__timex_tagger = load_default_timex_tagger()\n            self.__timex_tagger.tag_document(self, **self.__kwargs)\n        return self", "response": "Create a timexes layer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef timex_spans(self):\n        if not self.is_tagged(TIMEXES):\n            self.tag_timexes()\n        return self.spans(TIMEXES)", "response": "The list of spans of the timexes layer elements."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntagging clause annotations in words layer. Depends on morphological analysis.", "response": "def tag_clause_annotations(self):\n        \"\"\"Tag clause annotations in ``words`` layer.\n        Depends on morphological analysis.\n        \"\"\"\n        if not self.is_tagged(ANALYSIS):\n            self.tag_analysis()\n        if self.__clause_segmenter is None:\n            self.__clause_segmenter = load_default_clausesegmenter()\n        return self.__clause_segmenter.tag(self)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clause_annotations(self):\n        if not self.is_tagged(CLAUSE_ANNOTATION):\n            self.tag_clause_annotations()\n        return [word.get(CLAUSE_ANNOTATION, None) for word in self[WORDS]]", "response": "The list of clause annotations in words layer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tag_clauses(self):\n        if not self.is_tagged(CLAUSE_ANNOTATION):\n            self.tag_clause_annotations()\n\n        def from_sentence(words):\n            \"\"\"Function that extracts clauses from a signle sentence.\"\"\"\n            clauses = defaultdict(list)\n            start = words[0][START]\n            end = words[0][END]\n            clause = words[0][CLAUSE_IDX]\n            for word in words:\n                if word[CLAUSE_IDX] != clause:\n                    clauses[clause].append((start, end))\n                    start, clause = word[START], word[CLAUSE_IDX]\n                end = word[END]\n            clauses[clause].append((start, words[-1][END]))\n            clauses = [(key, {START: [s for s, e in clause], END: [e for s, e in clause]}) for key, clause in clauses.items()]\n            return [v for k, v in sorted(clauses)]\n\n        clauses = []\n        sentences = self.divide()\n        for sentence in sentences:\n            clauses.extend(from_sentence(sentence))\n\n        self[CLAUSES] = clauses\n        return self", "response": "Create ``clauses`` multilayer.\n\n        Depends on clause annotations."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clause_texts(self):\n        if not self.is_tagged(CLAUSES):\n            self.tag_clauses()\n        return self.texts(CLAUSES)", "response": "The texts of clauses multilayer elements."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate wordnet attribute in words layer.", "response": "def tag_wordnet(self, **kwargs):\n        \"\"\"Create wordnet attribute in ``words`` layer.\n\n        See :py:meth:`~estnltk.text.wordnet_tagger.WordnetTagger.tag_text` method\n        for applicable keyword arguments.\n        \"\"\"\n        global wordnet_tagger\n        if wordnet_tagger is None: # cached wn tagger\n            wordnet_tagger = WordnetTagger()\n        self.__wordnet_tagger = wordnet_tagger\n        if len(kwargs) > 0:\n            return self.__wordnet_tagger.tag_text(self, **kwargs)\n        return self.__wordnet_tagger.tag_text(self, **self.__kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef synsets(self):\n        synsets = []\n        for wn_annots in self.wordnet_annotations:\n            word_synsets = []\n            for wn_annot in wn_annots:\n                for synset in wn_annot.get(SYNSETS, []):\n                    word_synsets.append(deepcopy(synset))\n            synsets.append(word_synsets)\n        return synsets", "response": "The list of synsets of words layer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef word_literals(self):\n        literals = []\n        for word_synsets in self.synsets:\n            word_literals = set()\n            for synset in word_synsets:\n                for variant in synset.get(SYN_VARIANTS):\n                    if LITERAL in variant:\n                        word_literals.add(variant[LITERAL])\n            literals.append(list(sorted(word_literals)))\n        return literals", "response": "The list of literals per word in words layer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef spelling(self):\n        if not self.is_tagged(WORDS):\n            self.tokenize_words()\n        return [data[SPELLING] for data in vabamorf.spellcheck(self.word_texts, suggestions=False)]", "response": "Returns a list of booleans where each element denotes if the word at the same position is spelled correctly."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef spelling_suggestions(self):\n        if not self.is_tagged(WORDS):\n            self.tokenize_words()\n        return [data[SUGGESTIONS] for data in vabamorf.spellcheck(self.word_texts, suggestions=True)]", "response": "The list of spelling suggestions per misspelled word."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef spellcheck_results(self):\n        if not self.is_tagged(WORDS):\n            self.tokenize_words()\n        return vabamorf.spellcheck(self.word_texts, suggestions=True)", "response": "The list of True or False values denoting the correct spelling of words."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfixing spelling of the text.", "response": "def fix_spelling(self):\n        \"\"\"Fix spelling of the text.\n\n        Note that this method uses the first suggestion that is given for each misspelled word.\n        It does not perform any sophisticated analysis to determine which one of the suggestions\n        fits best into the context.\n\n        Returns\n        -------\n        Text\n            A copy of this instance with automatically fixed spelling.\n        \"\"\"\n        if not self.is_tagged(WORDS):\n            self.tokenize_words()\n        text = self.text\n        fixed = vabamorf.fix_spelling(self.word_texts, join=False)\n        spans = self.word_spans\n        assert len(fixed) == len(spans)\n        if len(spans) > 0:\n            newtoks = []\n            lastend = 0\n            for fix, (start, end) in zip(fixed, spans):\n                newtoks.append(text[lastend:start])\n                newtoks.append(fix)\n                lastend = end\n            newtoks.append(text[lastend:])\n            return Text(''.join(newtoks), **self.__kwargs)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clean(self):\n        return Text(self.__text_cleaner.clean(self[TEXT]), **self.__kwargs)", "response": "Return a copy of this Text instance with invalid characters removed."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef split_given_spans(self, spans, sep=' '):\n        N = len(spans)\n        results = [{TEXT: text} for text in self.texts_from_spans(spans, sep=sep)]\n        for elem in self:\n            if isinstance(self[elem], list):\n                splits = divide_by_spans(self[elem], spans, translate=True, sep=sep)\n                for idx in range(N):\n                    results[idx][elem] = splits[idx]\n        return [Text(res) for res in results]", "response": "Split the text into several pieces."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsplit the text into multiple instances defined by elements of given layer.", "response": "def split_by(self, layer, sep=' '):\n        \"\"\"Split the text into multiple instances defined by elements of given layer.\n\n        The spans for layer elements are extracted and feed to :py:meth:`~estnltk.text.Text.split_given_spans`\n        method.\n\n        Parameters\n        ----------\n        layer: str\n            String determining the layer that is used to define the start and end positions of resulting splits.\n        sep: str (default: ' ')\n            The separator to use to join texts of multilayer elements.\n\n        Returns\n        -------\n        list of Text\n        \"\"\"\n        if not self.is_tagged(layer):\n            self.tag(layer)\n        return self.split_given_spans(self.spans(layer), sep=sep)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsplitting the text into multiple Text instances using a regular expression.", "response": "def split_by_regex(self, regex_or_pattern, flags=re.U, gaps=True):\n        \"\"\"Split the text into multiple instances using a regex.\n\n        Parameters\n        ----------\n        regex_or_pattern: str or compiled pattern\n            The regular expression to use for splitting.\n        flags: int (default: re.U)\n            The regular expression flags (only used, when user has not supplied compiled regex).\n        gaps: boolean (default: True)\n            If True, then regions matched by the regex are not included in the resulting Text instances, which\n            is expected behaviour.\n            If False, then only regions matched by the regex are included in the result.\n\n        Returns\n        -------\n        list of Text\n            The Text instances obtained by splitting.\n        \"\"\"\n\n        text = self[TEXT]\n        regex = regex_or_pattern\n        if isinstance(regex, six.string_types):\n            regex = re.compile(regex_or_pattern, flags=flags)\n        # else is assumed pattern\n        last_end = 0\n        spans = []\n        if gaps: # tag cap spans\n            for mo in regex.finditer(text):\n                start, end = mo.start(), mo.end()\n                if start > last_end:\n                    spans.append((last_end, start))\n                last_end = end\n            if last_end < len(text):\n                spans.append((last_end, len(text)))\n        else: # use matched regions\n            spans = [(mo.start(), mo.end()) for mo in regex.finditer(text)]\n        return self.split_given_spans(spans)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef divide(self, layer=WORDS, by=SENTENCES):\n        if not self.is_tagged(layer):\n            self.tag(layer)\n        if not self.is_tagged(by):\n            self.tag(by)\n        return divide(self[layer], self[by])", "response": "Divide the Text into pieces by keeping references to original elements when possible."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning that creates tags that are not overlapping with the concatenated css classes.", "response": "def create_tags_with_concatenated_css_classes(tags):\n    \"\"\"Function that creates <mark> tags such that they are not overlapping.\n    In order to do this, it concatenates the css classes and stores the concatenated\n    result in new tags.\n    \"\"\"\n    current_classes = set()\n    result = []\n    for pos, group in group_tags_at_same_position(tags):\n        opening, closing = get_opening_closing_tags(group)\n        # handle closing tags at current position\n        closing_added = False\n        if len(closing) > 0:\n            closing_tag = Tag(pos, False, '')\n            for tag in closing:\n                current_classes.remove(tag.css_class)\n            result.append(closing_tag)\n            closing_added = True\n        # handle opening tags at current position\n        opening_added = False\n        if len(opening) > 0:\n            # handle the begin of an overlap\n            if not closing_added and len(current_classes) > 0:\n                result.append(Tag(pos, False, ''))\n            for tag in opening:\n                current_classes.add(tag.css_class)\n            opening_tag = Tag(pos, True, ' '.join(sorted(current_classes)))\n            result.append(opening_tag)\n            opening_added = True\n        # handle the end of an overlap\n        if closing_added and not opening_added and len(current_classes) > 0:\n            opening_tag = Tag(pos, True, ' '.join(sorted(current_classes)))\n            result.append(opening_tag)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a list of matches select a subset of matches that have the maximum number of covered characters.", "response": "def resolve_using_maximal_coverage(matches):\n    \"\"\"Given a list of matches, select a subset of matches\n    such that there are no overlaps and the total number of\n    covered characters is maximal.\n\n    Parameters\n    ----------\n    matches: list of Match\n\n    Returns\n    --------\n    list of Match\n    \"\"\"\n    if len(matches) == 0:\n        return matches\n    matches.sort()\n    N = len(matches)\n    scores = [len(match) for match in matches]\n    prev = [-1] * N\n    for i in range(1, N):\n        bestscore = -1\n        bestprev = -1\n        j = i\n        while j >= 0:\n            # if matches do not overlap\n            if matches[j].is_before(matches[i]):\n                l = scores[j] + len(matches[i])\n                if l >= bestscore:\n                    bestscore = l\n                    bestprev = j\n            else:\n                # in case of overlapping matches\n                l = scores[j] - len(matches[j]) + len(matches[i])\n                if l >= bestscore:\n                    bestscore = l\n                    bestprev = prev[j]\n            j = j - 1\n        scores[i] = bestscore\n        prev[i] = bestprev\n    # first find the matching with highest combined score\n    bestscore = max(scores)\n    bestidx = len(scores) - scores[-1::-1].index(bestscore) -1\n    # then backtrack the non-conflicting matchings that should be kept\n    keepidxs = [bestidx]\n    bestidx = prev[bestidx]\n    while bestidx != -1:\n        keepidxs.append(bestidx)\n        bestidx = prev[bestidx]\n    # filter the matches\n    return [matches[idx] for idx in reversed(keepidxs)]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if the given list of possible clause breaks are separated by possible clause breaks.", "response": "def _isSeparatedByPossibleClauseBreakers( tokens, wordID1, wordID2, punctForbidden = True, \\\r\n                                                                    commaForbidden = True, \\\r\n                                                                    conjWordsForbidden = True ):\r\n    '''\r\n         Teeb kindlaks, kas j2rjendi tokens s6naindeksite vahemikus [wordID1, wordID2) (vahemiku \r\n        algus on inklusiivne) leidub sides6nu (ja/ning/ega/v6i), punktuatsiooni (koma, \r\n        sidekriipsud, koolon, kolm j2rjestikkust punkti) v6i adverbe-sidendeid aga/kuid/vaid;\r\n         Lippudega saab kontrolli l6dvendada:\r\n          *) punctForbidden=False lylitab v2lja punktuatsiooni ( kirjavahem2rgid v.a koma ) \r\n             kontrolli;\r\n          *) commaForbidden=False lylitab v2lja koma kontrolli ( ei puuduta teisi kirjavahem2rke ) \r\n             kontrolli;\r\n          *) conjWordsForbidden=False lylitab v2lja sides6nade ja adverb-sidendite kontrolli;\r\n         Tagastab True, kui leidub kasv6i yks eelnimetatud juhtudest, vastasel juhul False;\r\n    '''\r\n    global _breakerJaNingEgaVoi, _breakerAgaKuidVaid, _breakerKomaLopus, _breakerPunktuats\r\n    minWID = min(wordID1, wordID2)\r\n    maxWID = max(wordID1, wordID2)\r\n    insideCheckArea = False\r\n    for i in range(len(tokens)):\r\n        token = tokens[i]\r\n        if token[WORD_ID] >= minWID:\r\n            insideCheckArea = True\r\n        if token[WORD_ID] >= maxWID:\r\n            insideCheckArea = False\r\n        if insideCheckArea:\r\n            if punctForbidden and _breakerPunktuats.matches(token):\r\n                return True\r\n            if commaForbidden and _breakerKomaLopus.matches(token):\r\n                return True\r\n            if conjWordsForbidden and (_breakerAgaKuidVaid.matches(token) or \\\r\n               _breakerJaNingEgaVoi.matches(token)):\r\n                return True\r\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if the wordID is in the final clause False otherwise.", "response": "def _isClauseFinal( wordID, clauseTokens ):\r\n    '''\r\n        Teeb kindlaks, kas etteantud ID-ga s6na on osalause l6pus:\r\n          -- s6nale ei j2rgne ykski teine s6na;\r\n          -- s6nale j2rgnevad vaid punktuatsioonim2rgid ja/v6i sidendid JA/NING/EGA/V\u00d5I;\r\n        Tagastab True, kui eeltoodud tingimused on t2idetud, vastasel juhul False;\r\n    '''\r\n    jaNingEgaVoi  = WordTemplate({ROOT:'^(ja|ning|ega|v[\\u014D\\u00F5]i)$',POSTAG:'[DJ]'})\r\n    punktuatsioon = WordTemplate({POSTAG:'Z'})\r\n    for i in range(len(clauseTokens)):\r\n        token = clauseTokens[i]\r\n        if token[WORD_ID] == wordID:\r\n            if i+1 == len(clauseTokens):\r\n                return True\r\n            else:\r\n                for j in range(i+1, len(clauseTokens)):\r\n                    token2 = clauseTokens[j]\r\n                    if not (jaNingEgaVoi.matches(token2) or punktuatsioon.matches(token2)):\r\n                        return False\r\n                return True\r\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if the wordID is following a comma - separated list of tokens.", "response": "def _isFollowedByComma( wordID, clauseTokens ):\r\n    '''\r\n        Teeb kindlaks, kas etteantud ID-ga s6nale j2rgneb vahetult koma;\r\n        Tagastab True, kui eeltoodud tingimus on t2idetud, vastasel juhul False;\r\n    '''\r\n    koma = WordTemplate({ROOT:'^,+$', POSTAG:'Z'})\r\n    for i in range(len(clauseTokens)):\r\n        token = clauseTokens[i]\r\n        if token[WORD_ID] == wordID:\r\n            if re.match('^.*,$', token[TEXT]):\r\n                return True\r\n            elif i+1 < len(clauseTokens) and koma.matches(clauseTokens[i+1]):\r\n                return True\r\n            break\r\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _canFormAraPhrase( araVerb, otherVerb ):\r\n    '''  Teeb kindlaks, kas etteantud '\u00e4ra' verb (araVerb) yhildub teise verbiga; \r\n        Arvestab j\u00e4rgimisi \u00fchilduvusi:\r\n            ains 2. p\u00f6\u00f6re:     \u00e4ra_neg.o   + V_o\r\n            ains 3. p\u00f6\u00f6re:     \u00e4ra_neg.gu  + V_gu\r\n            mitm 1. p\u00f6\u00f6re:     \u00e4ra_neg.me  + V_me\r\n                               \u00e4ra_neg.me  + V_o\r\n                               \u00e4ra_neg.gem + V_gem\r\n            mitm 2. p\u00f6\u00f6re:     \u00e4ra_neg.ge  + V_ge\r\n            mitm 3. p\u00f6\u00f6re:     \u00e4ra_neg.gu  + V_gu\r\n            passiiv:           \u00e4ra_neg.gu  + V_tagu\r\n         Kui yhildub, tagastab listide listi, vastasel juhul tagastab tyhja listi. \r\n         \r\n         Tagastatava listi esimene liige on '\u00e4ra' verbi anal\u00fc\u00fcside indeksite list \r\n        (millised anal\u00fc\u00fcsid vastavad '\u00e4ra' verbile) ning listi teine liige on yhilduva \r\n        verbi anal\u00fc\u00fcside indeksite list (millised anal\u00fc\u00fcsid vastavad \u00fchilduvale verbile);\r\n        Indeksite listid on sellised, nagu neid leitakse meetodi \r\n        wordtemplate.matchingAnalyseIndexes(token) abil;\r\n    '''\r\n    global _verbAraAgreements\r\n    for i in range(0, len(_verbAraAgreements), 2):\r\n        araVerbTemplate   = _verbAraAgreements[i]\r\n        otherVerbTemplate = _verbAraAgreements[i+1]\r\n        matchingAraAnalyses = araVerbTemplate.matchingAnalyseIndexes(araVerb)\r\n        if matchingAraAnalyses:\r\n            matchingVerbAnalyses = otherVerbTemplate.matchingAnalyseIndexes(otherVerb)\r\n            if matchingVerbAnalyses:\r\n                return [matchingAraAnalyses, matchingVerbAnalyses]\r\n    return []", "response": "Returns true if the given verb is a valid ara phrase."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _extractBasicPredicateFromClause( clauseTokens, clauseID ):\r\n    ''' \r\n        Meetod, mis tuvastab antud osalausest kesksed verbid + nendega otseselt seotud \r\n        esmased verbifraasid:\r\n           1) predikaadiga seotud eituse(d): (ei/\u00e4ra/pole) + sobiv verb;\r\n           2) olema-verbifraasid: olema; olema + sobiv verb;\r\n           3) tavalised (mitte-olema) verbid, mis peaksid olema osalause keskmeks;\r\n        Sisend 'clauseTokens' on list, mis sisaldab yhe osalause k6iki s6nu (pyvabamorfi poolt tehtud\r\n        s6na-analyyse);\r\n        Tagastab listi tuvastatud fraasidest, kus iga liige (dict) on kujul:\r\n           { PHRASE: list,    -- tuvastatud fraasi positsioon lauses (WORD_ID indeksid);\r\n             PATTERN: list,   -- yldine muster, mille alusel tuvastamine toimus;\r\n             POLARITY: str,        -- polaarsus ('NEG', 'POS', '??')\r\n             OTHER_VERBS: bool -- kas kontekstis on veel verbe, mida v6iks potentsiaalselt\r\n                                   s6naga liita?\r\n           }\r\n        Eraldatakse j\u00e4rgmised \u00fcldised mustrid (PATTERN j2rjendid):\r\n            verb \r\n            ole\r\n            ei+V\r\n            ole+V\r\n            pole\r\n            ei+ole\r\n            pole+V\r\n            ole+ole\r\n            ei\r\n            \u00e4ra+V\r\n            pole+ole\r\n            \u00e4ra\r\n            \u00e4ra+ole\r\n        NB! Kui osalauses on veel verbe, mis v6iksid (potentsiaalselt) eraldatud mustriga liituda,\r\n        siis m22ratakse mustris otherVerbs = True;\r\n    '''\r\n    global _phraseBreakerAdvs\r\n    # Verbieituse indikaatorid\r\n    verbEi   = WordTemplate({ROOT:'^ei$',FORM:'neg',POSTAG:'V'})\r\n    verbEi2  = WordTemplate({ROOT:'^ei$',POSTAG:'D'})  # juhuks, kui morf yhestamises valitakse vale analyys\r\n    verbAra  = WordTemplate({ROOT:'^\u00e4ra$',FORM:'neg.*',POSTAG:'V'})\r\n    verbPole = WordTemplate({ROOT:'^ole$',FORM:'neg.*',POSTAG:'V'})\r\n    # Eituse sisuverbi osad\r\n    verbEiJarel   = WordTemplate({POSTAG:'V',FORM:'o|nud|tud|nuks|nuvat|vat|ks|ta|taks|tavat$'})\r\n    verbEiJarel2  = WordTemplate({POSTAG:'V',FORM:'neg o$'})\r\n    # Infiniitverb, olema ja verbid, mis v6ivad olema-le j2rgneda\r\n    verbInf = WordTemplate({POSTAG:'V', FORM:'^(da|des|ma|tama|ta|maks|mas|mast|nud|tud|v|mata)$'})\r\n    verbOle = WordTemplate({ROOT:'^ole$',POSTAG:'V'})\r\n    verbOleJarel = WordTemplate({POSTAG:'V',FORM:'nud$'})\r\n    verbOleJarelHeur1 = WordTemplate({POSTAG:'V',FORM:'^(tud|da|mas)$'})\r\n    verbOleJarelHeur2 = WordTemplate({POSTAG:'V',FORM:'^(tud|mas)$'})\r\n    # Muud\r\n    verb    = WordTemplate({POSTAG:'V'})\r\n    verbid  = verb.matchingPositions( clauseTokens )\r\n    sonaEga = WordTemplate({ROOT:'^ega$',POSTAG:'[DJ]'})\r\n    # Eraldamise tulemused: eraldatud (verbi)fraasid ja kasutatud reeglid\r\n    foundMatches  = []\r\n    negPhraseWIDs = []\r\n    posPhraseWIDs = []\r\n    for i in range(len(clauseTokens)):\r\n        tokenJson  = clauseTokens[i]\r\n        matchFound = False\r\n        # ===================================================================\r\n        #      V e r b i e i t u s\r\n        # ===================================================================\r\n        if verbEi.matches(tokenJson) or verbEi2.matches(tokenJson):\r\n            # \r\n            #  1. \"Ei\" + Verb (k\u00e4skivas, -nud, -tud, -nuks, -nuvat, -vat,\r\n            #                  -ks, -ta, -taks, tavat)\r\n            #\r\n            if i+1 < len(clauseTokens):\r\n                tokenJson2 = clauseTokens[i+1]\r\n                if verbEiJarel.matches(tokenJson2):\r\n                    wid1 = tokenJson[WORD_ID]\r\n                    wid2 = tokenJson2[WORD_ID]\r\n                    matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"ei\", \"verb\"] }\r\n                    matchobj[CLAUSE_IDX] = clauseID\r\n                    if verbOle.matches(tokenJson2):\r\n                        matchobj[PATTERN][1] = 'ole'\r\n                    matchobj[OTHER_VERBS] = (len(verbid) > 2)\r\n                    matchobj[POLARITY] = 'NEG'\r\n                    matchobj[ANALYSIS_IDS] = []\r\n                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, [verbEi, verbEi2] ) )\r\n                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson2, verbEiJarel ) )\r\n                    foundMatches.append( matchobj )\r\n                    negPhraseWIDs.extend( [wid1, wid2] )\r\n                    matchFound = True\r\n                #\r\n                #   Lisamuster:\r\n                #     -neg o:   Ainult \"l\u00e4he\" korral, kuna selle s6na k\u00e4skiv\r\n                #               (\"mine\") ei lange kokku eituse vormiga;\r\n                #\r\n                if not matchFound and verbEiJarel2.matches(tokenJson2):\r\n                    wid1 = tokenJson[WORD_ID]\r\n                    wid2 = tokenJson2[WORD_ID]\r\n                    matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"ei\", \"verb\"] }\r\n                    matchobj[CLAUSE_IDX] = clauseID\r\n                    matchobj[OTHER_VERBS] = (len(verbid) > 2)\r\n                    matchobj[POLARITY] = 'NEG'\r\n                    matchobj[ANALYSIS_IDS] = []\r\n                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, [verbEi, verbEi2] ) )\r\n                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson2, verbEiJarel2 ) )\r\n                    foundMatches.append( matchobj )\r\n                    negPhraseWIDs.extend( [wid1, wid2] )\r\n                    matchFound = True\r\n            #\r\n            #   1.2. Kui \"ei\" on (osa)lause alguses, ja lauses ongi vaid kaks verbi, siis \r\n            #        v\u00f5ib eituse ja verbi vahel olla ka teisi s\u00f5nu ...\r\n            #          Nt. Ei_0 ta ole_0 , \u00fctlesin selge s\u00f5naga .\r\n            #              H\u00e4vita vaenlane - ei_0 sammugi tagane_0 .\r\n            #\r\n            if not matchFound and verbEi.matches(tokenJson) and i+1 < len(clauseTokens):\r\n                #   Leiame k6ik verbid: kui ongi vaid kaks verbi, esimene 'ei'\r\n                #  ja teine sellega sobiv verb ning kehtivad kitsendused:\r\n                #      ** teine verb j2rgneb 'ei'-le;\r\n                #      ** vahetult p2rast 'ei'-d pole koma (Nt 'Aga ei_0, s\u00f5na antud_0.')\r\n                #      ** teine verb on osalause l6pus;\r\n                if len(verbid)==2 and verbid[0]==i:\r\n                    if verbEiJarel.matches(clauseTokens[verbid[1]]):\r\n                        if not _isFollowedByComma( tokenJson[WORD_ID], clauseTokens ) and \\\r\n                               _isClauseFinal( clauseTokens[verbid[1]][WORD_ID], clauseTokens ):\r\n                            wid1 = tokenJson[WORD_ID]\r\n                            wid2 = clauseTokens[verbid[1]][WORD_ID]\r\n                            matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"ei\", \"verb\"] }\r\n                            matchobj[CLAUSE_IDX] = clauseID\r\n                            if verbOle.matches(clauseTokens[verbid[1]]):\r\n                                matchobj[PATTERN][1] = 'ole'\r\n                            matchobj[OTHER_VERBS] = False\r\n                            matchobj[POLARITY] = 'NEG'\r\n                            matchobj[ANALYSIS_IDS] = []\r\n                            matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbEi ) )\r\n                            matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( clauseTokens[verbid[1]], verbEiJarel ) )\r\n                            foundMatches.append( matchobj )\r\n                            negPhraseWIDs.extend( [wid1, wid2] )\r\n                            matchFound = True\r\n            #\r\n            #   1.X. Ei oska \"ei\" predikaadikonteksti m22rata (v6imalik, et ei eitatagi verbi,\r\n            #        vaid hoopis nimis6nafraasi vms).\r\n            #\r\n            if not matchFound:\r\n                wid1 = tokenJson[WORD_ID]\r\n                matchobj = { PHRASE: [wid1], PATTERN: [\"ei\"] }\r\n                matchobj[CLAUSE_IDX] = clauseID\r\n                # Leiame, kas j2rgneb s6nu, millega potentsiaalselt saaks eituse moodustada\r\n                matchobj[OTHER_VERBS] = \\\r\n                    any([ verbEiJarel.matches(clauseTokens[j]) for j in range(i+1, len(clauseTokens)) ])\r\n                matchobj[POLARITY] = 'NEG'\r\n                matchobj[ANALYSIS_IDS] = []\r\n                matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, [verbEi, verbEi2] ) )\r\n                foundMatches.append( matchobj )\r\n                negPhraseWIDs.extend( [wid1] )\r\n                matchFound = True\r\n        elif verbAra.matches(tokenJson):\r\n            # \r\n            #   2. \"\u00c4ra\" + Verb (k\u00e4skivas, -ge, -gem, -gu, -tagu, -me)\r\n            #\r\n            #       Kui \"\u00e4ra\"-le j\u00e4rgneb (osa)lauses veel teisi verbe, proovime \r\n            #      moodustada \u00e4ra-fraasi esimese j\u00e4rgneva verbiga, mis \u00fchildub:\r\n            #        Nt.  \u00c4rme_0 enam nii tee_0 !\r\n            #             \u00c4rge_0 palun minge_0 . \r\n            #             \u00c4rge_0 ainult naerma puhkege_0 .\r\n            #\r\n            if i+1 < len(clauseTokens) and len(verbid) >= 2:\r\n                for verbIndex in verbid:\r\n                    tokenJson2 = clauseTokens[ verbIndex ]\r\n                    if tokenJson[WORD_ID] < tokenJson2[WORD_ID]:\r\n                        # Teeme kindlaks, kas j\u00e4rgnev verb v\u00f5ib \u00fchilduda '\u00e4ra'-ga:\r\n                        analyses = _canFormAraPhrase( tokenJson, tokenJson2 )\r\n                        if analyses:\r\n                            wid1 = tokenJson[WORD_ID]\r\n                            wid2 = tokenJson2[WORD_ID]\r\n                            matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"\u00e4ra\", \"verb\"] }\r\n                            matchobj[CLAUSE_IDX] = clauseID\r\n                            if verbOle.matches(tokenJson2):\r\n                                matchobj[PATTERN][1] = 'ole'\r\n                            matchobj[OTHER_VERBS] = (len(verbid) > 2)\r\n                            matchobj[POLARITY] = 'NEG'\r\n                            matchobj[ANALYSIS_IDS] = []\r\n                            matchobj[ANALYSIS_IDS].append( analyses[0] )\r\n                            matchobj[ANALYSIS_IDS].append( analyses[1] )\r\n                            foundMatches.append( matchobj )\r\n                            negPhraseWIDs.extend( [wid1, wid2] )\r\n                            matchFound = True\r\n                            break\r\n                            #\r\n                            #  Teadaolevad veakohad:  \r\n                            #    yks koma vahel:  \u00c4ra_0 piina ennast , j\u00e4ta_0 laps mulle.\r\n                            #    (aga siin on p6hiliseks veaks puudulik morf analyys)\r\n                            #\r\n            #\r\n            #   2.X. Ei oska \"\u00e4ra\" predikaadikonteksti m22rata ...\r\n            #\r\n            if not matchFound:\r\n                wid1 = tokenJson[WORD_ID]\r\n                matchobj = { PHRASE: [wid1], PATTERN: [\"\u00e4ra\"] }\r\n                matchobj[CLAUSE_IDX] = clauseID\r\n                matchobj[OTHER_VERBS] = (len(verbid) > 1)\r\n                #  Kui kontekstis on ka teisi verbe, v\u00f5ib \u00e4ra t\u00e4ita hoopis m\u00e4\u00e4rs\u00f5na rolli, ja\r\n                # kuna eitusmustrid on v\u00e4listatud, pole enam kindel, et tegu on eitusega;\r\n                matchobj[POLARITY] = '??'\r\n                matchobj[ANALYSIS_IDS] = []\r\n                matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbAra ) )\r\n                foundMatches.append( matchobj )\r\n                negPhraseWIDs.extend( [wid1] )\r\n                matchFound = True\r\n        elif verbPole.matches(tokenJson):\r\n            # \r\n            #  3. \"Pole\" + Verb (-nud)\r\n            #\r\n            if i+1 < len(clauseTokens):\r\n                tokenJson2 = clauseTokens[i+1]\r\n                if verbOleJarel.matches(tokenJson2):\r\n                    wid1 = tokenJson[WORD_ID]\r\n                    wid2 = tokenJson2[WORD_ID]\r\n                    matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"pole\", \"verb\"] }\r\n                    matchobj[CLAUSE_IDX] = clauseID\r\n                    if verbOle.matches(tokenJson2):\r\n                        matchobj[PATTERN][1] = 'ole'\r\n                    matchobj[OTHER_VERBS] = (len(verbid) > 2)\r\n                    matchobj[POLARITY] = 'NEG'\r\n                    matchobj[ANALYSIS_IDS] = []\r\n                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbPole ) )\r\n                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson2, verbOleJarel ) )\r\n                    foundMatches.append( matchobj )\r\n                    negPhraseWIDs.extend( [wid1, wid2] )\r\n                    matchFound = True\r\n            if not matchFound and i+1 < len(clauseTokens):\r\n                tokenJson2 = clauseTokens[i+1]\r\n                #\r\n                #   3.2. Heuristik: Kui \"pole\" j2rel on vahetult verb (-tud, -mas), ning m6lemad\r\n                #        paiknevad (osa)lause l6pus ning osalauses ongi vaid kaks verbi, loeme \r\n                #        selle ka eituse fraasiks:\r\n                #          Nt.  Autode ostuhinda pole avalikustatud .\r\n                #               Skriptid n\u00e4itavad veateateid , kui tingimused pole t\u00e4idetud .\r\n                #               Aktsia- ja rahaturud on rahutud ning stabiilsust pole n\u00e4ha .\r\n                #               ... kas ehk kedagi liikumas_0 pole_0 , keda v\u00f5iks asjasse p\u00fchendada ...\r\n                #\r\n                if len(verbid)==2 and verbOleJarelHeur2.matches(tokenJson2) and \\\r\n                   _isClauseFinal( tokenJson2[WORD_ID], clauseTokens ):\r\n                    wid1 = tokenJson[WORD_ID]\r\n                    wid2 = tokenJson2[WORD_ID]\r\n                    matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"pole\", \"verb\"] }\r\n                    matchobj[CLAUSE_IDX] = clauseID\r\n                    if verbOle.matches(tokenJson2):\r\n                        matchobj[PATTERN][1] = 'ole'\r\n                    matchobj[OTHER_VERBS] = False\r\n                    matchobj[POLARITY] = 'NEG'\r\n                    matchobj[ANALYSIS_IDS] = []\r\n                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbPole ) )\r\n                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson2, verbOleJarelHeur2 ) )\r\n                    foundMatches.append( matchobj )\r\n                    negPhraseWIDs.extend( [wid1, wid2] )\r\n                    matchFound = True\r\n                #\r\n                #   3.3. Heuristik: Kui ongi vaid kaks verbi, ning \"pole\" j2rel on osalause l6pus\r\n                #        \"nud\", loeme selle samuti yheks fraasiks. \r\n                #          Nt.\r\n                #              Ladina keel pole v\u00e4lja surnud .\r\n                #              Nii odavalt pole Eesti oma laevu kunagi v\u00e4lja andnud .\r\n                #              T\u00f6\u00f6ga pole keegi rikkaks saanud .\r\n                #\r\n                if not matchFound and len(verbid)==2 and verbid[0] == i:\r\n                    if verbOleJarel.matches( clauseTokens[verbid[1]] ) and \\\r\n                       _isClauseFinal( clauseTokens[verbid[1]][WORD_ID], clauseTokens ):\r\n                        wid1 = tokenJson[WORD_ID]\r\n                        wid2 = clauseTokens[verbid[1]][WORD_ID]\r\n                        matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"pole\", \"verb\"] }\r\n                        matchobj[CLAUSE_IDX] = clauseID\r\n                        matchobj[OTHER_VERBS] = False\r\n                        if verbOle.matches( clauseTokens[verbid[1]] ):\r\n                            matchobj[PATTERN][1] = 'ole'\r\n                        matchobj[POLARITY] = 'NEG'\r\n                        matchobj[ANALYSIS_IDS] = []\r\n                        matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbPole ) )\r\n                        matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( clauseTokens[verbid[1]], verbOleJarel ) )\r\n                        foundMatches.append( matchobj )\r\n                        negPhraseWIDs.extend( [wid1, wid2] )\r\n                        matchFound = True\r\n                if not matchFound:\r\n                    #\r\n                    #  3.4. Heuristik: Kui 'pole'-le j2rgneb osalauses kusagil kaugemal -nud, \r\n                    #       mis ei saa olla fraasi eest\u00e4iend, siis loeme selle olema-verbiga \r\n                    #       kokkukuuluvaks;\r\n                    #\r\n                    seenNudVerbs = 0\r\n                    for k in range(i+1, len(clauseTokens)):\r\n                        tokenJson2 = clauseTokens[k]\r\n                        if verb.matches(tokenJson2) and not verbInf.matches(tokenJson2):\r\n                            #  Kui j6uame finiitverbini, siis katkestame otsingu\r\n                            break\r\n                        if sonaEga.matches(tokenJson2):\r\n                            #  Kui j6uame 'ega'-ni, siis katkestame otsingu\r\n                            break\r\n                        if verbOleJarel.matches(tokenJson2):\r\n                            seenNudVerbs += 1\r\n                            #\r\n                            #     Kui -nud verb eelneb vahetult m6nele teisele infiniitverbile, \r\n                            #  on v2ga t6en2oline, et -nud on peaverb \"pole\" otsene alluv ning \r\n                            #  pole eest\u00e4iend, nt:\r\n                            #\r\n                            #       kuid ta polnud_0 ka teatris \u00f5ppinud_1 improviseerima ning\r\n                            #       Ega me pole_0 siia tulnud_1 paastuma ja palvetama , \"\r\n                            #       ja Raul poleks_0 teda h\u00e4rrasmehena kodust v\u00e4lja tahtnud_1 ajada .\r\n                            #       ma pole_0 iial kasutanud_1 keelatud aineid .\r\n                            #\r\n                            #    Kontrollime, et nud-ile j2rgneks infiniitverb, ning\r\n                            #  vahel poleks teisi nud-verbe ...\r\n                            #\r\n                            if k+1 in verbid and verbInf.matches(clauseTokens[k+1]) and \\\r\n                                seenNudVerbs < 2:\r\n                                wid1 = tokenJson[WORD_ID]\r\n                                wid2 = tokenJson2[WORD_ID]\r\n                                matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"pole\", \"verb\"] }\r\n                                matchobj[CLAUSE_IDX] = clauseID\r\n                                if verbOle.matches(tokenJson2):\r\n                                    matchobj[PATTERN][1] = 'ole'\r\n                                matchobj[OTHER_VERBS] = True\r\n                                matchobj[POLARITY] = 'NEG'\r\n                                matchobj[ANALYSIS_IDS] = []\r\n                                matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbPole, discardAnalyses = verbInf ) )\r\n                                matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson2, [verbOleJarel] ) )\r\n                                foundMatches.append( matchobj )\r\n                                negPhraseWIDs.extend( [wid1, wid2] )\r\n                                matchFound = True\r\n                                #_debugPrint( (('+'.join(matchobj[PATTERN]))+' | '+_getJsonAsTextString(clauseTokens, markTokens = [ matchobj[PHRASE] ] )))\r\n                                break\r\n                            #\r\n                            #     Kui -nud verb eelneb vahetult m6nele adverbile, mis t6en2oliselt\r\n                            #  on lauses iseseisev s6na (nt 'ka', 'siis', 'veel', 'juba' jms), siis ei \r\n                            #  saa -nud olla eest2iend ning peaks olema peaverb \"pole\" otsene alluv, nt:\r\n                            #\r\n                            #       Varem pole_0 ma kirjandile j\u00f5udnud_0 aga sellep\u00e4rast ,\r\n                            #       \" Ma pole_0 Belgias saanud_0 isegi parkimistrahvi ! \"\r\n                            #       Polnud_0 \u00f5llelembid saanud_0 veel \u00f5ieti j\u00f5uluvaimu sisse elada ,\r\n                            #       mulle polnud_0 V\u00e4ike j\u00f5udnud_0 ju veel r\u00e4\u00e4kida ,\r\n                            #\r\n                            #   Lisaks kontrollime, et vahel poleks teisi -nud verbe;\r\n                            #\r\n                            elif k+1<len(clauseTokens) and _phraseBreakerAdvs.matches(clauseTokens[k+1]) and \\\r\n                                seenNudVerbs < 2:\r\n                                wid1 = tokenJson[WORD_ID]\r\n                                wid2 = tokenJson2[WORD_ID]\r\n                                matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"pole\", \"verb\"] }\r\n                                matchobj[CLAUSE_IDX] = clauseID\r\n                                if verbOle.matches(tokenJson2):\r\n                                    matchobj[PATTERN][1] = 'ole'\r\n                                matchobj[OTHER_VERBS] = (len(verbid) > 2)\r\n                                matchobj[POLARITY] = 'NEG'\r\n                                matchobj[ANALYSIS_IDS] = []\r\n                                matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbPole, discardAnalyses = verbInf ) )\r\n                                matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson2, [verbOleJarel] ) )\r\n                                foundMatches.append( matchobj )\r\n                                negPhraseWIDs.extend( [wid1, wid2] )\r\n                                matchFound = True\r\n                                #_debugPrint( (('+'.join(matchobj[PATTERN]))+' | '+_getJsonAsTextString(clauseTokens, markTokens = [ matchobj[PHRASE] ] )))\r\n                                break\r\n            if not matchFound and _isClauseFinal( tokenJson[WORD_ID], clauseTokens ):\r\n                #\r\n                #   3.5. Heuristik: Kui \"pole\" on osalause l6pus, ning sellele eelneb vahetult\r\n                #        \"nud\", v6i eelneb vahetult tud/da/mas ning osalauses pole teisi verbe,\r\n                #        loeme liiteituseks:\r\n                #          Nt.\r\n                #              Huvitav ainult , miks ta mulle helistanud_0 pole_0 .\r\n                #              Mingit kuulsust ma k\u00fcll kogunud_0 pole_0 .\r\n                #\r\n                if i-1 > -1:\r\n                    tokenJson2 = clauseTokens[i-1]\r\n                    if verbOleJarel.matches(tokenJson2) or (len(verbid)==2 and \\\r\n                       verbOleJarelHeur2.matches(tokenJson2)):\r\n                        wid1 = tokenJson[WORD_ID]\r\n                        wid2 = tokenJson2[WORD_ID]\r\n                        matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"pole\", \"verb\"] }\r\n                        matchobj[CLAUSE_IDX] = clauseID\r\n                        matchobj[OTHER_VERBS] = (len(verbid) > 2)\r\n                        if verbOle.matches( tokenJson2 ):\r\n                            matchobj[PATTERN][1] = 'ole'\r\n                        matchobj[POLARITY] = 'NEG'\r\n                        matchobj[ANALYSIS_IDS] = []\r\n                        matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbPole ) )\r\n                        matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson2, [verbOleJarel, verbOleJarelHeur2] ) )\r\n                        foundMatches.append( matchobj )\r\n                        negPhraseWIDs.extend( [wid1, wid2] )\r\n                        matchFound = True\r\n            #\r\n            #   3.X. Ei oska \"pole\" predikaadikonteksti m22rata ...\r\n            #\r\n            if not matchFound:\r\n                wid1 = tokenJson[WORD_ID]\r\n                matchobj = { PHRASE: [wid1], POLARITY: 'NEG', PATTERN: [\"pole\"] }\r\n                matchobj[CLAUSE_IDX]   = clauseID\r\n                matchobj[OTHER_VERBS] = (len(verbid) > 1)\r\n                matchobj[ANALYSIS_IDS] = []\r\n                matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbPole ) )\r\n                foundMatches.append( matchobj )\r\n                negPhraseWIDs.extend( [wid1] )\r\n                matchFound = True\r\n        # ===================================================================\r\n        #      V e r b i   j a a t u s\r\n        # ===================================================================\r\n        elif tokenJson[WORD_ID] not in negPhraseWIDs and verb.matches(tokenJson) and \\\r\n             not verbInf.matches(tokenJson):\r\n            #\r\n            #  Tavaline verb ( mitte olema-verb )\r\n            #\r\n            if not verbOle.matches( tokenJson ):\r\n                wid1 = tokenJson[WORD_ID]\r\n                matchobj = { PHRASE: [wid1], POLARITY: 'POS', PATTERN: [\"verb\"] }\r\n                matchobj[CLAUSE_IDX]   = clauseID\r\n                matchobj[OTHER_VERBS] = (len(verbid) > 1)\r\n                matchobj[ANALYSIS_IDS] = []\r\n                matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verb, discardAnalyses = verbInf ) )\r\n                foundMatches.append( matchobj )\r\n                posPhraseWIDs.extend( [wid1] )\r\n                matchFound = True\r\n            #\r\n            #  Olema-verb\r\n            #\r\n            else:\r\n                if (len(verbid) == 1):\r\n                    #  Yksik olema-verb\r\n                    wid1 = tokenJson[WORD_ID]\r\n                    matchobj = { PHRASE: [wid1], POLARITY: 'POS', PATTERN: [\"ole\"] }\r\n                    matchobj[CLAUSE_IDX]   = clauseID\r\n                    matchobj[OTHER_VERBS] = False\r\n                    matchobj[ANALYSIS_IDS] = []\r\n                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbOle, discardAnalyses = verbInf ) )\r\n                    foundMatches.append( matchobj )\r\n                    posPhraseWIDs.extend( [wid1] )\r\n                    matchFound = True\r\n                else:\r\n                    #\r\n                    #  Lauses on veel verbe: yritame teha kindlaks, kas tegu on liitkonstruktsiooniga\r\n                    #\r\n                    if i+1 < len(clauseTokens):\r\n                        if verbOleJarel.matches(clauseTokens[i+1]) and \\\r\n                           clauseTokens[i+1][WORD_ID] not in negPhraseWIDs:\r\n                            #\r\n                            #   Vahetult j2rgnev '-nud':\r\n                            #       Ta ise on_0 kasutanud_0 mitme turvafima teenuseid .\r\n                            #       Luule on_0 v\u00f5tnud_0 Linnutee kuju .\r\n                            #       \u00d5htul oli_0 olnud_0 org , aga hommikul j\u00e4rv .\r\n                            #\r\n                            tokenJson2 = clauseTokens[i+1]\r\n                            wid1 = tokenJson[WORD_ID]\r\n                            wid2 = tokenJson2[WORD_ID]\r\n                            matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"ole\", \"verb\"] }\r\n                            matchobj[CLAUSE_IDX] = clauseID\r\n                            if verbOle.matches(tokenJson2):\r\n                                matchobj[PATTERN][1] = 'ole'\r\n                            matchobj[OTHER_VERBS] = (len(verbid) > 2)\r\n                            matchobj[POLARITY] = 'POS'\r\n                            matchobj[ANALYSIS_IDS] = []\r\n                            matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbOle, discardAnalyses = verbInf ) )\r\n                            matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson2, verbOleJarel ) )\r\n                            #matchobj[PATTERN][1] += '??'\r\n                            foundMatches.append( matchobj )\r\n                            posPhraseWIDs.extend( [wid1, wid2] )\r\n                            matchFound = True\r\n                            #\r\n                            #  NB! See reegel v\u00f5ib eksida eksistentsiaallausete korral,\r\n                            #  mis, t\u00f5si kyll, tunduvad olevat mittesagedased:\r\n                            #        P\u00f5lvamaal oli_0 m\u00f6\u00f6dunud_0 n\u00e4dala teine pool traagiline .\r\n                            #        Kevadisel l\u00e4bivaatusel oli_0 kogenud_0 mesinik abiks .\r\n                            #\r\n                        elif len(verbid)==2:\r\n                            otherVerbIndex = verbid[1] if verbid[0]==i else verbid[0]\r\n                            otherVerb = clauseTokens[ otherVerbIndex ]\r\n                            #\r\n                            #   Osalauses ongi vaid kaks verbi ning 'nud/tud/mas' on osalause \r\n                            #   l6pus:\r\n                            #        S\u00f6\u00f6gimaja ja kiriku uksed olid_0 suletud_0 ,\r\n                            #        N\u00f6\u00f6p on_0 olemas_0 , kunagi \u00f5mmeldakse mantel ka k\u00fclge !\r\n                            #        Naine oli_0 Kalevi selleni viinud_0 .\r\n                            #        Etnofuturismi esivanemaid on_0 veel v\u00e4he uuritud_0 .\r\n                            #\r\n                            if (verbOleJarel.matches(otherVerb) or verbOleJarelHeur2.matches(otherVerb)) and \\\r\n                               _isClauseFinal( otherVerb[WORD_ID], clauseTokens ) and \\\r\n                               otherVerb[WORD_ID] not in negPhraseWIDs:\r\n                                wid1 = tokenJson[WORD_ID]\r\n                                wid2 = otherVerb[WORD_ID]\r\n                                #\r\n                                #   Siin v6ib tekkida vigu/kaheldavaid kohti, kui kahe s6na vahel on \r\n                                #   sides6nu/punktuatsiooni/teatud_adverbe, n2iteks:\r\n                                #        on_0 kaasas\u00fcndinud v\u00f5i elu jooksul omandatud_0\r\n                                #        Mariboris oli_0 \u00e4kki medal k\u00e4es ja Tallinnas 240kilone Ruano v\u00f5idetud_0\r\n                                #        Mina olen_0 p\u00e4ritolult p\u00f5hjaeestlane , 50 aastat P\u00f5hja-Eestis elanud_0 .\r\n                                #   J2tame sellistel puhkudel yhtse verbifraasina eraldamata ...\r\n                                #\r\n                                if not _isSeparatedByPossibleClauseBreakers( clauseTokens, tokenJson[WORD_ID], otherVerb[WORD_ID], True, True, True):\r\n                                    matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"ole\", \"verb\"] }\r\n                                    matchobj[CLAUSE_IDX] = clauseID\r\n                                    if verbOle.matches(otherVerb):\r\n                                        matchobj[PATTERN][1] = 'ole'\r\n                                    matchobj[OTHER_VERBS] = (len(verbid) > 2)\r\n                                    matchobj[POLARITY] = 'POS'\r\n                                    matchobj[ANALYSIS_IDS] = []\r\n                                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbOle, discardAnalyses = verbInf ) )\r\n                                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( otherVerb, [verbOleJarel, verbOleJarelHeur2] ) )\r\n                                    foundMatches.append( matchobj )\r\n                                    posPhraseWIDs.extend( [wid1, wid2] )\r\n                                    matchFound = True\r\n                            elif (verbOleJarel.matches(otherVerb) or verbOleJarelHeur2.matches(otherVerb)) and \\\r\n                                  otherVerb[WORD_ID] not in negPhraseWIDs and \\\r\n                                  i+1 == otherVerbIndex:\r\n                                  #\r\n                                  #   Osalauses ongi vaid kaks verbi ning 'nud/tud/mas' j2rgneb vahetult\r\n                                  #   olema verbile (umbisikuline k\u00f5neviis):\r\n                                  #        Oktoobris-detsembris 1944. a on_0 registreeritud_0 318 haigusjuhtu .\r\n                                  #        Enamik uuringuid on_0 korraldatud_0 t\u00e4iskasvanutel .\r\n                                  #        Graafikud on_0 tehtud_0 programmis Exel 2003 .\r\n                                  #   \u00dcsna sagedane just teadustekstides;\r\n                                  #\r\n                                    wid1 = tokenJson[WORD_ID]\r\n                                    wid2 = otherVerb[WORD_ID]\r\n                                    matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"ole\", \"verb\"] }\r\n                                    matchobj[CLAUSE_IDX] = clauseID\r\n                                    if verbOle.matches(otherVerb):\r\n                                        matchobj[PATTERN][1] = 'ole'\r\n                                    matchobj[OTHER_VERBS] = (len(verbid) > 2)\r\n                                    matchobj[POLARITY] = 'POS'\r\n                                    matchobj[ANALYSIS_IDS] = []\r\n                                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbOle, discardAnalyses = verbInf ) )\r\n                                    matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( otherVerb, [verbOleJarel, verbOleJarelHeur2] ) )\r\n                                    foundMatches.append( matchobj )\r\n                                    posPhraseWIDs.extend( [wid1, wid2] )\r\n                                    matchFound = True\r\n                                    #\r\n                                    #   Kuna '-tud' v\u00f5ib potentsiaalselt olla ka eest\u00e4iend, v\u00f5ib tekkida \r\n                                    #   ka vigu:\r\n                                    #      Tema tegevuses on_0 teatud_0 plaan ehk tegevuskava .\r\n                                    #      K\u00f5ige t\u00e4htsam v\u00f5istlusala on_0 kombineeritud_0 v\u00f5istlus .\r\n                                    #      L\u00f5petuseks on_0 grillitud_0 mereandide valik .\r\n                                    #\r\n                        #\r\n                        #    Kui olema-verbile j2rgneb osalauses kusagil kaugemal -nud, mis ei saa\r\n                        #   olla fraasi eest\u00e4iend, siis loeme selle olema-verbiga kokkukuuluvaks;\r\n                        #\r\n                        if not matchFound:\r\n                            seenNudVerbs = 0\r\n                            for k in range(i+1, len(clauseTokens)):\r\n                                tokenJson2 = clauseTokens[k]\r\n                                if verb.matches(tokenJson2) and not verbInf.matches(tokenJson2):\r\n                                    #  Kui j6uame finiitverbini, siis katkestame otsingu\r\n                                    break\r\n                                if sonaEga.matches(tokenJson2):\r\n                                    #  Kui j6uame 'ega'-ni, siis katkestame otsingu\r\n                                    break\r\n                                if verbOleJarel.matches(tokenJson2):\r\n                                    seenNudVerbs += 1\r\n                                    #\r\n                                    #     Kui -nud verb eelneb vahetult m6nele teisele infiniitverbile, \r\n                                    #  on v2ga t6en2oline, et -nud on peaverb \"olema\" otsene alluv ning \r\n                                    #  pole eest\u00e4iend, nt:\r\n                                    #\r\n                                    #       Midagi niisugust olin_0 ma kogu aeg lootnud_1 leida .\r\n                                    #       siis varem v\u00f5i hiljem on_0 ta pidanud_1 taanduma\r\n                                    #       siis oleks_0 ta mingisuguse plaani t\u00f5esti v\u00f5inud_1 koostada\r\n                                    #       j\u00e4lle on_0 \u00fchest investeeringust saanud_1 surnud kapital\r\n                                    #\r\n                                    #    Kontrollime, et nud-ile j2rgneks infiniitverb, ning\r\n                                    #  vahel poleks teisi nud-verbe ...\r\n                                    #\r\n                                    if k+1 in verbid and verbInf.matches(clauseTokens[k+1]) and \\\r\n                                       seenNudVerbs < 2:\r\n                                        wid1 = tokenJson[WORD_ID]\r\n                                        wid2 = tokenJson2[WORD_ID]\r\n                                        matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"ole\", \"verb\"] }\r\n                                        matchobj[CLAUSE_IDX] = clauseID\r\n                                        if verbOle.matches(tokenJson2):\r\n                                            matchobj[PATTERN][1] = 'ole'\r\n                                        matchobj[OTHER_VERBS] = True\r\n                                        matchobj[POLARITY] = 'POS'\r\n                                        matchobj[ANALYSIS_IDS] = []\r\n                                        matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbOle, discardAnalyses = verbInf ) )\r\n                                        matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson2, [verbOleJarel] ) )\r\n                                        foundMatches.append( matchobj )\r\n                                        posPhraseWIDs.extend( [wid1, wid2] )\r\n                                        matchFound = True\r\n                                        #_debugPrint( (('+'.join(matchobj[PATTERN]))+' | '+_getJsonAsTextString(clauseTokens, markTokens = [ matchobj[PHRASE] ] )))\r\n                                        break\r\n                                        #\r\n                                        # Probleemset:\r\n                                        #  *) Kui kaks -nud-i on k\u00f5rvuti, v\u00f5ib minna valesti, kui pimesi siduda \r\n                                        #     esimene, n\u00e4iteks:\r\n                                        #          k\u00fcllap ta oli_0 siis ka alati armunud_0 olnud .\r\n                                        #          Eksamikomisjon oli_0 veidi ehmunud_0 olnud ,\r\n                                        #          Samuti on_0 mitmed TTga \u00f5nnetuses osalenud_0 lausunud ,\r\n                                        #\r\n                                    #\r\n                                    #     Kui -nud verb eelneb vahetult m6nele adverbile, mis t6en2oliselt\r\n                                    #  on lauses iseseisev s6na (nt 'ka', 'siis', 'veel', 'juba' jms), siis ei \r\n                                    #  saa -nud olla eest2iend ning peaks olema peaverb \"olema\" otsene alluv, nt:\r\n                                    #\r\n                                    #       Kasiinodega on_0 rikkaks saanud_1 siiski vaid h\u00f5imud ,\r\n                                    #       See n\u00e4itaja on_0 j\u00e4llegi t\u00f5usnud_1 ainult Hansapangal .\r\n                                    #       Me oleme_0 tegelikult Kristiga ikka laval laulnud_1 ka .\r\n                                    #       Georg Ots on_0 noorte hulgas t\u00f5usnud_1 k\u00fcll s\u00fcmboli staatusesse\r\n                                    #\r\n                                    #    Lisaks kontrollime, et vahel poleks teisi -nud verbe;\r\n                                    #\r\n                                    elif k+1<len(clauseTokens) and _phraseBreakerAdvs.matches(clauseTokens[k+1]) and \\\r\n                                         seenNudVerbs < 2:\r\n                                        wid1 = tokenJson[WORD_ID]\r\n                                        wid2 = tokenJson2[WORD_ID]\r\n                                        matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"ole\", \"verb\"] }\r\n                                        matchobj[CLAUSE_IDX] = clauseID\r\n                                        if verbOle.matches(tokenJson2):\r\n                                            matchobj[PATTERN][1] = 'ole'\r\n                                        matchobj[OTHER_VERBS] = (len(verbid) > 2)\r\n                                        matchobj[POLARITY] = 'POS'\r\n                                        matchobj[ANALYSIS_IDS] = []\r\n                                        matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbOle, discardAnalyses = verbInf ) )\r\n                                        matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson2, [verbOleJarel] ) )\r\n                                        foundMatches.append( matchobj )\r\n                                        posPhraseWIDs.extend( [wid1, wid2] )\r\n                                        matchFound = True\r\n                                        #_debugPrint( (('+'.join(matchobj[PATTERN]))+' | '+_getJsonAsTextString(clauseTokens, markTokens = [ matchobj[PHRASE] ] )))\r\n                                        break\r\n                                        #\r\n                                        #  Probleemset:\r\n                                        #   *) kui -nud-ile vahetult eelneb sidend, v6ib -nud kuuluda v2ljaj2ttelise \r\n                                        #      olema verbi juurde:\r\n                                        #          Mart Timmi on_0 maakonna \u00fcks edukamaid talupidajaid ja olnud_1 ka taluseltsi esimees .\r\n                                        #          Ulvi oli_0 ometigi loov kunstnik ega v\u00f5inud_1 ka eraelus esineda epigoonina .\r\n                                        #\r\n                    if i-1 > -1 and not matchFound:\r\n                        if _isClauseFinal( tokenJson[WORD_ID], clauseTokens ) and \\\r\n                           clauseTokens[i-1][WORD_ID] not in negPhraseWIDs and \\\r\n                           (verbOleJarel.matches(clauseTokens[i-1]) or (len(verbid)==2 and \\\r\n                           verbOleJarelHeur2.matches(clauseTokens[i-1]))) and \\\r\n                           clauseTokens[i-1][WORD_ID] not in negPhraseWIDs:\r\n                            #\r\n                            #   Vahetult eelnev '-nud':\r\n                            #       Ma \u00f5petan \u00f5ievalemeid , mida ma ise viiendas klassis vihanud_0 olin_0 .\r\n                            #       ... siis kui nemad juba \u00e4ra s\u00f5itnud_0 on_0 ...\r\n                            #   Vahetult eelnev 'tud/mas' ning osalauses pole rohkem verbe:\r\n                            #       Ja sellep\u00e4rast j\u00e4igi k\u00f5ik nii , nagu kirjutatud_0 oli_0 .\r\n                            #\r\n                            tokenJson2 = clauseTokens[i-1]\r\n                            wid1 = tokenJson[WORD_ID]\r\n                            wid2 = tokenJson2[WORD_ID]\r\n                            matchobj = { PHRASE: [wid1, wid2], PATTERN: [\"ole\", \"verb\"] }\r\n                            matchobj[CLAUSE_IDX] = clauseID\r\n                            if verbOle.matches(tokenJson2):\r\n                                matchobj[PATTERN][1] = 'ole'\r\n                            matchobj[OTHER_VERBS] = (len(verbid) > 2)\r\n                            matchobj[POLARITY] = 'POS'\r\n                            matchobj[ANALYSIS_IDS] = []\r\n                            matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbOle, discardAnalyses = verbInf ) )\r\n                            matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson2, [verbOleJarel, verbOleJarelHeur2] ) )\r\n                            #matchobj[PATTERN][1] += '??'\r\n                            foundMatches.append( matchobj )\r\n                            posPhraseWIDs.extend( [wid1, wid2] )\r\n                            matchFound = True\r\n                    if not matchFound:\r\n                        #\r\n                        #    Ei oska m22rata, millega t2pselt \"olema\" verb seotud on ...\r\n                        #\r\n                        wid1 = tokenJson[WORD_ID]\r\n                        matchobj = { PHRASE: [wid1], POLARITY: 'POS', PATTERN: [\"ole\"] }\r\n                        matchobj[CLAUSE_IDX]   = clauseID\r\n                        matchobj[OTHER_VERBS] = True\r\n                        matchobj[ANALYSIS_IDS] = []\r\n                        matchobj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( tokenJson, verbOle, discardAnalyses = verbInf ) )\r\n                        #matchobj[PATTERN][0]+='??'\r\n                        foundMatches.append( matchobj )\r\n                        posPhraseWIDs.extend( [wid1] )\r\n                        matchFound = True\r\n    return foundMatches", "response": "Extract basic filter from a set of clause tokens."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _expandOlemaVerbChains( clauseTokens, clauseID, foundChains ):\r\n    '''\r\n         Meetod, mis proovib laiendada 'olema'-l6pulisi (predikaadi) verbiahelaid, lisades \r\n        v\u00f5imalusel nende otsa teisi verbe, nt \r\n            \"on olnud\" + \"tehtud\", \"ei olnud\" + \"tehtud\", \"ei oleks\" + \"arvatud\";\r\n        Vastavalt leitud laiendustele t2iendab andmeid sisendlistis foundChains;\r\n    '''\r\n    verbOle       = WordTemplate({ROOT:'^ole$',POSTAG:'V'})\r\n    verbOleJarel1 = WordTemplate({POSTAG:'V',FORM:'(nud)$'})\r\n    verbOleJarel2 = WordTemplate({POSTAG:'V',FORM:'^(mas|tud)$'})\r\n    verbMata      = WordTemplate({POSTAG:'V',FORM:'^(mata)$'})\r\n    verbMaDa      = WordTemplate({POSTAG:'V',FORM:'^(da|ma)$'})\r\n    # J22dvustame s6nad, mis kuuluvad juba mingi tuvastatud verbifraasi koosseisu\r\n    annotatedWords = []\r\n    for verbObj in foundChains:\r\n        if verbObj[CLAUSE_IDX] != clauseID:\r\n            continue\r\n        if (len(verbObj[PATTERN])==1 and re.match('^(ei|\u00e4ra|ega)$', verbObj[PATTERN][0])):\r\n            # V2lja j22vad yksikuna esinevad ei/\u00e4ra/ega, kuna need t\u00f5en\u00e4oliselt ei sega\r\n            continue\r\n        annotatedWords.extend( verbObj[PHRASE] )\r\n    for verbObj in foundChains:\r\n        if verbObj[CLAUSE_IDX] != clauseID:\r\n            continue\r\n        if verbObj[PATTERN][-1] == 'ole' and verbObj[OTHER_VERBS]:\r\n            #\r\n            #  Kui on tegemist 'olema' l6pulise verbiahelaga, mille kontekstis on teisi verbe,\r\n            #  st saab veel laiendada ...\r\n            #\r\n            eiOlePattern = (len(verbObj[PATTERN])==2 and verbObj[PATTERN][0] == 'ei')\r\n            lastVerbWID = verbObj[PHRASE][-1]\r\n            lastTokIndex = [i for i in range(len(clauseTokens)) if clauseTokens[i][WORD_ID] == lastVerbWID]\r\n            lastTokIndex = lastTokIndex[0]\r\n            expansion   = None\r\n            appliedRule = 0\r\n            if not _isClauseFinal( lastVerbWID, clauseTokens ):\r\n                maDaVerbsBetween = 0\r\n                oleInfFollowing  = 0\r\n                for i in range(lastTokIndex + 1, len(clauseTokens)):\r\n                    token = clauseTokens[i]\r\n                    tokenWID = token[WORD_ID]\r\n                    if tokenWID in annotatedWords:\r\n                        break\r\n                    if verbMaDa.matches(token):\r\n                        maDaVerbsBetween += 1\r\n                    if (verbOleJarel1.matches(token)) or verbOleJarel2.matches(token):\r\n                        #\r\n                        #    Heuristik:\r\n                        #      Kui olema j2rel, osalause l6pus on nud/tud/mas ja nende vahel pole yhtegi \r\n                        #     punktuatsioonim2rki, sides6na, adverbe aga/kuid/vaid, juba m2rgendatud verbiahelat\r\n                        #     ega teist nud/tud/mas s6na, loeme selle s6na olema-fraasi laienduseks:\r\n                        #\r\n                        #           Pere ei_0 ole_0 Eestis toimuvast vaimustatud_0 .\r\n                        #           \" Viimasel ajal on_0 see asi j\u00e4lle susisema hakanud_0 \" ,\r\n                        #           Esiteks ei_0 olnud_0 vajalikul ajal tavaliselt bussi tulemas_0\r\n                        #\r\n                        if _isClauseFinal(tokenWID, clauseTokens ) and \\\r\n                           not _isSeparatedByPossibleClauseBreakers( clauseTokens, verbObj[PHRASE][-1], \\\r\n                           tokenWID, True, True, True):\r\n                           expansion = token\r\n                           #   Veakoht: kui -mas j2rel on da/ma, pole kindel, et tegu otsese rektsiooniseosega:\r\n                           #      Islamlannale on_0 harjumatu n\u00e4ha meest midagi maast korjamas_0 ,\r\n                        elif verbOleJarel1.matches(token) and eiOlePattern and i-lastTokIndex<=2:\r\n                           #\r\n                           #   Heuristik: \"ei\"+\"ole\"-ahela j2rel \"nud\" ning nende vahel pole rohkem kui\r\n                           #   yks muu s6na:\r\n                           #            Tagantj\u00e4rele m\u00f5eldes ei_0 oleks_0 ma pidanud_0 seda tegema .\r\n                           #            Mina ei_0 ole_0 suutnud_0 siiani maad osta .\r\n                           #\r\n                           expansion = token\r\n                        oleInfFollowing += 1\r\n                        break\r\n                    elif verbMata.matches(token) and maDaVerbsBetween == 0:\r\n                        #\r\n                        #    Heuristik:\r\n                        #      Kui olema j2rel, osalause l6pus on mata ja nende vahel pole yhtegi \r\n                        #     punktuatsioonim2rki, sides6na, adverbe aga/kuid/vaid, juba m2rgendatud \r\n                        #     verbiahelat, m6nd nud/tud/mas/ma/da verbi, loeme selle s6na olema-fraasi \r\n                        #     laienduseks:\r\n                        #\r\n                        #           Maanaine on_0 veel leidmata_0 .\r\n                        #           linnaarhitekti koht oli_0 aasta aega t\u00e4itmata_0\r\n                        #\r\n                        if _isClauseFinal(tokenWID, clauseTokens ) and \\\r\n                           not _isSeparatedByPossibleClauseBreakers( clauseTokens, verbObj[PHRASE][-1], \\\r\n                           tokenWID, True, True, True):\r\n                            expansion = token\r\n                            break\r\n                            #   Veakoht: kui vahel on 'ilma', siis see heuristik eksib t6en2oliselt:\r\n                            #          on_0 lihtsalt t\u00f5lgendatavad ka ilma situatsioonis osalemata_0\r\n                        oleInfFollowing += 1\r\n                #\r\n                #    Heuristik:\r\n                #     Kui osalauses ei j2rgne 'olema'-verbiga yhilduvaid verbe, kyll aga eelneb vahetult \r\n                #    m6ni selline ning seda pole veel m2rgendatud, loeme selle potentsiaalselt olema-verbiga\r\n                #    yhilduvaks, nt:\r\n                #\r\n                #                Unustatud_0 ei_0 ole_0 ka m\u00e4nge .\r\n                #                T\u00f5hustatud_0 on_0 ka turvameetmeid .\r\n                #                milleks looja ta maailma loonud_0 on_0 , nimelt soo j\u00e4tkamiseks .\r\n                #\r\n                if oleInfFollowing == 0 and not expansion:\r\n                    minWID = min( verbObj[PHRASE] )\r\n                    lastTokIndex = [i for i in range(len(clauseTokens)) if clauseTokens[i][WORD_ID] == minWID]\r\n                    lastTokIndex = lastTokIndex[0]\r\n                    token = clauseTokens[lastTokIndex-1]\r\n                    if lastTokIndex-1 > -1 and token[WORD_ID] not in annotatedWords:\r\n                        if (verbOleJarel1.matches(token) or verbOleJarel2.matches(token)):\r\n                            expansion = token\r\n                            appliedRule = 1\r\n                    \r\n                #\r\n                #    Eituse (aga ka vastavates jaatuse) fraasides j22vad siin eraldamata \r\n                #       ei + ole + Adv/Nom + Verb_da    \r\n                #    mustrid, nt:\r\n                #       Ei_0 ole_0 m\u00f5tet teha sellist s\u00f6\u00f6gikohta .\r\n                #       Ei_0 ole_0 v\u00f5imalik v\u00e4iksema vastu vahetada .\r\n                #       Ei_0 ole_0 pankuril vaja teada .\r\n                #    Nendega proovime tegeleda hiljem.\r\n                #\r\n            else:\r\n                #\r\n                #   Leiame ahela alguspunkti (minimaalse ID-ga verbi)\r\n                #\r\n                minWID = min( verbObj[PHRASE] )\r\n                lastTokIndex = [i for i in range(len(clauseTokens)) if clauseTokens[i][WORD_ID] == minWID]\r\n                if lastTokIndex:\r\n                    lastTokIndex = lastTokIndex[0]\r\n                    if lastTokIndex-1 > -1 and clauseTokens[lastTokIndex-1][WORD_ID] not in annotatedWords:\r\n                        #\r\n                        #    Heuristik:\r\n                        #   Kui \"olema\"-l6puline ahel on osalause l6pus, ning vahetult eelneb nud/tud/mas,\r\n                        #  siis loeme selle olema juurde kuuluvaks, nt:\r\n                        #          mis juba olnud ja veel tulemas_0 on_0 ,\r\n                        #          Eesti selle alamprojektiga seotud_0 ei_0 ole_0 .\r\n                        #          trombootilisi episoode kordunud_0 ei_0 ole_0 .\r\n                        #  (Yldiselt paistab suhteliselt v2heproduktiivne reegel olevat)\r\n                        # \r\n                        token = clauseTokens[lastTokIndex-1]\r\n                        if (verbOleJarel1.matches(token) or verbOleJarel2.matches(token)):\r\n                            expansion = token\r\n            if expansion:\r\n                tokenWID = expansion[WORD_ID]\r\n                verbObj[PHRASE].append( tokenWID )\r\n                verbObj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( expansion, [verbOleJarel1, verbOleJarel2, verbMata] ) )\r\n                if verbOle.matches(expansion):\r\n                    verbObj[PATTERN].append('ole')\r\n                else:\r\n                    verbObj[PATTERN].append('verb')\r\n                annotatedWords.append( tokenWID )", "response": "Given a list of tokens and a list of verb IDs returns a list of tokens that are annotated with the verb IDs in the clause."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _loadVerbSubcatRelations(infile):\r\n    ''' \r\n        Meetod, mis loeb failist sisse verbide rektsiooniseosed infiniitverbidega;\r\n        Eeldab, et rektsiooniseosed on tekstifailis, kujul:\r\n           h\u00e4bene\tda mast\r\n           igatse\tda\r\n        St rea alguses on verbilemma ning TAB-iga on sellest eraldatud v\u00f5imalike\r\n        rektsioonide (k\u00e4\u00e4ndeliste verbide vormitunnuste) loetelu, t\u00e4htsuse \r\n        j\u00e4rjekorras;\r\n        \r\n        Tagastab rektsiooniseosed s\u00f5nastikuna, mille v\u00f5tmeteks lemmad ning v\u00e4\u00e4rtusteks\r\n        vastavad vormitunnuste loetelud.\r\n    '''\r\n    relations = dict()\r\n    in_f = codecs.open(infile, mode='r', encoding='utf-8')\r\n    for line in in_f:\r\n        line = line.rstrip()\r\n        if len(line) > 0 and not re.match(\"^#.+$\", line):\r\n            (verb, forms) = line.split('\\t')\r\n            relations[verb] = forms.split()\r\n    in_f.close()\r\n    return relations", "response": "Load the subcat relations from a verb - level file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _isVerbExpansible( verbObj, clauseTokens, clauseID ):\r\n    '''\r\n         Kontrollib, kas tavaline verb on laiendatav etteantud osalauses:\r\n          *) verbi kontekstis (osalauses) on veel teisi verbe;\r\n          *) verb kuulub etteantud osalausesse;\r\n          *) tegemist ei ole olema-verbiga (neid vaatame mujal eraldi);\r\n          *) tegemist pole maks|mas|mast|mata-verbiga;\r\n          *) tegemist pole verbiahelaga, mille l6pus on ja/ning/ega/v6i-fraas;\r\n         Tagastab True, kui k6ik tingimused t2idetud;\r\n    '''\r\n    global _verbInfNonExpansible\r\n    # Leiame, kas fraas kuulub antud osalausesse ning on laiendatav\r\n    if verbObj[OTHER_VERBS] and verbObj[CLAUSE_IDX] == clauseID and \\\r\n       re.match('^(verb)$', verbObj[PATTERN][-1], re.I):\r\n        # Leiame viimasele s6nale vastava token'i\r\n        lastToken = [token for token in clauseTokens if token[WORD_ID] == verbObj[PHRASE][-1]]\r\n        if not lastToken:\r\n            raise Exception(' Last token not found for '+str(verbObj)+' in '+str( getJsonAsTextString(clauseTokens) ))\r\n        lastToken = lastToken[0]\r\n        # Leiame, ega tegu pole maks/mas/mast/mata verbidega (neid esialgu ei laienda edasi)\r\n        # NB! Tegelikult peaks v2hemalt -mas verbe saama siiski laiendada:\r\n        #      Ma ei_0 k\u00e4inud_0 teda palumas_0 \u00fcmber otsustada_0 .\r\n        # Aga kuidas seda teha v6imalikult v2heste vigadega, vajab edasist uurimist ...\r\n        if not _verbInfNonExpansible.matches(lastToken):\r\n           #   Kontrollime, et fraasi l6pus poleks ja/ning/ega/v6i fraasi:\r\n           #  kui on, siis esialgu targu seda fraasi laiendama ei hakka:\r\n           if len(verbObj[PATTERN]) >=3 and verbObj[PATTERN][-2] == '&':\r\n                return False\r\n           return True\r\n           #\r\n           #  TODO: siin tuleks ilmselt keelata ka 'saama + Verb_tud' konstruktsioonide laiendused,\r\n           #        kuna need kipuvad olema pigem vigased (kuigi haruldased); Nt.\r\n           #\r\n           #   ringi h\u00e4\u00e4letades sai_0 rongidega j\u00e4nest s\u00f5ita_0 ja vagunisaatjatest neidudega \u00f6\u00f6siti napsu v\u00f5etud_0 .\r\n           #\r\n    return False", "response": "Returns true if the verb is expansible."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _suitableVerbExpansion( foundSubcatChain ):\r\n    '''\r\n         V6tab etteantud jadast osa, mis sobib:\r\n          *) kui liikmeid on 3, keskmine on konjuktsioon ning esimene ja viimane \r\n             klapivad, tagastab selle kolmiku;\r\n             Nt.   ei_0 saa_0 lihtsalt v\u00e4lja astuda_? ja_? uttu t\u00f5mmata_? \r\n                   => astuda ja t\u00f5mmata\r\n          *) kui liikmeid on rohkem kui 3, teine on konjuktsioon ning esimene ja \r\n             kolmas klapivad, ning l6pus pole verbe, tagastab esikolmiku;\r\n          *) kui liikmeid on rohkem kui yks, v6tab liikmeks esimese mitte-\r\n             konjunktsiooni (kui selline leidub);\r\n         Kui need tingimused pole t2idetud, tagastab tyhis6ne;\r\n    '''\r\n    markings      = []\r\n    tokens        = []\r\n    nonConjTokens = []\r\n    for (marking, token) in foundSubcatChain:\r\n        markings.append( marking )\r\n        tokens.append( token )\r\n        if marking != '&':\r\n            nonConjTokens.append( token )\r\n    if (len(markings) == 3 and markings[0]==markings[2] and markings[0]!='&' and markings[1]=='&'):\r\n        return tokens\r\n    elif (len(markings) > 3 and markings[0]==markings[2] and markings[0]!='&' and markings[1]=='&' and \\\r\n          all([m == '&' for m in markings[3:]]) ):\r\n        return tokens[:3]\r\n    elif (len(nonConjTokens) > 0):\r\n        return nonConjTokens[:1]\r\n    return []", "response": "Returns a list of tuples where each tuple is a tuple of two - element tuples where the first element is the name of the target and the second is the name of the target and the second is the name of the target."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a new list of words with the same verb and other words.", "response": "def _expandSaamaWithTud( clauseTokens, clauseID, foundChains ):\r\n    ''' \r\n         Meetod, mis m\u00e4\u00e4rab spetsiifilised rektsiooniseosed: t\u00e4iendab 'saama'-verbiga l\u00f5ppevaid \r\n        verbijadasid, lisades (v6imalusel) nende l6ppu 'tud'-infiniitverbi \r\n        (nt. sai tehtud, sai k\u00e4idud ujumas);\r\n         Vastavalt leitud laiendustele t2iendab andmeid sisendlistis foundChains;\r\n    '''\r\n    verbTud   = WordTemplate({POSTAG:'V', FORM:'^(tud|dud)$'})\r\n    verb      = WordTemplate({POSTAG:'V'})\r\n    verbOlema = WordTemplate({POSTAG:'V', ROOT:'^(ole)$'})\r\n    for verbObj in foundChains:\r\n        # Leiame, kas fraas kuulub antud osalausesse ning on laiendatav\r\n        if _isVerbExpansible(verbObj, clauseTokens, clauseID):\r\n            lastVerbWID = verbObj[PHRASE][-1]\r\n            lastToken = [token for token in clauseTokens if token[WORD_ID] == lastVerbWID]\r\n            lastIndex = [i for i in range(len(clauseTokens)) if clauseTokens[i][WORD_ID] == lastVerbWID]\r\n            lastToken = lastToken[0]\r\n            lastIndex = lastIndex[0]\r\n            mainVerb  = [analysis[ROOT] for analysis in verb.matchingAnalyses(lastToken)]\r\n            mainVerbLemma = mainVerb[0]\r\n            # Leiame, kas tegemist on 'saama' verbiga\r\n            if mainVerbLemma == 'saa':\r\n                #\r\n                #    Saama + 'tud', lubame eraldada verbiahelana vaid siis, kui:\r\n                #     *) 'tud' on osalause l6pus ning vahel pole punktuatsioonim2rke, nt:\r\n                #          Kord sai_0 laadalt isegi aprikoosipuu koduaeda viidud_0 .\r\n                #     *) 'saama' on osalause l6pus ning vahetult eelneb 'tud', nt:\r\n                #          Ja et see vajaduse korral avalikustatud_1 saaks_1 .\r\n                #\r\n                expansion = None\r\n                if not _isClauseFinal(lastVerbWID, clauseTokens ):\r\n                    for i in range(lastIndex + 1, len(clauseTokens)):\r\n                        token = clauseTokens[i]\r\n                        tokenWID = token[WORD_ID]\r\n                        if verbTud.matches(token) and _isClauseFinal(tokenWID, clauseTokens ) and \\\r\n                           not _isSeparatedByPossibleClauseBreakers( clauseTokens, verbObj[PHRASE][-1], tokenWID, True, True, False):\r\n                            expansion = token\r\n                            break\r\n                elif lastIndex-1 > -1:\r\n                    if verbTud.matches(clauseTokens[lastIndex-1]):\r\n                        expansion = clauseTokens[lastIndex-1]\r\n                if expansion:\r\n                    tokenWID = expansion[WORD_ID]\r\n                    verbObj[PHRASE].append( tokenWID )\r\n                    verbObj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( expansion, verbTud ) )\r\n                    if verbOlema.matches(expansion):\r\n                        verbObj[PATTERN].append('ole')\r\n                    else:\r\n                        verbObj[PATTERN].append('verb')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _expandVerbChainsBySubcat( clauseTokens, clauseID, foundChains, verbSubcat, \\\r\n                                                        skipQuestionable=False, \\\r\n                                                        breakOnPunctuation=True ):\r\n    ''' \r\n        Meetod, mis proovib laiendada (mitte-'olema') verbidega l6ppevaid predikaadifraase, \r\n        lisades nende l\u00f5ppu rektsiooniseoste j\u00e4rgi uusi infiniitverbe, \r\n        nt \"kutsub\" + \"langetama\"\r\n           \"p\u00fc\u00fctakse\" + \"keelustada\" \"v\u00f5i\" \"takistada\"\r\n           \"ei julgenud\" + \"arvata\", \r\n           \"ei hakka\" + \"t\u00fclitama\";\r\n\r\n        Sisend 'clauseTokens' on list, mis sisaldab yhe osalause k6iki s6nu (pyvabamorfi poolt\r\n        tehtud s6na-analyyse); Sisend 'verbSubcat' sisaldab andmeid verb-infiniitverb \r\n        rektsiooniseoste kohta;\r\n        Tulemusena t2iendatakse olemasolevat verbijadade listi (foundChains), pikendades seal\r\n        olevaid verbiga l\u00f5ppevaid fraase, millal v\u00f5imalik;\r\n    '''\r\n    global _breakerJaNingEgaVoi, _breakerKomaLopus, _breakerPunktuats\r\n    verb      = WordTemplate({POSTAG:'V'})\r\n    verbInf1  = WordTemplate({POSTAG:'V', FORM:'^(da|ma|maks|mas|mast|mata)$'})\r\n    verbOlema = WordTemplate({POSTAG:'V', ROOT:'^(ole)$'})\r\n    sonaMitte = WordTemplate({ROOT:'^mitte$',POSTAG:'D'})\r\n    # J22dvustame s6nad, mis kuuluvad juba mingi tuvastatud verbifraasi koosseisu\r\n    annotatedWords = []\r\n    for verbObj in foundChains:\r\n        if (len(verbObj[PATTERN])==1 and re.match('^(ei|\u00e4ra|ega)$', verbObj[PATTERN][0])):\r\n            # V2lja j22vad yksikuna esinevad ei/\u00e4ra/ega, kuna need t\u00f5en\u00e4oliselt ei sega\r\n            continue\r\n        annotatedWords.extend( verbObj[PHRASE] )\r\n    # Leiame, millised verbid on veel vabad (st v6ivad potentsiaalselt liituda)\r\n    freeVerbsWIDs = [t[WORD_ID] for t in clauseTokens if verbInf1.matches(t) and t[WORD_ID] not in annotatedWords]\r\n    for verbObj in foundChains:\r\n        # Leiame, kas fraas kuulub antud osalausesse ning on laiendatav\r\n        if _isVerbExpansible(verbObj, clauseTokens, clauseID):\r\n            # Leiame viimasele s6nale vastava token'i, selle lemma ja vormitunnuse\r\n            lastToken = [token for token in clauseTokens if token[WORD_ID] == verbObj[PHRASE][-1]]\r\n            lastIndex = [i for i in range(len(clauseTokens)) if clauseTokens[i][WORD_ID] == verbObj[PHRASE][-1]]\r\n            lastToken = lastToken[0]\r\n            lastIndex = lastIndex[0]\r\n            mainVerb  = [(analysis[ROOT], analysis[FORM]) for analysis in verb.matchingAnalyses(lastToken)]\r\n            mainVerbLemma = mainVerb[0][0]\r\n            mainVerbForm  = mainVerb[0][1]\r\n            positivePhrase = (verbObj[POLARITY] == 'POS')\r\n            egaPhrase      = (verbObj[PATTERN][0] == 'ega')\r\n            #  Teeme kindlaks, kas verbi lemma on ylesm2rgitud rektsiooniseoste leksikoni\r\n            if mainVerbLemma in verbSubcat:\r\n                subcatForms = verbSubcat[ mainVerbLemma ]\r\n                for subcatForm in subcatForms:\r\n                    foundSubcatChain = []\r\n                    addingCompleted = False\r\n                    #  Kui on tegu vaieldava rektsiooniseosega: j2tame vahele v6i, kui vaieldavad\r\n                    #  on lubatud, eemaldame vaieldavuse m2rgi \r\n                    if re.match(\"^.+\\?$\", subcatForm):\r\n                        if skipQuestionable:\r\n                            continue\r\n                        else:\r\n                            subcatForm = subcatForm.replace('?', '')\r\n                    #\r\n                    #  1) Otsime sobivat verbi v6i verbifraasi s6na tagant, osalause teisest poolest\r\n                    #\r\n                    j = lastIndex + 1\r\n                    while (j < len(clauseTokens)):\r\n                        token = clauseTokens[j]\r\n                        tokenWID = token[WORD_ID]\r\n                        #  Katkestame kui:\r\n                        #  *) satume juba m2rgendatud s6nale;\r\n                        #  *) satume punktuatsioonile;\r\n                        if tokenWID in annotatedWords:\r\n                            break\r\n                        if breakOnPunctuation and _breakerPunktuats.matches(token):\r\n                            break\r\n                        #  Lisame kui:\r\n                        #  *) satume konjunktsioonile;\r\n                        #  *) satume sobivas vormis verbile;\r\n                        if _breakerJaNingEgaVoi.matches(token):\r\n                            foundSubcatChain.append(('&', token))\r\n                        if verb.matches(token):\r\n                            tokenForms = [analysis[FORM] for analysis in verb.matchingAnalyses(token)]\r\n                            if subcatForm in tokenForms:\r\n                                foundSubcatChain.append( (subcatForm, token) )\r\n                        #  Katkestame kui:\r\n                        #  *) satume komale (kuna koma v6ib kinnituda sobiva s6na l6ppu);\r\n                        if _breakerKomaLopus.matches(token):\r\n                            break\r\n                        j += 1\r\n                    #\r\n                    #     Kui osalause teisest poolest midagi ei leidnud, vaatame \r\n                    #     osalause esimest poolt:\r\n                    #\r\n                    #  2) Otsime sobivat verbi v6i verbifraasi vahetult s6na algusest\r\n                    #     (seda vaid siis, kui tegemist pole n\u00f6 'ega'-verbifraasiga - \r\n                    #      nondele midagi eelneda ei saagi);\r\n                    #     ( NB! 'ega' fraaside puhul tuleks tegelikult ka tagasi vaadata,\r\n                    #       aga ainult verbi ja 'ega' vahele, ja mitte mingil juhul \r\n                    #       'ega'-st ettepoole );\r\n                    #\r\n                    if not _suitableVerbExpansion( foundSubcatChain ) and not egaPhrase:\r\n                        minWid = min( verbObj[PHRASE] )\r\n                        j = lastIndex - 1\r\n                        while (j > -1):\r\n                            token = clauseTokens[j]\r\n                            tokenWID = token[WORD_ID]\r\n                            #  Katkestame kui:\r\n                            #  *) satume juba m2rgendatud s6nale (mis pole sellest fraasist);\r\n                            #  *) satume komale v6i muule punktuatsioonile;\r\n                            #  *) satume s6nale, mis on k6ige esimesest fraasiliikmest tagapool kui 2 s6na;\r\n                            if tokenWID in annotatedWords and tokenWID not in verbObj[PHRASE]:\r\n                                break\r\n                            if _breakerKomaLopus.matches(token) or (breakOnPunctuation and _breakerPunktuats.matches(token)):\r\n                                break\r\n                            if token[WORD_ID]+1 < minWid:\r\n                                break\r\n                            #  Lisame kui:\r\n                            #  *) satume konjunktsioonile;\r\n                            #  *) satume sobivas vormis verbile;\r\n                            if _breakerJaNingEgaVoi.matches(token):\r\n                                foundSubcatChain.append(('&', token))\r\n                            if verb.matches(token):\r\n                                tokenForms = [analysis[FORM] for analysis in verb.matchingAnalyses(token)]\r\n                                if subcatForm in tokenForms:\r\n                                    foundSubcatChain.append( (subcatForm, token) )\r\n                            j -= 1\r\n                    suitablePhrase = _suitableVerbExpansion( foundSubcatChain )\r\n                    if suitablePhrase:\r\n                        #\r\n                        #   Kui sobiv fraasikandidaat leidus, teostamine liitmise\r\n                        #\r\n                        for token in suitablePhrase:\r\n                            tokenWID = token[WORD_ID]\r\n                            verbObj[PHRASE].append( tokenWID )\r\n                            annotatedWords.append( tokenWID )\r\n                            if _breakerJaNingEgaVoi.matches(token):\r\n                                verbObj[PATTERN].append('&')\r\n                                verbObj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( token, _breakerJaNingEgaVoi ) )\r\n                            elif len(suitablePhrase) == 1 and verbOlema.matches(token):\r\n                                verbObj[PATTERN].append('ole')\r\n                                verbObj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( token, verbOlema ) )\r\n                                freeVerbsWIDs.remove( tokenWID )\r\n                            else:\r\n                                verbObj[PATTERN].append('verb')\r\n                                analysisIDs = [i for i in range(len(token[ANALYSIS])) if subcatForm == token[ANALYSIS][i][FORM]]\r\n                                assert len(analysisIDs) > 0\r\n                                verbObj[ANALYSIS_IDS].append( analysisIDs )\r\n                                freeVerbsWIDs.remove( tokenWID )\r\n                        if not freeVerbsWIDs:\r\n                            verbObj[OTHER_VERBS] = False\r\n                        addingCompleted = True\r\n                    if addingCompleted:\r\n                        break", "response": "A helper function that expands a list of verb chains by subcat."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _extractEgaNegFromSent( sentTokens, clausesDict, foundChains ):\r\n    ''' Meetod, mis tuvastab antud lausest 'ega'-predikaadiga seotud eituse(d): ega + sobiv verb.\r\n        *) Juhtudel kui 'ega'-le j2rgneb juba tuvastatud, positiivse polaarsusega verbiahel (nt \r\n           ahel mille alguses on k\u00e4skivas k\u00f5neviisis verb), liidetakse 'ega' olemasoleva ahela ette\r\n           ning muudetakse ahela polaarsus negatiivseks;\r\n        *) Muudel juhtudel otsitakse 'ega'-le j2rgnevat 'ei'-ga sobivat verbi (enamasti on selleks\r\n           'nud'-verb) ning liidetakse see (teatud heuristikute j2rgi) 'ega'-ga yheks fraasiks;\r\n\r\n        Tagastab True, kui uute 'ega' fraaside seas leidus m6ni selline, mida potentsiaalselt saaks \r\n        veel m6ne teise verbi liitmisega laiendada, muudel juhtudel tagastab False;\r\n        \r\n        Miks see meetod opereerib tervel lausel, mitte yksikul osalausel?\r\n        >> Kuna 'ega' on sageli m2rgitud osalause piiriks (p2rast 'ega'-t v6ib l6ppeda osalause), \r\n           ei saa 'ega'-le j2rgnevaid verbe alati otsida yhe osalause seest, vaid tuleb vaadata \r\n           korraga mitut k6rvutiolevat osalauset; k2esolevalt lihtsustame ja vaatame tervet \r\n           lauset.\r\n    '''\r\n    sonaEga     = WordTemplate({ROOT:'^ega$',POSTAG:'[DJ]'})\r\n    verbEiJarel  = WordTemplate({POSTAG:'V',FORM:'(o|nud|tud|nuks|nuvat|vat|ks|ta|taks|tavat)$'})\r\n    verbEiJarel2 = WordTemplate({ROOT:'^mine$', POSTAG:'V',FORM:'neg o$'})\r\n    verbTud     = WordTemplate({POSTAG:'V',FORM:'(tud)$'})\r\n    verb        = WordTemplate({POSTAG:'V'})\r\n    verbOlema   = WordTemplate({POSTAG:'V', ROOT:'^(ole)$'})\r\n    # J22dvustame s6nad, mis kuuluvad juba mingi tuvastatud verbifraasi koosseisu\r\n    annotatedWords = []\r\n    for verbObj in foundChains:\r\n        if (len(verbObj[PATTERN])==1 and re.match('^(ei|\u00e4ra|ega)$', verbObj[PATTERN][0])):\r\n            # V2lja j22vad yksikuna esinevad ei/\u00e4ra/ega, kuna need t\u00f5en\u00e4oliselt ei sega\r\n            continue\r\n        annotatedWords.extend( verbObj[PHRASE] )\r\n    expandableEgaFound = False\r\n    for i in range(len(sentTokens)):\r\n        token = sentTokens[i]\r\n        if sonaEga.matches(token) and token[WORD_ID] not in annotatedWords:\r\n            matchFound = False\r\n            if i+1 < len(sentTokens) and sentTokens[i+1][WORD_ID] in annotatedWords:\r\n                #\r\n                #    K6ige lihtsam juht: eelnevalt on verbifraas juba tuvastatud (ja \r\n                #   eeldatavasti maksimaalses pikkuses), seega pole teha muud, kui sellele\r\n                #   ega ette panna ning polaarsuse negatiivseks muuta:\r\n                #         Te saate kaebusi palju ega_0 j\u00f5ua_0 nendele reageerida_0 .\r\n                #         vene keelt ta ei m\u00f5ista ega_0 v\u00f5i_0 seep\u00e4rast olla_0 vene spioon\r\n                #   NB! Lisamist ei teosta siiski juhtudel kui:\r\n                #    *) J2rgnev fraas on juba negatiivse polaarsusega (selline laiendamine \r\n                #       tekitaks lihtsalt mustreid juurde, aga sisulist infot juurde ei \r\n                #       annaks);\r\n                #    *) J2rgnev s6na pole 'ei'-ga yhilduv verb (t6en2oliselt on mingi jama,\r\n                #       nt morf yhestamisel);\r\n                #    *) J2rgnev s6na kuulub verbiahelasse, mis algab enne 'ega'-t (see viitab \r\n                #       tegelikult sellele, et k6nealune verbiahel on katkiselt eraldatud);\r\n                #\r\n                for verbObj in foundChains:\r\n                    if sentTokens[i+1][WORD_ID] in verbObj[PHRASE] and verbObj[POLARITY] != 'NEG' and \\\r\n                       (verbEiJarel.matches( sentTokens[i+1] ) or verbEiJarel2.matches( sentTokens[i+1] )) \\\r\n                       and i < min( verbObj[PHRASE] ):\r\n                            verbObj[PHRASE].insert(0, token[WORD_ID])\r\n                            verbObj[PATTERN].insert(0, 'ega')\r\n                            verbObj[POLARITY] = 'NEG'\r\n                            verbObj[ANALYSIS_IDS].insert(0, _getMatchingAnalysisIDs( token, sonaEga ) )\r\n                            annotatedWords.append( token[WORD_ID] )\r\n                            matchFound = True\r\n                            break\r\n            elif i+1 < len(sentTokens) and verbEiJarel.matches( sentTokens[i+1] ) and \\\r\n             sentTokens[i+1][WORD_ID] not in annotatedWords:\r\n                #\r\n                #    Heuristik:\r\n                #      kui 'ega'-le j2rgneb vahetult 'ei'-ga sobiv verb (peaks olema\r\n                #     infiniitne nud/tud verb, kuna finiitsed leitakse ja seotakse\r\n                #     t6en2oliselt eelmises harus), siis eraldame uue fraasina:\r\n                #\r\n                #        Hakkasin Ainikiga r\u00e4\u00e4kima ega_0 p\u00f6\u00f6ranud_0 Ivole enam t\u00e4helepanu .\r\n                #        Tereese oli t\u00fckk aega vait ega_0 teadnud_0 , kas t\u00f5tt r\u00e4\u00e4kida v\u00f5i mitte .\r\n                #\r\n                # >> clauseID-iks saab j2rgneva verbi ID, kuna 'ega' j2relt l2heb sageli\r\n                #    osalausepiir ning ega-le eelnevad verbid kindlasti sellega seotud olla \r\n                #    ei saa.\r\n                clauseID = sentTokens[i+1][CLAUSE_IDX]\r\n                wid1 = sentTokens[i][WORD_ID]\r\n                wid2 = sentTokens[i+1][WORD_ID]\r\n                verbObj = { PHRASE: [wid1, wid2], PATTERN: [\"ega\", \"verb\"] }\r\n                verbObj[CLAUSE_IDX] = clauseID\r\n                if verbOlema.matches(sentTokens[i+1]):\r\n                    verbObj[PATTERN][1] = 'ole'\r\n                verbObj[POLARITY] = 'NEG'\r\n                verbObj[ANALYSIS_IDS] = []\r\n                verbObj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( sentTokens[i], sonaEga ) )\r\n                verbObj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( sentTokens[i+1], verbEiJarel ) )\r\n                # Teeme kindlaks, kas j2rgneb veel verbe, mis v6iksid potentsiaalselt liituda\r\n                verbObj[OTHER_VERBS] = False\r\n                if i+2 < len(sentTokens):\r\n                    for j in range(i+2, len(sentTokens)):\r\n                        token2 = sentTokens[j]\r\n                        if token2[CLAUSE_IDX] == clauseID and verb.matches(token2):\r\n                            verbObj[OTHER_VERBS] = True\r\n                            break\r\n                if verbObj[OTHER_VERBS]:\r\n                    expandableEgaFound = True\r\n                else:\r\n                    #\r\n                    #    Kui osalausest on tuvastatud teisi predikaadieituseid ning need\r\n                    #   eelnevad praegusele 'ega'-eitusele , nt:\r\n                    #        Ei l\u00fckka ma \u00fcmber ega kinnita.\r\n                    #        Ta ei oota ega looda_0 ( enam ).\r\n                    #    V6ib olla tegu keerukama tervikfraasiga, nt:\r\n                    #        Ta ise pole kuidagi saanud ega tahnud_0 end samastada nendega.\r\n                    #    Sellistel juhtudel m2rgime konteksti mitmeseks, kuna 'ega'-fraas\r\n                    #    v6ib toetuda varasemale verbiahelale;\r\n                    #\r\n                    for j in range(i-1, -1, -1):\r\n                        token2 = sentTokens[j]\r\n                        if token2[CLAUSE_IDX] == clauseID:\r\n                            for verbObj2 in foundChains:\r\n                                if token2[WORD_ID] in verbObj2[PHRASE] and verbObj2[POLARITY] != 'POS':\r\n                                    verbObj[OTHER_VERBS] = True\r\n                                    break\r\n                foundChains.append( verbObj )\r\n                annotatedWords.extend( verbObj[PHRASE] )\r\n                matchFound = True\r\n            if not matchFound:\r\n                #\r\n                #    2.  'ega' + kaugemal j\u00e4rgnev verb\r\n                # \r\n                #    2.1   Kui 'ega'-le ei j2rgne ega eelne yhtegi eitust, kyll aga j2rgneb \r\n                #          (osalause piires) 'ei'-le sobiv verb, loeme teatud juhtudel, et \r\n                #          tegu on sobiva eitusfraasiga.\r\n                #          Nt.\r\n                #              Nii et ega_0 Diana j\u00f5ulureedel s\u00fcnnitanudki .\r\n                #              Ega_0 ta tahtnud algul r\u00e4\u00e4kida .\r\n                #           Yldiselt paistab see muster olevat sage just ilukirjanduses ja \r\n                #          suulise k6ne l2hedases keelekasutuses, harvem ajakirjanduses ning\r\n                #          veel v2hem kasutusel teaduskirjanduses;\r\n                #\r\n                egaClauseID = sentTokens[i][CLAUSE_IDX]\r\n                precedingNeg = False\r\n                followingNeg = False\r\n                followingPos = None\r\n                for verbObj1 in foundChains:\r\n                    if verbObj1[CLAUSE_IDX] == egaClauseID:\r\n                        if verbObj1[POLARITY] != 'POS':\r\n                            if any([ wid < sentTokens[i][WORD_ID] for wid in verbObj1[PHRASE] ]):\r\n                                precedingNeg = True\r\n                            if any([ wid > sentTokens[i][WORD_ID] for wid in verbObj1[PHRASE] ]):\r\n                                followingNeg = True\r\n                        elif verbObj1[POLARITY] == 'POS' and \\\r\n                             all([wid > sentTokens[i][WORD_ID] for wid in verbObj1[PHRASE]]):\r\n                            followingPos = verbObj1\r\n                if not precedingNeg and not followingNeg:\r\n                    if followingPos:\r\n                        #\r\n                        #    K6ige lihtsam juht: kui j2rgneb positiivne verbiahel (ja eeldatavasti \r\n                        #   maksimaalses pikkuses) ning:\r\n                        #        *) ahelverbi ja 'ega' vahel pole punktuatsiooni;\r\n                        #        *) ahelverb sisaldab 'ei'-ga yhilduvat verbivormi;\r\n                        #   liidame ahelale 'ega' ette ning muudame polaarsuse negatiivseks:\r\n                        #        Ega_0 neil seal kerge ole_0 . \"\r\n                        #        Ega_0 70 eluaastat ole_0 naljaasi !\r\n                        #        Ega_0 sa puus\u00e4rgis paugutama_0 hakka_0 . \"\r\n                        #\r\n                        minWID = min(followingPos[PHRASE])\r\n                        phraseTokens = [t for t in sentTokens if t[WORD_ID] in followingPos[PHRASE]]\r\n                        if any( [verbEiJarel.matches( t ) for t in phraseTokens] ) and \\\r\n                           not _isSeparatedByPossibleClauseBreakers( sentTokens, token[WORD_ID], minWID, True, True, False):\r\n                            followingPos[PHRASE].insert(0, token[WORD_ID])\r\n                            followingPos[PATTERN].insert(0, 'ega')\r\n                            followingPos[POLARITY] = 'NEG'\r\n                            followingPos[ANALYSIS_IDS].insert(0, _getMatchingAnalysisIDs( token, sonaEga ) )\r\n                            annotatedWords.append( token[WORD_ID] )\r\n                            matchFound = True\r\n                            #\r\n                            #   Veakoht - vahel on 'kui':\r\n                            #      \" Ega_0 muud kui pista_0 heinad p\u00f5lema_0\r\n                            #\r\n                    elif i+1 < len(sentTokens):\r\n                        #\r\n                        #    Heuristik:\r\n                        #      Kui 'ega'-le j2rgneb samas osalauses 'ei'-ga sobiv verb ning:\r\n                        #        *) see verb ei ole 'tud'-verb (seega t6en2oliselt on 'nud');\r\n                        #        *) see verb asub osalause l6pus v6i pole 'ega'-st kaugemal kui \r\n                        #           2 s6na;\r\n                        #        *) see verb ei kuulu juba m2rgendatud verbiahelate sisse;\r\n                        #      siis eraldame uue 'ega'-fraasina, nt:\r\n                        #\r\n                        #            Ega_0 poiss teda enam vahtinudki_0 .\r\n                        #            Ega_0 keegi sellist tulemust ju soovinud_0 ,\r\n                        #            Ja ega_0 ta soovinudki_0 Semperi kombel \u00fcmber \u00f5ppida .\r\n                        #\r\n                        for j in range(i+1, len(sentTokens)):\r\n                            token2 = sentTokens[j]\r\n                            if token2[CLAUSE_IDX] == egaClauseID and verbEiJarel.matches(token2) and \\\r\n                               not verbTud.matches(token2) and token2[WORD_ID] not in annotatedWords and \\\r\n                               (_isClauseFinal( token2[WORD_ID], clausesDict[token2[CLAUSE_IDX]] ) or \\\r\n                               j-i <= 2):\r\n                                    wid1 = sentTokens[i][WORD_ID]\r\n                                    wid2 = token2[WORD_ID]\r\n                                    verbObj = { PHRASE: [wid1, wid2], PATTERN: [\"ega\", \"verb\"] }\r\n                                    verbObj[CLAUSE_IDX] = token2[CLAUSE_IDX]\r\n                                    if verbOlema.matches(token2):\r\n                                        verbObj[PATTERN][1] = 'ole'\r\n                                    verbObj[POLARITY] = 'NEG'\r\n                                    verbObj[ANALYSIS_IDS] = []\r\n                                    verbObj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( sentTokens[i], sonaEga ) )\r\n                                    verbObj[ANALYSIS_IDS].append( _getMatchingAnalysisIDs( token2, verbEiJarel ) )\r\n                                    # Teeme kindlaks, kas osalauses on veel verbe, mis v6iksid potentsiaalselt liituda\r\n                                    verbObj[OTHER_VERBS] = False\r\n                                    if i+2 < len(sentTokens):\r\n                                        for j in range(i+2, len(sentTokens)):\r\n                                            token3 = sentTokens[j]\r\n                                            if token3[CLAUSE_IDX] == verbObj[CLAUSE_IDX] and \\\r\n                                               token2 != token3 and verb.matches(token3):\r\n                                                    verbObj[OTHER_VERBS] = True\r\n                                                    break\r\n                                    if verbObj[OTHER_VERBS]:\r\n                                        expandableEgaFound = True\r\n                                    foundChains.append( verbObj )\r\n                                    annotatedWords.extend( verbObj[PHRASE] )\r\n                                    matchFound = True\r\n                                    break\r\n    return expandableEgaFound", "response": "Extract an egaNeg from a list of sentTokens and clausesDict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a new list of tokens that are found in the verbChain.", "response": "def _determineVerbChainContextualAmbiguity( clauseTokens, clauseID, foundChains ):\r\n    '''\r\n         Meetod, mis p\u00fc\u00fcab otsustada iga leitud verbiahela (foundChains liikme) puhul, kas \r\n        osalauses leidub veel vabu verbe, millega verbiahelat oleks v\u00f5imalik t\u00e4iendada;\r\n         Kui vabu verbe ei leidu, muudab verbiahela OTHER_VERBS v\u00e4\u00e4rtuse negatiivseks, vastasel \r\n        juhul ei tee midagi.\r\n         Sisend 'clauseTokens' on list, mis sisaldab yhe osalause k6iki s6nu (pyvabamorfi poolt\r\n        tehtud s6na-analyyse), clauseID on vastava osalause indentifikaator; \r\n    '''\r\n    verb      = WordTemplate({POSTAG:'V'})\r\n    verbOlema = WordTemplate({POSTAG:'V', ROOT:'^(ole)$'})\r\n    verbSaama = WordTemplate({POSTAG:'V', ROOT:'^(saa)$'})\r\n    verbEiAra = WordTemplate({ROOT:'^(\u00e4ra|ei)$',FORM:'neg.*',POSTAG:'V'})\r\n    verbInf        = WordTemplate({POSTAG:'V', FORM:'^(da|des|ma|tama|ta|mas|mast|nud|tud|v|mata)$'})\r\n    regularVerbInf = WordTemplate({POSTAG:'V', FORM:'^(da|ma|maks|mas|mast|mata)$'})\r\n    olemaVerbInf   = WordTemplate({POSTAG:'V', FORM:'^(nud|tud|da|ma|mas|mata)$'})\r\n    saamaVerbInf   = WordTemplate({POSTAG:'V', FORM:'^(tud|da|ma)$'})\r\n    sonaMitte = WordTemplate({ROOT:'^mitte$',POSTAG:'D'})\r\n    # J22dvustame s6nad, mis kuuluvad juba mingi tuvastatud verbifraasi koosseisu\r\n    annotatedWords = []\r\n    for verbObj in foundChains:\r\n        if (len(verbObj[PATTERN])==1 and re.match('^(ei|\u00e4ra|ega)$', verbObj[PATTERN][0])):\r\n            # V2lja j22vad yksikuna esinevad ei/\u00e4ra/ega, kuna need t\u00f5en\u00e4oliselt ei sega\r\n            continue\r\n        annotatedWords.extend( verbObj[PHRASE] )\r\n    finVerbs      = [t for t in clauseTokens if verb.matches(t) and not verbInf.matches(t) ]\r\n    negFinVerbs   = [t for t in finVerbs if verbEiAra.matches(t)]\r\n    looseNegVerbs = [t for t in negFinVerbs if t[WORD_ID] not in annotatedWords]\r\n    #\r\n    #  Kontrollime, milline on osalause finiitverbiline kontekst. Kui seal on mingi potentsiaalne\r\n    # segadus, j\u00e4tamegi k\u00fcsim\u00e4rgid alles / kustutamata.\r\n    #\r\n    if len(negFinVerbs)==0 and len(finVerbs) >= 2:\r\n        #  *) Kui negatiivseid finiitverbe pole, aga positiivseid on rohkem kui 2, j\u00e4\u00e4b \r\n        #     praegu lahtiseks, mis seal kontekstis toimub. J\u00e4tame k\u00f5ik k\u00fcsim\u00e4rgiga;\r\n        return\r\n    elif len(looseNegVerbs) > 0:\r\n        #  *) Kui leidub negatiivseid finiitverbe, mida pole 6nnestunud pikemaks ahelaks\r\n        #     pikendada, j\u00e4\u00e4b samuti lahtiseks, mis seal kontekstis toimub. J\u00e4tame k\u00f5ik\r\n        #     k\u00fcsim\u00e4rgiga;\r\n        return\r\n    elif not looseNegVerbs and negFinVerbs and len(negFinVerbs)-len(finVerbs)>0:\r\n        #  *) Kui negatiivseid verbe leidub rohkem, kui positiivseid, j22b ka lahtiseks,\r\n        #     mis seal kontekstis t\u00e4pselt toimub. NB! Mineviku eitus j\u00e4\u00e4b paraku samuti\r\n        #     lahtiseks, aga praegu ei oska selle v\u00e4ltimiseks lihtsat reeglit anda;\r\n        return\r\n    rVerbFreeVerbs = None\r\n    olemaFreeVerbs = None\r\n    saamaFreeVerbs = None\r\n    for verbObj in foundChains:\r\n        #\r\n        #    Vaatame verbe, mille osalausekontekstis on teisi (infiniit)verbe; Kui kontekstis \r\n        #   ei leidu vabu (potentsiaalselt liituda v\u00f5ivaid verbe), m\u00e4rgime konteksti vabaks.\r\n        #   Nt. alltoodud kontekstis ei ole m\u00e4rgitud verbidele enam yhtki teist verbi \r\n        #       liita (kuigi kontekstis leidub teisi infiniitverbe):\r\n        #\r\n        #         1920 vastu v\u00f5etud Tallinna tehnikumi p\u00f5hikiri kaotas_0 kehtivuse .\r\n        #         kuid h\u00e4irest haaratud \u00f5unad nakatuvad_0 kiiresti m\u00e4danikesse ,\r\n        #\r\n        if verbObj[CLAUSE_IDX] == clauseID and verbObj[OTHER_VERBS]:\r\n            contextClear = False\r\n            #\r\n            #   Leiame viimasele s6nale vastava token'i, selle lemma ja vormitunnuse\r\n            #\r\n            lastToken = [ token for token in clauseTokens if token[WORD_ID] == verbObj[PHRASE][-1] ]\r\n            lastToken = lastToken[0]\r\n            analyses  = [ lastToken[ANALYSIS][j] for j in range(len(lastToken[ANALYSIS])) if j in verbObj[ANALYSIS_IDS][-1] ]\r\n            mainVerb  = [ analysis[ROOT] for analysis in analyses ]\r\n            mainVerbLemma = mainVerb[0]\r\n            #\r\n            #   Leiame, millised verbid on veel vabad (st v6ivad potentsiaalselt rektsiooni-\r\n            #  seoses liituda); 'saama' ja 'olema' verbide puhul on potentsiaalsed liitujad\r\n            #  natuke teistsugused kui ylej22nud verbidel;\r\n            #\r\n            if 'saa' == mainVerbLemma:\r\n                if saamaFreeVerbs == None:\r\n                    saamaFreeVerbs = [t[WORD_ID] for t in clauseTokens if saamaVerbInf.matches(t) and t[WORD_ID] not in annotatedWords]\r\n                if not saamaFreeVerbs:\r\n                    contextClear = True\r\n            elif 'ole' == mainVerbLemma:\r\n                if olemaFreeVerbs == None:\r\n                    olemaFreeVerbs = [t[WORD_ID] for t in clauseTokens if olemaVerbInf.matches(t) and t[WORD_ID] not in annotatedWords]\r\n                if not olemaFreeVerbs:\r\n                    contextClear = True\r\n            else:\r\n                if rVerbFreeVerbs == None:\r\n                    rVerbFreeVerbs = [t[WORD_ID] for t in clauseTokens if regularVerbInf.matches(t) and t[WORD_ID] not in annotatedWords]\r\n                if not rVerbFreeVerbs:\r\n                    contextClear = True\r\n            #\r\n            #   Kui yhtegi vaba verbi ei leidunud, m\u00e4rgime konteksti puhtaks\r\n            #\r\n            if contextClear:\r\n                verbObj[OTHER_VERBS] = False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _getMatchingAnalysisIDs( tokenJson, requiredWordTemplate, discardAnalyses = None ):\r\n    '''   Tagastab listi tokenJson'i analyysidest, mis sobivad etteantud yksiku \r\n         s\u00f5namalli v\u00f5i s\u00f5namallide listi m\u00f5ne elemendiga (requiredWordTemplate v\u00f5ib \r\n         olla \u00fcks WordTemplate v\u00f5i list WordTemplate elementidega);\r\n         \r\n          Kui discardAnalyses on defineeritud (ning on WordTemplate), visatakse minema\r\n         analyysid, mis vastavad sellele s6namallile;\r\n    '''\r\n    final_ids = set()\r\n    if isinstance(requiredWordTemplate, list):\r\n        for wt in requiredWordTemplate:\r\n            ids = wt.matchingAnalyseIndexes(tokenJson)\r\n            if ids:\r\n                final_ids.update(ids)\r\n    elif isinstance(requiredWordTemplate, WordTemplate):\r\n        ids = requiredWordTemplate.matchingAnalyseIndexes(tokenJson)\r\n        final_ids = set(ids)\r\n    if discardAnalyses:\r\n        if isinstance(discardAnalyses, WordTemplate):\r\n            ids2 = discardAnalyses.matchingAnalyseIndexes(tokenJson)\r\n            if ids2:\r\n                final_ids = final_ids.difference(set(ids2))\r\n        else:\r\n            raise Exception(' The parameter discardAnalyses should be WordTemplate.')\r\n    if len(final_ids) == 0:\r\n        raise Exception(' Unable to find matching analyse IDs for: '+str(tokenJson))\r\n    return list(final_ids)", "response": "Returns a list of all the IDs that match the given tokenJson."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfunction for checking a valid regex.", "response": "def is_valid_regex(regex):\n    \"\"\"Function for checking a valid regex.\"\"\"\n    if len(regex) == 0:\n        return False\n    try:\n        re.compile(regex)\n        return True\n    except sre_constants.error:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_left(elem1, elem2):\n    # assert not (nested(elem1, elem2) or nested(elem2, elem1)), 'deletion not defined for nested elements'\n    if overlapping_right(elem1, elem2):\n        elem1['end'] = elem2['start']\n    return elem1, elem2", "response": "delete elem1 and elem2 if overlapping elem1 and elem2"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_right(elem1, elem2):\n    # assert not (nested(elem1, elem2) or nested(elem2, elem1)), 'deletion not defined for nested elements'\n    if overlapping_left(elem1, elem2):\n        elem2['start'] = elem1['end']\n    return elem1, elem2", "response": "delete elem1 and elem2 if overlapping elem1 and elem2"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\niterate over pairwise intersecting elements.", "response": "def iterate_intersecting_pairs(layer):\n    \"\"\"\n    Given a layer of estntltk objects, yields pairwise intersecting elements.\n    Breaks when the layer is changed or deleted after initializing the iterator.\n    \"\"\"\n    yielded = set()\n    ri = layer[:]  # Shallow copy the layer\n    for i1, elem1 in enumerate(ri):\n        for i2, elem2 in enumerate(ri):\n            if i1 != i2 and elem1['start'] <= elem2['start'] < elem1['end']:\n                inds = (i1, i2) if i1 < i2 else (i2, i1)\n                if inds not in yielded and in_by_identity(layer, elem1) and in_by_identity(layer, elem2):\n                    yielded.add(inds)\n                    yield elem1, elem2"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef analyze_text( self, text, **kwargs ):\r\n        ''' \r\n        Analyzes given Text for noun phrase chunks. \r\n\r\n         As result of analysis, a layer NOUN_CHUNKS will be attached to the input\r\n        Text object, containing a noun phrases detected from the Text;\r\n        \r\n         Note: for preprocessing the Text, MaltParser is used by default. In order \r\n        to obtain a decent performance with MaltParser, it is advisable to analyse \r\n        texts at their full extent with this method. Splitting a text into smaller \r\n        chunks, such as clauses or sentences, and analysing one-small-chunk-at-time \r\n        may be rather demanding in terms of performance, because a file-based \r\n        preprocessing is used for obtaining the dependency relations.\r\n\r\n        Parameters\r\n        ----------\r\n        text:  estnltk.text.Text\r\n            The input text that should be analysed for noun phrases; \r\n\r\n        force_parsing : bool \r\n            If True, uses the *self.parser* to parse the given *text*, and overrides\r\n            the syntactic annotations in *text* with the new layer obtained from the \r\n            parser;\r\n            (default: False)\r\n        \r\n        syntax_layer : str\r\n            Specifies which layer of syntactic annotations should be used as a\r\n            basis for NP chunking; If the *syntax_layer* exists within the *text*\r\n            (and force_parsing==False), uses the syntactic annotations from \r\n            *text[syntax_layer]*;\r\n            (default: LAYER_CONLL)\r\n\r\n        cutPhrases: bool\r\n            If True, all phrases exceeding the cutMaxThreshold will be \r\n            cut into single word phrases, consisting only of part-of-speech \r\n            categories 'S', 'Y', 'H';\r\n            (default: True)\r\n\r\n        cutMaxThreshold: int\r\n            Threshold indicating the maximum number of words allowed in a \r\n            phrase.\r\n            If cutPhrases is set, all phrases exceeding the threshold will be \r\n            cut into single word phrases, consisting only of part-of-speech \r\n            categories 'S', 'Y', 'H';\r\n            Automatic analysis of the Balanced Corpus of Estonian suggests \r\n            that 97% of all NP chunks are likely chunks of length 1-3, thus \r\n            the default threshold is set to 3;\r\n            (default value: 3)\r\n        \r\n        return_type: string\r\n            If return_type==\"text\" (Default), \r\n                returns the input Text object;\r\n            If return_type==\"labels\", \r\n                returns a list of NP labels (strings), containing a label for \r\n                each word token in Text, indicating whether the word is at the \r\n                beginning of a phrase ('B'), inside a phrase ('I') or does \r\n                not belong to any phrase ('O').\r\n            If return_type==\"tokens\", \r\n                returns a list of phrases, where each phrase is a list of\r\n                tokens, and each token is a dictionary representing word;\r\n            If return_type==\"strings\", \r\n                returns a list of text strings, where each string is phrase's \r\n                text;\r\n            Regardless the return type, a layer named NOUN_CHUNKS will be added \r\n            to the input Text containing noun phrase annotations;\r\n        \r\n        '''\r\n        # 0) Parse given arguments\r\n        #\r\n        # Output specifics\r\n        all_return_types = [\"text\", \"labels\", \"tokens\", \"strings\"]\r\n        return_type     = all_return_types[0]\r\n        cutPhrases      = True\r\n        cutMaxThreshold = 3\r\n        annotate_text   = True\r\n        # Syntax layer & Parsing specifics\r\n        syntax_layer_name = LAYER_CONLL\r\n        force_parsing     = False\r\n        for argName, argVal in kwargs.items():\r\n            if argName == 'cutPhrases':\r\n                cutPhrases = bool(argVal)\r\n            elif argName == 'force_parsing':\r\n                force_parsing = bool(argVal)\r\n            elif argName == 'syntax_layer':\r\n                syntax_layer_name = argVal\r\n            elif argName == 'cutMaxThreshold':\r\n                cutMaxThreshold = int(argVal)\r\n            elif argName == 'return_type':\r\n                if argVal.lower() in all_return_types:\r\n                    return_type = argVal.lower()\r\n                else:\r\n                    raise Exception(' Unexpected return type: ', argVal)\r\n            else:\r\n                raise Exception(' Unsupported argument given: '+argName)\r\n\r\n        #\r\n        # 1) Acquire the layers of morphological & syntactic annotations:\r\n        #\r\n        if not syntax_layer_name in text or force_parsing:\r\n            # No existing layer found: produce a new layer with the parser\r\n            self.parser.parse_text( text )\r\n            if isinstance(self.parser, MaltParser):\r\n                syntax_layer_name = LAYER_CONLL\r\n            elif isinstance(self.parser, VISLCG3Parser):\r\n                syntax_layer_name = LAYER_VISLCG3\r\n            else:\r\n                raise Exception(' (!) Unknown type of syntactic parser: ',self.parser)\r\n\r\n        if not text.is_tagged(ANALYSIS):\r\n            # If missing, add the layer of morphological analyses\r\n            text = text.tag_analysis()\r\n\r\n        # 2) Process text sentence by sentence\r\n        all_np_labels = []\r\n        for sentence_text in text.split_by( SENTENCES ):\r\n            tokens       = sentence_text[WORDS]\r\n            syntax_layer = sentence_text[syntax_layer_name]\r\n            # Find phrases\r\n            np_labels = self._find_phrases( tokens, syntax_layer, cutPhrases, cutMaxThreshold )\r\n            # Normalize labels\r\n            np_labels = [ 'O' if not l in ['B', 'I'] else l for l in np_labels ]\r\n            # Collect results\r\n            all_np_labels.extend( np_labels )\r\n\r\n        # 3) Return input text, labels, phrases or phrase texts\r\n        if annotate_text:\r\n            self.annotateText( text, NOUN_CHUNKS, all_np_labels )\r\n        if return_type == \"text\":\r\n            return text\r\n        elif return_type == \"labels\":\r\n            return all_np_labels\r\n        elif return_type == \"tokens\":\r\n            return self.get_phrases(text, all_np_labels)\r\n        else:\r\n            return self.get_phrase_texts(text, all_np_labels)", "response": "Analyzes the given text for noun phrases and returns a dictionary of the appropriate NP - related fields."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the POS of the current token.", "response": "def _getPOS( self, token, onlyFirst = True ):\r\n        ''' Returns POS of the current token.\r\n        '''\r\n        if onlyFirst:\r\n            return token[ANALYSIS][0][POSTAG]\r\n        else:\r\n            return [ a[POSTAG] for a in token[ANALYSIS] ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the full length phrase from the position i based on the NP phrase annotations from NPlabels.", "response": "def _getPhrase( self, i, sentence, NPlabels ):\r\n        ''' Fetches the full length phrase from the position i\r\n            based on the existing NP phrase annotations (from \r\n            NPlabels);\r\n            Returns list of sentence tokens in the phrase, and \r\n            indices of the phrase;\r\n        ''' \r\n        phrase  = []\r\n        indices = []\r\n        if 0 <= i and i < len(sentence) and NPlabels[i] == 'B':\r\n            phrase  = [ sentence[i] ]\r\n            indices = [ i ]\r\n            j = i + 1\r\n            while ( j < len(sentence) ):\r\n                if NPlabels[j] in ['B', '']:\r\n                    break\r\n                else:\r\n                    phrase.append( sentence[j] )\r\n                    indices.append( j )\r\n                j += 1\r\n        return phrase, indices"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _getCaseAgreement(self, token1, token2):\r\n        '''  Detects whether there is a morphological case agreement \r\n            between two consecutive nominals (token1 and token2), and \r\n            returns the common case, or None if no agreement exists;\r\n             Applies a special set of rules for detecting agreement on\r\n            the word in genitive followed by the word in ter, es, ab or\r\n            kom.\r\n        '''\r\n        forms1 = set( [a[FORM] for a in token1[ANALYSIS]] )\r\n        forms2 = set( [a[FORM] for a in token2[ANALYSIS]] )\r\n        if len(forms1.intersection(forms2))==0:\r\n            # Kontrollime ka ni-na-ta-ga k22ndeid:\r\n            if 'sg g' in forms1:\r\n                if 'sg ter' in forms2:\r\n                    return 'sg ter'\r\n                elif 'sg es' in forms2:\r\n                    return 'sg es'\r\n                elif 'sg ab' in forms2:\r\n                    return 'sg ab'\r\n                elif 'sg kom' in forms2:\r\n                    return 'sg kom'\r\n            elif 'pl g' in forms1:\r\n                if 'pl ter' in forms2:\r\n                    return 'pl ter'\r\n                elif 'pl es' in forms2:\r\n                    return 'pl es'\r\n                elif 'pl ab' in forms2:\r\n                    return 'pl ab'\r\n                elif 'pl kom' in forms2:\r\n                    return 'pl kom'\r\n            return None\r\n        else:\r\n            return list(forms1.intersection(forms2))[0]", "response": "Returns the common case of two tokens."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _find_phrases( self, sentence, syntax_layer, cutPhrases, cutMaxThreshold ):\r\n        ''' Detects NP phrases by relying on local dependency relations:\r\n        \r\n            1) Identifies potential heads of NP phrases;\r\n            2) Identifies consecutive words that can form an NP phrase:\r\n               2.1) potential attribute + potential head;\r\n               2.2) quantity word or phrase + nominal;\r\n            3) Identifies non-consecutive words (word1 __ wordN) that\r\n               can form a complete phrase (including the gap part);\r\n            4) Applies post-corrections;\r\n            \r\n            Returns a list of tags, which contains a B-I-O style phrase \r\n            tag for each word in the sentence ('B'-begins phrase, 'I'-\r\n            inside phrase, or ''-not in phrase);\r\n        '''\r\n        NPattribPos = [ 'Y', 'S', 'A', 'C', 'G', 'H', 'N', 'O', 'K', 'D', 'P' ]\r\n        NPheadPos   = [ 'S', 'Y', 'H' ]\r\n        NPlabels = [ '' for i in range(len(sentence)) ]\r\n        #\r\n        # 0 Faas: M2rgistame k6ik s6nad, mis v6iksid olla nimis6nafraasi peas6nad, nt:\r\n        #        Kas [venelaste] [ambitsioon] on [siiras] ?\r\n        #        [Raskused] algasid [aastal] 2009 , mil oli [majanduskriis] .\r\n        #        [P\u00f5llumaad] on ka , aga [kartulikasvatamisega] on \u00fcksjagu [jamamist] .\r\n        #\r\n        for i in range(len(sentence)):\r\n            pos1 = self._getPOS(sentence[i])\r\n            if pos1 in NPheadPos:\r\n                NPlabels[i] = 'B'\r\n            # Lisaks m\u00e4rgistame ka peas\u00f5nadena ka \u00fcksikud pronoomenid, kuigi \r\n            # eeldame, et need on peas\u00f5nadena vaid \u00fcksikutes fraasides;\r\n            elif pos1 == 'P':\r\n                NPlabels[i] = 'B'\r\n        #\r\n        # I Faas: liidame yheks nimis6nafraasiks k6ik k6rvutiseisvad nimis6nafraasi\r\n        #     sobivad s6nad, kui esimene on j\u00e4rgmise vahetu alluv, nt:\r\n        #        [Venemaa otsus] alustada S\u00fc\u00fcrias \u00f5hur\u00fcnnakuid ...\r\n        #        Kas [venelaste ambitsioon] on siiras ?\r\n        #        [J\u00e4rgmine hoop] tuli 2012-2013 ...\r\n        #        [Eelmise n\u00e4dala reedel] , [19. septembril] leidsid [kolleegid] ...\r\n        #        \r\n        for i in range(len(sentence)):\r\n            label1  = i\r\n            parent1 = syntax_layer[i][PARSER_OUT][0][1]\r\n            #label1  = sentence[i][SYNTAX_LABEL]\r\n            #parent1 = sentence[i][SYNTAX_HEAD]\r\n            if i+1 < len(sentence):\r\n                label2  = i+1\r\n                parent2 = syntax_layer[i+1][PARSER_OUT][0][1]\r\n                #label2  = sentence[i+1][SYNTAX_LABEL]\r\n                #parent2 = sentence[i+1][SYNTAX_HEAD]\r\n                pos1 = self._getPOS(sentence[i])\r\n                pos2 = self._getPOS(sentence[i+1])\r\n                if int(parent1) == int(label2) and pos1 in NPattribPos and \\\r\n                   pos2 in NPheadPos:\r\n                    if 'K' in pos1 and NPlabels[i] == '':\r\n                        #\r\n                        #   1) erandjuht: \r\n                        #    K fraasi alguses viitab peaaegu alati mingile jamale, \r\n                        #    seega katkestame, et v\u00e4ltida selliseid asju nagu:\r\n                        #      ... , mille [kohta Eestiski] piisavalt n\u00e4iteid .\r\n                        #      ... l\u00e4hedaste majandussidemete [t\u00f5ttu Brasiiliaga] .\r\n                        #      ... kultuuri allutamise [vastu rahav\u00f5imule] , vaid t\u00f6\u00f6tavad\r\n                        # \r\n                        pass\r\n                    elif 'D' in pos1 and not self._AdvStartingPhrase.matches(sentence[i]):\r\n                        #\r\n                        #   2) erandjuht: \r\n                        #   Lubame ainult teatud adverbe fraasi algusesse, et v\u00e4ltida selliseid\r\n                        #   juhte nagu nt:\r\n                        #      ... said s\u00f5na [ka lapsed] , aga kingitust\r\n                        #      ... k\u00e4ttesaamatuks [nii Nehatu hamburgeriputka] ,\r\n                        #      ... osta [ka hinnaga 1 kr] \r\n                        #      ... ette [just Los Angelese auton\u00e4itusel] ,\r\n                        \r\n                        #   TODO: M6nikord me ikkagi tahame, et D ka sees oleks, nt:\r\n                        #      ... filmis \" Tagasi [tulevikku] \" ...\r\n                        pass\r\n                    else:\r\n                        if NPlabels[i] == '':\r\n                            NPlabels[i] = 'B'\r\n                        NPlabels[i+1] = 'I'\r\n        #\r\n        # II Faas: Koondame k\u00f5rvutipaiknevad ja \u00fcksteisega alluvussuhtes olevad arvs\u00f5nad/numbrid \r\n        #     \u00fcheks arvudest koosnevaks \"NP-fraasiks\", nt:\r\n        #       [Sada nelik\u00fcmmend viis]\r\n        #       [10 405 miljonit]\r\n        #       [kaheksa miljardit]\r\n        #     \r\n        for i in range(len(sentence)):\r\n            label1  = i\r\n            parent1 = syntax_layer[i][PARSER_OUT][0][1]\r\n            #label1  = sentence[i][SYNTAX_LABEL]\r\n            #parent1 = sentence[i][SYNTAX_HEAD]\r\n            pos1 = self._getPOS(sentence[i])\r\n            if pos1 in ['N', 'O']  and  i+1 < len(sentence):\r\n                label2  = i+1\r\n                parent2 = syntax_layer[i+1][PARSER_OUT][0][1]\r\n                #label2  = sentence[i+1][SYNTAX_LABEL]\r\n                #parent2 = sentence[i+1][SYNTAX_HEAD]\r\n                pos2 = self._getPOS(sentence[i+1])\r\n                if pos2 in ['N', 'O'] and ( int(parent2) == int(label1) or \\\r\n                   int(parent1) == int(label2) ):\r\n                    if NPlabels[i] == '':\r\n                        NPlabels[i] = 'B'\r\n                    NPlabels[i+1] = 'I'\r\n        #\r\n        # III Faas: Kleebime otsa NP-fraaside otsa j\u00e4relt\u00e4ienditena esinevad numbrilised \r\n        #     arvud, nt:\r\n        #        \u00dcritus kandis nime [Rahu Missioon 2007.]\r\n        #        Allkirjastas [1. jaanuaril 2004.]\r\n        #        Saabus [uus Peugeot 307] , millest [aastatel 1987-1997] ei osatud unistadagi .\r\n        #        [Perioodil 1997-2001] oli neid rohkem , [vt tabel 1.]\r\n        #\r\n        for i in range(len(sentence)):\r\n            label1  = i\r\n            parent1 = syntax_layer[i][PARSER_OUT][0][1]\r\n            #label1  = sentence[i][SYNTAX_LABEL]\r\n            #parent1 = sentence[i][SYNTAX_HEAD]\r\n            pos1 = self._getPOS(sentence[i])\r\n            if pos1 in ['N', 'O']  and  i-1 > -1:\r\n                label2  = i-1\r\n                parent2 = syntax_layer[i-1][PARSER_OUT][0][1]\r\n                #label2  = sentence[i-1][SYNTAX_LABEL]\r\n                #parent2 = sentence[i-1][SYNTAX_HEAD]\r\n                if int(parent1) == int(label2) and NPlabels[i-1] != '':\r\n                    NPlabels[i] = 'I'\r\n        #\r\n        # IV Faas: Kleebime arvufraaside(hulgafraaside) otsa j\u00e4relt\u00e4ienditena esinevad \r\n        #     nimis\u00f5nad, nt:\r\n        #        Meri laius [100 kilomeetri] pikkusena .\r\n        #        Aasta alguseks oli mahust j\u00e4rel [30-40 protsenti] .\r\n        #        Jah , [k\u00fcmne aasta] tagusega ei maksa siin \u00fcldse v\u00f5rrelda .\r\n        #        Mees n\u00f5udis [10 miljonit dollarit] kahjutasu [10-15 cm] kaugusele .\r\n        #        Eelmisel n\u00e4dalal v\u00f5ttis endalt elu veel [kaks politseiametnikku] .\r\n        #        Kujutlesin [kaheksa miljonit aastat] vana k\u00fcpressimetsa [mituk\u00fcmmend aastat] nooremana .\r\n        #\r\n        for i in range(len(sentence)):\r\n            label1  = i\r\n            parent1 = syntax_layer[i][PARSER_OUT][0][1]\r\n            #label1  = sentence[i][SYNTAX_LABEL]\r\n            #parent1 = sentence[i][SYNTAX_HEAD]\r\n            pos1 = self._getPOS(sentence[i])\r\n            if pos1 in ['N', 'O']  and  i+1 < len(sentence):\r\n                label2  = i+1\r\n                parent2 = syntax_layer[i+1][PARSER_OUT][0][1]\r\n                #label2  = sentence[i+1][SYNTAX_LABEL]\r\n                #parent2 = sentence[i+1][SYNTAX_HEAD]\r\n                pos2    = self._getPOS(sentence[i+1])\r\n                if int(parent2) == int(label1) and NPlabels[i+1] != '' and pos2 != 'P':\r\n                    if NPlabels[i]=='':\r\n                        NPlabels[i] = 'B'\r\n                    NPlabels[i+1] = 'I'\r\n        # \r\n        # V Faas: Kui NP-fraasi l6pus on arvu/numbrifraas ( N_Y voi N_S ), siis t6stame arvufraasi\r\n        #         lahku, isegi kui see teatud m22ral l6huks NP-fraasi, nt \r\n        #               [pindala 48 ha]            ==> [pindala] [48 ha]\r\n        #               [J\u00e4rvamaal 36 283 inimest] ==> [J\u00e4rvamaal] [36 283 inimest]\r\n        #               [kasahhid 3 %]             ==> [kasahhid] [3 %]\r\n        #               [Tallinna Lihat\u00f6\u00f6stuse aktsiatest 80 protsenti] ==>\r\n        #                      [Tallinna Lihat\u00f6\u00f6stuse aktsiatest] [80 protsenti]\r\n        #\r\n        for i in range( len(sentence) ):\r\n            if NPlabels[i] == 'B':\r\n                phrase, indices = self._getPhrase( i, sentence, NPlabels )\r\n                posTags = [ self._getPOS(tok) for tok in phrase ]\r\n                if len(phrase)>2 and posTags[-1] in ['S','Y'] and posTags[-2]=='N' and \\\r\n                   posTags[0] not in ['N', 'O']:\r\n                    #\r\n                    # Lisakontroll: tegu ei tohiks olla aastarvuga, nt:\r\n                    #    [Eesti Tervishoiuprojekt] [2015 Lisaks]\r\n                    #    [Prantsusmaa loobumine EXPO] [2004 korraldamisest]\r\n                    # \r\n                    yearCheck = re.match('.*\\d\\d\\d\\d.*', phrase[-2][TEXT])\r\n                    #\r\n                    # Lisakontroll: kui eelneb rohkem kui yks arv, siis tuleb \r\n                    #    poolitamispunkti nihutada, nt:\r\n                    #       [Viinis 170] [000 USA dollari]\r\n                    #       [J\u00e4rvamaal 36] [283 inimest]\r\n                    #\r\n                    breakPoint = indices[-2]\r\n                    j = -3\r\n                    while posTags[j] == 'N':\r\n                        breakPoint = indices[j]\r\n                        j -= 1\r\n                    if not yearCheck:\r\n                        NPlabels[breakPoint] = 'B'\r\n\r\n        # \r\n        # VI Faas: Kui NP-fraasi sobiva s6na vanem on +2 v6i rohkema s6na kaugusel s6na j2rel, \r\n        #          siis pole s6na veel fraasi arvatud;\r\n        #          Arvame ta fraasi j2rgmistel juhtudel:\r\n        #            Eelnev j2rgarv, nt:\r\n        #                ... p\u00fchendus meenutab [teisigi] [P\u00f5hjala suurmehi] , nagu ...\r\n        #                ... enamikus j\u00e4id [esimese] [Eesti Vabariigi aegadesse] ...\r\n        #            Eelnev omaduss6na, nt:\r\n        #                ... makett \u00fchest [olulisest] [j\u00f5e\u00e4\u00e4rsest t\u00e4navast] sellisena ,\r\n        #                ... soojendades ja [suures] soojaks [k\u00f6etud telgis] kuuma teed ...\r\n        #\r\n        for i in range(len(sentence)-1, -1, -1):\r\n            label1  = i\r\n            parent1 = syntax_layer[i][PARSER_OUT][0][1]\r\n            #label1  = sentence[i][SYNTAX_LABEL]\r\n            #parent1 = sentence[i][SYNTAX_HEAD]\r\n            pos1 = self._getPOS(sentence[i])\r\n            parentRelativeLoc = int(parent1) - int(label1)\r\n            if pos1 in NPattribPos and NPlabels[i]=='' and parentRelativeLoc > 1 and \\\r\n               i+parentRelativeLoc < len(sentence):\r\n                label2  = i+parentRelativeLoc\r\n                parent2 = syntax_layer[i+parentRelativeLoc][PARSER_OUT][0][1]\r\n                #label2  = sentence[i+parentRelativeLoc][SYNTAX_LABEL]\r\n                #parent2 = sentence[i+parentRelativeLoc][SYNTAX_HEAD]\r\n                if int(parent1) == int(label2) and NPlabels[i+parentRelativeLoc] != '':\r\n                    #\r\n                    #   Kogume kokku k6ik kahe s6na vahele j22vad token'id:\r\n                    #  \r\n                    interveningTokens   = []\r\n                    interveningTokenIDs = []\r\n                    j = i + 1\r\n                    while ( j < i + parentRelativeLoc ):\r\n                        interveningTokens.append( sentence[j] )\r\n                        interveningTokenIDs.append( j )\r\n                        j += 1\r\n                    #\r\n                    #   Eemaldame neist tokenid, mis juba kuuluvad fraasi:\r\n                    #\r\n                    if NPlabels[i+parentRelativeLoc] == 'I':\r\n                        while ( len(interveningTokenIDs) > 0 ):\r\n                            lastID = interveningTokenIDs.pop()\r\n                            lastToken = interveningTokens.pop()\r\n                            if NPlabels[lastID] == 'B':\r\n                                # Kui j6udsime fraasi alguseni, siis l6petame\r\n                                break\r\n                    \r\n                    #\r\n                    #    Kontroll1: s6na ja j2rgneva s6na vahele ei tohi j22da \r\n                    #     punktuatsiooni ega sidendeid, kuna need j2tame alati \r\n                    #     fraasist v2lja;\r\n                    #\r\n                    punctIntervening = False\r\n                    jaNingEgaVoi     = False\r\n                    for interToken in interveningTokens:\r\n                        if self._punctPos.matches( interToken ):\r\n                            punctIntervening = True\r\n                        if self._jaNingEgaVoi.matches( interToken ):\r\n                            jaNingEgaVoi = True\r\n\r\n                    #\r\n                    #   Leiame s6na ja tema ylema vahelise k22ndeyhilduvuse;\r\n                    #\r\n                    caseAgreement = \\\r\n                        self._getCaseAgreement(sentence[i], sentence[i+parentRelativeLoc])\r\n\r\n                    if pos1 == 'O' and not punctIntervening and not jaNingEgaVoi and \\\r\n                       caseAgreement != None:\r\n                        if len(interveningTokenIDs) == 0:\r\n                            #\r\n                            #    VI.a.  Eelnev s6na on k22ndes yhilduv j2rgarv, nt:\r\n                            #      ... nagu ka teised [Eesti pered] , iga ...\r\n                            #        ... mil esimene [T\u0161et\u0161eenia s\u00f5da] k\u00e4is t\u00e4ie ...\r\n                            #        ... ka m\u00f5nedel teistel [mineraalsetel k\u00fctetel] peale autobensiini ...\r\n                            #        ... on p\u00e4rit kolmandast [Moosese raamatust] ehk leviitide ...\r\n                            #\r\n                            NPlabels[i]   = 'B'\r\n                            NPlabels[i+1] = 'I'\r\n                        else:\r\n                            #\r\n                            #    VI.b.  Eelnev s6na on k22ndes yhilduv j2rgarv, ning vahele j22vad\r\n                            #           ainult k22ndes yhilduvad s6nad, nt:\r\n                            #        ... Teised s\u00f5javastased [Euroopa riigid] ilmselt avaldavad ...\r\n                            #        ... t\u00f5i \u00e4ra esimesed pesuehtsad [punased v\u00e4rsid] . ...\r\n                            #        ... Esimene \u00fcleriigiline [automatiseeritud haiguseregister] - v\u00e4hiregister ...\r\n                            #\r\n                            agreements = [self._getCaseAgreement(interTok, sentence[i+parentRelativeLoc]) for interTok in interveningTokens]\r\n                            if all(agreements):\r\n                                NPlabels[i] = 'B'\r\n                                j = i + 1\r\n                                while ( j <= i + parentRelativeLoc ):\r\n                                    NPlabels[j] = 'I'\r\n                                    j += 1\r\n\r\n                    if pos1 in ['A','G'] and not punctIntervening and not jaNingEgaVoi and \\\r\n                       caseAgreement != None:\r\n                        # \r\n                        #   Lisakontroll 1:\r\n                        #      J\u00e4tame algusesse lisamata kesks\u00f5nadena esinevad s\u00f5nad, kuna \r\n                        #      nende puhul on t\u00f5en\u00e4oliselt tegemist millegi keerukamaga (nn\r\n                        #      lausel\u00fchendiga):\r\n                        #        ... Pingilt sekkunud [Chris Anstey] viskas ...\r\n                        #        ... NBA meistriks t\u00fc\u00fcrinud [Phil Jackson] ...\r\n                        #        ... kaasaegsele maailmale mittevastav [teoreetiline l\u00e4henemine] ...\r\n                        #\r\n                        isVerbParticle = self._verbParticle.matches(sentence[i])\r\n                        #\r\n                        #  Lisakontroll 2:\r\n                        #      Kui omaduss6na ja fraasi vahele j22b ka teisi s6nu, teeme \r\n                        #      kindlaks, et need s6nad poleks s6naliikidest V, D, J, mis\r\n                        #      on probleemsed, nt:\r\n                        #       D : ...  skreipi nii [p\u00e4rilik] kui ka [nakkav haigus]  ...\r\n                        #       V : ...  2002. aasta [keskmine] purunenud [terade saak]  ...\r\n                        #       J : ...  oleks maakondadele [sobilik] kuni [14-r\u00fchmaline loend] Eesti  ...\r\n                        #\r\n                        interveningProblematicPOS = False\r\n                        if len(interveningTokenIDs) > 0:\r\n                            iPosTags = [ a[POSTAG] for t1 in interveningTokens for a in t1[ANALYSIS] ]\r\n                            interveningProblematicPOS = \\\r\n                              'V' in iPosTags or 'D' in iPosTags or 'J' in iPosTags or 'Z' in iPosTags\r\n                        if not isVerbParticle and len(interveningTokenIDs) == 0:\r\n                            #\r\n                            #    VI.c.  Eelnev s6na on k22ndes yhilduv ja vahetult eelnev \r\n                            #           omaduss6na (v.a. kesks6na), nt:\r\n                            #           ... peeti pidu karmi [vene korra] ajal ning ...\r\n                            #           ... \u00e4ravajunud , arhailisest [Suurbritannia nurgast] ...\r\n                            #           ... , v\u00f5imaldades uutel [vapratel riikidel] kahel pool ...\r\n                            #\r\n                            NPlabels[i]   = 'B'\r\n                            NPlabels[i+1] = 'I'\r\n                        elif not isVerbParticle and len(interveningTokenIDs) > 0 and \\\r\n                            not interveningProblematicPOS:\r\n                            #\r\n                            #    VI.d.  Eelnev s6na on k22ndes yhilduv omaduss6na (v.a. kesks6na) \r\n                            #           ning vahele j22b veel v2hemalt yks sobiva POS tag'iga\r\n                            #           s6na, nt:\r\n                            #           ... korral on [tavaline] tugev [p\u00e4evane unisus] , ...\r\n                            #           ... m\u00f5jus silmadele [vana] mustvalge pisike [ekraan] ...\r\n                            #           ... on enesekindel [valgete] higiste [k\u00e4tega intelligent] ...\r\n                            #\r\n                            NPlabels[i] = 'B'\r\n                            j = i + 1\r\n                            while ( j <= i + parentRelativeLoc ):\r\n                                NPlabels[j] = 'I'\r\n                                j += 1\r\n                                \r\n                    if pos1 in ['C'] and not punctIntervening and not jaNingEgaVoi and \\\r\n                       caseAgreement != None:\r\n                        if i - 1 > -1  and  self._k6ige.matches( sentence[i - 1] ):\r\n                            #\r\n                            #    VI.e.  Eelnev s6na on k22ndes yhilduv keskv6rde omaduss6na, \r\n                            #           millele eelneb yliv6rde tunnus 'k6ige', nt:\r\n                            #           ... juhib perekonda k\u00f5ige noorem [t\u00e4iskasvanud naine] . ...\r\n                            #           ... K\u00f5ige suurem [akustiline erinevus] oli vokaalide ...\r\n                            #           ... on k\u00f5ige levinumad [antikolinergilised ravimid] ...\r\n                            #\r\n                            NPlabels[i-1] = 'B'\r\n                            j = i\r\n                            while ( j <= i + parentRelativeLoc ):\r\n                                NPlabels[j] = 'I'\r\n                                j += 1\r\n                        elif re.match('^(pl\\s.+|sg\\s(ab|abl|ad|all|el|es|ill|in|kom|ter|tr))$', \\\r\n                             caseAgreement):\r\n                            #\r\n                            #    VI.f.  Eelnev s6na on k22ndes yhilduv keskv6rde omaduss6na, \r\n                            #           mis on kas mitmuses v6i yhildub semantilise k22ndega, nt:\r\n                            #           ... olnud \u00fcks aktiivsemaid [NATO rahupartnereid] . ...\r\n                            #           ... meestel lisandub halvemale [f\u00fc\u00fcsilisele tervisele] veel ...\r\n                            #           ... Varasemates [samalaadsetes uurimustes] on laste ...\r\n                            #          (grammatilise ainsusek22nde puhul ei pruugi nii kindel\r\n                            #           olla, et kuulub just nimis6nafraasi juurde: v6ib kuuluda\r\n                            #           ka (olema) verbifraasi juurde)\r\n                            #\r\n                            NPlabels[i] = 'B'\r\n                            j = i + 1\r\n                            while ( j <= i + parentRelativeLoc ):\r\n                                NPlabels[j] = 'I'\r\n                                j += 1\r\n                            \r\n                            #ex = self.__debug_extract_NP_from_pos(sentence, NPlabels, i-1, i+parentRelativeLoc)\r\n                            #try:\r\n                            #    print(sentence[i][TEXT]+' | '+sentence[i+parentRelativeLoc][TEXT]+' | '+pos1+\" | \"+ex)\r\n                            #except:\r\n                            #    print(' ### Err ###')\r\n                       \r\n\r\n\r\n        #\r\n        #   Viimane faas: rakendame nn j2relparandusi, proovime pahna v2lja visata ...\r\n        #\r\n        self._apply_post_fixes( sentence, NPlabels, cutPhrases, cutMaxThreshold )\r\n        return NPlabels", "response": "Find NP phrases in the sentence."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a new instance of MimeType with the necessary post fixes applied to the given sentence.", "response": "def _apply_post_fixes( self, sentence, NPlabels, cutPhrases, cutMaxThreshold ):\r\n        '''  Fraasituvastaja j2relparandused:\r\n            *) Tekstis6renduste eemaldamine (s6rendatud tekst ei pruugi olla \r\n                fraas, v6ib olla nt terve lause);\r\n            *) Problemaatiliste kesks6nade eemaldamine fraasialgusest;\r\n            *) Ainult arvs6nadest koosnevate fraaside eemaldamine;\r\n            *) ...\r\n            *) B/I m2rkide parandus;\r\n            *) Fraaside l6ikamine sobivasse pikkusse (kui cutPhrases==True ja\r\n               cutMaxThreshold on seadistatud);\r\n        '''\r\n        for i in range( len(sentence) ):\r\n            if NPlabels[i] == 'B':\r\n                phrase, indices = self._getPhrase( i, sentence, NPlabels )\r\n                posTags = [ self._getPOS(tok) for tok in phrase ]\r\n                #\r\n                #   1) Eemaldame tekstis6rendused, mis kogemata kombel on loetud\r\n                #      eraldi s6nadeks ja s6nade liitmise abil saadud fraasid, nt:\r\n                #       et [\u00f5 i g e k e e l s u s r a a m a t u i s] sisaldub\r\n                #       , [k u s v \u00f5 i m i l l a l] ma\r\n                #\r\n                if len(posTags) > 1 and len( set(posTags).difference(set(['Y'])) )==0:\r\n                    # Kustutame fraasi\r\n                    for k in indices:\r\n                        NPlabels[k] = ''\r\n                if len(posTags) > 1 and posTags[0] == 'A':\r\n                    forms = [ a[FORM] for a in phrase[0][ANALYSIS] ]\r\n                    if 'nud' in forms or 'tud' in forms or 'dud' in forms:\r\n                        #\r\n                        #   2) Eemaldame nud/tud fraasi algusest, kui nud/tud \r\n                        #      moodustavad toenaolisel liitoeldise, nt:\r\n                        #           t\u00e4pselt on [j\u00e4lgitud seadust] .\r\n                        #           T\u00f6\u00f6tud on [kutsunud protestiga] liituma ka t\u00f6\u00f6lisi\r\n                        #           ise ei [saanud naeru] pidama . \"\r\n                        #\r\n                        if i - 1  >  -1 and ( \\\r\n                           self._verbEi.matches(sentence[i-1]) or \\\r\n                           self._verbOle.matches(sentence[i-1]) ):\r\n                           NPlabels[i] = ''\r\n                           #print(self.__debug_extract_NP_from_pos(sentence, NPlabels, i))\r\n                if len(phrase) > 1 and set(posTags).issubset(set(['O', 'N'])):\r\n                    #\r\n                    #   3) Eemaldame vaid arvs6nadest koosnevad fraasid, nt:\r\n                    #           , vaid [800 miljonit] .\r\n                    #           p\u00f5hjustel umbes [100 000.] \r\n                    #           kolmandat ja [kolmas neljandat] .\r\n                    #           \u00fcleeuroopalisel konkursil [esimese kolme] hulka .\r\n                    #           1990. aastate [teisel poolel] .\r\n                    #           v\u00f5itis k\u00fcll [esimese veerandi 31] : 13 ,\r\n                    #\r\n                    for k in indices:\r\n                        NPlabels[k] = ''\r\n                if posTags.count( 'N' ) > 7:\r\n                    #\r\n                    #   4) Eemaldame ylipikaks veninud numbrifraasid (kuna on kahtlus,\r\n                    #      et sellisel juhul pole tegu mitte numbrifraasiga, vaid\r\n                    #      mingi loetelu/tabeli vms-ga), nt:\r\n                    #         Vaip , [1 1 1 1 1 0 1 1 1 1 Vaip] [ : 2\r\n                    #         [1 0 0 0 0 1 1 1 1 B] \u00dches Eesti ettev\u00f5ttes\r\n                    #  \r\n                    for k in range( len(indices) ):\r\n                        ind = indices[k]\r\n                        pos = posTags[k]\r\n                        if pos == 'N' and ( k==0 or (k>0 and NPlabels[ind-1]=='') ):\r\n                            NPlabels[ind] = ''\r\n                        elif ( k > 0 and NPlabels[ind-1] == '' ):\r\n                            NPlabels[ind] = 'B'\r\n                        elif ( k > 0 and NPlabels[ind-1] != '' ):\r\n                            NPlabels[ind] = 'I'\r\n\r\n                #  Kontrollime, kas fraasis eelneb suurt2helisele s6nale \r\n                #    mineviku kesks6na, mis pole suurt2heline;                \r\n                verbPartFollowedByTitle = -1\r\n                for j in range( len(phrase) ):\r\n                    if self._verbPastParticle.matches( phrase[j] ) and \\\r\n                       not phrase[j][TEXT].istitle() and \\\r\n                       j+1 < len(phrase) and \\\r\n                       phrase[j+1][TEXT].istitle():\r\n                        verbPartFollowedByTitle = j\r\n                if verbPartFollowedByTitle == 0:\r\n                    #   \r\n                    #  5) P2risnimele eelneva kesks6na kustutamine:\r\n                    #     P2risnimele eelnev kesks6na on sageli probleemne, st v6ib olla:\r\n                    #           a) seotud eelneva verbiga, nt:\r\n                    #               ... Hiibus ei [j\u00e4tnud Elviiret] kiitmata ...\r\n                    #              ... on isa-ema kodu [vahetanud Kohila] vastu ...\r\n                    #              ... on aastaid [olnud Valgem\u00e4e perenaine] ...\r\n                    #           b) olla osa keerukamast nimis6nafraasist (lauselyhendist), nt:\r\n                    #              ... revolutsiooni ellu [viinud Reagan] oli ametist lahkudes ...\r\n                    #              ... ol\u00fcmpiam\u00e4ngude A-normi [t\u00e4itnud Uusorg] ...\r\n                    #      Seet6ttu kustutame teatud tingimustel eelneva kesks6na maha;\r\n                    #\r\n                    NPlabels[indices[verbPartFollowedByTitle]]   = ''\r\n                    NPlabels[indices[verbPartFollowedByTitle]+1] = 'B'\r\n\r\n                if posTags[0] == 'C' and i + 1 > -1 and NPlabels[i-1] == '':\r\n                    #   \r\n                    #  6) Puuduva 'k\u00f5ige' lisamine fraasile, mille alguses on C, nt:\r\n                    #      ... K\u00f5ige [selgemal p\u00e4eval] l\u00e4ksin ma taas ...\r\n                    #      ... Ka k\u00f5ige [avarama ruumiihalusega eurooplane] talub Hiinas ...  \r\n                    #      ... K\u00f5ige [n\u00f5rgema toimega] olid harilik puju ...\r\n                    #\r\n                    if self._k6ige.matches( sentence[i-1] ):\r\n                        NPlabels[i-1] = 'B'\r\n                        NPlabels[i]   = 'I'\r\n                if posTags[0] == 'C' and len( posTags ) == 2 and posTags[1] == 'H' and \\\r\n                   NPlabels[i] == 'B':\r\n                    #\r\n                    #  7) Empiiriline t\u00e4helepanek - kui p\u00e4risnime ees on komparatiiv-\r\n                    #     omaduss\u00f5na, siis enamasti on tegu katkise fraasiga, nt:\r\n                    #       ... n\u00e4htavas tulevikus [t\u00e4htsam Balkanitel] toimuv kui ...\r\n                    #       ... oma eluasemekuludeks [varasema Tallinnas] kehtinud ...\r\n                    #       ... 30 kraadi [paremal Jedinstvost] ( \u00dchtsusest ) ...\r\n                    #     Seet\u00f5ttu eemaldame fraasist C;\r\n                    #\r\n                    NPlabels[i]   = ''\r\n                    NPlabels[i+1] = 'B'\r\n\r\n        # X) Kui kogemata on sattunud m6ni iseseisev 'I' (ilma eelneva 'I' v6i 'B'-ta),\r\n        #    muudame selle 'B'-ks\r\n        for i in range( len(sentence) ):\r\n            if NPlabels[i] == 'I':\r\n                if i == 0 or (i-1>-1 and NPlabels[i-1] not in ['I','B']):\r\n                    NPlabels[i] = 'B'\r\n\r\n        #\r\n        # Y) Kui on n6utud fraaside l6ikamine pikkuse j2rgi (j2tta alles vaid fraasid\r\n        #    pikkusega N), l6ikame pikkust N yletavad fraasid juppideks nii, et alles\r\n        #    j22vad vaid fraasi peas6naks sobivad s6nad;\r\n        #\r\n        if cutPhrases and cutMaxThreshold > 0:\r\n            NPheadPos = [ 'S', 'Y', 'H' ]\r\n            for i in range( len(sentence) ):\r\n                if NPlabels[i] == 'B':\r\n                    phrase, indices = self._getPhrase( i, sentence, NPlabels )\r\n                    posTags = [ self._getPOS(tok) for tok in phrase ]\r\n                    if len(phrase) > cutMaxThreshold:\r\n                        for j in range(len(phrase)):\r\n                            posTag = posTags[j]\r\n                            if posTag in NPheadPos:\r\n                                # J2tame alles vaid nimis6nafraasi peas6nadeks\r\n                                # sobivad s6nad, yksikute s6nadena;\r\n                                NPlabels[indices[j]] = 'B'\r\n                            else:\r\n                                # Kui s6na ei sobi peas6naks, kustutame sellelt\r\n                                # yldse m2rgenduse;\r\n                                NPlabels[indices[j]] = ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of phrases that are in common list of words.", "response": "def get_phrases(self, text, np_labels):\r\n        ''' Given a Text and a BIO labels (one label for each word in Text) , \r\n            extracts phrases and returns as a list of phrases, where each phrase \r\n            is a list of word tokens belonging to the phrase;\r\n            \r\n            Parameters\r\n            ----------\r\n            text:  estnltk.text.Text\r\n                The input Text, or a list consecutive words (dict objects).\r\n                The method attempts to automatically determine the type of \r\n                the input;\r\n                \r\n            np_labels : list of str\r\n                A list of strings, containing a B-I-O label for each word in \r\n                *text*;\r\n                \r\n            Returns\r\n            -------\r\n            list of (list of tokens)\r\n                List of phrases, where each phrase is a list of word tokens \r\n                belonging to the phrase;\r\n        '''\r\n        # 1) Take different inputs to common list of words format:\r\n        input_words = []\r\n        if isinstance(text, Text):\r\n            # input is Text\r\n            input_words = text.words\r\n        elif isinstance(text, list) and len(text)>0 and isinstance(text[0], dict) and \\\r\n             TEXT in text[0]:\r\n            # input is a list of words\r\n            input_words = text\r\n        elif text:\r\n            raise Exception('Unexpected input text:', text)\r\n        if len(input_words) != len(np_labels):\r\n            raise Exception(' (!) Number of words ('+str(len(input_words))+\\\r\n                            ') does not match number of labels '+str(len(np_labels)))\r\n\r\n        # 2) Extract phrases from input words:\r\n        phrases = []\r\n        for i, word in enumerate(input_words):\r\n            label = np_labels[i]\r\n            if label == 'B':\r\n                phrases.append([])\r\n            if label in ['B', 'I']:\r\n                phrases[-1].append( word )\r\n        return phrases"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a Text and a list of text annotations in the same B - I - O format returns a list of phrase texts.", "response": "def get_phrase_texts(self, text, np_labels):\r\n        ''' Given a Text, and a list describing text annotations in the \r\n            B-I-O format (*np_label*), extracts phrases and returns as a\r\n            list of phrase texts;\r\n            \r\n            Assumes that the input is same as the input acceptable for \r\n            the method NounPhraseChunker.get_phrases();\r\n            \r\n            Returns\r\n            -------\r\n            list of string\r\n                Returns a list of phrase texts;\r\n        '''\r\n        phrases = self.get_phrases(text, np_labels)\r\n        texts = []\r\n        for phrase in phrases:\r\n            phrase_str = ' '.join([word[TEXT] for word in phrase])\r\n            texts.append( phrase_str )\r\n        return texts"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef annotateText(self, text, layer, np_labels = None):\r\n        ''' Applies this chunker on given Text, and adds results of \r\n            the chunking as a new annotation layer to the text.\r\n            If the NP annotations are provided (via the input list \r\n            *np_labels*), uses the given NP annotations, otherwise \r\n            produces new NP_LABEL annotations via the method \r\n            self.analyze_text();\r\n            \r\n            Parameters\r\n            ----------\r\n            text:  estnltk.text.Text\r\n                The input text where the new layer of NP chunking \r\n                annotations is to be added;\r\n            layer: str\r\n                Name of the new layer;\r\n            np_labels : list of str\r\n                Optional: A list of strings, containing a B-I-O label \r\n                for each word in *text*; If provided, uses annotations\r\n                from *np_labels*, otherwise creates new annotations \r\n                with this chunker;\r\n                \r\n            Returns\r\n            -------\r\n            text\r\n                The input text where a new layer (containing NP \r\n                annotations) has been added;\r\n        ''' \r\n        input_words = None\r\n        if isinstance(text, Text):\r\n            # input is Text\r\n            input_words = text.words\r\n        else:\r\n            raise Exception(' Input text should be of type Text, but it is ', text)\r\n        phrases = []\r\n        #  If NP_LABEL-s are not provided, text needs to be analyzed first:\r\n        if not np_labels:\r\n            np_labels = self.analyze_text( text, return_type=\"labels\" )\r\n        if len(input_words) != len(np_labels):\r\n            raise Exception(' (!) Number of words ('+str(len(input_words))+\\\r\n                            ') does not match number of labels '+str(len(np_labels)))\r\n        #  Fetch NP chunks\r\n        phrases = self.get_phrases( text, np_labels )\r\n        # Create and attach annotations to the Text object\r\n        annotations = []\r\n        if phrases:\r\n            for phrase in phrases: \r\n                phrase_annotation = {}\r\n                phrase_annotation[START] = phrase[0][START]\r\n                phrase_annotation[END]   = phrase[-1][END]\r\n                phrase_annotation[TEXT]  = ' '.join([word[TEXT] for word in phrase ])\r\n                annotations.append( phrase_annotation )\r\n        text[layer] = annotations\r\n        return text", "response": "Applies this chunker on given Text and adds results of this chunker as a new annotation layer to the text."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndivides lists elements and by.", "response": "def divide(elements, by, translate=False, sep=' '):\n    \"\"\"Divide lists `elements` and `by`.\n    All elements are grouped into N bins, where N denotes the elements in `by` list.\n\n    Parameters\n    ----------\n    elements: list of dict\n        Elements to be grouped into bins.\n    by: list of dict\n        Elements defining the bins.\n    translate: bool (default: False)\n        When dividing, also translate start and end positions of elements.\n    sep: str (default ' ')\n        In case of multispans, what is the default text separator.\n        This is required in order to tag correct start, end positions of elements.\n    \"\"\"\n    outer_spans = [spans(elem) for elem in by]\n    return divide_by_spans(elements, outer_spans, translate=translate, sep=sep)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dropSpans(spans, text):\n    spans.sort()\n    res = ''\n    offset = 0\n    for s, e in  spans:\n        if offset <= s:         # handle nesting\n            if offset < s:\n                res += text[offset:s]\n            offset = e\n    res += text[offset:]\n    return res", "response": "Drop from text the blocks identified in spans."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncleans the text into a single object.", "response": "def clean(text):\n    \"\"\"\n    Transforms wiki markup.\n    @see https://www.mediawiki.org/wiki/Help:Formatting\n    \"\"\"\n\n\n\n    text = bold_italic.sub(r'\\1', text)\n    text = bold.sub(r'\\1', text)\n    text = italic_quote.sub(r'\"\\1\"', text)\n    text = italic.sub(r'\"\\1\"', text)\n    text = quote_quote.sub(r'\"\\1\"', text)\n    # residuals of unbalanced quotes\n    text = text.replace(\"'''\", '').replace(\"''\", '\"')\n    text = newlines.sub(r'\\n', text)\n    text = bulletlist.sub(r'', text)\n\n    # Collect spans\n\n    spans = []\n    # Drop HTML comments\n    for m in comment.finditer(text):\n            spans.append((m.start(), m.end()))\n\n    # Drop self-closing tags\n    for pattern in selfClosing_tag_patterns:\n        for m in pattern.finditer(text):\n            spans.append((m.start(), m.end()))\n\n    # Drop ignored tags\n    for left, right in ignored_tag_patterns:\n        for m in left.finditer(text):\n            spans.append((m.start(), m.end()))\n        for m in right.finditer(text):\n            spans.append((m.start(), m.end()))\n\n    # Bulk remove all spans\n    text = dropSpans(spans, text)\n\n    # Drop discarded elements\n    for tag in discardElements:\n        text = dropNested(text, r'<\\s*%s\\b[^>/]*>' % tag, r'<\\s*/\\s*%s>' % tag)\n\n    # Expand placeholders\n    for pattern, placeholder in placeholder_tag_patterns:\n        index = 1\n        for match in pattern.finditer(text):\n            text = text.replace(match.group(), '%s_%d' % (placeholder, index))\n            index += 1\n\n    text = text.replace('<<', u'\u00c2\u00ab').replace('>>', u'\u00c2\u00bb')\n\n    #############################################\n\n    # Cleanup text\n    text = text.replace('\\t', ' ')\n    text = spaces.sub(' ', text)\n    text = dots.sub('...', text)\n    text = re.sub(u' (,:\\.\\)\\]\u00c2\u00bb)', r'\\1', text)\n    text = re.sub(u'(\\[\\(\u00c2\u00ab) ', r'\\1', text)\n    text = re.sub(r'\\n\\W+?\\n', '\\n', text, flags=re.U) # lines with only punctuations\n    text = text.replace(',,', ',').replace(',.', '.')\n\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndisambiguates the specified list of documents in the input document collection docs.", "response": "def disambiguate(self, docs, **kwargs):\n        \"\"\" Performs morphological analysis along with different morphological \n            disambiguation steps (pre-disambiguation, vabamorf's disambiguation\n            and post-disambiguation) in the input document collection `docs`.\n        \n        Note\n        ----\n             It is assumed that the documents in the input document collection `docs`\n            have some similarities, e.g. they are parts of the same story, they are \n            on the same topic etc., so that morphologically ambiguous words (for \n            example: proper names) reoccur in different parts of the collection. \n            The information about reoccurring ambiguous words is then used in \n            pre-disambiguation and post-disambiguation steps for improving the overall\n            quality of morphological disambiguation.\n            \n             Additionally, the input collection `docs` can have two levels: it can be\n            list of list of estnltk.text.Text . For example, if we have a corpus of\n            daily newspaper issues from one month, and each issue consists of articles\n            (published on a single day), we can place the issues to the outer list, \n            and the articles of the issues to the inner lists. \n        \n        Parameters\n        ----------\n        docs: list of estnltk.text.Text\n              List of texts (documents) in which the morphological disambiguation\n              is performed. Additionally, the list can have two levels: it can be\n              list of list of estnltk.text.Text (this can improve quality of the\n              post-disambiguation);\n        post_disambiguate : boolean, optional\n              Applies the lemma-based post-disambiguation on the collection. \n              Default: True;\n        disambiguate : boolean, optional\n              Applies vabamorf's statistical disambiguation on the collection. \n              Default: True;\n              Note: this step shouldn't be turned off, unless for testing purposes;\n        pre_disambiguate : boolean, optional\n              Applies the pre-disambiguation of proper names on the collection. \n              Default: True;\n        vabamorf : boolean, optional\n              Applies vabamorf's morphological analyzer on the collection. \n              Default: True;\n              Note: this step shouldn't be turned off, unless for testing purposes.\n              \n        Returns\n        -------\n        list of estnltk.text.Text\n          List of morphologically disambiguated texts (documents). Preserves the\n          structure, if the input was  list of list of estnltk.text.Text;\n          \n        \"\"\"\n        # For testing purposes, morph analysis and morph disambiguation can both\n        # be switched off:\n        use_vabamorf              = kwargs.get('vabamorf', True)\n        use_vabamorf_disambiguate = kwargs.get('disambiguate', True)\n        # Configuration for pre- and post disambiguation:\n        use_pre_disambiguation    = kwargs.get('pre_disambiguate', True)\n        use_post_disambiguation   = kwargs.get('post_disambiguate', True)\n\n        kwargs = kwargs\n        # Inner/default configuration for text objects:\n        kwargs['disambiguate'] = False # do not use vabamorf disambiguation at first place\n        kwargs['guess']        = True  # should be set for the morph analyzer\n        kwargs['propername']   = True  # should be set for the morph analyzer\n        \n        # Check, whether the input is a list of lists of docs, or just a list of docs\n        if not self.__isListOfLists( docs ):\n            if not self.__isListOfTexts( docs ):\n                raise Exception(\"Unexpected input argument 'docs': should be a list of strings or Text-s;\")\n            collections = [ docs ]\n        else:\n            collections = docs\n        \n        #  I. perform morphological analysis, pre_disambiguation, and \n        #     statistical (vabamorf) disambiguation with-in a single \n        #     document collection;\n        for i in range(len(collections)):\n            docs = [Text(doc, **kwargs) for doc in collections[i]]\n\n            # morf.analysis without disambiguation\n            if use_vabamorf:\n                docs = [doc.tag_analysis() for doc in docs]\n\n            if use_pre_disambiguation:\n                docs = self.pre_disambiguate(docs)\n\n            if use_vabamorf_disambiguate:\n                docs = self.__vabamorf_disambiguate(docs)\n            \n            collections[i] = docs\n\n        #\n        #  II. perform post disambiguation over all document collections;\n        #\n        if use_post_disambiguation:\n           collections = self.post_disambiguate( collections )\n        return collections if len(collections)>1 else collections[0]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __isListOfTexts(self, docs):\n        return isinstance(docs, list) and \\\n               all(isinstance(d, (basestring, Text)) for d in docs)", "response": "Checks whether the input is a list of strings or Text - s ; \n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __isListOfLists(self, docs):\n        return isinstance(docs, list) and \\\n               all(self.__isListOfTexts(ds) for ds in docs)", "response": "Checks whether the input is a list of lists of strings - s ; \n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating proper names lexicon for each word in the list of documents.", "response": "def __create_proper_names_lexicon(self, docs):\n        \"\"\" Moodustab dokumendikollektsiooni p\u00f5hjal p\u00e4risnimede sageduss\u00f5nastiku\n            (mis kirjeldab, mitu korda iga p\u00e4risnimelemma esines);\n        \"\"\"\n        lemmaFreq = dict()\n        for doc in docs:\n            for word in doc[WORDS]:\n                # 1) Leiame k6ik s6naga seotud unikaalsed p\u00e4risnimelemmad \n                #    (kui neid on)\n                uniqLemmas = set()\n                for analysis in word[ANALYSIS]:\n                    if analysis[POSTAG] == 'H':\n                        uniqLemmas.add( analysis[ROOT] )\n                # 2) J\u00e4\u00e4dvustame lemmade sagedused\n                for lemma in uniqLemmas:\n                    if lemma not in lemmaFreq:\n                        lemmaFreq[lemma] = 1\n                    else:\n                        lemmaFreq[lemma] += 1\n        return lemmaFreq"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __disambiguate_proper_names_1(self, docs, lexicon):\n        for doc in docs:\n            for word in doc[WORDS]:\n                # Vaatame vaid s6nu, millele on pakutud rohkem kui yks analyys:\n                if len(word[ANALYSIS]) > 1:\n                    # 1) Leiame k\u00f5igi p\u00e4risnimede sagedused sagedusleksikonist\n                    highestFreq = 0\n                    properNameAnalyses = []\n                    for analysis in word[ANALYSIS]:\n                        if analysis[POSTAG] == 'H':\n                            if analysis[ROOT] in lexicon:\n                                properNameAnalyses.append( analysis )\n                                if lexicon[analysis[ROOT]] > highestFreq:\n                                    highestFreq = lexicon[analysis[ROOT]]\n                            else:\n                                raise Exception(' Unable to find lemma ',analysis[ROOT], \\\n                                      ' from the lexicon. ')\n                    # 2) J2tame alles vaid suurima lemmasagedusega p\u00e4risnimeanalyysid,\n                    #    ylejaanud kustutame maha\n                    if highestFreq > 0:\n                        toDelete = []\n                        for analysis in properNameAnalyses:\n                            if lexicon[analysis[ROOT]] < highestFreq:\n                                toDelete.append(analysis)\n                        for analysis in toDelete:\n                            word[ANALYSIS].remove(analysis)", "response": "Disambiguate proper names for 1 - word document."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds certain proper names for the given set of words.", "response": "def __find_certain_proper_names(self, docs):\n        \"\"\" Moodustame kindlate p\u00e4risnimede loendi: vaatame s\u00f5nu, millel ongi\n            ainult p\u00e4risnimeanal\u00fc\u00fcsid ning v\u00f5tame sealt loendisse  unikaalsed\n            p\u00e4risnimed;\n        \"\"\"\n        certainNames = set()\n        for doc in docs:\n            for word in doc[WORDS]:\n                # Vaatame vaid p\u00e4risnimeanal\u00fc\u00fcsidest koosnevaid s\u00f5nu\n                if all([ a[POSTAG] == 'H' for a in word[ANALYSIS] ]):\n                    # J\u00e4\u00e4dvustame k\u00f5ik unikaalsed lemmad kui kindlad p\u00e4risnimed\n                    for analysis in word[ANALYSIS]:\n                        certainNames.add( analysis[ROOT] )\n        return certainNames"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __find_sentence_initial_proper_names(self, docs):\n        sentInitialNames = set()\n        for doc in docs:\n            for sentence in doc.divide( layer=WORDS, by=SENTENCES ): \n                sentencePos = 0 # Tavaline lausealgus\n                for i in range(len(sentence)):\n                    word = sentence[i]\n                    #  T\u00e4iendavad heuristikud lausealguspositsioonide leidmiseks:\n                    #  1) kirjavahem\u00e4rk, mis pole koma ega semikoolon, on lausealgus:\n                    if all([ a[POSTAG] == 'Z' for a in word[ANALYSIS] ]) and \\\n                       not re.match('^[,;]+$', word[TEXT]):\n                        sentencePos = 0\n                        #self.__debug_print_word_in_sentence_str(sentence, word)\n                        continue\n                    # 2) potentsiaalne loendi algus (arv, millele j\u00e4rgneb punkt v\u00f5i\n                    #    sulg ja mis ei ole kuup\u00e4ev);\n                    if not re.match('^[1234567890]*$', word[TEXT] ) and \\\n                       not re.match('^[1234567890]{1,2}.[1234567890]{1,2}.[1234567890]{4}$', word[TEXT] ) and \\\n                       re.match(\"^[1234567890.()]*$\", word[TEXT]):\n                        sentencePos = 0\n                        #self.__debug_print_word_in_sentence_str(sentence, word)\n                        continue\n                    if sentencePos == 0:\n                        # Vaatame lausealgulisi s\u00f5nu, millel on nii p\u00e4risnimeanal\u00fc\u00fcs(e) \n                        # kui ka mitte-p\u00e4risnimeanal\u00fc\u00fcs(e)\n                        h_postags = [ a[POSTAG] == 'H' for a in word[ANALYSIS] ]\n                        if any( h_postags )  and  not all( h_postags ):\n                            for analysis in word[ANALYSIS]:\n                                # J\u00e4tame meelde k\u00f5ik unikaalsed p\u00e4risnimelemmad\n                                if analysis[POSTAG] == 'H':\n                                    sentInitialNames.add( analysis[ROOT] )\n                    sentencePos += 1\n        return sentInitialNames", "response": "Find initial proper names for words in a list of sentences."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove redundant proper names from the document list.", "response": "def __remove_redundant_proper_names(self, docs, lemma_set):\n        \"\"\" Eemaldame yleliigsed p\u00e4risnimeanal\u00fc\u00fcsid etteantud s\u00f5nalemmade\n            loendi (hulga) p\u00f5hjal;\n        \"\"\"\n        for doc in docs:\n            for word in doc[WORDS]:\n                # Vaatame vaid s6nu, millele on pakutud rohkem kui yks analyys:\n                if len(word[ANALYSIS]) > 1:\n                    # 1) Leiame analyysid, mis tuleks loendi j\u00e4rgi eemaldada\n                    toDelete = []\n                    for analysis in word[ANALYSIS]:\n                        if analysis[POSTAG] == 'H' and analysis[ROOT] in lemma_set:\n                            toDelete.append( analysis )\n                    # 2) Eemaldame yleliigsed analyysid\n                    if toDelete:\n                        for analysis in toDelete:\n                            word[ANALYSIS].remove(analysis)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisambiguate the given list of words and sets of words to their respective values.", "response": "def pre_disambiguate(self, docs):\n        \"\"\"  Teostab p\u00e4risnimede eel\u00fchestamine. \u00dcldiseks eesm\u00e4rgiks on v\u00e4hendada mitmesust \n             suurt\u00e4hega algavate sonade morf anal\u00fc\u00fcsil, nt eemaldada p\u00e4risnime anal\u00fc\u00fcs, kui\n             suurt\u00e4ht t\u00e4histab t\u00f5en\u00e4oliselt lausealgust.\n        \"\"\"\n        # 1) Leiame p\u00e4risnimelemmade sagedusleksikoni\n        lexicon = self.__create_proper_names_lexicon(docs)\n        # 2) Teeme esialgse kustutamise: kui s\u00f5nal on mitu erineva korpuse-\n        #    sagedusega p\u00e4risnimeanal\u00fc\u00fcsi, siis j\u00e4tame alles vaid k\u00f5ige \n        #    sagedasema analyysi ...\n        self.__disambiguate_proper_names_1(docs, lexicon)\n        \n        # 3) Eemaldame yleliigsed lause alguse p\u00e4risnimeanal\u00fc\u00fcsid;\n        #  K\u00f5igepealt leiame: kindlad p\u00e4risnimed, lause alguses esinevad \n        #  p2risnimed ja lause keskel esinevad p\u00e4risnimed\n        certainNames     = self.__find_certain_proper_names(docs)\n        sentInitialNames = self.__find_sentence_initial_proper_names(docs)\n        sentCentralNames = self.__find_sentence_central_proper_names(docs)\n        \n        # 3.1) V\u00f5rdleme lause alguses ja keskel esinevaid lemmasid: leiame \n        #      lemmad, mis esinesid ainult lause alguses ...\n        onlySentenceInitial = sentInitialNames.difference(sentCentralNames)\n        # 3.2) V\u00f5rdleme ainult lause alguses esinevaid ning kindlaid p\u00e4risnime-\n        #      lemmasid: kui s\u00f5na esines vaid lause alguses ega ole kindel \n        #      p\u00e4risnimelemma, pole t\u00f5en\u00e4oliselt tegu p\u00e4risnimega ...\n        notProperNames = onlySentenceInitial.difference(certainNames)\n        # 3.3) Eemaldame yleliigsed p2risnimeanalyysid (kui selliseid leidus)\n        if len(notProperNames) > 0:\n            self.__remove_redundant_proper_names(docs, notProperNames)\n        \n        # 4) Leiame uue p\u00e4risnimelemmade sagedusleksikoni (sagedused on \n        #    t\u00f5en\u00e4oliselt vahepeal muutunud);\n        lexicon = self.__create_proper_names_lexicon(docs)\n        \n        # 5) Teeme \u00fcleliigsete mittep\u00e4risnimeanal\u00fc\u00fcside kustutamise s\u00f5nadelt,\n        #    millel on lisaks p\u00e4risnimeanal\u00fc\u00fcsidele ka teisi anal\u00fc\u00fcse: \n        #    lausealgusesse j\u00e4tame alles vaid p\u00e4risnimeanal\u00fc\u00fcsid, kui neid \n        #    esineb korpuses ka mujal; \n        #    lause keskele j\u00e4tame igal juhul alles vaid p\u00e4risnimeanal\u00fc\u00fcsid;\n        self.__disambiguate_proper_names_2(docs, lexicon)\n        return docs"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __analyses_match(self, analysisA, analysisB):\n        return POSTAG in analysisA and POSTAG in analysisB and \\\n               analysisA[POSTAG]==analysisB[POSTAG] and \\\n               ROOT in analysisA and ROOT in analysisB and \\\n               analysisA[ROOT]==analysisB[ROOT] and \\\n               FORM in analysisA and FORM in analysisB and \\\n               analysisA[FORM]==analysisB[FORM] and \\\n               CLITIC in analysisA and CLITIC in analysisB and \\\n               analysisA[CLITIC]==analysisB[CLITIC] and \\\n               ENDING in analysisA and ENDING in analysisB and \\\n               analysisA[ENDING]==analysisB[ENDING]", "response": "Returns True if the analysisA and analysisB are the same."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __remove_duplicate_and_problematic_analyses(self, docs):\n        for doc in docs:\n            for word in doc[WORDS]:\n                # 1) Leiame k6ik analyysi-duplikaadid (kui neid on)\n                toDelete = []\n                for i in range(len(word[ANALYSIS])):\n                    if i+1 < len(word[ANALYSIS]):\n                        for j in range(i+1, len(word[ANALYSIS])):\n                            analysisI = word[ANALYSIS][i]\n                            analysisJ = word[ANALYSIS][j]\n                            if self.__analyses_match(analysisI, analysisJ):\n                                if j not in toDelete:\n                                    toDelete.append(j)\n                # 2) Kustutame yleliigsed analyysid\n                if toDelete:\n                    for a in sorted(toDelete, reverse=True):\n                        del word[ANALYSIS][a]\n                #\n                # *) Kui verbi anal\u00fc\u00fcside puhul on olemas nii '-tama' kui ka '-ma' \n                #    l\u00f5pp, siis j\u00e4tta alles vaid -ma, \u00fclej\u00e4\u00e4nud kustutada;\n                #    Nt   l\u00f5petama:    l\u00f5p+tama,   l\u00f5ppe+tama,  l\u00f5peta+ma\n                #         teatama:     tead+tama,  teata+ma\n                #\n                if any([ a[POSTAG]=='V' and a[ENDING]=='tama' for a in word[ANALYSIS] ]) and \\\n                   any([ a[POSTAG]=='V' and a[ENDING]=='ma' for a in word[ANALYSIS] ]):\n                    toDelete = []\n                    for a in range( len(word[ANALYSIS]) ):\n                        if word[ANALYSIS][a][POSTAG]=='V' and \\\n                           word[ANALYSIS][a][ENDING]=='tama':\n                            toDelete.append(a)\n                    if toDelete:\n                        for a in sorted(toDelete, reverse=True):\n                            del word[ANALYSIS][a]", "response": "Remove duplicate and problematic analyses from a list of documents."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __find_hidden_analyses(self, docs):\n        hidden = dict()\n        nudTudLopud = re.compile('^.*[ntd]ud$')\n        for d in range(len(docs)):\n            for w in range(len(docs[d][WORDS])):\n                word = docs[d][WORDS][w]\n                if ANALYSIS in word and len(word[ANALYSIS]) > 1:\n                    #\n                    # 1) Kui enamus anal\u00fc\u00fcse on nud/tud/dud anal\u00fc\u00fcsid, peida mitmesus:\n                    #    k\u00f5la+nud //_V_ nud, //    k\u00f5la=nud+0 //_A_ //    k\u00f5la=nud+0 //_A_ sg n, //    k\u00f5la=nud+d //_A_ pl n, //\n                    nudTud = [ nudTudLopud.match(a[ROOT]) != None or \\\n                               nudTudLopud.match(a[ENDING]) != None \\\n                               for a in word[ANALYSIS] ]\n                    if nudTud.count( True ) > 1:\n                        hidden[(d, w)] = 1\n                    #\n                    # 2) Kui analyysidel on sama lemma ja puudub vormitunnus, siis peida mitmesused \u00e4ra:\n                    #    Nt    kui+0 //_D_ //    kui+0 //_J_ //\n                    #          nagu+0 //_D_ //    nagu+0 //_J_ //\n                    lemmas = set([ a[ROOT] for a in word[ANALYSIS] ])\n                    forms  = set([ a[FORM] for a in word[ANALYSIS] ])\n                    if len(lemmas) == 1 and len(forms) == 1 and (list(forms))[0] == '':\n                        hidden[(d, w)] = 1\n                    #\n                    # 3) Kui 'olema'-analyysidel on sama lemma ning sama l6pp, peida mitmesused:\n                    #    Nt  'nad on' vs 'ta on' saavad sama olema-analyysi, mis j\u00e4\u00e4b mitmeseks;\n                    endings  = set([ a[ENDING] for a in word[ANALYSIS] ])\n                    if len(lemmas) == 1 and (list(lemmas))[0] == 'ole' and len(endings) == 1 \\\n                       and (list(endings))[0] == '0':\n                        hidden[(d, w)] = 1\n                    #\n                    # 4) Kui ases\u00f5nadel on sama lemma ja l\u00f5pp, peida ainsuse/mitmuse mitmesus:\n                    #    Nt     k\u00f5ik+0 //_P_ sg n //    k\u00f5ik+0 //_P_ pl n //\n                    #           kes+0 //_P_ sg n //    kes+0 //_P_ pl n //\n                    postags  = set([ a[POSTAG] for a in word[ANALYSIS] ])\n                    if len(lemmas) == 1 and len(postags) == 1 and 'P' in postags and \\\n                       len(endings) == 1:\n                        hidden[(d, w)] = 1\n                    #\n                    # 5) Kui on sama lemma ja l\u00f5pp, peida arv- ja ases\u00f5nadevaheline mitmesus:\n                    #    Nt     teine+0 //_O_ pl n, //    teine+0 //_P_ pl n, //\n                    #           \u00fcks+l //_N_ sg ad, //    \u00fcks+l //_P_ sg ad, //\n                    if len(lemmas) == 1 and 'P' in postags and ('O' in postags or \\\n                       'N' in postags) and len(endings) == 1:\n                        hidden[(d, w)] = 1\n        return hidden", "response": "Find hidden analyses in the given list of sentences."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __supplement_lemma_frequency_lexicon(self, docs, hiddenWords, lexicon, amb_lexicon):\n        for d in range(len(docs)):\n            for w in range(len(docs[d][WORDS])):\n                word = docs[d][WORDS][w]\n                # J\u00e4tame vahele nn peidetud s\u00f5nad\n                if (d, w) in hiddenWords:\n                    continue\n                isAmbiguous = (len(word[ANALYSIS])>1)\n                # J\u00e4\u00e4dvustame sagedused, verbide omad eraldiseisva m\u00e4rkega:\n                for a in word[ANALYSIS]:\n                    lemma = a[ROOT]+'ma' if a[POSTAG]=='V' else a[ROOT]\n                    # 1) J\u00e4\u00e4dvustame \u00fcldise sageduse\n                    if lemma not in lexicon:\n                        lexicon[lemma] = 1\n                    else:\n                        lexicon[lemma] += 1\n                    # 2) J\u00e4\u00e4dvustame mitmeste s\u00f5nade esinemise\n                    if isAmbiguous:\n                        amb_lexicon[lemma] = 1\n        #  Kanname yldisest sagedusleksikonist sagedused yle mitmeste lemmade\n        # sagedusleksikoni\n        for lemma in amb_lexicon.keys():\n            amb_lexicon[lemma] = lexicon[lemma]", "response": "Supplement the lemma frequency of the lemmas in the lexicon."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisambiguate a list of words in a list of words with a given lexicon.", "response": "def __disambiguate_with_lexicon(self, docs, lexicon, hiddenWords):\n        \"\"\" Teostab lemmade leksikoni j\u00e4rgi mitmeste morf anal\u00fc\u00fcside \n            \u00fchestamise - eemaldab \u00fcleliigsed anal\u00fc\u00fcsid;\n            Toetub ideele \"\u00fcks t\u00e4hendus teksti kohta\": kui mitmeseks j\u00e4\u00e4nud \n            lemma esineb tekstis/korpuses ka mujal ning l\u00f5ppkokkuv\u00f5ttes \n            esineb sagedamini kui alternatiivsed anal\u00fc\u00fcsid, siis t\u00f5en\u00e4oliselt\n            see ongi \u00f5ige lemma/anal\u00fc\u00fcs;\n        \"\"\"\n        for d in range(len(docs)):\n            for w in range(len(docs[d][WORDS])):\n                word = docs[d][WORDS][w]\n                # J\u00e4tame vahele nn peidetud s\u00f5nad\n                if (d, w) in hiddenWords:\n                    continue\n                # Vaatame vaid mitmeseks j\u00e4\u00e4nud anal\u00fc\u00fcsidega s\u00f5nu\n                if len(word[ANALYSIS]) > 1:\n                    #  1) Leiame suurima esinemissageduse mitmeste lemmade seas\n                    highestFreq = 0\n                    for analysis in word[ANALYSIS]:\n                        lemma = analysis[ROOT]+'ma' if analysis[POSTAG]=='V' else analysis[ROOT]\n                        if lemma in lexicon and lexicon[lemma] > highestFreq:\n                            highestFreq = lexicon[lemma]\n                    if highestFreq > 0:\n                        #  2) J\u00e4tame v\u00e4lja k\u00f5ik anal\u00fc\u00fcsid, mille lemma esinemissagedus\n                        #     on v\u00e4iksem kui suurim esinemissagedus;\n                        toDelete = []\n                        for analysis in word[ANALYSIS]:\n                            lemma = analysis[ROOT]+'ma' if analysis[POSTAG]=='V' else analysis[ROOT]\n                            freq = lexicon[lemma] if lemma in lexicon else 0\n                            if freq < highestFreq:\n                                toDelete.append(analysis)\n                        for analysis in toDelete:\n                            word[ANALYSIS].remove(analysis)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef post_disambiguate(self, collections):\n        #\n        #  I etapp: \u00fchestame \u00fche dokumendikollektsiooni piires \n        #           (nt \u00fcle k\u00f5igi samal p\u00e4eval ilmunud ajaleheartiklite);\n        #\n        for docs in collections:\n            # 1) Eemaldame anal\u00fc\u00fcside seast duplikaadid ja probleemsed\n            self.__remove_duplicate_and_problematic_analyses(docs)\n            # 2) Leiame s\u00f5nad, mis sisaldavad nn ignoreeritavaid mitmesusi\n            #    (selliseid mitmesusi, mida me \u00fchestamisel ei arvesta);\n            hiddenWords = self.__find_hidden_analyses(docs)\n            # 3) Leiame kaks lemmade sagedusleksikoni: \u00fcldise lemmade sagedus-\n            #    leksikoni ja mitmeseks j\u00e4\u00e4nud sonade lemmade sagedusleksikoni;\n            #    Mitmeste lemmade leksikoni l\u00e4heb kirja vastavate lemmade yldine \n            #    sagedus korpuses (kuhu arvatud ka sagedus \u00fchestatud s\u00f5nades);\n            genLemmaLex = dict()\n            ambLemmaLex = dict()\n            self.__supplement_lemma_frequency_lexicon(docs, hiddenWords, ambLemmaLex, genLemmaLex)\n            # 4) Teostame lemmade-p6hise yhestamise: mitmeseks j22nud analyyside \n            #    puhul j2tame alles analyysid, mille lemma esinemisagedus on suurim\n            #    (ja kui k6igi esinemissagedus on v6rdne, siis ei tee midagi)\n            self.__disambiguate_with_lexicon(docs, ambLemmaLex, hiddenWords)\n        #\n        #  II etapp: \u00fchestame \u00fcle k\u00f5ikide dokumendikollektsioonide \n        #            (nt \u00fcle k\u00f5igi \u00fche aasta ajalehenumbrite, kus\n        #             \u00fcks ajalehenumber sisaldab k\u00f5iki sama p\u00e4eva artikleid);\n        #\n        if len(collections) > 1:\n            # Genereerime mitmeste sagedusleksikoni\n            genLemmaLex = dict()\n            ambLemmaLex = dict()\n            for docs in collections:\n                # *) Leiame s\u00f5nad, mis sisaldavad nn ignoreeritavaid mitmesusi\n                hiddenWords = self.__find_hidden_analyses(docs)\n                # *) T\u00e4iendame \u00fcldist lemmade sagedusleksikoni ja mitmeseks j\u00e4\u00e4nud\n                #    lemmade sagedusleksikoni;\n                self.__supplement_lemma_frequency_lexicon(docs, hiddenWords, ambLemmaLex, genLemmaLex)\n            # Teostame j\u00e4rel\u00fchestamise\n            for docs in collections:\n                # *) Leiame s\u00f5nad, mis sisaldavad nn ignoreeritavaid mitmesusi\n                hiddenWords = self.__find_hidden_analyses(docs)\n                # *) Teostame lemmade-p6hise yhestamise;\n                self.__disambiguate_with_lexicon(docs, ambLemmaLex, hiddenWords)\n        return collections", "response": "Post disambiguation of the words in the list of collections."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tag_text(self, text, **kwargs):\n\n        for analysis_match in text.analysis:\n            for candidate in analysis_match:\n                if candidate['partofspeech'] in PYVABAMORF_TO_WORDNET_POS_MAP:\n                    # Wordnet contains data about the given lemma and pos combination - will annotate.\n                    wordnet_obj = {}\n                    tag_synsets(wordnet_obj, candidate, **kwargs)\n        return text", "response": "Annotates the given text with the word - level analysis."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a sentence chunk extract original texts and labels.", "response": "def get_texts_and_labels(sentence_chunk):\n    \"\"\"Given a sentence chunk, extract original texts and labels.\"\"\"\n    words = sentence_chunk.split('\\n')\n    texts = []\n    labels = []\n    for word in words:\n        word = word.strip()\n        if len(word) > 0:\n            toks = word.split('\\t')\n            texts.append(toks[0].strip())\n            labels.append(toks[-1].strip())\n    return texts, labels"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_doc(doc):\n    word_spans = []\n    sentence_spans = []\n    sentence_chunks = doc.split('\\n\\n')\n    sentences = []\n    for chunk in sentence_chunks:\n        sent_texts, sent_labels = get_texts_and_labels(chunk.strip())\n        sentences.append(list(zip(sent_texts, sent_labels)))\n    return sentences", "response": "Exract list of sentences containing text and label pairs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert(document):\n    raw_tokens = []\n    curpos = 0\n    text_spans = []\n    all_labels = []\n    sent_spans = []\n    word_texts = []\n    for sentence in document:\n        startpos = curpos\n        for idx, (text, label) in enumerate(sentence):\n            raw_tokens.append(text)\n            word_texts.append(text)\n            all_labels.append(label)\n            text_spans.append((curpos, curpos+len(text)))\n            curpos += len(text)\n            if idx < len(sentence) - 1:\n                raw_tokens.append(' ')\n                curpos += 1\n        sent_spans.append((startpos, curpos))\n        raw_tokens.append('\\n')\n        curpos += 1\n    return {\n        TEXT: ''.join(raw_tokens),\n        WORDS: [{TEXT: text, START: start, END: end, LABEL: label} for text, (start, end), label in zip(word_texts, text_spans, all_labels)],\n        SENTENCES: [{START: start, END:end} for start, end in sent_spans]\n    }", "response": "Convert a document to a Text object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nselecting the current user from the database.", "response": "def select(self, cb=None):\n        '''\n        Set this channel to use transactions.\n        '''\n        if not self._enabled:\n            self._enabled = True\n            self.send_frame(MethodFrame(self.channel_id, 90, 10))\n            self._select_cb.append(cb)\n            self.channel.add_synchronous_cb(self._recv_select_ok)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncommits the current transaction.", "response": "def commit(self, cb=None):\n        '''\n        Commit the current transaction.  Caller can specify a callback to use\n        when the transaction is committed.\n        '''\n        # Could call select() but spec 1.9.2.3 says to raise an exception\n        if not self.enabled:\n            raise self.TransactionsNotEnabled()\n\n        self.send_frame(MethodFrame(self.channel_id, 90, 20))\n        self._commit_cb.append(cb)\n        self.channel.add_synchronous_cb(self._recv_commit_ok)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rollback(self, cb=None):\n        '''\n        Abandon all message publications and acks in the current transaction.\n        Caller can specify a callback to use when the transaction has been\n        aborted.\n        '''\n        # Could call select() but spec 1.9.2.5 says to raise an exception\n        if not self.enabled:\n            raise self.TransactionsNotEnabled()\n\n        self.send_frame(MethodFrame(self.channel_id, 90, 30))\n        self._rollback_cb.append(cb)\n        self.channel.add_synchronous_cb(self._recv_rollback_ok)", "response": "Rolls back all messages in the current transaction."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef synchronous(self):\n        '''\n        True if transport is synchronous or the connection has been forced\n        into synchronous mode, False otherwise.\n        '''\n        if self._transport is None:\n            if self._close_info and len(self._close_info['reply_text']) > 0:\n                raise ConnectionClosed(\"connection is closed: %s : %s\" %\n                                       (self._close_info['reply_code'],\n                                        self._close_info['reply_text']))\n            raise ConnectionClosed(\"connection is closed\")\n        return self.transport.synchronous or self._synchronous", "response": "Returns True if the transport is synchronous False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconnecting to a host and port.", "response": "def connect(self, host, port):\n        '''\n        Connect to a host and port.\n        '''\n        # Clear the connect state immediately since we're no longer connected\n        # at this point.\n        self._connected = False\n\n        # Only after the socket has connected do we clear this state; closed\n        # must be False so that writes can be buffered in writePacket(). The\n        # closed state might have been set to True due to a socket error or a\n        # redirect.\n        self._host = \"%s:%d\" % (host, port)\n        self._closed = False\n        self._close_info = {\n            'reply_code': 0,\n            'reply_text': 'failed to connect to %s' % (self._host),\n            'class_id': 0,\n            'method_id': 0\n        }\n\n        self._transport.connect((host, port))\n        self._transport.write(PROTOCOL_HEADER)\n\n        self._last_octet_time = time.time()\n\n        if self._synchronous_connect:\n            # Have to queue this callback just after connect, it can't go\n            # into the constructor because the channel needs to be\n            # \"always there\" for frame processing, but the synchronous\n            # callback can't be added until after the protocol header has\n            # been written. This SHOULD be registered before the protocol\n            # header is written, in the case where the header bytes are\n            # written, but this thread/greenlet/context does not return until\n            # after another thread/greenlet/context has read and processed the\n            # recv_start frame. Without more re-write to add_sync_cb though,\n            # it will block on reading responses that will never arrive\n            # because the protocol header isn't written yet. TBD if needs\n            # refactoring. Could encapsulate entirely here, wherein\n            # read_frames exits if protocol header not yet written. Like other\n            # synchronous behaviors, adding this callback will result in a\n            # blocking frame read and process loop until _recv_start and any\n            # subsequent synchronous callbacks have been processed. In the\n            # event that this is /not/ a synchronous transport, but the\n            # caller wants the connect to be synchronous so as to ensure that\n            # the connection is ready, then do a read frame loop here.\n            self._channels[0].add_synchronous_cb(self._channels[0]._recv_start)\n            while not self._connected:\n                self.read_frames()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndisconnecting from the current host.", "response": "def disconnect(self):\n        '''\n        Disconnect from the current host, but do not update the closed state.\n        After the transport is disconnected, the closed state will be True if\n        this is called after a protocol shutdown, or False if the disconnect\n        was in error.\n\n        TODO: do we really need closed vs. connected states? this only adds\n        complication and the whole reconnect process has been scrapped anyway.\n\n        '''\n        self._connected = False\n        if self._transport is not None:\n            try:\n                self._transport.disconnect()\n            except Exception:\n                self.logger.error(\n                    \"Failed to disconnect from %s\", self._host, exc_info=True)\n                raise\n            finally:\n                self._transport = None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transport_closed(self, **kwargs):\n        msg = 'unknown cause'\n        self.logger.warning('transport to %s closed : %s' %\n                            (self._host, kwargs.get('msg', msg)))\n        self._close_info = {\n            'reply_code': kwargs.get('reply_code', 0),\n            'reply_text': kwargs.get('msg', msg),\n            'class_id': kwargs.get('class_id', 0),\n            'method_id': kwargs.get('method_id', 0)\n        }\n\n        # We're not connected any more, but we're not closed without an\n        # explicit close call.\n        self._connected = False\n        self._transport = None\n\n        # Call back to a user-provided close function\n        self._callback_close()", "response": "Called by Transports when they close unexpectedly."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _next_channel_id(self):\n        '''Return the next possible channel id.  Is a circular enumeration.'''\n        self._channel_counter += 1\n        if self._channel_counter >= self._channel_max:\n            self._channel_counter = 1\n        return self._channel_counter", "response": "Return the next possible channel id. Is a circular enumeration."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef channel(self, channel_id=None, synchronous=False):\n        if channel_id is None:\n            # adjust for channel 0\n            if len(self._channels) - 1 >= self._channel_max:\n                raise Connection.TooManyChannels(\n                    \"%d channels already open, max %d\",\n                    len(self._channels) - 1,\n                    self._channel_max)\n            channel_id = self._next_channel_id()\n            while channel_id in self._channels:\n                channel_id = self._next_channel_id()\n        elif channel_id in self._channels:\n            return self._channels[channel_id]\n        else:\n            raise Connection.InvalidChannel(\n                \"%s is not a valid channel id\", channel_id)\n\n        # Call open() here so that ConnectionChannel doesn't have it called.\n        # Could also solve this other ways, but it's a HACK regardless.\n        rval = Channel(\n            self, channel_id, self._class_map, synchronous=synchronous)\n        self._channels[channel_id] = rval\n        rval.add_close_listener(self._channel_closed)\n        rval.open()\n        return rval", "response": "Fetch a Channel object identified by the numeric channel_id or create a new one if it doesn t already exist."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_frames(self):\n        '''\n        Read frames from the transport and process them. Some transports may\n        choose to do this in the background, in several threads, and so on.\n        '''\n        # It's possible in a concurrent environment that our transport handle\n        # has gone away, so handle that cleanly.\n        # TODO: Consider moving this block into Translator base class. In many\n        # ways it belongs there. One of the problems though is that this is\n        # essentially the read loop. Each Transport has different rules for\n        # how to kick this off, and in the case of gevent, this is how a\n        # blocking call to read from the socket is kicked off.\n        if self._transport is None:\n            return\n\n        # Send a heartbeat (if needed)\n        self._channels[0].send_heartbeat()\n\n        data = self._transport.read(self._heartbeat)\n        current_time = time.time()\n\n        if data is None:\n            # Wait for 2 heartbeat intervals before giving up. See AMQP 4.2.7:\n            # \"If a peer detects no incoming traffic (i.e. received octets) for two heartbeat intervals or longer,\n            # it should close the connection\"\n            if self._heartbeat and (current_time-self._last_octet_time > 2*self._heartbeat):\n                msg = 'Heartbeats not received from %s for %d seconds' % (self._host, 2*self._heartbeat)\n                self.transport_closed(msg=msg)\n                raise ConnectionClosed('Connection is closed: ' + msg)\n            return\n        self._last_octet_time = current_time\n        reader = Reader(data)\n        p_channels = set()\n\n        try:\n            for frame in Frame.read_frames(reader):\n                if self._debug > 1:\n                    self.logger.debug(\"READ: %s\", frame)\n                self._frames_read += 1\n                ch = self.channel(frame.channel_id)\n                ch.buffer_frame(frame)\n                p_channels.add(ch)\n        except Frame.FrameError as e:\n            # Frame error in the peer, disconnect\n            self.close(reply_code=501,\n                       reply_text='frame error from %s : %s' % (\n                           self._host, str(e)),\n                       class_id=0, method_id=0, disconnect=True)\n            raise ConnectionClosed(\"connection is closed: %s : %s\" %\n                                   (self._close_info['reply_code'],\n                                    self._close_info['reply_text']))\n\n        # NOTE: we process channels after buffering unused data in order to\n        # preserve the integrity of the input stream in case a channel needs to\n        # read input, such as when a channel framing error necessitates the use\n        # of the synchronous channel.close method. See `Channel.process_frames`.\n        #\n        # HACK: read the buffer contents and re-buffer.  Would prefer to pass\n        # buffer back, but there's no good way of asking the total size of the\n        # buffer, comparing to tell(), and then re-buffering.  There's also no\n        # ability to clear the buffer up to the current position. It would be\n        # awesome if we could free that memory without a new allocation.\n        if reader.tell() < len(data):\n            self._transport.buffer(data[reader.tell():])\n\n        self._transport.process_channels(p_channels)", "response": "Read frames from the transport and process them."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _flush_buffered_frames(self):\n        '''\n        Callback when protocol has been initialized on channel 0 and we're\n        ready to send out frames to set up any channels that have been\n        created.\n        '''\n        # In the rare case (a bug) where this is called but send_frame thinks\n        # they should be buffered, don't clobber.\n        frames = self._output_frame_buffer\n        self._output_frame_buffer = []\n        for frame in frames:\n            self.send_frame(frame)", "response": "Callback when protocol has been initialized on channel 0 and we re ready to send out any buffered frames."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_frame(self, frame):\n        '''\n        Send a single frame. If there is no transport or we're not connected\n        yet, append to the output buffer, else send immediately to the socket.\n        This is called from within the MethodFrames.\n        '''\n        if self._closed:\n            if self._close_info and len(self._close_info['reply_text']) > 0:\n                raise ConnectionClosed(\"connection is closed: %s : %s\" %\n                                       (self._close_info['reply_code'],\n                                        self._close_info['reply_text']))\n            raise ConnectionClosed(\"connection is closed\")\n\n        if self._transport is None or \\\n                (not self._connected and frame.channel_id != 0):\n            self._output_frame_buffer.append(frame)\n            return\n\n        if self._debug > 1:\n            self.logger.debug(\"WRITE: %s\", frame)\n\n        buf = bytearray()\n        frame.write_frame(buf)\n        if len(buf) > self._frame_max:\n            self.close(\n                reply_code=501,\n                reply_text='attempted to send frame of %d bytes, frame max %d' % (\n                    len(buf), self._frame_max),\n                class_id=0, method_id=0, disconnect=True)\n            raise ConnectionClosed(\n                \"connection is closed: %s : %s\" %\n                (self._close_info['reply_code'],\n                 self._close_info['reply_text']))\n        self._transport.write(buf)\n\n        self._frames_written += 1", "response": "Send a single frame to the remote socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dispatch(self, frame):\n        '''\n        Override the default dispatch since we don't need the rest of\n        the stack.\n        '''\n        if frame.type() == HeartbeatFrame.type():\n            self.send_heartbeat()\n\n        elif frame.type() == MethodFrame.type():\n            if frame.class_id == 10:\n                cb = self._method_map.get(frame.method_id)\n                if cb:\n                    method = self.clear_synchronous_cb(cb)\n                    method(frame)\n                else:\n                    raise Channel.InvalidMethod(\n                        \"unsupported method %d on channel %d\",\n                        frame.method_id, self.channel_id)\n            else:\n                raise Channel.InvalidClass(\n                    \"class %d is not supported on channel %d\",\n                    frame.class_id, self.channel_id)\n\n        else:\n            raise Frame.InvalidFrameType(\n                \"frame type %d is not supported on channel %d\",\n                frame.type(), self.channel_id)", "response": "Dispatches the given frame to the appropriate method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending a heartbeat if needed. Tracks last heartbeat send time.", "response": "def send_heartbeat(self):\n        '''\n        Send a heartbeat if needed. Tracks last heartbeat send time.\n        '''\n        # Note that this does not take into account the time that we last\n        # sent a frame. Hearbeats are so small the effect should be quite\n        # limited. Also note that we're looking for something near to our\n        # scheduled interval, because if this is exact, then we'll likely\n        # actually send a heartbeat at twice the period, which could cause\n        # a broker to kill the connection if the period is large enough. The\n        # 90% bound is arbitrary but seems a sensible enough default.\n        if self.connection._heartbeat:\n            if time.time() >= (self._last_heartbeat_send + 0.9 *\n                               self.connection._heartbeat):\n                self.send_frame(HeartbeatFrame(self.channel_id))\n                self._last_heartbeat_send = time.time()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend the start_ok message.", "response": "def _send_start_ok(self):\n        '''Send the start_ok message.'''\n        args = Writer()\n        args.write_table(self.connection._properties)\n        args.write_shortstr(self.connection._login_method)\n        args.write_longstr(self.connection._login_response)\n        args.write_shortstr(self.connection._locale)\n        self.send_frame(MethodFrame(self.channel_id, 10, 11, args))\n\n        self.add_synchronous_cb(self._recv_tune)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef declare(self, exchange, type, passive=False, durable=False,\n                nowait=True, arguments=None, ticket=None, cb=None):\n        \"\"\"\n        Declare the exchange.\n\n        exchange - The name of the exchange to declare\n        type - One of\n        \"\"\"\n        nowait = nowait and self.allow_nowait() and not cb\n\n        args = Writer()\n        args.write_short(ticket or self.default_ticket).\\\n            write_shortstr(exchange).\\\n            write_shortstr(type).\\\n            write_bits(passive, durable, False, False, nowait).\\\n            write_table(arguments or {})\n        self.send_frame(MethodFrame(self.channel_id, 40, 10, args))\n\n        if not nowait:\n            self._declare_cb.append(cb)\n            self.channel.add_synchronous_cb(self._recv_declare_ok)", "response": "Declare the exchange.\n\n        exchange - The name of the exchange to declare\n        type - One of"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconnect assuming a host and port tuple.", "response": "def connect(self, (host, port), klass=socket.socket):\n        '''Connect assuming a host and port tuple.\n\n        :param tuple: A tuple containing host and port for a connection.\n        :param klass: A implementation of socket.socket.\n        :raises socket.gaierror: If no address can be resolved.\n        :raises socket.error: If no connection can be made.\n        '''\n        self._host = \"%s:%s\" % (host, port)\n\n        for info in socket.getaddrinfo(host, port, 0, 0, socket.IPPROTO_TCP):\n\n            family, socktype, proto, _, sockaddr = info\n            self._sock = klass(family, socktype, proto)\n            self._sock.settimeout(self.connection._connect_timeout)\n            if self.connection._sock_opts:\n                _sock_opts = self.connection._sock_opts\n                for (level, optname), value in _sock_opts.iteritems():\n                    self._sock.setsockopt(level, optname, value)\n            try:\n\n                self._sock.connect(sockaddr)\n\n            except socket.error:\n\n                self.connection.logger.exception(\n                    \"Failed to connect to %s:\",\n                    sockaddr,\n                )\n                continue\n\n            # After connecting, switch to full-blocking mode.\n            self._sock.settimeout(None)\n            break\n\n        else:\n\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading from the transport. If timeout is 0 will block for timeout seconds. If timeout is None will block for timeout seconds.", "response": "def read(self, timeout=None):\n        '''\n        Read from the transport. If timeout>0, will only block for `timeout`\n        seconds.\n        '''\n        e = None\n        if not hasattr(self, '_sock'):\n            return None\n\n        try:\n            # Note that we ignore both None and 0, i.e. we either block with a\n            # timeout or block completely and let gevent sort it out.\n            if timeout:\n                self._sock.settimeout(timeout)\n            else:\n                self._sock.settimeout(None)\n            data = self._sock.recv(\n                self._sock.getsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF))\n\n            if len(data):\n                if self.connection.debug > 1:\n                    self.connection.logger.debug(\n                        'read %d bytes from %s' % (len(data), self._host))\n                if len(self._buffer):\n                    self._buffer.extend(data)\n                    data = self._buffer\n                    self._buffer = bytearray()\n                return data\n\n            # Note that no data means the socket is closed and we'll mark that\n            # below\n\n        except socket.timeout as e:\n            # Note that this is implemented differently and though it would be\n            # caught as an EnvironmentError, it has no errno. Not sure whose\n            # fault that is.\n            return None\n\n        except EnvironmentError as e:\n            # thrown if we have a timeout and no data\n            if e.errno in (errno.EAGAIN, errno.EWOULDBLOCK, errno.EINTR):\n                return None\n\n            self.connection.logger.exception(\n                'error reading from %s' % (self._host))\n\n        self.connection.transport_closed(\n            msg='error reading from %s' % (self._host))\n        if e:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef buffer(self, data):\n        '''\n        Buffer unused bytes from the input stream.\n        '''\n        if not hasattr(self, '_sock'):\n            return None\n\n        # data will always be a byte array\n        if len(self._buffer):\n            self._buffer.extend(data)\n        else:\n            self._buffer = bytearray(data)", "response": "Buffer unused bytes from the input stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write(self, data):\n        '''\n        Write some bytes to the transport.\n        '''\n        if not hasattr(self, '_sock'):\n            return None\n\n        try:\n            self._sock.sendall(data)\n\n            if self.connection.debug > 1:\n                self.connection.logger.debug(\n                    'sent %d bytes to %s' % (len(data), self._host))\n\n            return\n        except EnvironmentError:\n            # sockets raise this type of error, and since if sendall() fails\n            # we're left in an indeterminate state, assume that any error we\n            # catch means that the connection is dead. Note that this\n            # assumption requires this to be a blocking socket; if we ever\n            # support non-blocking in this class then this whole method has\n            # to change a lot.\n            self.connection.logger.exception(\n                'error writing to %s' % (self._host))\n\n        self.connection.transport_closed(\n            msg='error writing to %s' % (self._host))", "response": "Write some bytes to the transport."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _cleanup(self):\n        '''\n        Cleanup all the local data.\n        '''\n        self._pending_consumers = None\n        self._consumer_cb = None\n        self._get_cb = None\n        self._recover_cb = None\n        self._cancel_cb = None\n        self._return_listener = None\n        super(BasicClass, self)._cleanup()", "response": "Cleanup all the local data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_return_listener(self, cb):\n        '''\n        Set a callback for basic.return listening. Will be called with a single\n        Message argument.\n\n        The return_info attribute of the Message will have the following\n        properties:\n            'channel': Channel instance\n            'reply_code': reply code (int)\n            'reply_text': reply text\n            'exchange': exchange name\n            'routing_key': routing key\n\n        RabbitMQ NOTE: if the channel was in confirmation mode when the message\n        was published, then basic.return will still be followed by basic.ack\n        later.\n\n        :param cb: callable cb(Message); pass None to reset\n        '''\n        if cb is not None and not callable(cb):\n            raise ValueError('return_listener callback must either be None or '\n                             'a callable, but got: %r' % (cb,))\n        self._return_listener = cb", "response": "Set a callback for basic. return listening. Will be called with a single\n            Message argument."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets QoS on this channel.", "response": "def qos(self, prefetch_size=0, prefetch_count=0, is_global=False):\n        '''\n        Set QoS on this channel.\n        '''\n        args = Writer()\n        args.write_long(prefetch_size).\\\n            write_short(prefetch_count).\\\n            write_bit(is_global)\n        self.send_frame(MethodFrame(self.channel_id, 60, 10, args))\n\n        self.channel.add_synchronous_cb(self._recv_qos_ok)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef consume(self, queue, consumer, consumer_tag='', no_local=False,\n                no_ack=True, exclusive=False, nowait=True, ticket=None,\n                cb=None):\n        '''\n        Start a queue consumer. If `cb` is supplied, will be called when\n        broker confirms that consumer is registered.\n        '''\n        nowait = nowait and self.allow_nowait() and not cb\n\n        if nowait and consumer_tag == '':\n            consumer_tag = self._generate_consumer_tag()\n\n        args = Writer()\n        args.write_short(ticket or self.default_ticket).\\\n            write_shortstr(queue).\\\n            write_shortstr(consumer_tag).\\\n            write_bits(no_local, no_ack, exclusive, nowait).\\\n            write_table({})  # unused according to spec\n        self.send_frame(MethodFrame(self.channel_id, 60, 20, args))\n\n        if not nowait:\n            self._pending_consumers.append((consumer, cb))\n            self.channel.add_synchronous_cb(self._recv_consume_ok)\n        else:\n            self._consumer_cb[consumer_tag] = consumer", "response": "Start a queue consumer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cancel(self, consumer_tag='', nowait=True, consumer=None, cb=None):\n        '''\n        Cancel a consumer. Can choose to delete based on a consumer tag or\n        the function which is consuming.  If deleting by function, take care\n        to only use a consumer once per channel.\n        '''\n        if consumer:\n            tag = self._lookup_consumer_tag_by_consumer(consumer)\n            if tag:\n                consumer_tag = tag\n\n        nowait = nowait and self.allow_nowait() and not cb\n\n        args = Writer()\n        args.write_shortstr(consumer_tag).\\\n            write_bit(nowait)\n        self.send_frame(MethodFrame(self.channel_id, 60, 30, args))\n\n        if not nowait:\n            self._cancel_cb.append(cb)\n            self.channel.add_synchronous_cb(self._recv_cancel_ok)\n        else:\n            self._purge_consumer_by_tag(consumer_tag)", "response": "Cancel a consumer. Can only delete based on a consumer tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlooks up consumer tag given its consumer function", "response": "def _lookup_consumer_tag_by_consumer(self, consumer):\n        '''Look up consumer tag given its consumer function\n\n        NOTE: this protected method may be called by derived classes\n\n        :param callable consumer: consumer function\n\n        :returns: matching consumer tag or None\n        :rtype: str or None\n        '''\n        for (tag, func) in self._consumer_cb.iteritems():\n            if func == consumer:\n                return tag"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npurge consumer entry by consumer tag", "response": "def _purge_consumer_by_tag(self, consumer_tag):\n        '''Purge consumer entry from this basic instance\n\n        NOTE: this protected method may be called by derived classes\n\n        :param str consumer_tag:\n        '''\n        try:\n            del self._consumer_cb[consumer_tag]\n        except KeyError:\n            self.logger.warning(\n                'no callback registered for consumer tag \" %s \"', consumer_tag)\n        else:\n            self.logger.info('purged consumer with tag \" %s \"', consumer_tag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a failed message.", "response": "def return_msg(self, reply_code, reply_text, exchange, routing_key):\n        '''\n        Return a failed message.  Not named \"return\" because python interpreter\n        can't deal with that.\n        '''\n        args = Writer()\n        args.write_short(reply_code).\\\n            write_shortstr(reply_text).\\\n            write_shortstr(exchange).\\\n            write_shortstr(routing_key)\n\n        self.send_frame(MethodFrame(self.channel_id, 60, 50, args))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _recv_return(self, method_frame):\n        '''\n        Handle basic.return method. If we have a complete message, will call the\n        user's return listener callabck (if any). If there are not enough\n        frames, will re-queue current frames and raise a FrameUnderflow\n\n        NOTE: if the channel was in confirmation mode when the message was\n        published, then this will still be followed by basic.ack later\n        '''\n        msg = self._read_returned_msg(method_frame)\n\n        if callable(self._return_listener):\n            self._return_listener(msg)\n        else:\n            self.logger.error(\n                \"Published message returned by broker: info=%s, properties=%s\",\n                msg.return_info, msg.properties)", "response": "Handle a basic. return message."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nask to fetch a single message from a queue.", "response": "def get(self, queue, consumer=None, no_ack=True, ticket=None):\n        '''\n        Ask to fetch a single message from a queue.  If a consumer is supplied,\n        the consumer will be called with either a Message argument, or None if\n        there is no message in queue. If a synchronous transport, Message or\n        None is returned.\n        '''\n        args = Writer()\n        args.write_short(ticket or self.default_ticket).\\\n            write_shortstr(queue).\\\n            write_bit(no_ack)\n\n        self._get_cb.append(consumer)\n        self.send_frame(MethodFrame(self.channel_id, 60, 70, args))\n        return self.channel.add_synchronous_cb(self._recv_get_response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _recv_get_response(self, method_frame):\n        '''\n        Handle either get_ok or get_empty. This is a hack because the\n        synchronous callback stack is expecting one method to satisfy the\n        expectation. To keep that loop as tight as possible, work within\n        those constraints. Use of get is not recommended anyway.\n        '''\n        if method_frame.method_id == 71:\n            return self._recv_get_ok(method_frame)\n        elif method_frame.method_id == 72:\n            return self._recv_get_empty(method_frame)", "response": "Handle either get_ok or get_empty."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ack(self, delivery_tag, multiple=False):\n        '''\n        Acknowledge delivery of a message.  If multiple=True, acknowledge up-to\n        and including delivery_tag.\n        '''\n        args = Writer()\n        args.write_longlong(delivery_tag).\\\n            write_bit(multiple)\n\n        self.send_frame(MethodFrame(self.channel_id, 60, 80, args))", "response": "Acknowledge delivery of a message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef recover(self, requeue=False, cb=None):\n        '''\n        Ask server to redeliver all unacknowledged messages.\n        '''\n        args = Writer()\n        args.write_bit(requeue)\n\n        # The XML spec is incorrect; this method is always synchronous\n        #  http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/2011-January/010738.html\n        self._recover_cb.append(cb)\n        self.send_frame(MethodFrame(self.channel_id, 60, 110, args))\n        self.channel.add_synchronous_cb(self._recv_recover_ok)", "response": "Ask server to redeliver all unacknowledged messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a Message from the current frame buffer.", "response": "def _read_msg(self, method_frame, with_consumer_tag=False,\n                  with_message_count=False):\n        '''\n        Support method to read a Message from the current frame buffer.\n        Will return a Message, or re-queue current frames and raise a\n        FrameUnderflow. Takes an optional argument on whether to read the\n        consumer tag so it can be used for both deliver and get-ok.\n        '''\n        header_frame, body = self._reap_msg_frames(method_frame)\n\n        if with_consumer_tag:\n            consumer_tag = method_frame.args.read_shortstr()\n        delivery_tag = method_frame.args.read_longlong()\n        redelivered = method_frame.args.read_bit()\n        exchange = method_frame.args.read_shortstr()\n        routing_key = method_frame.args.read_shortstr()\n        if with_message_count:\n            message_count = method_frame.args.read_long()\n\n        delivery_info = {\n            'channel': self.channel,\n            'delivery_tag': delivery_tag,\n            'redelivered': redelivered,\n            'exchange': exchange,\n            'routing_key': routing_key,\n        }\n        if with_consumer_tag:\n            delivery_info['consumer_tag'] = consumer_tag\n        if with_message_count:\n            delivery_info['message_count'] = message_count\n\n        return Message(body=body, delivery_info=delivery_info,\n                       **header_frame.properties)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsupports method to read a returned (basic.return) Message from the current frame buffer. Will return a Message with return_info, or re-queue current frames and raise a FrameUnderflow. :returns: Message with the return_info attribute set, where return_info is a dict with the following properties: 'channel': Channel instance 'reply_code': reply code (int) 'reply_text': reply text 'exchange': exchange name 'routing_key': routing key", "response": "def _read_returned_msg(self, method_frame):\n        '''\n        Support method to read a returned (basic.return) Message from the\n        current frame buffer. Will return a Message with return_info, or\n        re-queue current frames and raise a FrameUnderflow.\n\n        :returns: Message with the return_info attribute set, where return_info\n          is a dict with the following properties:\n            'channel': Channel instance\n            'reply_code': reply code (int)\n            'reply_text': reply text\n            'exchange': exchange name\n            'routing_key': routing key\n        '''\n        header_frame, body = self._reap_msg_frames(method_frame)\n\n        return_info = {\n            'channel': self.channel,\n            'reply_code': method_frame.args.read_short(),\n            'reply_text': method_frame.args.read_shortstr(),\n            'exchange': method_frame.args.read_shortstr(),\n            'routing_key': method_frame.args.read_shortstr()\n        }\n\n        return Message(body=body, return_info=return_info,\n                       **header_frame.properties)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _reap_msg_frames(self, method_frame):\n        '''\n        Support method to reap header frame and body from current frame buffer.\n        Used in processing of basic.return, basic.deliver, and basic.get_ok.\n        Will return a pair (<header frame>, <body>), or re-queue current frames\n        and raise a FrameUnderflow.\n\n        :returns: pair (<header frame>, <body>)\n        :rtype: tuple of (HeaderFrame, bytearray)\n        '''\n        # No need to assert that is instance of Header or Content frames\n        # because failure to access as such will result in exception that\n        # channel will pick up and handle accordingly.\n        header_frame = self.channel.next_frame()\n        if header_frame:\n            size = header_frame.size\n            body = bytearray()\n            rbuf_frames = deque([header_frame, method_frame])\n\n            while len(body) < size:\n                content_frame = self.channel.next_frame()\n                if content_frame:\n                    rbuf_frames.appendleft(content_frame)\n                    body.extend(content_frame.payload.buffer())\n                else:\n                    self.channel.requeue_frames(rbuf_frames)\n                    raise self.FrameUnderflow()\n        else:\n            self.channel.requeue_frames([method_frame])\n            raise self.FrameUnderflow()\n\n        return (header_frame, body)", "response": "Support method to reap header frame and body from current frame buffer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npublishing a message. Caller can supply an optional callback which will be fired when the transaction is committed. Tries very hard to avoid closed and inactive channels, but a ChannelError or ConnectionError may still be raised.", "response": "def publish(self, *args, **kwargs):\n        '''\n        Publish a message. Caller can supply an optional callback which will\n        be fired when the transaction is committed. Tries very hard to avoid\n        closed and inactive channels, but a ChannelError or ConnectionError\n        may still be raised.\n        '''\n        user_cb = kwargs.pop('cb', None)\n\n        # If the first channel we grab is inactive, continue fetching until\n        # we get an active channel, then put the inactive channels back in\n        # the pool. Try to keep the overhead to a minimum.\n        channel = self._get_channel()\n\n        if channel and not channel.active:\n            inactive_channels = set()\n            while channel and not channel.active:\n                inactive_channels.add(channel)\n                channel = self._get_channel()\n            self._free_channels.update(inactive_channels)\n\n        # When the transaction is committed, add the channel back to the pool\n        # and call any user-defined callbacks. If there is anything in queue,\n        # pop it and call back to publish(). Only do so if the channel is\n        # still active though, because otherwise the message will end up at\n        # the back of the queue, breaking the original order.\n        def committed():\n            self._free_channels.add(channel)\n            if channel.active and not channel.closed:\n                self._process_queue()\n            if user_cb is not None:\n                user_cb()\n\n        if channel:\n            channel.publish_synchronous(*args, cb=committed, **kwargs)\n        else:\n            kwargs['cb'] = user_cb\n            self._queue.append((args, kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _process_queue(self):\n        '''\n        If there are any message in the queue, process one of them.\n        '''\n        if len(self._queue):\n            args, kwargs = self._queue.popleft()\n            self.publish(*args, **kwargs)", "response": "Process the queue and publish the next message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch a channel from the free pool. Will return a new channel if necessary. Will return None if there is no free channel.", "response": "def _get_channel(self):\n        '''\n        Fetch a channel from the pool. Will return a new one if necessary. If\n        a channel in the free pool is closed, will remove it. Will return None\n        if we hit the cap. Will clean up any channels that were published to\n        but closed due to error.\n        '''\n        while len(self._free_channels):\n            rval = self._free_channels.pop()\n            if not rval.closed:\n                return rval\n            # don't adjust _channels value because the callback will do that\n            # and we don't want to double count it.\n\n        if not self._size or self._channels < self._size:\n            rval = self._connection.channel()\n            self._channels += 1\n            rval.add_close_listener(self._channel_closed_cb)\n            return rval"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_frame(self, buf):\n        '''\n        Write the frame into an existing buffer.\n        '''\n        writer = Writer(buf)\n\n        writer.write_octet(self.type()).\\\n            write_short(self.channel_id).\\\n            write_long(len(self._payload)).\\\n            write(self._payload).\\\n            write_octet(0xce)", "response": "Write the frame into a buffer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connect(self, (host, port)):\n        '''\n        Connect assuming a host and port tuple. Implemented as non-blocking,\n        and will close the transport if there's an error\n        '''\n        self._host = \"%s:%s\" % (host, port)\n        self._sock = EventSocket(\n            read_cb=self._sock_read_cb,\n            close_cb=self._sock_close_cb,\n            error_cb=self._sock_error_cb,\n            debug=self.connection.debug,\n            logger=self.connection.logger)\n        if self.connection._sock_opts:\n            for k, v in self.connection._sock_opts.iteritems():\n                family, type = k\n                self._sock.setsockopt(family, type, v)\n        self._sock.setblocking(False)\n        self._sock.connect(\n            (host, port), timeout=self.connection._connect_timeout)\n        self._heartbeat_timeout = None", "response": "Connects to a specific host and port tuple."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read(self, timeout=None):\n        '''\n        Read from the transport. If no data is available, should return None.\n        The timeout is ignored as this returns only data that has already\n        been buffered locally.\n        '''\n        # NOTE: copying over this comment from Connection, because there is\n        # knowledge captured here, even if the details are stale\n        # Because of the timer callback to dataRead when we re-buffered,\n        # there's a chance that in between we've lost the socket. If that's\n        # the case, just silently return as some code elsewhere would have\n        # already notified us. That bug could be fixed by improving the\n        # message reading so that we consume all possible messages and ensure\n        # that only a partial message was rebuffered, so that we can rely on\n        # the next read event to read the subsequent message.\n        if not hasattr(self, '_sock'):\n            return None\n\n        # This is sort of a hack because we're faking that data is ready, but\n        # it works for purposes of supporting timeouts\n        if timeout:\n            if self._heartbeat_timeout:\n                self._heartbeat_timeout.delete()\n            self._heartbeat_timeout = \\\n                event.timeout(timeout, self._sock_read_cb, self._sock)\n        elif self._heartbeat_timeout:\n            self._heartbeat_timeout.delete()\n            self._heartbeat_timeout = None\n\n        return self._sock.read()", "response": "Read from the transport."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndisconnects from the transport. Typically socket. close.", "response": "def disconnect(self):\n        '''\n        Disconnect from the transport. Typically socket.close(). This call is\n        welcome to raise exceptions, which the Connection will catch.\n\n        The transport is encouraged to allow for any pending writes to complete\n        before closing the socket.\n        '''\n        if not hasattr(self, '_sock'):\n            return\n\n        # TODO: If there are bytes left on the output, queue the close for\n        # later.\n        self._sock.close_cb = None\n        self._sock.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a header frame for a channel given a Reader payload.", "response": "def parse(self, channel_id, payload):\n        '''\n        Parse a header frame for a channel given a Reader payload.\n        '''\n        class_id = payload.read_short()\n        weight = payload.read_short()\n        size = payload.read_longlong()\n        properties = {}\n\n        # The AMQP spec is overly-complex when it comes to handling header\n        # frames. The spec says that in addition to the first 16bit field,\n        # additional ones can follow which /may/ then be in the property list\n        # (because bit flags aren't in the list). Properly implementing custom\n        # values requires the ability change the properties and their types,\n        # which someone is welcome to do, but seriously, what's the point?\n        # Because the complexity of parsing and writing this frame directly\n        # impacts the speed at which messages can be processed, there are two\n        # branches for both a fast parse which assumes no changes to the\n        # properties and a slow parse. For now it's up to someone using custom\n        # headers to flip the flag.\n        if self.DEFAULT_PROPERTIES:\n            flag_bits = payload.read_short()\n            for key, proptype, rfunc, wfunc, mask in self.PROPERTIES:\n                if flag_bits & mask:\n                    properties[key] = rfunc(payload)\n        else:\n            flags = []\n            while True:\n                flag_bits = payload.read_short()\n                flags.append(flag_bits)\n                if flag_bits & 1 == 0:\n                    break\n\n            shift = 0\n            for key, proptype, rfunc, wfunc, mask in self.PROPERTIES:\n                if shift == 0:\n                    if not flags:\n                        break\n                    flag_bits, flags = flags[0], flags[1:]\n                    shift = 15\n                if flag_bits & (1 << shift):\n                    properties[key] = rfunc(payload)\n                shift -= 1\n\n        return HeaderFrame(channel_id, class_id, weight, size, properties)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_frame(self, buf):\n        '''\n        Write the frame into an existing buffer.\n        '''\n        writer = Writer(buf)\n        writer.write_octet(self.type())\n        writer.write_short(self.channel_id)\n\n        # Track the position where we're going to write the total length\n        # of the frame arguments.\n        stream_args_len_pos = len(buf)\n        writer.write_long(0)\n\n        stream_method_pos = len(buf)\n\n        writer.write_short(self._class_id)\n        writer.write_short(self._weight)\n        writer.write_longlong(self._size)\n\n        # Like frame parsing, branch to faster code for default properties\n        if self.DEFAULT_PROPERTIES:\n            # Track the position where we're going to write the flags.\n            flags_pos = len(buf)\n            writer.write_short(0)\n            flag_bits = 0\n            for key, proptype, rfunc, wfunc, mask in self.PROPERTIES:\n                val = self._properties.get(key, None)\n                if val is not None:\n                    flag_bits |= mask\n                    wfunc(writer, val)\n            writer.write_short_at(flag_bits, flags_pos)\n        else:\n            shift = 15\n            flag_bits = 0\n            flags = []\n            stack = deque()\n            for key, proptype, rfunc, wfunc, mask in self.PROPERTIES:\n                val = self._properties.get(key, None)\n                if val is not None:\n                    if shift == 0:\n                        flags.append(flag_bits)\n                        flag_bits = 0\n                        shift = 15\n\n                    flag_bits |= (1 << shift)\n                    stack.append((wfunc, val))\n\n                shift -= 1\n\n            flags.append(flag_bits)\n            for flag_bits in flags:\n                writer.write_short(flag_bits)\n            for method, val in stack:\n                method(writer, val)\n\n        # Write the total length back at the beginning of the frame\n        stream_len = len(buf) - stream_method_pos\n        writer.write_long_at(stream_len, stream_args_len_pos)\n\n        writer.write_octet(0xce)", "response": "Write the current state of the object into a buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads one or more frames from an IO stream.", "response": "def read_frames(cls, reader):\n        '''\n        Read one or more frames from an IO stream.  Buffer must support file\n        object interface.\n\n        After reading, caller will need to check if there are bytes remaining\n        in the stream. If there are, then that implies that there is one or\n        more incomplete frames and more data needs to be read.  The position\n        of the cursor in the frame stream will mark the point at which the\n        last good frame was read. If the caller is expecting a sequence of\n        frames and only received a part of that sequence, they are responsible\n        for buffering those frames until the rest of the frames in the sequence\n        have arrived.\n        '''\n        rval = deque()\n\n        while True:\n            frame_start_pos = reader.tell()\n            try:\n                frame = Frame._read_frame(reader)\n            except Reader.BufferUnderflow:\n                # No more data in the stream\n                frame = None\n            except Reader.ReaderError as e:\n                # Some other format error\n                raise Frame.FormatError, str(e), sys.exc_info()[-1]\n            except struct.error as e:\n                raise Frame.FormatError, str(e), sys.exc_info()[-1]\n\n            if frame is None:\n                reader.seek(frame_start_pos)\n                break\n\n            rval.append(frame)\n\n        return rval"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nunbinds an exchange from another.", "response": "def unbind(self, exchange, source, routing_key='', nowait=True,\n               arguments={}, ticket=None, cb=None):\n        '''\n        Unbind an exchange from another.\n        '''\n        nowait = nowait and self.allow_nowait() and not cb\n\n        args = Writer()\n        args.write_short(ticket or self.default_ticket).\\\n            write_shortstr(exchange).\\\n            write_shortstr(source).\\\n            write_shortstr(routing_key).\\\n            write_bit(nowait).\\\n            write_table(arguments or {})\n        self.send_frame(MethodFrame(self.channel_id, 40, 40, args))\n\n        if not nowait:\n            self._unbind_cb.append(cb)\n            self.channel.add_synchronous_cb(self._recv_unbind_ok)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npublishing a message. Will return the id of the message.", "response": "def publish(self, *args, **kwargs):\n        '''\n        Publish a message. Will return the id of the message if publisher\n        confirmations are enabled, else will return 0.\n        '''\n        if self.channel.confirm._enabled:\n            self._msg_id += 1\n        super(RabbitBasicClass, self).publish(*args, **kwargs)\n        return self._msg_id"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _recv_ack(self, method_frame):\n        '''Receive an ack from the broker.'''\n        if self._ack_listener:\n            delivery_tag = method_frame.args.read_longlong()\n            multiple = method_frame.args.read_bit()\n            if multiple:\n                while self._last_ack_id < delivery_tag:\n                    self._last_ack_id += 1\n                    self._ack_listener(self._last_ack_id)\n            else:\n                self._last_ack_id = delivery_tag\n                self._ack_listener(self._last_ack_id)", "response": "Receive an ack from the broker."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a nack to the broker.", "response": "def nack(self, delivery_tag, multiple=False, requeue=False):\n        '''Send a nack to the broker.'''\n        args = Writer()\n        args.write_longlong(delivery_tag).\\\n            write_bits(multiple, requeue)\n\n        self.send_frame(MethodFrame(self.channel_id, 60, 120, args))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _recv_nack(self, method_frame):\n        '''Receive a nack from the broker.'''\n        if self._nack_listener:\n            delivery_tag = method_frame.args.read_longlong()\n            multiple, requeue = method_frame.args.read_bits(2)\n            if multiple:\n                while self._last_ack_id < delivery_tag:\n                    self._last_ack_id += 1\n                    self._nack_listener(self._last_ack_id, requeue)\n            else:\n                self._last_ack_id = delivery_tag\n                self._nack_listener(self._last_ack_id, requeue)", "response": "Receive a nack from the broker."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef consume(self, queue, consumer, consumer_tag='', no_local=False,\n                no_ack=True, exclusive=False, nowait=True, ticket=None,\n                cb=None, cancel_cb=None):\n        '''Start a queue consumer.\n\n        Accepts the following optional arg in addition to those of\n        `BasicClass.consume()`:\n\n        :param cancel_cb: a callable to be called when the broker cancels the\n          consumer; e.g., when the consumer's queue is deleted. See\n          www.rabbitmq.com/consumer-cancel.html.\n        :type cancel_cb: None or callable with signature cancel_cb(consumer_tag)\n        '''\n        # Register the consumer's broker-cancel callback entry\n        if cancel_cb is not None:\n            if not callable(cancel_cb):\n                raise ValueError('cancel_cb is not callable: %r' % (cancel_cb,))\n\n        if not consumer_tag:\n            consumer_tag = self._generate_consumer_tag()\n\n        self._broker_cancel_cb_map[consumer_tag] = cancel_cb\n\n        # Start consumer\n        super(RabbitBasicClass, self).consume(queue, consumer, consumer_tag,\n                                              no_local, no_ack, exclusive,\n                                              nowait, ticket, cb)", "response": "Start a queue consumer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncancel a consumer. Can only delete by function.", "response": "def cancel(self, consumer_tag='', nowait=True, consumer=None, cb=None):\n        '''\n        Cancel a consumer. Can choose to delete based on a consumer tag or\n        the function which is consuming.  If deleting by function, take care\n        to only use a consumer once per channel.\n        '''\n        # Remove the consumer's broker-cancel callback entry\n        if consumer:\n            tag = self._lookup_consumer_tag_by_consumer(consumer)\n            if tag:\n                consumer_tag = tag\n\n        try:\n            del self._broker_cancel_cb_map[consumer_tag]\n        except KeyError:\n            self.logger.warning(\n                'cancel: no broker-cancel-cb entry for consumer tag %r '\n                '(consumer %r)', consumer_tag, consumer)\n\n        # Cancel consumer\n        super(RabbitBasicClass, self).cancel(consumer_tag, nowait, consumer, cb)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _recv_cancel(self, method_frame):\n        '''Handle Basic.Cancel from broker\n\n        :param MethodFrame method_frame: Basic.Cancel method frame from broker\n        '''\n        self.logger.warning(\"consumer cancelled by broker: %r\", method_frame)\n\n        consumer_tag = method_frame.args.read_shortstr()\n\n        # NOTE: per RabbitMQ spec, no-wait is always true in Basic.Cancel from\n        # broker\n\n        # Remove consumer from this basic instance\n        try:\n            cancel_cb = self._broker_cancel_cb_map.pop(consumer_tag)\n        except KeyError:\n            # Must be a race condition between user's cancel and broker's cancel\n            self.logger.warning(\n                '_recv_cancel: no broker-cancel-cb entry for consumer tag %r',\n                consumer_tag)\n        else:\n            if callable(cancel_cb):\n                # Purge from base class only when user supplies cancel_cb\n                self._purge_consumer_by_tag(consumer_tag)\n\n                # Notify user\n                cancel_cb(consumer_tag)", "response": "Handle Basic. Cancel from broker."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nselect a new entry from the list of available entries.", "response": "def select(self, nowait=True, cb=None):\n        '''\n        Set this channel to use publisher confirmations.\n        '''\n        nowait = nowait and self.allow_nowait() and not cb\n\n        if not self._enabled:\n            self._enabled = True\n            self.channel.basic._msg_id = 0\n            self.channel.basic._last_ack_id = 0\n            args = Writer()\n            args.write_bit(nowait)\n\n            self.send_frame(MethodFrame(self.channel_id, 85, 10, args))\n\n            if not nowait:\n                self._select_cb.append(cb)\n                self.channel.add_synchronous_cb(self._recv_select_ok)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close(self, reply_code=0, reply_text='', class_id=0, method_id=0):\n        '''\n        Close this channel.  Routes to channel.close.\n        '''\n        # In the off chance that we call this twice. A good example is if\n        # there's an error in close listeners and so we're still inside a\n        # single call to process_frames, which will try to close this channel\n        # if there's an exception.\n        if hasattr(self, 'channel'):\n            self.channel.close(reply_code, reply_text, class_id, method_id)", "response": "Closes this channel. Routes to channel. close."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_frames(self):\n        '''\n        Process the input buffer.\n        '''\n        while len(self._frame_buffer):\n            # It would make sense to call next_frame, but it's\n            # technically faster to repeat the code here.\n            frame = self._frame_buffer.popleft()\n\n            if self._emergency_close_pending:\n                # Implement stability rule from AMQP 0.9.1 section 1.5.2.5.\n                # Method channel.close: \"After sending this method, any\n                # received methods except Close and Close-OK MUST be discarded.\"\n                #\n                # NOTE: presently, we limit our implementation of the rule to\n                # the \"emergency close\" scenario to avoid potential adverse\n                # side-effect during normal user-initiated close\n                if (not isinstance(frame, MethodFrame) or\n                      frame.class_id != self.channel.CLASS_ID or\n                      frame.method_id not in (self.channel.CLOSE_METHOD_ID,\n                                              self.channel.CLOSE_OK_METHOD_ID)):\n                    self.logger.warn(\"Emergency channel close: dropping input \"\n                                     \"frame %.255s\", frame)\n                    continue\n            try:\n                self.dispatch(frame)\n            except ProtocolClass.FrameUnderflow:\n                return\n            except (ConnectionClosed, ChannelClosed):\n                # Immediately raise if connection or channel is closed\n                raise\n            except Exception:\n                self.logger.exception(\n                    \"Closing on failed dispatch of frame %.255s\", frame)\n\n                # Spec says that channel should be closed if there's a framing\n                # error. Unsure if we can send close if the current exception\n                # is transport level (e.g. gevent.GreenletExit)\n                self._emergency_close_pending = True\n\n                # Preserve the original exception and traceback during cleanup,\n                # only allowing system-exiting exceptions (e.g., SystemExit,\n                # KeyboardInterrupt) to override it\n                try:\n                    raise\n                finally:\n                    try:\n                        self.close(500, \"Failed to dispatch %s\" % (str(frame)))\n                    except Exception:\n                        # Suppress secondary non-system-exiting exception in\n                        # favor of the original exception\n                        self.logger.exception(\"Channel close failed\")\n                        pass", "response": "Process the input buffer and dispatch the next frame."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_frame(self, frame):\n        '''\n        Queue a frame for sending.  Will send immediately if there are no\n        pending synchronous transactions on this connection.\n        '''\n        if self.closed:\n            if self.close_info and len(self.close_info['reply_text']) > 0:\n                raise ChannelClosed(\n                    \"channel %d is closed: %s : %s\",\n                    self.channel_id,\n                    self.close_info['reply_code'],\n                    self.close_info['reply_text'])\n            raise ChannelClosed()\n\n        # If there's any pending event at all, then it means that when the\n        # current dispatch loop started, all possible frames were flushed\n        # and the remaining item(s) starts with a sync callback. After careful\n        # consideration, it seems that it's safe to assume the len>0 means to\n        # buffer the frame. The other advantage here is\n        if not len(self._pending_events):\n            if not self._active and \\\n                    isinstance(frame, (ContentFrame, HeaderFrame)):\n                raise Channel.Inactive(\n                    \"Channel %d flow control activated\", self.channel_id)\n            self._connection.send_frame(frame)\n        else:\n            self._pending_events.append(frame)", "response": "Queue a frame for sending. Will send immediately if there are pending synchronous transactions on this connection. Will send immediately if there are pending synchronous transactions on this connection. Will send immediately if there are pending synchronous transactions on this connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an expectation of a callback to release a synchronous transaction.", "response": "def add_synchronous_cb(self, cb):\n        '''\n        Add an expectation of a callback to release a synchronous transaction.\n        '''\n        if self.connection.synchronous or self._synchronous:\n            wrapper = SyncWrapper(cb)\n            self._pending_events.append(wrapper)\n            while wrapper._read:\n                # Don't check that the channel has been closed until after\n                # reading frames, in the case that this is processing a clean\n                # channel closed. If there's a protocol error during\n                # read_frames, this will loop back around and result in a\n                # channel closed exception.\n                if self.closed:\n                    if self.close_info and \\\n                            len(self.close_info['reply_text']) > 0:\n                        raise ChannelClosed(\n                            \"channel %d is closed: %s : %s\",\n                            self.channel_id,\n                            self.close_info['reply_code'],\n                            self.close_info['reply_text'])\n                    raise ChannelClosed()\n                self.connection.read_frames()\n\n            return wrapper._result\n        else:\n            self._pending_events.append(cb)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clear_synchronous_cb(self, cb):\n        '''\n        If the callback is the current expected callback, will clear it off the\n        stack.  Else will raise in exception if there's an expectation but this\n        doesn't satisfy it.\n        '''\n        if len(self._pending_events):\n            ev = self._pending_events[0]\n\n            # We can't have a strict check using this simple mechanism,\n            # because we could be waiting for a synch response while messages\n            # are being published. So for now, if it's not in the list, do a\n            # check to see if the callback is in the pending list, and if so,\n            # then raise, because it means we received stuff out of order.\n            # Else just pass it through. Note that this situation could happen\n            # on any broker-initiated message.\n            if ev == cb:\n                self._pending_events.popleft()\n                self._flush_pending_events()\n                return ev\n\n            elif cb in self._pending_events:\n                raise ChannelError(\n                    \"Expected synchronous callback %s, got %s\", ev, cb)\n        # Return the passed-in callback by default\n        return cb", "response": "Clear the synchronous callback for the current node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _flush_pending_events(self):\n        '''\n        Send pending frames that are in the event queue.\n        '''\n        while len(self._pending_events) and \\\n                isinstance(self._pending_events[0], Frame):\n            self._connection.send_frame(self._pending_events.popleft())", "response": "Send pending frames that are in the event queue."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _closed_cb(self, final_frame=None):\n        '''\n        \"Private\" callback from the ChannelClass when a channel is closed. Only\n        called after broker initiated close, or we receive a close_ok. Caller\n        has the option to send a final frame, to be used to bypass any\n        synchronous or otherwise-pending frames so that the channel can be\n        cleanly closed.\n        '''\n        # delete all pending data and send final frame if thre is one. note\n        # that it bypasses send_frame so that even if the closed state is set,\n        # the frame is published.\n        if final_frame:\n            self._connection.send_frame(final_frame)\n\n        try:\n            self._notify_close_listeners()\n        finally:\n            self._pending_events = deque()\n            self._frame_buffer = deque()\n\n            # clear out other references for faster cleanup\n            for protocol_class in self._class_map.values():\n                protocol_class._cleanup()\n                delattr(self, protocol_class.name)\n            self._connection = None\n            self._class_map = None\n            self._close_listeners = set()", "response": "Private callback from the ChannelClass when a channel is closed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconnecting using a host and port tuple", "response": "def connect(self, (host, port)):\n        '''\n        Connect using a host,port tuple\n        '''\n        super(GeventTransport, self).connect((host, port), klass=socket.socket)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading from the transport.", "response": "def read(self, timeout=None):\n        '''\n        Read from the transport. If no data is available, should return None.\n        If timeout>0, will only block for `timeout` seconds.\n        '''\n        # If currently locked, another greenlet is trying to read, so yield\n        # control and then return none. Required if a Connection is configured\n        # to be synchronous, a sync callback is trying to read, and there's\n        # another read loop running read_frames. Without it, the run loop will\n        # release the lock but then immediately acquire it again. Yielding\n        # control in the reading thread after bytes are read won't fix\n        # anything, because it's quite possible the bytes read resulted in a\n        # frame that satisfied the synchronous callback, and so this needs to\n        # return immediately to first check the current status of synchronous\n        # callbacks before attempting to read again.\n        if self._read_lock.locked():\n            self._read_wait.wait(timeout)\n            return None\n\n        self._read_lock.acquire()\n        try:\n            return super(GeventTransport, self).read(timeout=timeout)\n        finally:\n            self._read_lock.release()\n            self._read_wait.set()\n            self._read_wait.clear()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuffer unused bytes from the input stream.", "response": "def buffer(self, data):\n        '''\n        Buffer unused bytes from the input stream.\n        '''\n        self._read_lock.acquire()\n        try:\n            return super(GeventTransport, self).buffer(data)\n        finally:\n            self._read_lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write(self, data):\n        '''\n        Write some bytes to the transport.\n        '''\n        # MUST use a lock here else gevent could raise an exception if 2\n        # greenlets try to write at the same time. I was hoping that\n        # sendall() would do that blocking for me, but I guess not. May\n        # require an eventsocket-like buffer to speed up under high load.\n        self._write_lock.acquire()\n        try:\n            return super(GeventTransport, self).write(data)\n        finally:\n            self._write_lock.release()", "response": "Write some bytes to the transport."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef process_channels(self, channels):\n        '''\n        Process a set of channels by calling Channel.process_frames() on each.\n        Some transports may choose to do this in unique ways, such as through\n        a pool of threads.\n\n        The default implementation will simply iterate over them and call\n        process_frames() on each.\n        '''\n        for channel in channels:\n            self._pool.spawn(channel.process_frames)", "response": "Process a set of channels by calling Channel. process_frames on each."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndispatch a method for this protocol.", "response": "def dispatch(self, method_frame):\n        '''\n        Dispatch a method for this protocol.\n        '''\n        method = self.dispatch_map.get(method_frame.method_id)\n        if method:\n            callback = self.channel.clear_synchronous_cb(method)\n            callback(method_frame)\n        else:\n            raise self.InvalidMethod(\n                \"no method is registered with id: %d\" % method_frame.method_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef seek(self, offset, whence=0):\n        '''\n        Simple seek. Follows standard interface.\n        '''\n        if whence == 0:\n            self._pos = self._start_pos + offset\n        elif whence == 1:\n            self._pos += offset\n        else:\n            self._pos = (self._end_pos - 1) + offset", "response": "Simple seek. Follows standard interface."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nraising BufferUnderflow if there s not enough bytes to satisfy the request.", "response": "def _check_underflow(self, n):\n        '''\n        Raise BufferUnderflow if there's not enough bytes to satisfy\n        the request.\n        '''\n        if self._pos + n > self._end_pos:\n            raise self.BufferUnderflow()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef buffer(self):\n        '''\n        Get a copy of the buffer that this is reading from. Returns a\n        buffer object\n        '''\n        return buffer(self._input, self._start_pos,\n                      (self._end_pos - self._start_pos))", "response": "Return a copy of the buffer that this object is reading from. Returns a copy of the buffer that this object is reading from. Returns a copy of the buffer object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread n bytes from the internal buffer. Will raise BufferUnderflow if there isn t enough bytes in the buffer.", "response": "def read(self, n):\n        \"\"\"\n        Read n bytes.\n\n        Will raise BufferUnderflow if there's not enough bytes in the buffer.\n        \"\"\"\n        self._check_underflow(n)\n        rval = self._input[self._pos:self._pos + n]\n        self._pos += n\n        return rval"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread a single boolean value. Returns 0 or 1. Convience for single bit fields. Will raise BufferUnderflow if there s not enough bytes in the buffer.", "response": "def read_bit(self):\n        \"\"\"\n        Read a single boolean value, returns 0 or 1. Convience for single\n        bit fields.\n\n        Will raise BufferUnderflow if there's not enough bytes in the buffer.\n        \"\"\"\n        # Perform a faster check on underflow\n        if self._pos >= self._end_pos:\n            raise self.BufferUnderflow()\n        result = ord(self._input[self._pos]) & 1\n        self._pos += 1\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads several bits packed into the same field. Will return as a list.", "response": "def read_bits(self, num):\n        '''\n        Read several bits packed into the same field. Will return as a list.\n        The bit field itself is little-endian, though the order of the\n        returned array looks big-endian for ease of decomposition.\n\n        Reader('\\x02').read_bits(2) -> [False,True]\n        Reader('\\x08').read_bits(2) ->\n            [False,True,False,False,False,False,False,False]\n        first_field, second_field = Reader('\\x02').read_bits(2)\n\n        Will raise BufferUnderflow if there's not enough bytes in the buffer.\n        Will raise ValueError if num < 0 or num > 9\n        '''\n        # Perform a faster check on underflow\n        if self._pos >= self._end_pos:\n            raise self.BufferUnderflow()\n        if num < 0 or num >= 9:\n            raise ValueError(\"8 bits per field\")\n        field = ord(self._input[self._pos])\n        result = map(lambda x: field >> x & 1, xrange(num))\n        self._pos += 1\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading one byte from the internal buffer and return it as an integer.", "response": "def read_octet(self, unpacker=Struct('B').unpack_from,\n                   size=Struct('B').size):\n        \"\"\"\n        Read one byte, return as an integer\n\n        Will raise BufferUnderflow if there's not enough bytes in the buffer.\n        Will raise struct.error if the data is malformed\n        \"\"\"\n        # Technically should look at unpacker.size, but skipping that is way\n        # faster and this method is the most-called of the readers\n        if self._pos >= self._end_pos:\n            raise self.BufferUnderflow()\n        rval = unpacker(self._input, self._pos)[0]\n        self._pos += size\n        return rval"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_short(self, unpacker=Struct('>H').unpack_from,\n                   size=Struct('>H').size):\n        \"\"\"\n        Read an unsigned 16-bit integer\n\n        Will raise BufferUnderflow if there's not enough bytes in the buffer.\n        Will raise struct.error if the data is malformed\n        \"\"\"\n        self._check_underflow(size)\n        rval = unpacker(self._input, self._pos)[0]\n        self._pos += size\n        return rval", "response": "Read an unsigned 16 - bit integer from the internal buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_table(self):\n        # Only need to check underflow on the table once\n        tlen = self.read_long()\n        self._check_underflow(tlen)\n        end_pos = self._pos + tlen\n        result = {}\n        while self._pos < end_pos:\n            name = self._field_shortstr()\n            result[name] = self._read_field()\n        return result", "response": "Read an AMQP table and return as a Python dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _read_field(self):\n        '''\n        Read a single byte for field type, then read the value.\n        '''\n        ftype = self._input[self._pos]\n        self._pos += 1\n\n        reader = self.field_type_map.get(ftype)\n        if reader:\n            return reader(self)\n\n        raise Reader.FieldError('Unknown field type %s', ftype)", "response": "Reads a single byte for the field type and returns the value."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nopens the channel for communication.", "response": "def open(self):\n        '''\n        Open the channel for communication.\n        '''\n        args = Writer()\n        args.write_shortstr('')\n        self.send_frame(MethodFrame(self.channel_id, 20, 10, args))\n        self.channel.add_synchronous_cb(self._recv_open_ok)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _send_flow(self, active):\n        '''\n        Send a flow control command.\n        '''\n        args = Writer()\n        args.write_bit(active)\n        self.send_frame(MethodFrame(self.channel_id, 20, 20, args))\n        self.channel.add_synchronous_cb(self._recv_flow_ok)", "response": "Send a flow control command."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreceiving a flow control command from the broker", "response": "def _recv_flow(self, method_frame):\n        '''\n        Receive a flow control command from the broker\n        '''\n        self.channel._active = method_frame.args.read_bit()\n\n        args = Writer()\n        args.write_bit(self.channel.active)\n        self.send_frame(MethodFrame(self.channel_id, 20, 21, args))\n\n        if self._flow_control_cb is not None:\n            self._flow_control_cb()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreceiving a flow control ack from the broker.", "response": "def _recv_flow_ok(self, method_frame):\n        '''\n        Receive a flow control ack from the broker.\n        '''\n        self.channel._active = method_frame.args.read_bit()\n        if self._flow_control_cb is not None:\n            self._flow_control_cb()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncloses this channel. Caller has the option of specifying the reason for closure and the class and method ids of the current frame in which an error occurred. If in the event of an exception, the channel will be marked as immediately closed. If channel is already closed, call is ignored.", "response": "def close(self, reply_code=0, reply_text='', class_id=0, method_id=0):\n        '''\n        Close this channel.  Caller has the option of specifying the reason for\n        closure and the class and method ids of the current frame in which an\n        error occurred.  If in the event of an exception, the channel will be\n        marked as immediately closed.  If channel is already closed, call is\n        ignored.\n        '''\n        if not getattr(self, 'channel', None) or self.channel._closed:\n            return\n\n        self.channel._close_info = {\n            'reply_code': reply_code,\n            'reply_text': reply_text,\n            'class_id': class_id,\n            'method_id': method_id\n        }\n\n        # exceptions here likely due to race condition as connection is closing\n        # cap the reply_text we send because it may be arbitrarily long\n        try:\n            args = Writer()\n            args.write_short(reply_code)\n            args.write_shortstr(reply_text[:255])\n            args.write_short(class_id)\n            args.write_short(method_id)\n            self.send_frame(MethodFrame(self.channel_id, 20, 40, args))\n\n            self.channel.add_synchronous_cb(self._recv_close_ok)\n        finally:\n            # Immediately set the closed flag so no more frames can be sent\n            # NOTE: in synchronous mode, by the time this is called we will\n            # have already run self.channel._closed_cb and so the channel\n            # reference is gone.\n            if self.channel:\n                self.channel._closed = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _recv_close(self, method_frame):\n        '''\n        Receive a close command from the broker.\n        '''\n        self.channel._close_info = {\n            'reply_code': method_frame.args.read_short(),\n            'reply_text': method_frame.args.read_shortstr(),\n            'class_id': method_frame.args.read_short(),\n            'method_id': method_frame.args.read_short()\n        }\n\n        self.channel._closed = True\n        self.channel._closed_cb(\n            final_frame=MethodFrame(self.channel_id, 20, 41))", "response": "Receive a close command from the broker."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _recv_close_ok(self, method_frame):\n        '''\n        Receive a close ack from the broker.\n        '''\n        self.channel._closed = True\n        self.channel._closed_cb()", "response": "Receive a close ack from the broker."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbinding to a queue.", "response": "def bind(self, queue, exchange, routing_key='', nowait=True, arguments={},\n             ticket=None, cb=None):\n        '''\n        bind to a queue.\n        '''\n        nowait = nowait and self.allow_nowait() and not cb\n\n        args = Writer()\n        args.write_short(ticket or self.default_ticket).\\\n            write_shortstr(queue).\\\n            write_shortstr(exchange).\\\n            write_shortstr(routing_key).\\\n            write_bit(nowait).\\\n            write_table(arguments)\n        self.send_frame(MethodFrame(self.channel_id, 50, 20, args))\n\n        if not nowait:\n            self._bind_cb.append(cb)\n            self.channel.add_synchronous_cb(self._recv_bind_ok)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unbind(self, queue, exchange, routing_key='', arguments={},\n               ticket=None, cb=None):\n        '''\n        Unbind a queue from an exchange.  This is always synchronous.\n        '''\n        args = Writer()\n        args.write_short(ticket or self.default_ticket).\\\n            write_shortstr(queue).\\\n            write_shortstr(exchange).\\\n            write_shortstr(routing_key).\\\n            write_table(arguments)\n        self.send_frame(MethodFrame(self.channel_id, 50, 50, args))\n\n        self._unbind_cb.append(cb)\n        self.channel.add_synchronous_cb(self._recv_unbind_ok)", "response": "Unbind a queue from an exchange."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npurging all messages in a queue.", "response": "def purge(self, queue, nowait=True, ticket=None, cb=None):\n        '''\n        Purge all messages in a queue.\n        '''\n        nowait = nowait and self.allow_nowait() and not cb\n\n        args = Writer()\n        args.write_short(ticket or self.default_ticket).\\\n            write_shortstr(queue).\\\n            write_bit(nowait)\n        self.send_frame(MethodFrame(self.channel_id, 50, 30, args))\n\n        if not nowait:\n            self._purge_cb.append(cb)\n            return self.channel.add_synchronous_cb(self._recv_purge_ok)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_bits(self, *args):\n        '''\n        Write multiple bits in a single byte field. The bits will be written in\n        little-endian order, but should be supplied in big endian order. Will\n        raise ValueError when more than 8 arguments are supplied.\n\n        write_bits(True, False) => 0x02\n        '''\n        # Would be nice to make this a bit smarter\n        if len(args) > 8:\n            raise ValueError(\"Can only write 8 bits at a time\")\n\n        self._output_buffer.append(chr(\n            reduce(lambda x, y: xor(x, args[y] << y), xrange(len(args)), 0)))\n\n        return self", "response": "Write multiple bits in a single byte field."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_bit(self, b, pack=Struct('B').pack):\n        '''\n        Write a single bit. Convenience method for single bit args.\n        '''\n        self._output_buffer.append(pack(True if b else False))\n        return self", "response": "Write a single bit. Convenience method for single bit args."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites an integer as an unsigned 8 - bit value.", "response": "def write_octet(self, n, pack=Struct('B').pack):\n        \"\"\"\n        Write an integer as an unsigned 8-bit value.\n        \"\"\"\n        if 0 <= n <= 255:\n            self._output_buffer.append(pack(n))\n        else:\n            raise ValueError('Octet %d out of range 0..255', n)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites an unsigned 16 - bit integer to the internal buffer.", "response": "def write_short(self, n, pack=Struct('>H').pack):\n        \"\"\"\n        Write an integer as an unsigned 16-bit value.\n        \"\"\"\n        if 0 <= n <= 0xFFFF:\n            self._output_buffer.extend(pack(n))\n        else:\n            raise ValueError('Short %d out of range 0..0xFFFF', n)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite an unsigned 16bit value at a specific position in the buffer.", "response": "def write_short_at(self, n, pos, pack_into=Struct('>H').pack_into):\n        '''\n        Write an unsigned 16bit value at a specific position in the buffer.\n        Used for writing tables and frames.\n        '''\n        if 0 <= n <= 0xFFFF:\n            pack_into(self._output_buffer, pos, n)\n        else:\n            raise ValueError('Short %d out of range 0..0xFFFF', n)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_long(self, n, pack=Struct('>I').pack):\n        if 0 <= n <= 0xFFFFFFFF:\n            self._output_buffer.extend(pack(n))\n        else:\n            raise ValueError('Long %d out of range 0..0xFFFFFFFF', n)\n        return self", "response": "Write an unsigned 32 - bit integer to the internal buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites an unsigned 32bit value at a specific position in the buffer.", "response": "def write_long_at(self, n, pos, pack_into=Struct('>I').pack_into):\n        '''\n        Write an unsigned 32bit value at a specific position in the buffer.\n        Used for writing tables and frames.\n        '''\n        if 0 <= n <= 0xFFFFFFFF:\n            pack_into(self._output_buffer, pos, n)\n        else:\n            raise ValueError('Long %d out of range 0..0xFFFFFFFF', n)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_longlong(self, n, pack=Struct('>Q').pack):\n        if 0 <= n <= 0xFFFFFFFFFFFFFFFF:\n            self._output_buffer.extend(pack(n))\n        else:\n            raise ValueError(\n                'Longlong %d out of range 0..0xFFFFFFFFFFFFFFFF', n)\n        return self", "response": "Writes an unsigned 64 - bit integer to the internal buffer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_shortstr(self, s):\n        if isinstance(s, unicode):\n            s = s.encode('utf-8')\n        self.write_octet(len(s))\n        self.write(s)\n        return self", "response": "Writes a string up to 255 bytes long after encoding."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite out a Python datetime. datetime object as a 64 - bit integer representing seconds since the Unix UTC epoch.", "response": "def write_timestamp(self, t, pack=Struct('>Q').pack):\n        \"\"\"\n        Write out a Python datetime.datetime object as a 64-bit integer\n        representing seconds since the Unix UTC epoch.\n        \"\"\"\n        # Double check timestamp, can't imagine why it would be signed\n        self._output_buffer.extend(pack(long(timegm(t.timetuple()))))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite out a Python dictionary made of up string keys and values that are strings signed integers Decimal datetime. datetime or or sub - dictionaries.", "response": "def write_table(self, d):\n        \"\"\"\n        Write out a Python dictionary made of up string keys, and values\n        that are strings, signed integers, Decimal, datetime.datetime, or\n        sub-dictionaries following the same constraints.\n        \"\"\"\n        # HACK: encoding of AMQP tables is broken because it requires the\n        # length of the /encoded/ data instead of the number of items. To\n        # support streaming, fiddle with cursor position, rewinding to write\n        # the real length of the data. Generally speaking, I'm not a fan of\n        # the AMQP encoding scheme, it could be much faster.\n        table_len_pos = len(self._output_buffer)\n        self.write_long(0)\n        table_data_pos = len(self._output_buffer)\n\n        for key, value in d.iteritems():\n            self._write_item(key, value)\n\n        table_end_pos = len(self._output_buffer)\n        table_len = table_end_pos - table_data_pos\n\n        self.write_long_at(table_len, table_len_pos)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_log_callback(callback):\n    global _log_callbacks\n\n    if not callable(callback):\n        raise ValueError(\"Callback must be callable\")\n\n    _log_callbacks.add(callback)\n    return callback", "response": "Adds a log callback."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread the specified number of bytes from the stream.", "response": "def read(self, size):\n        \"\"\"Attempts to read data from the stream.\n\n        :param size: int, The maximum amount of bytes to read.\n\n        Raises :exc:`IOError` on error.\n        \"\"\"\n        # If enabled tell the server that our buffer can fit the whole\n        # stream, this often increases throughput alot.\n        if self._update_buffer and not self._updated_buffer and self.duration:\n            self.update_buffer((self.duration * 1000) + 5000)\n            self._updated_buffer = True\n\n        if not self._buf or len(self._buf) != size:\n            self._buf = ffi.new(\"char[]\", size)\n            self._view = ffi.buffer(self._buf, size)\n\n        res = librtmp.RTMP_Read(self.client.rtmp, self._buf, size)\n\n        if res < 0:\n            raise IOError(\"Failed to read data\")\n\n        return self._view[:res]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite data to the stream.", "response": "def write(self, data):\n        \"\"\"Writes data to the stream.\n\n        :param data: bytes, FLV data to write to the stream\n\n        The data passed can contain multiple FLV tags, but it MUST\n        always contain complete tags or undefined behaviour might\n        occur.\n\n        Raises :exc:`IOError` on error.\n        \"\"\"\n        if isinstance(data, bytearray):\n            data = bytes(data)\n\n        if not isinstance(data, byte_types):\n            raise ValueError(\"A bytes argument is required\")\n\n        res = librtmp.RTMP_Write(self.client.rtmp, data, len(data))\n\n        if res < 0:\n            raise IOError(\"Failed to write data\")\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nattempting to seek in the stream.", "response": "def seek(self, time):\n        \"\"\"Attempts to seek in the stream.\n\n        :param time: int, Time to seek to in seconds\n\n        \"\"\"\n        res = librtmp.RTMP_SendSeek(self.client.rtmp, time)\n\n        if res < 1:\n            raise RTMPError(\"Failed to seek\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntell the server how big our buffer is ( in milliseconds.", "response": "def update_buffer(self, ms):\n        \"\"\"Tells the server how big our buffer is (in milliseconds).\"\"\"\n        librtmp.RTMP_SetBufferMS(self.client.rtmp, int(ms))\n        librtmp.RTMP_UpdateBufferMS(self.client.rtmp)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_option(self, key, value):\n\n        akey = AVal(key)\n        aval = AVal(value)\n\n        res = librtmp.RTMP_SetOpt(self.rtmp, akey.aval, aval.aval)\n\n        if res < 1:\n            raise ValueError(\"Unable to set option {0}\".format(key))\n\n        self._options[akey] = aval", "response": "Sets a option for this session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setup_url(self, url):\n\n        self.url = bytes(url, \"utf8\")\n\n        res = librtmp.RTMP_SetupURL(self.rtmp, self.url)\n        if res < 1:\n            raise RTMPError(\"Unable to parse URL\")", "response": "r Attempt to parse a RTMP URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connect(self, packet=None):\n\n        if isinstance(packet, RTMPPacket):\n            packet = packet.packet\n        else:\n            packet = ffi.NULL\n\n        res = librtmp.RTMP_Connect(self.rtmp, packet)\n        if res < 1:\n            raise RTMPError(\"Failed to connect\")\n\n        return RTMPCall(self, 1.0)", "response": "Connect to the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npreparing the session for streaming of audio and video cancelling.", "response": "def create_stream(self, seek=None, writeable=False, update_buffer=True):\n        \"\"\"Prepares the session for streaming of audio/video\n           and returns a :class:`RTMPStream` object.\n\n        :param seek: int, Attempt to seek to this position.\n        :param writeable: bool, Make the stream writeable instead of readable.\n        :param update_buffer: bool, When enabled will attempt to speed up\n                              download by telling the server our buffer can\n                              fit the whole stream.\n\n        Raises :exc:`RTMPError` if a stream could not be created.\n\n        Usage::\n\n          >>> stream = conn.create_stream()\n          >>> data = stream.read(1024)\n        \"\"\"\n\n        if writeable:\n            librtmp.RTMP_EnableWrite(self.rtmp)\n\n        # Calling handle_packet() on a connect result causes\n        # librtmp to send a CreateStream call. This is not always\n        # desired when using process_packets(), therefore we do it\n        # here instead.\n        if self._connect_result:\n            self.handle_packet(self._connect_result)\n\n        if not seek:\n            seek = 0\n\n        res = librtmp.RTMP_ConnectStream(self.rtmp, seek)\n        if res < 1:\n            raise RTMPError(\"Failed to start RTMP playback\")\n\n        return RTMPStream(self, update_buffer=update_buffer)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads a RTMP packet from the server.", "response": "def read_packet(self):\n        \"\"\"Reads a RTMP packet from the server.\n\n        Returns a :class:`RTMPPacket`.\n\n        Raises :exc:`RTMPError` on error.\n        Raises :exc:`RTMPTimeoutError` on timeout.\n\n        Usage::\n\n          >>> packet = conn.read_packet()\n          >>> packet.body\n          b'packet body ...'\n        \"\"\"\n\n        packet = ffi.new(\"RTMPPacket*\")\n        packet_complete = False\n\n        while not packet_complete:\n            res = librtmp.RTMP_ReadPacket(self.rtmp, packet)\n\n            if res < 1:\n                if librtmp.RTMP_IsTimedout(self.rtmp):\n                    raise RTMPTimeoutError(\"Timed out while reading packet\")\n                else:\n                    raise RTMPError(\"Failed to read packet\")\n\n            packet_complete = packet.m_nBytesRead == packet.m_nBodySize\n\n        return RTMPPacket._from_pointer(packet)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a RTMP packet to the server.", "response": "def send_packet(self, packet, queue=True):\n        \"\"\"Sends a RTMP packet to the server.\n\n        :param packet: RTMPPacket, the packet to send to the server.\n        :param queue: bool, If True, queue up the packet in a internal queue rather\n                      than sending it right away.\n\n        \"\"\"\n\n        if not isinstance(packet, RTMPPacket):\n            raise ValueError(\"A RTMPPacket argument is required\")\n\n        return librtmp.RTMP_SendPacket(self.rtmp, packet.packet,\n                                       int(queue))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlets librtmp look at a packet and send a response if needed.", "response": "def handle_packet(self, packet):\n        \"\"\"Lets librtmp look at a packet and send a response\n           if needed.\"\"\"\n\n        if not isinstance(packet, RTMPPacket):\n            raise ValueError(\"A RTMPPacket argument is required\")\n\n        return librtmp.RTMP_ClientPacket(self.rtmp, packet.packet)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwait for packets and process them as needed.", "response": "def process_packets(self, transaction_id=None, invoked_method=None,\n                        timeout=None):\n        \"\"\"Wait for packets and process them as needed.\n\n        :param transaction_id: int, Wait until the result of this\n                               transaction ID is recieved.\n        :param invoked_method: int, Wait until this method is invoked\n                               by the server.\n        :param timeout: int, The time to wait for a result from the server.\n                             Note: This is the timeout used by this method only,\n                             the connection timeout is still used when reading\n                             packets.\n\n        Raises :exc:`RTMPError` on error.\n        Raises :exc:`RTMPTimeoutError` on timeout.\n\n        Usage::\n\n          >>> @conn.invoke_handler\n          ... def add(x, y):\n          ...   return x + y\n\n          >>> @conn.process_packets()\n\n        \"\"\"\n\n        start = time()\n\n        while self.connected and transaction_id not in self._invoke_results:\n            if timeout and (time() - start) >= timeout:\n                raise RTMPTimeoutError(\"Timeout\")\n\n            packet = self.read_packet()\n\n            if packet.type == PACKET_TYPE_INVOKE:\n                try:\n                    decoded = decode_amf(packet.body)\n                except AMFError:\n                    continue\n\n                try:\n                    method, transaction_id_, obj = decoded[:3]\n                    args = decoded[3:]\n                except ValueError:\n                    continue\n\n                if method == \"_result\":\n                    if len(args) > 0:\n                        result = args[0]\n                    else:\n                        result = None\n\n                    self._invoke_results[transaction_id_] = result\n                else:\n                    handler = self._invoke_handlers.get(method)\n                    if handler:\n                        res = handler(*args)\n                        if res is not None:\n                            self.call(\"_result\", res,\n                                      transaction_id=transaction_id_)\n\n                    if method == invoked_method:\n                        self._invoke_args[invoked_method] = args\n                        break\n\n                if transaction_id_ == 1.0:\n                    self._connect_result = packet\n                else:\n                    self.handle_packet(packet)\n            else:\n                self.handle_packet(packet)\n\n        if transaction_id:\n            result = self._invoke_results.pop(transaction_id, None)\n\n            return result\n\n        if invoked_method:\n            args = self._invoke_args.pop(invoked_method, None)\n\n            return args"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef call(self, method, *args, **params):\n\n        transaction_id = params.get(\"transaction_id\")\n\n        if not transaction_id:\n            self.transaction_id += 1\n            transaction_id = self.transaction_id\n\n        obj = params.get(\"obj\")\n\n        args = [method, transaction_id, obj] + list(args)\n        args_encoded = map(lambda x: encode_amf(x), args)\n        body = b\"\".join(args_encoded)\n\n        format = params.get(\"format\", PACKET_SIZE_MEDIUM)\n        channel = params.get(\"channel\", 0x03)\n\n        packet = RTMPPacket(type=PACKET_TYPE_INVOKE,\n                            format=format, channel=channel,\n                            body=body)\n\n        self.send_packet(packet)\n\n        return RTMPCall(self, transaction_id)", "response": "Calls a method on the server."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a Python function that will attempt to call a remote method when used.", "response": "def remote_method(self, method, block=False, **params):\n        \"\"\"Creates a Python function that will attempt to\n           call a remote method when used.\n\n        :param method: str, Method name on the server to call\n        :param block: bool, Wheter to wait for result or not\n\n        Usage::\n\n          >>> send_usher_token = conn.remote_method(\"NetStream.Authenticate.UsherToken\", block=True)\n          >>> send_usher_token(\"some token\")\n          'Token Accepted'\n        \"\"\"\n\n        def func(*args):\n            call = self.call(method, *args, **params)\n\n            if block:\n                return call.result()\n\n            return call\n\n        func.__name__ = method\n\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving the result of the call.", "response": "def result(self, timeout=None):\n        \"\"\"Retrieves the result of the call.\n\n        :param timeout: The time to wait for a result from the server.\n\n        Raises :exc:`RTMPTimeoutError` on timeout.\n        \"\"\"\n        if self.done:\n            return self._result\n\n        result = self.conn.process_packets(transaction_id=self.transaction_id,\n                                           timeout=timeout)\n\n        self._result = result\n        self.done = True\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a signal handler to handle KeyboardInterrupt.", "response": "def add_signal_handler():\n    \"\"\"Adds a signal handler to handle KeyboardInterrupt.\"\"\"\n    import signal\n\n    def handler(sig, frame):\n        if sig == signal.SIGINT:\n            librtmp.RTMP_UserInterrupt()\n            raise KeyboardInterrupt\n\n    signal.signal(signal.SIGINT, handler)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset initial values form existing self. data value", "response": "def set_initial_values(self):\n        \"\"\"Set initial values form existing self.data value\n        :return: None\n        \"\"\"\n        self.normals = self.data['normals']\n        self.vectors = numpy.ones((\n            self.data['vectors'].shape[0],\n            self.data['vectors'].shape[1],\n            self.data['vectors'].shape[2] + 1\n        ))\n        self.vectors[:, :, :-1] = self.data['vectors']\n        self.attr = self.data['attr']\n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rotate_x(self, deg):\n        rad = math.radians(deg)\n        mat = numpy.array([\n            [1, 0, 0, 0],\n            [0, math.cos(rad), math.sin(rad), 0],\n            [0, -math.sin(rad), math.cos(rad), 0],\n            [0, 0, 0, 1]\n        ])\n        self.vectors = self.vectors.dot(mat)\n        return self", "response": "Rotate the mesh around x - axis."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntranslates mesh for x - direction", "response": "def translate_x(self, d):\n        \"\"\"Translate mesh for x-direction\n\n        :param float d: Amount to translate\n        \"\"\"\n        mat = numpy.array([\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [d, 0, 0, 1]\n        ])\n        self.vectors = self.vectors.dot(mat)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntranslating mesh for y - direction", "response": "def translate_y(self, d):\n        \"\"\"Translate mesh for y-direction\n\n        :param float d: Amount to translate\n        \"\"\"\n        mat = numpy.array([\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, d, 0, 1]\n        ])\n        self.vectors = self.vectors.dot(mat)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntranslating mesh for z - direction", "response": "def translate_z(self, d):\n        \"\"\"Translate mesh for z-direction\n\n        :param float d: Amount to translate\n        \"\"\"\n        mat = numpy.array([\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, d, 1]\n        ])\n        self.vectors = self.vectors.dot(mat)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nscales the mesh by the given x - and y - and z - direction.", "response": "def scale(self, sx, sy, sz):\n        \"\"\"Scale mesh\n\n        :param float sx: Amount to scale for x-direction\n        :param float sy: Amount to scale for y-direction\n        :param float sz: Amount to scale for z-direction\n        \"\"\"\n        mat = numpy.array([\n            [sx, 0, 0, 0],\n            [0, sy, 0, 0],\n            [0, 0, sz, 0],\n            [0, 0, 0, 1]\n        ])\n        self.vectors = self.vectors.dot(mat)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the signed volume of a list of triangle", "response": "def __calc_signed_volume(triangle):\n        \"\"\" Calculate signed volume of given triangle\n        :param list of list triangle:\n        :rtype float\n        \"\"\"\n        v321 = triangle[2][0] * triangle[1][1] * triangle[0][2]\n        v231 = triangle[1][0] * triangle[2][1] * triangle[0][2]\n        v312 = triangle[2][0] * triangle[0][1] * triangle[1][2]\n        v132 = triangle[0][0] * triangle[2][1] * triangle[1][2]\n        v213 = triangle[1][0] * triangle[0][1] * triangle[2][2]\n        v123 = triangle[0][0] * triangle[1][1] * triangle[2][2]\n\n        signed_volume = (-v321 + v231 + v312 - v132 - v213 + v123) / 6.0\n        return signed_volume"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving data with stl format.", "response": "def save_stl(self, path, mode=MODE_STL_AUTO, update_normals=True):\n        \"\"\"Save data with stl format\n        :param str path:\n        :param int mode:\n        :param bool update_normals:\n        \"\"\"\n        if update_normals:\n            self.update_normals()\n\n        filename = os.path.split(path)[-1]\n\n        if mode is MODE_STL_AUTO:\n            if self.mode == MODE_STL_BINARY:\n                save_func = self.__save_stl_binary\n\n            elif self.mode == MODE_STL_ASCII:\n                save_func = self.__save_stl_ascii\n\n            else:\n                raise ValueError(\"Mode %r is invalid\" % mode)\n\n        elif mode is MODE_STL_BINARY:\n            save_func = self.__save_stl_binary\n\n        else:\n            raise ValueError(\"Mode %r is invalid\" % mode)\n\n        with open(path, 'wb') as fh:\n            save_func(fh, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves data with OBJ format", "response": "def save_obj(self, path, update_normals=True):\n        \"\"\"Save data with OBJ format\n        :param stl path:\n        :param bool update_normals:\n        \"\"\"\n        if update_normals:\n            self.update_normals()\n\n        # Create triangle_list\n        vectors_key_list = []\n        vectors_list = []\n        normals_key_list = []\n        normals_list = []\n        triangle_list = []\n        for i, vector in enumerate(self.vectors):\n            one_triangle = []\n            for j in range(3):\n                v_key = \",\".join(map(str, self.vectors[i][j][:3]))\n                if v_key in vectors_key_list:\n                    v_index = vectors_key_list.index(v_key)\n                else:\n                    v_index = len(vectors_key_list)\n                    vectors_key_list.append(v_key)\n                    vectors_list.append(self.vectors[i][j][:3])\n                one_triangle.append(v_index + 1)\n\n            n_key = \",\".join(map(str, self.normals[i][:3]))\n            if n_key in normals_key_list:\n                n_index = normals_key_list.index(n_key)\n            else:\n                n_index = len(normals_key_list)\n                normals_key_list.append(n_key)\n                normals_list.append(self.normals[i][:3])\n\n            # print(normals_list)\n            triangle_list.append((one_triangle, n_index + 1))\n\n        with open(path, \"wb\") as fh:\n            print(\"# {} {}\".format(__title__, __version__), file=fh)\n            print(\"# {}\".format(datetime.datetime.now()), file=fh)\n            print(\"# {}\".format(__url__), file=fh)\n            print(\"\", file=fh)\n            for v in vectors_list:\n                print(\"v {} {} {}\".format(v[0], v[1], v[2]), file=fh)\n            for vn in normals_list:\n                print(\"vn {} {} {}\".format(vn[0], vn[1], vn[2]), file=fh)\n            for t in triangle_list:\n                faces = t[0]\n                normal = t[1]\n\n                print(\"f {}//{} {}//{} {}//{}\".format(\n                    faces[0], normal,\n                    faces[1], normal,\n                    faces[2], normal,\n                ), file=fh)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __load(fh, mode=MODE_AUTO):\n        header = fh.read(Stl.HEADER_SIZE).lower()\n        name = \"\"\n        data = None\n        if not header.strip():\n            return\n\n        if mode in (Stl.MODE_AUTO, Stl.MODE_ASCII) and header.startswith('solid'):\n            try:\n                name = header.split('\\n', 1)[0][:5].strip()\n                data = Stl.__load_ascii(fh, header)\n                mode = Stl.MODE_ASCII\n\n            except:\n                pass\n\n        else:\n            data = Stl.__load_binary(fh)\n            mode = Stl.MODE_BINARY\n\n        return name, data, mode", "response": "Load the Mesh from STL file and return the name data and mode."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __ascii_reader(fh, header):\n\n        lines = header.split('\\n')\n        recoverable = [True]\n\n        def get(prefix=''):\n            if lines:\n                line = lines.pop(0)\n            else:\n                raise RuntimeError(recoverable[0], 'Unable to find more lines')\n\n            if not lines:\n                recoverable[0] = False\n\n                # Read more lines and make sure we prepend any old data\n                lines[:] = fh.read(Stl.BUFFER_SIZE).split('\\n')\n                line += lines.pop(0)\n            line = line.lower().strip()\n            if prefix:\n                if line.startswith(prefix):\n                    values = line.replace(prefix, '', 1).strip().split()\n                elif line.startswith('endsolid'):\n                    raise StopIteration()\n                else:\n                    raise RuntimeError(recoverable[0],\n                                       '%r should start with %r' % (line,\n                                                                    prefix))\n\n                if len(values) == 3:\n                    vertex = [float(v) for v in values]\n                    return vertex\n                else:  # pragma: no cover\n                    raise RuntimeError(recoverable[0],\n                                       'Incorrect value %r' % line)\n            else:\n                return line\n\n        line = get()\n        if not line.startswith('solid ') and line.startswith('solid'):\n            print(\"Error\")\n\n        if not lines:\n            raise RuntimeError(recoverable[0],\n                               'No lines found, impossible to read')\n\n        while True:\n            # Read from the header lines first, until that point we can recover\n            # and go to the binary option. After that we cannot due to\n            # unseekable files such as sys.stdin\n            #\n            # Numpy doesn't support any non-file types so wrapping with a\n            # buffer and/or StringIO does not work.\n            try:\n                normals = get('facet normal')\n                assert get() == 'outer loop'\n                v0 = get('vertex')\n                v1 = get('vertex')\n                v2 = get('vertex')\n                assert get() == 'endloop'\n                assert get() == 'endfacet'\n                attrs = 0\n                yield (normals, (v0, v1, v2), attrs)\n            except AssertionError as e:\n                raise RuntimeError(recoverable[0], e)\n            except StopIteration:\n                if any(lines):\n                    # Seek back to where the next solid should begin\n                    fh.seek(-len('\\n'.join(lines)), os.SEEK_CUR)\n                raise", "response": "This function is used to read an ASCII file from the file handle fh."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the steppy logger.", "response": "def initialize_logger():\n    \"\"\"Initialize steppy logger.\n\n    This logger is used throughout the steppy library to report computation progress.\n\n    Example:\n    \n        Simple use of steppy logger:\n\n        .. code-block:: python\n        \n            initialize_logger()\n            logger = get_logger()\n            logger.info('My message inside pipeline')\n            \n        result looks like this:\n        \n        .. code::\n        \n            2018-06-02 12:33:48 steppy >>> My message inside pipeline\n\n    Returns:\n        logging.Logger: logger object formatted in the steppy style\n    \"\"\"\n    logger = logging.getLogger('steppy')\n    logger.setLevel(logging.INFO)\n    message_format = logging.Formatter(fmt='%(asctime)s %(name)s >>> %(message)s',\n                                       datefmt='%Y-%m-%d %H:%M:%S')\n\n    # console handler\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setLevel(logging.INFO)\n    console_handler.setFormatter(fmt=message_format)\n\n    # add the handlers to the logger\n    logger.addHandler(console_handler)\n\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef display_upstream_structure(structure_dict):\n    graph = _create_graph(structure_dict)\n    plt = Image(graph.create_png())\n    display(plt)", "response": "Displays the upstream structure in the jupyter notebook."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves the pipeline diagram to disk as png file.", "response": "def persist_as_png(structure_dict, filepath):\n    \"\"\"Saves pipeline diagram to disk as png file.\n\n    Args:\n        structure_dict (dict): dict returned by\n            :func:`~steppy.base.Step.upstream_structure`\n        filepath (str): filepath to which the png with pipeline visualization should be persisted\n    \"\"\"\n    graph = _create_graph(structure_dict)\n    graph.write(filepath, format='png')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a pydot graph from the pipeline structure dict.", "response": "def _create_graph(structure_dict):\n    \"\"\"Creates pydot graph from the pipeline structure dict.\n\n    Args:\n        structure_dict (dict): dict returned by step.upstream_structure\n\n    Returns:\n        graph (pydot.Dot): object representing upstream pipeline structure (with regard to the current Step).\n    \"\"\"\n    graph = pydot.Dot()\n    for node in structure_dict['nodes']:\n        graph.add_node(pydot.Node(node))\n    for node1, node2 in structure_dict['edges']:\n        graph.add_edge(pydot.Edge(node1, node2))\n    return graph"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef adapt(self, all_ouputs: AllOutputs) -> DataPacket:\n        adapted = {}\n        for name, recipe in self.adapting_recipes.items():\n            adapted[name] = self._construct(all_ouputs, recipe)\n        return adapted", "response": "Adapt inputs for the transformer included in the step."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef upstream_structure(self):\n        structure_dict = {'edges': set(),\n                          'nodes': set()}\n        structure_dict = self._build_structure_dict(structure_dict)\n        return structure_dict", "response": "Build a dictionary describing the upstream pipeline structure."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfit the model and transform data or load already processed data.", "response": "def fit_transform(self, data):\n        \"\"\"Fit the model and transform data or load already processed data.\n\n        Loads cached or persisted output or adapts data for the current transformer and\n        executes ``transformer.fit_transform``.\n\n        Args:\n            data (dict): data dictionary with keys as input names and values as dictionaries of\n                key-value pairs that can be passed to the ``self.transformer.fit_transform`` method.\n                Example:\n\n                .. code-block:: python\n\n                    data = {'input_1': {'X': X,\n                                        'y': y},\n                            'input_2': {'X': X,\n                                        'y': y}\n                            }\n\n        Returns:\n            dict: Step output from the ``self.transformer.fit_transform`` method\n        \"\"\"\n        if data:\n            assert isinstance(data, dict), 'Step {}, \"data\" argument in the \"fit_transform()\" method must be dict, ' \\\n                                           'got {} instead.'.format(self.name, type(data))\n        logger.info('Step {}, working in \"{}\" mode'.format(self.name, self._mode))\n\n        if self._mode == 'inference':\n            ValueError('Step {}, you are in \"{}\" mode, where you cannot run \"fit\".'\n                       'Please change mode to \"train\" to enable fitting.'\n                       'Use: \"step.set_mode_train()\" then \"step.fit_transform()\"'.format(self.name, self._mode))\n\n        if self.output_is_cached and not self.force_fitting:\n            logger.info('Step {} using cached output'.format(self.name))\n            step_output_data = self.output\n        elif self.output_is_persisted and self.load_persisted_output and not self.force_fitting:\n            logger.info('Step {} loading persisted output from {}'.format(self.name,\n                                                                          self.experiment_directory_output_step))\n            step_output_data = self._load_output(self.experiment_directory_output_step)\n        else:\n            step_inputs = {}\n            if self.input_data is not None:\n                for input_data_part in self.input_data:\n                    step_inputs[input_data_part] = data[input_data_part]\n\n            for input_step in self.input_steps:\n                step_inputs[input_step.name] = input_step.fit_transform(data)\n\n            if self.adapter:\n                step_inputs = self._adapt(step_inputs)\n            else:\n                step_inputs = self._unpack(step_inputs)\n            step_output_data = self._fit_transform_operation(step_inputs)\n        logger.info('Step {}, fit and transform completed'.format(self.name))\n        return step_output_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreset all upstream Steps to the default training parameters and cleans cache for all upstream Steps including this Step.", "response": "def reset(self):\n        \"\"\"Reset all upstream Steps to the default training parameters and\n        cleans cache for all upstream Steps including this Step.\n        Defaults are:\n            'mode': 'train',\n            'is_fittable': True,\n            'force_fitting': True,\n            'persist_output': False,\n            'cache_output': False,\n            'load_persisted_output': False\n        \"\"\"\n        self.clean_cache_upstream()\n        self.set_mode_train()\n        for step_obj in self.all_upstream_steps.values():\n            step_obj.is_fittable = DEFAULT_TRAINING_SETUP['is_fittable']\n            step_obj.force_fitting = DEFAULT_TRAINING_SETUP['force_fitting']\n            step_obj.persist_output = DEFAULT_TRAINING_SETUP['persist_output']\n            step_obj.cache_output = DEFAULT_TRAINING_SETUP['cache_output']\n            step_obj.load_persisted_output = DEFAULT_TRAINING_SETUP['load_persisted_output']\n        logger.info('Step {}, reset all upstream Steps to default training parameters, '\n                    'including this Step'.format(self.name))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_parameters_upstream(self, parameters):\n        assert isinstance(parameters, dict), 'parameters must be dict, got {} instead'.format(type(parameters))\n        for step_obj in self.all_upstream_steps.values():\n            for key in step_obj.__dict__.keys():\n                if key in list(parameters.keys()):\n                    step_obj.__dict__[key] = parameters[key]\n                    if key == 'experiment_directory':\n                        step_obj._prepare_experiment_directories()\n        logger.info('set new values to all upstream Steps including this Step.')\n        return self", "response": "Set parameters to all upstream Steps including this Step."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclean cache for current step.", "response": "def clean_cache_step(self):\n        \"\"\"Clean cache for current step.\n        \"\"\"\n        logger.info('Step {}, cleaning cache'.format(self.name))\n        self.output = None\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clean_cache_upstream(self):\n        logger.info('Cleaning cache for the entire upstream pipeline')\n        for step in self.all_upstream_steps.values():\n            logger.info('Step {}, cleaning cache'.format(step.name))\n            step.output = None\n        return self", "response": "Clean cache for all upstream steps."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting a step by name from the pipeline.", "response": "def get_step_by_name(self, name):\n        \"\"\"Extracts step by name from the pipeline.\n\n        Extracted Step is a fully functional pipeline as well.\n        All upstream Steps are already defined.\n\n        Args:\n            name (str): name of the step to be fetched\n        Returns:\n            Step (obj): extracted step\n        \"\"\"\n        self._validate_step_name(name)\n        name = str(name)\n        try:\n            return self.all_upstream_steps[name]\n        except KeyError as e:\n            msg = 'No Step with name \"{}\" found. ' \\\n                  'You have following Steps: {}'.format(name, list(self.all_upstream_steps.keys()))\n            raise StepError(msg) from e"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npersists the upstream steps structure to the json file with the upstream steps names and their connections.", "response": "def persist_upstream_structure(self):\n        \"\"\"Persist json file with the upstream steps structure, that is step names and their connections.\"\"\"\n        persist_dir = os.path.join(self.experiment_directory, '{}_upstream_structure.json'.format(self.name))\n        logger.info('Step {}, saving upstream pipeline structure to {}'.format(self.name, persist_dir))\n        joblib.dump(self.upstream_structure, persist_dir)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef persist_upstream_diagram(self, filepath):\n        assert isinstance(filepath, str),\\\n            'Step {} error, filepath must be str. Got {} instead'.format(self.name, type(filepath))\n        persist_as_png(self.upstream_structure, filepath)", "response": "Creates upstream steps diagram and persists it to disk as png file under the filepath directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nperforms fit followed by transform.", "response": "def fit_transform(self, *args, **kwargs):\n        \"\"\"Performs fit followed by transform.\n\n        This method simply combines fit and transform.\n\n        Args:\n            args: positional arguments (can be anything)\n            kwargs: keyword arguments (can be anything)\n\n        Returns:\n            dict: output\n        \"\"\"\n        self.fit(*args, **kwargs)\n        return self.transform(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning full URL for specified API endpoint", "response": "def url(self, endpoint):\n    \"\"\"\n    Returns full URL for specified API endpoint\n    >>> translate = YandexTranslate(\"trnsl.1.1.20130421T140201Z.323e508a33e9d84b.f1e0d9ca9bcd0a00b0ef71d82e6cf4158183d09e\")\n    >>> translate.url(\"langs\")\n    'https://translate.yandex.net/api/v1.5/tr.json/getLangs'\n    >>> translate.url(\"detect\")\n    'https://translate.yandex.net/api/v1.5/tr.json/detect'\n    >>> translate.url(\"translate\")\n    'https://translate.yandex.net/api/v1.5/tr.json/translate'\n    \"\"\"\n    return self.api_url.format(version=self.api_version,\n                               endpoint=self.api_endpoints[endpoint])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning list with translate directions", "response": "def directions(self, proxies=None):\n    \"\"\"\n    Returns list with translate directions\n    >>> translate = YandexTranslate(\"trnsl.1.1.20130421T140201Z.323e508a33e9d84b.f1e0d9ca9bcd0a00b0ef71d82e6cf4158183d09e\")\n    >>> directions = translate.directions\n    >>> len(directions) > 0\n    True\n    \"\"\"\n    try:\n      response = requests.get(self.url(\"langs\"), params={\"key\": self.api_key}, proxies=proxies)\n    except requests.exceptions.ConnectionError:\n      raise YandexTranslateException(self.error_codes[503])\n    else:\n      response = response.json()\n    status_code = response.get(\"code\", 200)\n    if status_code != 200:\n      raise YandexTranslateException(status_code)\n    return response.get(\"dirs\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetecting language of text.", "response": "def detect(self, text, proxies=None, format=\"plain\"):\n    \"\"\"\n    Specifies language of text\n    >>> translate = YandexTranslate(\"trnsl.1.1.20130421T140201Z.323e508a33e9d84b.f1e0d9ca9bcd0a00b0ef71d82e6cf4158183d09e\")\n    >>> result = translate.detect(text=\"Hello world!\")\n    >>> result == \"en\"\n    True\n    \"\"\"\n    data = {\n      \"text\": text,\n      \"format\": format,\n      \"key\": self.api_key,\n    }\n    try:\n      response = requests.post(self.url(\"detect\"), data=data, proxies=proxies)\n    except ConnectionError:\n      raise YandexTranslateException(self.error_codes[503])\n    except ValueError:\n      raise YandexTranslateException(response)\n    else:\n      response = response.json()\n    language = response.get(\"lang\", None)\n    status_code = response.get(\"code\", 200)\n    if status_code != 200:\n      raise YandexTranslateException(status_code)\n    elif not language:\n      raise YandexTranslateException(501)\n    return language"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntranslates text to passed language", "response": "def translate(self, text, lang, proxies=None, format=\"plain\"):\n    \"\"\"\n    Translates text to passed language\n    >>> translate = YandexTranslate(\"trnsl.1.1.20130421T140201Z.323e508a33e9d84b.f1e0d9ca9bcd0a00b0ef71d82e6cf4158183d09e\")\n    >>> result = translate.translate(lang=\"ru\", text=\"Hello, world!\")\n    >>> result[\"code\"] == 200\n    True\n    >>> result[\"lang\"] == \"en-ru\"\n    True\n    \"\"\"\n    data = {\n      \"text\": text,\n      \"format\": format,\n      \"lang\": lang,\n      \"key\": self.api_key\n    }\n    try:\n      response = requests.post(self.url(\"translate\"), data=data, proxies=proxies)\n    except ConnectionError:\n      raise YandexTranslateException(503)\n    else:\n      response = response.json()\n    status_code = response.get(\"code\", 200)\n    if status_code != 200:\n      raise YandexTranslateException(status_code)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a HOTP code.", "response": "def generate_hotp(secret, counter=4):\n    \"\"\"Generate a HOTP code.\n\n    :param secret: A secret token for the authentication.\n    :param counter: HOTP is a counter based algorithm.\n    \"\"\"\n    # https://tools.ietf.org/html/rfc4226\n    msg = struct.pack('>Q', counter)\n    digest = hmac.new(to_bytes(secret), msg, hashlib.sha1).digest()\n\n    ob = digest[19]\n    if PY2:\n        ob = ord(ob)\n\n    pos = ob & 15\n    base = struct.unpack('>I', digest[pos:pos + 4])[0] & 0x7fffffff\n    token = base % 1000000\n    return token"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_totp(secret, period=30, timestamp=None):\n    if timestamp is None:\n        timestamp = time.time()\n    counter = int(timestamp) // period\n    return generate_hotp(secret, counter)", "response": "Generate a TOTP code."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef valid_hotp(self, code, last=0, trials=100):\n        if not valid_code(code):\n            return False\n\n        code = bytes(int(code))\n        for i in range(last + 1, last + trials + 1):\n            if compare_digest(bytes(self.hotp(counter=i)), code):\n                return i\n        return False", "response": "Validate a HOTP code."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate a TOTP code.", "response": "def valid_totp(self, code, period=30, timestamp=None):\n        \"\"\"Valid a TOTP code.\n\n        :param code: A number that is less than 6 characters.\n        :param period: A period that a TOTP code is valid in seconds\n        :param timestamp: Validate TOTP at this given timestamp\n        \"\"\"\n        if not valid_code(code):\n            return False\n        return compare_digest(\n            bytes(self.totp(period, timestamp)),\n            bytes(int(code))\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the otpauth protocal string.", "response": "def to_uri(self, type, label, issuer, counter=None):\n        \"\"\"Generate the otpauth protocal string.\n\n        :param type: Algorithm type, hotp or totp.\n        :param label: Label of the identifier.\n        :param issuer: The company, the organization or something else.\n        :param counter: Counter of the HOTP algorithm.\n        \"\"\"\n        type = type.lower()\n\n        if type not in ('hotp', 'totp'):\n            raise ValueError('type must be hotp or totp')\n\n        if type == 'hotp' and not counter:\n            raise ValueError('HOTP type authentication need counter')\n\n        # https://code.google.com/p/google-authenticator/wiki/KeyUriFormat\n        url = ('otpauth://%(type)s/%(label)s?secret=%(secret)s'\n               '&issuer=%(issuer)s')\n        dct = dict(\n            type=type, label=label, issuer=issuer,\n            secret=self.encoded_secret, counter=counter\n        )\n        ret = url % dct\n        if type == 'hotp':\n            ret = '%s&counter=%s' % (ret, counter)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate the otpauth protocal string for Google Authenticator.", "response": "def to_google(self, type, label, issuer, counter=None):\n        \"\"\"Generate the otpauth protocal string for Google Authenticator.\n\n        .. deprecated:: 0.2.0\n           Use :func:`to_uri` instead.\n        \"\"\"\n        warnings.warn('deprecated, use to_uri instead', DeprecationWarning)\n        return self.to_uri(type, label, issuer, counter)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_jaro_distance(first, second, winkler=True, winkler_ajustment=True, scaling=0.1):\n    if not first or not second:\n        raise JaroDistanceException(\"Cannot calculate distance from NoneType ({0}, {1})\".format(\n            first.__class__.__name__,\n            second.__class__.__name__))\n\n    jaro = _score(first, second)\n    cl = min(len(_get_prefix(first, second)), 4)\n\n    if all([winkler, winkler_ajustment]):  # 0.1 as scaling factor\n        return round((jaro + (scaling * cl * (1.0 - jaro))) * 100.0) / 100.0\n\n    return jaro", "response": "Calculates the jaro distance between two words."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninstalling an exchange rates backend using a python path string", "response": "def install(self, backend='money.exchange.SimpleBackend'):\n        \"\"\"Install an exchange rates backend using a python path string\"\"\"\n        # RADAR: Python2\n        if isinstance(backend, money.six.string_types):\n            path, name = backend.rsplit('.', 1)\n            module = importlib.import_module(path)\n            backend = getattr(module, name)()\n        elif isinstance(backend, type):\n            backend = backend()\n        if not isinstance(backend, BackendBase):\n            raise TypeError(\"backend '{}' is not a subclass of \"\n                            \"money.xrates.BackendBase\".format(backend))\n        self._backend = backend"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns quotation between the base and another currency", "response": "def rate(self, currency):\n        \"\"\"Return quotation between the base and another currency\"\"\"\n        if not self._backend:\n            raise ExchangeBackendNotInstalled()\n        return self._backend.rate(currency)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning quotation between two currencies", "response": "def quotation(self, origin, target):\n        \"\"\"Return quotation between two currencies (origin, target)\"\"\"\n        if not self._backend:\n            raise ExchangeBackendNotInstalled()\n        return self._backend.quotation(origin, target)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _register_scatter():\n\n    @functools.wraps(PathCollection.__init__)\n    def __init__(self, *args, **kwargs):\n        _nonscatter_pathcollections.add(self)\n        return __init__.__wrapped__(self, *args, **kwargs)\n    PathCollection.__init__ = __init__\n\n    @functools.wraps(Axes.scatter)\n    def scatter(*args, **kwargs):\n        paths = scatter.__wrapped__(*args, **kwargs)\n        with suppress(KeyError):\n            _nonscatter_pathcollections.remove(paths)\n        return paths\n    Axes.scatter = scatter", "response": "Patch PathCollection and scatter to register their return values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomputing the projection of a artist on a path.", "response": "def _compute_projection_pick(artist, path, xy):\n    \"\"\"\n    Project *xy* on *path* to obtain a `Selection` for *artist*.\n\n    *path* is first transformed to screen coordinates using the artist\n    transform, and the target of the returned `Selection` is transformed\n    back to data coordinates using the artist *axes* inverse transform.  The\n    `Selection` `index` is returned as a float.  This function returns ``None``\n    for degenerate inputs.\n\n    The caller is responsible for converting the index to the proper class if\n    needed.\n    \"\"\"\n    transform = artist.get_transform().frozen()\n    tpath = (path.cleaned(transform) if transform.is_affine\n             # `cleaned` only handles affine transforms.\n             else transform.transform_path(path).cleaned())\n    # `cleaned` should return a path where the first element is `MOVETO`, the\n    # following are `LINETO` or `CLOSEPOLY`, and the last one is `STOP`, i.e.\n    #     codes = path.codes\n    #     assert (codes[0], codes[-1]) == (path.MOVETO, path.STOP)\n    #     assert np.in1d(codes[1:-1], [path.LINETO, path.CLOSEPOLY]).all()\n    vertices = tpath.vertices[:-1]\n    codes = tpath.codes[:-1]\n    vertices[codes == tpath.CLOSEPOLY] = vertices[0]\n    # Unit vectors for each segment.\n    us = vertices[1:] - vertices[:-1]\n    ls = np.hypot(*us.T)\n    with np.errstate(invalid=\"ignore\"):\n        # Results in 0/0 for repeated consecutive points.\n        us /= ls[:, None]\n    # Vectors from each vertex to the event (overwritten below).\n    vs = xy - vertices[:-1]\n    # Clipped dot products -- `einsum` cannot be done in place, `clip` can.\n    # `clip` can trigger invalid comparisons if there are nan points.\n    with np.errstate(invalid=\"ignore\"):\n        dot = np.clip(np.einsum(\"ij,ij->i\", vs, us), 0, ls, out=vs[:, 0])\n    # Projections.\n    projs = vertices[:-1] + dot[:, None] * us\n    ds = np.hypot(*(xy - projs).T, out=vs[:, 1])\n    try:\n        argmin = np.nanargmin(ds)\n        dmin = ds[argmin]\n    except (ValueError, IndexError):  # See above re: exceptions caught.\n        return\n    else:\n        target = AttrArray(\n            artist.axes.transData.inverted().transform_point(projs[argmin]))\n        target.index = (\n            (argmin + dot[argmin] / ls[argmin])\n            / (path._interpolation_steps / tpath._interpolation_steps))\n        return Selection(artist, target, dmin, None, None)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning data coordinates to place an annotation at screen coordinates *screen_xy* in axes *ax*. *orig_xy* are the \"original\" coordinates as stored by the artist; they are transformed to *screen_xy* by whatever transform the artist uses. If the artist uses ``ax.transData``, just return *orig_xy*; else, apply ``ax.transData.inverse()`` to *screen_xy*. (The first case is more accurate than always applying ``ax.transData.inverse()``.)", "response": "def _untransform(orig_xy, screen_xy, ax):\n    \"\"\"\n    Return data coordinates to place an annotation at screen coordinates\n    *screen_xy* in axes *ax*.\n\n    *orig_xy* are the \"original\" coordinates as stored by the artist; they are\n    transformed to *screen_xy* by whatever transform the artist uses.  If the\n    artist uses ``ax.transData``, just return *orig_xy*; else, apply\n    ``ax.transData.inverse()`` to *screen_xy*.  (The first case is more\n    accurate than always applying ``ax.transData.inverse()``.)\n    \"\"\"\n    tr_xy = ax.transData.transform(orig_xy)\n    return (\n        orig_xy\n        if ((tr_xy == screen_xy) | np.isnan(tr_xy) & np.isnan(screen_xy)).all()\n        else ax.transData.inverted().transform(screen_xy))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _call_with_selection(func):\n    wrapped_kwonly_params = [\n        param for param in inspect.signature(func).parameters.values()\n        if param.kind == param.KEYWORD_ONLY]\n    sel_sig = inspect.signature(Selection)\n    default_sel_sig = sel_sig.replace(\n        parameters=[param.replace(default=None) if param.default is param.empty\n                    else param\n                    for param in sel_sig.parameters.values()])\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        extra_kw = {param.name: kwargs.pop(param.name)\n                    for param in wrapped_kwonly_params if param.name in kwargs}\n        ba = default_sel_sig.bind(*args, **kwargs)\n        # apply_defaults\n        ba.arguments = ChainMap(\n            ba.arguments,\n            {name: param.default\n             for name, param in default_sel_sig.parameters.items()\n             if param.default is not param.empty})\n        sel = Selection(*ba.args, **ba.kwargs)\n        return func(sel, **extra_kw)\n\n    wrapper.__signature__ = Signature(\n        list(sel_sig.parameters.values()) + wrapped_kwonly_params)\n    return wrapper", "response": "Decorator that passes a Selection built from the non - kwonly args."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _set_valid_props(artist, kwargs):\n    artist.set(**{k: kwargs[k] for k in kwargs if hasattr(artist, \"set_\" + k)})\n    return artist", "response": "Set valid properties for the artist dropping the others."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to(self, currency):\n        if currency == self._currency:\n            return self\n        rate = xrates.quotation(self._currency, currency)\n        if rate is None:\n            raise ExchangeRateNotFound(xrates.backend_name,\n                                         self._currency, currency)\n        amount = self._amount * rate\n        return self.__class__(amount, currency)", "response": "Return equivalent money object in another currency"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format(self, locale=LC_NUMERIC, pattern=None, currency_digits=True,\n               format_type='standard'):\n        \"\"\"\n        Return a locale-aware, currency-formatted string.\n        \n        This method emulates babel.numbers.format_currency().\n        \n        A specific locale identifier (language[_territory]) can be passed,\n        otherwise the system's default locale will be used. A custom\n        formatting pattern of the form \"\u00a4#,##0.00;(\u00a4#,##0.00)\"\n        (positive[;negative]) can also be passed, otherwise it will be\n        determined from the locale and the CLDR (Unicode Common Locale Data\n        Repository) included with Babel.\n        \n        >>> m = Money('1234.567', 'EUR')\n        >>> m.format() # assuming the system's locale is 'en_US'\n        \u20ac1,234.57\n        >>> m.format('de_DE') # German formatting\n        1.234,57 \u20ac\n        >>> m.format('de', '#,##0 \u00a4') # German formatting (short), no cents\n        1.235 \u20ac\n        >>> m.format(pattern='#,##0.00 \u00a4\u00a4\u00a4') # Default locale, full name\n        1,235.57 euro\n        \n        Learn more about this formatting syntaxis at:\n        http://www.unicode.org/reports/tr35/tr35-numbers.html\n        \"\"\"\n        if BABEL_AVAILABLE:\n            if BABEL_VERSION < StrictVersion('2.2'):\n                raise Exception('Babel {} is unsupported. '\n                    'Please upgrade to 2.2 or higher.'.format(BABEL_VERSION))\n            return babel.numbers.format_currency(\n                self._amount, self._currency, format=pattern, locale=locale,\n                currency_digits=currency_digits, format_type=format_type)\n        else:\n            raise NotImplementedError(\"formatting requires Babel \"\n                                      \"(https://pypi.python.org/pypi/Babel)\")", "response": "Return a locale - aware currency - formatted string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing from a string representation of a nacove.", "response": "def loads(cls, s):\n        \"\"\"Parse from a string representation (repr)\"\"\"\n        try:\n            currency, amount = s.strip().split(' ')\n            return cls(amount, currency)\n        except ValueError as err:\n            # RADAR: Python2\n            money.six.raise_from(ValueError(\"failed to parse string \"\n                \" '{}': {}\".format(s, err)), None)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_rounded_intersection_area(bbox_1, bbox_2):\n    # The rounding allows sorting areas without floating point issues.\n    bbox = bbox_1.intersection(bbox_1, bbox_2)\n    return round(bbox.width * bbox.height, 8) if bbox else 0", "response": "Compute the intersection area between two bboxes rounded to 8 digits."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nyields all child artists of Axes", "response": "def _iter_axes_subartists(ax):\n    r\"\"\"Yield all child `Artist`\\s (*not* `Container`\\s) of *ax*.\"\"\"\n    yield from ax.collections\n    yield from ax.images\n    yield from ax.lines\n    yield from ax.patches\n    yield from ax.texts"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking whether artist is still present on its parent axes.", "response": "def _is_alive(artist):\n    \"\"\"Check whether *artist* is still present on its parent axes.\"\"\"\n    return bool(artist\n                and artist.axes\n                and (artist.container in artist.axes.containers\n                     if isinstance(artist, _pick_info.ContainerArtist) else\n                     artist in _iter_axes_subartists(artist.axes)))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreassign event to axes ax.", "response": "def _reassigned_axes_event(event, ax):\n    \"\"\"Reassign *event* to *ax*.\"\"\"\n    event = copy.copy(event)\n    event.xdata, event.ydata = (\n        ax.transData.inverted().transform_point((event.x, event.y)))\n    return event"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cursor(pickables=None, **kwargs):\n\n    if pickables is None:\n        # Do not import pyplot ourselves to avoid forcing the backend.\n        plt = sys.modules.get(\"matplotlib.pyplot\")\n        pickables = [\n            plt.figure(num) for num in plt.get_fignums()] if plt else []\n    elif (isinstance(pickables, Container)\n          or not isinstance(pickables, Iterable)):\n        pickables = [pickables]\n\n    def iter_unpack_figures(pickables):\n        for entry in pickables:\n            if isinstance(entry, Figure):\n                yield from entry.axes\n            else:\n                yield entry\n\n    def iter_unpack_axes(pickables):\n        for entry in pickables:\n            if isinstance(entry, Axes):\n                yield from _iter_axes_subartists(entry)\n                containers.extend(entry.containers)\n            elif isinstance(entry, Container):\n                containers.append(entry)\n            else:\n                yield entry\n\n    containers = []\n    artists = list(iter_unpack_axes(iter_unpack_figures(pickables)))\n    for container in containers:\n        contained = list(filter(None, container.get_children()))\n        for artist in contained:\n            with suppress(ValueError):\n                artists.remove(artist)\n        if contained:\n            artists.append(_pick_info.ContainerArtist(container))\n\n    return Cursor(artists, **kwargs)", "response": "Creates a Cursor for a list of artists containers and axes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef selections(self):\n        for sel in self._selections:\n            if sel.annotation.axes is None:\n                raise RuntimeError(\"Annotation unexpectedly removed; \"\n                                   \"use 'cursor.remove_selection' instead\")\n        return tuple(self._selections)", "response": "The tuple of current Selections."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new Selection to the Cursor.", "response": "def add_selection(self, pi):\n        \"\"\"\n        Create an annotation for a `Selection` and register it.\n\n        Returns a new `Selection`, that has been registered by the `Cursor`,\n        with the added annotation set in the :attr:`annotation` field and, if\n        applicable, the highlighting artist in the :attr:`extras` field.\n\n        Emits the ``\"add\"`` event with the new `Selection` as argument.  When\n        the event is emitted, the position of the annotation is temporarily\n        set to ``(nan, nan)``; if this position is not explicitly set by a\n        callback, then a suitable position will be automatically computed.\n\n        Likewise, if the text alignment is not explicitly set but the position\n        is, then a suitable alignment will be automatically computed.\n        \"\"\"\n        # pi: \"pick_info\", i.e. an incomplete selection.\n        # Pre-fetch the figure and axes, as callbacks may actually unset them.\n        figure = pi.artist.figure\n        axes = pi.artist.axes\n        if axes.get_renderer_cache() is None:\n            figure.canvas.draw()  # Needed by draw_artist below anyways.\n        renderer = pi.artist.axes.get_renderer_cache()\n        ann = pi.artist.axes.annotate(\n            _pick_info.get_ann_text(*pi), xy=pi.target,\n            xytext=(np.nan, np.nan),\n            ha=_MarkedStr(\"center\"), va=_MarkedStr(\"center\"),\n            visible=self.visible,\n            **self.annotation_kwargs)\n        ann.draggable(use_blit=not self._multiple)\n        extras = []\n        if self._highlight:\n            hl = self.add_highlight(*pi)\n            if hl:\n                extras.append(hl)\n        sel = pi._replace(annotation=ann, extras=extras)\n        self._selections.append(sel)\n        for cb in self._callbacks[\"add\"]:\n            cb(sel)\n\n        # Check that `ann.axes` is still set, as callbacks may have removed the\n        # annotation.\n        if ann.axes and ann.xyann == (np.nan, np.nan):\n            fig_bbox = figure.get_window_extent()\n            ax_bbox = axes.get_window_extent()\n            overlaps = []\n            for idx, annotation_position in enumerate(\n                    self.annotation_positions):\n                ann.set(**annotation_position)\n                # Work around matplotlib/matplotlib#7614: position update is\n                # missing.\n                ann.update_positions(renderer)\n                bbox = ann.get_window_extent(renderer)\n                overlaps.append(\n                    (_get_rounded_intersection_area(fig_bbox, bbox),\n                     _get_rounded_intersection_area(ax_bbox, bbox),\n                     # Avoid needlessly jumping around by breaking ties using\n                     # the last used position as default.\n                     idx == self._last_auto_position))\n            auto_position = max(range(len(overlaps)), key=overlaps.__getitem__)\n            ann.set(**self.annotation_positions[auto_position])\n            self._last_auto_position = auto_position\n        else:\n            if isinstance(ann.get_ha(), _MarkedStr):\n                ann.set_ha({-1: \"right\", 0: \"center\", 1: \"left\"}[\n                    np.sign(np.nan_to_num(ann.xyann[0]))])\n            if isinstance(ann.get_va(), _MarkedStr):\n                ann.set_va({-1: \"top\", 0: \"center\", 1: \"bottom\"}[\n                    np.sign(np.nan_to_num(ann.xyann[1]))])\n\n        if (extras\n                or len(self.selections) > 1 and not self._multiple\n                or not figure.canvas.supports_blit):\n            # Either:\n            #  - there may be more things to draw, or\n            #  - annotation removal will make a full redraw necessary, or\n            #  - blitting is not (yet) supported.\n            figure.canvas.draw_idle()\n        elif ann.axes:\n            # Fast path, only needed if the annotation has not been immediately\n            # removed.\n            figure.draw_artist(ann)\n            # Explicit argument needed on MacOSX backend.\n            figure.canvas.blit(figure.bbox)\n        # Removal comes after addition so that the fast blitting path works.\n        if not self._multiple:\n            for sel in self.selections[:-1]:\n                self.remove_selection(sel)\n        return sel"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate and add a highlighting artist.", "response": "def add_highlight(self, artist, *args, **kwargs):\n        \"\"\"\n        Create, add, and return a highlighting artist.\n\n        This method is should be called with an \"unpacked\" `Selection`,\n        possibly with some fields set to None.\n\n        It is up to the caller to register the artist with the proper\n        `Selection` (by calling ``sel.extras.append`` on the result of this\n        method) in order to ensure cleanup upon deselection.\n        \"\"\"\n        hl = _pick_info.make_highlight(\n            artist, *args,\n            **ChainMap({\"highlight_kwargs\": self.highlight_kwargs}, kwargs))\n        if hl:\n            artist.axes.add_artist(hl)\n            return hl"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connect(self, event, func=None):\n        if event not in self._callbacks:\n            raise ValueError(\"{!r} is not a valid cursor event\".format(event))\n        if func is None:\n            return partial(self.connect, event)\n        self._callbacks[event].append(func)\n        return func", "response": "Connect a callback to a Cursor event ; return the callback."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef disconnect(self, event, cb):\n        try:\n            self._callbacks[event].remove(cb)\n        except KeyError:\n            raise ValueError(\"{!r} is not a valid cursor event\".format(event))\n        except ValueError:\n            raise ValueError(\"Callback {} is not registered\".format(event))", "response": "Disconnect a previously connected callback."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves a cursor. Remove all `Selection`\\\\s, disconnect all callbacks, and allow the cursor to be garbage collected.", "response": "def remove(self):\n        \"\"\"\n        Remove a cursor.\n\n        Remove all `Selection`\\\\s, disconnect all callbacks, and allow the\n        cursor to be garbage collected.\n        \"\"\"\n        for disconnectors in self._disconnectors:\n            disconnectors()\n        for sel in self.selections:\n            self.remove_selection(sel)\n        for s in type(self)._keep_alive.values():\n            with suppress(KeyError):\n                s.remove(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract_code_from_args(args):\n    if args is None:\n        raise_error(\"Couldn't extract GitHub authentication code \"\n                    \"from response\")\n\n    # TODO: Is there a case where the length of the error will be < 0?\n    error = args.get(\"error_description\", None)\n    if error is not None:\n        if len(error) >= 0:\n            raise_github_error(error)\n        else:\n            raise_error(\"Something went wrong\")\n\n    access_code = args.get(\"code\", None)\n\n    # access_code is supposed to be a list with 1 thing in it\n    if not isinstance(access_code, list) or access_code[0] is None or \\\n            len(access_code) != 1 or len(access_code[0]) <= 0:\n\n        raise_error(\"Couldn't extract GitHub authentication code from \"\n                    \"response\")\n\n    # If we get here, everything was good - no errors\n    access_code = access_code[0].decode('ascii')\n    return access_code", "response": "Extracts the access code from the arguments dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrequest access token from GitHub", "response": "def request_access_token(self, access_code):\n        \"Request access token from GitHub\"\n        token_response = request_session.post(\n            \"https://github.com/login/oauth/access_token\",\n            data={\n                \"client_id\": self.oauth_client_id,\n                \"client_secret\": self.oauth_client_secret,\n                \"code\": access_code\n            },\n            headers={\"Accept\": \"application/json\"},\n        )\n        return helper_request_access_token(token_response.json())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef combine_dicts(recs):\n    if not recs:\n        return None\n\n    if len(recs) == 1:\n        return recs.pop()\n\n    new_rec = {}\n    for rec in recs:\n        for k, v in rec.iteritems():\n            if k in new_rec:\n                new_rec[k] = \"%s, %s\" % (new_rec[k], v)\n            else:\n                new_rec[k] = v\n    return new_rec", "response": "Combine a list of recs appending values to matching keys"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef combine_recs(rec_list, key):\n    final_recs = {}\n    for rec in rec_list:\n        rec_key = rec[key]\n        if rec_key in final_recs:\n            for k, v in rec.iteritems():\n                if k in final_recs[rec_key] and final_recs[rec_key][k] != v:\n                    raise Exception(\"Mis-match for key '%s'\" % k)\n                final_recs[rec_key][k] = v\n        else:\n            final_recs[rec_key] = rec\n    return final_recs.values()", "response": "Use a common key to combine a list of recs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main():\n\n    parser = ArgumentParser(prog=\"hwinfo\")\n\n    filter_choices = ['bios', 'nic', 'storage', 'gpu', 'cpu']\n    parser.add_argument(\"-f\", \"--filter\", choices=filter_choices, help=\"Query a specific class.\")\n    parser.add_argument(\"-m\", \"--machine\", default='localhost', help=\"Remote host address.\")\n    parser.add_argument(\"-u\", \"--username\", help=\"Username for remote host.\")\n    parser.add_argument(\"-p\", \"--password\", help=\"Password for remote host.\")\n    parser.add_argument(\"-l\", \"--logs\", help=\"Path to the directory with the logfiles.\")\n    parser.add_argument(\"-e\", \"--export\", action=\"store_true\", help=\"Export result in JSON format.\")\n\n    args = parser.parse_args()\n    validate_args(args)\n\n    if args.logs:\n        if \".tar\" in args.logs:\n            host = HostFromTarball(args.logs)\n        else:\n            host = HostFromLogs(args.logs)\n    else:\n        host = Host(args.machine, args.username, args.password)\n\n    options = []\n\n    if args.filter:\n        filter_args = args.filter.split(',')\n        for arg in filter_args:\n            options.append(arg.strip())\n    else:\n        options = filter_choices\n\n    if args.export:\n        print export_system_info(host, options)\n    else:\n        print system_info(host, options)", "response": "Entry Point for the hwinfo command line interface."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load_from_file(self, filename):\n        if filename in self.fdata:\n            return self.fdata[filename]\n        else:\n            filepath = find_in_tarball(self.tarloc, filename)\n            return read_from_tarball(self.tarloc, filepath)", "response": "Load a single file from the tar file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_tag(tag):\n    tag = normalize_characters(tag)\n    if tag in EXCEPTIONS:\n        return [('grandfathered', tag)]\n    else:\n        # The first subtag is always either the language code, or 'x' to mark\n        # the entire tag as private-use. Other subtags are distinguished\n        # by their length and format, but the language code is distinguished\n        # entirely by the fact that it is required to come first.\n        subtags = tag.split('-')\n        if subtags[0] == 'x':\n            if len(subtags) == 1:\n                raise LanguageTagError(\"'x' is not a language tag on its own\")\n            else:\n                # the entire language tag is private use, but we know that,\n                # whatever it is, it fills the \"language\" slot\n                return [('language', tag)]\n        elif len(subtags[0]) >= 2:\n            return [('language', subtags[0])] + parse_subtags(subtags[1:])\n        else:\n            subtag_error(subtags[0], 'a language code')", "response": "Parse the syntax of a language tag into a list of tuples indicating what is needed to be looked up."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_subtags(subtags, expect=EXTLANG):\n    # We parse the parts of a language code recursively: each step of\n    # language code parsing handles one component of the code, recurses\n    # to handle the rest of the code, and adds what it found onto the\n    # list of things that were in the rest of the code.\n    #\n    # This could just as well have been iterative, but the loops would have\n    # been convoluted.\n    #\n    # So here's the base case.\n    if not subtags:\n        return []\n\n    # There's a subtag that comes next. We need to find out what it is.\n    #\n    # The primary thing that distinguishes different types of subtags is\n    # length, but the subtags also come in a specified order. The 'expect'\n    # parameter keeps track of where we are in that order. expect=REGION,\n    # for example, means we're expecting a region code, or anything later\n    # (because everything but the language is optional).\n    subtag = subtags[0]\n    tag_length = len(subtag)\n\n    # In the usual case, our goal is to recognize what kind of tag this is,\n    # and set it in 'tagtype' -- as an integer, so we can compare where it\n    # should go in order. You can see the enumerated list of tagtypes above,\n    # where the SUBTAG_TYPES global is defined.\n    tagtype = None\n\n    if tag_length == 0 or tag_length > 8:\n        # Unless you're inside a private use tag or something -- in which case,\n        # you're not in this function at the moment -- every component needs to\n        # be between 1 and 8 characters.\n        subtag_error(subtag, '1-8 characters')\n\n    elif tag_length == 1:\n        # A one-character subtag introduces an extension, which can itself have\n        # sub-subtags, so we dispatch to a different function at this point.\n        #\n        # We don't need to check anything about the order, because extensions\n        # necessarily come last.\n        return parse_extension(subtags)\n\n    elif tag_length == 2:\n        if subtag.isalpha():\n            # Two-letter alphabetic subtags are regions. These are the only\n            # two-character subtags after the language.\n            tagtype = REGION\n\n    elif tag_length == 3:\n        if subtag.isalpha():\n            # Three-letter alphabetic subtags are 'extended languages'.\n            # It's allowed for there to be up to three of them in a row, so we\n            # need another function to enforce that. Before we dispatch to that\n            # function, though, we need to check whether we're in the right\n            # place in order.\n            if expect <= EXTLANG:\n                return parse_extlang(subtags)\n            else:\n                order_error(subtag, EXTLANG, expect)\n        elif subtag.isdigit():\n            # Three-digit subtags are broad regions, such as Latin America\n            # (419).\n            tagtype = REGION\n\n    elif tag_length == 4:\n        if subtag.isalpha():\n            # Four-letter alphabetic subtags are scripts.\n            tagtype = SCRIPT\n        elif subtag[0].isdigit():\n            # Four-character subtags that start with a digit are variants.\n            tagtype = VARIANT\n\n    else:\n        # Tags of length 5-8 are variants.\n        tagtype = VARIANT\n\n    # That's the end of the big elif block for figuring out what kind of\n    # subtag we have based on its length. Now we should do something with that\n    # kind of subtag.\n\n    if tagtype is None:\n        # We haven't recognized a type of tag. This subtag just doesn't fit the\n        # standard.\n        subtag_error(subtag)\n\n    elif tagtype < expect:\n        # We got a tag type that was supposed to appear earlier in the order.\n        order_error(subtag, tagtype, expect)\n\n    else:\n        # We've recognized a subtag of a particular type. If it's a region or\n        # script, we expect the next subtag to be a strictly later type, because\n        # there can be at most one region and one script. Otherwise, we expect\n        # the next subtag to be the type we got or later.\n\n        if tagtype in (SCRIPT, REGION):\n            expect = tagtype + 1\n        else:\n            expect = tagtype\n\n        # Get the name of this subtag type instead of its integer value.\n        typename = SUBTAG_TYPES[tagtype]\n\n        # Some subtags are conventionally written with capitalization. Apply\n        # those conventions.\n        if tagtype == SCRIPT:\n            subtag = subtag.title()\n        elif tagtype == REGION:\n            subtag = subtag.upper()\n\n        # Recurse on the remaining subtags.\n        return [(typename, subtag)] + parse_subtags(subtags[1:], expect)", "response": "Parses the subtags of a language tag into a list of subtags."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_extlang(subtags):\n    index = 0\n    parsed = []\n    while index < len(subtags) and len(subtags[index]) == 3 and index < 3:\n        parsed.append(('extlang', subtags[index]))\n        index += 1\n    return parsed + parse_subtags(subtags[index:], SCRIPT)", "response": "Parses an extended language tag and returns a list of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a list of extension tags.", "response": "def parse_extension(subtags):\n    \"\"\"\n    An extension tag consists of a 'singleton' -- a one-character subtag --\n    followed by other subtags. Extension tags are in the BCP 47 syntax, but\n    their meaning is outside the scope of the standard.\n\n    For example, there's the u- extension, which is used for setting Unicode\n    properties in some context I'm not aware of.\n\n    If the singleton is 'x', it's a private use extension, and consumes the\n    rest of the tag. Otherwise, it stops at the next singleton.\n    \"\"\"\n    subtag = subtags[0]\n    if len(subtags) == 1:\n        raise LanguageTagError(\n            \"The subtag %r must be followed by something\" % subtag\n        )\n\n    if subtag == 'x':\n        # Private use. Everything after this is arbitrary codes that we\n        # can't look up.\n        return [('private', '-'.join(subtags))]\n\n    else:\n        # Look for the next singleton, if there is one.\n        boundary = 1\n        while boundary < len(subtags) and len(subtags[boundary]) != 1:\n            boundary += 1\n\n        # We've parsed a complete extension subtag. Return to the main\n        # parse_subtags function, but expect to find nothing but more\n        # extensions at this point.\n        return ([('extension', '-'.join(subtags[:boundary]))]\n                + parse_subtags(subtags[boundary:], EXTENSION))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\noutputting an error indicating that tags are out of place.", "response": "def order_error(subtag, got, expected):\n    \"\"\"\n    Output an error indicating that tags were out of order.\n    \"\"\"\n    options = SUBTAG_TYPES[expected:]\n    if len(options) == 1:\n        expect_str = options[0]\n    elif len(options) == 2:\n        expect_str = '%s or %s' % (options[0], options[1])\n    else:\n        expect_str = '%s, or %s' % (', '.join(options[:-1]), options[-1])\n    got_str = SUBTAG_TYPES[got]\n    raise LanguageTagError(\"This %s subtag, %r, is out of place. \"\n                           \"Expected %s.\" % (got_str, subtag, expect_str))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstandardizes a language tag.", "response": "def standardize_tag(tag: {str, Language}, macro: bool=False) -> str:\n    \"\"\"\n    Standardize a language tag:\n\n    - Replace deprecated values with their updated versions (if those exist)\n    - Remove script tags that are redundant with the language\n    - If *macro* is True, use a macrolanguage to represent the most common\n      standardized language within that macrolanguage. For example, 'cmn'\n      (Mandarin) becomes 'zh' (Chinese), and 'arb' (Modern Standard Arabic)\n      becomes 'ar' (Arabic).\n    - Format the result according to the conventions of BCP 47\n\n    Macrolanguage replacement is not required by BCP 47, but it is required\n    by the Unicode CLDR.\n\n    >>> standardize_tag('en_US')\n    'en-US'\n\n    >>> standardize_tag('en-Latn')\n    'en'\n\n    >>> standardize_tag('en-uk')\n    'en-GB'\n\n    >>> standardize_tag('eng')\n    'en'\n\n    >>> standardize_tag('arb-Arab', macro=True)\n    'ar'\n\n    >>> standardize_tag('sh-QU')\n    'sr-Latn-EU'\n\n    >>> standardize_tag('sgn-US')\n    'ase'\n\n    >>> standardize_tag('zh-cmn-hans-cn')\n    'cmn-Hans-CN'\n\n    >>> standardize_tag('zh-cmn-hans-cn', macro=True)\n    'zh-Hans-CN'\n\n    >>> standardize_tag('zsm', macro=True)\n    'ms'\n\n    >>> standardize_tag('ja-latn-hepburn')\n    'ja-Latn-hepburn'\n\n    >>> standardize_tag('spa-latn-mx')\n    'es-MX'\n\n    If the tag can't be parsed according to BCP 47, this will raise a\n    LanguageTagError (a subclass of ValueError):\n\n    >>> standardize_tag('spa-mx-latn')\n    Traceback (most recent call last):\n        ...\n    langcodes.tag_parser.LanguageTagError: This script subtag, 'latn', is out of place. Expected variant, extension, or end of string.\n    \"\"\"\n    langdata = Language.get(tag, normalize=True)\n    if macro:\n        langdata = langdata.prefer_macrolanguage()\n\n    return langdata.simplify_script().to_tag()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the score of the match between the desired language D and supported language S.", "response": "def tag_match_score(desired: {str, Language}, supported: {str, Language}) -> int:\n    \"\"\"\n    Return a number from 0 to 100 indicating the strength of match between the\n    language the user desires, D, and a supported language, S. Higher numbers\n    are better. A reasonable cutoff for not messing with your users is to\n    only accept scores of 75 or more.\n\n    A score of 100 means the languages are the same, possibly after normalizing\n    and filling in likely values.\n\n    >>> tag_match_score('en', 'en')\n    100\n    >>> tag_match_score('en', 'en-US')\n    100\n    >>> tag_match_score('zh-Hant', 'zh-TW')\n    100\n    >>> tag_match_score('ru-Cyrl', 'ru')\n    100\n    >>> # Serbo-Croatian is a politically contentious idea, but in practice\n    >>> # it's considered equivalent to Serbian in Latin characters.\n    >>> tag_match_score('sh', 'sr-Latn')\n    100\n\n    A score of 92 to 97 indicates a regional difference.\n\n    >>> tag_match_score('zh-HK', 'zh-MO')   # Chinese is similar in Hong Kong and Macao\n    97\n    >>> tag_match_score('en-AU', 'en-GB')   # Australian English is similar to British English\n    96\n    >>> tag_match_score('en-IN', 'en-GB')   # Indian English is also similar to British English\n    96\n    >>> tag_match_score('es-PR', 'es-419')  # Peruvian Spanish is Latin American Spanish\n    96\n    >>> tag_match_score('en-US', 'en-GB')   # American and British English are somewhat different\n    94\n    >>> tag_match_score('es-MX', 'es-ES')   # Mexican Spanish is different from Spanish Spanish\n    92\n    >>> # Serbian has two scripts, and people might prefer one but understand both\n    >>> tag_match_score('sr-Latn', 'sr-Cyrl')\n    95\n    >>> # European Portuguese is different from the most common form (Brazilian Portuguese)\n    >>> tag_match_score('pt', 'pt-PT')\n    92\n\n    A score of 86 to 90 indicates that people who use the desired language\n    are demographically likely to understand the supported language, even if\n    the languages themselves are unrelated. There are many languages that have\n    a one-way connection of this kind to English or French.\n\n    >>> tag_match_score('ta', 'en')  # Tamil to English\n    86\n    >>> tag_match_score('mg', 'fr')  # Malagasy to French\n    86\n\n    Sometimes it's more straightforward than that: people who use the desired\n    language are demographically likely to understand the supported language\n    because it's demographically relevant and highly related.\n\n    >>> tag_match_score('af', 'nl')  # Afrikaans to Dutch\n    86\n    >>> tag_match_score('ms', 'id')  # Malay to Indonesian\n    86\n    >>> tag_match_score('nn', 'nb')  # Nynorsk to Norwegian Bokm\u00e5l\n    90\n    >>> tag_match_score('nb', 'da')  # Norwegian Bokm\u00e5l to Danish\n    88\n\n    A score of 80 to 85 indicates a particularly contentious difference in\n    script, where people who understand one script can learn the other but\n    probably won't be happy with it. This specifically applies to Chinese.\n\n    >>> tag_match_score('zh-Hans', 'zh-Hant')\n    85\n    >>> tag_match_score('zh-CN', 'zh-HK')\n    85\n    >>> tag_match_score('zh-CN', 'zh-TW')\n    85\n    >>> tag_match_score('zh-Hant', 'zh-Hans')\n    81\n    >>> tag_match_score('zh-TW', 'zh-CN')\n    81\n\n    When the supported script is a different one than desired, this is usually\n    a major difference with score of 60 or less.\n\n    >>> tag_match_score('ja', 'ja-Latn-US-hepburn')\n    56\n\n    >>> # You can read the Shavian script, right?\n    >>> tag_match_score('en', 'en-Shaw')\n    56\n\n    When there is no indication the supported language will be understood, the\n    score will be 20 or less, to a minimum of 0.\n\n    >>> tag_match_score('es', 'fr')   # Spanish and French are different.\n    16\n    >>> tag_match_score('en', 'ta')   # English speakers generally do not know Tamil.\n    0\n\n    CLDR doesn't take into account which languages are considered part of a\n    common 'macrolanguage'. We have this data, so we can use it in matching.\n    If two languages have no other rule that would allow them to match, but\n    share a macrolanguage, they'll get a match score of 20 less than what\n    they would get if the language matched.\n\n    >>> tag_match_score('arz', 'ar')   # Egyptian Arabic to Standard Arabic\n    80\n    >>> tag_match_score('arz', 'ary')  # Egyptian Arabic to Moroccan Arabic\n    76\n\n    Here's an example that has script, region, and language differences, but\n    a macrolanguage in common.\n\n    Written Chinese is usually presumed to be Mandarin Chinese, but colloquial\n    Cantonese can be written as well. When it is, it probably has region,\n    script, and language differences from the usual mainland Chinese. But it is\n    still part of the 'Chinese' macrolanguage, so there is more similarity\n    than, say, comparing Mandarin to Hindi.\n\n    >>> tag_match_score('yue', 'zh')\n    36\n\n    Comparing Swiss German ('gsw') to standardized German ('de') shows how\n    these scores can be asymmetrical. Swiss German speakers will understand\n    German, so the score in that direction is 92. Most German speakers find\n    Swiss German unintelligible, and CLDR in fact assigns this a score of 16.\n\n    This seems a little bit extreme, but the asymmetry is certainly there. And\n    if your text is tagged as 'gsw', it must be that way for a reason.\n\n    >>> tag_match_score('gsw', 'de')\n    92\n    >>> tag_match_score('de', 'gsw')\n    16\n    \"\"\"\n    desired_ld = Language.get(desired)\n    supported_ld = Language.get(supported)\n    return desired_ld.match_score(supported_ld)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the best - matching language code for the given language.", "response": "def best_match(desired_language: {str, Language}, supported_languages: list,\n               min_score: int=75) -> (str, int):\n    \"\"\"\n    You have software that supports any of the `supported_languages`. You want\n    to use `desired_language`. This function lets you choose the right language,\n    even if there isn't an exact match.\n\n    Returns:\n\n    - The best-matching language code, which will be one of the\n      `supported_languages` or 'und'\n    - The score of the match, from 0 to 100\n\n    `min_score` sets the minimum match score. If all languages match with a lower\n    score than that, the result will be 'und' with a score of 0.\n\n    When there is a tie for the best matching language, the first one in the\n    tie will be used.\n\n    Setting `min_score` lower will enable more things to match, at the cost\n    of possibly mis-handling data or upsetting users. Read the documentation\n    for :func:`tag_match_score` to understand what the numbers mean.\n\n    >>> best_match('fr', ['de', 'en', 'fr'])\n    ('fr', 100)\n    >>> best_match('sh', ['hr', 'bs', 'sr-Latn', 'sr-Cyrl'])\n    ('sr-Latn', 100)\n    >>> best_match('zh-CN', ['zh-Hant', 'zh-Hans', 'gan', 'nan'])\n    ('zh-Hans', 100)\n    >>> best_match('zh-CN', ['cmn-Hant', 'cmn-Hans', 'gan', 'nan'])\n    ('cmn-Hans', 100)\n    >>> best_match('pt', ['pt-BR', 'pt-PT'])\n    ('pt-BR', 100)\n    >>> best_match('en-AU', ['en-GB', 'en-US'])\n    ('en-GB', 96)\n    >>> best_match('es-MX', ['es-ES', 'es-419', 'en-US'])\n    ('es-419', 96)\n    >>> best_match('es-MX', ['es-PU', 'es-AR', 'es-PY'])\n    ('es-PU', 95)\n    >>> best_match('es-MX', ['es-AR', 'es-PU', 'es-PY'])\n    ('es-AR', 95)\n    >>> best_match('zsm', ['id', 'mhp'])\n    ('id', 86)\n    >>> best_match('eu', ['el', 'en', 'es'])\n    ('es', 90)\n    >>> best_match('eu', ['el', 'en', 'es'], min_score=92)\n    ('und', 0)\n    \"\"\"\n    # Quickly return if the desired language is directly supported\n    if desired_language in supported_languages:\n        return desired_language, 100\n\n    # Reduce the desired language to a standard form that could also match\n    desired_language = standardize_tag(desired_language)\n    if desired_language in supported_languages:\n        return desired_language, 100\n\n    match_scores = [\n        (supported, tag_match_score(desired_language, supported))\n        for supported in supported_languages\n    ]\n    match_scores = [\n        (supported, score) for (supported, score) in match_scores\n        if score >= min_score\n    ] + [('und', 0)]\n\n    match_scores.sort(key=lambda item: -item[1])\n    return match_scores[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make(cls, language=None, extlangs=None, script=None,\n             region=None, variants=None, extensions=None, private=None):\n        \"\"\"\n        Create a Language object by giving any subset of its attributes.\n\n        If this value has been created before, return the existing value.\n        \"\"\"\n        values = (language, tuple(extlangs or ()), script, region,\n                  tuple(variants or ()), tuple(extensions or ()), private)\n        if values in cls._INSTANCES:\n            return cls._INSTANCES[values]\n\n        instance = cls(\n            language=language, extlangs=extlangs,\n            script=script, region=region, variants=variants,\n            extensions=extensions, private=private\n        )\n        cls._INSTANCES[values] = instance\n        return instance", "response": "Create a Language object by giving any subset of its attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new Language object from a language tag string.", "response": "def get(tag: {str, 'Language'}, normalize=True) -> 'Language':\n        \"\"\"\n        Create a Language object from a language tag string.\n\n        If normalize=True, non-standard or overlong tags will be replaced as\n        they're interpreted. This is recommended.\n\n        Here are several examples of language codes, which are also test cases.\n        Most language codes are straightforward, but these examples will get\n        pretty obscure toward the end.\n\n        >>> Language.get('en-US')\n        Language.make(language='en', region='US')\n\n        >>> Language.get('zh-Hant')\n        Language.make(language='zh', script='Hant')\n\n        >>> Language.get('und')\n        Language.make()\n\n        This function is idempotent, in case you already have a Language object:\n\n        >>> Language.get(Language.get('en-us'))\n        Language.make(language='en', region='US')\n\n        The non-code 'root' is sometimes used to represent the lack of any\n        language information, similar to 'und'.\n\n        >>> Language.get('root')\n        Language.make()\n\n        By default, getting a Language object will automatically convert\n        deprecated tags:\n\n        >>> Language.get('iw')\n        Language.make(language='he')\n\n        >>> Language.get('in')\n        Language.make(language='id')\n\n        One type of deprecated tag that should be replaced is for sign\n        languages, which used to all be coded as regional variants of a\n        fictitious global sign language called 'sgn'. Of course, there is no\n        global sign language, so sign languages now have their own language\n        codes.\n\n        >>> Language.get('sgn-US')\n        Language.make(language='ase')\n\n        >>> Language.get('sgn-US', normalize=False)\n        Language.make(language='sgn', region='US')\n\n        'en-gb-oed' is a tag that's grandfathered into the standard because it\n        has been used to mean \"spell-check this with Oxford English Dictionary\n        spelling\", but that tag has the wrong shape. We interpret this as the\n        new standardized tag 'en-gb-oxendict', unless asked not to normalize.\n\n        >>> Language.get('en-gb-oed')\n        Language.make(language='en', region='GB', variants=['oxendict'])\n\n        >>> Language.get('en-gb-oed', normalize=False)\n        Language.make(language='en-gb-oed')\n\n        'zh-min-nan' is another oddly-formed tag, used to represent the\n        Southern Min language, which includes Taiwanese as a regional form. It\n        now has its own language code.\n\n        >>> Language.get('zh-min-nan')\n        Language.make(language='nan')\n\n        There's not much we can do with the vague tag 'zh-min':\n\n        >>> Language.get('zh-min')\n        Language.make(language='zh-min')\n\n        Occasionally Wiktionary will use 'extlang' tags in strange ways, such\n        as using the tag 'und-ibe' for some unspecified Iberian language.\n\n        >>> Language.get('und-ibe')\n        Language.make(extlangs=['ibe'])\n\n        Here's an example of replacing multiple deprecated tags.\n\n        The language tag 'sh' (Serbo-Croatian) ended up being politically\n        problematic, and different standards took different steps to address\n        this. The IANA made it into a macrolanguage that contains 'sr', 'hr',\n        and 'bs'. Unicode further decided that it's a legacy tag that should\n        be interpreted as 'sr-Latn', which the language matching rules say\n        is mutually intelligible with all those languages.\n\n        We complicate the example by adding on the region tag 'QU', an old\n        provisional tag for the European Union, which is now standardized as\n        'EU'.\n\n        >>> Language.get('sh-QU')\n        Language.make(language='sr', script='Latn', region='EU')\n        \"\"\"\n        if isinstance(tag, Language):\n            if not normalize:\n                # shortcut: we have the tag already\n                return tag\n            \n            # We might need to normalize this tag. Convert it back into a\n            # string tag, to cover all the edge cases of normalization in a\n            # way that we've already solved.\n            tag = tag.to_tag()\n\n        if (tag, normalize) in Language._PARSE_CACHE:\n            return Language._PARSE_CACHE[tag, normalize]\n\n        data = {}\n        # if the complete tag appears as something to normalize, do the\n        # normalization right away. Smash case when checking, because the\n        # case normalization that comes from parse_tag() hasn't been applied\n        # yet.\n        tag_lower = tag.lower()\n        if normalize and tag_lower in LANGUAGE_REPLACEMENTS:\n            tag = LANGUAGE_REPLACEMENTS[tag_lower]\n\n        components = parse_tag(tag)\n\n        for typ, value in components:\n            if typ == 'extlang' and normalize and 'language' in data:\n                # smash extlangs when possible\n                minitag = '%s-%s' % (data['language'], value)\n                norm = LANGUAGE_REPLACEMENTS.get(minitag.lower())\n                if norm is not None:\n                    data.update(\n                        Language.get(norm, normalize).to_dict()\n                    )\n                else:\n                    data.setdefault('extlangs', []).append(value)\n            elif typ in {'extlang', 'variant', 'extension'}:\n                data.setdefault(typ + 's', []).append(value)\n            elif typ == 'language':\n                if value == 'und':\n                    pass\n                elif normalize:\n                    replacement = LANGUAGE_REPLACEMENTS.get(value.lower())\n                    if replacement is not None:\n                        # parse the replacement if necessary -- this helps with\n                        # Serbian and Moldovan\n                        data.update(\n                            Language.get(replacement, normalize).to_dict()\n                        )\n                    else:\n                        data['language'] = value\n                else:\n                    data['language'] = value\n            elif typ == 'region':\n                if normalize:\n                    data['region'] = REGION_REPLACEMENTS.get(value.lower(), value)\n                else:\n                    data['region'] = value\n            elif typ == 'grandfathered':\n                # If we got here, we got a grandfathered tag but we were asked\n                # not to normalize it, or the CLDR data doesn't know how to\n                # normalize it. The best we can do is set the entire tag as the\n                # language.\n                data['language'] = value\n            else:\n                data[typ] = value\n\n        result = Language.make(**data)\n        Language._PARSE_CACHE[tag, normalize] = result\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_tag(self) -> str:\n        if self._str_tag is not None:\n            return self._str_tag\n        subtags = ['und']\n        if self.language:\n            subtags[0] = self.language\n        if self.extlangs:\n            for extlang in sorted(self.extlangs):\n                subtags.append(extlang)\n        if self.script:\n            subtags.append(self.script)\n        if self.region:\n            subtags.append(self.region)\n        if self.variants:\n            for variant in sorted(self.variants):\n                subtags.append(variant)\n        if self.extensions:\n            for ext in self.extensions:\n                subtags.append(ext)\n        if self.private:\n            subtags.append(self.private)\n        self._str_tag = '-'.join(subtags)\n        return self._str_tag", "response": "Convert a Language object to a standard language tag as a string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsimplifying the script of the language.", "response": "def simplify_script(self) -> 'Language':\n        \"\"\"\n        Remove the script from some parsed language data, if the script is\n        redundant with the language.\n\n        >>> Language.make(language='en', script='Latn').simplify_script()\n        Language.make(language='en')\n\n        >>> Language.make(language='yi', script='Latn').simplify_script()\n        Language.make(language='yi', script='Latn')\n\n        >>> Language.make(language='yi', script='Hebr').simplify_script()\n        Language.make(language='yi')\n        \"\"\"\n        if self._simplified is not None:\n            return self._simplified\n\n        if self.language and self.script:\n            if DEFAULT_SCRIPTS.get(self.language) == self.script:\n                result = self.update_dict({'script': None})\n                self._simplified = result\n                return self._simplified\n\n        self._simplified = self\n        return self._simplified"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassume the script for the current language.", "response": "def assume_script(self) -> 'Language':\n        \"\"\"\n        Fill in the script if it's missing, and if it can be assumed from the\n        language subtag. This is the opposite of `simplify_script`.\n\n        >>> Language.make(language='en').assume_script()\n        Language.make(language='en', script='Latn')\n\n        >>> Language.make(language='yi').assume_script()\n        Language.make(language='yi', script='Hebr')\n\n        >>> Language.make(language='yi', script='Latn').assume_script()\n        Language.make(language='yi', script='Latn')\n\n        This fills in nothing when the script cannot be assumed -- such as when\n        the language has multiple scripts, or it has no standard orthography:\n\n        >>> Language.make(language='sr').assume_script()\n        Language.make(language='sr')\n\n        >>> Language.make(language='eee').assume_script()\n        Language.make(language='eee')\n\n        It also dosn't fill anything in when the language is unspecified.\n\n        >>> Language.make(region='US').assume_script()\n        Language.make(region='US')\n        \"\"\"\n        if self._assumed is not None:\n            return self._assumed\n        if self.language and not self.script:\n            try:\n                self._assumed = self.update_dict({'script': DEFAULT_SCRIPTS[self.language]})\n            except KeyError:\n                self._assumed = self\n        else:\n            self._assumed = self\n        return self._assumed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new Language object with the same language as the current one.", "response": "def prefer_macrolanguage(self) -> 'Language':\n        \"\"\"\n        BCP 47 doesn't specify what to do with macrolanguages and the languages\n        they contain. The Unicode CLDR, on the other hand, says that when a\n        macrolanguage has a dominant standardized language, the macrolanguage\n        code should be used for that language. For example, Mandarin Chinese\n        is 'zh', not 'cmn', according to Unicode, and Malay is 'ms', not 'zsm'.\n\n        This isn't a rule you'd want to follow in all cases -- for example, you may\n        want to be able to specifically say that 'ms' (the Malay macrolanguage)\n        contains both 'zsm' (Standard Malay) and 'id' (Indonesian). But applying\n        this rule helps when interoperating with the Unicode CLDR.\n\n        So, applying `prefer_macrolanguage` to a Language object will\n        return a new object, replacing the language with the macrolanguage if\n        it is the dominant language within that macrolanguage. It will leave\n        non-dominant languages that have macrolanguages alone.\n\n        >>> Language.get('arb').prefer_macrolanguage()\n        Language.make(language='ar')\n\n        >>> Language.get('cmn-Hant').prefer_macrolanguage()\n        Language.make(language='zh', script='Hant')\n\n        >>> Language.get('yue-Hant').prefer_macrolanguage()\n        Language.make(language='yue', script='Hant')\n        \"\"\"\n        if self._macrolanguage is not None:\n            return self._macrolanguage\n        language = self.language or 'und'\n        if language in NORMALIZED_MACROLANGUAGES:\n            self._macrolanguage = self.update_dict({\n                'language': NORMALIZED_MACROLANGUAGES[language]\n            })\n        else:\n            self._macrolanguage = self\n        return self._macrolanguage"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef broaden(self) -> 'List[Language]':\n        if self._broader is not None:\n            return self._broader\n        self._broader = [self]\n        seen = set(self.to_tag())\n        for keyset in self.BROADER_KEYSETS:\n            filtered = self._filter_attributes(keyset)\n            tag = filtered.to_tag()\n            if tag not in seen:\n                self._broader.append(filtered)\n                seen.add(tag)\n        return self._broader", "response": "Iterate through increasingly general versions of this parsed language tag and return a list of languages that can be used to find the broader version of that language tag."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef maximize(self) -> 'Language':\n        if self._filled is not None:\n            return self._filled\n\n        for broader in self.broaden():\n            tag = broader.to_tag()\n            if tag in LIKELY_SUBTAGS:\n                result = Language.get(LIKELY_SUBTAGS[tag], normalize=False)\n                result = result.update(self)\n                self._filled = result\n                return result\n\n        raise RuntimeError(\n            \"Couldn't fill in likely values. This represents a problem with \"\n            \"the LIKELY_SUBTAGS data.\"\n        )", "response": "Returns a new language tag with the most likely values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_score(self, supported: 'Language') -> int:\n        if supported == self:\n            return 100\n\n        desired_complete = self.prefer_macrolanguage().maximize()\n        supported_complete = supported.prefer_macrolanguage().maximize()\n\n        desired_triple = (desired_complete.language, desired_complete.script, desired_complete.region)\n        supported_triple = (supported_complete.language, supported_complete.script, supported_complete.region)\n\n        return 100 - raw_distance(desired_triple, supported_triple)", "response": "This method returns the score of matching the language with the given language."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the name of the language in a natural language.", "response": "def language_name(self, language=DEFAULT_LANGUAGE, min_score: int=75) -> str:\n        \"\"\"\n        Give the name of the language (not the entire tag, just the language part)\n        in a natural language. The target language can be given as a string or\n        another Language object.\n\n        By default, things are named in English:\n\n        >>> Language.get('fr').language_name()\n        'French'\n        >>> Language.get('el').language_name()\n        'Greek'\n\n        But you can ask for language names in numerous other languages:\n\n        >>> Language.get('fr').language_name('fr')\n        'fran\u00e7ais'\n        >>> Language.get('el').language_name('fr')\n        'grec'\n\n        Why does everyone get Slovak and Slovenian confused? Let's ask them.\n\n        >>> Language.get('sl').language_name('sl')\n        'sloven\u0161\u010dina'\n        >>> Language.get('sk').language_name('sk')\n        'sloven\u010dina'\n        >>> Language.get('sl').language_name('sk')\n        'slovin\u010dina'\n        >>> Language.get('sk').language_name('sl')\n        'slova\u0161\u010dina'\n        \"\"\"\n        return self._get_name('language', language, min_score)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the name of the autonym language.", "response": "def autonym(self, min_score: int=95) -> str:\n        \"\"\"\n        Give the name of this language *in* this language.\n\n        >>> Language.get('fr').autonym()\n        'fran\u00e7ais'\n        >>> Language.get('es').autonym()\n        'espa\u00f1ol'\n        >>> Language.get('ja').autonym()\n        '\u65e5\u672c\u8a9e'\n\n        This doesn't give the name of the region or script, but in some cases\n        the language can name itself in multiple scripts:\n\n        >>> Language.get('sr-Latn').autonym()\n        'srpski'\n        >>> Language.get('sr-Cyrl').autonym()\n        '\u0441\u0440\u043f\u0441\u043a\u0438'\n        >>> Language.get('pa').autonym()\n        '\u0a2a\u0a70\u0a1c\u0a3e\u0a2c\u0a40'\n        >>> Language.get('pa-Arab').autonym()\n        '\u067e\u0646\u062c\u0627\u0628\u06cc'\n\n        This only works for language codes that CLDR has locale data for. You\n        can't ask for the autonym of 'ja-Latn' and get 'nihongo'.\n        \"\"\"\n        return self.language_name(language=self, min_score=min_score)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef script_name(self, language=DEFAULT_LANGUAGE, min_score: int=75) -> str:\n        return self._get_name('script', language, min_score)", "response": "Get the script part of the language tag in a natural language."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the name of the region part of the language tag.", "response": "def region_name(self, language=DEFAULT_LANGUAGE, min_score: int=75) -> str:\n        \"\"\"\n        Describe the region part of the language tag in a natural language.\n        \"\"\"\n        return self._get_name('region', language, min_score)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndescribe each of the variant parts of the language tag in a natural taxonomy.", "response": "def variant_names(self, language=DEFAULT_LANGUAGE, min_score: int=75) -> list:\n        \"\"\"\n        Describe each of the variant parts of the language tag in a natural\n        language.\n        \"\"\"\n        names = []\n        for variant in self.variants:\n            var_names = code_to_names('variant', variant)\n            names.append(self._best_name(var_names, language, min_score))\n        return names"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dictionary that describes a given language tag in a specified natural language.", "response": "def describe(self, language=DEFAULT_LANGUAGE, min_score: int=75) -> dict:\n        \"\"\"\n        Return a dictionary that describes a given language tag in a specified\n        natural language.\n\n        See `language_name` and related methods for more specific versions of this.\n\n        The desired `language` will in fact be matched against the available\n        options using the matching technique that this module provides.  We can\n        illustrate many aspects of this by asking for a description of Shavian\n        script (a script devised by author George Bernard Shaw), and where you\n        might find it, in various languages.\n\n        >>> from pprint import pprint\n        >>> shaw = Language.make(script='Shaw').maximize()\n        >>> pprint(shaw.describe('en'))\n        {'language': 'English', 'region': 'United Kingdom', 'script': 'Shavian'}\n\n        >>> pprint(shaw.describe('fr'))\n        {'language': 'anglais', 'region': 'Royaume-Uni', 'script': 'shavien'}\n\n        >>> pprint(shaw.describe('es'))\n        {'language': 'ingl\u00e9s', 'region': 'Reino Unido', 'script': 'shaviano'}\n\n        >>> pprint(shaw.describe('pt'))\n        {'language': 'ingl\u00eas', 'region': 'Reino Unido', 'script': 'shaviano'}\n\n        >>> pprint(shaw.describe('uk'))\n        {'language': '\u0430\u043d\u0433\u043b\u0456\u0439\u0441\u044c\u043a\u0430', 'region': '\u0412\u0435\u043b\u0438\u043a\u0430 \u0411\u0440\u0438\u0442\u0430\u043d\u0456\u044f', 'script': '\u0448\u043e\u0443'}\n\n        >>> pprint(shaw.describe('arb'))\n        {'language': '\u0627\u0644\u0625\u0646\u062c\u0644\u064a\u0632\u064a\u0629', 'region': '\u0627\u0644\u0645\u0645\u0644\u0643\u0629 \u0627\u0644\u0645\u062a\u062d\u062f\u0629', 'script': '\u0627\u0644\u0634\u0648\u0627\u0646\u064a'}\n\n        >>> pprint(shaw.describe('th'))\n        {'language': '\u0e2d\u0e31\u0e07\u0e01\u0e24\u0e29', 'region': '\u0e2a\u0e2b\u0e23\u0e32\u0e0a\u0e2d\u0e32\u0e13\u0e32\u0e08\u0e31\u0e01\u0e23', 'script': '\u0e0b\u0e2d\u0e40\u0e27\u0e35\u0e22\u0e19'}\n\n        >>> pprint(shaw.describe('zh-Hans'))\n        {'language': '\u82f1\u8bed', 'region': '\u82f1\u56fd', 'script': '\u8427\u4f2f\u7eb3\u5f0f\u6587'}\n\n        >>> pprint(shaw.describe('zh-Hant'))\n        {'language': '\u82f1\u6587', 'region': '\u82f1\u570b', 'script': '\u7c2b\u67cf\u7d0d\u5b57\u7b26'}\n\n        >>> pprint(shaw.describe('ja'))\n        {'language': '\u82f1\u8a9e', 'region': '\u30a4\u30ae\u30ea\u30b9', 'script': '\u30b7\u30e7\u30fc\u6587\u5b57'}\n\n        When we don't have a localization for the language, we fall back on\n        'und', which just shows the language codes.\n\n        >>> pprint(shaw.describe('lol'))\n        {'language': 'en', 'region': 'GB', 'script': 'Shaw'}\n\n        Wait, is that a real language?\n\n        >>> pprint(Language.get('lol').maximize().describe())\n        {'language': 'Mongo', 'region': 'Congo - Kinshasa', 'script': 'Latin'}\n        \"\"\"\n        names = {}\n        if self.language:\n            names['language'] = self.language_name(language, min_score)\n        if self.script:\n            names['script'] = self.script_name(language, min_score)\n        if self.region:\n            names['region'] = self.region_name(language, min_score)\n        if self.variants:\n            names['variants'] = self.variant_names(language, min_score)\n        return names"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding the subtag of a particular tagtype that has the given name.", "response": "def find_name(tagtype: str, name: str, language: {str, 'Language', None}=None):\n        \"\"\"\n        Find the subtag of a particular `tagtype` that has the given `name`.\n\n        The default language, \"und\", will allow matching names in any language,\n        so you can get the code 'fr' by looking up \"French\", \"Fran\u00e7ais\", or\n        \"franc\u00e9s\".\n\n        Occasionally, names are ambiguous in a way that can be resolved by\n        specifying what name the language is supposed to be in. For example,\n        there is a language named 'Malayo' in English, but it's different from\n        the language named 'Malayo' in Spanish (which is Malay). Specifying the\n        language will look up the name in a trie that is only in that language.\n\n        In a previous version, we thought we were going to deprecate the\n        `language` parameter, as there weren't significant cases of conflicts\n        in names of things between languages. Well, we got more data, and\n        conflicts in names are everywhere.\n\n        Specifying the language that the name should be in is still not\n        required, but it will help to make sure that names can be\n        round-tripped.\n\n        >>> Language.find_name('language', 'franc\u00e9s')\n        Language.make(language='fr')\n\n        >>> Language.find_name('region', 'United Kingdom')\n        Language.make(region='GB')\n\n        >>> Language.find_name('script', 'Arabic')\n        Language.make(script='Arab')\n\n        >>> Language.find_name('language', 'norsk bokm\u00e5l')\n        Language.make(language='nb')\n\n        >>> Language.find_name('language', 'norsk')\n        Language.make(language='no')\n\n        >>> Language.find_name('language', 'norsk', 'en')\n        Traceback (most recent call last):\n            ...\n        LookupError: Can't find any language named 'norsk'\n\n        >>> Language.find_name('language', 'norsk', 'no')\n        Language.make(language='no')\n\n        >>> Language.find_name('language', 'malayo', 'en')\n        Language.make(language='mbp')\n\n        >>> Language.find_name('language', 'malayo', 'es')\n        Language.make(language='ms')\n\n        Some langauge names resolve to more than a language. For example,\n        the name 'Brazilian Portuguese' resolves to a language and a region,\n        and 'Simplified Chinese' resolves to a language and a script. In these\n        cases, a Language object with multiple subtags will be returned.\n\n        >>> Language.find_name('language', 'Brazilian Portuguese', 'en')\n        Language.make(language='pt', region='BR')\n\n        >>> Language.find_name('language', 'Simplified Chinese', 'en')\n        Language.make(language='zh', script='Hans')\n\n        A small amount of fuzzy matching is supported: if the name can be\n        shortened to match a single language name, you get that language.\n        This allows, for example, \"Hakka dialect\" to match \"Hakka\".\n\n        >>> Language.find_name('language', 'Hakka dialect')\n        Language.make(language='hak')\n        \"\"\"\n\n        # No matter what form of language we got, normalize it to a single\n        # language subtag\n        if isinstance(language, Language):\n            language = language.language\n        elif isinstance(language, str):\n            language = get(language).language\n        if language is None:\n            language = 'und'\n\n        code = name_to_code(tagtype, name, language)\n        if code is None:\n            raise LookupError(\"Can't find any %s named %r\" % (tagtype, name))\n        if '-' in code:\n            return Language.get(code)\n        else:\n            data = {tagtype: code}\n            return Language.make(**data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_dict(self):\n        if self._dict is not None:\n            return self._dict\n\n        result = {}\n        for key in self.ATTRIBUTES:\n            value = getattr(self, key)\n            if value:\n                result[key] = value\n        self._dict = result\n        return result", "response": "Returns a dictionary of the attributes of this Language object which can be useful for constructing a similar object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, other: 'Language') -> 'Language':\n        return Language.make(\n            language=other.language or self.language,\n            extlangs=other.extlangs or self.extlangs,\n            script=other.script or self.script,\n            region=other.region or self.region,\n            variants=other.variants or self.variants,\n            extensions=other.extensions or self.extensions,\n            private=other.private or self.private\n        )", "response": "Update this Language with the fields of the other Language."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the attributes of this Language from a dictionary.", "response": "def update_dict(self, newdata: dict) -> 'Language':\n        \"\"\"\n        Update the attributes of this Language from a dictionary.\n        \"\"\"\n        return Language.make(\n            language=newdata.get('language', self.language),\n            extlangs=newdata.get('extlangs', self.extlangs),\n            script=newdata.get('script', self.script),\n            region=newdata.get('region', self.region),\n            variants=newdata.get('variants', self.variants),\n            extensions=newdata.get('extensions', self.extensions),\n            private=newdata.get('private', self.private)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nselects a subset of keys from a dictionary.", "response": "def _filter_keys(d: dict, keys: set) -> dict:\n        \"\"\"\n        Select a subset of keys from a dictionary.\n        \"\"\"\n        return {key: d[key] for key in keys if key in d}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _filter_attributes(self, keyset):\n        filtered = self._filter_keys(self.to_dict(), keyset)\n        return Language.make(**filtered)", "response": "Returns a copy of this object with a subset of its attributes set."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _searchable_form(self) -> 'Language':\n        if self._searchable is not None:\n            return self._searchable\n\n        self._searchable = self._filter_attributes(\n            {'language', 'script', 'region'}\n        ).simplify_script().prefer_macrolanguage()\n        return self._searchable", "response": "Convert a parsed language tag so that the information it contains is in the most likely form."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resolve_name(key, vals, debug=False):\n    max_priority = max([val[2] for val in vals])\n    val_count = Counter([val[1] for val in vals if val[2] == max_priority])\n    if len(val_count) == 1:\n        unanimous = val_count.most_common(1)\n        return unanimous[0][0]\n\n    for pkey in val_count:\n        if pkey in AMBIGUOUS_PREFERENCES:\n            others = set(val_count)\n            others.remove(pkey)\n            if others == others & AMBIGUOUS_PREFERENCES[pkey]:\n                if debug:\n                    print(\"Resolved: {} -> {}\".format(key, pkey))\n                return pkey\n\n    # In debug mode, show which languages vote for which name\n    if debug and max_priority >= 0:\n        votes = defaultdict(list)\n        for voter, val, prio in vals:\n            if prio == max_priority:\n                votes[val].append(voter)\n\n        print(\"{}:\".format(key))\n        for val, voters in sorted(votes.items()):\n            print(\"\\t{}: {}\".format(val, ' '.join(voters)))\n\n    # Don't use names that remain ambiguous\n    return None", "response": "Given a name and a number of possible values find the name that can be resolved to."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_cldr_names(path, language, category):\n    filename = data_filename('{}/{}/{}.json'.format(path, language, category))\n    fulldata = json.load(open(filename, encoding='utf-8'))\n    data = fulldata['main'][language]['localeDisplayNames'][category]\n    return data", "response": "Read CLDR s names for things in a particular language and category."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the IANA subtag registry file and yield a dictionary of information for each subtag it describes.", "response": "def parse_file(file):\n    \"\"\"\n    Take an open file containing the IANA subtag registry, and yield a\n    dictionary of information for each subtag it describes.\n    \"\"\"\n    lines = []\n    for line in file:\n        line = line.rstrip('\\n')\n        if line == '%%':\n            # This is a separator between items. Parse the data we've\n            # collected and yield the result.\n            yield from parse_item(lines)\n            lines.clear()\n        elif line.startswith('  '):\n            # This is a continuation line. Concatenate it to the previous\n            # line, including one of the spaces.\n            lines[-1] += line[1:]\n        else:\n            lines.append(line)\n    yield from parse_item(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_item(lines):\n    info = {}\n    for line in lines:\n        key, value = line.split(': ', 1)\n        if key in LIST_KEYS:\n            info.setdefault(key, []).append(value)\n        else:\n            assert key not in info\n            info[key] = value\n    \n    if 'Subtag' in info or 'Tag' in info:\n        yield info", "response": "Given the lines that form a subtag entry parse the data they contain."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _make_simple_distances():\n    distances = {}\n    def sym(desired, supported, strength):\n        \"Define a symmetric distance between languages.\"\n        desired_t = tuple(desired.split('-'))\n        supported_t = tuple(supported.split('-'))\n        distances[desired_t, supported_t] = strength\n        distances[supported_t, desired_t] = strength\n\n    def one(desired, supported, strength):\n        \"Define a one-way distance between languages.\"\n        desired_t = tuple(desired.split('-'))\n        supported_t = tuple(supported.split('-'))\n        distances[desired_t, supported_t] = strength\n\n    def ok(desired, supported):\n        \"Define the most common type of link: a one-way distance of 10.\"\n        one(desired, supported, 10)\n\n    sym('no', 'nb', 1)\n    sym('hr', 'bs', 4)\n    sym('sh', 'bs', 4)\n    sym('sr', 'bs', 4)\n    sym('sh', 'hr', 4)\n    sym('sr', 'hr', 4)\n    sym('sh', 'sr', 4)\n    sym('ssy', 'aa', 4)\n    one('gsw', 'de', 4)\n    one('lb', 'de', 4)\n    sym('da', 'no', 8)\n    sym('da', 'nb', 8)\n    ok('ab', 'ru')\n    ok('ach', 'en')\n    ok('af', 'nl')\n    ok('ak', 'en')\n    ok('ay', 'es')\n    ok('az', 'ru')\n    ok('az-Latn', 'ru-Cyrl')\n    ok('be', 'ru')\n    ok('bem', 'en')\n    ok('bh', 'hi')\n    ok('bn', 'en')\n    ok('bn-Beng', 'en-Latn')\n    ok('br', 'fr')\n    ok('ceb', 'fil')\n    ok('chr', 'en')\n    ok('ckb', 'ar')\n    ok('co', 'fr')\n    ok('crs', 'fr')\n    ok('cy', 'en')\n    ok('ee', 'en')\n    ok('eo', 'en')\n    ok('et', 'fi')\n    ok('eu', 'es')\n    ok('fo', 'da')\n    ok('fy', 'nl')\n    ok('ga', 'en')\n    ok('gaa', 'en')\n    ok('gd', 'en')\n    ok('gl', 'es')\n    ok('gn', 'es')\n    ok('gu', 'hi')\n    ok('ha', 'en')\n    ok('haw', 'en')\n    ok('ht', 'fr')\n    ok('hy', 'ru')\n    ok('hy-Armn', 'ru-Cyrl')\n    ok('ia', 'en')\n    ok('ig', 'en')\n    ok('is', 'en')\n    ok('jv', 'id')\n    ok('ka-Geor', 'en-Latn')\n    ok('ka', 'en')\n    ok('kg', 'fr')\n    ok('kk', 'ru')\n    ok('km', 'en')\n    ok('km-Khmr', 'en-Latn')\n    ok('kn', 'en')\n    ok('kn-Knda', 'en-Latn')\n    ok('kri', 'en')\n    ok('ku', 'tr')\n    ok('ky', 'ru')\n    ok('la', 'it')\n    ok('lg', 'en')\n    ok('ln', 'fr')\n    ok('lo', 'en')\n    ok('lo-Laoo', 'en-Latn')\n    ok('loz', 'en')\n    ok('lua', 'fr')\n    ok('mfe', 'en')\n    ok('mg', 'fr')\n    ok('mi', 'en')\n    ok('mk', 'bg')\n    ok('ml', 'en')\n    ok('ml-Mlym', 'en-Latn')\n    ok('mn', 'ru')\n    ok('mr', 'hi')\n    ok('ms', 'id')\n    ok('mt', 'en')\n    ok('my', 'en')\n    ok('my-Mymr', 'en-Latn')\n    ok('ne', 'en')\n    ok('ne-Deva', 'en-Latn')\n    sym('nn', 'nb', 10)\n    ok('nn', 'no')\n    ok('nso', 'en')\n    ok('ny', 'en')\n    ok('nyn', 'en')\n    ok('oc', 'fr')\n    ok('om', 'en')\n    ok('or', 'en')\n    ok('or-Orya', 'en-Latn')\n    ok('pa', 'en')\n    ok('pa-Guru', 'en-Latn')\n    ok('pcm', 'en')\n    ok('ps', 'en')\n    ok('ps-Arab', 'en-Latn')\n    ok('qu', 'es')\n    ok('rm', 'de')\n    ok('rn', 'en')\n    ok('rw', 'fr')\n    ok('sa', 'hi')\n    ok('sd', 'en')\n    ok('sd-Arab', 'en-Latn')\n    ok('si', 'en')\n    ok('si-Sinh', 'en-Latn')\n    ok('sn', 'en')\n    ok('so', 'en')\n    ok('sq', 'en')\n    ok('st', 'en')\n    ok('su', 'id')\n    ok('sw', 'en')\n    ok('ta', 'en')\n    ok('ta-Taml', 'en-Latn')\n    ok('te', 'en')\n    ok('te-Telu', 'en-Latn')\n    ok('tg', 'ru')\n    ok('ti', 'en')\n    ok('ti-Ethi', 'en-Latn')\n    ok('tk', 'ru')\n    ok('tk-Latn', 'ru-Cyrl')\n    ok('tlh', 'en')\n    ok('tn', 'en')\n    ok('to', 'en')\n    ok('tt', 'ru')\n    ok('tum', 'en')\n    ok('ug', 'zh')\n    ok('ur', 'en')\n    ok('ur-Arab', 'en-Latn')\n    ok('uz', 'ru')\n    ok('uz-Latn', 'ru-Cyrl')\n    ok('wo', 'fr')\n    ok('xh', 'en')\n    ok('yi', 'en')\n    ok('yi-Hebr', 'en-Latn')\n    ok('yo', 'en')\n    ok('zu', 'en')\n    sym('sr-Latn', 'sr-Cyrl', 5)\n    one('zh-Hans', 'zh-Hant', 15)\n    one('zh-Hant', 'zh-Hans', 19)\n    sym('zh-Hant-HK', 'zh-Hant-MO', 3)\n\n    return distances", "response": "This function creates a simple structure of the base class for the base class."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef normalize_name(name):\n    name = name.casefold()\n    name = name.replace(\"\u2019\", \"'\")\n    name = name.replace(\"-\", \" \")\n    name = name.replace(\"(\", \"\")\n    name = name.replace(\")\", \"\")\n    name = name.replace(\",\", \"\")\n    return name.strip()", "response": "Normalizes a language - code component name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_trie(filename):\n    trie = marisa_trie.BytesTrie()\n    # marisa_trie raises warnings that make no sense. Ignore them.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        trie.load(filename)\n    return trie", "response": "Load a BytesTrie from the marisa_trie on - disk format."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a language script or region from a name in some language.", "response": "def name_to_code(category, name, language: str='und'):\n    \"\"\"\n    Get a language, script, or region by its name in some language.\n\n    The language here must be a string representing a language subtag only.\n    The `Language.find` method can handle other representations of a language\n    and normalize them to this form.\n\n    The default language, \"und\", will allow matching names in any language,\n    so you can get the code 'fr' by looking up \"French\", \"Fran\u00e7ais\", or\n    \"franc\u00e9s\".\n\n    A small amount of fuzzy matching is supported: if the name can be\n    shortened or lengthened to match a single language name, you get that\n    language. This allows, for example, \"Hakka Chinese\" to match \"Hakka\".\n\n    Occasionally, names are ambiguous in a way that can be resolved by\n    specifying what name the language is supposed to be in. For example,\n    there is a language named 'Malayo' in English, but it's different from\n    the language named 'Malayo' in Spanish (which is Malay). Specifying the\n    language will look up the name in a trie that is only in that language.\n    \"\"\"\n    assert '/' not in language, \"Language codes cannot contain slashes\"\n    assert '-' not in language, \"This code should be reduced to a language subtag only\"\n    trie_name = '{}/name_to_{}'.format(language, category)\n    if trie_name not in TRIES:\n        TRIES[trie_name] = load_trie(data_filename('trie/{}.marisa'.format(trie_name)))\n\n    trie = TRIES[trie_name]\n    lookup = normalize_name(name)\n    if lookup in trie:\n        return get_trie_value(trie, lookup)\n    else:\n        # Is this a language plus extra junk? Maybe it has \"...isch\", \"... language\",\n        # or \"... Chinese\" attached to it, for example.\n        prefixes = trie.prefixes(lookup)\n        if prefixes and len(prefixes[-1]) >= 4:\n            return get_trie_value(trie, prefixes[-1])\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a code for a language script or region get a dictionary of its names in various languages.", "response": "def code_to_names(category, code):\n    \"\"\"\n    Given the code for a language, script, or region, get a dictionary of its\n    names in various languages.\n    \"\"\"\n    trie_name = '{}_to_name'.format(category)\n    if trie_name not in TRIES:\n        TRIES[trie_name] = load_trie(data_filename('trie/{}.marisa'.format(trie_name)))\n\n    trie = TRIES[trie_name]\n    lookup = code.lower() + '@'\n    possible_keys = trie.keys(lookup)\n    names = {}\n    for key in possible_keys:\n        target_language = key.split('@')[1]\n        names[target_language] = get_trie_value(trie, key)\n    return names"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unicode2encode(text, charmap):\r\n    '''\r\n    charmap : dictionary which has both encode as key, unicode as value\r\n    '''\r\n    if isinstance(text, (list, tuple)):\r\n        unitxt = ''\r\n        for line in text:\r\n            for val,key in charmap.items():\r\n                if key in line:\r\n                    line = line.replace(key, val)\r\n                # end of if val in text:\r\n            unitxt += line\r\n        # end of for line in text:\r\n        return unitxt\r\n    elif isinstance(text, str):\r\n        for val,key in charmap.items():\r\n            if key in text:\r\n                text = text.replace(key, val)\r\n        return text", "response": "converts unicode to unicode"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unicode2auto(unicode_text, encode_text):\r\n\r\n    _all_unique_encodes_, _all_common_encodes_ = _get_unique_common_encodes()\r\n    # get unique word which falls under any one of available encodes from\r\n    # user passed text lines\r\n    unique_chars = _get_unique_ch(encode_text, _all_common_encodes_)\r\n    # count common encode chars\r\n    clen = len(_all_common_encodes_)\r\n    msg = \"Sorry, couldn't find encode :-(\\n\"\r\n    msg += 'Need more words to find unique encode out side of %d ' % clen\r\n    msg += 'common compound characters'\r\n    if not unique_chars:\r\n        print(msg)\r\n        return ''\r\n    # end of if not unique_chars:\r\n\r\n    for encode_name, encode_keys in _all_unique_encodes_:\r\n        if not len(encode_keys): continue\r\n        for ch in encode_keys:\r\n            # check either encode char is presnent in word\r\n            if ch in unique_chars:\r\n                # found encode\r\n                print((\"Found encode : \", encode_name))\r\n                encode = _all_encodes_[encode_name]\r\n                return unicode2encode(unicode_text, encode)\r\n            # end of if ch in unique_chars:\r\n        # end of ifor ch in encode_keys:\r\n    else:\r\n        print(msg)\r\n        return ''", "response": "This function will convert unicode text into other word components by auto - finds the encode of the word and returns the new word."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef print_huffman_code_cwl(code,p,v):\n    cwl = 0.0\n    for k,_v in code.items():\n        print(u\"%s -> %s\"%(k,_v))\n        cwl += p[v.index(k)]*len(_v)\n    print(u\"cwl = %g\"%cwl)\n    return cwl,code.values()", "response": "print the code map for huffman code p v is probability map"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nimplementing Daegmar - Levenshtein edit distance algorithm", "response": "def edit_distance(wordA,wordB):\n    \"\"\"\" Implements Daegmar-Levenshtein edit distance algorithm:\n         Ref: https://en.wikipedia.org/wiki/Edit_distance\n         Ref: https://en.wikipedia.org/wiki/Levenshtein_distance\"\"\"\n    if not type(wordA) is list:\n        lettersA = tamil.utf8.get_letters(wordA)\n    else:\n        lettersA = wordA\n    \n    if not type(wordB) is list:\n        lettersB = tamil.utf8.get_letters(wordB)\n    else:\n        lettersB = wordB\n    n_A = len(lettersA)\n    n_B = len(lettersB)\n    dist_AB = [[0 for i in range(0,n_B+1)] for i in range(0,(n_A+1))]\n    # Target prefix reached by insertion\n    for j in range(1,n_B+1):\n        dist_AB[0][j] = j\n    for i in range(1,n_A+1):\n        dist_AB[i][0] = i\n    for j in range(1,n_B+1):\n        for i in range(1,n_A+1):\n            if (lettersA[i-1] == lettersB[j-1]):\n                new_dist = dist_AB[i-1][j-1]\n            else:\n                new_dist = min( [dist_AB[i-1][j]+1, dist_AB[i][j-1]+1, dist_AB[i-1][j-1]+1] ) #del, ins, or sub\n            dist_AB[i][j] = new_dist \n    return dist_AB[-1][-1]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate edit - distance between two words in the language tree.", "response": "def Dice_coeff(wordA,wordB):\n    \"\"\"\n        # Calculate edit-distance - Implements the Dice coefficent\n        # Ref: https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient\n        # distance should be between 0 - 1.0. can be used as a similarity match\n    \"\"\"\n    if not type(wordA) is list:\n        lettersA = tamil.utf8.get_letters(wordA)\n    else:\n        lettersA = wordA\n    \n    if not type(wordB) is list:\n        lettersB = tamil.utf8.get_letters(wordB)\n    else:\n        lettersB = wordB\n    n_A = len(lettersA)\n    n_B = len(lettersB)\n    # OK only if unique - set(lettersA).intersection(set(lettersB))\n    n_AB = len( list( filter( lambda cmnL: cmnL in lettersB, lettersA) ) )\n    return (2.0*n_AB)/(n_A+n_B)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_splits(self):\n        L = len(self.letters)-1\n        for idx,letter in enumerate(self.letters):\n            if not( letter in tamil.utf8.grantha_uyirmei_letters):\n                continue\n            muthal = idx == 0 and u\"\" or u\"\".join(self.letters[0:idx])\n            meethi = idx == L and u\"\" or u\"\".join(self.letters[idx+1:])\n            mei,uyir = tamil.utf8.splitMeiUyir(letter)\n            muthal = muthal + mei\n            meethi = uyir + meethi\n            self.results.append([muthal,meethi])\n        return len(self.results) > 0", "response": "Generate the splits of the muthal mei and uyir."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a list of patterns for the given word.", "response": "def oridam_generate_patterns(word_in,cm,ed=1,level=0,pos=0,candidates=None):\n    \"\"\" ed = 1 by default, pos - internal variable for algorithm \"\"\"\n    alternates = cm.get(word_in[pos],[])\n    if not candidates:\n        candidates = []\n    assert ed <= len(word_in), 'edit distance has to be comparable to word size [ins/del not explored]'\n    if (pos >len(word_in)) or ed == 0:\n        return candidates\n    pfx = ''\n    sfx = ''\n    curr_candidates = []\n    for p in range(0,pos):\n        pfx = pfx + word_in[p]\n    for p in range(pos+1,len(word_in)):\n        sfx = sfx + word_in[p]\n    for alt in alternates:\n        word_alt = pfx + alt + sfx\n        if not (word_alt in candidates):\n            candidates.append( word_alt )\n            curr_candidates.append( word_alt )\n    for n_pos in range(pos,len(word_in)):\n        # already what we have ' candidates ' of this round are edit-distance 1\n        for word in curr_candidates:\n            oridam_generate_patterns(word,cm,ed-1,level+1,n_pos,candidates)\n    if level == 0:\n        #candidates.append(word_in)\n        for n_pos in range(pos,len(word_in)):\n            oridam_generate_patterns(word_in,cm,ed, level+1,n_pos,candidates)\n    return candidates"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_unicode_repr( _letter ):\n    # Python 2-3 compatible\n    return u\"u'\"+ u\"\".join( [ u\"\\\\u%04x\"%ord(l) for l in _letter ] ) + u\"'\"", "response": "Convert a unicode character to a unicode string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef uyirmei_constructed( mei_idx, uyir_idx):\n    idx,idy = mei_idx,uyir_idx\n    assert ( idy >= 0 and idy < uyir_len() )\n    assert ( idx >= 0 and idx < 6+mei_len() )\n    return grantha_agaram_letters[mei_idx]+accent_symbols[uyir_idx]", "response": "construct uyirmei letter give mei index and uyir index"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if the string contains any English letters in the string.", "response": "def has_english( word_in ):\n    \"\"\" return True if word_in has any English letters in the string\"\"\"\n    return not all_tamil(word_in) and len(word_in) > 0 and any([l in word_in for l in string.ascii_letters])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all_tamil( word_in ):\n    if isinstance(word_in,list):\n        word = word_in\n    else:\n        word = get_letters( word_in )\n    return all( [(letter in tamil_letters) for letter in word] )", "response": "predicate checks if all letters of the input word are Tamil letters"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reverse_word( word ):\n    op = get_letters( word )\n    op.reverse()\n    return u\"\".join(op)", "response": "reverse a Tamil word according to letters not unicode - points"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of all the letters present in the word", "response": "def get_letters( word ):\n    \"\"\" splits the word into a character-list of tamil/english\n    characters present in the stream \"\"\"\n    ta_letters = list()\n    not_empty = False\n    WLEN,idx = len(word),0\n    while (idx < WLEN):\n        c = word[idx]\n        #print(idx,hex(ord(c)),len(ta_letters))\n        if c in uyir_letter_set or c == ayudha_letter:\n            ta_letters.append(c)\n            not_empty = True\n        elif c in grantha_agaram_set:\n            ta_letters.append(c)\n            not_empty = True\n        elif c in accent_symbol_set:\n            if not not_empty:\n                # odd situation\n                ta_letters.append(c)\n                not_empty = True\n            else:\n                #print(\"Merge/accent\")\n                ta_letters[-1] += c\n        else:\n            if ord(c) < 256 or not (is_tamil_unicode(c)):\n                ta_letters.append( c )\n            else:\n                if not_empty:\n                    #print(\"Merge/??\")\n                    ta_letters[-1]+= c\n                else:\n                    ta_letters.append(c)\n                    not_empty = True\n        idx = idx + 1\n    return ta_letters"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an iterable of all letters in the word", "response": "def get_letters_iterable( word ):\n    \"\"\" splits the word into a character-list of tamil/english\n    characters present in the stream \"\"\"\n    WLEN,idx = len(word),0\n\n    while (idx < WLEN):\n        c = word[idx]\n        #print(idx,hex(ord(c)),len(ta_letters))\n        if c in uyir_letter_set or c == ayudha_letter:\n            idx = idx + 1\n            yield c\n        elif c in grantha_agaram_set:\n            if idx + 1 < WLEN and word[idx+1] in all_symbol_set:\n                c2 = word[idx+1]\n                idx = idx + 2\n                yield (c + c2)\n            else:\n                idx = idx + 1\n                yield c\n        else:\n            idx = idx + 1\n            yield c\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nyield a list of words from a list of UTF - 8 letters", "response": "def get_words_iterable( letters, tamil_only=False ):\n    \"\"\" given a list of UTF-8 letters section them into words, grouping them at spaces \"\"\"\n\n    # correct algorithm for get-tamil-words\n    buf = []\n    for idx,let in enumerate(letters):\n        if not let.isspace():\n            if istamil(let) or (not tamil_only):\n                buf.append( let )\n        else:\n            if len(buf) > 0:\n                yield  u\"\".join( buf )\n                buf = []\n    if len(buf) > 0:\n        yield u\"\".join(buf)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreversing a Tamil word according to letters not unicode - points", "response": "def get_tamil_words( letters ):\n    \"\"\" reverse a Tamil word according to letters, not unicode-points \"\"\"\n    if not isinstance(letters,list):\n        raise Exception(\"metehod needs to be used with list generated from 'tamil.utf8.get_letters(...)'\")\n    return [word for word in get_words_iterable( letters, tamil_only = True )]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomparing words in Tamil lexicographic order", "response": "def compare_words_lexicographic( word_a, word_b ):\n    \"\"\" compare words in Tamil lexicographic order \"\"\"\n    # sanity check for words to be all Tamil\n    if ( not all_tamil(word_a) ) or (not all_tamil(word_b)) :\n        #print(\"## \")\n        #print(word_a)\n        #print(word_b)\n        #print(\"Both operands need to be Tamil words\")\n        pass\n    La = len(word_a)\n    Lb = len(word_b)\n    all_TA_letters = u\"\".join(tamil_letters)\n    for itr in range(0,min(La,Lb)):\n            pos1 = all_TA_letters.find( word_a[itr] )\n            pos2 = all_TA_letters.find( word_b[itr] )\n\n            if pos1 != pos2 :\n                    #print  not( pos1 > pos2), pos1, pos2\n                    return cmp(pos1, pos2)\n\n    # result depends on if La is shorter than Lb, or 0 if La == Lb  i.e. cmp\n    return cmp(La,Lb)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef word_intersection( word_a, word_b ):\n    positions = []\n    word_a_letters = get_letters( word_a )\n    word_b_letters = get_letters( word_b )\n    for idx,wa in enumerate(word_a_letters):\n        for idy,wb in enumerate(word_b_letters):\n            if ( wa == wb ):\n                positions.append( (idx, idy) )\n    return positions", "response": "return a list of tuples where word_a and word_b intersect"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef joinMeiUyir(mei_char, uyir_char):\n    if not mei_char: return uyir_char\n    if not uyir_char: return mei_char\n    \n    if not isinstance(mei_char, PYTHON3 and str or unicode):\n        raise ValueError(u\"Passed input mei character '%s' must be unicode, not just string\" % mei_char)\n    if not isinstance(uyir_char, PYTHON3 and str or unicode) and uyir_char != None:\n        raise ValueError(u\"Passed input uyir character '%s' must be unicode, not just string\" % uyir_char)\n    if mei_char not in grantha_mei_letters:\n        raise ValueError(u\"Passed input character '%s' is not a tamil mei character\" % mei_char)\n    if uyir_char not in uyir_letters:\n        raise ValueError(u\"Passed input character '%s' is not a tamil uyir character\" % uyir_char)\n    if uyir_char:\n        uyiridx = uyir_letters.index(uyir_char)\n    else:\n        return mei_char\n    meiidx = grantha_mei_letters.index(mei_char)\n    # calculate uyirmei index\n    uyirmeiidx = meiidx*12 + uyiridx\n    return grantha_uyirmei_letters[uyirmeiidx]", "response": "This function joins mei character and uyir character and returns as\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexpands uyir or mei - letter range etc.", "response": "def expand_tamil(start,end):\n    \"\"\" expand uyir or mei-letter range etc.\n        i.e. \u0b85-\u0b94  gets converted to \u0b85,\u0b86,\u0b87,\u0b88,\u0b89,\u0b8a,\u0b8e,\u0b8f,\u0b90,\u0b92,\u0b93,\u0b94 etc.\n    \"\"\"\n    # few sequences\n    for seq in [utf8.uyir_letters, utf8.grantha_mei_letters, \\\n                utf8.grantha_agaram_letters]:\n        if is_containing_seq(start,end,seq):\n            return expand_sequence(start,end,seq)\n    # all Tamil letters\n    seq = utf8.grantha_uyirmei_letters\n    if is_containing_seq(start,end,seq):\n        return expand_sequence(start,end,seq)\n    \n    raise Exception(\"Cannot understand sequence [%s-%s]\"%(start,end))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_pattern( patt, flags=0 ):\n    # print('input',len(patt))\n    patt_letters = utf8.get_letters( patt )\n    patt_out = list()\n    idx = 0\n    # print('output',len(patt_letters))\n    patt = [None,None]\n    prev = None\n    LEN_PATT = len(patt_letters)\n    while( idx < LEN_PATT ):\n        if utf8.istamil( patt_letters[idx] ) and ( prev == '-' or ((idx+1) < LEN_PATT and patt_letters[idx+1] == u'-') ):\n            if (idx+1) < LEN_PATT and patt_letters[idx+1] == u'-':\n                patt[0] = patt_letters[idx]\n                idx = idx + 2\n                prev = \"-\"\n            elif prev == '-':\n                patt[1] = patt_letters[idx]\n                patt_out.extend( expand_tamil( patt[0], patt[1]) )\n                idx = idx + 1\n                prev = patt_letters[idx]\n            continue\n        patt_out.extend( patt_letters[idx] )\n        prev = patt_letters[idx]\n        idx = idx + 1\n    opattern = u\"\".join( patt_out )\n    compile_regexp = re.compile( opattern, flags )        \n    return (compile_regexp,opattern)", "response": "returns a compile regular expression object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef frequency_model( self ):\n        prev_letter = None\n        # use a generator in corpus\n        prev_letter = list(self.corpus.next_tamil_letter())[0]\n        for next_letter in self.corpus.next_tamil_letter():\n            # update frequency from corpus\n            key = prev_letter+next_letter\n            val = self.bigram.get(key,None)\n            prev_letter = next_letter\n            if not val:\n                self.bigram[key] = 0\n            self.bigram[key] += 1\n        \n        return", "response": "build a letter frequency model for Tamil letters from a corpus"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a byte - ASCII encoded string into equivalent Unicode string", "response": "def convert_to_unicode( tscii_input ):\n    \"\"\" convert a byte-ASCII encoded string into equivalent Unicode string\n    in the UTF-8 notation.\"\"\"\n    output = list()\n    prev = None\n    prev2x = None\n    # need a look ahead of 2 tokens atleast\n    for char in tscii_input:\n        ## print \"%2x\"%ord(char) # debugging\n        if ord(char) < 128 :\n            # base-ASCII copy to output\n            output.append( char )\n            prev = None\n            prev2x = None\n            \n        elif ord(char) in ISCII_DIRECT_LOOKUP:\n            if ( prev in ISCII_PRE_MODIFIER ):\n                curr_char = [ISCII[ord(char)],ISCII[prev]]                \n            else:\n                # we are direct lookup char\n                curr_char = [ISCII[ord(char)]]\n                char = None\n\n            output.extend( curr_char )\n\n        elif ( (ord(char) in ISCII_POST_MODIFIER) ): \n            \n            if ( (prev in ISCII_DIRECT_LOOKUP) and \n                 (prev2x in ISCII_PRE_MODIFIER) ):\n                if len(output) >= 2:\n                    del output[-1] #we are reducing this token to something new\n                    del output[-2]\n                elif len(output)==1:\n                    del output[-1] \n                else:\n                    # nothing to delete here.. \n                    pass\n                output.extend( [ISCII[prev], ISCII[prev2x]] )\n            else:\n                print(\"Warning: malformed ISCII encoded file; skipping characters\")\n            \n            prev = None\n            char = None\n        else:\n            # pass - must be one of the pre/post modifiers\n            pass\n        \n        prev2x = prev\n        if char:\n            prev = ord(char)\n    return u\"\".join(output)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the intersection graph into the dictionary of words and their intersections", "response": "def compute( self ):\r\n        # compute the intersection graph into @xsections dictionary\r\n        wordlist = self.wordlist\r\n        \"\"\" build a dictionary of words, and their intersections \"\"\"\r\n        xsections = {}\r\n        for i in range(len(wordlist)):\r\n            word_i = wordlist[i]\r\n            for j in range(len(wordlist)):\r\n                word_j = wordlist[j]\r\n                if i == j:\r\n                    # force self-intersection to be 0\r\n                    if not xsections.get(word_i,None):\r\n                        xsections[word_i] = ['']\r\n                    else:\r\n                        xsections[word_i].extend([''])\r\n                    continue\r\n                # optimize for, i > j, info is calculated already \r\n                if i > j:\r\n                    xsec_counts = xsections[word_j][i]\r\n                else:\r\n                    xsec_counts = tamil.utf8.word_intersection( word_i, word_j )\r\n                if not xsections.get(word_i,None):\r\n                    xsections[word_i] =  [xsec_counts]\r\n                else:\r\n                    xsections[word_i].extend( [ xsec_counts ] )\r\n        self.xsections = xsections"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if word is in sequence", "response": "def in_sequence( word, ref_set, ref_reason, freq_threshold = 2 ):\n        \"\"\" ignore ctx information right now. If repetition/match length >= @freq_threshold then we flag-it \"\"\"\n        chars = get_letters(word)\n        flag = True #no error assumed\n        reason = None #no reason\n        freq_count = 0\n        for char in chars:\n            if char in ref_set:\n                freq_count += 1\n                if freq_count >= freq_threshold:\n                    flag = False\n                    break\n                continue\n            freq_count = 0 # continue loop\n        if not flag:\n            reason = ref_reason\n        return flag,reason"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply(self, word, ctx=None):\n        return Sequential.in_sequence(word,AdjacentVowels.uyir_letters,AdjacentVowels.reason)", "response": "apply the rule to word"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying the rule to word", "response": "def apply(self, word, ctx=None):\n        \"\"\" ignore ctx information right now \"\"\"\n        flag,reason = Sequential.in_sequence(word,AdjacentConsonants.mei_letters,AdjacentConsonants.reason,self.freq_threshold)\n        if flag:\n            flag,reason = Sequential.in_sequence(word,AdjacentConsonants.agaram_letters,AdjacentConsonants.reason,self.freq_threshold)\n        return flag,reason"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef apply(self,word,ctx=None):\n        chars = get_letters(word)\n        flag = True #no error assumed\n        reason = None #no reason\n        prev_letter = None\n        for char in chars:\n            if prev_letter == char:\n                flag = False\n                break\n            prev_letter = char # continue loop\n        if not flag:\n            reason = RepeatedLetters.reason\n        return flag,reason", "response": "check if the word is in the list of letters and return the flag and reason"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apply(self, word, ctx=None):\n        chars = get_letters(word)\n        flag = True #no error assumed\n        reason = None #no reason\n        prev_char = None\n\n        for char in chars:\n            rule1,rule2,rule3 = False,False,False\n            # rule 1 : uyir followed by kombugal\n            rule1 = (char[-1] in utf8.accent_symbols) and (char[0] in utf8.uyir_letters)\n            if not rule1:\n                # rule 2 : two pullis adjacent to each other\n                rule2 = len(char) >= 2 and (char[-1] == utf8.pulli_symbols[0]) and (char[-2] == char[-1] )\n                if not rule2:\n                    # rule 3 : none of the accent symbols repeat\n                    # exclusions to rule 3 : non-standard Unicode encoding of periya kombu / siriya kombu with thunai kaal\n                    rule3 =  len(char) >= 2 and (char[-1] in utf8.accent_symbols) and (char[-2] in utf8.accent_symbols) \\\n                    and not( char[-1] == u\"\u0bbe\" and char[-2] in [u\"\u0bc6\",u\"\u0bc7\"])\n\n            if rule1 or rule2 or rule3:\n                flag = False\n                reason = BadIME.reason\n                break\n            prev_char = char # continue loop\n        #print([flag,reason])\n        return flag,reason", "response": "check if the word is in the list of possible characters"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the current string.", "response": "def set_current(self, value):\n        '''\n        Set the self.current string.\n        '''\n        self.current = value\n        self.cursor = 0\n        self.limit = len(self.current)\n        self.limit_backward = 0\n        self.bra = self.cursor\n        self.ket = self.limit"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef replace_s(self, c_bra, c_ket, s):\n        '''\n        to replace chars between c_bra and c_ket in self.current by the\n        chars in s.\n\n        @type c_bra int\n        @type c_ket int\n        @type s: string\n        '''\n        adjustment = len(s) - (c_ket - c_bra)\n        self.current = self.current[0:c_bra] + s + self.current[c_ket:]\n        self.limit += adjustment\n        if self.cursor >= c_ket:\n            self.cursor += adjustment\n        elif self.cursor > c_bra:\n            self.cursor = c_bra\n        return adjustment", "response": "replace_s is used to replace the current string by the characters between c_bra and c_ket in self. current by the the\n            chars in s."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef slice_to(self, s):\n        '''\n        Copy the slice into the supplied StringBuffer\n\n        @type s: string\n        '''\n        result = ''\n        if self.slice_check():\n            result = self.current[self.bra:self.ket]\n        return result", "response": "Copy the slice into the supplied StringBuffer"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isTamilPredicate(word):\n        for c in word:\n            if unicodedata.name(c).split()[0] != u'TAMIL' :\n                return False\n        return True", "response": "is Tamil word : boolean True/False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cleanupPunct( tweet ):\n        tweet = ''.join( map( lambda c: (unicodedata.name(c).split()[0] in [u'TAMIL',u'LATIN']) and c or u' ', tweet) )\n        return tweet", "response": "Remove punctuation from a tweet."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nword needs to all be in the same tamil language", "response": "def getTamilWords( tweet ):\n        \"\"\"\" word needs to all be in the same tamil language \"\"\"\n        tweet = TamilTweetParser.cleanupPunct( tweet );\n        nonETwords = filter( lambda x: len(x) > 0 , re.split(r'\\s+',tweet) );#|\"+|\\'+|#+\n        tamilWords = filter( TamilTweetParser.isTamilPredicate, nonETwords );\n        return tamilWords"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a byte - ASCII encoded string into equivalent Unicode string", "response": "def convert_to_unicode( tscii_input ):\n    \"\"\" convert a byte-ASCII encoded string into equivalent Unicode string\n    in the UTF-8 notation.\"\"\"\n    output = list()\n    prev = None\n    prev2x = None\n    # need a look ahead of 2 tokens atleast\n    for char in tscii_input:\n        ## print \"%2x\"%ord(char) # debugging\n        if ord(char) < 128 :\n            # base-ASCII copy to output\n            output.append( char )\n            prev = None\n            prev2x = None\n            \n        elif ord(char) in TSCII_DIRECT_LOOKUP:\n            if ( prev in TSCII_PRE_MODIFIER ):\n                curr_char = [TSCII[ord(char)],TSCII[prev]]                \n            else:\n                # we are direct lookup char\n                curr_char = [TSCII[ord(char)]]\n                char = None\n\n            output.extend( curr_char )\n\n        elif ( (ord(char) in TSCII_POST_MODIFIER) ): \n            \n            if ( (prev in TSCII_DIRECT_LOOKUP) and \n                 (prev2x in TSCII_PRE_MODIFIER) ):\n                if len(output) >= 2:\n                    del output[-1] #we are reducing this token to something new\n                    del output[-2]\n                elif len(output)==1:\n                    del output[-1] \n                else:\n                    # nothing to delete here.. \n                    pass\n                output.extend( [TSCII[prev], TSCII[prev2x]] )\n            else:\n                print(\"Warning: malformed TSCII encoded file; skipping characters\")\n            \n            prev = None\n            char = None\n        else:\n            # pass - must be one of the pre/post modifiers\n            pass\n        \n        prev2x = prev\n        if char:\n            prev = ord(char)\n    return u\"\".join(output)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the first unique character in the input text.", "response": "def _get_unique_ch(text, all_common_encodes):\r\n    \"\"\"\r\n        text : encode sample strings\r\n\r\n        returns unique word / characters from input text encode strings.\r\n    \"\"\"\r\n\r\n    unique_chars = ''\r\n    if isinstance(text, str):\r\n        text = text.split(\"\\n\")\r\n    elif isinstance(text, (list, tuple)):\r\n        pass\r\n\r\n    special_chars = ['.', ',', ';', ':','', ' ', '\\r', '\\t', '=', '\\n']\r\n    for line in text:\r\n        for word in line.split(' '):\r\n            if ( not PYTHON3 ): word = word.decode( 'utf-8')\r\n            for ch in all_common_encodes:\r\n                if ch in word: word = word.replace(ch, '')\r\n            # end of for ch in _all_common_encodes_:\r\n            # if len of word is zero, then go for another word\r\n            if not word: continue\r\n\r\n            for ch in word:\r\n                if ch.isdigit() or ch in special_chars:\r\n                    # remove special common chars\r\n                    word = word.replace(ch, '')\r\n                    continue\r\n                # end of if ch.isdigit() or ...:\r\n                # Whola, got unique chars from user passed text\r\n                return word\r\n            # end of for ch in word:\r\n        # end of for word in line.split(' '):\r\n    # end of for line in text:\r\n    return ''"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_unique_common_encodes():\r\n\r\n    _all_unique_encodes_ = []\r\n    _all_unicode_encodes_ = {}\r\n    _all_common_encodes_ = set([])\r\n    _all_common_encodes_single_char_ = set([])\r\n\r\n    for name, encode in _all_encodes_.items():\r\n        encode_utf8 = set([PYTHON3 and ch or ch.decode( 'utf-8') for ch in encode.keys()])\r\n        _all_unicode_encodes_[name] = encode_utf8\r\n    _all_unique_encodes_full_ =_all_unicode_encodes_.copy()\r\n\r\n    for supname, super_encode in _all_unicode_encodes_.items():\r\n        for subname, sub_encode in _all_unicode_encodes_.items():\r\n            if supname == subname: continue\r\n            # get unique of super_encode among other encodings\r\n            super_encode = super_encode - sub_encode\r\n        # get common for all over encodings\r\n        common = _all_unique_encodes_full_[supname] - super_encode\r\n        # merge common to all encodings common\r\n        _all_common_encodes_ = _all_common_encodes_.union(common)\r\n        # store super_encode's unique keys with its name\r\n        _all_unique_encodes_.append((supname, super_encode))\r\n    for ch in _all_common_encodes_:\r\n        # collect single common chars\r\n        if len(ch) == 1: _all_common_encodes_single_char_.add(ch)\r\n    # end of for ch in _all_common_encodes_:\r\n\r\n    # remove single common char from compound common chars\r\n    _all_common_encodes_ -= _all_common_encodes_single_char_\r\n\r\n\r\n    if __WRITE_CHARS_TXT:\r\n        # write common compound characters of all encodes\r\n        f = open('all.encodes.common.chars.txt', 'w')\r\n        for ch in _all_common_encodes_:\r\n            ch = ch.encode('utf-8')\r\n            for encode_keys in _all_encodes_.values():\r\n                if ch in encode_keys:\r\n                    uni = encode_keys[ch]\r\n                    break\r\n                # end of if ch in encode_keys:\r\n            # end of for encode_keys in _all_encodes_.values():\r\n            f.write(ch + '  =>  ' + uni + '\\n')\r\n        # end of for ch in _all_common_encodes_:\r\n        f.close()\r\n        # write unique compound characters of all encodes\r\n        for encode_name, encode_keys in _all_unique_encodes_:\r\n            f = open(encode_name + '.unique.chars.txt', 'w')\r\n            for ch in encode_keys:\r\n                ch = ch.encode('utf-8')\r\n                uni = _all_encodes_[encode_name][ch]\r\n                f.write(ch + '  =>  ' + uni + '\\n')\r\n            # end of for ch in encode_keys:\r\n            f.close()\r\n        # end of for encode_name, encode_keys in _all_unique_encodes_:\r\n    # end of if __WRITE_CHARS_TXT:\r\n\r\n    return (_all_unique_encodes_, _all_common_encodes_)", "response": "Returns a tuple of unique and common encodings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef auto2unicode(text):\r\n\r\n    _all_unique_encodes_, _all_common_encodes_ = _get_unique_common_encodes()\r\n    # get unique word which falls under any one of available encodes from\r\n    # user passed text lines\r\n    unique_chars = _get_unique_ch(text, _all_common_encodes_)\r\n    # count common encode chars\r\n    clen = len(_all_common_encodes_)\r\n    msg = \"Sorry, couldn't find encode :-(\\n\"\r\n    msg += 'Need more words to find unique encode out side of %d ' % clen\r\n    msg += 'common compound characters'\r\n    if not unique_chars:\r\n        print(msg)\r\n        return ''\r\n    # end of if not unique_chars:\r\n\r\n    for encode_name, encode_keys in _all_unique_encodes_:\r\n        if not len(encode_keys): continue\r\n        for ch in encode_keys:\r\n            # check either encode char is presnent in word\r\n            if ch in unique_chars:\r\n                # found encode\r\n                print((\"Found encode : \", encode_name))\r\n                encode = _all_encodes_[encode_name]\r\n                return encode2unicode(text, encode)\r\n            # end of if ch in unique_chars:\r\n        # end of ifor ch in encode_keys:\r\n    else:\r\n        print(msg)\r\n        return ''", "response": "This function tries to identify encode in available encodings and converts text into unicode string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a letter frequency model for Tamil letters from a corpus", "response": "def frequency_model( self ):\n        \"\"\" build a letter frequency model for Tamil letters from a corpus \"\"\"\n        # use a generator in corpus\n        for next_letter in self.corpus.next_tamil_letter():\n            # update frequency from corpus\n            self.letter[next_letter] = self.letter[next_letter] + 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a Tamil bigram letter model", "response": "def language_model(self,verbose=True):\n        \"\"\" builds a Tamil bigram letter model \"\"\"\n        # use a generator in corpus\n        prev = None\n        for next_letter in self.corpus.next_tamil_letter():\n            # update frequency from corpus\n            if prev:\n                self.letter2[prev][next_letter] += 1\n                if ( verbose ) :\n                    print(prev)\n                    print(next_letter)\n                    print( self.letter2[prev][next_letter] )\n            prev = next_letter #update always\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef language_model(self,verbose=True):\n        # use a generator in corpus\n        p2 = None\n        p1 = None\n        for next_letter in self.corpus.next_tamil_letter():\n            # update frequency from corpus\n            if p2:\n                trig = p2+p1+next_letter\n                self.letter3[trig] = 1 + self.letter3.get(trig,0)\n            p2 = p1\n            p1 = next_letter #update always\n        return", "response": "builds a Tamil bigram letter model"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a number into a tamil string", "response": "def num2tamilstr( *args ):\n    \"\"\" work till one lakh crore - i.e 1e5*1e7 = 1e12.\n        turn number into a numeral, Indian style. Fractions upto 1e-30\"\"\"\n    number = args[0]\n    if len(args) < 2:\n        filenames = []\n    else:\n        filenames = args[1]\n    if len(args) ==3:\n        tensSpecial = args[2]\n    else:\n        tensSpecial='BASIC'\n    if not any( filter( lambda T: isinstance( number, T), [str,unicode,int, long, float]) ) or isinstance(number,complex):\n        raise Exception('num2tamilstr input has to be a long or integer or float')\n    if float(number) > long(1e12):\n        raise Exception('num2tamilstr input is too large')\n    if float(number) < 0:\n        return u\"- \"+num2tamilstr( -number )\n\n    units = (u'\u0baa\u0bc2\u0b9c\u0bcd\u0b9c\u0bbf\u0baf\u0bae\u0bcd', u'\u0b92\u0ba9\u0bcd\u0bb1\u0bc1', u'\u0b87\u0bb0\u0ba3\u0bcd\u0b9f\u0bc1', u'\u0bae\u0bc2\u0ba9\u0bcd\u0bb1\u0bc1', u'\u0ba8\u0bbe\u0ba9\u0bcd\u0b95\u0bc1', u'\u0b90\u0ba8\u0bcd\u0ba4\u0bc1', u'\u0b86\u0bb1\u0bc1', u'\u0b8f\u0bb4\u0bc1', u'\u0b8e\u0b9f\u0bcd\u0b9f\u0bc1', u'\u0b92\u0ba9\u0bcd\u0baa\u0ba4\u0bc1', u'\u0baa\u0ba4\u0bcd\u0ba4\u0bc1') # 0-10\n    units_suffix = (u'\u0baa\u0bc2\u0b9c\u0bcd\u0b9c\u0bbf\u0baf\u0bae\u0bcd', u'\u0ba4\u0bca\u0ba9\u0bcd\u0bb1\u0bc1', u'\u0ba4\u0bbf\u0bb0\u0ba3\u0bcd\u0b9f\u0bc1', u'\u0bae\u0bc2\u0ba9\u0bcd\u0bb1\u0bc1', u'\u0ba8\u0bbe\u0ba9\u0bcd\u0b95\u0bc1', u'\u0ba4\u0bc8\u0ba8\u0bcd\u0ba4\u0bc1', u'\u0ba4\u0bbe\u0bb1\u0bc1', u'\u0ba4\u0bc7\u0bb4\u0bc1', u'\u0ba4\u0bc6\u0b9f\u0bcd\u0b9f\u0bc1', u'\u0ba4\u0bca\u0ba9\u0bcd\u0baa\u0ba4\u0bc1', u'\u0baa\u0ba4\u0bcd\u0ba4\u0bc1') # 0-10\n    units_suffix_nine = (u'\u0baa\u0bc2\u0b9c\u0bcd\u0b9c\u0bbf\u0baf\u0bae\u0bcd', u'\u0bb1\u0bca\u0ba9\u0bcd\u0bb1\u0bc1', u'\u0bb1\u0bbf\u0bb0\u0ba3\u0bcd\u0b9f\u0bc1', u'\u0bae\u0bc2\u0ba9\u0bcd\u0bb1\u0bc1', u'\u0ba8\u0bbe\u0ba9\u0bcd\u0b95\u0bc1', u'\u0bb1\u0bc8\u0ba8\u0bcd\u0ba4\u0bc1', u'\u0bb1\u0bbe\u0bb1\u0bc1', u'\u0bb1\u0bc7\u0bb4\u0bc1', u'\u0bb1\u0bc6\u0b9f\u0bcd\u0b9f\u0bc1', u'\u0bb1\u0bca\u0ba9\u0bcd\u0baa\u0ba4\u0bc1', u'\u0baa\u0ba4\u0bcd\u0ba4\u0bc1') # 0-10\n    tween = [1.0,2.0,5.0,6.0,7.0,8.0,9.0]\n    teens = (u'\u0baa\u0ba4\u0bbf\u0ba9\u0bca\u0ba9\u0bcd\u0bb1\u0bc1', u'\u0baa\u0ba9\u0bbf\u0bb0\u0ba3\u0bcd\u0b9f\u0bc1', u'\u0baa\u0ba4\u0bbf\u0bae\u0bc2\u0ba9\u0bcd\u0bb1\u0bc1', u'\u0baa\u0ba4\u0bbf\u0ba9\u0bbe\u0ba9\u0bcd\u0b95\u0bc1', u'\u0baa\u0ba4\u0bbf\u0ba9\u0bc8\u0ba8\u0bcd\u0ba4\u0bc1',u'\u0baa\u0ba4\u0bbf\u0ba9\u0bbe\u0bb1\u0bc1', u'\u0baa\u0ba4\u0bbf\u0ba9\u0bc7\u0bb4\u0bc1', u'\u0baa\u0ba4\u0bbf\u0ba9\u0bc6\u0b9f\u0bcd\u0b9f\u0bc1', u'\u0baa\u0ba4\u0bcd\u0ba4\u0bca\u0ba9\u0bcd\u0baa\u0ba4\u0bc1') # 11-19\n    tens = (u'\u0baa\u0ba4\u0bcd\u0ba4\u0bc1', u'\u0b87\u0bb0\u0bc1\u0baa\u0ba4\u0bc1', u'\u0bae\u0bc1\u0baa\u0bcd\u0baa\u0ba4\u0bc1', u'\u0ba8\u0bbe\u0bb1\u0bcd\u0baa\u0ba4\u0bc1', u'\u0b90\u0bae\u0bcd\u0baa\u0ba4\u0bc1',u'\u0b85\u0bb1\u0bc1\u0baa\u0ba4\u0bc1', u'\u0b8e\u0bb4\u0bc1\u0baa\u0ba4\u0bc1', u'\u0b8e\u0ba3\u0bcd\u0baa\u0ba4\u0bc1', u'\u0ba4\u0bca\u0ba9\u0bcd\u0ba9\u0bc2\u0bb1\u0bc1') # 10-90\n    tens_full_prefix = (u'\u0b87\u0bb0\u0bc1\u0baa\u0ba4\u0bcd\u0ba4\u0bc1', u'\u0bae\u0bc1\u0baa\u0bcd\u0baa\u0ba4\u0bcd\u0ba4\u0bc1', u'\u0ba8\u0bbe\u0bb1\u0bcd\u0baa\u0ba4\u0bcd\u0ba4\u0bc1', u'\u0b90\u0bae\u0bcd\u0baa\u0ba4\u0bcd\u0ba4\u0bc1', u'\u0b85\u0bb1\u0bc1\u0baa\u0ba4\u0bcd\u0ba4\u0bc1', u'\u0b8e\u0bb4\u0bc1\u0baa\u0ba4\u0bcd\u0ba4\u0bc1', u'\u0b8e\u0ba3\u0bcd\u0baa\u0ba4\u0bcd\u0ba4\u0bc1', u'\u0ba4\u0bca\u0ba9\u0bcd\u0ba9\u0bc2\u0bb1\u0bcd\u0bb1\u0bc1') # 10+-90+\n    tens_prefix = (u'\u0b87\u0bb0\u0bc1\u0baa\u0ba4\u0bcd', u'\u0bae\u0bc1\u0baa\u0bcd\u0baa\u0ba4\u0bcd', u'\u0ba8\u0bbe\u0bb1\u0bcd\u0baa\u0ba4\u0bcd', u'\u0b90\u0bae\u0bcd\u0baa\u0ba4\u0bcd', u'\u0b85\u0bb1\u0bc1\u0baa\u0ba4\u0bcd', u'\u0b8e\u0bb4\u0bc1\u0baa\u0ba4\u0bcd', u'\u0b8e\u0ba3\u0bcd\u0baa\u0ba4\u0bcd', u'\u0ba4\u0bca\u0ba9\u0bcd\u0ba9\u0bc2\u0bb1\u0bcd') # 10+-90+\n    hundreds = ( u'\u0ba8\u0bc2\u0bb1\u0bc1', u'\u0b87\u0bb0\u0bc1\u0ba8\u0bc2\u0bb1\u0bc1', u'\u0bae\u0bc1\u0ba9\u0bcd\u0ba9\u0bc2\u0bb1\u0bc1', u'\u0ba8\u0bbe\u0ba8\u0bc2\u0bb1\u0bc1',u'\u0b90\u0ba8\u0bc2\u0bb1\u0bc1', u'\u0b85\u0bb1\u0bc1\u0ba8\u0bc2\u0bb1\u0bc1', u'\u0b8e\u0bb4\u0bc1\u0ba8\u0bc2\u0bb1\u0bc1', u'\u0b8e\u0ba3\u0bcd\u0ba3\u0bc2\u0bb1\u0bc1', u'\u0ba4\u0bca\u0bb3\u0bcd\u0bb3\u0bbe\u0baf\u0bbf\u0bb0\u0bae\u0bcd') #100 - 900\n    hundreds_suffix = (u'\u0ba8\u0bc2\u0bb1\u0bcd\u0bb1\u0bbf', u'\u0b87\u0bb0\u0bc1\u0ba8\u0bc2\u0bb1\u0bcd\u0bb1\u0bc1', u'\u0bae\u0bc1\u0ba9\u0bcd\u0ba9\u0bc2\u0bb1\u0bcd\u0bb1\u0bc1', u'\u0ba8\u0bbe\u0ba8\u0bc2\u0bb1\u0bcd\u0bb1\u0bc1', u'\u0b90\u0ba8\u0bc2\u0bb1\u0bcd\u0bb1\u0bc1', u'\u0b85\u0bb1\u0bc1\u0ba8\u0bc2\u0bb1\u0bcd\u0bb1\u0bc1', u'\u0b8e\u0bb4\u0bc1\u0ba8\u0bc2\u0bb1\u0bcd\u0bb1\u0bc1', u'\u0b8e\u0ba3\u0bcd\u0ba3\u0bc2\u0bb1\u0bcd\u0bb1\u0bc1',u'\u0ba4\u0bca\u0bb3\u0bcd\u0bb3\u0bbe\u0baf\u0bbf\u0bb0\u0ba4\u0bcd\u0ba4\u0bc1') #100+ - 900+\n\n    one_thousand_prefix = u'\u0b93\u0bb0\u0bcd'\n    thousands = (u'\u0b86\u0baf\u0bbf\u0bb0\u0bae\u0bcd',u'\u0b86\u0baf\u0bbf\u0bb0\u0ba4\u0bcd\u0ba4\u0bc1')\n\n    one_prefix = u'\u0b92\u0bb0\u0bc1'\n    lakh = (u'\u0b87\u0bb2\u0b9f\u0bcd\u0b9a\u0bae\u0bcd',u'\u0b87\u0bb2\u0b9f\u0bcd\u0b9a\u0ba4\u0bcd\u0ba4\u0bc1')\n    crore = (u'\u0b95\u0bcb\u0b9f\u0bbf',u'\u0b95\u0bcb\u0b9f\u0bbf\u0baf\u0bc7')\n\n    pulli = u'\u0baa\u0bc1\u0bb3\u0bcd\u0bb3\u0bbf'\n    n_one = 1.0\n    n_ten = 10.0\n    n_hundred = 100.0\n    n_thousand = 1000.0\n    n_lakh = 100.0*n_thousand\n    n_crore = (100.0*n_lakh)\n    # handle fractional parts\n    if float(number) > 0.0 and float(number) < 1.0:\n        rval = []\n        rval.append(pulli)\n        filenames.append( 'pulli' )\n        number_str = str(number).replace('0.','')\n        for digit in number_str:\n            filenames.append( \"units_%d\"%int(digit))\n            rval.append( units[int(digit)] )\n        return u' '.join(rval)\n\n    if isinstance(number,str) or isinstance(number,unicode):\n        result = u\"\"\n        number = number.strip()\n        assert(len(args) == 1)\n        assert(len(number) > 0)\n        is_negative = number[0] == \"-\"\n        if  is_negative:\n            number = number[1:]\n        frac_part = u\"\"\n        if number.find(\".\") >= 0:\n            rat_part,frac_part = number.split(\".\")\n            frac_part = num2tamilstr(u\"0.\"+frac_part)\n        else:\n            rat_part = number\n        if len(rat_part) > 0:\n            result = num2tamilstr(float(rat_part))\n        result = result +u\" \"+ frac_part\n        return is_negative and \"-\" + result.strip() or result.strip()\n\n    suffix_base = { n_crore: crore, n_lakh : lakh, n_thousand : thousands}\n    suffix_file_map = {n_crore: \"crore\", n_lakh : \"lakh\", n_thousand : \"thousands\"}\n\n    file_map = {n_crore :[\"one_prefix\",\"crore_0\"],\n                n_lakh : [\"one_prefix\",\"lakh_0\"],\n                n_thousand :  [\"one_thousand_prefix\", \"thousands_0\"],\n               n_hundred : [\"hundreds_0\"], #special\n               n_ten : [\"units_10\"],\n               n_one : [\"units_1\"]}\n\n    num_map = {n_crore : [one_prefix,crore[0]],\n               n_lakh  : [one_prefix,lakh[0]],\n               n_thousand : [one_thousand_prefix, thousands[0]],\n               n_hundred : [hundreds[0]], #special\n               n_ten : [units[10]],\n               n_one : [units[1]]}\n\n    all_bases = [n_crore, n_lakh, n_thousand, n_hundred, n_ten,n_one]\n    allowed_bases = list(filter( lambda base: number >= base, all_bases ))\n    if len(allowed_bases) >= 1:\n        n_base = allowed_bases[0]\n        if number == n_base:\n            if tensSpecial=='BASIC':\n                filenames.extend(file_map[n_base])\n                return u\" \".join(num_map[n_base])\n            elif tensSpecial=='NINES':\n                filenames.extend(file_map[n_base])\n                return units_suffix_nine[long(number%10)]\n            else:\n                filenames.extend(file_map[n_base])\n                return units_suffix[long(number%10)]\n        quotient_number = long( number/n_base )\n        residue_number = number - n_base*quotient_number\n        #print number, n_base, quotient_number, residue_number, tensSpecial\n        if n_base == n_one:\n            if isinstance(number,float):\n                int_part = long(number%10)\n                frac = number - float(int_part)\n                filenames.append(\"units_%d\"%int_part)\n                if abs(frac) > 1e-30:\n                    if tensSpecial=='BASIC':\n                        return units[int_part]+u' ' + num2tamilstr(frac,filenames)\n                    elif tensSpecial=='NINES':\n                        return units_suffix_nine[int_part]+u' ' + num2tamilstr(frac,filenames)\n                    else:\n                        return units_suffix[int_part]+u' ' + num2tamilstr(frac,filenames)\n\n                else:\n                    if tensSpecial=='BASIC':\n                        return units[int_part]\n                    elif tensSpecial=='NINES':\n                        return units_suffix_nine[int_part]\n                    else:\n                        return units_suffix[int_part]\n            else:\n                if tensSpecial=='BASIC':\n                    filenames.append(\"units_%d\"%number)\n                    return units[number]\n                elif tensSpecial=='NINES':\n                    filenames.append(\"units_%d\"%number)\n                    return units_suffix_nine[number]\n                else:\n                    filenames.append(\"units_%d\"%number)\n                    return units_suffix[number]\n\n        elif n_base == n_ten:\n            if residue_number < 1.0:\n                filenames.append(\"tens_%d\"%(quotient_number-1))\n                if residue_number == 0.0:\n                    return tens[quotient_number-1]\n                #else: //seems not reachable.\n                #    numeral = tens[quotient_number-1]\n            elif number < 20:\n                filenames.append(\"teens_%d\"%(number-10))\n                residue_number = math.fmod(number,1)\n                teen_number = int(math.floor(number - 10))\n                if residue_number > 1e-30:\n                    return teens[teen_number-1] +u' ' + num2tamilstr(residue_number,filenames)\n                else:\n                    return teens[teen_number-1]+u' '\n            if residue_number < 1.0:\n                filenames.append( \"tens_%d\"%(quotient_number-1) )\n                numeral = tens[quotient_number-1]+u' '\n            else:\n                if residue_number in tween:\n                    filenames.append( \"tens_prefix_%d\"%(quotient_number-2) )\n                    numeral = tens_prefix[quotient_number-2]\n                    tensSpecial='SPECIAL'\n                    if (quotient_number==9):\n                        tensSpecial = 'NINES'\n                else:\n                    filenames.append( \"tens_prefix_%d\"%(quotient_number-2) )\n                    numeral = tens_full_prefix[quotient_number-2]+u' '\n        elif n_base == n_hundred:\n            if residue_number == 0:\n                filenames.append(\"hundreds_%d\"%(quotient_number-1))\n                return hundreds[quotient_number-1]+u' '\n            if residue_number < 1.0:\n                filenames.append( \"hundreds_%d\"%(quotient_number-1) )\n                numeral = hundreds[quotient_number-1]+u' '\n            else:\n                filenames.append(\"hundreds_suffix_%d\"%(quotient_number-1))\n                numeral = hundreds_suffix[quotient_number-1]+u' '\n        else:\n            if ( quotient_number == 1 ):\n                if n_base == n_thousand:\n                    filenames.append(\"one_thousand_prefix\")\n                    numeral = one_thousand_prefix\n                else:\n                    filenames.append(\"one_prefix\")\n                    numeral = one_prefix\n            else:\n                numeral = num2tamilstr( quotient_number, filenames )\n        if n_base >= n_thousand:\n            suffix = suffix_base[n_base][long(residue_number >= 1)]\n            suffix_filename = \"%s_%d\"%(suffix_file_map[n_base],long(residue_number >= 1))\n            if residue_number == 0:\n                filenames.append(suffix_filename)\n                return numeral + u' ' + suffix+u' '\n            filenames.append(suffix_filename)\n            numeral = numeral + u' ' + suffix+u' '\n        residue_numeral = num2tamilstr( residue_number, filenames, tensSpecial)\n        #return numeral+u' '+residue_numeral\n        return numeral+residue_numeral\n    # number has to be zero\n    filenames.append(\"units_0\")\n    return units[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef num2tamilstr_american( *args ):\n    number = args[0]\n    \"\"\" work till 1000 trillion  - 1 - i.e  = 1e12*1e3 - 1.\n        turn number into a numeral, American style. Fractions upto 1e-30. \"\"\"\n\n    if not any( filter( lambda T: isinstance( number, T), [int, str, unicode, long, float]) ) or isinstance(number,complex):\n        raise Exception('num2tamilstr_american input has to be long or integer')\n    if float(number) >= long(1e15):\n        raise Exception('num2tamilstr input is too large')\n    if float(number) < 0:\n        return u\"- \"+num2tamilstr_american( -float(number) )\n\n    units = (u'\u0baa\u0bc2\u0b9c\u0bcd\u0b9c\u0bbf\u0baf\u0bae\u0bcd', u'\u0b92\u0ba9\u0bcd\u0bb1\u0bc1', u'\u0b87\u0bb0\u0ba3\u0bcd\u0b9f\u0bc1', u'\u0bae\u0bc2\u0ba9\u0bcd\u0bb1\u0bc1', u'\u0ba8\u0bbe\u0ba9\u0bcd\u0b95\u0bc1', u'\u0b90\u0ba8\u0bcd\u0ba4\u0bc1', u'\u0b86\u0bb1\u0bc1', u'\u0b8f\u0bb4\u0bc1', u'\u0b8e\u0b9f\u0bcd\u0b9f\u0bc1', u'\u0b92\u0ba9\u0bcd\u0baa\u0ba4\u0bc1', u'\u0baa\u0ba4\u0bcd\u0ba4\u0bc1') # 0-10\n    hundreds = ( u'\u0ba8\u0bc2\u0bb1\u0bc1', u'\u0b87\u0bb0\u0bc1\u0ba8\u0bc2\u0bb1\u0bc1', u'\u0bae\u0bc1\u0ba9\u0bcd\u0ba9\u0bc2\u0bb1\u0bc1', u'\u0ba8\u0bbe\u0ba8\u0bc2\u0bb1\u0bc1',u'\u0b90\u0ba8\u0bc2\u0bb1\u0bc1', u'\u0b85\u0bb1\u0bc1\u0ba8\u0bc2\u0bb1\u0bc1', u'\u0b8e\u0bb4\u0bc1\u0ba8\u0bc2\u0bb1\u0bc1', u'\u0b8e\u0ba3\u0bcd\u0ba3\u0bc2\u0bb1\u0bc1', u'\u0ba4\u0bca\u0bb3\u0bcd\u0bb3\u0bbe\u0baf\u0bbf\u0bb0\u0bae\u0bcd') #100 - 900\n\n    one_thousand_prefix = u'\u0b93\u0bb0\u0bcd'\n    thousands = (u'\u0b86\u0baf\u0bbf\u0bb0\u0bae\u0bcd',u'\u0b86\u0baf\u0bbf\u0bb0\u0ba4\u0bcd\u0ba4\u0bc1')\n\n    one_prefix = u'\u0b92\u0bb0\u0bc1'\n    mil = u'\u0bae\u0bbf\u0bb2\u0bcd\u0bb2\u0bbf\u0baf\u0ba9\u0bcd'\n    million = (mil,mil)\n\n    bil = u'\u0baa\u0bbf\u0bb2\u0bcd\u0bb2\u0bbf\u0baf\u0ba9\u0bcd'\n    billion = (bil,bil)\n\n    tril = u'\u0b9f\u0bbf\u0bb0\u0bbf\u0bb2\u0bcd\u0bb2\u0bbf\u0baf\u0ba9\u0bcd'\n    trillion = (tril,tril)\n\n    n_one = 1\n    n_ten = 10\n    n_hundred = 100\n    n_thousand = 1000\n    n_million = 1000*n_thousand\n    n_billion = long(1000*n_million)\n    n_trillion = long(1000*n_billion)\n\n    suffix_base = { n_trillion: trillion,\n                    n_billion : billion,\n                    n_million : million,\n                    n_thousand : thousands}\n\n    num_map = {n_trillion : [one_prefix,trillion[0]],\n               n_billion : [one_prefix,billion[0]],\n               n_million  : [one_prefix,million[0]],\n               n_thousand : [one_thousand_prefix, thousands[0]],\n               n_hundred : [hundreds[0]], #special\n               n_ten : [units[10]],\n               n_one : [units[1]]}\n\n    all_bases = [n_trillion,n_billion, n_million, n_thousand, n_hundred, n_ten,n_one]\n    allowed_bases = list(filter( lambda base: float(number) >= base, all_bases ))\n\n    # handle fractional parts\n    if float(number) > 0.0 and float(number) <= 1000.0:\n        return num2tamilstr(number)\n\n    if isinstance(number,str) or isinstance(number,unicode):\n        result = u\"\"\n        number = number.strip()\n        assert(len(args) == 1)\n        assert(len(number) > 0)\n        is_negative = number[0] == \"-\"\n        if  is_negative:\n            number = number[1:]\n        frac_part = u\"\"\n        if number.find(\".\") >= 0:\n            rat_part,frac_part = number.split(\".\")\n            frac_part = num2tamilstr_american(u\"0.\"+frac_part)\n        else:\n            rat_part = number\n        if len(rat_part) > 0:\n            result = num2tamilstr_american(float(rat_part))\n        result = result +u\" \"+ frac_part\n        return result.strip()\n\n    if len(allowed_bases) >= 1:\n        n_base = allowed_bases[0]\n        if number == n_base:\n            return u\" \".join(num_map[n_base])\n        quotient_number = long( number/n_base )\n        residue_number = number - n_base*quotient_number\n\n        if n_base < n_thousand:\n            raise Exception(\"This can never happen\")\n        else:\n            if ( quotient_number == 1 ):\n                if n_base == n_thousand:\n                    numeral = one_thousand_prefix+u' '\n                else:\n                    numeral = one_prefix+u' '\n            else:\n                numeral = num2tamilstr( quotient_number )\n        if n_base >= n_thousand:\n            suffix = suffix_base[n_base][long(residue_number >= 1)]\n            if residue_number == 0:\n                return numeral + u' ' + suffix\n            numeral = numeral + u' ' + suffix\n        residue_numeral = num2tamilstr_american( residue_number )\n        return numeral+u' '+residue_numeral\n\n    # number has to be zero\n    return units[0]", "response": "Convert a number into a numeral American style."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_tamil_words_iterable( letters ):\n        #punctuations = u'-,+,/,*,>,<,_,],[,{,},(,)'.split(',')+[',']\n        #isspace_or_tamil = lambda x:  not x in punctuations  and tamil.utf8.istamil(x)\n        \n        # correct algorithm for get-tamil-words\n        buf = []\n        for idx,let in enumerate(letters):\n            if tamil.utf8.istamil( let ):\n                buf.append( let )\n            else:\n                if len(buf) > 0:\n                    yield  u\"\".join( buf )\n                    buf = []\n        if len(buf) > 0:\n            yield u\"\".join(buf)", "response": "given a list of UTF - 8 letters section them into words grouping them at spaces"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if structure of file is as expected and return dictionary linking names to run_IDs.", "response": "def validate_split_runs_file(split_runs_file):\n    \"\"\"Check if structure of file is as expected and return dictionary linking names to run_IDs.\"\"\"\n    try:\n        content = [l.strip() for l in split_runs_file.readlines()]\n        if content[0].upper().split('\\t') == ['NAME', 'RUN_ID']:\n            return {c.split('\\t')[1]: c.split('\\t')[0] for c in content[1:] if c}\n        else:\n            sys.exit(\"ERROR: Mandatory header of --split_runs tsv file not found: 'NAME', 'RUN_ID'\")\n            logging.error(\"Mandatory header of --split_runs tsv file not found: 'NAME', 'RUN_ID'\")\n    except IndexError:\n        sys.exit(\"ERROR: Format of --split_runs tab separated file not as expected\")\n        logging.error(\"ERROR: Format of --split_runs tab separated file not as expected\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchanging the dataset identifiers based on the names in the dictionary.", "response": "def change_identifiers(datadf, split_dict):\n    \"\"\"Change the dataset identifiers based on the names in the dictionary.\"\"\"\n    for rid, name in split_dict.items():\n        datadf.loc[datadf[\"runIDs\"] == rid, \"dataset\"] = name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_report(plots, path):\n    '''\n    Creates a fat html report based on the previously created files\n    plots is a list of Plot objects defined by a path and title\n    statsfile is the file to which the stats have been saved,\n    which is parsed to a table (rather dodgy)\n    '''\n    logging.info(\"Writing html report.\")\n    html_head = \"\"\"<!DOCTYPE html>\n    <html>\n        <head>\n        <meta charset=\"UTF-8\">\n            <style>\n            table, th, td {\n                text-align: left;\n                padding: 2px;\n                /* border: 1px solid black;\n                border-collapse: collapse; */\n            }\n            h2 {\n                line-height: 0pt;\n            }\n            </style>\n            <title>NanoComp Report</title>\n        </head>\"\"\"\n    html_content = [\"\\n<body>\\n<h1>NanoComp report</h1>\"]\n    html_content.append(\"<h2>Summary statistics</h2>\")\n    html_content.append(utils.stats2html(path + \"NanoStats.txt\"))\n    html_content.append('\\n<br>\\n<br>\\n<br>\\n<br>')\n    html_content.append(\"<h2>Plots</h2>\")\n    for plot in plots:\n        html_content.append(\"\\n<h3>\" + plot.title + \"</h3>\\n\" + plot.encode())\n        html_content.append('\\n<br>\\n<br>\\n<br>\\n<br>')\n    html_body = '\\n'.join(html_content) + \"</body></html>\"\n    html_str = html_head + html_body\n    with open(path + \"NanoComp-report.html\", \"w\") as html_file:\n        html_file.write(html_str)\n    return path + \"NanoComp-report.html\"", "response": "Creates a fat html report based on the previously created files and plots."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an HTTP response object.", "response": "def _http_response(self, url, method, data=None, **kwargs):\n        \"\"\"url -> full target url\n           method -> method from requests\n           data -> request body\n           kwargs -> url formatting args\n        \"\"\"\n        header = {'content-type': 'application/json'}\n\n        if data:\n            data = json.dumps(data)\n        path = url.format(**kwargs)\n        logger.debug(\"%s %s\", method.__name__.upper(), path)\n        response = method(self.host + path,\n                          data=data, headers=header, **self.method_kwargs)\n        logger.debug(\"%s %s\", response.status_code, response.reason)\n        response.raise_for_status()\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef search(self, q=''):\n        if q:\n            q = '?q=' + q\n        return self._http_call('/v1/search' + q, get)", "response": "GET / v1 / search"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the image layer", "response": "def get_images_layer(self, image_id):\n        \"\"\"GET /v1/images/{image_id}/layer\"\"\"\n        return self._http_call(self.IMAGE_LAYER, get, image_id=image_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef put_images_layer(self, image_id, data):\n        return self._http_call(self.IMAGE_LAYER, put,\n                               image_id=image_id, data=data)", "response": "PUT the image layer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put_image_layer(self, image_id, data):\n        return self._http_call(self.IMAGE_JSON, put,\n                               data=data, image_id=image_id)", "response": "PUT an image layer"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the image layer for the given image_id.", "response": "def get_image_layer(self, image_id):\n        \"\"\"GET /v1/images/(image_id)/json\"\"\"\n        return self._http_call(self.IMAGE_JSON, get, image_id=image_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_image_ancestry(self, image_id):\n        return self._http_call(self.IMAGE_ANCESTRY, get, image_id=image_id)", "response": "Get ancestry for an image"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting tags for a repository.", "response": "def get_repository_tags(self, namespace, repository):\n        \"\"\"GET /v1/repositories/(namespace)/(repository)/tags\"\"\"\n        return self._http_call(self.TAGS, get,\n                               namespace=namespace, repository=repository)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the image id for a given tag", "response": "def get_image_id(self, namespace, respository, tag):\n        \"\"\"GET /v1/repositories/(namespace)/(repository)/tags/(tag*)\"\"\"\n        return self._http_call(self.TAGS + '/' + tag, get,\n                               namespace=namespace, repository=respository)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the JSON data for a given tag", "response": "def get_tag_json(self, namespace, repository, tag):\n        \"\"\"GET /v1/repositories(namespace)/(repository)tags(tag*)/json\"\"\"\n        return self._http_call(self.TAGS + '/' + tag + '/json', get,\n                               namespace=namespace, repository=repository)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_repository_tag(self, namespace, repository, tag):\n        return self._http_call(self.TAGS + '/' + tag, delete,\n                               namespace=namespace, repository=repository)", "response": "Delete a repository tag"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the tag for an image", "response": "def set_tag(self, namespace, repository, tag, image_id):\n        \"\"\"PUT /v1/repositories/(namespace)/(repository)/tags/(tag*)\"\"\"\n        return self._http_call(self.TAGS + '/' + tag, put, data=image_id,\n                               namespace=namespace, repository=repository)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _http_response(self, url, method, data=None, content_type=None,\n                       schema=None, **kwargs):\n        \"\"\"url -> full target url\n           method -> method from requests\n           data -> request body\n           kwargs -> url formatting args\n        \"\"\"\n\n        if schema is None:\n            schema = self.schema_2\n\n        header = {\n            'content-type': content_type or 'application/json',\n            'Accept': schema,\n        }\n\n        # Token specific part. We add the token in the header if necessary\n        auth = self.auth\n        token_required = auth.token_required\n        token = auth.token\n        desired_scope = auth.desired_scope\n        scope = auth.scope\n\n        if token_required:\n            if not token or desired_scope != scope:\n                logger.debug(\"Getting new token for scope: %s\", desired_scope)\n                auth.get_new_token()\n\n            header['Authorization'] = 'Bearer %s' % self.auth.token\n\n        if data and not content_type:\n            data = json.dumps(data)\n\n        path = url.format(**kwargs)\n        logger.debug(\"%s %s\", method.__name__.upper(), path)\n        response = method(self.host + path,\n                          data=data, headers=header, **self.method_kwargs)\n        logger.debug(\"%s %s\", response.status_code, response.reason)\n        response.raise_for_status()\n\n        return response", "response": "Returns an HTTP response object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef begin(self):\n\t\t# Check manufacturer and device ID match expected values.\n\t\tmid = self._device.readU16BE(MCP9808_REG_MANUF_ID)\n\t\tdid = self._device.readU16BE(MCP9808_REG_DEVICE_ID)\n\t\tself._logger.debug('Read manufacturer ID: {0:04X}'.format(mid))\n\t\tself._logger.debug('Read device ID: {0:04X}'.format(did))\n\t\treturn mid == 0x0054 and did == 0x0400", "response": "Start taking temperature measurements. Returns True if the device is \n\tintialized False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread sensor and return its value in degrees celsius.", "response": "def readTempC(self):\n\t\t\"\"\"Read sensor and return its value in degrees celsius.\"\"\"\n\t\t# Read temperature register value.\n\t\tt = self._device.readU16BE(MCP9808_REG_AMBIENT_TEMP)\n\t\tself._logger.debug('Raw ambient temp register value: 0x{0:04X}'.format(t & 0xFFFF))\n\t\t# Scale and convert to signed value.\n\t\ttemp = (t & 0x0FFF) / 16.0\n\t\tif t & 0x1000:\n\t\t\ttemp -= 256.0\n\t\treturn temp"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef crud_url_name(model, action, prefix=None):\n    if prefix is None:\n        prefix = \"\"\n    app_label = model._meta.app_label\n    model_lower = model.__name__.lower()\n    return '%s%s_%s_%s' % (prefix, app_label, model_lower, action)", "response": "Returns url name for given model and action."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_fields(model, include=None):\n    fields = OrderedDict()\n    info = model._meta\n    if include:\n        selected = [info.get_field(name) for name in include]\n    else:\n        selected = [field for field in info.fields if field.editable]\n    for field in selected:\n        fields[field.name] = field.verbose_name\n    return fields", "response": "Returns ordered dict in format field = verbose_name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef crud_url(instance_or_model, action, prefix=None, additional_kwargs=None):\n    if additional_kwargs is None:\n        additional_kwargs = {}\n    if isinstance(instance_or_model, Model):\n        additional_kwargs['pk'] = instance_or_model.pk\n        model_name = instance_or_model._meta.model\n    else:\n        model_name = instance_or_model\n    return reverse(\n        crud_url_name(model_name, action, prefix),\n        kwargs=additional_kwargs\n    )", "response": "Shortcut function returns URL for instance or model and action."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a permission name using Django naming convention.", "response": "def crud_permission_name(model, action, convert=True):\n    \"\"\"Returns permission name using Django naming convention: app_label.action_object.\n\n    If `convert` is True, `create` and `update` actions would be renamed\n    to `add` and `change`.\n    \"\"\"\n    app_label = model._meta.app_label\n    model_lower = model.__name__.lower()\n    if convert:\n        action = MAP_PERMISSION_ACTIONS.get(action, action)\n    return '%s.%s_%s' % (\n        app_label,\n        action,\n        model_lower\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format_value(obj, field_name):\n    display_func = getattr(obj, 'get_%s_display' % field_name, None)\n    if display_func:\n        return display_func()\n    value = getattr(obj, field_name)\n\n    if isinstance(value, models.fields.files.FieldFile):\n        if value:\n            return mark_safe('<a href=\"%s\">%s</a>' % (\n                value.url,\n                os.path.basename(value.name),\n            ))\n        else:\n            return ''\n\n    if isinstance(value, models.Model):\n        return format_value_instance(value)\n\n    if isinstance(value, models.Manager):\n        return mark_safe(', '.join(\n            [format_value_instance(instance) for instance in value.all()]\n        ))\n    if value is None:\n        value = \"\"\n    return value", "response": "Simple value formatting.\n\n    If value is model instance returns link to detail view if exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef crud_fields(obj, fields=None):\n    if fields is None:\n        fields = utils.get_fields(type(obj))\n    elif isinstance(fields, six.string_types):\n        field_names = [f.strip() for f in fields.split(',')]\n        fields = utils.get_fields(type(obj), include=field_names)\n    return {\n        'object': obj,\n        'fields': fields,\n    }", "response": "Display object fields in table rows::\n            object id fields to include"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of fields for a given model.", "response": "def get_fields(model, fields=None):\n    \"\"\"\n    Assigns fields for model.\n    \"\"\"\n    include = [f.strip() for f in fields.split(',')] if fields else None\n    return utils.get_fields(\n        model,\n        include\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of url patterns for a given model.", "response": "def crud_urls(model,\n              list_view=None,\n              create_view=None,\n              update_view=None,\n              detail_view=None,\n              delete_view=None,\n              url_prefix=None,\n              name_prefix=None,\n              list_views=None,\n              **kwargs):\n    \"\"\"Returns a list of url patterns for model.\n\n    :param list_view:\n    :param create_view:\n    :param update_view:\n    :param detail_view:\n    :param delete_view:\n    :param url_prefix: prefix to prepend, default is `'$'`\n    :param name_prefix: prefix to prepend to name, default is empty string\n    :param list_views(dict): additional list views\n    :param **kwargs: additional detail views\n    :returns: urls\n    \"\"\"\n    if url_prefix is None:\n        url_prefix = r'^'\n    urls = []\n    if list_view:\n        urls.append(url(\n            url_prefix + '$',\n            list_view,\n            name=utils.crud_url_name(model, utils.ACTION_LIST, name_prefix)\n        ))\n    if create_view:\n        urls.append(url(\n            url_prefix + r'new/$',\n            create_view,\n            name=utils.crud_url_name(model, utils.ACTION_CREATE, name_prefix)\n        ))\n    if detail_view:\n        urls.append(url(\n            url_prefix + r'(?P<pk>\\d+)/$',\n            detail_view,\n            name=utils.crud_url_name(model, utils.ACTION_DETAIL, name_prefix)\n        ))\n    if update_view:\n        urls.append(url(\n            url_prefix + r'(?P<pk>\\d+)/edit/$',\n            update_view,\n            name=utils.crud_url_name(model, utils.ACTION_UPDATE, name_prefix)\n        ))\n    if delete_view:\n        urls.append(url(\n            url_prefix + r'(?P<pk>\\d+)/remove/$',\n            delete_view,\n            name=utils.crud_url_name(model, utils.ACTION_DELETE, name_prefix)\n        ))\n\n    if list_views is not None:\n        for name, view in list_views.items():\n            urls.append(url(\n                url_prefix + r'%s/$' % name,\n                view,\n                name=utils.crud_url_name(model, name, name_prefix)\n            ))\n\n    for name, view in kwargs.items():\n        urls.append(url(\n            url_prefix + r'(?P<pk>\\d+)/%s/$' % name,\n            view,\n            name=utils.crud_url_name(model, name, name_prefix)\n        ))\n    return urls"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef crud_for_model(model, urlprefix=None):\n    model_lower = model.__name__.lower()\n\n    if urlprefix is None:\n        urlprefix = ''\n    urlprefix += model_lower + '/'\n\n    urls = crud_urls(\n        model,\n        list_view=CRUDListView.as_view(model=model),\n        create_view=CRUDCreateView.as_view(model=model),\n        detail_view=CRUDDetailView.as_view(model=model),\n        update_view=CRUDUpdateView.as_view(model=model),\n        delete_view=CRUDDeleteView.as_view(model=model),\n        url_prefix=urlprefix,\n    )\n    return urls", "response": "Returns list of url items to CRUD a model."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn list of url items to CRUD an app.", "response": "def crud_for_app(app_label, urlprefix=None):\n    \"\"\"\n    Returns list of ``url`` items to CRUD an app.\n    \"\"\"\n    if urlprefix is None:\n        urlprefix = app_label + '/'\n    app = apps.get_app_config(app_label)\n    urls = []\n    for model in app.get_models():\n        urls += crud_for_model(model, urlprefix)\n    return urls"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_context_data(self, **kwargs):\n        context = super(CRUDMixin, self).get_context_data(**kwargs)\n        context.update({\n            'model_verbose_name': self.model._meta.verbose_name,\n            'model_verbose_name_plural': self.model._meta.verbose_name_plural,\n        })\n\n        context['fields'] = utils.get_fields(self.model)\n\n        if hasattr(self, 'object') and self.object:\n            for action in utils.INSTANCE_ACTIONS:\n                try:\n                    url = reverse(\n                        utils.crud_url_name(self.model, action),\n                        kwargs={'pk': self.object.pk})\n                except NoReverseMatch:  # pragma: no cover\n                    url = None\n                context['url_%s' % action] = url\n\n        for action in utils.LIST_ACTIONS:\n            try:\n                url = reverse(utils.crud_url_name(self.model, action))\n            except NoReverseMatch:  # pragma: no cover\n                url = None\n            context['url_%s' % action] = url\n\n        return context", "response": "Adds available urls and names."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_template_names(self):\n        names = super(CRUDMixin, self).get_template_names()\n        if self.crud_template_name:\n            names.append(self.crud_template_name)\n        return names", "response": "Returns a list of all the template names that are available for this application."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef python_value(self, value):\n        value = super(JSONField, self).python_value(value)\n\n        if value is not None:\n            return flask.json.loads(value, **self._load_kwargs)", "response": "Return the JSON in the database as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstore the value in the database.", "response": "def db_value(self, value):\n        \"\"\"Store the value in the database.\n\n        If the value is a dict like object, it is converted to a string before\n        storing.\n        \"\"\"\n        # Everything is encoded being before being surfaced\n        value = flask.json.dumps(value)\n\n        return super(JSONField, self).db_value(value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the attribute to the field in question so this always gets deserialzed into the field name without _id.", "response": "def _add_to_schema(self, field_name, schema):\n        \"\"\"Set the ``attribute`` attr to the field in question so this always\n        gets deserialzed into the field name without ``_id``.\n\n        Args:\n            field_name (str): The name of the field (the attribute name being\n                set in the schema).\n            schema (marshmallow.Schema): The actual parent schema this field\n               belongs to.\n        \"\"\"\n        super(ForeignKeyField, self)._add_to_schema(field_name, schema)\n\n        if self.get_field_value('convert_fks', default=True):\n            self.attribute = field_name.replace('_id', '')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nserializes the ID value back to the Peewee model.", "response": "def _serialize(self, value, attr, obj):\n        \"\"\"Grab the ID value off the Peewee model so we serialize an ID back.\n        \"\"\"\n        # this might be an optional field\n        if value:\n            value = value.id\n\n        return super(ForeignKeyField, self)._serialize(value, attr, obj)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _discover_ideal_backend(orm_backend):\n    if orm_backend:\n        return orm_backend\n\n    if peewee is not MISSING and sqlalchemy is not MISSING:\n        raise RuntimeError('Both PeeWee and SQLAlchemy detected as installed, '\n                           'but no explicit backend provided! Please specify '\n                           'one!')\n    if peewee is not MISSING:\n        return _PEEWEE_BACKEND\n    elif sqlalchemy is not MISSING:\n        return _SQLALCHEMY_BACKEND\n    else:\n        return MISSING", "response": "Auto - discover the ideal backend based on what is installed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing the PeeWee extension with the application that was created.", "response": "def _init_peewee_ext(cls, app, dummy_configuration=None,\n                         dummy_configure_args=None):\n        \"\"\"Init the actual PeeWee extension with the app that was created.\n\n        Since PeeWee requires the ``DATABASE`` config parameter to be present\n        IMMEDIATELY upon initializing the application, we need to delay this\n        construction. This is because, in standard use, we will create the app\n        and attempt to init this extension BEFORE we configure the app, which\n        is totally fine. To fix this, we just need to set this up to try and\n        run after every call to configure. If there is not ``DATABASE`` config\n        parameter present when run, this method does nothing other than\n        reschedule itself to run in the future.\n\n        In all cases, this is a Post Configure Hook that should RUN ONCE!\n\n        Args:\n            app (flask.Flask): The application you want to init the PeeWee\n                Flask extension for. Hint: if you need to use this as\n                a callback, use a partial to provide this.\n            dummy_configuration (dict): The resulting application configuration\n                that the post_configure hook provides to all of it's callbacks.\n                We will NEVER use this, but since we utilize the post_configure\n                system to register this for complicated apps, we gotta accept\n                it.\n            dummy_configure_args (list[object]): The args passed to the\n                :meth:`configure` function that triggered this callback. Just\n                like the above arg, we'll never use it, but we must accept it.\n        \"\"\"\n        # the database still isn't present, go ahead and register the callback\n        # again, so we can try later.\n        if 'DATABASE' not in app.config:\n            app.add_post_configure_callback(partial(cls._init_peewee_ext, app),\n                                            run_once=True)\n            return\n\n        _PEEWEE_EXT.init_app(app)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconfigure the application through a varied number of sources of type dict - like or dict - like.", "response": "def configure(self, *args, **kwargs):\n        \"\"\"Configure the Application through a varied number of sources of\n        different types.\n\n        This function chains multiple possible configuration methods together\n        in order to just \"make it work\". You can pass multiple configuration\n        sources in to the method and each one will be tried in a sane fashion.\n        Later sources will override earlier sources if keys collide. For\n        example:\n\n        .. code:: python\n\n            from application import default_config\n            app.configure(default_config, os.environ, '.secrets')\n\n        In the above example, values stored in ``default_config`` will be\n        loaded first, then overwritten by those in ``os.environ``, and so on.\n\n        An endless number of configuration sources may be passed.\n\n        Configuration sources are type checked and processed according to the\n        following rules:\n\n        * ``string`` - if the source is a ``str``, we will assume it is a file\n          or module that should be loaded. If the file ends in ``.json``, then\n          :meth:`flask.Config.from_json` is used; if the file ends in ``.py``\n          or ``.cfg``, then :meth:`flask.Config.from_pyfile` is used; if the\n          module has any other extension we assume it is an import path, import\n          the module and pass that to :meth:`flask.Config.from_object`. See\n          below for a few more semantics on module loading.\n        * ``dict-like`` - if the source is ``dict-like``, then\n          :meth:`flask.Config.from_mapping` will be used. ``dict-like`` is\n          defined as anything implementing an ``items`` method that returns\n          a tuple of ``key``, ``val``.\n        * ``class`` or ``module`` - if the source is an uninstantiated\n          ``class`` or ``module``, then :meth:`flask.Config.from_object` will\n          be used.\n\n        Just like Flask's standard configuration, only uppercased keys will be\n        loaded into the config.\n\n        If the item we are passed is a ``string`` and it is determined to be\n        a possible Python module, then a leading ``.`` is relevant. If\n        a leading ``.`` is provided, we assume that the module to import is\n        located in the current package and operate as such; if it begins with\n        anything else we assume the import path provided is absolute. This\n        allows you to source configuration stored in a module in your package,\n        or in another package.\n\n        Args:\n            *args (object):\n                Any object you want us to try to configure from.\n\n        Keyword Args:\n            whitelist_keys_from_mappings (bool):\n                Should we whitelist the keys we pull from mappings? Very useful\n                if you're passing in an entire OS ``environ`` and you want to\n                omit things like ``LESSPIPE``. If no whitelist is provided, we\n                use the pre-existing config keys as a whitelist.\n            whitelist (list[str]):\n                An explicit list of keys that should be allowed. If provided\n                and ``whitelist_keys`` is ``True``, we will use that as our\n                whitelist instead of pre-existing app config keys.\n        \"\"\"\n        whitelist_keys_from_mappings = kwargs.get(\n            'whitelist_keys_from_mappings', False\n        )\n        whitelist = kwargs.get('whitelist')\n\n        for item in args:\n            if isinstance(item, string_types):\n                _, ext = splitext(item)\n\n                if ext == '.json':\n                    self._configure_from_json(item)\n                elif ext in ('.cfg', '.py'):\n                    self._configure_from_pyfile(item)\n                else:\n                    self._configure_from_module(item)\n\n            elif isinstance(item, (types.ModuleType, type)):\n                self._configure_from_object(item)\n\n            elif hasattr(item, 'items'):\n                # assume everything else is a mapping like object; ``.items()``\n                # is what Flask uses under the hood for this method\n                # @TODO: This doesn't handle the edge case of using a tuple of\n                # two element tuples to config; but Flask does that. IMO, if\n                # you do that, you're a monster.\n                self._configure_from_mapping(\n                    item,\n                    whitelist_keys=whitelist_keys_from_mappings,\n                    whitelist=whitelist\n                )\n\n            else:\n                raise TypeError(\"Could not determine a valid type for this\"\n                                \" configuration object: `{}`!\".format(item))\n\n        # we just finished here, run the post configure callbacks\n        self._run_post_configure_callbacks(args)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconfiguring from a module by import path.", "response": "def _configure_from_module(self, item):\n        \"\"\"Configure from a module by import path.\n\n        Effectively, you give this an absolute or relative import path, it will\n        import it, and then pass the resulting object to\n        ``_configure_from_object``.\n\n        Args:\n            item (str):\n                A string pointing to a valid import path.\n\n        Returns:\n            fleaker.App:\n                Returns itself.\n        \"\"\"\n        package = None\n        if item[0] == '.':\n            package = self.import_name\n\n        obj = importlib.import_module(item, package=package)\n\n        self.config.from_object(obj)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconfiguring from a mapping or dict like object.", "response": "def _configure_from_mapping(self, item, whitelist_keys=False,\n                                whitelist=None):\n        \"\"\"Configure from a mapping, or dict, like object.\n\n        Args:\n            item (dict):\n                A dict-like object that we can pluck values from.\n\n        Keyword Args:\n            whitelist_keys (bool):\n                Should we whitelist the keys before adding them to the\n                configuration? If no whitelist is provided, we use the\n                pre-existing config keys as a whitelist.\n            whitelist (list[str]):\n                An explicit list of keys that should be allowed. If provided\n                and ``whitelist_keys`` is true, we will use that as our\n                whitelist instead of pre-existing app config keys.\n\n        Returns:\n            fleaker.App:\n                Returns itself.\n        \"\"\"\n        if whitelist is None:\n            whitelist = self.config.keys()\n\n        if whitelist_keys:\n            item = {k: v for k, v in item.items() if k in whitelist}\n\n        self.config.from_mapping(item)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconfiguring from the entire set of available environment variables.", "response": "def configure_from_environment(self, whitelist_keys=False, whitelist=None):\n        \"\"\"Configure from the entire set of available environment variables.\n\n        This is really a shorthand for grabbing ``os.environ`` and passing to\n        :meth:`_configure_from_mapping`.\n\n        As always, only uppercase keys are loaded.\n\n        Keyword Args:\n            whitelist_keys (bool):\n                Should we whitelist the keys by only pulling those that are\n                already present in the config? Useful for avoiding adding\n                things like ``LESSPIPE`` to your app config. If no whitelist is\n                provided, we use the current config keys as our whitelist.\n            whitelist (list[str]):\n                An explicit list of keys that should be allowed. If provided\n                and ``whitelist_keys`` is true, we will use that as our\n                whitelist instead of pre-existing app config keys.\n\n        Returns:\n            fleaker.base.BaseApplication:\n                Returns itself.\n        \"\"\"\n        self._configure_from_mapping(os.environ, whitelist_keys=whitelist_keys,\n                                     whitelist=whitelist)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_post_configure_callback(self, callback, run_once=False):\n        if run_once:\n            self._post_configure_callbacks['single'].append(callback)\n        else:\n            self._post_configure_callbacks['multiple'].append(callback)\n\n        return self", "response": "Adds a callback to be run after every application s current configuration is set."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns all post configure callbacks that have been set for this entry point.", "response": "def _run_post_configure_callbacks(self, configure_args):\n        \"\"\"Run all post configure callbacks we have stored.\n\n        Functions are passed the configuration that resulted from the call to\n        :meth:`configure` as the first argument, in an immutable form; and are\n        given the arguments passed to :meth:`configure` for the second\n        argument.\n\n        Returns from callbacks are ignored in all fashion.\n\n        Args:\n            configure_args (list[object]):\n                The full list of arguments passed to :meth:`configure`.\n\n        Returns:\n            None:\n                Does not return anything.\n        \"\"\"\n        resulting_configuration = ImmutableDict(self.config)\n\n        # copy callbacks in case people edit them while running\n        multiple_callbacks = copy.copy(\n            self._post_configure_callbacks['multiple']\n        )\n        single_callbacks = copy.copy(self._post_configure_callbacks['single'])\n        # clear out the singles\n        self._post_configure_callbacks['single'] = []\n\n        for callback in multiple_callbacks:\n            callback(resulting_configuration, configure_args)\n\n        # now do the single run callbacks\n        for callback in single_callbacks:\n            callback(resulting_configuration, configure_args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate the data and create a model instance from it s data.", "response": "def make_instance(cls, data):\n        \"\"\"Validate the data and create a model instance from the data.\n\n        Args:\n            data (dict): The unserialized data to insert into the new model\n                instance through it's constructor.\n\n        Returns:\n            peewee.Model|sqlalchemy.Model: The model instance with it's data\n                inserted into it.\n\n        Raises:\n            AttributeError: This is raised if ``Meta.model`` isn't set on the\n                schema's definition.\n        \"\"\"\n        schema = cls()\n\n        if not hasattr(schema.Meta, 'model'):\n            raise AttributeError(\"In order to make an instance, a model for \"\n                                 \"the schema must be defined in the Meta \"\n                                 \"class.\")\n\n        serialized_data = schema.load(data).data\n\n        return cls.Meta.model(**serialized_data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef invalid_fields(self, data, original_data):\n        errors = []\n\n        for field in original_data:\n            # Skip nested fields because they will loop infinitely\n            if isinstance(field, (set, list, tuple, dict)):\n                continue\n\n            if field not in self.fields.keys():\n                errors.append(field)\n\n        if errors:\n            raise ValidationError(\"Invalid field\", field_names=errors)", "response": "Validator that checks if any keys provided aren t in the schema."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the value in the data base as an arrow object.", "response": "def python_value(self, value):\n        \"\"\"Return the value in the data base as an arrow object.\n\n        Returns:\n            arrow.Arrow: An instance of arrow with the field filled in.\n        \"\"\"\n        value = super(ArrowDateTimeField, self).python_value(value)\n\n        if (isinstance(value, (datetime.datetime, datetime.date,\n                               string_types))):\n            return arrow.get(value)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert the Arrow instance to a datetime for saving in the db.", "response": "def db_value(self, value):\n        \"\"\"Convert the Arrow instance to a datetime for saving in the db.\"\"\"\n        if isinstance(value, string_types):\n            value = arrow.get(value)\n\n        if isinstance(value, arrow.Arrow):\n            value = value.datetime\n\n        return super(ArrowDateTimeField, self).db_value(value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_app(self, app, context=DEFAULT_DICT):\n        if context is not _CONTEXT_MISSING:\n            self.update_context(context, app=app)\n\n        # do not readd callbacks if already present; and if there's no context\n        # present, there's no real need to add callbacks\n        if (app not in _CONTEXT_CALLBACK_MAP\n                and context is not _CONTEXT_MISSING):\n            key = self._get_context_name(app=app)\n            self._context_callbacks(app, key, original_context=context)", "response": "Lazy initialization of the Component class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _context_callbacks(app, key, original_context=_CONTEXT_MISSING):\n        def _get_context(dummy_app):\n            \"\"\"Set the context proxy so that it points to a specific context.\n            \"\"\"\n            _CONTEXT_LOCALS.context = _CONTEXT_LOCALS(key)  # pylint: disable=assigning-non-slot\n\n        def _clear_context(dummy_app):\n            \"\"\"Remove the context proxy that points to a specific context and\n            restore the original context, if there was one.\n            \"\"\"\n            try:\n                del _CONTEXT_LOCALS.context\n            except AttributeError:\n                pass\n\n            if original_context is not _CONTEXT_MISSING:\n                setattr(_CONTEXT_LOCALS, key, original_context)\n\n        # store for later so Blinker doesn't remove these listeners and so we\n        # don't add them twice\n        _CONTEXT_CALLBACK_MAP[app] = (_get_context, _clear_context)\n\n        # and listen for any app context changes\n        appcontext_pushed.connect(_get_context, app)\n        appcontext_popped.connect(_clear_context, app)\n\n        return (_get_context, _clear_context)", "response": "Register the callbacks we need to properly pop and push the app - local context for a component."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreplacing the component s context with a new one.", "response": "def update_context(self, context, app=None):\n        \"\"\"Replace the component's context with a new one.\n\n        Args:\n            context (dict): The new context to set this component's context to.\n\n        Keyword Args:\n            app (flask.Flask, optional): The app to update this context for. If\n                not provided, the result of ``Component.app`` will be used.\n        \"\"\"\n        if (app is None and self._context is _CONTEXT_MISSING\n                and not in_app_context()):\n            raise RuntimeError(\"Attempted to update component context without\"\n                               \" a bound app context or eager app set! Please\"\n                               \" pass the related app you want to update the\"\n                               \" context for!\")\n\n        if self._context is not _CONTEXT_MISSING:\n            self._context = ImmutableDict(context)\n        else:\n            key = self._get_context_name(app=app)\n            setattr(_CONTEXT_LOCALS, key, ImmutableDict(context))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclear the component s context.", "response": "def clear_context(self, app=None):\n        \"\"\"Clear the component's context.\n\n        Keyword Args:\n            app (flask.Flask, optional): The app to clear this component's\n                context for. If omitted, the value from ``Component.app`` is\n                used.\n        \"\"\"\n        if (app is None and self._context is _CONTEXT_MISSING\n                and not in_app_context()):\n            raise RuntimeError(\"Attempted to clear component context without\"\n                               \" a bound app context or eager app set! Please\"\n                               \" pass the related app you want to update the\"\n                               \" context for!\")\n\n        if self._context is not _CONTEXT_MISSING:\n            self._context = DEFAULT_DICT\n        else:\n            key = self._get_context_name(app=app)\n            setattr(_CONTEXT_LOCALS, key, DEFAULT_DICT)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_context_name(self, app=None):\n        elements = [\n            self.__class__.__name__,\n            'context',\n            text_type(id(self)),\n        ]\n\n        if app:\n            elements.append(text_type(id(app)))\n        else:\n            try:\n                elements.append(text_type(id(self.app)))\n            except RuntimeError:\n                pass\n\n        return '_'.join(elements)", "response": "Generate the name of the context variable for this component & app."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a standard Fleaker web application.", "response": "def create_app(cls, import_name, **settings):\n        \"\"\"Create a standard Fleaker web application.\n\n        This is the main entrypoint for creating your Fleaker application.\n        Instead of defining your own app factory function, it's preferred that\n        you use :meth:`create_app`, which is responsible for automatically\n        configuring extensions (such as your ORM), parsing setup code for\n        mixins, and calling relevant hooks (such as to setup logging).\n\n        Usage is easy:\n\n        .. code:: python\n\n            from fleaker import App\n\n            def my_create_app():\n                app = App.create_app(__name__)\n                return app\n\n        And the rest works like a normal Flask app with application factories\n        setup!\n\n        .. versionadded:: 0.1.0\n           This has always been the preferred way to create Fleaker\n           Applications.\n        \"\"\"\n        settings = cls.pre_create_app(**settings)\n\n        # now whitelist the settings\n        flask_kwargs = cls._whitelist_standard_flask_kwargs(settings)\n\n        app = cls(import_name, **flask_kwargs)\n        return cls.post_create_app(app, **settings)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat the log record.", "response": "def format(self, record):\n        \"\"\"Format the log record.\"\"\"\n        levelname = getattr(record, 'levelname', None)\n        record.levelcolor = ''\n        record.endlevelcolor = ''\n\n        if levelname:\n            level_color = getattr(self.TermColors, levelname, '')\n            record.levelcolor = level_color\n            record.endlevelcolor = self.TermColors.ENDC if level_color else ''\n\n        return super(FleakerLogFormatter, self).format(record)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nregister the errorhandler for the AppException to the passed in App.", "response": "def post_create_app(cls, app, **settings):\n        \"\"\"Register the errorhandler for the AppException to the passed in\n        App.\n\n        Args:\n            app (fleaker.base.BaseApplication): A Flask application that\n                extends the Fleaker Base Application, such that the hooks are\n                implemented.\n\n        Kwargs:\n            register_errorhandler (bool): A boolean indicating if we want to\n                automatically register an errorhandler for the\n                :class:`AppException` exception class after we create this App.\n                Pass ``False`` to prevent registration. Default is ``True``.\n\n\n        Returns:\n            fleaker.base.BaseApplication: Returns the app it was given.\n        \"\"\"\n        register_errorhandler = settings.pop('register_errorhandler', True)\n\n        if register_errorhandler:\n            AppException.register_errorhandler(app)\n\n        return app"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_app():\n    app = App.create_app(__name__)\n    app.configure('.configs.settings')\n\n    # yes, I should use blueprints; but I don't really care for such a small\n    # toy app\n    @app.route('/config')\n    def get_config():\n        \"\"\"Get the current configuration of the app.\"\"\"\n        return jsonify(app.config)\n\n    @app.route('/put_config', methods=['PUT'])\n    def put_config():\n        \"\"\"Add to the current configuration of the app.\n\n        Takes any JSON body and adds all keys to the configs with the provided\n        values.\n        \"\"\"\n        data = request.json()\n\n        for key, val in data.items():\n            app.config[key] = val\n\n        return jsonify({'message': 'Config updated!'})\n\n    return app", "response": "Create a new app for two\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_signature(self):\n        if not self._meta.signature_fields:\n            raise AttributeError(\n                \"No fields defined in {}.Meta.signature_fields. Please define \"\n                \"at least one.\".format(type(self).__name__)\n            )\n\n        # If the field is archived, unset the signature so records in the\n        # future can have this value.\n        if getattr(self, 'archived', False):\n            self.signature = None\n            return\n\n        # Otherwise, combine the values of the fields together and SHA1 them\n        computed = [getattr(self, value) or ' '\n                    for value in self._meta.signature_fields]\n        computed = ''.join([text_type(value) for value in computed])\n\n        # If computed is a falsey value, that means all the fields were\n        # None or blank and that will lead to some pain.\n        if computed:\n            self.signature = sha1(computed.encode('utf-8')).hexdigest()", "response": "Update the signature field of the current object based on the contents of the signature_fields attribute of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(service_account, credentials_file_path, api_version='v2'):\n\n    # Create an httplib2.Http object to handle our HTTP requests an\n    # authorize it with the Credentials. Note that the first parameter,\n    # service_account_name, is the Email address created for the Service\n    # account. It must be the email address associated with the key that\n    # was created.\n    scope = 'https://www.googleapis.com/auth/androidpublisher'\n    credentials = ServiceAccountCredentials.from_p12_keyfile(service_account, credentials_file_path, scopes=scope)\n    http = httplib2.Http()\n    http = credentials.authorize(http)\n\n    service = build('androidpublisher', api_version, http=http, cache_discovery=False)\n\n    return service", "response": "Connect to the Google Play interface"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats and validate a phone number.", "response": "def _format_phone_number(self, value, attr):\n        \"\"\"Format and validate a phone number.\"\"\"\n        strict_validation = self.get_field_value(\n            'strict_phone_validation',\n            default=False\n        )\n        strict_region = self.get_field_value(\n            'strict_phone_region',\n            default=strict_validation\n        )\n        region = self.get_field_value('region', 'US')\n        phone_number_format = self.get_field_value(\n            'phone_number_format',\n            default=phonenumbers.PhoneNumberFormat.INTERNATIONAL\n        )\n\n        # Remove excess special chars, except for the plus sign\n        stripped_value = re.sub(r'[^\\w+]', '', value)\n\n        try:\n            if not stripped_value.startswith('+') and not strict_region:\n                phone = phonenumbers.parse(stripped_value, region)\n            else:\n                phone = phonenumbers.parse(stripped_value)\n\n            if (not phonenumbers.is_possible_number(phone) or\n                    not phonenumbers.is_valid_number(phone) and\n                    strict_validation):\n                raise ValidationError(\n                    \"The value for {} ({}) is not a valid phone \"\n                    \"number.\".format(attr, value)\n                )\n\n            return phonenumbers.format_number(phone, phone_number_format)\n\n        except phonenumbers.phonenumberutil.NumberParseException as exc:\n            if strict_validation or strict_region:\n                raise ValidationError(exc)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting and validate the phone number using libphonenumber.", "response": "def _deserialize(self, value, attr, data):\n        \"\"\"Format and validate the phone number using libphonenumber.\"\"\"\n        if value:\n            value = self._format_phone_number(value, attr)\n\n        return super(PhoneNumberField, self)._deserialize(value, attr, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats and validate the phone number user libphonenumber.", "response": "def _serialize(self, value, attr, obj):\n        \"\"\"Format and validate the phone number user libphonenumber.\"\"\"\n        value = super(PhoneNumberField, self)._serialize(value, attr, obj)\n\n        if value:\n            value = self._format_phone_number(value, attr)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef default(self, obj):\n        if isinstance(obj, decimal.Decimal):\n            obj = format(obj, 'f')\n            str_digit = text_type(obj)\n\n            return (str_digit.rstrip('0').rstrip('.')\n                    if '.' in str_digit\n                    else str_digit)\n\n        elif isinstance(obj, phonenumbers.PhoneNumber):\n            return phonenumbers.format_number(\n                obj,\n                phonenumbers.PhoneNumberFormat.E164\n            )\n\n        elif isinstance(obj, pendulum.Pendulum):\n            return text_type(obj)\n\n        elif isinstance(obj, arrow.Arrow):\n            return text_type(obj)\n\n        elif isinstance(obj, (datetime.datetime, datetime.date)):\n            return obj.isoformat()\n\n        try:\n            return list(iter(obj))\n        except TypeError:\n            pass\n\n        return super(FleakerJSONEncoder, self).default(obj)", "response": "Encode individual objects into their JSON representation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _serialize(self, value, attr, obj):\n        if isinstance(value, arrow.arrow.Arrow):\n            value = value.datetime\n\n        return super(ArrowField, self)._serialize(value, attr, obj)", "response": "Convert the Arrow object into a string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the value in the database as an instance of Pendulum.", "response": "def python_value(self, value):\n        \"\"\"Return the value in the database as an Pendulum object.\n\n        Returns:\n            pendulum.Pendulum:\n                An instance of Pendulum with the field filled in.\n        \"\"\"\n        value = super(PendulumDateTimeField, self).python_value(value)\n\n        if isinstance(value, datetime.datetime):\n            value = pendulum.instance(value)\n        elif isinstance(value, datetime.date):\n            value = pendulum.instance(\n                datetime.datetime.combine(\n                    value, datetime.datetime.min.time()\n                )\n            )\n        elif isinstance(value, string_types):\n            value = pendulum.parse(value)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the Pendulum instance to a datetime for saving in the db.", "response": "def db_value(self, value):\n        \"\"\"Convert the Pendulum instance to a datetime for saving in the db.\"\"\"\n        if isinstance(value, pendulum.Pendulum):\n            value = datetime.datetime(\n                value.year, value.month, value.day, value.hour, value.minute,\n                value.second, value.microsecond, value.tzinfo\n            )\n\n        return super(PendulumDateTimeField, self).db_value(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if package_name has a release on staged rollout for too long", "response": "def check_rollout(edits_service, package_name, days):\n    \"\"\"Check if package_name has a release on staged rollout for too long\"\"\"\n    edit = edits_service.insert(body={}, packageName=package_name).execute()\n    response = edits_service.tracks().get(editId=edit['id'], track='production', packageName=package_name).execute()\n    releases = response['releases']\n    for release in releases:\n        if release['status'] == 'inProgress':\n            url = 'https://archive.mozilla.org/pub/mobile/releases/{}/SHA512SUMS'.format(release['name'])\n            resp = requests.head(url)\n            if resp.status_code != 200:\n                if resp.status_code != 404:  # 404 is expected for release candidates\n                    logger.warning(\"Could not check %s: %s\", url, resp.status_code)\n                continue\n            age = time.time() - calendar.timegm(eu.parsedate(resp.headers['Last-Modified']))\n            if age >= days * DAY:\n                yield release, age"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_json_schema(cls, schema, context=DEFAULT_DICT):\n        schema = cls._get_schema(schema)\n\n        # Generate the JSON Schema\n        return cls(context=context).dump(schema).data", "response": "Generate a JSON Schema from a Marshmallow schema."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_schema_to_file(cls, schema, file_pointer=stdout,\n                             folder=MISSING, context=DEFAULT_DICT):\n        \"\"\"Given a Marshmallow schema, create a JSON Schema for it.\n\n        Args:\n            schema (marshmallow.Schema|str): The Marshmallow schema, or the\n                Python path to one, to create the JSON schema for.\n\n        Keyword Args:\n            file_pointer (file, optional): The pointer to the file to write\n                this schema to. If not provided, the schema will be dumped to\n                ``sys.stdout``.\n            folder (str, optional): The folder in which to save the JSON\n                schema. The name of the schema file can be optionally\n                controlled my the schema's ``Meta.json_schema_filename``. If\n                that attribute is not set, the class's name will be used for\n                the filename. If writing the schema to a specific file is\n                desired, please pass in a ``file_pointer``.\n            context (dict, optional): The Marshmallow context to be pushed to\n                the schema generates the JSONSchema.\n\n        Returns:\n            dict: The JSON schema in dictionary form.\n        \"\"\"\n        schema = cls._get_schema(schema)\n        json_schema = cls.generate_json_schema(schema, context=context)\n\n        if folder:\n            schema_filename = getattr(\n                schema.Meta,\n                'json_schema_filename',\n                '.'.join([schema.__class__.__name__, 'json'])\n            )\n            json_path = os.path.join(folder, schema_filename)\n            file_pointer = open(json_path, 'w')\n\n        json.dump(json_schema, file_pointer, indent=2)\n\n        return json_schema", "response": "Given a Marshmallow schema and a file pointer write the JSON schema to that file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef post_save_event_listener(sender, instance, created):\n    if not instance._meta.event_ready:\n        return\n\n    if created:\n        instance.create_creation_event()\n    else:\n        instance.create_update_event()\n\n    # Reset the original key\n    instance._original = None", "response": "Event listener to create creation and update events."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nverify that the Event s code is a valid one.", "response": "def validate_event_type(sender, event, created):\n    \"\"\"Verify that the Event's code is a valid one.\"\"\"\n    if event.code not in sender.event_codes():\n        raise ValueError(\"The Event.code '{}' is not a valid Event \"\n                         \"code.\".format(event.code))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_original(self):\n        pk_value = self._get_pk_value()\n\n        if isinstance(pk_value, int) and not self._original:\n            self._original = (\n                self.select().where(self.__class__.id == pk_value).get()\n            )\n\n        return self._original", "response": "Get the original instance of this instance before it s updated."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_creation_event(self):\n        event = self.create_audit_event(code='AUDIT_CREATE')\n\n        if self._meta.create_message:\n            event.body = self._meta.create_message['message']\n            event.code = self._meta.create_message['code']\n            event.meta = self.parse_meta(self._meta.create_message['meta'])\n\n        self.create_event_callback(event)\n\n        event.save()\n\n        return event", "response": "Parse the create message DSL to insert the data into the Event."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the update messages DSL to insert the data into the Event.", "response": "def create_update_event(self):\n        \"\"\"Parse the update messages DSL to insert the data into the Event.\n\n        Returns:\n            list[fleaker.peewee.EventStorageMixin]:\n                All the events that were created for the update.\n        \"\"\"\n        events = []\n\n        for fields, rules in iteritems(self._meta.update_messages):\n            if not isinstance(fields, (list, tuple, set)):\n                fields = (fields,)\n\n            changed = any([\n                getattr(self, field) != getattr(self.get_original(), field)\n                for field in fields\n            ])\n\n            if changed:\n                event = self.create_audit_event(code=rules['code'])\n                event.body = rules['message']\n                event.meta = self.parse_meta(rules['meta'])\n                events.append(event)\n\n        self.update_event_callback(events)\n\n        with db.database.atomic():\n            for event in events:\n                event.save()\n\n        return events"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_deletion_event(self):\n        event = self.create_audit_event(code='AUDIT_DELETE')\n\n        if self._meta.delete_message:\n            event.code = self._meta.delete_message['code']\n            event.body = self._meta.delete_message['message']\n            event.meta = self.parse_meta(self._meta.delete_message['meta'])\n\n        self.delete_event_callback(event)\n\n        event.save()\n\n        return event", "response": "Parse the delete message DSL to insert data into the Event."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_meta(self, meta):\n        res = {}\n\n        for key, val in meta.items():\n            if not val:\n                continue\n            elif isinstance(val, dict):\n                res[key] = self.parse_meta(val)\n            elif val.startswith('current_user.'):\n                res[key] = self.get_path_attribute(current_user, val)\n            elif val.startswith('original.'):\n                res[key] = self.get_path_attribute(self.get_original(), val)\n            else:\n                res[key] = self.get_path_attribute(self, val)\n\n        return res", "response": "Parses the meta field in the message and returns a new dict with the keys and values which should be attribute paths relative to the current user and the current value at the end of that object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_path_attribute(obj, path):\n        # Strip out ignored keys passed in\n        path = path.replace('original.', '').replace('current_user.', '')\n\n        attr_parts = path.split('.')\n        res = obj\n\n        try:\n            for part in attr_parts:\n                try:\n                    res = getattr(res, part)\n                except AttributeError:\n                    res = getattr(res.get(), part)\n\n        except (peewee.DoesNotExist, AttributeError):\n            return None\n\n        return res", "response": "Given an object and a path return the value of the attribute that corresponds to that object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncopies the possible foreign key values from the object into the Event instance.", "response": "def copy_foreign_keys(self, event):\n        \"\"\"Copies possible foreign key values from the object into the Event,\n        skipping common keys like modified and created.\n\n        Args:\n            event (Event): The Event instance to copy the FKs into\n            obj (fleaker.db.Model): The object to pull the values from\n        \"\"\"\n        event_keys = set(event._meta.fields.keys())\n        obj_keys = self._meta.fields.keys()\n        matching_keys = event_keys.intersection(obj_keys)\n\n        for key in matching_keys:\n            # Skip created_by because that will always be the current_user\n            # for the Event.\n            if key == 'created_by':\n                continue\n\n            # Skip anything that isn't a FK\n            if not isinstance(self._meta.fields[key], peewee.ForeignKeyField):\n                continue\n\n            setattr(event, key, getattr(self, key))\n\n        # Attempt to set the obj's ID in the correct FK field on Event, if it\n        # exists. If this conflicts with desired behavior, handle this in the\n        # respective callback. This does rely on the FK matching the lower case\n        # version of the class name and that the event isn't trying to delete\n        # the current record, becuase that ends badly.\n        possible_key = self.__class__.__name__.lower()\n\n        if possible_key in event_keys and event.code != 'AUDIT_DELETE':\n            setattr(event, possible_key, self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_audit_event(self, code='AUDIT'):\n        event = self._meta.event_model(\n            code=code,\n            model=self.__class__.__name__,\n        )\n\n        # Use the logged in User, if possible\n        if current_user:\n            event.created_by = current_user.get_id()\n\n        self.copy_foreign_keys(event)\n        self.populate_audit_fields(event)\n\n        return event", "response": "Creates a generic auditing Event with relevant info inserted into it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npopulating the audit JSON fields with raw data from the model.", "response": "def populate_audit_fields(self, event):\n        \"\"\"Populates the the audit JSON fields with raw data from the model, so\n        all changes can be tracked and diffed.\n\n        Args:\n            event (Event): The Event instance to attach the data to\n            instance (fleaker.db.Model): The newly created/updated model\n        \"\"\"\n        event.updated = self._data\n        event.original = self.get_original()._data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef formatted_message(self):\n        return render_template_string(\n            self.body,\n            event=self,\n            meta=self.meta,\n            original=self.original,\n            updated=self.updated,\n            version=self.version,\n        )", "response": "Method that returns the formatted message for the event."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_cached_time(self):\n        if not self._cached_time:\n            self._cached_time = self._meta.datetime.utcnow()\n\n        return self._cached_time", "response": "Method that will allow for consistent modified and archived\n        timestamps."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting all the translated locales supported by Google play", "response": "def _get_list_of_completed_locales(product, channel):\n    \"\"\" Get all the translated locales supported by Google play\n    So, locale unsupported by Google play won't be downloaded\n    Idem for not translated locale\n    \"\"\"\n    return utils.load_json_url(_ALL_LOCALES_URL.format(product=product, channel=channel))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_field_value(self, key, default=MISSING):\n        meta_value = self.metadata.get(key)\n        context_value = self.context.get(key)\n\n        if context_value is not None:\n            return context_value\n        elif meta_value is not None:\n            return meta_value\n\n        return default", "response": "Method to fetch a value from either the fields metadata or the fields context."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a single instance of the model queried by ID.", "response": "def get_by_id(cls, record_id, execute=True):\n        \"\"\"Return a single instance of the model queried by ID.\n\n        Args:\n            record_id (int): Integer representation of the ID to query on.\n\n        Keyword Args:\n            execute (bool, optional):\n                Should this method execute the query or return a query object\n                for further manipulation?\n\n        Returns:\n            cls | :py:class:`peewee.SelectQuery`:\n                If ``execute`` is ``True``, the query is executed, otherwise\n                a query is returned.\n\n        Raises:\n            :py:class:`peewee.DoesNotExist`:\n                Raised if a record with that ID doesn't exist.\n        \"\"\"\n        query = cls.base_query().where(cls.id == record_id)\n\n        if execute:\n            return query.get()\n\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_instance(self, data):\n        for key, val in iteritems(data):\n            if not hasattr(self, key):\n                raise AttributeError(\n                    \"No field named {key} for model {model}\".format(\n                        key=key,\n                        model=self.__class__.__name__\n                    )\n                )\n\n            setattr(self, key, val)\n\n        self.save()\n\n        return self", "response": "Update a single record by id with the provided data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_code(self):\n        return \"\" if not self.is_enabled else (\"\"\"\n        <script src='//www.google.com/recaptcha/api.js'></script>\n        <div class=\"g-recaptcha\" data-sitekey=\"{SITE_KEY}\" data-theme=\"{THEME}\" data-type=\"{TYPE}\" data-size=\"{SIZE}\"\\\n         data-tabindex=\"{TABINDEX}\"></div>\n        \"\"\".format(SITE_KEY=self.site_key, THEME=self.theme, TYPE=self.type, SIZE=self.size, TABINDEX=self.tabindex))", "response": "Returns the new ReCaptcha code"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ensure(self, name, preparefunc, restart=False):\n        from subprocess import Popen, STDOUT\n        info = self.getinfo(name)\n        if not restart and not info.isrunning():\n            restart = True\n\n        if restart:\n            if info.pid is not None:\n                info.terminate()\n            controldir = info.controldir.ensure(dir=1)\n            #controldir.remove()\n            preparefunc = CompatStarter.wrap(preparefunc)\n            starter = preparefunc(controldir, self)\n            args = [str(x) for x in starter.args]\n            self.log.debug(\"%s$ %s\", controldir, \" \".join(args))\n            stdout = open(str(info.logpath), \"wb\", 0)\n            kwargs = {'env': starter.env}\n            if sys.platform == \"win32\":\n                kwargs[\"startupinfo\"] = sinfo = std.subprocess.STARTUPINFO()\n                if sys.version_info >= (2,7):\n                    sinfo.dwFlags |= std.subprocess.STARTF_USESHOWWINDOW\n                    sinfo.wShowWindow |= std.subprocess.SW_HIDE\n            else:\n                kwargs[\"close_fds\"] = True\n                kwargs[\"preexec_fn\"] = os.setpgrp  # no CONTROL-C\n            popen = Popen(args, cwd=str(controldir),\n                          stdout=stdout, stderr=STDOUT,\n                          **kwargs)\n            info.pid = pid = popen.pid\n            info.pidpath.write(str(pid))\n            self.log.debug(\"process %r started pid=%s\", name, pid)\n            stdout.close()\n        f = info.logpath.open()\n        if not restart:\n            f.seek(0, 2)\n        else:\n            if not starter.wait(f):\n                raise RuntimeError(\"Could not start process %s\" % name)\n            self.log.debug(\"%s process startup detected\", name)\n        logfiles = self.config.__dict__.setdefault(\"_extlogfiles\", {})\n        logfiles[name] = f\n        self.getinfo(name)\n        return info.pid, info.logpath", "response": "Creates a new process and returns the PID logfile if it is running."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wait(self, log_file):\n        \"Wait until the process is ready.\"\n        lines = map(self.log_line, self.filter_lines(self.get_lines(log_file)))\n        return any(\n            std.re.search(self.pattern, line)\n            for line in lines\n        )", "response": "Wait until the process is ready."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prep(self, wait, args, env=None):\n        self.pattern = wait\n        self.env = env\n        self.args = args\n\n        # wait is a function, supersedes the default behavior\n        if callable(wait):\n            self.wait = lambda lines: wait()", "response": "Given the return value of a preparefunc prepare this CompatStarter.\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wrap(self, starter_cls):\n        if isinstance(starter_cls, type) and issubclass(starter_cls, ProcessStarter):\n            return starter_cls\n        depr_msg = 'Pass a ProcessStarter for preparefunc'\n        warnings.warn(depr_msg, DeprecationWarning, stacklevel=3)\n        return functools.partial(CompatStarter, starter_cls)", "response": "Wrap a process_class in a CompatStarter."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_start_date(self, start_day: int, data_limit: str, month_threshold: int):\n        return self._connection.post('monitoring/start_date', OrderedDict((\n            ('StartDay', start_day),\n            ('DataLimit', data_limit),\n            ('MonthThreshold', month_threshold),\n            ('SetMonthData', 1)\n        )))", "response": "Sets the start date of the network usage alarm for LTE\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake a GET request.", "response": "def _get(self, *args, **kwargs):\n        \"\"\"\n        Make a GET request.\n        \"\"\"\n        return self._request(requests.get, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _post(self, *args, **kwargs):\n        data = self._default_data()\n        data.update(kwargs.get('data') or {})\n        kwargs['data'] = data\n        return self._request(requests.post, *args, **kwargs)", "response": "Make a POST request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconstructing the url to use for the orderbook.", "response": "def _construct_url(self, url, base, quote):\n        \"\"\"\n        Adds the orderbook to the url if base and quote are specified.\n        \"\"\"\n        if not base and not quote:\n            return url\n        else:\n            url = url + base.lower() + quote.lower() + \"/\"\n            return url"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake a generic request to the Bitstamp API.", "response": "def _request(self, func, url, version=1, *args, **kwargs):\n        \"\"\"\n        Make a generic request, adding in any proxy defined by the instance.\n\n        Raises a ``requests.HTTPError`` if the response status isn't 200, and\n        raises a :class:`BitstampError` if the response contains a json encoded\n        error message.\n        \"\"\"\n        return_json = kwargs.pop('return_json', False)\n        url = self.api_url[version] + url\n        response = func(url, *args, **kwargs)\n\n        if 'proxies' not in kwargs:\n            kwargs['proxies'] = self.proxydict\n\n        # Check for error, raising an exception if appropriate.\n        response.raise_for_status()\n\n        try:\n            json_response = response.json()\n        except ValueError:\n            json_response = None\n        if isinstance(json_response, dict):\n            error = json_response.get('error')\n            if error:\n                raise BitstampError(error)\n            elif json_response.get('status') == \"error\":\n                raise BitstampError(json_response.get('reason'))\n\n        if return_json:\n            if json_response is None:\n                raise BitstampError(\n                    \"Could not decode json for: \" + response.text)\n            return json_response\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dictionary of the available ticker items.", "response": "def ticker(self, base=\"btc\", quote=\"usd\"):\n        \"\"\"\n        Returns dictionary.\n        \"\"\"\n        url = self._construct_url(\"ticker/\", base, quote)\n        return self._get(url, return_json=True, version=2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef order_book(self, group=True, base=\"btc\", quote=\"usd\"):\n        params = {'group': group}\n        url = self._construct_url(\"order_book/\", base, quote)\n        return self._get(url, params=params, return_json=True, version=2)", "response": "Returns a dictionary with bids and asks."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the last timedelta seconds of the last transaction in the specified base and quote.", "response": "def transactions(self, time=TransRange.HOUR, base=\"btc\", quote=\"usd\"):\n        \"\"\"\n        Returns transactions for the last 'timedelta' seconds.\n        Parameter time is specified by one of two values of TransRange class.\n        \"\"\"\n        params = {'time': time}\n        url = self._construct_url(\"transactions/\", base, quote)\n        return self._get(url, params=params, return_json=True, version=2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a unique nonce for the bitstamp API.", "response": "def get_nonce(self):\n        \"\"\"\n        Get a unique nonce for the bitstamp API.\n\n        This integer must always be increasing, so use the current unix time.\n        Every time this variable is requested, it automatically increments to\n        allow for more than one API request per second.\n\n        This isn't a thread-safe function however, so you should only rely on a\n        single thread if you have a high level of concurrent API requests in\n        your application.\n        \"\"\"\n        nonce = getattr(self, '_nonce', 0)\n        if nonce:\n            nonce += 1\n        # If the unix time is greater though, use that instead (helps low\n        # concurrency multi-threaded apps always call with the largest nonce).\n        self._nonce = max(int(time.time()), nonce)\n        return self._nonce"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a one - time signature and other data required to send a secure POST request to Bitstamp API.", "response": "def _default_data(self, *args, **kwargs):\n        \"\"\"\n        Generate a one-time signature and other data required to send a secure\n        POST request to the Bitstamp API.\n        \"\"\"\n        data = super(Trading, self)._default_data(*args, **kwargs)\n        data['key'] = self.key\n        nonce = self.get_nonce()\n        msg = str(nonce) + self.username + self.key\n\n        signature = hmac.new(\n            self.secret.encode('utf-8'), msg=msg.encode('utf-8'),\n            digestmod=hashlib.sha256).hexdigest().upper()\n        data['signature'] = signature\n        data['nonce'] = nonce\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the balance of the current account.", "response": "def account_balance(self, base=\"btc\", quote=\"usd\"):\n        \"\"\"\n        Returns dictionary::\n\n            {u'btc_reserved': u'0',\n             u'fee': u'0.5000',\n             u'btc_available': u'2.30856098',\n             u'usd_reserved': u'0',\n             u'btc_balance': u'2.30856098',\n             u'usd_balance': u'114.64',\n             u'usd_available': u'114.64',\n             ---If base and quote were specified:\n             u'fee': u'',\n             ---If base and quote were not specified:\n             u'btcusd_fee': u'0.25',\n             u'btceur_fee': u'0.25',\n             u'eurusd_fee': u'0.20',\n             }\n            There could be reasons to set base and quote to None (or False),\n            because the result then will contain the fees for all currency pairs\n            For backwards compatibility this can not be the default however.\n        \"\"\"\n        url = self._construct_url(\"balance/\", base, quote)\n        return self._post(url, return_json=True, version=2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef user_transactions(self, offset=0, limit=100, descending=True,\n                          base=None, quote=None):\n        \"\"\"\n        Returns descending list of transactions. Every transaction (dictionary)\n        contains::\n\n            {u'usd': u'-39.25',\n             u'datetime': u'2013-03-26 18:49:13',\n             u'fee': u'0.20',\n             u'btc': u'0.50000000',\n             u'type': 2,\n             u'id': 213642}\n\n        Instead of the keys btc and usd, it can contain other currency codes\n        \"\"\"\n        data = {\n            'offset': offset,\n            'limit': limit,\n            'sort': 'desc' if descending else 'asc',\n        }\n        url = self._construct_url(\"user_transactions/\", base, quote)\n        return self._post(url, data=data, return_json=True, version=2)", "response": "Returns descending list of transactions. Every transaction contains a single entry for each user."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the status of the order with the given ID", "response": "def order_status(self, order_id):\n        \"\"\"\n        Returns dictionary.\n        - status: 'Finished'\n          or      'In Queue'\n          or      'Open'\n        - transactions: list of transactions\n          Each transaction is a dictionary with the following keys:\n              btc, usd, price, type, fee, datetime, tid\n          or  btc, eur, ....\n          or  eur, usd, ....\n        \"\"\"\n        data = {'id': order_id}\n        return self._post(\"order_status/\", data=data, return_json=True,\n                          version=1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cancel_order(self, order_id, version=1):\n        data = {'id': order_id}\n        return self._post(\"cancel_order/\", data=data, return_json=True,\n                          version=version)", "response": "Cancel the order specified by order_id.\n\n        Version 1 (default for backwards compatibility reasons):\n        Returns True if order was successfully canceled, otherwise\n        raise a BitstampError.\n\n        Version 2:\n        Returns dictionary of the canceled order, containing the keys:\n        id, type, price, amount"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef buy_limit_order(self, amount, price, base=\"btc\", quote=\"usd\", limit_price=None):\n        data = {'amount': amount, 'price': price}\n        if limit_price is not None:\n            data['limit_price'] = limit_price\n        url = self._construct_url(\"buy/\", base, quote)\n        return self._post(url, data=data, return_json=True, version=2)", "response": "Buy amount of bitcoins for specified price."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuying a market order.", "response": "def buy_market_order(self, amount, base=\"btc\", quote=\"usd\"):\n        \"\"\"\n        Order to buy amount of bitcoins for market price.\n        \"\"\"\n        data = {'amount': amount}\n        url = self._construct_url(\"buy/market/\", base, quote)\n        return self._post(url, data=data, return_json=True, version=2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks USD and BTC amount included in given bitstamp code. Returns JSON dictionary containing USD and BTC amount included in given bitstamp code.", "response": "def check_bitstamp_code(self, code):\n        \"\"\"\n        Returns JSON dictionary containing USD and BTC amount included in given\n        bitstamp code.\n        \"\"\"\n        data = {'code': code}\n        return self._post(\"check_code/\", data=data, return_json=True,\n                          version=1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef redeem_bitstamp_code(self, code):\n        data = {'code': code}\n        return self._post(\"redeem_code/\", data=data, return_json=True,\n                          version=1)", "response": "Redeem bitstamp code to user s user s set of bitstamps."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef withdrawal_requests(self, timedelta = 86400):\n        data = {'timedelta': timedelta}\n        return self._post(\"withdrawal_requests/\", return_json=True, version=1, data=data)", "response": "Returns a list of withdrawal requests."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef litecoin_withdrawal(self, amount, address):\n        data = {'amount': amount, 'address': address}\n        return self._post(\"ltc_withdrawal/\", data=data, return_json=True,\n                          version=2)", "response": "Send litecoins to another litecoin wallet specified by address."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ripple_withdrawal(self, amount, address, currency):\n        data = {'amount': amount, 'address': address, 'currency': currency}\n        response = self._post(\"ripple_withdrawal/\", data=data,\n                              return_json=True)\n        return self._expect_true(response)", "response": "Returns true if successful."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef xrp_withdrawal(self, amount, address, destination_tag=None):\n        data = {'amount': amount, 'address': address}\n        if destination_tag:\n            data['destination_tag'] = destination_tag\n\n        return self._post(\"xrp_withdrawal/\", data=data, return_json=True,\n                          version=2)[\"id\"]", "response": "Sends xrps to another xrp wallet specified by address. Returns withdrawal id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transfer_to_main(self, amount, currency, subaccount=None):\n        data = {'amount': amount,\n                'currency': currency,}\n        if subaccount is not None:\n            data['subAccount'] = subaccount\n        return self._post(\"transfer-to-main/\", data=data, return_json=True,\n                          version=2)", "response": "Transfer amount to main account"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resample(self, target_sr):\n        y_hat = librosa.core.resample(self.y, self.sr, target_sr)\n        return Sound(y_hat, target_sr)", "response": "Returns a new sound with a samplerate of target_sr."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprovide an IPythonwidgets player that can be used in a notebook.", "response": "def as_ipywidget(self):\n        \"\"\" Provides an IPywidgets player that can be used in a notebook. \"\"\"\n        from IPython.display import Audio\n\n        return Audio(data=self.y, rate=self.sr)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_file(cls, filename, sr=22050):\n        y, sr = librosa.load(filename, sr=sr)\n        return cls(y, sr)", "response": "Loads an audio file into a new object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef chunks(self):\n        if not hasattr(self, '_it'):\n            class ChunkIterator(object):\n                def __iter__(iter):\n                    return iter\n\n                def __next__(iter):\n                    try:\n                        chunk = self._next_chunk()\n                    except StopIteration:\n                        if self.loop:\n                            self._init_stretching()\n                            return iter.__next__()\n\n                        raise\n\n                    return chunk\n                next = __next__\n\n            self._it = ChunkIterator()\n\n        return self._it", "response": "Returns an iterator over the sound."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pitch_shifter(self, chunk, shift):\n        freq = numpy.fft.rfft(chunk)\n\n        N = len(freq)\n        shifted_freq = numpy.zeros(N, freq.dtype)\n\n        S = numpy.round(shift if shift > 0 else N + shift, 0)\n        s = N - S\n\n        shifted_freq[:S] = freq[s:]\n        shifted_freq[S:] = freq[:s]\n\n        shifted_chunk = numpy.fft.irfft(shifted_freq)\n\n        return shifted_chunk.astype(chunk.dtype)", "response": "Pitch - Shift the given chunk by shift semi - tones."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _time_stretcher(self, stretch_factor):\n        start = self._i2\n        end = min(self._i2 + self._N, len(self._sy) - (self._N + self._H))\n\n        if start >= end:\n            raise StopIteration\n\n        # The not so clean code below basically implements a phase vocoder\n        out = numpy.zeros(self._N, dtype=numpy.complex)\n\n        while self._i2 < end:\n            if self._i1 + self._N + self._H > len(self.y):\n                raise StopIteration\n\n            a, b = self._i1, self._i1 + self._N\n            S1 = numpy.fft.fft(self._win * self.y[a: b])\n            S2 = numpy.fft.fft(self._win * self.y[a + self._H: b + self._H])\n\n            self._phi += (numpy.angle(S2) - numpy.angle(S1))\n            self._phi = self._phi - 2.0 * numpy.pi * numpy.round(self._phi / (2.0 * numpy.pi))\n\n            out.real, out.imag = numpy.cos(self._phi), numpy.sin(self._phi)\n\n            self._sy[self._i2: self._i2 + self._N] += self._win * numpy.fft.ifft(numpy.abs(S2) * out).real\n\n            self._i1 += int(self._H * self.stretch_factor)\n            self._i2 += self._H\n\n        chunk = self._sy[start:end]\n\n        if stretch_factor == 1.0:\n            chunk = self.y[start:end]\n\n        return chunk", "response": "Real time - scale without pitch modification."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_tokenizer(specs):\n\n    def compile_spec(spec):\n        name, args = spec\n        return name, re.compile(*args)\n\n    compiled = [compile_spec(s) for s in specs]\n\n    def match_specs(specs, str, i, position):\n        line, pos = position\n        for type, regexp in specs:\n            m = regexp.match(str, i)\n            if m is not None:\n                value = m.group()\n                nls = value.count(u'\\n')\n                n_line = line + nls\n                if nls == 0:\n                    n_pos = pos + len(value)\n                else:\n                    n_pos = len(value) - value.rfind(u'\\n') - 1\n                return Token(type, value, (line, pos + 1), (n_line, n_pos))\n        else:\n            errline = str.splitlines()[line - 1]\n            raise LexerError((line, pos + 1), errline)\n\n    def f(str):\n        length = len(str)\n        line, pos = 1, 0\n        i = 0\n        while i < length:\n            t = match_specs(compiled, str, i, (line, pos))\n            yield t\n            line, pos = t.end\n            i += len(t.value)\n\n    return f", "response": "Returns a function that returns tokens for the given list of specs."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef finished(tokens, s):\n    if s.pos >= len(tokens):\n        return None, s\n    else:\n        raise NoParseError(u'should have reached <EOF>', s)", "response": "Parser returns None if no more tokens are left in the input unparsed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a parser that applies one or more times to a parser.", "response": "def oneplus(p):\n    \"\"\"Parser(a, b) -> Parser(a, [b])\n\n    Returns a parser that applies the parser p one or more times.\n    \"\"\"\n    @Parser\n    def _oneplus(tokens, s):\n        (v1, s2) = p.run(tokens, s)\n        (v2, s3) = many(p).run(tokens, s2)\n        return [v1] + v2, s3\n\n    _oneplus.name = u'(%s , { %s })' % (p.name, p.name)\n    return _oneplus"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef with_forward_decls(suspension):\n\n    @Parser\n    def f(tokens, s):\n        return suspension().run(tokens, s)\n\n    return f", "response": "Returns a parser that computes itself lazily as a result of the suspension\n   ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef define(self, p):\n        f = getattr(p, 'run', p)\n        if debug:\n            setattr(self, '_run', f)\n        else:\n            setattr(self, 'run', f)\n        self.named(getattr(p, 'name', p.__doc__))", "response": "Defines a parser wrapped into this object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning a parser wrapped into this object.", "response": "def run(self, tokens, s):\n        \"\"\"Sequence(a), State -> (b, State)\n\n        Runs a parser wrapped into this object.\n        \"\"\"\n        if debug:\n            log.debug(u'trying %s' % self.name)\n        return self._run(tokens, s)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse(self, tokens):\n        try:\n            (tree, _) = self.run(tokens, State())\n            return tree\n        except NoParseError, e:\n            max = e.state.max\n            if len(tokens) > max:\n                tok = tokens[max]\n            else:\n                tok = u'<EOF>'\n            raise NoParseError(u'%s: %s' % (e.msg, tok), e.state)", "response": "Applies the parser to a sequence of tokens producing a parsing result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a new sound to the Sampler.", "response": "def play(self, sound):\n        \"\"\" Adds and plays a new Sound to the Sampler.\n\n            :param sound: sound to play\n\n            .. note:: If the sound is already playing, it will restart from the beginning.\n\n        \"\"\"\n        self.is_done.clear()  # hold is_done until the sound is played\n        if self.sr != sound.sr:\n            raise ValueError('You can only play sound with a samplerate of {} (here {}). Use the Sound.resample method for instance.', self.sr, sound.sr)\n\n        if sound in self.sounds:\n            self.remove(sound)\n\n        with self.chunk_available:\n            self.sounds.append(sound)\n            sound.playing = True\n\n            self.chunk_available.notify()\n        self.is_done.wait()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove(self, sound):\n        with self.chunk_available:\n            sound.playing = False\n            self.sounds.remove(sound)", "response": "Remove a currently played sound."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef next_chunks(self):\n        with self.chunk_available:\n            while True:\n                playing_sounds = [s for s in self.sounds if s.playing]\n\n                chunks = []\n                for s in playing_sounds:\n                    try:\n                        chunks.append(next(s.chunks))\n                    except StopIteration:\n                        s.playing = False\n                        self.sounds.remove(s)\n                        self.is_done.set()  # sound was played, release is_done to end the wait in play\n\n                if chunks:\n                    break\n\n                self.chunk_available.wait()\n\n            return numpy.mean(chunks, axis=0)", "response": "Gets a new chunk from all played sound and mix them together."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self):\n        self.running = True\n\n        def chunks_producer():\n            while self.running:\n                self.chunks.put(self.next_chunks())\n\n        t = Thread(target=chunks_producer)\n        t.start()\n\n        with self.BackendStream(samplerate=self.sr, channels=1) as stream:\n            while self.running:\n                try:\n                    stream.write(self.chunks.get(timeout=self.timeout))  # timeout so stream.write() thread can exit\n                except Empty:\n                    self.running = False", "response": "Play loop i. e. send all sound chunks by chunk to the soundcard."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef xml(self):\n        root = Element('UsernameToken', ns=wssens)\n        u = Element('Username', ns=wssens)\n        u.setText(self.username)\n        root.append(u)\n        p = Element('Password', ns=wssens)\n        p.setText(self.password)\n        if self.password_digest:\n            p.set(\"Type\", wsdigest)\n            p.setText(self.password_digest)\n        root.append(p)\n        if self.nonce is not None:\n            n = Element('Nonce', ns=wssens)\n            if self.nonce_has_encoding:\n                n.set(\"EncodingType\", nonce_encoding_type)\n            n.setText(self.nonce)\n            root.append(n)\n        if self.created is not None:\n            n = Element('Created', ns=wsuns)\n            n.setText(str(DateTime(self.created)))\n            root.append(n)\n        return root", "response": "Get xml representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef skip(self, attr):\n        ns = attr.namespace()\n        skip = (\n            Namespace.xmlns[1],\n            'http://schemas.xmlsoap.org/soap/encoding/',\n            'http://schemas.xmlsoap.org/soap/envelope/',\n            'http://www.w3.org/2003/05/soap-envelope',\n        )\n        return ( Namespace.xs(ns) or ns[1] in skip )", "response": "Returns whether to skip the specified attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsorts items dependencies first in a given dependency tree.", "response": "def dependency_sort(dependency_tree):\n    \"\"\"\n    Sorts items 'dependencies first' in a given dependency tree.\n\n    A dependency tree is a dictionary mapping an object to a collection its\n    dependency objects.\n\n    Result is a properly sorted list of items, where each item is a 2-tuple\n    containing an object and its dependency list, as given in the input\n    dependency tree.\n\n    If B is directly or indirectly dependent on A and they are not both a part\n    of the same dependency cycle (i.e. then A is neither directly nor\n    indirectly dependent on B) then A needs to come before B.\n\n    If A and B are a part of the same dependency cycle, i.e. if they are both\n    directly or indirectly dependent on each other, then it does not matter\n    which comes first.\n\n    Any entries found listed as dependencies, but that do not have their own\n    dependencies listed as well, are logged & ignored.\n\n    @return: The sorted items.\n    @rtype: list\n\n    \"\"\"\n    sorted = []\n    processed = set()\n    for key, deps in dependency_tree.iteritems():\n        _sort_r(sorted, processed, key, deps, dependency_tree)\n    return sorted"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _sort_r(sorted, processed, key, deps, dependency_tree):\n    if key in processed:\n        return\n    processed.add(key)\n    for dep_key in deps:\n        dep_deps = dependency_tree.get(dep_key)\n        if dep_deps is None:\n            log.debug('\"%s\" not found, skipped', Repr(dep_key))\n            continue\n        _sort_r(sorted, processed, dep_key, dep_deps, dependency_tree)\n    sorted.append((key, deps))", "response": "Recursive topological sort implementation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresolving the node s type reference and returns the referenced external node.", "response": "def resolve(self, nobuiltin=False):\n        \"\"\"\n        Resolve the node's type reference and return the referenced type node.\n\n        Returns self if the type is defined locally, e.g. as a <complexType>\n        subnode. Otherwise returns the referenced external node.\n\n        @param nobuiltin: Flag indicating whether resolving to XSD built-in\n            types should not be allowed.\n        @return: The resolved (true) type.\n        @rtype: L{SchemaObject}\n\n        \"\"\"\n        cached = self.resolved_cache.get(nobuiltin)\n        if cached is not None:\n            return cached\n        resolved = self.__resolve_type(nobuiltin)\n        self.resolved_cache[nobuiltin] = resolved\n        return resolved"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the type to <xsd : any/> when implicit.", "response": "def implany(self):\n        \"\"\"\n        Set the type to <xsd:any/> when implicit.\n\n        An element has an implicit <xsd:any/> type when it has no body and no\n        explicitly defined type.\n\n        @return: self\n        @rtype: L{Element}\n\n        \"\"\"\n        if self.type is None and self.ref is None and self.root.isempty():\n            self.type = self.anytype()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting this schema element s target namespace.", "response": "def namespace(self, prefix=None):\n        \"\"\"\n        Get this schema element's target namespace.\n\n        In case of reference elements, the target namespace is defined by the\n        referenced and not the referencing element node.\n\n        @param prefix: The default prefix.\n        @type prefix: str\n        @return: The schema element's target namespace\n        @rtype: (I{prefix},I{URI})\n\n        \"\"\"\n        e = self.__deref()\n        if e is not None:\n            return e.namespace(prefix)\n        return super(Element, self).namespace()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef open(self, options, loaded_schemata):\n        if self.opened:\n            return\n        self.opened = True\n        log.debug(\"%s, importing ns='%s', location='%s'\", self.id, self.ns[1],\n            self.location)\n        result = self.__locate()\n        if result is None:\n            if self.location is None:\n                log.debug(\"imported schema (%s) not-found\", self.ns[1])\n            else:\n                url = self.location\n                if \"://\" not in url:\n                    url = urljoin(self.schema.baseurl, url)\n                result = (loaded_schemata.get(url) or\n                    self.__download(url, loaded_schemata, options))\n        log.debug(\"imported:\\n%s\", result)\n        return result", "response": "Open and import the referenced schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __locate(self):\n        if self.ns[1] != self.schema.tns[1]:\n            return self.schema.locate(self.ns)", "response": "Find the schema locally."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmake sure included schema has the same target namespace.", "response": "def __applytns(self, root):\n        \"\"\"Make sure included schema has the same target namespace.\"\"\"\n        TNS = \"targetNamespace\"\n        tns = root.get(TNS)\n        if tns is None:\n            tns = self.schema.tns[1]\n            root.set(TNS, tns)\n        else:\n            if self.schema.tns[1] != tns:\n                raise Exception, \"%s mismatch\" % TNS"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresolving named references to other WSDL objects.", "response": "def resolve(self, definitions):\n        \"\"\"\n        Resolve named references to other WSDL objects.\n\n        Can be safely called multiple times.\n\n        @param definitions: A definitions object.\n        @type definitions: L{Definitions}\n\n        \"\"\"\n        if not self.__resolved:\n            self.do_resolve(definitions)\n            self.__resolved = True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mktns(self, root):\n        tns = root.get(\"targetNamespace\")\n        prefix = root.findPrefix(tns)\n        if prefix is None:\n            log.debug(\"warning: tns (%s), not mapped to prefix\", tns)\n            prefix = \"tns\"\n        return (prefix, tns)", "response": "Get the target namespace."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nopen the imported WSDLs.", "response": "def open_imports(self, imported_definitions):\n        \"\"\"Import the I{imported} WSDLs.\"\"\"\n        for imp in self.imports:\n            imp.load(self, imported_definitions)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_methods(self, service):\n        bindings = {\n            \"document/literal\": Document(self),\n            \"rpc/literal\": RPC(self),\n            \"rpc/encoded\": Encoded(self)}\n        for p in service.ports:\n            binding = p.binding\n            ptype = p.binding.type\n            operations = p.binding.type.operations.values()\n            for name in (op.name for op in operations):\n                m = Facade(\"Method\")\n                m.name = name\n                m.location = p.location\n                m.binding = Facade(\"binding\")\n                op = binding.operation(name)\n                m.soap = op.soap\n                key = \"/\".join((op.soap.style, op.soap.input.body.use))\n                m.binding.input = bindings.get(key)\n                key = \"/\".join((op.soap.style, op.soap.output.body.use))\n                m.binding.output = bindings.get(key)\n                p.methods[name] = m", "response": "Build method view for service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef import_schema(self, definitions, d):\n        if not definitions.types:\n            root = Element(\"types\", ns=wsdlns)\n            definitions.root.insert(root)\n            types = Types(root, definitions)\n            definitions.types.append(types)\n        else:\n            types = definitions.types[-1]\n        types.root.append(d.root)\n        log.debug(\"imported (XSD):\\n%s\", d.root)", "response": "Import schema as <types/> content."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef soaproot(self):\n        for ns in (soapns, soap12ns):\n            sr = self.root.getChild(\"binding\", ns=ns)\n            if sr is not None:\n                return sr", "response": "Get the soap root element."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_resolve(self, definitions):\n        self.__resolveport(definitions)\n        for op in self.operations.values():\n            self.__resolvesoapbody(definitions, op)\n            self.__resolveheaders(definitions, op)\n            self.__resolvefaults(definitions, op)", "response": "Resolve named references to other WSDL objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nresolve a port type reference.", "response": "def __resolveport(self, definitions):\n        \"\"\"\n        Resolve port_type reference.\n\n        @param definitions: A definitions object.\n        @type definitions: L{Definitions}\n\n        \"\"\"\n        ref = qualify(self.type, self.root, definitions.tns)\n        port_type = definitions.port_types.get(ref)\n        if port_type is None:\n            raise Exception(\"portType '%s', not-found\" % (self.type,))\n        # Later on we will require access to the message data referenced by\n        # this port_type instance, and in order for those data references to be\n        # available, port_type first needs to dereference its message\n        # identification string. The only scenario where the port_type might\n        # possibly not have already resolved its references, and where this\n        # explicit resolve() call is required, is if we are dealing with a\n        # recursive WSDL import chain.\n        port_type.resolve(definitions)\n        self.type = port_type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef port(self, name):\n        for p in self.ports:\n            if p.name == name:\n                return p", "response": "Locate a port by name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_resolve(self, definitions):\n        filtered = []\n        for p in self.ports:\n            ref = qualify(p.binding, self.root, definitions.tns)\n            binding = definitions.bindings.get(ref)\n            if binding is None:\n                raise Exception(\"binding '%s', not-found\" % (p.binding,))\n            if binding.soap is None:\n                log.debug(\"binding '%s' - not a SOAP binding, discarded\",\n                    binding.name)\n                continue\n            # After we have been resolved, our caller will expect that the\n            # binding we are referencing has been fully constructed, i.e.\n            # resolved, as well. The only scenario where the operations binding\n            # might possibly not have already resolved its references, and\n            # where this explicit resolve() call is required, is if we are\n            # dealing with a recursive WSDL import chain.\n            binding.resolve(definitions)\n            p.binding = binding\n            filtered.append(p)\n        self.ports = filtered", "response": "Resolve named references to other WSDL objects. Ports without SOAP\n            bindings are discarded."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate an object based on the root tag name.", "response": "def create(cls, root, definitions):\n        \"\"\"\n        Create an object based on the root tag name.\n\n        @param root: An XML root element.\n        @type root: L{Element}\n        @param definitions: A definitions object.\n        @type definitions: L{Definitions}\n        @return: The created object.\n        @rtype: L{WObject}\n\n        \"\"\"\n        fn = cls.tags.get(root.name)\n        if fn is not None:\n            return fn(root, definitions)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing the I { reply } for the specified method and return the result.", "response": "def get_reply(self, method, replyroot):\n        \"\"\"\n        Process the I{reply} for the specified I{method} by unmarshalling it\n        into into Python object(s).\n\n        @param method: The name of the invoked method.\n        @type method: str\n        @param replyroot: The reply XML root node received after invoking the\n            specified method.\n        @type replyroot: L{Element}\n        @return: The unmarshalled reply. The returned value is an L{Object} or\n            a I{list} depending on whether the service returns a single object\n            or a collection.\n        @rtype: L{Object} or I{list}\n\n        \"\"\"\n        soapenv = replyroot.getChild(\"Envelope\", envns)\n        soapenv.promotePrefixes()\n        soapbody = soapenv.getChild(\"Body\", envns)\n        soapbody = self.multiref.process(soapbody)\n        nodes = self.replycontent(method, soapbody)\n        rtypes = self.returned_types(method)\n        if len(rtypes) > 1:\n            return self.replycomposite(rtypes, nodes)\n        if len(rtypes) == 0:\n            return\n        if rtypes[0].multi_occurrence():\n            return self.replylist(rtypes[0], nodes)\n        if len(nodes):\n            resolved = rtypes[0].resolve(nobuiltin=True)\n            return self.unmarshaller().process(nodes[0], resolved)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs a list of I{unmarshalled} objects.", "response": "def replylist(self, rt, nodes):\n        \"\"\"\n        Construct a I{list} reply.\n\n        Called for replies with possible multiple occurrences.\n\n        @param rt: The return I{type}.\n        @type rt: L{suds.xsd.sxbase.SchemaObject}\n        @param nodes: A collection of XML nodes.\n        @type nodes: [L{Element},...]\n        @return: A list of I{unmarshalled} objects.\n        @rtype: [L{Object},...]\n\n        \"\"\"\n        resolved = rt.resolve(nobuiltin=True)\n        unmarshaller = self.unmarshaller()\n        return [unmarshaller.process(node, resolved) for node in nodes]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mkheader(self, method, hdef, object):\n        marshaller = self.marshaller()\n        if isinstance(object, (list, tuple)):\n            return [self.mkheader(method, hdef, item) for item in object]\n        content = Content(tag=hdef[0], value=object, type=hdef[1])\n        return marshaller.process(content)", "response": "Builds a soapheader for the specified I { method } using the specified header definition and the specified value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef envelope(self, header, body):\n        env = Element(\"Envelope\", ns=envns)\n        env.addPrefix(Namespace.xsins[0], Namespace.xsins[1])\n        env.append(header)\n        env.append(body)\n        return env", "response": "Builds the SOAP envelope for a SOAP outbound message."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef header(self, content):\n        header = Element(\"Header\", ns=envns)\n        header.append(content)\n        return header", "response": "Builds the B{<Body/> element for a SOAP outbound message."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the XML content for the SOAP I{Header node.", "response": "def headercontent(self, method):\n        \"\"\"\n        Get the content for the SOAP I{Header} node.\n\n        @param method: A service method.\n        @type method: I{service.Method}\n        @return: The XML content for the <body/>.\n        @rtype: [L{Element},...]\n\n        \"\"\"\n        content = []\n        wsse = self.options().wsse\n        if wsse is not None:\n            content.append(wsse.xml())\n        headers = self.options().soapheaders\n        if not isinstance(headers, (tuple, list, dict)):\n            headers = (headers,)\n        elif not headers:\n            return content\n        pts = self.headpart_types(method)\n        if isinstance(headers, (tuple, list)):\n            n = 0\n            for header in headers:\n                if isinstance(header, Element):\n                    content.append(deepcopy(header))\n                    continue\n                if len(pts) == n:\n                    break\n                h = self.mkheader(method, pts[n], header)\n                ns = pts[n][1].namespace(\"ns0\")\n                h.setPrefix(ns[0], ns[1])\n                content.append(h)\n                n += 1\n        else:\n            for pt in pts:\n                header = headers.get(pt[0])\n                if header is None:\n                    continue\n                h = self.mkheader(method, pt, header)\n                ns = pt[1].namespace(\"ns0\")\n                h.setPrefix(ns[0], ns[1])\n                content.append(h)\n        return content"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of types defined for the specified method.", "response": "def bodypart_types(self, method, input=True):\n        \"\"\"\n        Get a list of I{parameter definitions} (pdefs) defined for the\n        specified method.\n\n        An input I{pdef} is a (I{name}, L{xsd.sxbase.SchemaObject}) tuple,\n        while an output I{pdef} is a L{xsd.sxbase.SchemaObject}.\n\n        @param method: A service method.\n        @type method: I{service.Method}\n        @param input: Defines input/output message.\n        @type input: boolean\n        @return:  A list of parameter definitions\n        @rtype: [I{pdef},...]\n\n        \"\"\"\n        if input:\n            parts = method.soap.input.body.parts\n        else:\n            parts = method.soap.output.body.parts\n        return [self.__part_type(p, input) for p in parts]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef headpart_types(self, method, input=True):\n        if input:\n            headers = method.soap.input.headers\n        else:\n            headers = method.soap.output.headers\n        return [self.__part_type(h.part, input) for h in headers]", "response": "Returns a list of header I { part } s defined for the\n            specified method."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __part_type(self, part, input):\n        if part.element is None:\n            query = TypeQuery(part.type)\n        else:\n            query = ElementQuery(part.element)\n        part_type = query.execute(self.schema())\n        if part_type is None:\n            raise TypeNotFound(query.ref)\n        if part.type is not None:\n            part_type = PartElement(part.name, part_type)\n        if not input:\n            return part_type\n        if part_type.name is None:\n            return part.name, part_type\n        return part_type.name, part_type", "response": "Returns a list of parameter definitions that are defined for a given body or header or message part."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the node s xsi : type attribute based on either I { value}'s or the node s text s class.", "response": "def auto(cls, node, value=None):\n        \"\"\"\n        Automatically set the node's xsi:type attribute based on either\n        I{value}'s or the node text's class. When I{value} is an unmapped\n        class, the default type (xs:any) is set.\n\n        @param node: XML node.\n        @type node: L{sax.element.Element}\n        @param value: Object that is or would be the node's text.\n        @type value: I{any}\n        @return: Specified node.\n        @rtype: L{sax.element.Element}\n\n        \"\"\"\n        if value is None:\n            value = node.getText()\n        if isinstance(value, Object):\n            known = cls.known(value)\n            if known.name is None:\n                return node\n            tm = known.name, known.namespace()\n        else:\n            tm = cls.types.get(value.__class__, cls.types.get(str))\n        cls.manual(node, *tm)\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef manual(cls, node, tval, ns=None):\n        xta = \":\".join((Namespace.xsins[0], \"type\"))\n        node.addPrefix(Namespace.xsins[0], Namespace.xsins[1])\n        if ns is None:\n            node.set(xta, tval)\n        else:\n            ns = cls.genprefix(node, ns)\n            qname = \":\".join((ns[0], tval))\n            node.set(xta, qname)\n            node.addPrefix(ns[0], ns[1])\n        return node", "response": "Set the node s xsi : type attribute based on either I { value}'s or the\n        node text s class. Then adds the referenced prefix to the node s xsi : type attribute mapping."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a prefix. @param node: XML node on which the prefix will be used. @type node: L{sax.element.Element} @param ns: Namespace needing a unique prefix. @type ns: (prefix, URI) @return: I{ns} with a new prefix. @rtype: (prefix, URI)", "response": "def genprefix(cls, node, ns):\n        \"\"\"\n        Generate a prefix.\n\n        @param node: XML node on which the prefix will be used.\n        @type node: L{sax.element.Element}\n        @param ns: Namespace needing a unique prefix.\n        @type ns: (prefix, URI)\n        @return: I{ns} with a new prefix.\n        @rtype: (prefix, URI)\n\n        \"\"\"\n        for i in range(1, 1024):\n            prefix = \"ns%d\" % (i,)\n            uri = node.resolvePrefix(prefix, default=None)\n            if uri in (None, ns[1]):\n                return prefix, ns[1]\n        raise Exception(\"auto prefix, exhausted\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _getf(self, id):\n        try:\n            filename = self.__filename(id)\n            self.__remove_if_expired(filename)\n            return self.__open(filename, \"rb\")\n        except Exception:\n            pass", "response": "Open a cached file with the given id for reading."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __filename(self, id):\n        suffix = self.fnsuffix()\n        filename = \"%s-%s.%s\" % (self.fnprefix, id, suffix)\n        return os.path.join(self.location, filename)", "response": "Return the cache file name for an entry with a given id."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the current process s default cache location folder.", "response": "def __get_default_location():\n        \"\"\"\n        Returns the current process's default cache location folder.\n\n        The folder is determined lazily on first call.\n\n        \"\"\"\n        if not FileCache.__default_location:\n            tmp = tempfile.mkdtemp(\"suds-default-cache\")\n            FileCache.__default_location = tmp\n            import atexit\n            atexit.register(FileCache.__remove_default_location)\n        return FileCache.__default_location"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the I { location folder if it does not already exist.", "response": "def __mktmp(self):\n        \"\"\"Create the I{location} folder if it does not already exist.\"\"\"\n        try:\n            if not os.path.isdir(self.location):\n                os.makedirs(self.location)\n        except Exception:\n            log.debug(self.location, exc_info=1)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __remove_if_expired(self, filename):\n        if not self.duration:\n            return\n        created = datetime.datetime.fromtimestamp(os.path.getctime(filename))\n        expired = created + self.duration\n        if expired < datetime.datetime.now():\n            os.remove(filename)\n            log.debug(\"%s expired, deleted\", filename)", "response": "Remove a cached file entry if it expired."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmatches by I { targetNamespace excluding those that are equal to the specified namespace.", "response": "def match(self, root, ns):\n        \"\"\"\n        Match by I{targetNamespace} excluding those that\n        are equal to the specified namespace to prevent\n        adding an import to itself.\n        @param root: A schema root.\n        @type root: L{Element}\n        \"\"\"\n        tns = root.get('targetNamespace')\n        if len(self.tns):\n            matched = ( tns in self.tns )\n        else:\n            matched = 1\n        itself = ( ns == tns )\n        return ( matched and not itself )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef u2opener(self):\n        if self.urlopener is None:\n            return urllib2.build_opener(*self.u2handlers())\n        return self.urlopener", "response": "Create a urllib opener."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef u2ver(self):\n        try:\n            part = urllib2.__version__.split('.', 1)\n            return float('.'.join(part))\n        except Exception, e:\n            log.exception(e)\n            return 0", "response": "Get the major or minor version of the urllib2 lib."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a local file path to a absolute path file protocol URL.", "response": "def path_to_URL(path, escape=True):\r\n    \"\"\"Convert a local file path to a absolute path file protocol URL.\"\"\"\r\n    # We do not use urllib's builtin pathname2url() function since:\r\n    #  - it has been commented with 'not recommended for general use'\r\n    #  - it does not seem to work the same on Windows and non-Windows platforms\r\n    #    (result starts with /// on Windows but does not on others)\r\n    #  - urllib implementation prior to Python 2.5 used to quote ':' characters\r\n    #    as '|' which would confuse pip on Windows.\r\n    url = os.path.abspath(path)\r\n    for sep in (os.sep, os.altsep):\r\n        if sep and sep != \"/\":\r\n            url = url.replace(sep, \"/\")\r\n    if escape:\r\n        # Must not escape ':' or '/' or Python will not recognize those URLs\r\n        # correctly. Detected on Windows 7 SP1 x64 with Python 3.4.0, but doing\r\n        # this always does not hurt since both are valid ASCII characters.\r\n        no_protocol_URL = url_quote(url, safe=\":/\")\r\n    else:\r\n        no_protocol_URL = url\r\n    return \"file:///%s\" % (no_protocol_URL,)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef requirement_spec(package_name, *args):\r\n    if not args or args == (None,):\r\n        return package_name\r\n    version_specs = []\r\n    for version_spec in args:\r\n        if isinstance(version_spec, (list, tuple)):\r\n            operator, version = version_spec\r\n        else:\r\n            assert isinstance(version_spec, str)\r\n            operator = \"==\"\r\n            version = version_spec\r\n        version_specs.append(\"%s%s\" % (operator, version))\r\n    return \"%s%s\" % (package_name, \",\".join(version_specs))", "response": "Identifier used when specifying a requirement to pip or setuptools."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef script_folder(script_path):\r\n    # There exist modules whose __file__ attribute does not correspond directly\r\n    # to a disk file, e.g. modules imported from inside zip archives.\r\n    if os.path.isfile(script_path):\r\n        return _rel_path(os.path.dirname(script_path)) or \".\"", "response": "Returns the folder where the given script is located."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef path_iter(path):\r\n    parts = []\r\n    while path:\r\n        path, item = os.path.split(path)\r\n        if item:\r\n            parts.append(item)\r\n    return reversed(parts)", "response": "Returns an iterator over all the file & folder names in a path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef document(self, wrapper):\n        tag = wrapper[1].name\n        ns = wrapper[1].namespace(\"ns0\")\n        return Element(tag, ns=ns)", "response": "Get the document root. For I { document / literal } this is the name of the the\n        wrapper element qualified by the schema s target namespace."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mkparam(self, method, pdef, object):\n        if isinstance(object, (list, tuple)):\n            return [self.mkparam(method, pdef, item) for item in object]\n        return super(Document, self).mkparam(method, pdef, object)", "response": "Expand list parameters into individual parameters each with the type\n        information."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef param_defs(self, method):\n        pts = self.bodypart_types(method)\n        if not method.soap.input.body.wrapped:\n            return pts\n        pt = pts[0][1].resolve()\n        return [(c.name, c, a) for c, a in pt if not c.isattr()]", "response": "Get parameter definitions for document literal."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a byte string version of s encoded as specified in encoding.", "response": "def byte_str(s=\"\", encoding=\"utf-8\", input_encoding=\"utf-8\", errors=\"strict\"):\n    \"\"\"\n    Returns a byte string version of 's', encoded as specified in 'encoding'.\n\n    Accepts str & unicode objects, interpreting non-unicode strings as byte\n    strings encoded using the given input encoding.\n\n    \"\"\"\n    assert isinstance(s, basestring)\n    if isinstance(s, unicode):\n        return s.encode(encoding, errors)\n    if s and encoding != input_encoding:\n        return s.decode(input_encoding, errors).encode(encoding, errors)\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _date_from_match(match_object):\n    year = int(match_object.group(\"year\"))\n    month = int(match_object.group(\"month\"))\n    day = int(match_object.group(\"day\"))\n    return datetime.date(year, month, day)", "response": "Create a date object from a regular expression match."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a time object from a regular expression match.", "response": "def _time_from_match(match_object):\n    \"\"\"\n    Create a time object from a regular expression match.\n\n    Returns the time object and information whether the resulting time should\n    be bumped up by one microsecond due to microsecond rounding.\n\n    Subsecond information is rounded to microseconds due to a restriction in\n    the python datetime.datetime/time implementation.\n\n    The regular expression match is expected to be from _RE_DATETIME or\n    _RE_TIME.\n\n    @param match_object: The regular expression match.\n    @type match_object: B{re}.I{MatchObject}\n    @return: Time object + rounding flag.\n    @rtype: tuple of B{datetime}.I{time} and bool\n\n    \"\"\"\n    hour = int(match_object.group('hour'))\n    minute = int(match_object.group('minute'))\n    second = int(match_object.group('second'))\n    subsecond = match_object.group('subsecond')\n\n    round_up = False\n    microsecond = 0\n    if subsecond:\n        round_up = len(subsecond) > 6 and int(subsecond[6]) >= 5\n        subsecond = subsecond[:6]\n        microsecond = int(subsecond + \"0\" * (6 - len(subsecond)))\n    return datetime.time(hour, minute, second, microsecond), round_up"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a timezone information object from a regular expression match.", "response": "def _tzinfo_from_match(match_object):\n    \"\"\"\n    Create a timezone information object from a regular expression match.\n\n    The regular expression match is expected to be from _RE_DATE, _RE_DATETIME\n    or _RE_TIME.\n\n    @param match_object: The regular expression match.\n    @type match_object: B{re}.I{MatchObject}\n    @return: A timezone information object.\n    @rtype: B{datetime}.I{tzinfo}\n\n    \"\"\"\n    tz_utc = match_object.group(\"tz_utc\")\n    if tz_utc:\n        return UtcTimezone()\n\n    tz_sign = match_object.group(\"tz_sign\")\n    if not tz_sign:\n        return\n\n    h = int(match_object.group(\"tz_hour\") or 0)\n    m = int(match_object.group(\"tz_minute\") or 0)\n    if h == 0 and m == 0:\n        return UtcTimezone()\n\n    # Python limitation - timezone offsets larger than one day (in absolute)\n    # will cause operations depending on tzinfo.utcoffset() to fail, e.g.\n    # comparing two timezone aware datetime.datetime/time objects.\n    if h >= 24:\n        raise ValueError(\"timezone indicator too large\")\n\n    tz_delta = datetime.timedelta(hours=h, minutes=m)\n    if tz_sign == \"-\":\n        tz_delta *= -1\n    return FixedOffsetTimezone(tz_delta)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the string date.", "response": "def __parse(value):\n        \"\"\"\n        Parse the string date.\n\n        Supports the subset of ISO8601 used by xsd:date, but is lenient with\n        what is accepted, handling most reasonable syntax.\n\n        Any timezone is parsed but ignored because a) it is meaningless without\n        a time and b) B{datetime}.I{date} does not support timezone\n        information.\n\n        @param value: A date string.\n        @type value: str\n        @return: A date object.\n        @rtype: B{datetime}.I{date}\n\n        \"\"\"\n        match_result = _RE_DATE.match(value)\n        if match_result is None:\n            raise ValueError(\"date data has invalid format '%s'\" % (value,))\n        return _date_from_match(match_result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the string datetime. and return a datetime object.", "response": "def __parse(value):\n        \"\"\"\n        Parse the string datetime.\n\n        Supports the subset of ISO8601 used by xsd:dateTime, but is lenient\n        with what is accepted, handling most reasonable syntax.\n\n        Subsecond information is rounded to microseconds due to a restriction\n        in the python datetime.datetime/time implementation.\n\n        @param value: A datetime string.\n        @type value: str\n        @return: A datetime object.\n        @rtype: B{datetime}.I{datetime}\n\n        \"\"\"\n        match_result = _RE_DATETIME.match(value)\n        if match_result is None:\n           raise ValueError(\"date data has invalid format '%s'\" % (value,))\n\n        date = _date_from_match(match_result)\n        time, round_up = _time_from_match(match_result)\n        tzinfo = _tzinfo_from_match(match_result)\n\n        value = datetime.datetime.combine(date, time)\n        value = value.replace(tzinfo=tzinfo)\n        if round_up:\n            value += datetime.timedelta(microseconds=1)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __parse(value):\n        match_result = _RE_TIME.match(value)\n        if match_result is None:\n           raise ValueError(\"date data has invalid format '%s'\" % (value,))\n\n        time, round_up = _time_from_match(match_result)\n        tzinfo = _tzinfo_from_match(match_result)\n        if round_up:\n            time = _bump_up_time_by_microsecond(time)\n        return time.replace(tzinfo=tzinfo)", "response": "Parse the string date."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the timezone name of the current instance.", "response": "def tzname(self, dt):\n        \"\"\"\n        http://docs.python.org/library/datetime.html#datetime.tzinfo.tzname\n\n        \"\"\"\n        # total_seconds was introduced in Python 2.7\n        if hasattr(self.__offset, \"total_seconds\"):\n            total_seconds = self.__offset.total_seconds()\n        else:\n            total_seconds = (self.__offset.days * 24 * 60 * 60) + \\\n                            (self.__offset.seconds)\n\n        hours = total_seconds // (60 * 60)\n        total_seconds -= hours * 60 * 60\n\n        minutes = total_seconds // 60\n        total_seconds -= minutes * 60\n\n        seconds = total_seconds // 1\n        total_seconds -= seconds\n\n        if seconds:\n            return \"%+03d:%02d:%02d\" % (hours, minutes, seconds)\n        return \"%+03d:%02d\" % (hours, minutes)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef postprocess(self, content):\n        node = content.node\n        if len(node.children) and node.hasText():\n            return node\n        attributes = AttrList(node.attributes)\n        if attributes.rlen() and \\\n            not len(node.children) and \\\n            node.hasText():\n                p = Factory.property(node.name, node.getText())\n                return merge(content.data, p)\n        if len(content.data):\n            return content.data\n        lang = attributes.lang()\n        if content.node.isnil():\n            return None\n        if not len(node.children) and content.text is None:\n            if self.nillable(content):\n                return None\n            else:\n                return Text('', lang=lang)\n        if isinstance(content.text, basestring):\n            return Text(content.text, lang=lang)\n        else:\n            return content.text", "response": "Perform final processing of the content."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef append_children(self, content):\n        for child in content.node:\n            cont = Content(child)\n            cval = self.append(cont)\n            key = reserved.get(child.name, child.name)\n            if key in content.data:\n                v = getattr(content.data, key)\n                if isinstance(v, list):\n                    v.append(cval)\n                else:\n                    setattr(content.data, key, [v, cval])\n                continue\n            if self.multi_occurrence(cont):\n                if cval is None:\n                    setattr(content.data, key, [])\n                else:\n                    setattr(content.data, key, [cval,])\n            else:\n                setattr(content.data, key, cval)", "response": "Append children into the content. data attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse(string):\n    if string:\n        return suds.sax.parser.Parser().parse(string=string)", "response": "Parses given XML document content."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, name):\n        timer = metrics.Timer()\n        timer.start()\n        type = self.resolver.find(name)\n        if type is None:\n            raise TypeNotFound(name)\n        if type.enum():\n            result = sudsobject.Factory.object(name)\n            for e, a in type.children():\n                setattr(result, e.name, e.name)\n        else:\n            try:\n                result = self.builder.build(type)\n            except Exception, e:\n                log.error(\"create '%s' failed\", name, exc_info=True)\n                raise BuildError(name, e)\n        timer.stop()\n        metrics.log.debug(\"%s created: %s\", name, timer)\n        return result", "response": "Create a WSDL type by name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __find(self, name):\n        service = None\n        if not self.__services:\n            raise Exception, \"No services defined\"\n        if isinstance(name, int):\n            try:\n                service = self.__services[name]\n                name = service.name\n            except IndexError:\n                raise ServiceNotFound, \"at [%d]\" % (name,)\n        else:\n            for s in self.__services:\n                if name == s.name:\n                    service = s\n                    break\n        if service is None:\n            raise ServiceNotFound, name\n        return PortSelector(self.__client, service.ports, name)", "response": "Find a service by name or index."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __ds(self):\n        ds = self.__client.options.service\n        if ds is not None:\n            return self.__find(ds)", "response": "Get the I { default } service if defined in the I { options.\n        } attribute."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef process_reply(self, reply, status=None, description=None):\n        return self.__process_reply(reply, status, description)", "response": "Process a SOAP reply and return the corresponding Python object representing the result."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send(self, soapenv):\n        location = self.__location()\n        log.debug(\"sending to (%s)\\nmessage:\\n%s\", location, soapenv)\n        plugins = PluginContainer(self.options.plugins)\n        plugins.message.marshalled(envelope=soapenv.root())\n        if self.options.prettyxml:\n            soapenv = soapenv.str()\n        else:\n            soapenv = soapenv.plain()\n        soapenv = soapenv.encode(\"utf-8\")\n        ctx = plugins.message.sending(envelope=soapenv)\n        soapenv = ctx.envelope\n        if self.options.nosend:\n            return RequestContext(self.process_reply, soapenv)\n        request = suds.transport.Request(location, soapenv)\n        request.headers = self.__headers()\n        try:\n            timer = metrics.Timer()\n            timer.start()\n            reply = self.options.transport.send(request)\n            timer.stop()\n            metrics.log.debug(\"waited %s on server reply\", timer)\n        except suds.transport.TransportError, e:\n            content = e.fp and e.fp.read() or \"\"\n            return self.process_reply(content, e.httpcode, tostr(e))\n        return self.process_reply(reply.message, None, None)", "response": "Send a SOAP message to the server."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess a SOAP reply and return the corresponding Python object representing the reply.", "response": "def process_reply(self, reply, status, description):\n        \"\"\"\n        Process a web service operation SOAP reply.\n\n        Depending on how the ``retxml`` option is set, may return the SOAP\n        reply XML or process it and return the Python object representing the\n        returned value.\n\n        @param reply: The SOAP reply envelope.\n        @type reply: I{bytes}\n        @param status: The HTTP status code (None indicates httplib.OK).\n        @type status: int|I{None}\n        @param description: Additional status description.\n        @type description: str\n        @return: The invoked web service operation return value.\n        @rtype: I{builtin}|I{subclass of} L{Object}|I{bytes}|I{None}\n\n        \"\"\"\n        if status is None:\n            status = httplib.OK\n        debug_message = \"Reply HTTP status - %d\" % (status,)\n        if status in (httplib.ACCEPTED, httplib.NO_CONTENT):\n            log.debug(debug_message)\n            return\n        #TODO: Consider whether and how to allow plugins to handle error,\n        # httplib.ACCEPTED & httplib.NO_CONTENT replies as well as successful\n        # ones.\n        if status == httplib.OK:\n            log.debug(\"%s\\n%s\", debug_message, reply)\n        else:\n            log.debug(\"%s - %s\\n%s\", debug_message, description, reply)\n\n        plugins = PluginContainer(self.options.plugins)\n        ctx = plugins.message.received(reply=reply)\n        reply = ctx.reply\n\n        # SOAP standard states that SOAP errors must be accompanied by HTTP\n        # status code 500 - internal server error:\n        #\n        # From SOAP 1.1 specification:\n        #   In case of a SOAP error while processing the request, the SOAP HTTP\n        # server MUST issue an HTTP 500 \"Internal Server Error\" response and\n        # include a SOAP message in the response containing a SOAP Fault\n        # element (see section 4.4) indicating the SOAP processing error.\n        #\n        # From WS-I Basic profile:\n        #   An INSTANCE MUST use a \"500 Internal Server Error\" HTTP status code\n        # if the response message is a SOAP Fault.\n        replyroot = None\n        if status in (httplib.OK, httplib.INTERNAL_SERVER_ERROR):\n            replyroot = _parse(reply)\n            plugins.message.parsed(reply=replyroot)\n            fault = self.__get_fault(replyroot)\n            if fault:\n                if status != httplib.INTERNAL_SERVER_ERROR:\n                    log.warn(\"Web service reported a SOAP processing fault \"\n                        \"using an unexpected HTTP status code %d. Reporting \"\n                        \"as an internal server error.\", status)\n                if self.options.faults:\n                    raise WebFault(fault, replyroot)\n                return httplib.INTERNAL_SERVER_ERROR, fault\n        if status != httplib.OK:\n            if self.options.faults:\n                #TODO: Use a more specific exception class here.\n                raise Exception((status, description))\n            return status, description\n\n        if self.options.retxml:\n            return reply\n\n        result = replyroot and self.method.binding.output.get_reply(\n            self.method, replyroot)\n        ctx = plugins.message.unmarshalled(reply=result)\n        result = ctx.reply\n        if self.options.faults:\n            return result\n        return httplib.OK, result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __get_fault(self, replyroot):\n        envns = suds.bindings.binding.envns\n        soapenv = replyroot and replyroot.getChild(\"Envelope\", envns)\n        soapbody = soapenv and soapenv.getChild(\"Body\", envns)\n        fault = soapbody and soapbody.getChild(\"Fault\", envns)\n        return fault is not None and UmxBasic().process(fault)", "response": "Extract fault information from a SOAP reply."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __headers(self):\n        action = self.method.soap.action\n        if isinstance(action, unicode):\n            action = action.encode(\"utf-8\")\n        result = {\n            \"Content-Type\": \"text/xml; charset=utf-8\",\n            \"SOAPAction\": action}\n        result.update(**self.options.headers)\n        log.debug(\"headers = %s\", result)\n        return result", "response": "Returns a dictionary of HTTP headers for a HTTP / HTTPS SOAP request."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef invoke(self, args, kwargs):\n        simulation = kwargs.pop(self.__injkey)\n        msg = simulation.get(\"msg\")\n        if msg is not None:\n            assert msg.__class__ is suds.byte_str_class\n            return self.send(_parse(msg))\n        msg = self.method.binding.input.get_message(self.method, args, kwargs)\n        log.debug(\"inject (simulated) send message:\\n%s\", msg)\n        reply = simulation.get(\"reply\")\n        if reply is not None:\n            assert reply.__class__ is suds.byte_str_class\n            status = simulation.get(\"status\")\n            description = simulation.get(\"description\")\n            if description is None:\n                description = \"injected reply\"\n            return self.process_reply(reply, status, description)\n        raise Exception(\"reply or msg injection parameter expected\")", "response": "Invoke a specified method."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the URL of the used object.", "response": "def __set_URL(self, url):\n        \"\"\"\n        URL is stored as a str internally and must not contain ASCII chars.\n\n        Raised exception in case of detected non-ASCII URL characters may be\n        either UnicodeEncodeError or UnicodeDecodeError, depending on the used\n        Python version's str type and the exact value passed as URL input data.\n\n        \"\"\"\n        if isinstance(url, str):\n            url.encode(\"ascii\")  # Check for non-ASCII characters.\n            self.url = url\n        elif sys.version_info < (3, 0):\n            self.url = url.encode(\"ascii\")\n        else:\n            self.url = url.decode(\"ascii\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nappends the content to the parent node.", "response": "def append(self, parent, content):\n        \"\"\"\n        Select an appender and append the content to parent.\n        @param parent: A parent node.\n        @type parent: L{Element}\n        @param content: The content to append.\n        @type content: L{Content}\n        \"\"\"\n        appender = self.default\n        for matcher, candidate_appender in self.appenders:\n            if matcher == content.value:\n                appender = candidate_appender\n                break\n        appender.append(parent, content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef root(self, parts):\n        result = None\n        name = parts[0]\n        log.debug('searching schema for (%s)', name)\n        qref = self.qualify(parts[0])\n        query = BlindQuery(qref)\n        result = query.execute(self.schema)\n        if result is None:\n            log.error('(%s) not-found', name)\n            raise PathResolver.BadPath(name)\n        log.debug('found (%s) as (%s)', name, Repr(result))\n        return result", "response": "Find the path root."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef branch(self, root, parts):\n        result = root\n        for part in parts[1:-1]:\n            name = splitPrefix(part)[1]\n            log.debug('searching parent (%s) for (%s)', Repr(result), name)\n            result, ancestry = result.get_child(name)\n            if result is None:\n                log.error('(%s) not-found', name)\n                raise PathResolver.BadPath(name)\n            result = result.resolve(nobuiltin=True)\n            log.debug('found (%s) as (%s)', name, Repr(result))\n        return result", "response": "Traverse the path until a leaf is reached."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a child by name.", "response": "def getchild(self, name, parent):\n        \"\"\"Get a child by name.\"\"\"\n        log.debug('searching parent (%s) for (%s)', Repr(parent), name)\n        if name.startswith('@'):\n            return parent.get_attribute(name[1:])\n        return parent.get_child(name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __path_prefix(self, folder):\r\n        path_parts = path_iter(folder)\r\n        _skip_expected(path_parts, self.__base_folder_parts)\r\n        result = \"/\".join(path_parts)\r\n        if result:\r\n            result += \"/\"\r\n        return result", "response": "Returns the path prefix to be used when archiving any items from the given folder."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a decimal. Decimal value to its XSD decimal type value.", "response": "def _decimal_to_xsd_format(value):\n        \"\"\"\n        Converts a decimal.Decimal value to its XSD decimal type value.\n\n        Result is a string containing the XSD decimal type's lexical value\n        representation. The conversion is done without any precision loss.\n\n        Note that Python's native decimal.Decimal string representation will\n        not do here as the lexical representation desired here does not allow\n        representing decimal values using float-like `<mantissa>E<exponent>'\n        format, e.g. 12E+30 or 0.10006E-12.\n\n        \"\"\"\n        value = XDecimal._decimal_canonical(value)\n        negative, digits, exponent = value.as_tuple()\n\n        # The following implementation assumes the following tuple decimal\n        # encoding (part of the canonical decimal value encoding):\n        #  - digits must contain at least one element\n        #  - no leading integral 0 digits except a single one in 0 (if a non-0\n        #    decimal value has leading integral 0 digits they must be encoded\n        #    in its 'exponent' value and not included explicitly in its\n        #    'digits' tuple)\n        assert digits\n        assert digits[0] != 0 or len(digits) == 1\n\n        result = []\n        if negative:\n            result.append(\"-\")\n\n        # No fractional digits.\n        if exponent >= 0:\n            result.extend(str(x) for x in digits)\n            result.extend(\"0\" * exponent)\n            return \"\".join(result)\n\n        digit_count = len(digits)\n\n        # Decimal point offset from the given digit start.\n        point_offset = digit_count + exponent\n\n        # Trim trailing fractional 0 digits.\n        fractional_digit_count = min(digit_count, -exponent)\n        while fractional_digit_count and digits[digit_count - 1] == 0:\n            digit_count -= 1\n            fractional_digit_count -= 1\n\n        # No trailing fractional 0 digits and a decimal point coming not after\n        # the given digits, meaning there is no need to add additional trailing\n        # integral 0 digits.\n        if point_offset <= 0:\n            # No integral digits.\n            result.append(\"0\")\n            if digit_count > 0:\n                result.append(\".\")\n                result.append(\"0\" * -point_offset)\n                result.extend(str(x) for x in digits[:digit_count])\n        else:\n            # Have integral and possibly some fractional digits.\n            result.extend(str(x) for x in digits[:point_offset])\n            if point_offset < digit_count:\n                result.append(\".\")\n                result.extend(str(x) for x in digits[point_offset:digit_count])\n        return \"\".join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(cls, schema, name):\n        fn = cls.tags.get(name, XBuiltin)\n        return fn(schema, name)", "response": "Create an object based on the root tag name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _avoid_setuptools_zipped_egg_upgrade_issue(env, ez_setup):\r\n    if env.sys_version_info[:2] != (2, 5):\r\n        return  # only Python 2.5.x affected by this\r\n    if not env.setuptools_zipped_egg:\r\n        return  # setuptools not pre-installed as a zipped egg\r\n    pv_new = parse_version(ez_setup.setuptools_version())\r\n    if pv_new != parse_version(env.setuptools_version):\r\n        return  # issue avoided since zipped egg archive names will not match\r\n    fixed_version = utility.lowest_version_string_with_prefix(\"3.5.2\")\r\n    if pv_new >= parse_version(fixed_version):\r\n        return  # issue fixed in setuptools\r\n    # We could check for pip and use it for a cleaner setuptools uninstall if\r\n    # available, but YAGNI since only Python 2.5.x environments are affected by\r\n    # the zipped egg upgrade issue.\r\n    os.remove(env.setuptools_zipped_egg)", "response": "Avoid setuptools self - upgrade issues."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns whether a pre - installed setuptools distribution should be reused.", "response": "def _reuse_pre_installed_setuptools(env, installer):\r\n    \"\"\"\r\n    Return whether a pre-installed setuptools distribution should be reused.\r\n\r\n    \"\"\"\r\n    if not env.setuptools_version:\r\n        return  # no prior setuptools ==> no reuse\r\n    reuse_old = config.reuse_old_setuptools\r\n    reuse_best = config.reuse_best_setuptools\r\n    reuse_future = config.reuse_future_setuptools\r\n    reuse_comment = None\r\n    if reuse_old or reuse_best or reuse_future:\r\n        pv_old = parse_version(env.setuptools_version)\r\n        pv_new = parse_version(installer.setuptools_version())\r\n        if pv_old < pv_new:\r\n            if reuse_old:\r\n                reuse_comment = \"%s+ recommended\" % (\r\n                    installer.setuptools_version(),)\r\n        elif pv_old > pv_new:\r\n            if reuse_future:\r\n                reuse_comment = \"%s+ required\" % (\r\n                    installer.setuptools_version(),)\r\n        elif reuse_best:\r\n            reuse_comment = \"\"\r\n    if reuse_comment is None:\r\n        return  # reuse not allowed by configuration\r\n    if reuse_comment:\r\n        reuse_comment = \" (%s)\" % (reuse_comment,)\r\n    print(\"Reusing pre-installed setuptools %s distribution%s.\" % (\r\n        env.setuptools_version, reuse_comment))\r\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download_pip(env, requirements):\r\n    if config.installation_cache_folder() is None:\r\n        raise EnvironmentSetupError(\"Local installation cache folder not \"\r\n            \"defined but required for downloading a pip installation.\")\r\n    # Installation cache folder needs to be explicitly created for setuptools\r\n    # to be able to copy its downloaded installation files into it. Seen using\r\n    # Python 2.4.4 & setuptools 1.4.\r\n    _create_installation_cache_folder_if_needed()\r\n    try:\r\n        env.execute([\"-m\", \"easy_install\", \"--zip-ok\", \"--multi-version\",\r\n            \"--always-copy\", \"--exclude-scripts\", \"--install-dir\",\r\n            config.installation_cache_folder()] + requirements)\r\n        zip_eggs_in_folder(config.installation_cache_folder())\r\n    except (KeyboardInterrupt, SystemExit):\r\n        raise\r\n    except Exception:\r\n        raise EnvironmentSetupError(\"pip download failed.\")", "response": "Download pip and its requirements using setuptools."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of options to make setuptools use installations from the given folder.", "response": "def setuptools_install_options(local_storage_folder):\r\n    \"\"\"\r\n    Return options to make setuptools use installations from the given folder.\r\n\r\n    No other installation source is allowed.\r\n\r\n    \"\"\"\r\n    if local_storage_folder is None:\r\n        return []\r\n    # setuptools expects its find-links parameter to contain a list of link\r\n    # sources (either local paths, file: URLs pointing to folders or URLs\r\n    # pointing to a file containing HTML links) separated by spaces. That means\r\n    # that, when specifying such items, whether local paths or URLs, they must\r\n    # not contain spaces. The problem can be worked around by using a local\r\n    # file URL, since URLs can contain space characters encoded as '%20' (for\r\n    # more detailed information see below).\r\n    #\r\n    # Any URL referencing a folder needs to be specified with a trailing '/'\r\n    # character in order for setuptools to correctly recognize it as a folder.\r\n    #\r\n    # All this has been tested using Python 2.4.3/2.4.4 & setuptools 1.4/1.4.2\r\n    # as well as Python 3.4 & setuptools 3.3.\r\n    #\r\n    # Supporting paths with spaces - method 1:\r\n    # ----------------------------------------\r\n    # One way would be to prepare a link file and pass an URL referring to that\r\n    # link file. The link file needs to contain a list of HTML link tags\r\n    # (<a href=\"...\"/>), one for every item stored inside the local storage\r\n    # folder. If a link file references a folder whose name matches the desired\r\n    # requirement name, it will be searched recursively (as described in method\r\n    # 2 below).\r\n    #\r\n    # Note that in order for setuptools to recognize a local link file URL\r\n    # correctly, the file needs to be named with the '.html' extension. That\r\n    # will cause the underlying urllib2.open() operation to return the link\r\n    # file's content type as 'text/html' which is required for setuptools to\r\n    # recognize a valid link file.\r\n    #\r\n    # Supporting paths with spaces - method 2:\r\n    # ----------------------------------------\r\n    # Another possible way is to use an URL referring to the local storage\r\n    # folder directly. This will cause setuptools to prepare and use a link\r\n    # file internally - with its content read from a 'index.html' file located\r\n    # in the given local storage folder, if it exists, or constructed so it\r\n    # contains HTML links to all top-level local storage folder items, as\r\n    # described for method 1 above.\r\n    if \" \" in local_storage_folder:\r\n        find_links_param = utility.path_to_URL(local_storage_folder)\r\n        if find_links_param[-1] != \"/\":\r\n            find_links_param += \"/\"\r\n    else:\r\n        find_links_param = local_storage_folder\r\n    return [\"-f\", find_links_param, \"--allow-hosts=None\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninstalls pip and its requirements using setuptools.", "response": "def install_pip(env, requirements):\r\n    \"\"\"Install pip and its requirements using setuptools.\"\"\"\r\n    try:\r\n        installation_source_folder = config.installation_cache_folder()\r\n        options = setuptools_install_options(installation_source_folder)\r\n        if installation_source_folder is not None:\r\n            zip_eggs_in_folder(installation_source_folder)\r\n        env.execute([\"-m\", \"easy_install\"] + options + requirements)\r\n    except (KeyboardInterrupt, SystemExit):\r\n        raise\r\n    except Exception:\r\n        raise EnvironmentSetupError(\"pip installation failed.\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprepare a pip requirements file if needed.", "response": "def prepare_pip_requirements_file_if_needed(requirements):\r\n    \"\"\"\r\n    Make requirements be passed to pip via a requirements file if needed.\r\n\r\n    We must be careful about how we pass shell operator characters (e.g. '<',\r\n    '>', '|' or '^') included in our command-line arguments or they might cause\r\n    problems if run through an intermediate shell interpreter. If our pip\r\n    requirement specifications contain such characters, we pass them using a\r\n    separate requirements file.\r\n\r\n    This problem has been encountered on Windows 7 SP1 x64 using Python 2.4.3,\r\n    2.4.4 & 2.5.4.\r\n\r\n    \"\"\"\r\n    if utility.any_contains_any(requirements, \"<>|()&^\"):\r\n        file_path, janitor = pip_requirements_file(requirements)\r\n        requirements[:] = [\"-r\", file_path]\r\n        return janitor"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef download_pip_based_installations(env, pip_invocation, requirements,\r\n        download_cache_folder):\r\n    \"\"\"Download requirements for pip based installation.\"\"\"\r\n    if config.installation_cache_folder() is None:\r\n        raise EnvironmentSetupError(\"Local installation cache folder not \"\r\n            \"defined but required for downloading pip based installations.\")\r\n    # Installation cache folder needs to be explicitly created for pip to be\r\n    # able to copy its downloaded installation files into it. The same does not\r\n    # hold for pip's download cache folder which gets created by pip on-demand.\r\n    # Seen using Python 3.4.0 & pip 1.5.4.\r\n    _create_installation_cache_folder_if_needed()\r\n    try:\r\n        pip_options = [\"install\", \"-d\", config.installation_cache_folder(),\r\n            \"--exists-action=i\"]\r\n        pip_options.extend(pip_download_cache_options(download_cache_folder))\r\n        # Running pip based installations on Python 2.5.\r\n        #   * Python 2.5 does not come with SSL support enabled by default and\r\n        #     so pip can not use SSL certified downloads from PyPI.\r\n        #   * To work around this either install the\r\n        #     https://pypi.python.org/pypi/ssl package or run pip using the\r\n        #     '--insecure' command-line options.\r\n        #       * Installing the ssl package seems ridden with problems on\r\n        #         Python 2.5 so this workaround has not been tested.\r\n        if (2, 5) <= env.sys_version_info < (2, 6):\r\n            # There are some potential cases where we do not need to use\r\n            # \"--insecure\", e.g. if the target Python environment already has\r\n            # the 'ssl' module installed. However, detecting whether this is so\r\n            # does not seem to be worth the effort. The only way to detect\r\n            # whether secure download is supported would be to scan the target\r\n            # environment for this information, e.g. setuptools has this\r\n            # information in its pip.backwardcompat.ssl variable - if it is\r\n            # None, the necessary SSL support is not available. But then we\r\n            # would have to be careful:\r\n            #  - not to run the scan if we already know this information from\r\n            #    some previous scan\r\n            #  - to track all actions that could have invalidated our previous\r\n            #    scan results, etc.\r\n            # It just does not seem to be worth the hassle so for now - YAGNI.\r\n            pip_options.append(\"--insecure\")\r\n        env.execute(pip_invocation + pip_options + requirements)\r\n    except (KeyboardInterrupt, SystemExit):\r\n        raise\r\n    except Exception:\r\n        raise EnvironmentSetupError(\"pip based download failed.\")", "response": "Download pip based installations."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of actions to perform when processing the given environment.", "response": "def enabled_actions_for_env(env):\r\n    \"\"\"Returns actions to perform when processing the given environment.\"\"\"\r\n    def enabled(config_value, required):\r\n        if config_value is Config.TriBool.No:\r\n            return False\r\n        if config_value is Config.TriBool.Yes:\r\n            return True\r\n        assert config_value is Config.TriBool.IfNeeded\r\n        return bool(required)\r\n\r\n    # Some old Python versions do not support HTTPS downloads and therefore can\r\n    # not download installation packages from PyPI. To run setuptools or pip\r\n    # based installations on such Python versions, all the required\r\n    # installation packages need to be downloaded locally first using a\r\n    # compatible Python version (e.g. Python 2.4.4 for Python 2.4.3) and then\r\n    # installed locally.\r\n    download_supported = not ((2, 4, 3) <= env.sys_version_info < (2, 4, 4))\r\n\r\n    local_install = config.installation_cache_folder() is not None\r\n\r\n    actions = set()\r\n\r\n    pip_required = False\r\n    run_pip_based_installations = enabled(config.install_environments, True)\r\n    if run_pip_based_installations:\r\n        actions.add(\"run pip based installations\")\r\n        pip_required = True\r\n    if download_supported and enabled(config.download_installations,\r\n            local_install and run_pip_based_installations):\r\n        actions.add(\"download pip based installations\")\r\n        pip_required = True\r\n\r\n    setuptools_required = False\r\n    run_pip_installation = enabled(config.install_environments, pip_required)\r\n    if run_pip_installation:\r\n        actions.add(\"run pip installation\")\r\n        setuptools_required = True\r\n    if download_supported and enabled(config.download_installations,\r\n            local_install and run_pip_installation):\r\n        actions.add(\"download pip installation\")\r\n        setuptools_required = True\r\n\r\n    if enabled(config.setup_setuptools, setuptools_required):\r\n        actions.add(\"setup setuptools\")\r\n\r\n    return actions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading setuptools version from the underlying ez_setup script.", "response": "def __setuptools_version(self):\r\n        \"\"\"Read setuptools version from the underlying ez_setup script.\"\"\"\r\n        # Read the script directly as a file instead of importing it as a\r\n        # Python module and reading the value from the loaded module's global\r\n        # DEFAULT_VERSION variable. Not all ez_setup scripts are compatible\r\n        # with all Python environments and so importing them would require\r\n        # doing so using a separate process run in the target Python\r\n        # environment instead of the current one.\r\n        f = open(self.script_path(), \"r\")\r\n        try:\r\n            matcher = re.compile(r'\\s*DEFAULT_VERSION\\s*=\\s*\"([^\"]*)\"\\s*$')\r\n            for i, line in enumerate(f):\r\n                if i > 50:\r\n                    break\r\n                match = matcher.match(line)\r\n                if match:\r\n                    return match.group(1)\r\n        finally:\r\n            f.close()\r\n        self.__error(\"error parsing setuptools installation script '%s'\" % (\r\n            self.script_path(),))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rename(self, name):\n        if name is None:\n            raise Exception(\"name (%s) not-valid\" % (name,))\n        self.prefix, self.name = splitPrefix(name)", "response": "Rename the element.\n\n        @param name: A new name for the element.\n        @type name: basestring"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clone(self, parent=None):\n        root = Element(self.qname(), parent, self.namespace())\n        for a in self.attributes:\n            root.append(a.clone(self))\n        for c in self.children:\n            root.append(c.clone(self))\n        for ns in self.nsprefixes.items():\n            root.addPrefix(ns[0], ns[1])\n        return root", "response": "Deep clone of this element and children."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, name, ns=None, default=None):\n        attr = self.getAttribute(name, ns)\n        if attr is None or attr.value is None:\n            return default\n        return attr.getValue()", "response": "Get the value of an attribute by name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef namespace(self):\n        if self.prefix is None:\n            return self.defaultNamespace()\n        return self.resolvePrefix(self.prefix)", "response": "Get the element s namespace by resolving the explicit\n            namespace."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef defaultNamespace(self):\n        p = self\n        while p is not None:\n            if p.expns is not None:\n                return None, p.expns\n            p = p.parent\n        return Namespace.default", "response": "Get the default namespace of the current node when not qualified."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append(self, objects):\n        if not isinstance(objects, (list, tuple)):\n            objects = (objects,)\n        for child in objects:\n            if isinstance(child, Element):\n                self.children.append(child)\n                child.parent = self\n                continue\n            if isinstance(child, Attribute):\n                self.attributes.append(child)\n                child.parent = self\n                continue\n            raise Exception(\"append %s not-valid\" %\n                (child.__class__.__name__,))\n        return self", "response": "Append the specified child based on whether it is an element or an attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef insert(self, objects, index=0):\n        objects = (objects,)\n        for child in objects:\n            if not isinstance(child, Element):\n                raise Exception(\"append %s not-valid\" %\n                    (child.__class__.__name__,))\n            self.children.insert(index, child)\n            child.parent = self\n        return self", "response": "Insert an object or collection of objects at the specified index."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a child by name and namespace.", "response": "def getChild(self, name, ns=None, default=None):\n        \"\"\"\n        Get a child by (optional) name and/or (optional) namespace.\n\n        @param name: The name of a child element (may contain prefix).\n        @type name: basestring\n        @param ns: An optional namespace used to match the child.\n        @type ns: (I{prefix}, I{name})\n        @param default: Returned when child not-found.\n        @type default: L{Element}\n        @return: The requested child, or I{default} when not-found.\n        @rtype: L{Element}\n\n        \"\"\"\n        if ns is None:\n            prefix, name = splitPrefix(name)\n            if prefix is not None:\n                ns = self.resolvePrefix(prefix)\n        for c in self.children:\n            if c.match(name, ns):\n                return c\n        return default"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef childAtPath(self, path):\n        result = None\n        node = self\n        for name in path.split(\"/\"):\n            if not name:\n                continue\n            ns = None\n            prefix, name = splitPrefix(name)\n            if prefix is not None:\n                ns = node.resolvePrefix(prefix)\n            result = node.getChild(name, ns)\n            if result is None:\n                return\n            node = result\n        return result", "response": "Get a child at the given path."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef childrenAtPath(self, path):\n        parts = [p for p in path.split(\"/\") if p]\n        if len(parts) == 1:\n            return self.getChildren(path)\n        return self.__childrenAtPath(parts)", "response": "Get a list of children at I { path"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a list of children by name and namespace.", "response": "def getChildren(self, name=None, ns=None):\n        \"\"\"\n        Get a list of children by (optional) name and/or (optional) namespace.\n\n        @param name: The name of a child element (may contain a prefix).\n        @type name: basestring\n        @param ns: An optional namespace used to match the child.\n        @type ns: (I{prefix}, I{name})\n        @return: The list of matching children.\n        @rtype: [L{Element},...]\n\n        \"\"\"\n        if ns is None:\n            if name is None:\n                return self.children\n            prefix, name = splitPrefix(name)\n            if prefix is not None:\n                ns = self.resolvePrefix(prefix)\n        return [c for c in self.children if c.match(name, ns)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npromoting the prefix declarations up the tree as far as possible.", "response": "def promotePrefixes(self):\n        \"\"\"\n        Push prefix declarations up the tree as far as possible.\n\n        Prefix mapping are pushed to its parent unless the parent has the\n        prefix mapped to another URI or the parent has the prefix. This is\n        propagated up the tree until the top is reached.\n\n        @return: self\n        @rtype: L{Element}\n\n        \"\"\"\n        for c in self.children:\n            c.promotePrefixes()\n        if self.parent is None:\n            return\n        for p, u in self.nsprefixes.items():\n            if p in self.parent.nsprefixes:\n                pu = self.parent.nsprefixes[p]\n                if pu == u:\n                    del self.nsprefixes[p]\n                continue\n            if p != self.parent.prefix:\n                self.parent.nsprefixes[p] = u\n                del self.nsprefixes[p]\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef isempty(self, content=True):\n        nochildren = not self.children\n        notext = self.text is None\n        nocontent = nochildren and notext\n        if content:\n            return nocontent\n        noattrs = not len(self.attributes)\n        return nocontent and noattrs", "response": "Return True if the element has no children and no attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if the element is I { nil } otherwise False.", "response": "def isnil(self):\n        \"\"\"\n        Get whether the element is I{nil} as defined by having an\n        I{xsi:nil=\"true\"} attribute.\n\n        @return: True if I{nil}, else False\n        @rtype: boolean\n\n        \"\"\"\n        nilattr = self.getAttribute(\"nil\", ns=Namespace.xsins)\n        return nilattr is not None and (nilattr.getValue().lower() == \"true\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting this node to I { nil } as defined by having an I { xsi : nil } = I { flag } = I { flag } = I { nil } = I { flag } = I { nil } = I { flag } = I { nil } = I { flag } = I { nil } = I { flag } = I { nil } = I { flag } = I { nil } = I { nil } = I { nil } = I {", "response": "def setnil(self, flag=True):\n        \"\"\"\n        Set this node to I{nil} as defined by having an I{xsi:nil}=I{flag}\n        attribute.\n\n        @param flag: A flag indicating how I{xsi:nil} will be set.\n        @type flag: boolean\n        @return: self\n        @rtype: L{Element}\n\n        \"\"\"\n        p, u = Namespace.xsins\n        name = \":\".join((p, \"nil\"))\n        self.set(name, str(flag).lower())\n        self.addPrefix(p, u)\n        if flag:\n            self.text = None\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying the namespace to this node.", "response": "def applyns(self, ns):\n        \"\"\"\n        Apply the namespace to this node.\n\n        If the prefix is I{None} then this element's explicit namespace\n        I{expns} is set to the URI defined by I{ns}. Otherwise, the I{ns} is\n        simply mapped.\n\n        @param ns: A namespace.\n        @type ns: (I{prefix}, I{URI})\n\n        \"\"\"\n        if ns is None:\n            return\n        if not isinstance(ns, (list, tuple)):\n            raise Exception(\"namespace must be a list or a tuple\")\n        if ns[0] is None:\n            self.expns = ns[1]\n        else:\n            self.prefix = ns[0]\n            self.nsprefixes[ns[0]] = ns[1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef str(self, indent=0):\n        tab = \"%*s\" % (indent * 3, \"\")\n        result = []\n        result.append(\"%s<%s\" % (tab, self.qname()))\n        result.append(self.nsdeclarations())\n        for a in self.attributes:\n            result.append(\" %s\" % (unicode(a),))\n        if self.isempty():\n            result.append(\"/>\")\n            return \"\".join(result)\n        result.append(\">\")\n        if self.hasText():\n            result.append(self.text.escape())\n        for c in self.children:\n            result.append(\"\\n\")\n            result.append(c.str(indent + 1))\n        if len(self.children):\n            result.append(\"\\n%s\" % (tab,))\n        result.append(\"</%s>\" % (self.qname(),))\n        return \"\".join(result)", "response": "Get a string representation of this XML fragment."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plain(self):\n        result = [\"<%s\" % (self.qname(),), self.nsdeclarations()]\n        for a in self.attributes:\n            result.append(\" %s\" % (unicode(a),))\n        if self.isempty():\n            result.append(\"/>\")\n            return \"\".join(result)\n        result.append(\">\")\n        if self.hasText():\n            result.append(self.text.escape())\n        for c in self.children:\n            result.append(c.plain())\n        result.append(\"</%s>\" % (self.qname(),))\n        return \"\".join(result)", "response": "Get a string representation of this XML fragment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a string representation for all namespace declarations as xmlns = None and xmlns : p = None.", "response": "def nsdeclarations(self):\n        \"\"\"\n        Get a string representation for all namespace declarations as xmlns=\"\"\n        and xmlns:p=\"\".\n\n        @return: A separated list of declarations.\n        @rtype: basestring\n\n        \"\"\"\n        s = []\n        myns = None, self.expns\n        if self.parent is None:\n            pns = Namespace.default\n        else:\n            pns = None, self.parent.expns\n        if myns[1] != pns[1]:\n            if self.expns is not None:\n                s.append(' xmlns=\"%s\"' % (self.expns,))\n        for item in self.nsprefixes.items():\n            p, u = item\n            if self.parent is not None:\n                ns = self.parent.resolvePrefix(p)\n                if ns[1] == u:\n                    continue\n            s.append(' xmlns:%s=\"%s\"' % (p, u))\n        return \"\".join(s)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nopening a WSDL schema at the specified I { URL.", "response": "def open(self, url):\n        \"\"\"\n        Open a WSDL schema at the specified I{URL}.\n\n        First, the WSDL schema is looked up in the I{object cache}. If not\n        found, a new one constructed using the I{fn} factory function and the\n        result is cached for the next open().\n\n        @param url: A WSDL URL.\n        @type url: str.\n        @return: The WSDL object.\n        @rtype: I{Definitions}\n\n        \"\"\"\n        cache = self.__cache()\n        id = self.mangle(url, \"wsdl\")\n        wsdl = cache.get(id)\n        if wsdl is None:\n            wsdl = self.fn(url, self.options)\n            cache.put(id, wsdl)\n        else:\n            # Cached WSDL Definitions objects may have been created with\n            # different options so we update them here with our current ones.\n            wsdl.options = self.options\n            for imp in wsdl.imports:\n                imp.imported.options = self.options\n        return wsdl"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the I { object cache } when I { cachingpolicy = B1.", "response": "def __cache(self):\n        \"\"\"\n        Get the I{object cache}.\n\n        @return: The I{cache} when I{cachingpolicy} = B{1}.\n        @rtype: L{Cache}\n\n        \"\"\"\n        if self.options.cachingpolicy == 1:\n            return self.options.cache\n        return suds.cache.NoCache()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open(self, url):\n        cache = self.__cache()\n        id = self.mangle(url, \"document\")\n        xml = cache.get(id)\n        if xml is None:\n            xml = self.__fetch(url)\n            cache.put(id, xml)\n        self.plugins.document.parsed(url=url, document=xml.root())\n        return xml", "response": "Open an XML document at the specified URL."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __fetch(self, url):\n        content = None\n        store = self.options.documentStore\n        if store is not None:\n            content = store.open(url)\n        if content is None:\n            request = suds.transport.Request(url)\n            fp = self.options.transport.open(request)\n            try:\n                content = fp.read()\n            finally:\n                fp.close()\n        ctx = self.plugins.document.loaded(url=url, document=content)\n        content = ctx.document\n        sax = suds.sax.parser.Parser()\n        return sax.parse(string=content)", "response": "Fetch the content of a document from an external source."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nencode special characters found in string I { s.", "response": "def encode(self, s):\n        \"\"\"\n        Encode special characters found in string I{s}.\n\n        @param s: A string to encode.\n        @type s: str\n        @return: The encoded string.\n        @rtype: str\n\n        \"\"\"\n        if isinstance(s, basestring) and self.__needs_encoding(s):\n            for x in self.encodings:\n                s = re.sub(x[0], x[1], s)\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __needs_encoding(self, s):\n        if isinstance(s, basestring):\n            for c in self.special:\n                if c in s:\n                    return True", "response": "Check if string I { s contains special characters."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef virtualenv_requirements(version_info=sys.version_info):\r\n    if version_info < (2, 5):\r\n        # 'virtualenv' release 1.8 dropped Python 2.4.x compatibility.\r\n        yield requirement_spec(\"virtualenv\",\r\n            (\"<\", lowest_version_string_with_prefix(\"1.8\")))\r\n    elif version_info < (2, 6):\r\n        # 'virtualenv' release 1.10 dropped Python 2.5.x compatibility.\r\n        yield requirement_spec(\"virtualenv\",\r\n            (\"<\", lowest_version_string_with_prefix(\"1.10\")))\r\n    else:\r\n        yield requirement_spec(\"virtualenv\")", "response": "Generate a generator of all the virtualenv packages that are available on the current Python version."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __construct_python_version(self):\r\n        major, minor, micro, release_level, serial = self.sys_version_info\r\n        assert release_level in (\"alfa\", \"beta\", \"candidate\", \"final\")\r\n        assert release_level != \"final\" or serial == 0\r\n        parts = [str(major), \".\", str(minor), \".\", str(micro)]\r\n        if release_level != \"final\":\r\n            parts.append(release_level[0])\r\n            parts.append(str(serial))\r\n        self.python_version = \"\".join(parts)", "response": "Construct a setuptools compatible Python version string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __parse_scanned_version_info(self):\r\n        string = self.sys_version_info_formatted\r\n        try:\r\n            major, minor, micro, release_level, serial = string.split(\",\")\r\n            if (release_level in (\"alfa\", \"beta\", \"candidate\", \"final\") and\r\n                    (release_level != \"final\" or serial == \"0\") and\r\n                    major.isdigit() and  # --- --- --- --- --- --- --- --- ---\r\n                    minor.isdigit() and  # Explicit isdigit() checks to detect\r\n                    micro.isdigit() and  # leading/trailing whitespace.\r\n                    serial.isdigit()):   # --- --- --- --- --- --- --- --- ---\r\n                self.sys_version_info = (int(major), int(minor), int(micro),\r\n                    release_level, int(serial))\r\n                self.__construct_python_version()\r\n                return\r\n        except (KeyboardInterrupt, SystemExit):\r\n            raise\r\n        except Exception:\r\n            pass\r\n        raise BadEnvironment(\"Unsupported Python version (%s)\" % (string,))", "response": "Parses the environment s formatted version info string and returns a tuple of integers."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting complex using the specified indent n and newline ( nl ).", "response": "def print_dictionary(self, d, h, n, nl=False):\n        \"\"\"Print complex using the specified indent (n) and newline (nl).\"\"\"\n        if d in h:\n            return \"{}...\"\n        h.append(d)\n        s = []\n        if nl:\n            s.append(\"\\n\")\n            s.append(self.indent(n))\n        s.append(\"{\")\n        for item in d.items():\n            s.append(\"\\n\")\n            s.append(self.indent(n+1))\n            if isinstance(item[1], (list,tuple)):\n                s.append(tostr(item[0]))\n                s.append(\"[]\")\n            else:\n                s.append(tostr(item[0]))\n            s.append(\" = \")\n            s.append(self.process(item[1], h, n, True))\n        s.append(\"\\n\")\n        s.append(self.indent(n))\n        s.append(\"}\")\n        h.pop()\n        return \"\".join(s)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting a collection using the specified indent n and newline nl.", "response": "def print_collection(self, c, h, n):\n        \"\"\"Print collection using the specified indent (n) and newline (nl).\"\"\"\n        if c in h:\n            return \"[]...\"\n        h.append(c)\n        s = []\n        for item in c:\n            s.append(\"\\n\")\n            s.append(self.indent(n))\n            s.append(self.process(item, h, n - 2))\n            s.append(\",\")\n        h.pop()\n        return \"\".join(s)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef node(self, content):\n        ns = content.type.namespace()\n        if content.type.form_qualified:\n            node = Element(content.tag, ns=ns)\n            if ns[0]:\n                node.addPrefix(ns[0], ns[1])\n        else:\n            node = Element(content.tag)\n        self.encode(node, content)\n        log.debug(\"created - node:\\n%s\", node)\n        return node", "response": "Create an XML node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds encoding information to the node.", "response": "def encode(self, node, content):\n        \"\"\"\n        Add (SOAP) encoding information if needed.\n\n        The encoding information is added only if the resolved type is derived\n        by extension. Furthermore, the xsi:type value is qualified by namespace\n        only if the content (tag) and referenced type are in different\n        namespaces.\n\n        \"\"\"\n        if content.type.any():\n            return\n        if not content.real.extension():\n            return\n        if content.type.resolve() == content.real:\n            return\n        ns = None\n        name = content.real.name\n        if self.xstq:\n            ns = content.real.namespace(\"ns1\")\n        Typer.manual(node, name, ns)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the content should be skipped.", "response": "def skip(self, content):\n        \"\"\"\n        Get whether to skip this I{content}.\n\n        Should be skipped when the content is optional and value is either None\n        or an empty list.\n\n        @param content: Content to skip.\n        @type content: L{Object}\n        @return: True if content is to be skipped.\n        @rtype: bool\n\n        \"\"\"\n        if self.optional(content):\n            v = content.value\n            if v is None:\n                return True\n            if isinstance(v, (list, tuple)) and not v:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetecting egg distributions located in the given folder.", "response": "def _detect_eggs_in_folder(folder):\r\n    \"\"\"\r\n    Detect egg distributions located in the given folder.\r\n\r\n    Only direct folder content is considered and subfolders are not searched\r\n    recursively.\r\n\r\n    \"\"\"\r\n    eggs = {}\r\n    for x in os.listdir(folder):\r\n        zip = x.endswith(_zip_ext)\r\n        if zip:\r\n            root = x[:-len(_zip_ext)]\r\n            egg = _Egg.NONE\r\n        elif x.endswith(_egg_ext):\r\n            root = x[:-len(_egg_ext)]\r\n            if os.path.isdir(os.path.join(folder, x)):\r\n                egg = _Egg.FOLDER\r\n            else:\r\n                egg = _Egg.FILE\r\n        else:\r\n            continue\r\n        try:\r\n            info = eggs[root]\r\n        except KeyError:\r\n            eggs[root] = _Egg(os.path.join(folder, root), egg, zip)\r\n        else:\r\n            if egg is not _Egg.NONE:\r\n                info.set_egg(egg)\r\n            if zip:\r\n                info.set_zip()\r\n    return eggs.values()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nnormalizing the contents of the egg distribution to be a single egg file.", "response": "def normalize(self):\r\n        \"\"\"\r\n        Makes sure this egg distribution is stored only as an egg file.\r\n\r\n        The egg file will be created from another existing distribution format\r\n        if needed.\r\n\r\n        \"\"\"\r\n        if self.has_egg_file():\r\n            if self.has_zip():\r\n                self.__remove_zip()\r\n        else:\r\n            if self.has_egg_folder():\r\n                if not self.has_zip():\r\n                    self.__zip_egg_folder()\r\n                self.__remove_egg_folder()\r\n            self.__rename_zip_to_egg()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_args(method_name, param_defs, args, kwargs, external_param_processor,\n    extra_parameter_errors):\n    \"\"\"\n    Parse arguments for suds web service operation invocation functions.\n\n    Suds prepares Python function objects for invoking web service operations.\n    This function implements generic binding agnostic part of processing the\n    arguments passed when calling those function objects.\n\n    Argument parsing rules:\n      * Each input parameter element should be represented by single regular\n        Python function argument.\n      * At most one input parameter belonging to a single choice parameter\n        structure may have its value specified as something other than None.\n      * Positional arguments are mapped to choice group input parameters the\n        same as is done for a simple all/sequence group - each in turn.\n\n    Expects to be passed the web service operation's parameter definitions\n    (parameter name, type & optional ancestry information) in order and, based\n    on that, extracts the values for those parameter from the arguments\n    provided in the web service operation invocation call.\n\n    Ancestry information describes parameters constructed based on suds\n    library's automatic input parameter structure unwrapping. It is expected to\n    include the parameter's XSD schema 'ancestry' context, i.e. a list of all\n    the parent XSD schema tags containing the parameter's <element> tag. Such\n    ancestry context provides detailed information about how the parameter's\n    value is expected to be used, especially in relation to other input\n    parameters, e.g. at most one parameter value may be specified for\n    parameters directly belonging to the same choice input group.\n\n    Rules on acceptable ancestry items:\n      * Ancestry item's choice() method must return whether the item\n        represents a <choice> XSD schema tag.\n      * Passed ancestry items are used 'by address' internally and the same XSD\n        schema tag is expected to be identified by the exact same ancestry item\n        object during the whole argument processing.\n\n    During processing, each parameter's definition and value, together with any\n    additional pertinent information collected from the encountered parameter\n    definition structure, is passed on to the provided external parameter\n    processor function. There that information is expected to be used to\n    construct the actual binding specific web service operation invocation\n    request.\n\n    Raises a TypeError exception in case any argument related errors are\n    detected. The exceptions raised have been constructed to make them as\n    similar as possible to their respective exceptions raised during regular\n    Python function argument checking.\n\n    Does not support multiple same-named input parameters.\n\n    \"\"\"\n    arg_parser = _ArgParser(method_name, param_defs, external_param_processor)\n    return arg_parser(args, kwargs, extra_parameter_errors)", "response": "Parses the arguments passed to the suds web service operation invocation functions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __all_parameters_processed(self):\n        assert self.active()\n        sentinel_frame = self.__stack[0]\n        self.__pop_frames_above(sentinel_frame)\n        assert len(self.__stack) == 1\n        self.__pop_top_frame()\n        assert not self.active()\n        args_required = sentinel_frame.args_required()\n        args_allowed = sentinel_frame.args_allowed()\n        self.__check_for_extra_arguments(args_required, args_allowed)\n        return args_required, args_allowed", "response": "Finish the argument processing."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if any extra arguments are detected.", "response": "def __check_for_extra_arguments(self, args_required, args_allowed):\n        \"\"\"\n        Report an error in case any extra arguments are detected.\n\n        Does nothing if reporting extra arguments as exceptions has not been\n        enabled.\n\n        May only be called after the argument processing has been completed.\n\n        \"\"\"\n        assert not self.active()\n        if not self.__extra_parameter_errors:\n            return\n\n        if self.__kwargs:\n            param_name = self.__kwargs.keys()[0]\n            if param_name in self.__params_with_arguments:\n                msg = \"got multiple values for parameter '%s'\"\n            else:\n                msg = \"got an unexpected keyword argument '%s'\"\n            self.__error(msg % (param_name,))\n\n        if self.__args:\n            def plural_suffix(count):\n                if count == 1:\n                    return \"\"\n                return \"s\"\n            def plural_was_were(count):\n                if count == 1:\n                    return \"was\"\n                return \"were\"\n            expected = args_required\n            if args_required != args_allowed:\n                expected = \"%d to %d\" % (args_required, args_allowed)\n            given = self.__args_count\n            msg_parts = [\"takes %s positional argument\" % (expected,),\n                plural_suffix(expected), \" but %d \" % (given,),\n                plural_was_were(given), \" given\"]\n            self.__error(\"\".join(msg_parts))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a new frame representing the given ancestry item.", "response": "def __frame_factory(self, ancestry_item):\n        \"\"\"Construct a new frame representing the given ancestry item.\"\"\"\n        frame_class = Frame\n        if ancestry_item is not None and ancestry_item.choice():\n            frame_class = ChoiceFrame\n        return frame_class(ancestry_item, self.__error,\n            self.__extra_parameter_errors)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract a parameter value from the remaining arguments.", "response": "def __get_param_value(self, name):\n        \"\"\"\n        Extract a parameter value from the remaining given arguments.\n\n        Returns a 2-tuple consisting of the following:\n          * Boolean indicating whether an argument has been specified for the\n            requested input parameter.\n          * Parameter value.\n\n        \"\"\"\n        if self.__args:\n            return True, self.__args.pop(0)\n        try:\n            value = self.__kwargs.pop(name)\n        except KeyError:\n            return False, None\n        return True, value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if we are currently processing a choice parameter group.", "response": "def __in_choice_context(self):\n        \"\"\"\n        Whether we are currently processing a choice parameter group.\n\n        This includes processing a parameter defined directly or indirectly\n        within such a group.\n\n        May only be called during parameter processing or the result will be\n        calculated based on the context left behind by the previous parameter\n        processing if any.\n\n        \"\"\"\n        for x in self.__stack:\n            if x.__class__ is ChoiceFrame:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing data for a new argument parsing run.", "response": "def __init_run(self, args, kwargs, extra_parameter_errors):\n        \"\"\"Initializes data for a new argument parsing run.\"\"\"\n        assert not self.active()\n        self.__args = list(args)\n        self.__kwargs = dict(kwargs)\n        self.__extra_parameter_errors = extra_parameter_errors\n        self.__args_count = len(args) + len(kwargs)\n        self.__params_with_arguments = set()\n        self.__stack = []\n        self.__push_frame(None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __match_ancestry(self, ancestry):\n        stack = self.__stack\n        if len(stack) == 1:\n            return stack[0], ancestry\n        previous = stack[0]\n        for frame, n in zip(stack[1:], xrange(len(ancestry))):\n            if frame.id() is not ancestry[n]:\n                return previous, ancestry[n:]\n            previous = frame\n        return frame, ancestry[n + 1:]", "response": "Find frames matching the given ancestry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __pop_frames_above(self, frame):\n        while self.__stack[-1] is not frame:\n            self.__pop_top_frame()\n        assert self.__stack", "response": "Pops all the frames above the given frame."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __pop_top_frame(self):\n        popped = self.__stack.pop()\n        if self.__stack:\n            self.__stack[-1].process_subframe(popped)", "response": "Pops the top frame off the frame stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __process_parameter(self, param_name, param_type, ancestry=None):\n        assert self.active()\n        param_optional = param_type.optional()\n        has_argument, value = self.__get_param_value(param_name)\n        if has_argument:\n            self.__params_with_arguments.add(param_name)\n        self.__update_context(ancestry)\n        self.__stack[-1].process_parameter(param_optional, value is not None)\n        self.__external_param_processor(param_name, param_type,\n            self.__in_choice_context(), value)", "response": "Collect values for a given web service operation input parameter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npush a new frame on top of the stack.", "response": "def __push_frame(self, ancestry_item):\n        \"\"\"Push a new frame on top of the frame stack.\"\"\"\n        frame = self.__frame_factory(ancestry_item)\n        self.__stack.append(frame)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nopening a document at the specified URL.", "response": "def open(self, url):\n        \"\"\"\n        Open a document at the specified URL.\n\n        The document URL's needs not contain a protocol identifier, and if it\n        does, that protocol identifier is ignored when looking up the store\n        content.\n\n        Missing documents referenced using the internal 'suds' protocol are\n        reported by raising an exception. For other protocols, None is returned\n        instead.\n\n        @param url: A document URL.\n        @type url: str\n        @return: Document content or None if not found.\n        @rtype: bytes\n\n        \"\"\"\n        protocol, location = self.__split(url)\n        content = self.__find(location)\n        if protocol == 'suds' and content is None:\n            raise Exception, 'location \"%s\" not in document store' % location\n        return content"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the given Python source file s compiled content.", "response": "def read_python_code(filename):\n    \"Returns the given Python source file's compiled content.\"\n    file = open(filename, \"rt\")\n    try:\n        source = file.read()\n    finally:\n        file.close()\n    # Python 2.6 and below did not support passing strings to exec() &\n    # compile() functions containing line separators other than '\\n'. To\n    # support them we need to manually make sure such line endings get\n    # converted even on platforms where this is not handled by native text file\n    # read operations.\n    source = source.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n    return compile(source, filename, \"exec\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of all the given packages and all their subpackages. Given packages are expected to be found relative to this script's location. Subpackages are detected by scanning the given packages' subfolder hierarchy for any folders containing the '__init__.py' module. As a consequence, namespace packages are not supported. This is our own specialized setuptools.find_packages() replacement so we can avoid the setuptools dependency.", "response": "def recursive_package_list(*packages):\n    \"\"\"\n    Returns a list of all the given packages and all their subpackages.\n\n    Given packages are expected to be found relative to this script's location.\n\n    Subpackages are detected by scanning the given packages' subfolder\n    hierarchy for any folders containing the '__init__.py' module. As a\n    consequence, namespace packages are not supported.\n\n    This is our own specialized setuptools.find_packages() replacement so we\n    can avoid the setuptools dependency.\n\n    \"\"\"\n    result = set()\n    todo = []\n    for package in packages:\n        folder = os.path.join(script_folder, *package.split(\".\"))\n        if not os.path.isdir(folder):\n            raise Exception(\"Folder not found for package '%s'.\" % (package,))\n        todo.append((package, folder))\n    while todo:\n        package, folder = todo.pop()\n        if package in result:\n            continue\n        result.add(package)\n        for subitem in os.listdir(folder):\n            subpackage = \".\".join((package, subitem))\n            subfolder = os.path.join(folder, subitem)\n            if not os.path.isfile(os.path.join(subfolder, \"__init__.py\")):\n                continue\n            todo.append((subpackage, subfolder))\n    return list(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef multi_occurrence(self):\n        max = self.max\n        if max is None:\n            return False\n        if max.isdigit():\n            return int(max) > 1\n        return max == \"unbounded\"", "response": "Returns True if the node has at most one occurrence."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds a referenced type in self or children. Return None if not found.", "response": "def find(self, qref, classes=[], ignore=None):\n        \"\"\"\n        Find a referenced type in self or children. Return None if not found.\n\n        Qualified references for all schema objects checked in this search will\n        be added to the set of ignored qualified references to avoid the find\n        operation going into an infinite loop in case of recursively defined\n        structures.\n\n        @param qref: A qualified reference.\n        @type qref: qref\n        @param classes: A collection of classes used to qualify the match.\n        @type classes: Collection(I{class},...), e.g. [I(class),...]\n        @param ignore: A set of qualified references to ignore in this search.\n        @type ignore: {qref,...}\n        @return: The referenced type.\n        @rtype: L{SchemaObject}\n        @see: L{qualify()}\n\n        \"\"\"\n        if not len(classes):\n            classes = (self.__class__,)\n        if ignore is None:\n            ignore = set()\n        if self.qname in ignore:\n            return\n        ignore.add(self.qname)\n        if self.qname == qref and self.__class__ in classes:\n            return self\n        for c in self.rawchildren:\n            p = c.find(qref, classes, ignore=ignore)\n            if p is not None:\n                return p"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef next(self):\n        frame = self.top()\n        while True:\n            result = frame.next()\n            if result is None:\n                self.pop()\n                return self.next()\n            if isinstance(result, Content):\n                ancestry = [f.sx for f in self.stack]\n                return result, ancestry\n            self.push(result)\n            return self.next()", "response": "Get the next item."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess the content using the optional type information.", "response": "def process(self, content):\n        \"\"\"\n        Process (marshal) the tag with the specified value using the\n        optional type information.\n        @param content: The content to process.\n        @type content: L{Object}\n        \"\"\"\n        log.debug('processing:\\n%s', content)\n        self.reset()\n        if content.tag is None:\n            content.tag = content.value.__class__.__name__\n        document = Document()\n        self.append(document, content)\n        return document.root()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds prefixes for each namespace referenced by parameter types.", "response": "def getprefixes(self):\n        \"\"\"Add prefixes for each namespace referenced by parameter types.\"\"\"\n        namespaces = []\n        for l in (self.params, self.types):\n            for t,r in l:\n                ns = r.namespace()\n                if ns[1] is None: continue\n                if ns[1] in namespaces: continue\n                if Namespace.xs(ns) or Namespace.xsd(ns):\n                    continue\n                namespaces.append(ns[1])\n                if t == r: continue\n                ns = t.namespace()\n                if ns[1] is None: continue\n                if ns[1] in namespaces: continue\n                namespaces.append(ns[1])\n        i = 0\n        namespaces.sort()\n        for u in namespaces:\n            p = self.nextprefix()\n            ns = (p, u)\n            self.prefixes.append(ns)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef xlate(self, type):\n        resolved = type.resolve()\n        name = resolved.name\n        if type.multi_occurrence():\n            name += '[]'\n        ns = resolved.namespace()\n        if ns[1] == self.wsdl.tns[1]:\n            return name\n        prefix = self.getprefix(ns[1])\n        return ':'.join((prefix, name))", "response": "Get a ( namespace ) translated I{qualified name for specified type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef description(self):\n        s = []\n        indent = (lambda n :  '\\n%*s'%(n*3,' '))\n        s.append('Service ( %s ) tns=\"%s\"' % (self.service.name, self.wsdl.tns[1]))\n        s.append(indent(1))\n        s.append('Prefixes (%d)' % len(self.prefixes))\n        for p in self.prefixes:\n            s.append(indent(2))\n            s.append('%s = \"%s\"' % p)\n        s.append(indent(1))\n        s.append('Ports (%d):' % len(self.ports))\n        for p in self.ports:\n            s.append(indent(2))\n            s.append('(%s)' % p[0].name)\n            s.append(indent(3))\n            s.append('Methods (%d):' % len(p[1]))\n            for m in p[1]:\n                sig = []\n                s.append(indent(4))\n                sig.append(m[0])\n                sig.append('(')\n                sig.append(', '.join(\"%s %s\" % (self.xlate(p[1]), p[0]) for p\n                    in m[1]))\n                sig.append(')')\n                try:\n                    s.append(''.join(sig))\n                except Exception:\n                    pass\n            s.append(indent(3))\n            s.append('Types (%d):' % len(self.types))\n            for t in self.types:\n                s.append(indent(4))\n                s.append(self.xlate(t[0]))\n        s.append('\\n\\n')\n        return ''.join(s)", "response": "Get a textual description of the service for which this object represents."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nappending the root element to the document root element.", "response": "def append(self, node):\n        \"\"\"\n        Append (set) the document root.\n        @param node: A root L{Element} or name used to build\n            the document root element.\n        @type node: (L{Element}|str|None)\n        \"\"\"\n        if isinstance(node, basestring):\n            self.__root = Element(node)\n            return\n        if isinstance(node, Element):\n            self.__root = node\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getChild(self, name, ns=None, default=None):\n        if self.__root is None:\n            return default\n        if ns is None:\n            prefix, name = splitPrefix(name)\n            if prefix is None:\n                ns = None\n            else:\n                ns = self.__root.resolvePrefix(prefix)\n        if self.__root.match(name, ns):\n            return self.__root\n        else:\n            return default", "response": "Get a child by name and namespace."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a child at the specified path.", "response": "def childAtPath(self, path):\n        \"\"\"\n        Get a child at I{path} where I{path} is a (/) separated\n        list of element names that are expected to be children.\n        @param path: A (/) separated list of element names.\n        @type path: basestring\n        @return: The leaf node at the end of I{path}\n        @rtype: L{Element}\n        \"\"\"\n        if self.__root is None:\n            return None\n        if path[0] == '/':\n            path = path[1:]\n        path = path.split('/',1)\n        if self.getChild(path[0]) is None:\n            return None\n        if len(path) > 1:\n            return self.__root.childAtPath(path[1])\n        else:\n            return self.__root"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef childrenAtPath(self, path):\n        if self.__root is None:\n            return []\n        if path[0] == '/':\n            path = path[1:]\n        path = path.split('/',1)\n        if self.getChild(path[0]) is None:\n            return []\n        if len(path) > 1:\n            return self.__root.childrenAtPath(path[1])\n        else:\n            return [self.__root,]", "response": "Get a list of children at the end of a path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a list of children by name and namespace.", "response": "def getChildren(self, name=None, ns=None):\n        \"\"\"\n        Get a list of children by (optional) name and/or (optional) namespace.\n        @param name: The name of a child element (may contain prefix).\n        @type name: basestring\n        @param ns: An optional namespace used to match the child.\n        @type ns: (I{prefix}, I{name})\n        @return: The list of matching children.\n        @rtype: [L{Element},...]\n        \"\"\"\n        if name is None:\n            matched = self.__root\n        else:\n            matched = self.getChild(name, ns)\n        if matched is None:\n            return []\n        else:\n            return [matched,]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a string representation of this XML document.", "response": "def plain(self):\n        \"\"\"\n        Get a string representation of this XML document.\n        @return: A I{plain} string.\n        @rtype: basestring\n        \"\"\"\n        s = []\n        s.append(self.DECL)\n        root = self.root()\n        if root is not None:\n            s.append(root.plain())\n        return ''.join(s)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge(self):\n        if self.children:\n            schema = self.children[0]\n            for s in self.children[1:]:\n                schema.merge(s)\n            return schema", "response": "Merge contained schemas into one."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mktns(self):\n        tns = self.root.get(\"targetNamespace\")\n        tns_prefix = None\n        if tns is not None:\n            tns_prefix = self.root.findPrefix(tns)\n        return tns_prefix, tns", "response": "Make the schema s target namespace."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nopen all contained L { sxbasic. Import } children to import all of their referenced schemas.", "response": "def open_imports(self, options, loaded_schemata):\n        \"\"\"\n        Instruct all contained L{sxbasic.Import} children to import all of\n        their referenced schemas. The imported schema contents are I{merged}\n        in.\n\n        @param options: An options dictionary.\n        @type options: L{options.Options}\n        @param loaded_schemata: Already loaded schemata cache (URL --> Schema).\n        @type loaded_schemata: dict\n\n        \"\"\"\n        for imp in self.imports:\n            imported = imp.open(options, loaded_schemata)\n            if imported is None:\n                continue\n            imported.open_imports(options, loaded_schemata)\n            log.debug(\"imported:\\n%s\", imported)\n            self.merge(imported)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninstruct all children to perform dereferencing.", "response": "def dereference(self):\n        \"\"\"Instruct all children to perform dereferencing.\"\"\"\n        all = []\n        indexes = {}\n        for child in self.children:\n            child.content(all)\n        dependencies = {}\n        for x in all:\n            x.qualify()\n            midx, deps = x.dependencies()\n            dependencies[x] = deps\n            indexes[x] = midx\n        for x, deps in dependency_sort(dependencies):\n            midx = indexes.get(x)\n            if midx is None:\n                continue\n            d = deps[midx]\n            log.debug(\"(%s) merging %s <== %s\", self.tns[1], Repr(x), Repr(d))\n            x.merge(d)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate and return a new schema object using the specified root and base URL.", "response": "def instance(self, root, baseurl, loaded_schemata, options):\n        \"\"\"\n        Create and return an new schema object using the specified I{root} and\n        I{URL}.\n\n        @param root: A schema root node.\n        @type root: L{sax.element.Element}\n        @param baseurl: A base URL.\n        @type baseurl: str\n        @param loaded_schemata: Already loaded schemata cache (URL --> Schema).\n        @type loaded_schemata: dict\n        @param options: An options dictionary.\n        @type options: L{options.Options}\n        @return: The newly created schema object.\n        @rtype: L{Schema}\n        @note: This is only used by Import children.\n\n        \"\"\"\n        return Schema(root, baseurl, options, loaded_schemata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_sqs_policy(self, topic_name, topic_arn, topic_subs):\n        t = self.template\n\n        arn_endpoints = []\n        url_endpoints = []\n        for sub in topic_subs:\n            arn_endpoints.append(sub[\"Endpoint\"])\n            split_endpoint = sub[\"Endpoint\"].split(\":\")\n            queue_url = \"https://%s.%s.amazonaws.com/%s/%s\" % (\n                split_endpoint[2],  # literally \"sqs\"\n                split_endpoint[3],  # AWS region\n                split_endpoint[4],  # AWS ID\n                split_endpoint[5],  # Queue name\n            )\n            url_endpoints.append(queue_url)\n\n        policy_doc = queue_policy(topic_arn, arn_endpoints)\n\n        t.add_resource(\n            sqs.QueuePolicy(\n                topic_name + \"SubPolicy\",\n                PolicyDocument=policy_doc,\n                Queues=url_endpoints,\n            )\n        )", "response": "This method creates the SQS policy needed for an SNS subscription. It creates the SQS policy needed for an SNS queue."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_topic(self, topic_name, topic_config):\n        topic_subs = []\n        t = self.template\n\n        if \"Subscription\" in topic_config:\n            topic_subs = topic_config[\"Subscription\"]\n\n        t.add_resource(\n            sns.Topic.from_dict(\n                topic_name,\n                topic_config\n            )\n        )\n\n        topic_arn = Ref(topic_name)\n\n        t.add_output(\n            Output(topic_name + \"Name\", Value=GetAtt(topic_name, \"TopicName\"))\n        )\n        t.add_output(Output(topic_name + \"Arn\", Value=topic_arn))\n\n        sqs_subs = [sub for sub in topic_subs if sub[\"Protocol\"] == \"sqs\"]\n        if sqs_subs:\n            self.create_sqs_policy(topic_name, topic_arn, sqs_subs)", "response": "Creates the SNS topic along with any subscriptions requested."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_stream_action_type(stream_arn):\n\n    stream_type_map = {\n        \"kinesis\": awacs.kinesis.Action,\n        \"dynamodb\": awacs.dynamodb.Action,\n    }\n\n    stream_type = stream_arn.split(\":\")[2]\n    try:\n        return stream_type_map[stream_type]\n    except KeyError:\n        raise ValueError(\n            \"Invalid stream type '%s' in arn '%s'\" % (stream_type, stream_arn)\n        )", "response": "Returns the awacs Action for a given stream type"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stream_reader_statements(stream_arn):\n    action_type = get_stream_action_type(stream_arn)\n    arn_parts = stream_arn.split(\"/\")\n    # Cut off the last bit and replace it with a wildcard\n    wildcard_arn_parts = arn_parts[:-1]\n    wildcard_arn_parts.append(\"*\")\n    wildcard_arn = \"/\".join(wildcard_arn_parts)\n\n    return [\n        Statement(\n            Effect=Allow,\n            Resource=[stream_arn],\n            Action=[\n                action_type(\"DescribeStream\"),\n                action_type(\"GetRecords\"),\n                action_type(\"GetShardIterator\"),\n            ]\n        ),\n        Statement(\n            Effect=Allow,\n            Resource=[wildcard_arn],\n            Action=[action_type(\"ListStreams\")]\n        )\n    ]", "response": "Returns a list of statements to allow Lambda to read from a stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd statements to the policy.", "response": "def add_policy_statements(self, statements):\n        \"\"\"Adds statements to the policy.\n\n        Args:\n            statements (:class:`awacs.aws.Statement` or list): Either a single\n                Statment, or a list of statements.\n        \"\"\"\n        if isinstance(statements, Statement):\n            statements = [statements]\n        self._policy_statements.extend(statements)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_policy_statements(self):\n        statements = self._policy_statements\n        statements.extend(\n            lambda_basic_execution_statements(\n                self.function.Ref()\n            )\n        )\n        extended_statements = self.extended_policy_statements()\n        if extended_statements:\n            statements.extend(extended_statements)\n        return statements", "response": "Generates the policy statements for the function used by the function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef snake_to_camel_case(name):\n    name = name.replace(\"-\", \"_\")\n    return \"\".join(word.capitalize() for word in name.split(\"_\"))", "response": "Convert a snake_case string to a CamelCase string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef kms_key_policy():\n\n    statements = []\n    statements.extend(kms_key_root_statements())\n\n    return Policy(\n        Version=\"2012-10-17\",\n        Id=\"root-account-access\",\n        Statement=statements\n    )", "response": "Returns a new policy that can be used to access a KMS Key."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_properties(properties, allowed_properties, resource):\n    for key in properties.keys():\n        if key not in allowed_properties:\n            raise ValueError(\n                \"%s is not a valid property of %s\" % (key, resource)\n            )", "response": "Checks the list of properties in the properties variable against the allowed_properties variable."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmerges two sets of tags into a new troposphere object.", "response": "def merge_tags(left, right, factory=Tags):\n    \"\"\"\n    Merge two sets of tags into a new troposphere object\n\n    Args:\n        left (Union[dict, troposphere.Tags]): dictionary or Tags object to be\n            merged with lower priority\n        right (Union[dict, troposphere.Tags]): dictionary or Tags object to be\n            merged with higher priority\n        factory (type): Type of object to create. Defaults to the troposphere\n            Tags class.\n    \"\"\"\n\n    if isinstance(left, Mapping):\n        tags = dict(left)\n    elif hasattr(left, 'tags'):\n        tags = _tags_to_dict(left.tags)\n    else:\n        tags = _tags_to_dict(left)\n\n    if isinstance(right, Mapping):\n        tags.update(right)\n    elif hasattr(left, 'tags'):\n        tags.update(_tags_to_dict(right.tags))\n    else:\n        tags.update(_tags_to_dict(right))\n\n    return factory(**tags)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccepting record_set Name and Type. Return MD5 sum of these values.", "response": "def get_record_set_md5(rs_name, rs_type):\n    \"\"\"Accept record_set Name and Type. Return MD5 sum of these values.\"\"\"\n    rs_name = rs_name.lower()\n    rs_type = rs_type.upper()\n    # Make A and CNAME records hash to same sum to support updates.\n    rs_type = \"ACNAME\" if rs_type in [\"A\", \"CNAME\"] else rs_type\n    return md5(rs_name + rs_type).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_hosted_zone_id_for_alias_target_if_missing(self, rs):\n        alias_target = getattr(rs, \"AliasTarget\", None)\n        if alias_target:\n            hosted_zone_id = getattr(alias_target, \"HostedZoneId\", None)\n            if not hosted_zone_id:\n                dns_name = alias_target.DNSName\n                if dns_name.endswith(CF_DOMAIN):\n                    alias_target.HostedZoneId = CLOUDFRONT_ZONE_ID\n                elif dns_name.endswith(ELB_DOMAIN):\n                    region = dns_name.split('.')[-5]\n                    alias_target.HostedZoneId = ELB_ZONE_IDS[region]\n                elif dns_name in S3_WEBSITE_ZONE_IDS:\n                    alias_target.HostedZoneId = S3_WEBSITE_ZONE_IDS[dns_name]\n                else:\n                    alias_target.HostedZoneId = self.hosted_zone_id\n        return rs", "response": "Add proper hosted zone id to record set alias target if missing."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_record_set(self, rs_dict):\n        record_set_md5 = get_record_set_md5(rs_dict[\"Name\"], rs_dict[\"Type\"])\n        rs = route53.RecordSetType.from_dict(record_set_md5, rs_dict)\n        rs = add_hosted_zone_id_if_missing(rs, self.hosted_zone_id)\n        rs = self.add_hosted_zone_id_for_alias_target_if_missing(rs)\n        return self.template.add_resource(rs)", "response": "Accept a record_set dict. Return a Troposphere record_set object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_record_set_group(self, name, g_dict):\n        rs = route53.RecordSetGroup.from_dict(name, g_dict)\n        rs = add_hosted_zone_id_if_missing(rs, self.hosted_zone_id)\n        rs = self.add_hosted_zone_id_for_alias_target_if_missing(rs)\n        return self.template.add_resource(rs)", "response": "Accept a record_set dict. Return a Troposphere record_set object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccepting list of record_set dicts. returns list of record_set objects.", "response": "def create_record_sets(self, record_set_dicts):\n        \"\"\"Accept list of record_set dicts.\n        Return list of record_set objects.\"\"\"\n        record_set_objects = []\n        for record_set_dict in record_set_dicts:\n            # pop removes the 'Enabled' key and tests if True.\n            if record_set_dict.pop('Enabled', True):\n                record_set_objects.append(\n                    self.create_record_set(record_set_dict)\n                )\n        return record_set_objects"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_record_set_groups(self, record_set_group_dicts):\n        record_set_groups = []\n        for name, group in record_set_group_dicts.iteritems():\n            # pop removes the 'Enabled' key and tests if True.\n            if group.pop('Enabled', True):\n                record_set_groups.append(\n                    self.create_record_set_group(name, group)\n                )\n        return record_set_groups", "response": "Accept list of record_set_group dicts.\n        Return list of record_set_group objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of statements that can be used to create a read - only policy an s3 bucket.", "response": "def read_only_s3_bucket_policy_statements(buckets, folder=\"*\"):\n    \"\"\" Read only policy an s3 bucket. \"\"\"\n    list_buckets = [s3_arn(b) for b in buckets]\n    object_buckets = [s3_objects_arn(b, folder) for b in buckets]\n\n    bucket_resources = list_buckets + object_buckets\n\n    return [\n        Statement(\n            Effect=Allow,\n            Resource=[s3_arn(\"*\")],\n            Action=[s3.ListAllMyBuckets]\n        ),\n        Statement(\n            Effect=Allow,\n            Resource=bucket_resources,\n            Action=[Action('s3', 'Get*'), Action('s3', 'List*')]\n        )\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a policy that can be used to access a static website for a given bucket.", "response": "def static_website_bucket_policy(bucket):\n    \"\"\"\n    Attach this policy directly to an S3 bucket to make it a static website.\n    This policy grants read access to **all unauthenticated** users.\n    \"\"\"\n    return Policy(\n        Statement=[\n            Statement(\n                Effect=Allow,\n                Principal=Principal(\"*\"),\n                Action=[s3.GetObject],\n                Resource=[s3_objects_arn(bucket)],\n            )\n        ]\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lambda_vpc_execution_statements():\n    return [\n        Statement(\n            Effect=Allow,\n            Resource=['*'],\n            Action=[\n                ec2.CreateNetworkInterface,\n                ec2.DescribeNetworkInterfaces,\n                ec2.DeleteNetworkInterface,\n            ]\n        )\n    ]", "response": "Return a list of Lambda execution statements that can be used to create and delete EC2 ENIs for VPC support."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dynamodb_autoscaling_policy(tables):\n    return Policy(\n        Statement=[\n            Statement(\n                Effect=Allow,\n                Resource=dynamodb_arns(tables),\n                Action=[\n                    dynamodb.DescribeTable,\n                    dynamodb.UpdateTable,\n                ]\n            ),\n            Statement(\n                Effect=Allow,\n                Resource=['*'],\n                Action=[\n                    cloudwatch.PutMetricAlarm,\n                    cloudwatch.DescribeAlarms,\n                    cloudwatch.GetMetricStatistics,\n                    cloudwatch.SetAlarmState,\n                    cloudwatch.DeleteAlarms,\n                ]\n            ),\n        ]\n    )", "response": "Policy to allow AutoScaling a list of DynamoDB tables."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert HEALPix indices to longitudes and latitudes.", "response": "def healpix_to_lonlat(self, healpix_index, dx=None, dy=None):\n        \"\"\"\n        Convert HEALPix indices (optionally with offsets) to longitudes/latitudes\n\n        Parameters\n        ----------\n        healpix_index : `~numpy.ndarray`\n            1-D array of HEALPix indices\n        dx, dy : `~numpy.ndarray`, optional\n            1-D arrays of offsets inside the HEALPix pixel, which must be in\n            the range [0:1] (0.5 is the center of the HEALPix pixels). If not\n            specified, the position at the center of the pixel is used.\n\n        Returns\n        -------\n        lon : :class:`~astropy.coordinates.Longitude`\n            The longitude values\n        lat : :class:`~astropy.coordinates.Latitude`\n            The latitude values\n        \"\"\"\n        return healpix_to_lonlat(healpix_index, self.nside, dx=dx, dy=dy, order=self.order)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting lon lat values to HEALPix indices.", "response": "def lonlat_to_healpix(self, lon, lat, return_offsets=False):\n        \"\"\"\n        Convert longitudes/latitudes to HEALPix indices (optionally with offsets)\n\n        Parameters\n        ----------\n        lon, lat : :class:`~astropy.units.Quantity`\n            The longitude and latitude values as :class:`~astropy.units.Quantity` instances\n            with angle units.\n        return_offsets : bool\n            If `True`, the returned values are the HEALPix pixel as well as\n            ``dx`` and ``dy``, the fractional positions inside the pixel. If\n            `False` (the default), only the HEALPix pixel is returned.\n\n        Returns\n        -------\n        healpix_index : `~numpy.ndarray`\n            1-D array of HEALPix indices\n        dx, dy : `~numpy.ndarray`\n            1-D arrays of offsets inside the HEALPix pixel in the range [0:1] (0.5\n            is the center of the HEALPix pixels). This is returned if\n            ``return_offsets`` is `True`.\n        \"\"\"\n        return lonlat_to_healpix(lon, lat, self.nside,\n                                 return_offsets=return_offsets, order=self.order)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the four neighbours for each ( lon lat ) position and the weight associated with each one for bilinear interpolation.", "response": "def bilinear_interpolation_weights(self, lon, lat):\n        \"\"\"\n        Get the four neighbours for each (lon, lat) position and the weight\n        associated with each one for bilinear interpolation.\n\n        Parameters\n        ----------\n        lon, lat : :class:`~astropy.units.Quantity`\n            The longitude and latitude values as\n            :class:`~astropy.units.Quantity` instances with angle units.\n\n        Returns\n        -------\n        indices : `~numpy.ndarray`\n            2-D array with shape (4, N) giving the four indices to use for the\n            interpolation\n        weights : `~numpy.ndarray`\n            2-D array with shape (4, N) giving the four weights to use for the\n            interpolation\n        \"\"\"\n        return bilinear_interpolation_weights(lon, lat, self.nside, order=self.order)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef interpolate_bilinear_lonlat(self, lon, lat, values):\n        if len(values) != self.npix:\n            raise ValueError('values must be an array of length {0} (got {1})'.format(self.npix, len(values)))\n        return interpolate_bilinear_lonlat(lon, lat, values, order=self.order)", "response": "Interpolate values at specific longitudes and latitudes using bilinear interpolation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsearch for HEALPix pixels within a given radius of a longitude and latitude pair.", "response": "def cone_search_lonlat(self, lon, lat, radius):\n        \"\"\"\n        Find all the HEALPix pixels within a given radius of a longitude/latitude.\n\n        Note that this returns all pixels that overlap, including partially, with\n        the search cone. This function can only be used for a single lon/lat pair at\n        a time, since different calls to the function may result in a different\n        number of matches.\n\n        Parameters\n        ----------\n        lon, lat : :class:`~astropy.units.Quantity`\n            The longitude and latitude to search around\n        radius : :class:`~astropy.units.Quantity`\n            The search radius\n\n        Returns\n        -------\n        healpix_index : `~numpy.ndarray`\n            1-D array with all the matching HEALPix pixel indices.\n        \"\"\"\n        if not lon.isscalar or not lat.isscalar or not radius.isscalar:\n            raise ValueError('The longitude, latitude and radius must be '\n                             'scalar Quantity objects')\n        return healpix_cone_search(lon, lat, radius, self.nside, order=self.order)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the longitude and latitude of the edges of each HEALPix pixels.", "response": "def boundaries_lonlat(self, healpix_index, step):\n        \"\"\"\n        Return the longitude and latitude of the edges of HEALPix pixels\n\n        This returns the longitude and latitude of points along the edge of each\n        HEALPIX pixel. The number of points returned for each pixel is ``4 * step``,\n        so setting ``step`` to 1 returns just the corners.\n\n        Parameters\n        ----------\n        healpix_index : `~numpy.ndarray`\n            1-D array of HEALPix pixels\n        step : int\n            The number of steps to take along each edge.\n\n        Returns\n        -------\n        lon, lat : :class:`~astropy.units.Quantity`\n            The longitude and latitude, as 2-D arrays where the first dimension is\n            the same as the ``healpix_index`` input, and the second dimension has\n            size ``4 * step``.\n        \"\"\"\n        return boundaries_lonlat(healpix_index, step, self.nside, order=self.order)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef neighbours(self, healpix_index):\n        return neighbours(healpix_index, self.nside, order=self.order)", "response": "Return the array of neighbours of a HEALPix pixel."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef healpix_to_skycoord(self, healpix_index, dx=None, dy=None):\n        if self.frame is None:\n            raise NoFrameError(\"healpix_to_skycoord\")\n        lon, lat = self.healpix_to_lonlat(healpix_index, dx=dx, dy=dy)\n        representation = UnitSphericalRepresentation(lon, lat, copy=False)\n        return SkyCoord(self.frame.realize_frame(representation))", "response": "Convert HEALPix indices to celestial coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a SkyCoord object to a HEALPix pixel array.", "response": "def skycoord_to_healpix(self, skycoord, return_offsets=False):\n        \"\"\"\n        Convert celestial coordinates to HEALPix indices (optionally with offsets).\n\n        Note that this method requires that a celestial frame was specified when\n        initializing HEALPix. If you don't know or need the celestial frame, you\n        can instead use :meth:`~astropy_healpix.HEALPix.lonlat_to_healpix`.\n\n        Parameters\n        ----------\n        skycoord : :class:`~astropy.coordinates.SkyCoord`\n            The celestial coordinates to convert\n        return_offsets : bool\n            If `True`, the returned values are the HEALPix pixel as well as\n            ``dx`` and ``dy``, the fractional positions inside the pixel. If\n            `False` (the default), only the HEALPix pixel is returned.\n\n        Returns\n        -------\n        healpix_index : `~numpy.ndarray`\n            1-D array of HEALPix indices\n        dx, dy : `~numpy.ndarray`\n            1-D arrays of offsets inside the HEALPix pixel in the range [0:1] (0.5\n            is the center of the HEALPix pixels). This is returned if\n            ``return_offsets`` is `True`.\n        \"\"\"\n        if self.frame is None:\n            raise NoFrameError(\"skycoord_to_healpix\")\n        skycoord = skycoord.transform_to(self.frame)\n        representation = skycoord.represent_as(UnitSphericalRepresentation)\n        lon, lat = representation.lon, representation.lat\n        return self.lonlat_to_healpix(lon, lat, return_offsets=return_offsets)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef interpolate_bilinear_skycoord(self, skycoord, values):\n        if self.frame is None:\n            raise NoFrameError(\"interpolate_bilinear_skycoord\")\n        skycoord = skycoord.transform_to(self.frame)\n        representation = skycoord.represent_as(UnitSphericalRepresentation)\n        lon, lat = representation.lon, representation.lat\n        return self.interpolate_bilinear_lonlat(lon, lat, values)", "response": "Interpolate values at specific celestial coordinates using bilinear interpolation."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cone_search_skycoord(self, skycoord, radius):\n        if self.frame is None:\n            raise NoFrameError(\"cone_search_skycoord\")\n        skycoord = skycoord.transform_to(self.frame)\n        representation = skycoord.represent_as(UnitSphericalRepresentation)\n        lon, lat = representation.lon, representation.lat\n        return self.cone_search_lonlat(lon, lat, radius)", "response": "Find all HEALPix pixels within a given radius of a given celestial position."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the celestial coordinates of the edges of each HEALPix pixel.", "response": "def boundaries_skycoord(self, healpix_index, step):\n        \"\"\"\n        Return the celestial coordinates of the edges of HEALPix pixels\n\n        This returns the celestial coordinates of points along the edge of each\n        HEALPIX pixel. The number of points returned for each pixel is ``4 * step``,\n        so setting ``step`` to 1 returns just the corners.\n\n        This method requires that a celestial frame was specified when\n        initializing HEALPix.  If you don't know or need the celestial frame,\n        you can instead use :meth:`~astropy_healpix.HEALPix.boundaries_lonlat`.\n\n        Parameters\n        ----------\n        healpix_index : `~numpy.ndarray`\n            1-D array of HEALPix pixels\n        step : int\n            The number of steps to take along each edge.\n\n        Returns\n        -------\n        skycoord : :class:`~astropy.coordinates.SkyCoord`\n            The celestial coordinates of the HEALPix pixel boundaries\n        \"\"\"\n        if self.frame is None:\n            raise NoFrameError(\"boundaries_skycoord\")\n        lon, lat = self.boundaries_lonlat(healpix_index, step)\n        representation = UnitSphericalRepresentation(lon, lat, copy=False)\n        return SkyCoord(self.frame.realize_frame(representation))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef level_to_nside(level):\n    level = np.asarray(level, dtype=np.int64)\n\n    _validate_level(level)\n    return 2 ** level", "response": "This function returns the number of pixels on the side of the HEALPix tiles at a given level."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nside_to_level(nside):\n    nside = np.asarray(nside, dtype=np.int64)\n\n    _validate_nside(nside)\n    return np.log2(nside).astype(np.int64)", "response": "Find the HEALPix level for a given HEALPix tile."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uniq_to_level_ipix(uniq):\n    uniq = np.asarray(uniq, dtype=np.int64)\n\n    level = (np.log2(uniq//4)) // 2\n    level = level.astype(np.int64)\n    _validate_level(level)\n\n    ipix = uniq - (1 << 2*(level + 1))\n    _validate_npix(level, ipix)\n\n    return level, ipix", "response": "Convert a HEALPix cell uniq number to its level and index equivalent."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef level_ipix_to_uniq(level, ipix):\n    level = np.asarray(level, dtype=np.int64)\n    ipix = np.asarray(ipix, dtype=np.int64)\n\n    _validate_level(level)\n    _validate_npix(level, ipix)\n\n    return ipix + (1 << 2*(level + 1))", "response": "Convert a level and HEALPix index into a uniq number representing the cell."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nside_to_pixel_area(nside):\n    nside = np.asanyarray(nside, dtype=np.int64)\n    _validate_nside(nside)\n    npix = 12 * nside * nside\n    pixel_area = 4 * math.pi / npix * u.sr\n    return pixel_area", "response": "Find the area of HEALPix pixels given the pixel dimensions of one of the 12 top - level HEALPix tiles."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds the resolution of HEALPix pixels given the pixel dimensions of one of the HEALPix tiles.", "response": "def nside_to_pixel_resolution(nside):\n    \"\"\"\n    Find the resolution of HEALPix pixels given the pixel dimensions of one of\n    the 12 'top-level' HEALPix tiles.\n\n    Parameters\n    ----------\n    nside : int\n        The number of pixels on the side of one of the 12 'top-level' HEALPix tiles.\n\n    Returns\n    -------\n    resolution : :class:`~astropy.units.Quantity`\n        The resolution of the HEALPix pixels\n\n    See also\n    --------\n    pixel_resolution_to_nside\n    \"\"\"\n    nside = np.asanyarray(nside, dtype=np.int64)\n    _validate_nside(nside)\n    return (nside_to_pixel_area(nside) ** 0.5).to(u.arcmin)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the HEALPix tiles on the given angular resolution.", "response": "def pixel_resolution_to_nside(resolution, round='nearest'):\n    \"\"\"Find closest HEALPix nside for a given angular resolution.\n\n    This function is the inverse of `nside_to_pixel_resolution`,\n    for the default rounding scheme of ``round='nearest'``.\n\n    If you choose ``round='up'``, you'll get HEALPix pixels that\n    have at least the requested resolution (usually a bit better\n    due to rounding).\n\n    Pixel resolution is defined as square root of pixel area.\n\n    Parameters\n    ----------\n    resolution : `~astropy.units.Quantity`\n        Angular resolution\n    round : {'up', 'nearest', 'down'}\n        Which way to round\n\n    Returns\n    -------\n    nside : int\n        The number of pixels on the side of one of the 12 'top-level' HEALPix tiles.\n        Always a power of 2.\n\n    Examples\n    --------\n    >>> from astropy import units as u\n    >>> from astropy_healpix import pixel_resolution_to_nside\n    >>> pixel_resolution_to_nside(13 * u.arcmin)\n    256\n    >>> pixel_resolution_to_nside(13 * u.arcmin, round='up')\n    512\n    \"\"\"\n    resolution = resolution.to(u.rad).value\n    pixel_area = resolution * resolution\n    npix = 4 * math.pi / pixel_area\n    nside = np.sqrt(npix / 12)\n\n    # Now we have to round to the closest ``nside``\n    # Since ``nside`` must be a power of two,\n    # we first compute the corresponding ``level = log2(nside)`\n    # round the level and then go back to nside\n    level = np.log2(nside)\n\n    if round == 'up':\n        level = np.ceil(level)\n    elif round == 'nearest':\n        level = np.round(level)\n    elif round == 'down':\n        level = np.floor(level)\n    else:\n        raise ValueError('Invalid value for round: {!r}'.format(round))\n\n    # For very low requested resolution (i.e. large angle values), we\n    # return ``level=0``, i.e. ``nside=1``, i.e. the lowest resolution\n    # that exists with HEALPix\n    level = np.clip(level.astype(int), 0, None)\n\n    return level_to_nside(level)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nside_to_npix(nside):\n    nside = np.asanyarray(nside, dtype=np.int64)\n    _validate_nside(nside)\n    return 12 * nside ** 2", "response": "Find the number of pixels corresponding to a HEALPix resolution."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef npix_to_nside(npix):\n\n    npix = np.asanyarray(npix, dtype=np.int64)\n\n    if not np.all(npix % 12 == 0):\n        raise ValueError('Number of pixels must be divisible by 12')\n\n    square_root = np.sqrt(npix / 12)\n    if not np.all(square_root ** 2 == npix / 12):\n        raise ValueError('Number of pixels is not of the form 12 * nside ** 2')\n\n    return np.round(square_root).astype(int)", "response": "This function returns the number of pixels on the top of a HEALPix map given a total number of pixels."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef healpix_to_lonlat(healpix_index, nside, dx=None, dy=None, order='ring'):\n\n    _validate_nside(nside)\n\n    if _validate_order(order) == 'ring':\n        func = _core.healpix_ring_to_lonlat\n    else:  # _validate_order(order) == 'nested'\n        func = _core.healpix_nested_to_lonlat\n\n    if dx is None:\n        dx = 0.5\n    else:\n        _validate_offset('x', dx)\n    if dy is None:\n        dy = 0.5\n    else:\n        _validate_offset('y', dy)\n\n    nside = np.asarray(nside, dtype=np.intc)\n\n    lon, lat = func(healpix_index, nside, dx, dy)\n\n    lon = Longitude(lon, unit=u.rad, copy=False)\n    lat = Latitude(lat, unit=u.rad, copy=False)\n\n    return lon, lat", "response": "Convert HEALPix indices to longitudes and latitudes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lonlat_to_healpix(lon, lat, nside, return_offsets=False, order='ring'):\n\n    if _validate_order(order) == 'ring':\n        func = _core.lonlat_to_healpix_ring\n    else:  # _validate_order(order) == 'nested'\n        func = _core.lonlat_to_healpix_nested\n\n    nside = np.asarray(nside, dtype=np.intc)\n\n    lon = lon.to_value(u.rad)\n    lat = lat.to_value(u.rad)\n\n    healpix_index, dx, dy = func(lon, lat, nside)\n\n    if return_offsets:\n        return healpix_index, dx, dy\n    else:\n        return healpix_index", "response": "Convert a longitude and latitude values into HEALPix indices."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nested_to_ring(nested_index, nside):\n\n    nside = np.asarray(nside, dtype=np.intc)\n\n    return _core.nested_to_ring(nested_index, nside)", "response": "Convert a HEALPix nested index to a HEALPix ring index."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ring_to_nested(ring_index, nside):\n\n    nside = np.asarray(nside, dtype=np.intc)\n\n    return _core.ring_to_nested(ring_index, nside)", "response": "Convert a HEALPix ring index to a HEALPix nested index."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bilinear_interpolation_weights(lon, lat, nside, order='ring'):\n\n    lon = lon.to_value(u.rad)\n    lat = lat.to_value(u.rad)\n\n    _validate_nside(nside)\n\n    nside = np.asarray(nside, dtype=np.intc)\n\n    result = _core.bilinear_interpolation_weights(lon, lat, nside)\n    indices = np.stack(result[:4])\n    weights = np.stack(result[4:])\n\n    if _validate_order(order) == 'nested':\n        indices = ring_to_nested(indices, nside)\n\n    return indices, weights", "response": "Get the four neighbours for each longitude and latitude of a HEALPix tile and the weight\n    associated with each one for bilinear interpolation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef interpolate_bilinear_lonlat(lon, lat, values, order='ring'):\n    nside = npix_to_nside(values.shape[0])\n    indices, weights = bilinear_interpolation_weights(lon, lat, nside, order=order)\n    values = values[indices]\n    # At this point values has shape (N, M) where both N and M might be several\n    # dimensions, and weights has shape (N,), so we need to transpose in order\n    # to benefit from broadcasting, then transpose back so that the dimension\n    # with length 4 is at the start again, ready for summing.\n    result = (values.T * weights.T).T\n    return result.sum(axis=0)", "response": "Interpolate values at specific longitudes and latitudes using bilinear interpolation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef neighbours(healpix_index, nside, order='ring'):\n\n    _validate_nside(nside)\n\n    nside = np.asarray(nside, dtype=np.intc)\n\n    if _validate_order(order) == 'ring':\n        func = _core.neighbours_ring\n    else:  # _validate_order(order) == 'nested'\n        func = _core.neighbours_nested\n\n    return np.stack(func(healpix_index, nside))", "response": "Find all the HEALPix pixels that are the neighbours of a HEALPix pixel."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch for HEALPix pixels within a given radius of a longitude and latitude pair.", "response": "def healpix_cone_search(lon, lat, radius, nside, order='ring'):\n    \"\"\"\n    Find all the HEALPix pixels within a given radius of a longitude/latitude.\n\n    Note that this returns all pixels that overlap, including partially, with\n    the search cone. This function can only be used for a single lon/lat pair at\n    a time, since different calls to the function may result in a different\n    number of matches.\n\n    Parameters\n    ----------\n    lon, lat : :class:`~astropy.units.Quantity`\n        The longitude and latitude to search around\n    radius : :class:`~astropy.units.Quantity`\n        The search radius\n    nside : int\n        Number of pixels along the side of each of the 12 top-level HEALPix tiles\n    order : { 'nested' | 'ring' }\n        Order of HEALPix pixels\n\n    Returns\n    -------\n    healpix_index : `~numpy.ndarray`\n        1-D array with all the matching HEALPix pixel indices.\n    \"\"\"\n\n    lon = lon.to_value(u.deg)\n    lat = lat.to_value(u.deg)\n    radius = radius.to_value(u.deg)\n\n    _validate_nside(nside)\n    order = _validate_order(order)\n\n    return _core.healpix_cone_search(lon, lat, radius, nside, order)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef boundaries_lonlat(healpix_index, step, nside, order='ring'):\n\n    healpix_index = np.asarray(healpix_index, dtype=np.int64)\n    step = int(step)\n\n    if step < 1:\n        raise ValueError('step must be at least 1')\n\n    # PERF: this could be optimized by writing a Cython routine to do this to\n    # avoid allocating temporary arrays\n\n    frac = np.linspace(0., 1., step + 1)[:-1]\n    dx = np.hstack([1 - frac, np.repeat(0, step), frac, np.repeat(1, step)])\n    dy = np.hstack([np.repeat(1, step), 1 - frac, np.repeat(0, step), frac])\n\n    healpix_index, dx, dy = np.broadcast_arrays(healpix_index.reshape(-1, 1), dx, dy)\n\n    lon, lat = healpix_to_lonlat(healpix_index.ravel(), nside, dx.ravel(), dy.ravel(), order=order)\n\n    lon = lon.reshape(-1, 4 * step)\n    lat = lat.reshape(-1, 4 * step)\n\n    return lon, lat", "response": "Returns the longitude and latitude of the edges of each HEALPix pixel in the order specified by order."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndrop - in replacement for healpy ~healpy. pixelfunc. nside2resol.", "response": "def nside2resol(nside, arcmin=False):\n    \"\"\"Drop-in replacement for healpy `~healpy.pixelfunc.nside2resol`.\"\"\"\n    resolution = nside_to_pixel_resolution(nside)\n    if arcmin:\n        return resolution.to(u.arcmin).value\n    else:\n        return resolution.to(u.rad).value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndrops - in replacement for healpy ~healpy. pixelfunc. nside2pixarea.", "response": "def nside2pixarea(nside, degrees=False):\n    \"\"\"Drop-in replacement for healpy `~healpy.pixelfunc.nside2pixarea`.\"\"\"\n    area = nside_to_pixel_area(nside)\n    if degrees:\n        return area.to(u.deg ** 2).value\n    else:\n        return area.to(u.sr).value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pix2ang(nside, ipix, nest=False, lonlat=False):\n    lon, lat = healpix_to_lonlat(ipix, nside, order='nested' if nest else 'ring')\n    return _lonlat_to_healpy(lon, lat, lonlat=lonlat)", "response": "Convert pixel indices into a healpy. HealPix object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ang2pix(nside, theta, phi, nest=False, lonlat=False):\n    lon, lat = _healpy_to_lonlat(theta, phi, lonlat=lonlat)\n    return lonlat_to_healpix(lon, lat, nside, order='nested' if nest else 'ring')", "response": "Convert an angle in HEALPix pixels to HEALPix pixels."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pix2vec(nside, ipix, nest=False):\n    lon, lat = healpix_to_lonlat(ipix, nside, order='nested' if nest else 'ring')\n    return ang2vec(*_lonlat_to_healpy(lon, lat))", "response": "Drop - in replacement for healpy ~healpy. pixelfunc. pix2vec."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef vec2pix(nside, x, y, z, nest=False):\n    theta, phi = vec2ang(np.transpose([x, y, z]))\n    # hp.vec2ang() returns raveled arrays, which are 1D.\n    if np.isscalar(x):\n        theta = theta.item()\n        phi = phi.item()\n    else:\n        shape = np.shape(x)\n        theta = theta.reshape(shape)\n        phi = phi.reshape(shape)\n    lon, lat = _healpy_to_lonlat(theta, phi)\n    return lonlat_to_healpix(lon, lat, nside, order='nested' if nest else 'ring')", "response": "Convert a vector of lon lat coordinates to HEALPix pixels."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndrop - in replacement for healpy. pixelfunc. nest2ring.", "response": "def nest2ring(nside, ipix):\n    \"\"\"Drop-in replacement for healpy `~healpy.pixelfunc.nest2ring`.\"\"\"\n    ipix = np.atleast_1d(ipix).astype(np.int64, copy=False)\n    return nested_to_ring(ipix, nside)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndropping - in replacement for healpy. pixelfunc. ring2nest.", "response": "def ring2nest(nside, ipix):\n    \"\"\"Drop-in replacement for healpy `~healpy.pixelfunc.ring2nest`.\"\"\"\n    ipix = np.atleast_1d(ipix).astype(np.int64, copy=False)\n    return ring_to_nested(ipix, nside)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndrop - in replacement for healpy ~healpy. boundaries.", "response": "def boundaries(nside, pix, step=1, nest=False):\n    \"\"\"Drop-in replacement for healpy `~healpy.boundaries`.\"\"\"\n    pix = np.asarray(pix)\n    if pix.ndim > 1:\n        # For consistency with healpy we only support scalars or 1D arrays\n        raise ValueError(\"Array has to be one dimensional\")\n    lon, lat = boundaries_lonlat(pix, step, nside, order='nested' if nest else 'ring')\n    rep_sph = UnitSphericalRepresentation(lon, lat)\n    rep_car = rep_sph.to_cartesian().xyz.value.swapaxes(0, 1)\n    if rep_car.shape[0] == 1:\n        return rep_car[0]\n    else:\n        return rep_car"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vec2ang(vectors, lonlat=False):\n    x, y, z = vectors.transpose()\n    rep_car = CartesianRepresentation(x, y, z)\n    rep_sph = rep_car.represent_as(UnitSphericalRepresentation)\n    return _lonlat_to_healpy(rep_sph.lon.ravel(), rep_sph.lat.ravel(), lonlat=lonlat)", "response": "Drop - in replacement for healpy ~healpy. pixelfunc. vec2ang."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndropping - in replacement for healpy ~healpy. pixelfunc. ang2vec.", "response": "def ang2vec(theta, phi, lonlat=False):\n    \"\"\"Drop-in replacement for healpy `~healpy.pixelfunc.ang2vec`.\"\"\"\n    lon, lat = _healpy_to_lonlat(theta, phi, lonlat=lonlat)\n    rep_sph = UnitSphericalRepresentation(lon, lat)\n    rep_car = rep_sph.represent_as(CartesianRepresentation)\n    return rep_car.xyz.value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_interp_weights(nside, theta, phi=None, nest=False, lonlat=False):\n    # if phi is not given, theta is interpreted as pixel number\n    if phi is None:\n        theta, phi = pix2ang(nside, ipix=theta, nest=nest)\n\n    lon, lat = _healpy_to_lonlat(theta, phi, lonlat=lonlat)\n    return bilinear_interpolation_weights(lon, lat, nside, order='nested' if nest else 'ring')", "response": "Get the interpolated weights for a given HEALPix pixel."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_interp_val(m, theta, phi, nest=False, lonlat=False):\n    lon, lat = _healpy_to_lonlat(theta, phi, lonlat=lonlat)\n    return interpolate_bilinear_lonlat(lon, lat, m, order='nested' if nest else 'ring')", "response": "Get the value of a bilinear interpolation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning all benchmarks. Return results as a dict.", "response": "def bench_run(fast=False):\n    \"\"\"Run all benchmarks. Return results as a dict.\"\"\"\n    results = []\n\n    if fast:\n        SIZES = [10, 1e3, 1e5]\n    else:\n        SIZES = [10, 1e3, 1e6]\n\n    for nest in [True, False]:\n        for size in SIZES:\n            for nside in [1, 128]:\n                results.append(run_single('pix2ang', bench_pix2ang, fast=fast,\n                                          size=int(size), nside=nside, nest=nest))\n\n    for nest in [True, False]:\n        for size in SIZES:\n            for nside in [1, 128]:\n                results.append(run_single('ang2pix', bench_ang2pix, fast=fast,\n                                          size=int(size), nside=nside, nest=nest))\n\n    for size in SIZES:\n        for nside in [1, 128]:\n            results.append(run_single('nest2ring', bench_nest2ring, fast=fast,\n                                      size=int(size), nside=nside))\n\n    for size in SIZES:\n        for nside in [1, 128]:\n            results.append(run_single('ring2nest', bench_ring2nest, fast=fast,\n                                      size=int(size), nside=nside))\n\n    for nest in [True, False]:\n        for size in SIZES:\n            for nside in [1, 128]:\n                results.append(run_single('get_interp_weights', bench_get_interp_weights,\n                                          fast=fast, size=int(size),\n                                          nside=nside, nest=nest))\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bench_report(results):\n\n    table = Table(names=['function', 'nest', 'nside', 'size',\n                         'time_healpy', 'time_self', 'ratio'],\n                  dtype=['S20', bool, int, int, float, float, float], masked=True)\n    for row in results:\n        table.add_row(row)\n\n    table['time_self'].format = '10.7f'\n\n    if HEALPY_INSTALLED:\n        table['ratio'] = table['time_self'] / table['time_healpy']\n        table['time_healpy'].format = '10.7f'\n        table['ratio'].format = '7.2f'\n\n    table.pprint(max_lines=-1)", "response": "Print a report for given benchmark results to the console."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun all benchmarks and print report to the console.", "response": "def main(fast=False):\n    \"\"\"Run all benchmarks and print report to the console.\"\"\"\n    print('Running benchmarks...\\n')\n    results = bench_run(fast=fast)\n    bench_report(results)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cached(f):\n\n    cache = f.cache = {}\n\n    @functools.wraps(f)\n    def decorator(*args, **kwargs):\n        key = str(args) + str(kwargs)\n        if key not in cache:\n            cache[key] = f(*args, **kwargs)\n        return cache[key]\n    return decorator", "response": "A decorator for functions taking one or more arguments."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering a Swagger UI application.", "response": "def register_swaggerui_app(app, swagger_uri, api_url, page_title='Swagger UI', favicon_url=None, config=None, uri_prefix=\"\"):\n\n    \"\"\":type app: falcon.API\"\"\"\n\n    templates_folder = 'templates'\n    static_folder = 'dist'\n\n    default_config = {\n        'client_realm': 'null',\n        'client_id': 'null',\n        'client_secret': 'null',\n        'app_name': 'null',\n        'docExpansion': \"none\",\n        'jsonEditor': False,\n        'defaultModelRendering': 'schema',\n        'showRequestHeaders': False,\n        'supportedSubmitMethods': ['get', 'post', 'put', 'delete', 'patch'],\n    }\n\n    if config:\n        default_config.update(config)\n\n    default_context = {\n        'page_title': page_title,\n        'favicon_url': favicon_url,\n        'base_url': uri_prefix + swagger_uri,\n        'api_url': api_url,\n        'app_name': default_config.pop('app_name'),\n        'client_realm': default_config.pop('client_realm'),\n        'client_id': default_config.pop('client_id'),\n        'client_secret': default_config.pop('client_secret'),\n        # Rest are just serialized into json string\n        # for inclusion in the .js file\n        'config_json': json.dumps(default_config)\n    }\n\n    app.add_sink(\n        StaticSinkAdapter(static_folder),\n        r'%s/(?P<filepath>.*)\\Z' % swagger_uri,\n    )\n\n    app.add_route(\n        swagger_uri,\n        SwaggerUiResource(templates_folder, default_context)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_app(self, app):\n\n        self.app = app\n\n        self.dynamic_url = self.app.config.get('APIDOC_DYNAMIC_URL', self.dynamic_url)\n        self.allow_absolute_url = self.app.config.get('APIDOC_ALLOW_ABSOLUTE_URL', self.allow_absolute_url)\n\n        url = self.url_path\n\n        if not self.url_path.endswith('/'):\n            url += '/'\n\n        app.add_url_rule(url, 'docs', self.__send_static_file, strict_slashes=True)\n        app.add_url_rule(url + '<path:path>', 'docs', self.__send_static_file, strict_slashes=True)", "response": "Initializes the flask application."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __send_static_file(self, path=None):\n\n        if not path:\n            path = 'index.html'\n\n        file_name = join(self.folder_path, path)\n\n        # the api_project.js has the absolute url\n        # hard coded so we replace them by the current url.\n        if self.dynamic_url and path == 'api_project.js':\n            return self.__send_api_file(file_name)\n\n        if self.allow_absolute_url and path == 'main.js':\n            return self.__send_main_file(file_name)\n\n        # Any other apidoc file is treated as a normal static file\n        return self.app.send_static_file(file_name)", "response": "Send static files from the apidoc folder to the browser."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __send_api_file(self, file_name):\n\n        file_name = join(self.app.static_folder, file_name)\n\n        with codecs.open(file_name, 'r', 'utf-8') as file:\n            data = file.read()\n\n        # replaces the hard coded url by the current url.\n        api_project = self.__read_api_project()\n\n        old_url = api_project.get('url')\n\n        # replaces the project's url only if it is present in the file.\n        if old_url:\n            new_url = request.url_root.strip('/')\n            data = data.replace(old_url, new_url)\n\n        # creates a flask response to send\n        # the file to the browser\n\n        headers = Headers()\n        headers['Content-Length'] = getsize(file_name)\n\n        response = self.app.response_class(data,\n                                           mimetype=mimetypes.guess_type(file_name)[0],\n                                           headers=headers,\n                                           direct_passthrough=True)\n\n        response.last_modified = int(getmtime(file_name))\n\n        return response", "response": "Send apidoc files from the apidoc folder to the browser."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend the apidoc files from the apidoc folder to the browser.", "response": "def __send_main_file(self, file_name):\n        \"\"\"\n        Send apidoc files from the apidoc folder to the browser.\n        This method replaces all absolute urls in the file by\n        the current url.\n        :param file_name: the apidoc file.\n        \"\"\"\n\n        file_name = join(self.app.static_folder, file_name)\n\n        with codecs.open(file_name, 'r', 'utf-8') as file:\n            data = file.read()\n\n        data = data.replace(\n            'fields.article.url = apiProject.url + fields.article.url;',\n            '''if (fields.article.url.substr(0, 4).toLowerCase() !== \\'http\\')\n                        fields.article.url = apiProject.url + fields.article.url;''')\n\n        headers = Headers()\n        headers['Content-Length'] = getsize(file_name)\n\n        response = self.app.response_class(data,\n                                           mimetype=mimetypes.guess_type(file_name)[0],\n                                           headers=headers,\n                                           direct_passthrough=True)\n\n        response.last_modified = int(getmtime(file_name))\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the api_project. json file from apidoc folder as a json string.", "response": "def __read_api_project(self):\n        \"\"\"\n        Reads the api_project.json file from apidoc folder as a json string.\n        :return: a json string\n        \"\"\"\n\n        file_name = join(self.app.static_folder, self.folder_path, 'api_project.json')\n\n        with open(file_name, 'rt') as file:\n            data = file.read()\n\n        return json.loads(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _raise_exception(cls, reason, data=None):\n    text_dict = {\n        \"error\": reason\n    }\n\n    if data is not None:\n        text_dict[\"errors\"] = data\n\n    raise cls(\n        text=json.dumps(text_dict),\n        content_type=\"application/json\"\n    )", "response": "Raise a aiohttp exception and pass payload / reason into it."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates the dict data against given schema.", "response": "def _validate_data(data, schema, validator_cls):\n    \"\"\"\n    Validate the dict against given schema (using given validator class).\n    \"\"\"\n    validator = validator_cls(schema)\n    _errors = defaultdict(list)\n    for err in validator.iter_errors(data):\n        path = err.schema_path\n\n        # Code courtesy: Ruslan Karalkin\n        # Looking in error schema path for\n        # property that failed validation\n        # Schema example:\n        # {\n        #    \"type\": \"object\",\n        #    \"properties\": {\n        #        \"foo\": {\"type\": \"number\"},\n        #        \"bar\": {\"type\": \"string\"}\n        #     }\n        #    \"required\": [\"foo\", \"bar\"]\n        # }\n        #\n        # Related err.schema_path examples:\n        # ['required'],\n        # ['properties', 'foo', 'type']\n\n        if \"properties\" in path:\n            path.remove(\"properties\")\n        key = path.popleft()\n\n        # If validation failed by missing property,\n        # then parse err.message to find property name\n        # as it always first word enclosed in quotes\n        if key == \"required\":\n            key = err.message.split(\"'\")[1]\n\n        _errors[key].append(str(err))\n\n    if _errors:\n        _raise_exception(\n            web.HTTPBadRequest,\n            \"Request is invalid; There are validation errors.\",\n            _errors)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecorate request handler to make it automagically validate it's request and response.", "response": "def validate(request_schema=None, response_schema=None):\n    \"\"\"\n    Decorate request handler to make it automagically validate it's request\n    and response.\n    \"\"\"\n    def wrapper(func):\n        # Validating the schemas itself.\n        # Die with exception if they aren't valid\n        if request_schema is not None:\n            _request_schema_validator = validator_for(request_schema)\n            _request_schema_validator.check_schema(request_schema)\n\n        if response_schema is not None:\n            _response_schema_validator = validator_for(response_schema)\n            _response_schema_validator.check_schema(response_schema)\n\n        @asyncio.coroutine\n        @functools.wraps(func)\n        def wrapped(*args):\n            if asyncio.iscoroutinefunction(func):\n                coro = func\n            else:\n                coro = asyncio.coroutine(func)\n\n            # Supports class based views see web.View\n            if isinstance(args[0], AbstractView):\n                class_based = True\n                request = args[0].request\n            else:\n                class_based = False\n                request = args[-1]\n\n            # Strictly expect json object here\n            try:\n                req_body = yield from request.json()\n            except (json.decoder.JSONDecodeError, TypeError):\n                _raise_exception(\n                    web.HTTPBadRequest,\n                    \"Request is malformed; could not decode JSON object.\")\n\n            # Validate request data against request schema (if given)\n            if request_schema is not None:\n                _validate_data(req_body, request_schema,\n                               _request_schema_validator)\n\n            coro_args = req_body, request\n            if class_based:\n                coro_args = (args[0], ) + coro_args\n\n            context = yield from coro(*coro_args)\n\n            # No validation of response for websockets stream\n            if isinstance(context, web.StreamResponse):\n                return context\n\n            # Validate response data against response schema (if given)\n            if response_schema is not None:\n                _validate_data(context, response_schema,\n                               _response_schema_validator)\n\n            try:\n                return web.json_response(context)\n            except (TypeError, ):\n                _raise_exception(\n                    web.HTTPInternalServerError,\n                    \"Response is malformed; could not encode JSON object.\")\n\n        # Store schemas in wrapped handlers, so it later can be reused\n        setattr(wrapped, \"_request_schema\", request_schema)\n        setattr(wrapped, \"_response_schema\", response_schema)\n        return wrapped\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating JSON Schema representation of a biolink model", "response": "def cli(yamlfile, inline, format):\n    \"\"\" Generate JSON Schema representation of a biolink model \"\"\"\n    print(JsonSchemaGenerator(yamlfile, format).serialize(inline=inline))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef root_representer(dumper: yaml.Dumper, data: YAMLRoot):\n    rval = dict()\n    for k, v in data.__dict__.items():\n        if not k.startswith('_') and v is not None and (not isinstance(v, (dict, list)) or v):\n            rval[k] = v\n    return dumper.represent_data(rval)", "response": "YAML callback that dumps the root node of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a markdown documentation of a biolink model", "response": "def cli(yamlfile, format, dir, classes, img, noimages):\n    \"\"\" Generate markdown documentation of a biolink model \"\"\"\n    MarkdownGenerator(yamlfile, format).serialize(classes=classes, directory=dir, image_dir=img, noimages=noimages)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_secondary_ref(self, en: str) -> bool:\n        if not self.gen_classes:\n            return True\n        elif en in self.schema.classes:\n            return en in self.gen_classes_neighborhood.classrefs\n        elif en in self.schema.slots:\n            return en in self.gen_classes_neighborhood.slotrefs\n        elif en in self.schema.types:\n            return en in self.gen_classes_neighborhood.typerefs\n        else:\n            return True", "response": "Determine whether the element name en is the name of a secondary reference."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a description for the object if it is unique.", "response": "def desc_for(self, obj: Element, doing_descs: bool) -> str:\n        \"\"\" Return a description for object if it is unique (different than its parent)\n\n        @param obj: object to be described\n        @param doing_descs: If false, always return an empty string\n        @return: text or empty string\n        \"\"\"\n        if obj.description and doing_descs:\n            if isinstance(obj, SlotDefinition) and obj.is_a:\n                parent = self.schema.slots[obj.is_a]\n            elif isinstance(obj, ClassDefinition) and obj.is_a:\n                parent = self.schema.classes[obj.is_a]\n            else:\n                parent = None\n            return '' if parent and obj.description == parent.description else obj.description\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef link(self, ref: Optional[Union[str, Element]], *, after_link: str = None, use_desc: bool=False,\n             add_subset: bool=True) -> str:\n        \"\"\" Create a link to ref if appropriate.\n\n        @param ref: the name or value of a class, slot, type or the name of a built in type.\n        @param after_link: Text to put between link and description\n        @param use_desc: True means append a description after the link if available\n        @param add_subset: True means add any subset information that is available\n        @return:\n        \"\"\"\n        obj = self.obj_for(ref) if isinstance(ref, str) else ref\n        nl = '\\n'\n        if isinstance(obj, str) or obj is None or not self.is_secondary_ref(obj.name):\n            return self.bbin(ref)\n        if isinstance(obj, SlotDefinition):\n            link_name = ((be(obj.domain) + '.') if obj.alias else '') + self.aliased_slot_name(obj)\n            link_ref = underscore(obj.name)\n        else:\n            link_name = self.obj_name(obj)\n            link_ref = link_name\n        desc = self.desc_for(obj, use_desc)\n        return f'[{link_name}]' \\\n               f'({link_ref}.{self.format})' + \\\n                 (f' *subsets*: ({\"| \".join(obj.in_subset)})' if add_subset and obj.in_subset else '') + \\\n                 (f' {after_link} ' if after_link else '') + (f' - {desc.split(nl)[0]}' if desc else '')", "response": "Create a link to the name of a class slot type or a built in type."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an OWL representation of a biolink model", "response": "def cli(yamlfile, format, output):\n    \"\"\" Generate an OWL representation of a biolink model \"\"\"\n    print(OwlSchemaGenerator(yamlfile, format).serialize(output=output))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef visit_slot(self, slot_name: str, slot: SlotDefinition) -> None:\n        # Note: We use the raw name in OWL and add a subProperty arc\n        slot_uri = self.prop_uri(slot.name)\n\n        # Parent slots\n        if slot.is_a:\n            self.graph.add((slot_uri, RDFS.subPropertyOf, self.prop_uri(slot.is_a)))\n        for mixin in slot.mixins:\n            self.graph.add((slot_uri, RDFS.subPropertyOf, self.prop_uri(mixin)))\n\n        # Slot range\n        if not slot.range or slot.range in builtin_names:\n            self.graph.add((slot_uri, RDF.type,\n                            OWL.DatatypeProperty if slot.object_property else OWL.AnnotationProperty))\n            self.graph.add((slot_uri, RDFS.range, URIRef(builtin_uri(slot.range, expand=True))))\n        elif slot.range in self.schema.types:\n            self.graph.add((slot_uri, RDF.type,\n                            OWL.DatatypeProperty if slot.object_property else OWL.AnnotationProperty))\n            self.graph.add((slot_uri, RDFS.range, self.type_uri(slot.range)))\n        else:\n            self.graph.add((slot_uri, RDF.type, OWL.ObjectProperty if slot.object_property else OWL.AnnotationProperty))\n            self.graph.add((slot_uri, RDFS.range, self.class_uri(slot.range)))\n\n        # Slot domain\n        if slot.domain:\n            self.graph.add((slot_uri, RDFS.domain, self.class_uri(slot.domain)))\n\n        # Annotations\n        self.graph.add((slot_uri, RDFS.label, Literal(slot.name)))\n        if slot.description:\n            self.graph.add((slot_uri, OBO.IAO_0000115, Literal(slot.description)))", "response": "Add a slot definition per slot_name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading and flatten a schema from a file name URL or a block of text.", "response": "def load_raw_schema(data: Union[str, TextIO],\n                    source_file: str=None,\n                    source_file_date: str=None,\n                    source_file_size: int=None,\n                    base_dir: Optional[str]=None) -> SchemaDefinition:\n    \"\"\" Load and flatten SchemaDefinition from a file name, a URL or a block of text\n\n    @param data: URL, file name or block of text\n    @param source_file: Source file name for the schema\n    @param source_file_date: timestamp of source file\n    @param source_file_size: size of source file\n    @param base_dir: Working directory of sources\n    @return: Map from schema name to SchemaDefinition\n    \"\"\"\n    if isinstance(data, str):\n        if '\\n' in data:\n            return load_raw_schema((cast(TextIO, StringIO(data))))  # Not sure why typing doesn't see StringIO as TextIO\n        elif '://' in data:\n            # TODO: complete and test URL access\n            req = Request(data)\n            req.add_header(\"Accept\", \"application/yaml, text/yaml;q=0.9\")\n            with urlopen(req) as response:\n                return load_raw_schema(response)\n        else:\n            fname = os.path.join(base_dir if base_dir else '', data)\n            with open(fname) as f:\n                return load_raw_schema(f, data, time.ctime(os.path.getmtime(fname)), os.path.getsize(fname))\n    else:\n        schemadefs = yaml.load(data, DupCheckYamlLoader)\n        # Some schemas don't have an outermost identifier.  Construct one if necessary\n        if 'name' in schemadefs:\n            schemadefs = {schemadefs.pop('name'): schemadefs}\n        elif 'id' in schemadefs:\n            schemadefs = {schemadefs['id']: schemadefs}\n        elif len(schemadefs) > 1 or not isinstance(list(schemadefs.values())[0], dict):\n            schemadefs = {'Unnamed Schema': schemadefs}\n        schema: SchemaDefinition = None\n        for sname, sdef in {k: SchemaDefinition(name=k, **v) for k, v in schemadefs.items()}.items():\n            if schema is None:\n                schema = sdef\n                schema.source_file = os.path.basename(source_file) if source_file else None\n                schema.source_file_date = source_file_date\n                schema.source_file_size = source_file_size\n                schema.generation_date =  datetime.now().strftime(\"%Y-%m-%d %H:%M\")\n                schema.metamodel_version = metamodel_version\n            else:\n                merge_schemas(schema, sdef)\n        return schema"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconstruct a mapping from a node.", "response": "def map_constructor(self, loader,  node, deep=False):\n        \"\"\" Walk the mapping, recording any duplicate keys.\n\n        \"\"\"\n        mapping = {}\n        for key_node, value_node in node.value:\n            key = loader.construct_object(key_node, deep=deep)\n            value = loader.construct_object(value_node, deep=deep)\n            if key in mapping:\n                raise ValueError(f\"Duplicate key: \\\"{key}\\\"\")\n            mapping[key] = value\n\n        return mapping"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncompares two files using a filter", "response": "def cli(file1, file2, comments) -> int:\n    \"\"\" Compare file1 to file2 using a filter \"\"\"\n    sys.exit(compare_files(file1, file2, comments))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cli(file, dir, format):\n    print(GolrSchemaGenerator(file, format).serialize(dirname=dir))", "response": "Generate GOLR representation of a biolink model"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cli(yamlfile, directory, out, classname, format):\n    DotGenerator(yamlfile, format).serialize(classname=classname, dirname=directory, filename=out)", "response": "Generate graphviz representations of the biolink model"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate JSONLD file from biolink schema", "response": "def cli(yamlfile, format, context):\n    \"\"\" Generate JSONLD file from biolink schema \"\"\"\n    print(JSONLDGenerator(yamlfile, format).serialize(context=context))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cli(yamlfile, format, output, context):\n    print(RDFGenerator(yamlfile, format).serialize(output=output, context=context))", "response": "Generate an RDF representation of a biolink model"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the list of slots directly included in the class definition.", "response": "def cls_slots(self, cls: CLASS_OR_CLASSNAME) -> List[SlotDefinition]:\n        \"\"\" Return the list of slots directly included in the class definition.  Includes slots whose\n        domain is cls -- as declared in slot.domain or class.slots\n\n        Does not include slots declared in mixins, apply_to or is_a links\n\n        @param cls: class name or class definition name\n        @return: all direct class slots\n        \"\"\"\n        if not isinstance(cls, ClassDefinition):\n            cls = self.schema.classes[cls]\n        return [self.schema.slots[s] for s in cls.slots]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning all slots that are part of the class definition.", "response": "def all_slots(self, cls: CLASS_OR_CLASSNAME, *, cls_slots_first: bool = False) \\\n            -> List[SlotDefinition]:\n        \"\"\" Return all slots that are part of the class definition.  This includes all is_a, mixin and apply_to slots\n        but does NOT include slot_usage targets.  If class B has a slot_usage entry for slot \"s\", only the slot\n        definition for the redefined slot will be included, not its base.  Slots are added in the order they appear\n        in classes, with recursive is_a's being added first followed by mixins and finally apply_tos\n\n        @param cls: class definition or class definition name\n        @param cls_slots_first: True means return class slots at the top of the list\n        @return: ordered list of slots in the class with slot usages removed\n        \"\"\"\n        def merge_definitions(cls_name: Optional[ClassDefinitionName]) -> None:\n            if cls_name:\n                for slot in self.all_slots(cls_name):\n                    aliased_name = self.aliased_slot_name(slot)\n                    if aliased_name not in known_slots:\n                        known_slots.add(aliased_name)\n                        rval.append(slot)\n\n        if not isinstance(cls, ClassDefinition):\n            cls = self.schema.classes[cls]\n        known_slots: Set[str] = self.aliased_slot_names(cls.slots)\n        rval: List[SlotDefinition] = []\n\n        if cls_slots_first:\n            rval += self.cls_slots(cls)\n            for mixin in cls.mixins:\n                merge_definitions(mixin)\n            merge_definitions(cls.is_a)\n        else:\n            merge_definitions(cls.is_a)\n            for mixin in cls.mixins:\n                merge_definitions(mixin)\n            rval += self.cls_slots(cls)\n\n        return rval"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ancestors(self, definition: Union[SLOT_OR_SLOTNAME,\n                                          CLASS_OR_CLASSNAME]) \\\n            -> List[Union[SlotDefinitionName, ClassDefinitionName]]:\n        \"\"\" Return an ordered list of ancestor names for the supplied slot or class\n\n        @param definition: Slot or class name or definition\n        @return: List of ancestor names\n        \"\"\"\n        definition = self.obj_for(definition)\n        if definition is not None:\n            return [definition.name] + self.ancestors(definition.is_a)\n        else:\n            return []", "response": "Return an ordered list of ancestor names for the supplied slot or class name or class."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of all slots classes and types that touch any element in elements including the element itself.", "response": "def neighborhood(self, elements: List[ELEMENT_NAME]) \\\n            -> References:\n        \"\"\" Return a list of all slots, classes and types that touch any element in elements, including the element\n        itself\n\n        @param elements: Elements to do proximity with\n        @return: All slots and classes that touch element\n        \"\"\"\n        touches = References()\n        for element in elements:\n            if element in self.schema.classes:\n                touches.classrefs.add(element)\n                if None in touches.classrefs:\n                    raise ValueError(\"1\")\n                cls = self.schema.classes[element]\n                if cls.is_a:\n                    touches.classrefs.add(cls.is_a)\n                if None in touches.classrefs:\n                    raise ValueError(\"1\")\n                # Mixins include apply_to's\n                touches.classrefs.update(set(cls.mixins))\n                for slotname in cls.slots:\n                    slot = self.schema.slots[slotname]\n                    if slot.range in self.schema.classes:\n                        touches.classrefs.add(slot.range)\n                    elif slot.range in self.schema.types:\n                        touches.typerefs.add(slot.range)\n                    if None in touches.classrefs:\n                        raise ValueError(\"1\")\n                if element in self.synopsis.rangerefs:\n                    for slotname in self.synopsis.rangerefs[element]:\n                        touches.slotrefs.add(slotname)\n                        if self.schema.slots[slotname].domain:\n                            touches.classrefs.add(self.schema.slots[slotname].domain)\n            elif element in self.schema.slots:\n                touches.slotrefs.add(element)\n                slot = self.schema.slots[element]\n                touches.slotrefs.update(set(slot.mixins))\n                if slot.is_a:\n                    touches.slotrefs.add(slot.is_a)\n                if element in self.synopsis.inverses:\n                    touches.slotrefs.update(self.synopsis.inverses[element])\n                if slot.domain:\n                    touches.classrefs.add(slot.domain)\n                if slot.range in self.schema.classes:\n                    touches.classrefs.add(slot.range)\n                elif slot.range in self.schema.types:\n                    touches.typerefs.add(slot.range)\n            elif element in self.schema.types:\n                if element in self.synopsis.rangerefs:\n                    touches.slotrefs.update(self.synopsis.rangerefs[element])\n\n        return touches"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchasing the slot range to its final form", "response": "def grounded_slot_range(self, slot: Optional[Union[SlotDefinition, Optional[str]]]) -> str:\n        \"\"\" Chase the slot range to its final form\n\n        @param slot: slot to check\n        @return: name of resolved range\n        \"\"\"\n        if slot is not None and not isinstance(slot, str):\n            slot = slot.range\n        if slot is None:\n            return DEFAULT_BUILTIN_TYPE_NAME         # Default type name\n        elif slot in builtin_names:\n            return slot\n        elif slot in self.schema.types:\n            return self.grounded_slot_range(self.schema.types[slot].typeof)\n        else:\n            return slot"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the overloaded slot name if one exists otherwise the actual name", "response": "def aliased_slot_name(self, slot: SLOT_OR_SLOTNAME) -> str:\n        \"\"\" Return the overloaded slot name -- the alias if one exists otherwise the actual name\n\n        @param slot: either a slot name or a definition\n        @return: overloaded name\n        \"\"\"\n        if isinstance(slot, str):\n            slot = self.schema.slots[slot]\n        return slot.alias if slot.alias else slot.name"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the aliased slot names for all members of the list .", "response": "def aliased_slot_names(self, slot_names: List[SlotDefinitionName]) -> Set[str]:\n        \"\"\" Return the aliased slot names for all members of the list\n\n        @param slot_names: actual slot names\n        @return: aliases w/ duplicates removed\n        \"\"\"\n        return {self.aliased_slot_name(sn) for sn in slot_names}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the class slot or type that represents name or name itself if it is a builtin type or None if not found.", "response": "def obj_for(self, obj_or_name: Union[str, Element]) -> Optional[Union[str, Element]]:\n        \"\"\" Return the class, slot or type that represents name or name itself if it is a builtin\n\n        @param obj_or_name: Object or name\n        @return: Corresponding element or None if not found (most likely cause is that it is a builtin type)\n        \"\"\"\n        name = obj_or_name.name if isinstance(obj_or_name, Element) else obj_or_name\n        return self.schema.classes[name] if name in self.schema.classes \\\n            else self.schema.slots[name] if name in self.schema.slots \\\n            else self.schema.types[name] if name in self.schema.types else name if name in builtin_names \\\n            else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the formatted name used for the supplied object", "response": "def obj_name(self, obj: Union[str, Element]) -> str:\n        \"\"\" Return the formatted name used for the supplied definition \"\"\"\n        if isinstance(obj, str):\n            obj = self.obj_for(obj)\n        if isinstance(obj, SlotDefinition):\n            return underscore(self.aliased_slot_name(obj))\n        else:\n            return camelcase(obj if isinstance(obj, str) else obj.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates CSV file from biolink model", "response": "def cli(yamlfile, root, format):\n    \"\"\" Generate CSV/TSV file from biolink model \"\"\"\n    print(CsvGenerator(yamlfile, format).serialize(classes=root))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gen_inherited(self) -> str:\n        inherited_head = 'inherited_slots: List[str] = ['\n        inherited_slots = ', '.join([f'\"{underscore(slot.name)}\"' for slot in self.schema.slots.values()\n                                     if slot.inherited])\n        is_rows = split_line(inherited_slots, 120 - len(inherited_head))\n        return inherited_head + ('\\n' + len(inherited_head) * ' ').join([r.strip() for r in is_rows]) + ']'", "response": "Generate the list of slot properties that are inherited across slot usage or is_a paths"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef gen_references(self) -> str:\n        rval = []\n        for cls in self.schema.classes.values():\n            pkeys = self.primary_keys_for(cls)\n            for pk in pkeys:\n                pk_slot = self.schema.slots[pk]\n                classname = camelcase(cls.name) + camelcase(pk)\n                if cls.is_a and getattr(self.schema.classes[cls.is_a], pk, None):\n                    parent = self.range_type_name(pk_slot, cls.is_a)\n                else:\n                    parent = self.python_name_for(pk_slot.range)\n                rval.append(f'class {classname}({parent}):\\n\\tpass')\n        return '\\n\\n\\n'.join(rval)", "response": "Generate python type declarations for all identifiers"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate python type declarations for all defined types", "response": "def gen_typedefs(self) -> str:\n        \"\"\" Generate python type declarations for all defined types \"\"\"\n        rval = []\n        for typ in self.schema.types.values():\n            typname = self.python_name_for(typ.name)\n            parent = self.python_name_for(typ.typeof)\n            rval.append(f'class {typname}({parent}):\\n\\tpass')\n        return '\\n\\n\\n'.join(rval) + ('\\n' if rval else '')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gen_classdefs(self) -> str:\n        return '\\n'.join([self.gen_classdef(k, v) for k, v in self.schema.classes.items() if not v.mixin])", "response": "Generate class definitions for all non - mixin classes in the model\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate python definition for class clsname", "response": "def gen_classdef(self, clsname: str,  cls: ClassDefinition) -> str:\n        \"\"\" Generate python definition for class clsname \"\"\"\n        parentref = f'({self.python_name_for(cls.is_a) if cls.is_a else \"YAMLRoot\"})'\n        slotdefs = self.gen_slot_variables(cls)\n        postinits = self.gen_postinits(cls)\n        if not slotdefs:\n            slotdefs = 'pass'\n        wrapped_description = f'''\n    \"\"\"\n    {wrapped_annotation(be(cls.description))}\n    \"\"\"''' if be(cls.description) else ''\n        return f'''\n@dataclass\nclass {camelcase(clsname)}{parentref}:{wrapped_description}\n    {slotdefs}\n    {postinits}'''"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate python definition for class cls generating primary keys first followed by the rest of the slots", "response": "def gen_slot_variables(self, cls: ClassDefinition) -> str:\n        \"\"\" Generate python definition for class cls, generating primary keys first followed by the rest of the slots\n        \"\"\"\n        return '\\n\\t'.join([self.gen_slot_variable(cls, pk) for pk in self.primary_keys_for(cls)] +\n                           [self.gen_slot_variable(cls, slot)\n                            for slot in cls.slots\n                            if not self.schema.slots[slot].primary_key and not self.schema.slots[slot].identifier])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a slot variable for the given slotname as defined in class", "response": "def gen_slot_variable(self, cls: ClassDefinition, slotname: str) -> str:\n        \"\"\" Generate a slot variable for slotname as defined in class\n        \"\"\"\n        slot = self.schema.slots[slotname]\n\n        # Alias allows re-use of slot names in different contexts\n        if slot.alias:\n            slotname = slot.alias\n\n        range_type = self.range_type_name(slot, cls.name)\n        # Python version < 3.7 -- forward references have to be quoted\n        if slot.inlined and slot.range in self.schema.classes and self.forward_reference(slot.range, cls.name):\n            range_type = f'\"{range_type}\"'\n        slot_range, default_val = self.range_cardinality(range_type, slot, cls)\n        default = f'= {default_val}' if default_val else ''\n        return f'''{underscore(slotname)}: {slot_range} {default}'''"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gen_postinits(self, cls: ClassDefinition) -> str:\n        post_inits = []\n        if not cls.abstract:\n            pkeys = self.primary_keys_for(cls)\n            for pkey in pkeys:\n                post_inits.append(self.gen_postinit(cls, pkey))\n        for slotname in cls.slots:\n            slot = self.schema.slots[slotname]\n            if not (slot.primary_key or slot.identifier):\n                post_inits.append(self.gen_postinit(cls, slotname))\n        post_inits_line = '\\n\\t\\t'.join([p for p in post_inits if p])\n        return (f'''\n    def _fix_elements(self):\n        super()._fix_elements()\n        {post_inits_line}''' + '\\n') if post_inits_line else ''", "response": "Generate all the typing and existence checks post initialize\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gen_postinit(self, cls: ClassDefinition, slotname: str) -> Optional[str]:\n        rlines: List[str] = []\n        slot = self.schema.slots[slotname]\n        if slot.alias:\n            slotname = slot.alias\n        slotname = self.python_name_for(slotname)\n        range_type_name = self.range_type_name(slot, cls.name)\n\n        # Generate existence check for required slots.  Note that inherited classes have to check post-init because\n        # named variables can't be mixed in the class signature\n        if slot.primary_key or slot.identifier or slot.required:\n            if cls.is_a:\n                rlines.append(f'if self.{slotname} is None:')\n                rlines.append(f'\\traise ValueError(f\"{slotname} must be supplied\")')\n                rlines.append(f'if not isinstance(self.{slotname}, {range_type_name}):')\n                rlines.append(f'\\tself.{slotname} = {range_type_name}(self.{slotname})')\n        elif slot.range in self.schema.classes or slot.range in self.schema.types:\n            if not slot.multivalued:\n                rlines.append(f'if self.{slotname} and not isinstance(self.{slotname}, {range_type_name}):')\n                # Another really wierd case -- a class that has no properties\n                if slot.range in self.schema.classes and not self.all_slots_for(self.schema.classes[slot.range]):\n                    rlines.append(f'\\tself.{slotname} = {range_type_name}()')\n                else:\n                    rlines.append(f'\\tself.{slotname} = {range_type_name}(self.{slotname})')\n            elif slot.inlined:\n                slot_range_cls = self.schema.classes[slot.range]\n                pkeys = self.primary_keys_for(slot_range_cls)\n                if pkeys:\n                    # Special situation -- if there are only two values: primary key and value,\n                    # we load it is a list, not a dictionary\n                    if len(self.all_slots_for(slot_range_cls)) - len(pkeys) == 1:\n                        class_init = '(k, v)'\n                    else:\n                        pkey_name = self.python_name_for(pkeys[0])\n                        class_init = f'({pkey_name}=k, **({{}} if v is None else v))'\n                    rlines.append(f'for k, v in self.{slotname}.items():')\n                    rlines.append(f'\\tif not isinstance(v, {range_type_name}):')\n                    rlines.append(f'\\t\\tself.{slotname}[k] = {range_type_name}{class_init}')\n            else:\n                rlines.append(f'self.{slotname} = [v if isinstance(v, {range_type_name})')\n                indent = len(f'self.{slotname} = [') * ' '\n                rlines.append(f'{indent}else {range_type_name}(v) for v in self.{slotname}]')\n        return '\\n\\t\\t'.join(rlines)", "response": "Generate python post - init rules for a class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all primary keys for cls", "response": "def primary_keys_for(self, cls: ClassDefinition) -> List[SlotDefinitionName]:\n        \"\"\" Return all primary keys / identifiers for cls\n\n        @param cls: class to get keys for\n        @return: List of primary keys\n        \"\"\"\n        return [slot_name for slot_name in self.all_slots_for(cls)\n                if self.schema.slots[slot_name].primary_key or self.schema.slots[slot_name].identifier]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef all_slots_for(self, cls: ClassDefinition) -> List[SlotDefinitionName]:\n        if not cls.is_a:\n            return cls.slots\n        else:\n            return [sn for sn in self.all_slots_for(self.schema.classes[cls.is_a]) if sn not in cls.slot_usage] \\\n                   + cls.slots", "response": "Return all slots for the given class cls."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef range_type_name(self, slot: SlotDefinition, containing_class_name: ClassDefinitionName) -> str:\n        if slot.primary_key or slot.identifier:\n            return self.python_name_for(containing_class_name) + camelcase(slot.name)\n\n        if slot.range in self.schema.classes and not slot.inlined:\n            class_key = self.key_name_for(cast(ClassDefinitionName, slot.range))\n            if class_key:\n                return class_key\n        return self.python_name_for(slot.range)", "response": "Generate the type name for the given slot."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef forward_reference(self, slot_range: str, owning_class: str) -> bool:\n        for cname in self.schema.classes:\n            if cname == owning_class:\n                return True             # Occurs on or after\n            elif cname == slot_range:\n                return False            # Occurs before\n        return True", "response": "Determines whether the given slot_range is a forward reference."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resolve(self) -> SchemaDefinition:\n\n        if not isinstance(self.schema.slots, dict):\n            raise ValueError(f\"File: {self.schema.source_file} Slots are not a dictionary\")\n\n        if not isinstance(self.schema.classes, dict):\n            raise ValueError(f\"File: {self.schema.source_file} Classes are not a dictionary\")\n\n        # Process imports\n        for sname in self.schema.imports:\n            if sname not in self.loaded:\n                self.loaded.add(sname)\n                merge_schemas(self.schema, load_raw_schema(sname + '.yaml', base_dir=self.base_dir))\n\n        # slot.domain --> class.slots\n        for slot in self.schema.slots.values():\n            if slot.domain in self.schema.classes and slot.name not in self.schema.classes[slot.domain].slots:\n                self.schema.classes[slot.domain].slots.append(slot.name)\n\n        # class.slots --> slot.domain\n        for cls in self.schema.classes.values():\n            if not isinstance(cls, ClassDefinition):\n                raise ValueError(\n                    f'File: {self.schema.source_file} Class \"{cls} (type: {type(cls)})\" definition is peculiar')\n            if isinstance(cls.slots, str):\n                print(f\"File: {self.schema.source_file} Class: {cls.name} Slots are not an array\", file=sys.stderr)\n                cls.slots = [cls.slots]\n            for slotname in cls.slots:\n                if slotname in self.schema.slots:\n                    if self.schema.slots[slotname].domain is None:\n                        self.schema.slots[slotname].domain = cls.name\n\n        # apply to --> mixins\n        for cls in self.schema.classes.values():\n            if cls.apply_to in self.schema.classes:\n                self.schema.classes[cls.apply_to].mixins.append(cls.name)\n\n        # Override class slots with slot usage definitions\n        for cls in self.schema.classes.values():\n            for slot_name, slot_usage in cls.slot_usage.items():\n                # Construct a new slot\n                # Follow the ancestry of the class to get the most proximal parent\n                parent_slot = self.slot_definition_for(slot_name, cls)\n                if not parent_slot and slot_name in self.schema.slots:\n                    parent_slot = self.schema.slots[slot_name]\n                # If parent slot is still not defined, it means that we introduced a NEW slot in the slot usages\n                child_name = SlotDefinitionName(cls.name + ' ' + slot_name) if parent_slot else slot_name\n                new_slot = SlotDefinition(name=child_name, alias=slot_name, domain=cls.name)\n                merge_slots(new_slot, slot_usage)\n\n                # Copy the parent definition.  If there is no parent definition, the slot is being defined\n                # locally as a slot_usage\n                if parent_slot is not None:\n                    new_slot.is_a = parent_slot.name\n                    merge_slots(new_slot, parent_slot)\n\n                # Add the slot usage overrides\n                merge_slots(new_slot, slot_usage)\n                self.schema.slots[child_name] = new_slot\n\n                # Add or replace the slot in the class definition\n                append = True\n                for i, s in enumerate(cls.slots):\n                    if s == slot_name:\n                        cls.slots[i] = SlotDefinitionName(child_name)\n                        append = False\n                        break\n                if append:\n                    cls.slots.append(SlotDefinitionName(child_name))\n\n        # Update slots with parental information\n        merged_slots: List[SlotDefinition] = []\n        for slot in self.schema.slots.values():\n            self.merge_slot(slot, merged_slots)\n\n        # Clean up the slot range defaults\n        for slot in self.schema.slots.values():\n            if not slot.range:\n                slot.range = 'string'\n\n        return self.schema", "response": "Resolve the schema to a fully resolved version of the schema."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind the most proximal definition for the given slotname in the context of cls.", "response": "def slot_definition_for(self, slotname: SlotDefinitionName, cls: ClassDefinition) -> Optional[SlotDefinition]:\n        \"\"\" Find the most proximal definition for slotname in the context of cls\"\"\"\n        if cls.is_a:\n            for sn in self.schema.classes[cls.is_a].slots:\n                slot = self.schema.slots[sn]\n                if slot.alias and slotname == slot.alias or slotname == slot.name:\n                    return slot\n        for mixin in cls.mixins:\n            for sn in self.schema.classes[mixin].slots:\n                slot = self.schema.slots[sn]\n                if slot.alias and slotname == slot.alias or slotname == slot.name:\n                    return slot\n        if cls.is_a:\n            defn = self.slot_definition_for(slotname, self.schema.classes[cls.is_a])\n            if defn:\n                return defn\n        for mixin in cls.mixins:\n            defn = self.slot_definition_for(slotname, self.schema.classes[mixin])\n            if defn:\n                return defn\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a UML representation of a biolink model", "response": "def cli(yamlfile, format, classes, directory):\n    \"\"\" Generate a UML representation of a biolink model \"\"\"\n    print(YumlGenerator(yamlfile, format).serialize(classes=classes, directory=directory), end=\"\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef class_box(self, cn: ClassDefinitionName) -> str:\n        slot_defs: List[str] = []\n        if cn not in self.box_generated and (not self.focus_classes or cn in self.focus_classes):\n            cls = self.schema.classes[cn]\n            for slotname in self.filtered_cls_slots(cn, all_slots=True):\n                slot = self.schema.slots[slotname]\n                if not slot.range or slot.range in builtin_names or slot.range in self.schema.types:\n                    mod = self.prop_modifier(cls, slot)\n                    slot_defs.append(underscore(self.aliased_slot_name(slot)) +\n                                     mod + ':' +\n                                     underscore(slot.range) + self.cardinality(slot))\n            self.box_generated.add(cn)\n        self.referenced.add(cn)\n        return '[' + camelcase(cn) + ('|' + ';'.join(slot_defs) if slot_defs else '') + ']'", "response": "Generates a box for the class."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nemit all associations for a focus class.", "response": "def class_associations(self, cn: ClassDefinitionName, must_render: bool=False) -> str:\n        \"\"\" Emit all associations for a focus class.  If none are specified, all classes are generated\n\n        @param cn: Name of class to be emitted\n        @param must_render: True means render even if this is a target (class is specifically requested)\n        @return: YUML representation of the association\n        \"\"\"\n\n        # NOTE: YUML diagrams draw in the opposite order in which they are created, so we work from bottom to top and\n        # from right to left\n        assocs: List[str] = []\n        if cn not in self.associations_generated and (not self.focus_classes or cn in self.focus_classes):\n            cls = self.schema.classes[cn]\n\n            # Slots\n            for slotname in self.filtered_cls_slots(cn, False)[::-1]:\n                slot = self.schema.slots[slotname]\n                if slot.range in self.schema.classes:\n                    assocs.append(self.class_box(cn) + (yuml_inline if slot.inlined else yuml_ref) +\n                                  self.aliased_slot_name(slot) + self.prop_modifier(cls, slot) +\n                                  self.cardinality(slot) + '>' + self.class_box(slot.range))\n\n            # Referencing slots\n            if cn in self.synopsis.rangerefs:\n                for slotname in sorted(self.synopsis.rangerefs[cn]):\n                    slot = self.schema.slots[slotname]\n                    if slot.domain in self.schema.classes and (slot.range != cls.name or must_render):\n                        assocs.append(self.class_box(slot.domain) + (yuml_inline if slot.inlined else yuml_ref) +\n                                      self.aliased_slot_name(slot) + self.prop_modifier(cls, slot) +\n                                      self.cardinality(slot) + '>' + self.class_box(cn))\n\n            # Mixins used in the class\n            for mixin in cls.mixins:\n                assocs.append(self.class_box(cn) + yuml_uses + self.class_box(mixin))\n\n            # Classes that use the class as a mixin\n            if cls.name in self.synopsis.mixinrefs:\n                for mixin in sorted(self.synopsis.mixinrefs[cls.name].classrefs, reverse=True):\n                    assocs.append(self.class_box(ClassDefinitionName(mixin)) + yuml_uses + self.class_box(cn))\n\n            # Classes that inject information\n            if cn in self.synopsis.applytos:\n                for injector in sorted(self.synopsis.applytos[cn].classrefs, reverse=True):\n                    assocs.append(self.class_box(cn) + yuml_injected + self.class_box(ClassDefinitionName(injector)))\n            self.associations_generated.add(cn)\n\n            # Children\n            if cn in self.synopsis.isarefs:\n                for is_a_cls in sorted(self.synopsis.isarefs[cn].classrefs, reverse=True):\n                    assocs.append(self.class_box(cn) + yuml_is_a + self.class_box(ClassDefinitionName(is_a_cls)))\n\n            # Parent\n            if cls.is_a:\n                assocs.append(self.class_box(cls.is_a) + yuml_is_a + self.class_box(cn))\n        return ', '.join(assocs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the set of slots associated with the class that meet the filter criteria.", "response": "def filtered_cls_slots(self, cn: ClassDefinitionName, all_slots: bool=True) \\\n            -> List[SlotDefinitionName]:\n        \"\"\" Return the set of slots associated with the class that meet the filter criteria.  Slots will be returned\n        in defining order, with class slots returned last\n\n        @param cn: name of class to filter\n        @param all_slots: True means include attributes\n        @return: List of slot definitions\n        \"\"\"\n        rval = []\n        cls = self.schema.classes[cn]\n        cls_slots = self.all_slots(cls, cls_slots_first=True)\n        for slot in cls_slots:\n            if all_slots or slot.range in self.schema.classes:\n                rval.append(slot.name)\n\n        return rval"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the modifiers for the given slot.", "response": "def prop_modifier(self, cls: ClassDefinition, slot: SlotDefinition) -> str:\n        \"\"\" Return the modifiers for the slot:\n            (i) - inherited\n            (m) - inherited through mixin\n            (a) - injected\n            (pk) - primary ckey\n\n        @param cls:\n        @param slot:\n        @return:\n        \"\"\"\n        pk = '(pk)' if slot.primary_key else ''\n        inherited = slot.name not in cls.slots\n        mixin = inherited and slot.name in \\\n                [mslot.name for mslot in [self.schema.classes[m] for m in cls.mixins]]\n        injected = cls.name in self.synopsis.applytos and \\\n                   slot.name in [aslot.name for aslot in\n                                 [self.schema.classes[a] for a in sorted(self.synopsis.applytos[cls.name].classrefs)]]\n        return pk + '(a)' if injected else '(m)' if mixin else '(i)' if inherited else ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a ShEx Schema for a biolink model", "response": "def cli(yamlfile, format, output, collections):\n    \"\"\" Generate a ShEx Schema for a  biolink model \"\"\"\n    print(ShExGenerator(yamlfile, format).serialize(output=output, collections=collections))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a shape that represents an RDF list of target_type", "response": "def gen_multivalued_slot(self, target_name_base: str, target_type: IRIREF) -> IRIREF:\n        \"\"\" Generate a shape that represents an RDF list of target_type\n\n        @param target_name_base:\n        @param target_type:\n        @return:\n        \"\"\"\n        list_shape_id = IRIREF(target_name_base + \"__List\")\n        if list_shape_id not in self.list_shapes:\n            list_shape = Shape(id=list_shape_id, closed=True)\n            list_shape.expression = EachOf()\n            expressions = [TripleConstraint(predicate=RDF.first, valueExpr=target_type, min=0, max=1)]\n            targets = ShapeOr()\n            targets.shapeExprs = [(NodeConstraint(values=[RDF.nil])), list_shape_id]\n            expressions.append(TripleConstraint(predicate=RDF.rest, valueExpr=targets))\n            list_shape.expression.expressions = expressions\n            self.shapes.append(list_shape)\n            self.list_shapes.append(list_shape_id)\n        return list_shape_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_prefix(self, ncname: str) -> None:\n        if ncname not in self.prefixmap:\n            uri = cu.expand_uri(ncname + ':', self.curi_maps)\n            if uri and '://' in uri:\n                self.prefixmap[ncname] = uri\n            else:\n                print(f\"Unrecognized prefix: {ncname}\", file=sys.stderr)\n                self.prefixmap[ncname] = f\"http://example.org/unknown/{ncname}/\"", "response": "Add a prefix to the prefix map if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the URI associated with ncname.", "response": "def get_uri(self, ncname: str) -> Optional[str]:\n        \"\"\" Get the URI associated with ncname\n\n        @param ncname:\n        \"\"\"\n        uri = cu.expand_uri(ncname + ':', self.curi_maps)\n        return uri if uri and uri.startswith('http') else None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_mappings(self, defn: Definition, target: Dict) -> None:\n        self.add_id_prefixes(defn)\n        for mapping in defn.mappings:\n            if '://' in mapping:\n                target['@id'] = mapping\n            else:\n                if ':' not in mapping or len(mapping.split(':')) != 2:\n                    raise ValueError(f\"Definition {defn.name} = unrecognized mapping: {mapping}\")\n                ns = mapping.split(':')[0]\n                self.add_prefix(ns)\n                target['@id'] = defn.mappings[0]", "response": "Process any mappings in defn add all of the namespace mappings to the namespace map and add links to the first mapping to the target dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot(self,xdata,ydata=[],logScale=False,disp=True,**kwargs):\n        '''Graphs a line plot.\n        \n        xdata: list of independent variable data. Can optionally include a header, see testGraph.py in https://github.com/Dfenestrator/GooPyCharts for an example.\n        ydata: list of dependent variable data. Can be multidimensional. If xdata includes a header, include a header list on ydata as well.\n        logScale: set to True to set the y axis to log scale.\n        disp: for displaying plots immediately. Set to True by default. Set to False for other operations, then use show() to display the plot.\n        **kwargs: Access to other Google Charts API options. The key is the option name, the value is the option's full JS code.\n        '''\n        \n        #combine data into proper format\n        #check if only 1 vector was sent, then plot against a count\n        if ydata:\n            data = combineData(xdata,ydata,self.xlabel)\n        else:\n            data = combineData(range(len(xdata)),xdata,self.xlabel)\n\n        #determine log scale parameter\n        if logScale:\n            logScaleStr = 'true'\n        else:\n            logScaleStr = 'false'\n\n        #Include other options, supplied by **kwargs\n        other = ''\n\n        for option in kwargs:\n            other += option + ': ' + kwargs[option] + ',\\n'\n\n        #input argument format to template is in dictionary format (see template for where variables are inserted)\n        argDict = { 'data': str(data),\n                    'title':self.title,\n                    'functionName':slugify(self.title),\n                    'height': self.height,\n                    'width': self.width,\n                    'logScaleFlag': logScaleStr,\n                    'ylabel': self.ylabel,\n                    'plotType': 'LineChart',\n                    'numFig': self.numFig,\n                    'other': other}\n\n        self.javascript = templateType(xdata) % argDict\n        \n        if disp:\n            self.dispFile()", "response": "Plots a line chart."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bar(self,xdata,ydata,disp=True,**kwargs):\n        '''Displays a bar graph.\n        \n        xdata: list of bar graph categories/bins. Can optionally include a header, see testGraph_barAndHist.py in https://github.com/Dfenestrator/GooPyCharts for an example.\n        ydata: list of values associated with categories in xdata. If xdata includes a header, include a header list on ydata as well.\n        disp: for displaying plots immediately. Set to True by default. Set to False for other operations, then use show() to display the plot.\n        **kwargs: Access to other Google Charts API options. The key is the option name, the value is the option's full JS code.\n        '''\n                \n        #combine data into proper format\n        data = combineData(xdata,ydata,self.xlabel)\n\n        #Include other options, supplied by **kwargs\n        other = ''\n\n        for option in kwargs:\n            other += option + ': ' + kwargs[option] + ',\\n'\n\n        #input argument format to template is in dictionary format (see template for where variables are inserted)\n        argDict = { 'data':str(data),\n                    'title':self.title,\n                    'functionName':slugify(self.title),\n                    'height':self.height,\n                    'width':self.width,\n                    'logScaleFlag':'false',\n                    'ylabel':self.ylabel,\n                    'plotType':'BarChart',\n                    'numFig':self.numFig,\n                    'other':other}\n\n        self.javascript = templateType(xdata) % argDict\n        \n        if disp:\n            self.dispFile()", "response": "Displays a bar graph."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngraph a histogram. xdata: List of values to bin. Can optionally include a header, see testGraph_barAndHist.py in https://github.com/Dfenestrator/GooPyCharts for an example. disp: for displaying plots immediately. Set to True by default. Set to False for other operations, then use show() to display the plot. **kwargs: Access to other Google Charts API options. The key is the option name, the value is the option's full JS code.", "response": "def hist(self,xdata,disp=True,**kwargs):\n        '''Graphs a histogram.\n        \n        xdata: List of values to bin. Can optionally include a header, see testGraph_barAndHist.py in https://github.com/Dfenestrator/GooPyCharts for an example.\n        disp: for displaying plots immediately. Set to True by default. Set to False for other operations, then use show() to display the plot.\n        **kwargs: Access to other Google Charts API options. The key is the option name, the value is the option's full JS code.\n        '''\n                \n        #combine data into proper format\n        data = [self.xlabel]+xdata\n\n        #Include other options, supplied by **kwargs\n        other = ''\n\n        for option in kwargs:\n            other += option + ': ' + kwargs[option] + ',\\n'\n            \n        #input argument format to template is in dictionary format (see template for where variables are inserted)\n        argDict = { 'data':str(data),\n                    'title':self.title,\n                    'functionName':slugify(self.title),\n                    'height':self.height,\n                    'width':self.width,\n                    'logScaleFlag':'false',\n                    'ylabel':self.ylabel,\n                    'plotType':'Histogram',\n                    'numFig':self.numFig,\n                    'other':other}\n\n        self.javascript = (graphPgTemplateStart+graphPgTemplate_hist+graphPgTemplateEnd) % argDict\n\n        if disp:\n            self.dispFile()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngraphs a line plot and embeds it in a Jupyter notebook.", "response": "def plot_nb(self,xdata,ydata=[],logScale=False):\n        '''Graphs a line plot and embeds it in a Jupyter notebook. See 'help(figure.plot)' for more info.'''\n        self.plot(xdata,ydata,logScale)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scatter_nb(self,xdata,ydata=[],trendline=False):\n        '''Graphs a scatter plot and embeds it in a Jupyter notebook. See 'help(figure.scatter)' for more info.'''\n        self.scatter(xdata,ydata,trendline)", "response": "Graphs a scatter plot and embeds it in a Jupyter notebook."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(text):\n    rv = {}\n    m = META.match(text)\n\n    while m:\n        key = m.group(1)\n        value = m.group(2)\n        value = INDENTATION.sub('\\n', value.strip())\n        rv[key] = value\n        text = text[len(m.group(0)):]\n        m = META.match(text)\n\n    return rv, text", "response": "Parse the given text into metadata and strip it for a Markdown parser."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_dir_walker(recursive, topdown=True, followlinks=False):\n    if recursive:\n        walk = partial(os.walk, topdown=topdown, followlinks=followlinks)\n    else:\n        def walk(path, topdown=topdown, followlinks=followlinks):\n            try:\n                yield next(os.walk(path, topdown=topdown, followlinks=followlinks))\n            except NameError:\n                yield os.walk(path, topdown=topdown, followlinks=followlinks).next() #IGNORE:E1101\n    return walk", "response": "Returns a function that returns a recursive or non - recursive directory walker."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef walk(dir_pathname, recursive=True, topdown=True, followlinks=False):\n    walk_func = get_dir_walker(recursive, topdown, followlinks)\n    for root, dirnames, filenames in walk_func(dir_pathname):\n        yield (root, dirnames, filenames)", "response": "Walks a directory tree optionally recursively."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nenlists all items using their absolute paths in a directory, optionally recursively. :param dir_pathname: The directory to traverse. :param recursive: ``True`` for walking recursively through the directory tree; ``False`` otherwise. :param topdown: Please see the documentation for :func:`os.walk` :param followlinks: Please see the documentation for :func:`os.walk`", "response": "def listdir(dir_pathname,\n            recursive=True,\n            topdown=True,\n            followlinks=False):\n    \"\"\"\n    Enlists all items using their absolute paths in a directory, optionally\n    recursively.\n\n    :param dir_pathname:\n        The directory to traverse.\n    :param recursive:\n        ``True`` for walking recursively through the directory tree;\n        ``False`` otherwise.\n    :param topdown:\n        Please see the documentation for :func:`os.walk`\n    :param followlinks:\n        Please see the documentation for :func:`os.walk`\n    \"\"\"\n    for root, dirnames, filenames\\\n    in walk(dir_pathname, recursive, topdown, followlinks):\n        for dirname in dirnames:\n            yield absolute_path(os.path.join(root, dirname))\n        for filename in filenames:\n            yield absolute_path(os.path.join(root, filename))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_directories(dir_pathname,\n                     recursive=True,\n                     topdown=True,\n                     followlinks=False):\n    \"\"\"\n    Enlists all the directories using their absolute paths within the specified\n    directory, optionally recursively.\n\n    :param dir_pathname:\n        The directory to traverse.\n    :param recursive:\n        ``True`` for walking recursively through the directory tree;\n        ``False`` otherwise.\n    :param topdown:\n        Please see the documentation for :func:`os.walk`\n    :param followlinks:\n        Please see the documentation for :func:`os.walk`\n    \"\"\"\n    for root, dirnames, filenames\\\n    in walk(dir_pathname, recursive, topdown, followlinks):\n        for dirname in dirnames:\n            yield absolute_path(os.path.join(root, dirname))", "response": "Returns an iterator over all the directories in the specified directory tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an iterator over all the files in the specified directory.", "response": "def list_files(dir_pathname,\n               recursive=True,\n               topdown=True,\n               followlinks=False):\n    \"\"\"\n    Enlists all the files using their absolute paths within the specified\n    directory, optionally recursively.\n\n    :param dir_pathname:\n        The directory to traverse.\n    :param recursive:\n        ``True`` for walking recursively through the directory tree;\n        ``False`` otherwise.\n    :param topdown:\n        Please see the documentation for :func:`os.walk`\n    :param followlinks:\n        Please see the documentation for :func:`os.walk`\n    \"\"\"\n    for root, dirnames, filenames\\\n    in walk(dir_pathname, recursive, topdown, followlinks):\n        for filename in filenames:\n            yield absolute_path(os.path.join(root, filename))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_path_against(pathname, patterns, case_sensitive=True):\n    if case_sensitive:\n        match_func = fnmatchcase\n        pattern_transform_func = (lambda w: w)\n    else:\n        match_func = fnmatch\n        pathname = pathname.lower()\n        pattern_transform_func = _string_lower\n    for pattern in set(patterns):\n        pattern = pattern_transform_func(pattern)\n        if match_func(pathname, pattern):\n            return True\n    return False", "response": "Matches a pathname against a list of patterns."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _match_path(pathname,\n                included_patterns,\n                excluded_patterns,\n                case_sensitive=True):\n    \"\"\"Internal function same as :func:`match_path` but does not check arguments.\n\n    Doctests::\n        >>> _match_path(\"/users/gorakhargosh/foobar.py\", [\"*.py\"], [\"*.PY\"], True)\n        True\n        >>> _match_path(\"/users/gorakhargosh/FOOBAR.PY\", [\"*.py\"], [\"*.PY\"], True)\n        False\n        >>> _match_path(\"/users/gorakhargosh/foobar/\", [\"*.py\"], [\"*.txt\"], False)\n        False\n        >>> _match_path(\"/users/gorakhargosh/FOOBAR.PY\", [\"*.py\"], [\"*.PY\"], False)\n        Traceback (most recent call last):\n            ...\n        ValueError: conflicting patterns `set(['*.py'])` included and excluded\n    \"\"\"\n    if not case_sensitive:\n        included_patterns = set(map(_string_lower, included_patterns))\n        excluded_patterns = set(map(_string_lower, excluded_patterns))\n    else:\n        included_patterns = set(included_patterns)\n        excluded_patterns = set(excluded_patterns)\n    common_patterns = included_patterns & excluded_patterns\n    if common_patterns:\n        raise ValueError('conflicting patterns `%s` included and excluded'\\\n                         % common_patterns)\n    return (match_path_against(pathname, included_patterns, case_sensitive)\\\n            and not match_path_against(pathname, excluded_patterns,\n                                       case_sensitive))", "response": "Internal function that matches a pathname against a set of patterns."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match_path(pathname,\n               included_patterns=None,\n               excluded_patterns=None,\n               case_sensitive=True):\n    \"\"\"\n    Matches a pathname against a set of acceptable and ignored patterns.\n\n    :param pathname:\n        A pathname which will be matched against a pattern.\n    :param included_patterns:\n        Allow filenames matching wildcard patterns specified in this list.\n        If no pattern is specified, the function treats the pathname as\n        a match_path.\n    :param excluded_patterns:\n        Ignores filenames matching wildcard patterns specified in this list.\n        If no pattern is specified, the function treats the pathname as\n        a match_path.\n    :param case_sensitive:\n        ``True`` if matching should be case-sensitive; ``False`` otherwise.\n    :returns:\n        ``True`` if the pathname matches; ``False`` otherwise.\n    :raises:\n        ValueError if included patterns and excluded patterns contain the\n        same pattern.\n\n    Doctests::\n        >>> match_path(\"/Users/gorakhargosh/foobar.py\")\n        True\n        >>> match_path(\"/Users/gorakhargosh/foobar.py\", case_sensitive=False)\n        True\n        >>> match_path(\"/users/gorakhargosh/foobar.py\", [\"*.py\"], [\"*.PY\"], True)\n        True\n        >>> match_path(\"/users/gorakhargosh/FOOBAR.PY\", [\"*.py\"], [\"*.PY\"], True)\n        False\n        >>> match_path(\"/users/gorakhargosh/foobar/\", [\"*.py\"], [\"*.txt\"], False)\n        False\n        >>> match_path(\"/users/gorakhargosh/FOOBAR.PY\", [\"*.py\"], [\"*.PY\"], False)\n        Traceback (most recent call last):\n            ...\n        ValueError: conflicting patterns `set(['*.py'])` included and excluded\n    \"\"\"\n    included = [\"*\"] if included_patterns is None else included_patterns\n    excluded = [] if excluded_patterns is None else excluded_patterns\n    return _match_path(pathname, included, excluded, case_sensitive)", "response": "Matches a pathname against a set of acceptable and ignored patterns."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfilter a set of paths based on acceptable patterns and ignored patterns.", "response": "def filter_paths(pathnames,\n                 included_patterns=None,\n                 excluded_patterns=None,\n                 case_sensitive=True):\n    \"\"\"\n    Filters from a set of paths based on acceptable patterns and\n    ignorable patterns.\n\n    :param pathnames:\n        A list of path names that will be filtered based on matching and\n        ignored patterns.\n    :param included_patterns:\n        Allow filenames matching wildcard patterns specified in this list.\n        If no pattern list is specified, [\"*\"] is used as the default pattern,\n        which matches all files.\n    :param excluded_patterns:\n        Ignores filenames matching wildcard patterns specified in this list.\n        If no pattern list is specified, no files are ignored.\n    :param case_sensitive:\n        ``True`` if matching should be case-sensitive; ``False`` otherwise.\n    :returns:\n        A list of pathnames that matched the allowable patterns and passed\n        through the ignored patterns.\n\n    Doctests::\n        >>> pathnames = set([\"/users/gorakhargosh/foobar.py\", \"/var/cache/pdnsd.status\", \"/etc/pdnsd.conf\", \"/usr/local/bin/python\"])\n        >>> set(filter_paths(pathnames)) == pathnames\n        True\n        >>> set(filter_paths(pathnames, case_sensitive=False)) == pathnames\n        True\n        >>> set(filter_paths(pathnames, [\"*.py\", \"*.conf\"], [\"*.status\"], case_sensitive=True)) == set([\"/users/gorakhargosh/foobar.py\", \"/etc/pdnsd.conf\"])\n        True\n    \"\"\"\n    included = [\"*\"] if included_patterns is None else included_patterns\n    excluded = [] if excluded_patterns is None else excluded_patterns\n\n    for pathname in pathnames:\n        # We don't call the public match_path because it checks arguments\n        # and sets default values if none are found. We're already doing that\n        # above.\n        if _match_path(pathname, included, excluded, case_sensitive):\n            yield pathname"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmatch a set of paths based on acceptable patterns and ignored patterns.", "response": "def match_any_paths(pathnames,\n                    included_patterns=None,\n                    excluded_patterns=None,\n                    case_sensitive=True):\n    \"\"\"\n    Matches from a set of paths based on acceptable patterns and\n    ignorable patterns.\n\n    :param pathnames:\n        A list of path names that will be filtered based on matching and\n        ignored patterns.\n    :param included_patterns:\n        Allow filenames matching wildcard patterns specified in this list.\n        If no pattern list is specified, [\"*\"] is used as the default pattern,\n        which matches all files.\n    :param excluded_patterns:\n        Ignores filenames matching wildcard patterns specified in this list.\n        If no pattern list is specified, no files are ignored.\n    :param case_sensitive:\n        ``True`` if matching should be case-sensitive; ``False`` otherwise.\n    :returns:\n        ``True`` if any of the paths matches; ``False`` otherwise.\n\n    Doctests::\n        >>> pathnames = set([\"/users/gorakhargosh/foobar.py\", \"/var/cache/pdnsd.status\", \"/etc/pdnsd.conf\", \"/usr/local/bin/python\"])\n        >>> match_any_paths(pathnames)\n        True\n        >>> match_any_paths(pathnames, case_sensitive=False)\n        True\n        >>> match_any_paths(pathnames, [\"*.py\", \"*.conf\"], [\"*.status\"], case_sensitive=True)\n        True\n        >>> match_any_paths(pathnames, [\"*.txt\"], case_sensitive=False)\n        False\n        >>> match_any_paths(pathnames, [\"*.txt\"], case_sensitive=True)\n        False\n    \"\"\"\n    included = [\"*\"] if included_patterns is None else included_patterns\n    excluded = [] if excluded_patterns is None else excluded_patterns\n\n    for pathname in pathnames:\n        # We don't call the public match_path because it checks arguments\n        # and sets default values if none are found. We're already doing that\n        # above.\n        if _match_path(pathname, included, excluded, case_sensitive):\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if the pathname matches any of the given patterns.", "response": "def match_patterns(pathname, patterns):\n    \"\"\"Returns ``True`` if the pathname matches any of the given patterns.\"\"\"\n    for pattern in patterns:\n        if fnmatch(pathname, pattern):\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering from a set of paths based on acceptable patterns and ignore_patterns.", "response": "def filter_paths(pathnames, patterns=None, ignore_patterns=None):\n    \"\"\"Filters from a set of paths based on acceptable patterns and\n    ignorable patterns.\"\"\"\n    result = []\n    if patterns is None:\n        patterns = ['*']\n    if ignore_patterns is None:\n        ignore_patterns = []\n    for pathname in pathnames:\n        if match_patterns(pathname, patterns) and not match_patterns(pathname, ignore_patterns):\n            result.append(pathname)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_team(sport, team):\n    team_pattern = re.compile(team, re.IGNORECASE)\n\n    supported_sports = ['baseball', 'football', 'hockey', 'basketball']\n    if sport not in supported_sports:\n        raise errors.StatsNotFound(sport)\n    elif sport == constants.FOOTBALL:\n        sport = 'pro-football'\n\n    base_url = 'https://www.{}-reference.com/teams/'.format(sport)\n    table_id = 'active_franchises' if sport == 'hockey' else 'teams_active'\n    links = SoupStrainer('table', {'id': table_id})\n    soup = BeautifulSoup(requests.get(base_url).content, 'html.parser', parse_only=links)\n\n    team_info_raw = _get_team_info_raw(soup, base_url, team_pattern, team, sport)\n\n    if sport == constants.BASEBALL:\n        team_info = {\n            'name': team_info_raw[0],\n            'record': team_info_raw[9],\n            'seasons': team_info_raw[6:7][0],\n            'playoff_app': team_info_raw[11],\n            'pennants': team_info_raw[13],\n            'champs': team_info_raw[15],\n            'leaders': ' '.join(team_info_raw[16:18])\n        }\n        return Team(team_info)\n\n    elif sport == constants.BASKETBALL:\n        team_info = {\n            'name': team_info_raw[0],\n            'record': team_info_raw[11].split(',')[0],\n            'seasons': team_info_raw[7].replace(';', ''),\n            'playoff_app': team_info_raw[14],\n            'champs': team_info_raw[17]\n        }\n        return Team(team_info)\n\n    elif sport == 'pro-football':\n        team_info = {\n            'name': team_info_raw[0],\n            'seasons': team_info_raw[2].split()[1],\n            'record': team_info_raw[4],\n            'playoff_record': team_info_raw[5].split()[2],\n            'super_bowls': team_info_raw[7],\n            'champs': team_info_raw[10],\n            'leaders': team_info_raw[11:17]\n        }\n        return Team(team_info)\n\n    elif sport == constants.HOCKEY:\n        team_info = {\n            'name': team_info_raw[0],\n            'record': team_info_raw[9],\n            'points': team_info_raw[10][1:-1],\n            'seasons': team_info_raw[2].split()[1],\n            'playoff_app': team_info_raw[3].split()[3],\n            'playoff_record': team_info_raw[7].split()[2],\n            'champs': team_info_raw[5],\n            'leaders': [\n                team_info_raw[11:13],\n                ' '.join(team_info_raw[13:15]),\n                ' '.join(team_info_raw[15:17])\n            ]\n        }\n        return Team(team_info)", "response": "Get extra info that pertains to a certain team."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the raw data of a team by looking through the html page to gather the raw data about it.", "response": "def _get_team_info_raw(soup, base_url, team_pattern, team, sport):\n    \"\"\"\n    Parses through html page to gather raw data about team\n\n    :param soup: BeautifulSoup object containing html to be parsed\n    :param base_url: Pre-formatted url that is formatted depending on sport\n    :param team_pattern: Compiled regex pattern of team name/city\n    :param team: Name of the team that is being searched for\n    :param sport: Sport that is being searched for\n    :return: List containing raw data of team\n    \"\"\"\n    team_url = None\n    team_name = None\n    for link in soup.find_all('a'):\n        if re.search(team_pattern, link.string):\n            team_name = link.string\n            team_url = base_url.replace('/teams/', link['href'])\n\n    if team_url is not None and team_name is not None:\n        team_soup = BeautifulSoup(requests.get(team_url).content, 'html.parser')\n        team_info_raw = team_soup.find('div', id='meta').contents[3].get_text().split('\\n')\n        team_info_raw = [x.replace('\\t', '') for x in team_info_raw]\n        team_info_raw = [x.strip() for x in team_info_raw if x != '']\n        team_info_raw[0] = team_name\n        return team_info_raw\n    else:\n        raise errors.TeamNotFoundError(sport, team)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrequest XML data from scorespro. com .", "response": "def _request_xml(sport):\n    \"\"\"\n    Request XML data from scorespro.com\n\n    :param sport: sport being played\n    :type sport: string\n    :return: XML data\n    :rtype: string\n    \"\"\"\n    url = 'http://www.scorespro.com/rss2/live-{}.xml'.format(sport)\n    r = requests.get(url)\n    if r.ok:\n        return _load_xml(r.content)\n    else:\n        raise errors.SportError(sport)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_match_info(match, soccer=False):\n    match_info = {}\n\n    i_open = match.index('(')\n    i_close = match.index(')')\n    match_info['league'] = match[i_open + 1:i_close].strip()\n\n    match = match[i_close + 1:]\n    i_vs = match.index('vs')\n    i_colon = match.index(':')\n    match_info['home_team'] = match[0:i_vs].replace('#', ' ').strip()\n    match_info['away_team'] = match[i_vs + 2:i_colon].replace('#', ' ').strip()\n    match = match[i_colon:]\n\n    if soccer:\n        i_hyph = match.index('-')\n        match_info['match_score'] = match[1:i_hyph + 2].strip()\n        match = match[i_hyph + 1:]\n        i_hyph = match.index('-')\n        match_info['match_time'] = match[i_hyph + 1:].strip()\n    else:\n        match_info['match_score'] = match[1:].strip()\n\n    return match_info", "response": "Parse a string containing info of a specific match"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget live scores for all matches in a particular sport", "response": "def get_sport(sport):\n    \"\"\"\n    Get live scores for all matches in a particular sport\n\n    :param sport: the sport being played\n    :type sport: string\n    :return: List containing Match objects\n    :rtype: list\n    \"\"\"\n    sport = sport.lower()\n    data = _request_xml(sport)\n\n    matches = []\n    for match in data:\n        if sport == constants.SOCCER:\n            desc = match.find('description').text\n            match_info = _parse_match_info(desc, soccer=True)\n        else:\n            desc = match.find('title').text\n            match_info = _parse_match_info(desc)\n            match_info['match_time'] = match.find('description').text\n\n        match_info['match_date'] = match.find('pubDate').text\n        match_info['match_link'] = match.find('guid').text\n\n        matches.append(Match(sport, match_info))\n\n    return matches"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a single match", "response": "def get_match(sport, team1, team2):\n    \"\"\"\n    Get live scores for a single match\n\n    :param sport: the sport being played\n    :type sport: string\n    :param team1: first team participating in the match\n    :ttype team1: string\n    :param team2: second team participating in the match\n    :type team2: string\n    :return: A specific match\n    :rtype: Match\n    \"\"\"\n    sport = sport.lower()\n    team1_pattern = re.compile(team1, re.I)\n    team2_pattern = re.compile(team2, re.I)\n\n    matches = get_sport(sport)\n    for match in matches:\n        if re.search(team1_pattern, match.home_team) or re.search(team1_pattern, match.away_team) \\\n                and re.search(team2_pattern, match.away_team) or re.search(team2_pattern, match.home_team):\n            return match\n\n    raise errors.MatchError(sport, [team1, team2])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending a metric to InfluxDB when a User object is deleted.", "response": "def user_post_delete_handler(sender, **kwargs):\n    \"\"\"Sends a metric to InfluxDB when a User object is deleted.\"\"\"\n    total = get_user_model().objects.all().count()\n    data = [{\n        'measurement': 'django_auth_user_delete',\n        'tags': {'host': settings.INFLUXDB_TAGS_HOST, },\n        'fields': {'value': 1, },\n        'time': timezone.now().isoformat(),\n    }]\n    write_points(data)\n\n    data = [{\n        'measurement': 'django_auth_user_count',\n        'tags': {'host': settings.INFLUXDB_TAGS_HOST, },\n        'fields': {'value': total, },\n        'time': timezone.now().isoformat(),\n    }]\n    write_points(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef user_post_save_handler(**kwargs):\n    if kwargs.get('created'):\n        total = get_user_model().objects.all().count()\n        data = [{\n            'measurement': 'django_auth_user_create',\n            'tags': {'host': settings.INFLUXDB_TAGS_HOST, },\n            'fields': {'value': 1, },\n            'time': timezone.now().isoformat(),\n        }]\n        write_points(data)\n\n        data = [{\n            'measurement': 'django_auth_user_count',\n            'tags': {'host': settings.INFLUXDB_TAGS_HOST, },\n            'fields': {'value': total, },\n            'time': timezone.now().isoformat(),\n        }]\n        write_points(data)", "response": "Sends a metric to InfluxDB when a new User object is created."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef annotate(text, gcube_token=None, lang=DEFAULT_LANG, api=DEFAULT_TAG_API,\n             long_text=DEFAULT_LONG_TEXT):\n    '''\n    Annotate a text, linking it to Wikipedia entities.\n    :param text: the text to annotate.\n    :param gcube_token: the authentication token provided by the D4Science infrastructure.\n    :param lang: the Wikipedia language.\n    :param api: the API endpoint.\n    :param long_text: long_text parameter (see TagMe documentation).\n    '''\n    payload = [(\"text\", text.encode(\"utf-8\")),\n               (\"long_text\", long_text),\n               (\"lang\", lang)]\n    json_response = _issue_request(api, payload, gcube_token)\n    return AnnotateResponse(json_response) if json_response else None", "response": "Annotate a text with a Wikipedia entity."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding possible mentions in a text.", "response": "def mentions(text, gcube_token=None, lang=DEFAULT_LANG, api=DEFAULT_SPOT_API):\n    '''\n    Find possible mentions in a text, do not link them to any entity.\n    :param text: the text where to find mentions.\n    :param gcube_token: the authentication token provided by the D4Science infrastructure.\n    :param lang: the Wikipedia language.\n    :param api: the API endpoint.\n    '''\n    payload = [(\"text\", text.encode(\"utf-8\")),\n               (\"lang\", lang.encode(\"utf-8\"))]\n    json_response = _issue_request(api, payload, gcube_token)\n    return MentionsResponse(json_response) if json_response else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef relatedness_wid(wid_pairs, gcube_token=None, lang=DEFAULT_LANG, api=DEFAULT_REL_API):\n    '''\n    Get the semantic relatedness among pairs of entities. Entities are indicated by their\n    Wikipedia ID (an integer).\n    :param wid_pairs: either one pair or a list of pairs of Wikipedia IDs.\n    :param gcube_token: the authentication token provided by the D4Science infrastructure.\n    :param lang: the Wikipedia language.\n    :param api: the API endpoint.\n    '''\n    return _relatedness(\"id\", wid_pairs, gcube_token, lang, api)", "response": "Get the semantic relatedness among pairs of entities."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the semantic relatedness among pairs of entity titles.", "response": "def relatedness_title(tt_pairs, gcube_token=None, lang=DEFAULT_LANG, api=DEFAULT_REL_API):\n    '''\n    Get the semantic relatedness among pairs of entities. Entities are indicated by their\n    Wikipedia ID (an integer).\n    :param tt_pairs: either one pair or a list of pairs of entity titles.\n    :param gcube_token: the authentication token provided by the D4Science infrastructure.\n    :param lang: the Wikipedia language.\n    :param api: the API endpoint.\n    '''\n    return _relatedness(\"tt\", tt_pairs, gcube_token, lang, api)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_annotations(self, min_rho=None):\n        '''\n        Get the list of annotations found.\n        :param min_rho: if set, only get entities with a rho-score (confidence) higher than this.\n        '''\n        return (a for a in self.annotations if min_rho is None or a.score > min_rho)", "response": "Get the list of annotations found in this object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the list of mentions found.", "response": "def get_mentions(self, min_lp=None):\n        '''\n        Get the list of mentions found.\n        :param min_lp: if set, only get mentions with a link probability higher than this.\n        '''\n        return (m for m in self.mentions if min_lp is None or m.linkprob > min_lp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an InfluxDBClient instance.", "response": "def get_client():\n    \"\"\"Returns an ``InfluxDBClient`` instance.\"\"\"\n    return InfluxDBClient(\n        settings.INFLUXDB_HOST,\n        settings.INFLUXDB_PORT,\n        settings.INFLUXDB_USER,\n        settings.INFLUXDB_PASSWORD,\n        settings.INFLUXDB_DATABASE,\n        timeout=settings.INFLUXDB_TIMEOUT,\n        ssl=getattr(settings, 'INFLUXDB_SSL', False),\n        verify_ssl=getattr(settings, 'INFLUXDB_VERIFY_SSL', False),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite a series to influxdb.", "response": "def write_points(data, force_disable_threading=False):\n    \"\"\"\n    Writes a series to influxdb.\n\n    :param data: Array of dicts, as required by\n      https://github.com/influxdb/influxdb-python\n    :param force_disable_threading: When being called from the Celery task, we\n      set this to `True` so that the user doesn't accidentally use Celery and\n      threading at the same time.\n\n    \"\"\"\n    if getattr(settings, 'INFLUXDB_DISABLED', False):\n        return\n\n    client = get_client()\n    use_threading = getattr(settings, 'INFLUXDB_USE_THREADING', False)\n    if force_disable_threading:\n        use_threading = False\n    if use_threading is True:\n        thread = Thread(target=process_points, args=(client, data, ))\n        thread.start()\n    else:\n        process_points(client, data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef process_points(client, data):  # pragma: no cover\n    try:\n        client.write_points(data)\n    except Exception:\n        if getattr(settings, 'INFLUXDB_FAIL_SILENTLY', True):\n            logger.exception('Error while writing data points')\n        else:\n            raise", "response": "Method to be called via threading module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a complete graph from the list of node ids.", "response": "def _create_complete_graph(node_ids):\n    \"\"\"Create a complete graph from the list of node ids.\n\n    Args:\n        node_ids: a list of node ids\n\n    Returns:\n        An undirected graph (as a networkx.Graph)\n    \"\"\"\n    g = nx.Graph()\n    g.add_nodes_from(node_ids)\n    for (i, j) in combinations(node_ids, 2):\n        g.add_edge(i, j)\n    return g"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef estimate_skeleton(indep_test_func, data_matrix, alpha, **kwargs):\n\n    def method_stable(kwargs):\n        return ('method' in kwargs) and kwargs['method'] == \"stable\"\n\n    node_ids = range(data_matrix.shape[1])\n    node_size = data_matrix.shape[1]\n    sep_set = [[set() for i in range(node_size)] for j in range(node_size)]\n    if 'init_graph' in kwargs:\n        g = kwargs['init_graph']\n        if not isinstance(g, nx.Graph):\n            raise ValueError\n        elif not g.number_of_nodes() == len(node_ids):\n            raise ValueError('init_graph not matching data_matrix shape')\n        for (i, j) in combinations(node_ids, 2):\n            if not g.has_edge(i, j):\n                sep_set[i][j] = None\n                sep_set[j][i] = None\n    else:\n        g = _create_complete_graph(node_ids)\n\n    l = 0\n    while True:\n        cont = False\n        remove_edges = []\n        for (i, j) in permutations(node_ids, 2):\n            adj_i = list(g.neighbors(i))\n            if j not in adj_i:\n                continue\n            else:\n                adj_i.remove(j)\n            if len(adj_i) >= l:\n                _logger.debug('testing %s and %s' % (i,j))\n                _logger.debug('neighbors of %s are %s' % (i, str(adj_i)))\n                if len(adj_i) < l:\n                    continue\n                for k in combinations(adj_i, l):\n                    _logger.debug('indep prob of %s and %s with subset %s'\n                                  % (i, j, str(k)))\n                    p_val = indep_test_func(data_matrix, i, j, set(k),\n                                            **kwargs)\n                    _logger.debug('p_val is %s' % str(p_val))\n                    if p_val > alpha:\n                        if g.has_edge(i, j):\n                            _logger.debug('p: remove edge (%s, %s)' % (i, j))\n                            if method_stable(kwargs):\n                                remove_edges.append((i, j))\n                            else:\n                                g.remove_edge(i, j)\n                        sep_set[i][j] |= set(k)\n                        sep_set[j][i] |= set(k)\n                        break\n                cont = True\n        l += 1\n        if method_stable(kwargs):\n            g.remove_edges_from(remove_edges)\n        if cont is False:\n            break\n        if ('max_reach' in kwargs) and (l > kwargs['max_reach']):\n            break\n\n    return (g, sep_set)", "response": "Estimate a skeleton graph from the statistis information."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nestimating a CPDAG from the given skeleton graph and separation sets returning a CPDAG.", "response": "def estimate_cpdag(skel_graph, sep_set):\n    \"\"\"Estimate a CPDAG from the skeleton graph and separation sets\n    returned by the estimate_skeleton() function.\n\n    Args:\n        skel_graph: A skeleton graph (an undirected networkx.Graph).\n        sep_set: An 2D-array of separation set.\n            The contents look like something like below.\n                sep_set[i][j] = set([k, l, m])\n\n    Returns:\n        An estimated DAG.\n    \"\"\"\n    dag = skel_graph.to_directed()\n    node_ids = skel_graph.nodes()\n    for (i, j) in combinations(node_ids, 2):\n        adj_i = set(dag.successors(i))\n        if j in adj_i:\n            continue\n        adj_j = set(dag.successors(j))\n        if i in adj_j:\n            continue\n        if sep_set[i][j] is None:\n            continue\n        common_k = adj_i & adj_j\n        for k in common_k:\n            if k not in sep_set[i][j]:\n                if dag.has_edge(k, i):\n                    _logger.debug('S: remove edge (%s, %s)' % (k, i))\n                    dag.remove_edge(k, i)\n                if dag.has_edge(k, j):\n                    _logger.debug('S: remove edge (%s, %s)' % (k, j))\n                    dag.remove_edge(k, j)\n\n    def _has_both_edges(dag, i, j):\n        return dag.has_edge(i, j) and dag.has_edge(j, i)\n\n    def _has_any_edge(dag, i, j):\n        return dag.has_edge(i, j) or dag.has_edge(j, i)\n\n    def _has_one_edge(dag, i, j):\n        return ((dag.has_edge(i, j) and (not dag.has_edge(j, i))) or\n                (not dag.has_edge(i, j)) and dag.has_edge(j, i))\n\n    def _has_no_edge(dag, i, j):\n        return (not dag.has_edge(i, j)) and (not dag.has_edge(j, i))\n\n    # For all the combination of nodes i and j, apply the following\n    # rules.\n    old_dag = dag.copy()\n    while True:\n        for (i, j) in combinations(node_ids, 2):\n            # Rule 1: Orient i-j into i->j whenever there is an arrow k->i\n            # such that k and j are nonadjacent.\n            #\n            # Check if i-j.\n            if _has_both_edges(dag, i, j):\n                # Look all the predecessors of i.\n                for k in dag.predecessors(i):\n                    # Skip if there is an arrow i->k.\n                    if dag.has_edge(i, k):\n                        continue\n                    # Skip if k and j are adjacent.\n                    if _has_any_edge(dag, k, j):\n                        continue\n                    # Make i-j into i->j\n                    _logger.debug('R1: remove edge (%s, %s)' % (j, i))\n                    dag.remove_edge(j, i)\n                    break\n\n            # Rule 2: Orient i-j into i->j whenever there is a chain\n            # i->k->j.\n            #\n            # Check if i-j.\n            if _has_both_edges(dag, i, j):\n                # Find nodes k where k is i->k.\n                succs_i = set()\n                for k in dag.successors(i):\n                    if not dag.has_edge(k, i):\n                        succs_i.add(k)\n                # Find nodes j where j is k->j.\n                preds_j = set()\n                for k in dag.predecessors(j):\n                    if not dag.has_edge(j, k):\n                        preds_j.add(k)\n                # Check if there is any node k where i->k->j.\n                if len(succs_i & preds_j) > 0:\n                    # Make i-j into i->j\n                    _logger.debug('R2: remove edge (%s, %s)' % (j, i))\n                    dag.remove_edge(j, i)\n\n            # Rule 3: Orient i-j into i->j whenever there are two chains\n            # i-k->j and i-l->j such that k and l are nonadjacent.\n            #\n            # Check if i-j.\n            if _has_both_edges(dag, i, j):\n                # Find nodes k where i-k.\n                adj_i = set()\n                for k in dag.successors(i):\n                    if dag.has_edge(k, i):\n                        adj_i.add(k)\n                # For all the pairs of nodes in adj_i,\n                for (k, l) in combinations(adj_i, 2):\n                    # Skip if k and l are adjacent.\n                    if _has_any_edge(dag, k, l):\n                        continue\n                    # Skip if not k->j.\n                    if dag.has_edge(j, k) or (not dag.has_edge(k, j)):\n                        continue\n                    # Skip if not l->j.\n                    if dag.has_edge(j, l) or (not dag.has_edge(l, j)):\n                        continue\n                    # Make i-j into i->j.\n                    _logger.debug('R3: remove edge (%s, %s)' % (j, i))\n                    dag.remove_edge(j, i)\n                    break\n\n            # Rule 4: Orient i-j into i->j whenever there are two chains\n            # i-k->l and k->l->j such that k and j are nonadjacent.\n            #\n            # However, this rule is not necessary when the PC-algorithm\n            # is used to estimate a DAG.\n\n        if nx.is_isomorphic(dag, old_dag):\n            break\n        old_dag = dag.copy()\n\n    return dag"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the high water mark on the given socket.", "response": "def set_high_water_mark(socket, config):\n    \"\"\" Set a high water mark on the zmq socket.  Do so in a way that is\n    cross-compatible with zeromq2 and zeromq3.\n    \"\"\"\n\n    if config['high_water_mark']:\n        if hasattr(zmq, 'HWM'):\n            # zeromq2\n            socket.setsockopt(zmq.HWM, config['high_water_mark'])\n        else:\n            # zeromq3\n            socket.setsockopt(zmq.SNDHWM, config['high_water_mark'])\n            socket.setsockopt(zmq.RCVHWM, config['high_water_mark'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_tcp_keepalive(socket, config):\n\n    keepalive_options = {\n        # Map fedmsg config keys to zeromq socket constants\n        'zmq_tcp_keepalive': 'TCP_KEEPALIVE',\n        'zmq_tcp_keepalive_cnt': 'TCP_KEEPALIVE_CNT',\n        'zmq_tcp_keepalive_idle': 'TCP_KEEPALIVE_IDLE',\n        'zmq_tcp_keepalive_intvl': 'TCP_KEEPALIVE_INTVL',\n    }\n    for key, const in keepalive_options.items():\n        if key in config:\n            attr = getattr(zmq, const, None)\n            if attr:\n                socket.setsockopt(attr, config[key])", "response": "Sets the TCP keepalive options on the socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the TCP reconnect options on the given socket.", "response": "def set_tcp_reconnect(socket, config):\n    \"\"\" Set a series of TCP reconnect options on the socket if\n    and only if\n      1) they are specified explicitly in the config and\n      2) the version of pyzmq has been compiled with support\n\n    Once our fedmsg bus grew to include many hundreds of endpoints, we started\n    notices a *lot* of SYN-ACKs in the logs.  By default, if an endpoint is\n    unavailable, zeromq will attempt to reconnect every 100ms until it gets a\n    connection.  With this code, you can reconfigure that to back off\n    exponentially to some max delay (like 1000ms) to reduce reconnect storm\n    spam.\n\n    See the following\n      - http://api.zeromq.org/3-2:zmq-setsockopt\n    \"\"\"\n\n    reconnect_options = {\n        # Map fedmsg config keys to zeromq socket constants\n        'zmq_reconnect_ivl': 'RECONNECT_IVL',\n        'zmq_reconnect_ivl_max': 'RECONNECT_IVL_MAX',\n    }\n    for key, const in reconnect_options.items():\n        if key in config:\n            attr = getattr(zmq, const, None)\n            if attr:\n                socket.setsockopt(attr, config[key])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the IRCBotConsumer class from a string of the form fedmsg. consumers. ircbot. IRCBotConsumer.", "response": "def load_class(location):\n    \"\"\" Take a string of the form 'fedmsg.consumers.ircbot:IRCBotConsumer'\n    and return the IRCBotConsumer class.\n    \"\"\"\n    mod_name, cls_name = location = location.strip().split(':')\n    tokens = mod_name.split('.')\n\n    fromlist = '[]'\n    if len(tokens) > 1:\n        fromlist = '.'.join(tokens[:-1])\n\n    module = __import__(mod_name, fromlist=fromlist)\n\n    try:\n        return getattr(module, cls_name)\n    except AttributeError:\n        raise ImportError(\"%r not found in %r\" % (cls_name, mod_name))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nqueries a dict with dotted notation. Returns an OrderedDict.", "response": "def dict_query(dic, query):\n    \"\"\" Query a dict with 'dotted notation'.  Returns an OrderedDict.\n\n    A query of \"foo.bar.baz\" would retrieve 'wat' from this::\n\n        dic = {\n            'foo': {\n                'bar': {\n                    'baz': 'wat',\n                }\n            }\n        }\n\n    Multiple queries can be specified if comma-separated.  For instance, the\n    query \"foo.bar.baz,foo.bar.something_else\" would return this::\n\n        OrderedDict({\n            \"foo.bar.baz\": \"wat\",\n            \"foo.bar.something_else\": None,\n        })\n\n    \"\"\"\n\n    if not isinstance(query, six.string_types):\n        raise ValueError(\"query must be a string, not %r\" % type(query))\n\n    def _browse(tokens, d):\n        \"\"\" Recurse through a dict to retrieve a value. \"\"\"\n        current, rest = tokens[0], tokens[1:]\n\n        if not rest:\n            return d.get(current, None)\n\n        if current in d:\n            if isinstance(d[current], dict):\n                return _browse(rest, d[current])\n            elif rest:\n                return None\n            else:\n                return d[current]\n\n    keys = [key.strip().split('.') for key in query.split(',')]\n    return OrderedDict([\n        ('.'.join(tokens), _browse(tokens, dic)) for tokens in keys\n    ])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cowsay_output(message):\n    command = 'cowsay \"%s\"' % message\n    ret = subprocess.Popen(\n        command, shell=True, stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)\n    output, error = ret.communicate()\n    return output, error", "response": "Invoke a shell command to print cowsay output."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dict representation of the object.", "response": "def to_json(obj, seen=None):\n    \"\"\" Returns a dict representation of the object.\n\n    Recursively evaluates to_json(...) on its relationships.\n    \"\"\"\n\n    if not seen:\n        seen = []\n\n    properties = list(class_mapper(type(obj)).iterate_properties)\n    relationships = [\n        p.key for p in properties if type(p) is RelationshipProperty\n    ]\n    attrs = [\n        p.key for p in properties if p.key not in relationships\n    ]\n\n    d = dict([(attr, getattr(obj, attr)) for attr in attrs])\n\n    for attr in relationships:\n        d[attr] = expand(obj, getattr(obj, attr), seen)\n\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the to_json or id of a sqlalchemy relationship.", "response": "def expand(obj, relation, seen):\n    \"\"\" Return the to_json or id of a sqlalchemy relationship. \"\"\"\n\n    if hasattr(relation, 'all'):\n        relation = relation.all()\n\n    if hasattr(relation, '__iter__'):\n        return [expand(obj, item, seen) for item in relation]\n\n    if type(relation) not in seen:\n        return to_json(relation, seen + [type(obj)])\n    else:\n        return relation.id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef consume(self, msg):\n        msg['body'] = crypto.sign(msg['body'], **self.hub.config)\n        super(SigningRelayConsumer, self).consume(msg)", "response": "Sign the message prior to sending it."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _backlog(self, data):\n\n        try:\n            data = json.loads(data)\n        except ValueError as e:\n            self.log.info(\"Status contents are %r\" % data)\n            self.log.exception(e)\n            self.log.info(\"Skipping backlog retrieval.\")\n            return\n\n        last = data['message']['body']\n        if isinstance(last, str):\n            last = json.loads(last)\n\n        then = last['timestamp']\n        now = int(time.time())\n\n        retrieved = 0\n        for message in self.get_datagrepper_results(then, now):\n            # Take the messages from datagrepper and remove any keys that were\n            # artificially added to the message.  The presence of these would\n            # otherwise cause message crypto validation to fail.\n            message = fedmsg.crypto.utils.fix_datagrepper_message(message)\n\n            if message['msg_id'] != last['msg_id']:\n                retrieved = retrieved + 1\n                self.incoming.put(dict(body=message, topic=message['topic']))\n            else:\n                self.log.warning(\"Already seen %r; Skipping.\" % last['msg_id'])\n\n        self.log.info(\"Retrieved %i messages from datagrepper.\" % retrieved)", "response": "Get all the datagrepper messages between then and now."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate the message before the consumer processes it.", "response": "def validate(self, message):\n        \"\"\"\n        Validate the message before the consumer processes it.\n\n        This needs to raise an exception, caught by moksha.\n\n        Args:\n            message (dict): The message as a dictionary. This must, at a minimum,\n                contain the 'topic' key with a unicode string value and 'body' key\n                with a dictionary value. However, the message might also be an object\n                with a ``__json__`` method that returns a dict with a 'body' key that\n                can be a unicode string that is JSON-encoded.\n\n        Raises:\n            RuntimeWarning: If the message is not valid.\n            UnicodeDecodeError: If the message body is not unicode or UTF-8 and also\n                happens to contain invalid UTF-8 binary.\n        \"\"\"\n        if hasattr(message, '__json__'):\n            message = message.__json__()\n            if isinstance(message['body'], six.text_type):\n                message['body'] = json.loads(message['body'])\n            elif isinstance(message['body'], six.binary_type):\n                # Try to decode the message body as UTF-8 since it's very likely\n                # that that was the encoding used. This API should eventually only\n                # accept unicode strings inside messages. If a UnicodeDecodeError\n                # happens, let that bubble up.\n                warnings.warn('Message body is not unicode', DeprecationWarning)\n                message['body'] = json.loads(message['body'].decode('utf-8'))\n\n        # Massage STOMP messages into a more compatible format.\n        if 'topic' not in message['body']:\n            message['body'] = {\n                'topic': message.get('topic'),\n                'msg': message['body'],\n            }\n\n        # If we're not validating, then everything is valid.\n        # If this is turned on globally, our child class can override it.\n        if not self.validate_signatures:\n            return\n\n        # We assume these match inside fedmsg.crypto, so we should enforce it.\n        if not message['topic'] == message['body']['topic']:\n            raise RuntimeWarning(\"Topic envelope mismatch.\")\n\n        if not fedmsg.crypto.validate(message['body'], **self.hub.config):\n            raise RuntimeWarning(\"Failed to authn message.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls by the consumer to handle a message.", "response": "def _consume(self, message):\n        \"\"\" Called when a message is consumed.\n\n        This private method handles some administrative setup and teardown\n        before calling the public interface `consume` typically implemented\n        by a subclass.\n\n        When `moksha.blocking_mode` is set to `False` in the config, this\n        method always returns `None`.  The argued message is stored in an\n        internal queue where the consumer's worker threads should eventually\n        pick it up.\n\n        When `moksha.blocking_mode` is set to `True` in the config, this\n        method should return True or False, indicating whether the message\n        was handled or not.  Specifically, in the event that the inner\n        `consume` method raises an exception of any kind, this method\n        should return `False` indicating that the message was not\n        successfully handled.\n\n        Args:\n            message (dict): The message as a dictionary.\n\n        Returns:\n            bool: Should be interpreted as whether or not the message was\n            handled by the consumer, or `None` if `moksha.blocking_mode` is\n            set to False.\n        \"\"\"\n\n        try:\n            self.validate(message)\n        except RuntimeWarning as e:\n            self.log.warn(\"Received invalid message {0}\".format(e))\n            return\n\n        # Pass along headers if present.  May be useful to filters or\n        # fedmsg.meta routines.\n        if isinstance(message, dict) and 'headers' in message and 'body' in message:\n            message['body']['headers'] = message['headers']\n\n        if hasattr(self, \"replay_name\"):\n            for m in check_for_replay(\n                    self.replay_name, self.name_to_seq_id,\n                    message, self.hub.config):\n\n                try:\n                    self.validate(m)\n                    return super(FedmsgConsumer, self)._consume(m)\n                except RuntimeWarning as e:\n                    self.log.warn(\"Received invalid message {}\".format(e))\n        else:\n            return super(FedmsgConsumer, self)._consume(message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove(self, x):\n\n        def _remove(x):\n            found = self.first(x)\n            if found is not None:\n                self._args.pop(found)\n\n        if _is_collection(x):\n            for item in x:\n                _remove(x)\n        else:\n            _remove(x)", "response": "Removes given arg or list thereof from Args object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef first(self, x):\n\n        def _find(x):\n            try:\n                return self.all.index(str(x))\n            except ValueError:\n                return None\n\n        if _is_collection(x):\n            for item in x:\n                found = _find(item)\n                if found is not None:\n                    return found\n            return None\n        else:\n            return _find(x)", "response": "Returns first found index of given value or list of values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start_with(self, x):\n\n        _args = []\n\n        for arg in self.all:\n            if _is_collection(x):\n                for _x in x:\n                    if arg.startswith(x):\n                        _args.append(arg)\n                        break\n            else:\n                if arg.startswith(x):\n                    _args.append(arg)\n\n        return ArgsList(_args, no_argv=True)", "response": "Returns all arguments beginning with given string\n           or list thereof."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all_without(self, x):\n\n        _args = []\n\n        for arg in self.all:\n            if _is_collection(x):\n                for _x in x:\n                    if _x not in arg:\n                        _args.append(arg)\n                        break\n            else:\n                if x not in arg:\n                    _args.append(arg)\n\n        return ArgsList(_args, no_argv=True)", "response": "Returns all arguments not containing given string\n           or list thereof."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an expanded list of all valid paths that were passed in.", "response": "def files(self, absolute=False):\n        \"\"\"Returns an expanded list of all valid paths that were passed in.\"\"\"\n\n        _paths = []\n\n        for arg in self.all:\n            for path in _expand_path(arg):\n                if os.path.exists(path):\n                    if absolute:\n                        _paths.append(os.path.abspath(path))\n                    else:\n                        _paths.append(path)\n\n        return _paths"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef not_files(self):\n\n        _args = []\n\n        for arg in self.all:\n            if not len(_expand_path(arg)):\n                if not os.path.exists(arg):\n                    _args.append(arg)\n\n        return ArgsList(_args, no_argv=True)", "response": "Returns a list of all arguments that aren t files or globs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef assignments(self):\n\n        collection = OrderedDict()\n\n        for arg in self.all:\n            if '=' in arg:\n                collection.setdefault(\n                    arg.split('=', 1)[0], ArgsList(no_argv=True))\n                collection[arg.split('=', 1)[0]]._args.append(\n                    arg.split('=', 1)[1])\n\n        return collection", "response": "Extracts assignment values from assignments."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsigns a message dict and return it.", "response": "def sign(message, gpg_home=None, gpg_signing_key=None, **config):\n    \"\"\" Insert a new field into the message dict and return it.\n\n    The new field is:\n\n        - 'signature' - the computed GPG message digest of the JSON repr\n          of the `msg` field.\n    \"\"\"\n\n    if gpg_home is None or gpg_signing_key is None:\n        raise ValueError(\"You must set the gpg_home \\\n                         and gpg_signing_key keyword arguments.\")\n\n    message['crypto'] = 'gpg'\n\n    signature = _ctx.sign(\n        fedmsg.encoding.dumps(message['msg']),\n        gpg_signing_key,\n        homedir=gpg_home\n    )\n    return dict(list(message.items()) + [('signature', b64encode(signature))])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate(message, gpg_home=None, **config):\n    if gpg_home is None:\n        raise ValueError(\"You must set the gpg_home keyword argument.\")\n    try:\n        _ctx.verify(\n            fedmsg.encoding.dumps(message['msg']),\n            b64decode(message['signature']),\n            homedir=gpg_home\n        )\n        return True\n    except GpgBinaryError:\n        log.warn(\"Failed validation. {0}\".format(six.text_type(message)))\n        return False", "response": "Return true or false if the message is signed appropriately.\n\n    Two things must be true:\n\n        1) The signature must be valid (obviously)\n        2) The signing key must be in the local keyring\n           as defined by the `gpg_home` config value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef verify(self, data, signature=None, keyrings=None, homedir=None):\n        '''\n        `data` <string> the data to verify.\n        `signature` <string> The signature, if detached from the data.\n        `keyrings` <list of string> Additional keyrings to search in.\n        `homedir` <string> Override the configured homedir.\n        '''\n\n        if isinstance(data, six.text_type):\n            data = data.encode('utf-8')\n\n        tmpdir = tempfile.mkdtemp()\n        data_file, data_path = tempfile.mkstemp(dir=tmpdir)\n        data_file = os.fdopen(data_file, 'wb')\n        data_file.write(data)\n        data_file.close()\n        if signature:\n            sig_file, sig_path = tempfile.mkstemp(dir=tmpdir)\n            sig_file = os.fdopen(sig_file, 'wb')\n            sig_file.write(signature)\n            sig_file.close()\n        else:\n            sig_path = None\n        try:\n            return self.verify_from_file(\n                data_path,\n                sig_path=sig_path,\n                keyrings=keyrings,\n                homedir=homedir\n            )\n        finally:\n            shutil.rmtree(tmpdir)", "response": "Verify a data file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nverifies a Gpg file.", "response": "def verify_from_file(self, data_path,\n                         sig_path=None, keyrings=None, homedir=None):\n        '''\n        `data_path` <string> The path to the data to verify.\n        `sig_path` <string> The signature file, if detached from the data.\n        `keyrings` <list of string> Additional keyrings to search in.\n        `homedir` <string> Override the configured homedir.\n        '''\n        cmd_line = ['gpg', '--homedir', homedir or self.homedir]\n        cmd_line.extend(self._get_keyrings_cl(keyrings))\n\n        cmd_line.append('--verify')\n        if sig_path:\n            cmd_line.extend([sig_path, data_path])\n        else:\n            cmd_line.append(data_path)\n\n        p = subprocess.Popen(cmd_line, stderr=subprocess.PIPE)\n        stdout, stderr = p.communicate()\n        if p.returncode:\n            raise GpgBinaryError(stderr)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndestroys a fedmsg context", "response": "def destroy(self):\n        \"\"\" Destroy a fedmsg context \"\"\"\n\n        if getattr(self, 'publisher', None):\n            self.log.debug(\"closing fedmsg publisher\")\n            self.log.debug(\"sent %i messages\" % self._i)\n            self.publisher.close()\n            self.publisher = None\n\n        if getattr(self, 'context', None):\n            self.context.term()\n            self.context = None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef publish(self, topic=None, msg=None, modname=None,\n                pre_fire_hook=None, **kw):\n        \"\"\"\n        Send a message over the publishing zeromq socket.\n\n            >>> import fedmsg\n            >>> fedmsg.publish(topic='testing', modname='test', msg={\n            ...     'test': \"Hello World\",\n            ... })\n\n        The above snippet will send the message ``'{test: \"Hello World\"}'``\n        over the ``<topic_prefix>.dev.test.testing`` topic. The fully qualified\n        topic of a message is constructed out of the following pieces:\n\n            <:ref:`conf-topic-prefix`>.<:ref:`conf-environment`>.<``modname``>.<``topic``>\n\n        This function (and other API functions) do a little bit more\n        heavy lifting than they let on.  If the \"zeromq context\" is not yet\n        initialized, :func:`fedmsg.init` is called to construct it and\n        store it as :data:`fedmsg.__local.__context` before anything else is\n        done.\n\n        **An example from Fedora Tagger -- SQLAlchemy encoding**\n\n        Here's an example from\n        `fedora-tagger <https://github.com/fedora-infra/fedora-tagger>`_ that\n        sends the information about a new tag over\n        ``org.fedoraproject.{dev,stg,prod}.fedoratagger.tag.update``::\n\n          >>> import fedmsg\n          >>> fedmsg.publish(topic='tag.update', msg={\n          ...     'user': user,\n          ...     'tag': tag,\n          ... })\n\n        Note that the `tag` and `user` objects are SQLAlchemy objects defined\n        by tagger.  They both have ``.__json__()`` methods which\n        :func:`fedmsg.publish` uses to encode both objects as stringified\n        JSON for you.  Under the hood, specifically, ``.publish`` uses\n        :mod:`fedmsg.encoding` to do this.\n\n        ``fedmsg`` has also guessed the module name (``modname``) of it's\n        caller and inserted it into the topic for you.  The code from which\n        we stole the above snippet lives in\n        ``fedoratagger.controllers.root``.  ``fedmsg`` figured that out and\n        stripped it down to just ``fedoratagger`` for the final topic of\n        ``org.fedoraproject.{dev,stg,prod}.fedoratagger.tag.update``.\n\n        **Shell Usage**\n\n        You could also use the ``fedmsg-logger`` from a shell script like so::\n\n            $ echo \"Hello, world.\" | fedmsg-logger --topic testing\n            $ echo '{\"foo\": \"bar\"}' | fedmsg-logger --json-input\n\n        :param topic: The message topic suffix. This suffix is joined to the\n            configured topic prefix (e.g. ``org.fedoraproject``), environment\n            (e.g. ``prod``, ``dev``, etc.), and modname.\n        :type topic: unicode\n        :param msg: A message to publish. This message will be JSON-encoded\n            prior to being sent, so the object must be composed of JSON-\n            serializable data types. Please note that if this is already a\n            string JSON serialization will be applied to that string.\n        :type msg: dict\n        :param modname: The module name that is publishing the message. If this\n            is omitted, ``fedmsg`` will try to guess the name of the module\n            that called it and use that to produce an intelligent topic.\n            Specifying ``modname`` explicitly overrides this behavior.\n        :type modname: unicode\n        :param pre_fire_hook: A callable that will be called with a single\n            argument -- the dict of the constructed message -- just before it\n            is handed off to ZeroMQ for publication.\n        :type pre_fire_hook: function\n        \"\"\"\n\n        topic = topic or 'unspecified'\n        msg = msg or dict()\n\n        # If no modname is supplied, then guess it from the call stack.\n        modname = modname or guess_calling_module(default=\"fedmsg\")\n        topic = '.'.join([modname, topic])\n\n        if topic[:len(self.c['topic_prefix'])] != self.c['topic_prefix']:\n            topic = '.'.join([\n                self.c['topic_prefix'],\n                self.c['environment'],\n                topic,\n            ])\n\n        if isinstance(topic, six.text_type):\n            topic = to_bytes(topic, encoding='utf8', nonstring=\"passthru\")\n\n        year = datetime.datetime.now().year\n\n        self._i += 1\n        msg = dict(\n            topic=topic.decode('utf-8'),\n            msg=msg,\n            timestamp=int(time.time()),\n            msg_id=str(year) + '-' + str(uuid.uuid4()),\n            i=self._i,\n            username=getpass.getuser(),\n        )\n\n        # Find my message-signing cert if I need one.\n        if self.c.get('sign_messages', False):\n            if not self.c.get(\"crypto_backend\") == \"gpg\":\n                if 'cert_prefix' in self.c:\n                    cert_index = \"%s.%s\" % (self.c['cert_prefix'],\n                                            self.hostname)\n                else:\n                    cert_index = self.c['name']\n                    if cert_index == 'relay_inbound':\n                        cert_index = \"shell.%s\" % self.hostname\n\n                self.c['certname'] = self.c['certnames'][cert_index]\n            else:\n                if 'gpg_signing_key' not in self.c:\n                    self.c['gpg_signing_key'] = self.c['gpg_keys'][self.hostname]\n\n        if self.c.get('sign_messages', False):\n            msg = fedmsg.crypto.sign(msg, **self.c)\n\n        store = self.c.get('persistent_store', None)\n        if store:\n            # Add the seq_id field\n            msg = store.add(msg)\n\n        if pre_fire_hook:\n            pre_fire_hook(msg)\n\n        # We handle zeromq publishing ourselves.  But, if that is disabled,\n        # defer to the moksha' hub's twisted reactor to send messages (if\n        # available).\n        if self.c.get('zmq_enabled', True):\n            self.publisher.send_multipart(\n                [topic, fedmsg.encoding.dumps(msg).encode('utf-8')],\n                flags=zmq.NOBLOCK,\n            )\n        else:\n            # Perhaps we're using STOMP or AMQP?  Let moksha handle it.\n            import moksha.hub\n            # First, a quick sanity check.\n            if not getattr(moksha.hub, '_hub', None):\n                raise AttributeError(\"Unable to publish non-zeromq msg \"\n                                     \"without moksha-hub initialization.\")\n            # Let moksha.hub do our work.\n            moksha.hub._hub.send_message(\n                topic=topic,\n                message=fedmsg.encoding.dumps(msg).encode('utf-8'),\n                jsonify=False,\n            )", "response": "Publish a message over the zeromq socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nyields the last messages published on the specified topic.", "response": "def tail_messages(self, topic=\"\", passive=False, **kw):\n        \"\"\"\n        Subscribe to messages published on the sockets listed in :ref:`conf-endpoints`.\n\n        Args:\n            topic (six.text_type): The topic to subscribe to. The default is to\n                subscribe to all topics.\n            passive (bool): If ``True``, bind to the :ref:`conf-endpoints` sockets\n                instead of connecting to them. Defaults to ``False``.\n            **kw: Additional keyword arguments. Currently none are used.\n\n        Yields:\n            tuple: A 4-tuple in the form (name, endpoint, topic, message).\n        \"\"\"\n\n        if not self.c.get('zmq_enabled', True):\n            raise ValueError(\"fedmsg.tail_messages() is only available for \"\n                             \"zeromq.  Use the hub-consumer approach for \"\n                             \"STOMP or AMQP support.\")\n\n        poller, subs = self._create_poller(topic=topic, passive=False, **kw)\n        try:\n            for msg in self._poll(poller, subs):\n                yield msg\n        finally:\n            self._close_subs(subs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsigns a message with the specified key pair.", "response": "def sign(message, ssldir=None, certname=None, **config):\n    \"\"\"Insert two new fields into the message dict and return it.\n\n    Those fields are:\n\n        - 'signature' - the computed RSA message digest of the JSON repr.\n        - 'certificate' - the base64 X509 certificate of the sending host.\n\n    Arg:\n        message (dict): An unsigned message to sign.\n        ssldir (str): The absolute path to the directory containing the SSL certificates to\n            use.\n        certname (str): The name of the key pair to sign the message with. This corresponds to\n            the filenames within ``ssldir`` sans prefixes. The key pair must be named\n            ``<certname>.key`` and ``<certname>.crt``\n    Returns:\n        dict: The signed message.\n    \"\"\"\n    if ssldir is None or certname is None:\n        error = \"You must set the ssldir and certname keyword arguments.\"\n        raise ValueError(error)\n\n    message['crypto'] = 'x509'\n\n    with open(\"%s/%s.key\" % (ssldir, certname), \"rb\") as f:\n        rsa_private = serialization.load_pem_private_key(\n            data=f.read(),\n            password=None,\n            backend=default_backend()\n        )\n\n    signature = rsa_private.sign(\n        fedmsg.encoding.dumps(message).encode('utf-8'),\n        asymmetric.padding.PKCS1v15(),\n        hashes.SHA1(),\n    )\n\n    with open(\"%s/%s.crt\" % (ssldir, certname), \"rb\") as f:\n        cert = x509.load_pem_x509_certificate(f.read(), default_backend())\n        cert_pem = cert.public_bytes(serialization.Encoding.PEM)\n\n    return _prep_crypto_msg(dict(list(message.items()) + [\n        ('signature', base64.b64encode(signature).decode('ascii')),\n        ('certificate', base64.b64encode(cert_pem).decode('ascii')),\n    ]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _prep_crypto_msg(message):\n    signature = message['signature']\n    certificate = message['certificate']\n    sliced_signature, sliced_certificate = [], []\n    for x in range(0, len(signature), 76):\n        sliced_signature.append(signature[x:x+76])\n    for x in range(0, len(certificate), 76):\n        sliced_certificate.append(certificate[x:x+76])\n\n    message['signature'] = u'\\n'.join(sliced_signature) + u'\\n'\n    message['certificate'] = u'\\n'.join(sliced_certificate) + u'\\n'\n    return message", "response": "Split the signature and certificate in the same way M2Crypto does."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate the signature on the given message.", "response": "def validate(message, ssldir=None, **config):\n    \"\"\"\n    Validate the signature on the given message.\n\n    Four things must be true for the signature to be valid:\n\n      1) The X.509 cert must be signed by our CA\n      2) The cert must not be in our CRL.\n      3) We must be able to verify the signature using the RSA public key\n         contained in the X.509 cert.\n      4) The topic of the message and the CN on the cert must appear in the\n         :ref:`conf-routing-policy` dict.\n\n    Args:\n        message (dict): A signed message in need of validation. A signed message\n            contains the 'signature' and 'certificate' keys.\n        ssldir (str): The path to the directory containing PEM-encoded X.509\n            key pairs.\n\n    Returns:\n        bool: True of the message passes validation, False otherwise.\n    \"\"\"\n    for field in ['signature', 'certificate']:\n        if field not in message:\n            _log.warn('No %s field found.', field)\n            return False\n        if not isinstance(message[field], six.text_type):\n            _log.error('msg[%r] is not a unicode string' % field)\n            try:\n                # Make an effort to decode it, it's very likely utf-8 since that's what\n                # is hardcoded throughout fedmsg. Worst case scenario is it'll cause a\n                # validation error when there shouldn't be one.\n                message[field] = message[field].decode('utf-8')\n            except UnicodeError as e:\n                _log.error(\"Unable to decode the message '%s' field: %s\", field, str(e))\n                return False\n\n    signature = base64.b64decode(message['signature'])\n    certificate = base64.b64decode(message['certificate'])\n    message = fedmsg.crypto.strip_credentials(message)\n\n    # Unfortunately we can't change this defaulting to Fedora behavior until\n    # fedmsg-2.0\n    ca_location = config.get('ca_cert_location', 'https://fedoraproject.org/fedmsg/ca.crt')\n    crl_location = config.get('crl_location', 'https://fedoraproject.org/fedmsg/crl.pem')\n    try:\n        ca_certificate, crl = utils.load_certificates(ca_location, crl_location)\n        _validate_signing_cert(ca_certificate, certificate, crl)\n    except (IOError, RequestException, X509StoreContextError) as e:\n        # Maybe the CA/CRL is expired or just rotated, so invalidate the cache and try again\n        try:\n            ca_certificate, crl = utils.load_certificates(\n                ca_location, crl_location, invalidate_cache=True)\n            _validate_signing_cert(ca_certificate, certificate, crl)\n        except (IOError, RequestException, X509StoreContextError) as e:\n            _log.error(str(e))\n            return False\n\n    # Validate the signature of the message itself\n    try:\n        crypto_certificate = x509.load_pem_x509_certificate(certificate, default_backend())\n        crypto_certificate.public_key().verify(\n            signature,\n            fedmsg.encoding.dumps(message).encode('utf-8'),\n            asymmetric.padding.PKCS1v15(),\n            hashes.SHA1(),\n        )\n    except InvalidSignature as e:\n        _log.error('message [{m}] has an invalid signature: {e}'.format(\n            m=message, e=str(e)))\n        return False\n\n    # Step 4, check that the certificate is permitted to emit messages for the\n    # topic.\n    common_name = crypto_certificate.subject.get_attributes_for_oid(x509.oid.NameOID.COMMON_NAME)\n    common_name = common_name[0]\n    routing_policy = config.get('routing_policy', {})\n    nitpicky = config.get('routing_nitpicky', False)\n    return utils.validate_policy(\n        message.get('topic'), common_name.value, routing_policy, nitpicky=nitpicky)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _validate_signing_cert(ca_certificate, certificate, crl=None):\n    pyopenssl_cert = load_certificate(FILETYPE_PEM, certificate)\n    pyopenssl_ca_cert = load_certificate(FILETYPE_PEM, ca_certificate)\n\n    cert_store = X509Store()\n    cert_store.add_cert(pyopenssl_ca_cert)\n    if crl:\n        pyopenssl_crl = load_crl(FILETYPE_PEM, crl)\n        cert_store.add_crl(pyopenssl_crl)\n        cert_store.set_flags(X509StoreFlags.CRL_CHECK | X509StoreFlags.CRL_CHECK_ALL)\n\n    cert_store_context = X509StoreContext(cert_store, pyopenssl_cert)\n    cert_store_context.verify_certificate()", "response": "Validate an X509 certificate using pyOpenSSL."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef consume(self, msg):\n        log.debug(\"Got message %r\" % msg)\n        topic, body = msg.get('topic'), msg.get('body')\n\n        for client in self.irc_clients:\n            if not client.factory.filters or (\n                client.factory.filters and\n                self.apply_filters(client.factory.filters, topic, body)\n            ):\n                raw_msg = self.prettify(\n                    topic=topic,\n                    msg=body,\n                    pretty=client.factory.pretty,\n                    terse=client.factory.terse,\n                    short=client.factory.short,\n                )\n                send = getattr(client, self.hub.config['irc_method'], 'notice')\n                send(client.factory.channel, raw_msg.encode('utf-8'))\n\n                backlog = self.incoming.qsize()\n                if backlog and (backlog % 20) == 0:\n                    warning = \"* backlogged by %i messages\" % backlog\n                    log.warning(warning)\n                    send(client.factory.channel, warning.encode('utf-8'))", "response": "Forward on messages from the bus to all IRC connections."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check(timeout, consumer=None, producer=None):\n    # It's weird to say --consumers, but there are multiple, so rename the variables\n    consumers, producers = consumer, producer\n\n    config = load_config()\n    endpoint = config.get('moksha.monitoring.socket')\n    if not endpoint:\n        raise click.ClickException('No monitoring endpoint has been configured: '\n                                   'please set \"moksha.monitoring.socket\"')\n\n    context = zmq.Context.instance()\n    socket = context.socket(zmq.SUB)\n    # ZMQ takes the timeout in milliseconds\n    socket.set(zmq.RCVTIMEO, timeout * 1000)\n    socket.subscribe(b'')\n    socket.connect(endpoint)\n\n    try:\n        message = socket.recv_json()\n    except zmq.error.Again:\n        raise click.ClickException(\n            'Failed to receive message from the monitoring endpoint ({e}) in {t} '\n            'seconds.'.format(e=endpoint, t=timeout))\n\n    if not consumers and not producers:\n        click.echo('No consumers or producers specified so all will be shown.')\n    else:\n        missing = False\n        uninitialized = False\n        for messager_type, messagers in (('consumers', consumers), ('producers', producers)):\n            active = {}\n            for messager in message[messager_type]:\n                active[messager['name']] = messager\n            for messager in messagers:\n                if messager not in active:\n                    click.echo('\"{m}\" is not active!'.format(m=messager), err=True)\n                    missing = True\n                else:\n                    if active[messager]['initialized'] is not True:\n                        click.echo('\"{m}\" is not initialized!'.format(m=messager), err=True)\n                        uninitialized = True\n\n        if missing:\n            raise click.ClickException('Some consumers and/or producers are missing!')\n        elif uninitialized:\n            raise click.ClickException('Some consumers and/or producers are uninitialized!')\n        else:\n            click.echo('All consumers and producers are active!')\n\n    click.echo(json.dumps(message, indent=2, sort_keys=True))", "response": "This command is used to check the status of consumers and producers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize a new context object.", "response": "def init(**kw):\n    \"\"\" Initialize an instance of :class:`fedmsg.core.FedMsgContext`.\n\n    The config is loaded with :func:`fedmsg.config.load_config` and updated\n    by any keyword arguments.  This config is used to initialize the context\n    object.\n\n    The object is stored in a thread local as\n    :data:`fedmsg.__local.__context`.\n    \"\"\"\n\n    if getattr(__local, '__context', None):\n        raise ValueError(\"fedmsg already initialized\")\n\n    # Read config from CLI args and a config file\n    config = fedmsg.config.load_config([], None)\n\n    # Override the defaults with whatever the user explicitly passes in.\n    config.update(kw)\n\n    __local.__context = fedmsg.core.FedMsgContext(**config)\n    return __local.__context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndump the collectd feedback.", "response": "def dump(self):\n        \"\"\" Called by CollectdProducer every `n` seconds. \"\"\"\n\n        # Print out the collectd feedback.\n        # This is sent to stdout while other log messages are sent to stderr.\n        for k, v in sorted(self._dict.items()):\n            print(self.formatter(k, v))\n\n        # Reset each entry to zero\n        for k, v in sorted(self._dict.items()):\n            self._dict[k] = 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef formatter(self, key, value):\n        template = \"PUTVAL {host}/fedmsg/fedmsg_wallboard-{key} \" +\\\n            \"interval={interval} {timestamp}:{value}\"\n        timestamp = int(time.time())\n        interval = self.hub.config['collectd_interval']\n        return template.format(\n            host=self.host,\n            timestamp=timestamp,\n            value=value,\n            interval=interval,\n            key=key,\n        )", "response": "Format messages for collectd to consume."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize the crypto backend.", "response": "def init(**config):\n    \"\"\" Initialize the crypto backend.\n\n    The backend can be one of two plugins:\n\n        - 'x509' - Uses x509 certificates.\n        - 'gpg' - Uses GnuPG keys.\n    \"\"\"\n    global _implementation\n    global _validate_implementations\n\n    if config.get('crypto_backend') == 'gpg':\n        _implementation = gpg\n    else:\n        _implementation = x509\n\n    _validate_implementations = []\n    for mod in config.get('crypto_validate_backends', []):\n        if mod == 'gpg':\n            _validate_implementations.append(gpg)\n        elif mod == 'x509':\n            _validate_implementations.append(x509)\n        else:\n            raise ValueError(\"%r is not a valid crypto backend\" % mod)\n\n    if not _validate_implementations:\n        _validate_implementations.append(_implementation)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsigns a message dict and return the signature.", "response": "def sign(message, **config):\n    \"\"\" Insert two new fields into the message dict and return it.\n\n    Those fields are:\n\n        - 'signature' - the computed message digest of the JSON repr.\n        - 'certificate' - the base64 certificate or gpg key of the signator.\n    \"\"\"\n\n    if not _implementation:\n        init(**config)\n\n    return _implementation.sign(message, **config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns true or false if the message is signed appropriately.", "response": "def validate(message, **config):\n    \"\"\" Return true or false if the message is signed appropriately. \"\"\"\n\n    if not _validate_implementations:\n        init(**config)\n\n    cfg = copy.deepcopy(config)\n    if 'gpg_home' not in cfg:\n        cfg['gpg_home'] = os.path.expanduser('~/.gnupg/')\n\n    if 'ssldir' not in cfg:\n        cfg['ssldir'] = '/etc/pki/fedmsg'\n\n    if 'crypto' in message:\n        if not message['crypto'] in _possible_backends:\n            log.warn(\"Message specified an impossible crypto backend\")\n            return False\n        try:\n            backend = _possible_backends[message['crypto']]\n        except Exception as e:\n            log.warn(\"Failed to load %r %r\" % (message['crypto'], e))\n            return False\n    # fedmsg 0.7.2 and earlier did not specify which crypto backend a message\n    # was signed with.  As long as we care about interoperability with those\n    # versions, attempt to guess the backend to use\n    elif 'certificate' in message:\n        backend = x509\n    elif 'signature' in message:\n        backend = gpg\n    else:\n        log.warn('Could not determine crypto backend.  Message unsigned?')\n        return False\n\n    if backend in _validate_implementations:\n        return backend.validate(message, **cfg)\n    else:\n        log.warn(\"Crypto backend %r is disallowed\" % backend)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate_signed_by(message, signer, **config):\n\n    config = copy.deepcopy(config)\n    config['routing_nitpicky'] = True\n    config['routing_policy'] = {message['topic']: [signer]}\n    return validate(message, **config)", "response": "Validate that a message was signed by a particular certificate."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstrip credentials from a message dict.", "response": "def strip_credentials(message):\n    \"\"\" Strip credentials from a message dict.\n\n    A new dict is returned without either `signature` or `certificate` keys.\n    This method can be called safely; the original dict is not modified.\n\n    This function is applicable using either using the x509 or gpg backends.\n    \"\"\"\n    message = copy.deepcopy(message)\n    for field in ['signature', 'certificate']:\n        if field in message:\n            del message[field]\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nquerying the replay endpoint for missed messages.", "response": "def get_replay(name, query, config, context=None):\n    \"\"\"\n    Query the replay endpoint for missed messages.\n\n    Args:\n        name (str): The replay endpoint name.\n        query (dict): A dictionary used to query the replay endpoint for messages.\n            Queries are dictionaries with the following any of the following keys:\n\n            * 'seq_ids': A ``list`` of ``int``, matching the seq_id attributes\n              of the messages. It should return at most as many messages as the\n              length of the list, assuming no duplicate.\n\n            * 'seq_id': A single ``int`` matching the seq_id attribute of the message.\n              Should return a single message. It is intended as a shorthand for\n              singleton ``seq_ids`` queries.\n\n            * 'seq_id_range': A two-tuple of ``int`` defining a range of seq_id to check.\n\n            * 'msg_ids': A ``list`` of UUIDs matching the msg_id attribute of the messages.\n\n            * 'msg_id': A single UUID for the msg_id attribute.\n\n            * 'time': A tuple of two timestamps. It will return all messages emitted in between.\n        config (dict): A configuration dictionary. This dictionary should contain, at a\n            minimum, two keys. The first key, 'replay_endpoints', should be a dictionary\n            that maps ``name`` to a ZeroMQ socket. The second key, 'io_threads', is an\n            integer used to initialize the ZeroMQ context.\n        context (zmq.Context): The ZeroMQ context to use. If a context is not provided,\n            one will be created.\n\n    Returns:\n        generator: A generator that yields message dictionaries.\n    \"\"\"\n    endpoint = config.get('replay_endpoints', {}).get(name, None)\n    if not endpoint:\n        raise IOError(\"No appropriate replay endpoint \"\n                      \"found for {0}\".format(name))\n\n    if not context:\n        context = zmq.Context(config['io_threads'])\n\n    # A replay endpoint isn't PUB/SUB but REQ/REP, as it allows\n    # for bidirectional communication\n    socket = context.socket(zmq.REQ)\n    try:\n        socket.connect(endpoint)\n    except zmq.ZMQError as e:\n        raise IOError(\"Error when connecting to the \"\n                      \"replay endpoint: '{0}'\".format(str(e)))\n\n    # REQ/REP dance\n    socket.send(fedmsg.encoding.dumps(query).encode('utf-8'))\n    msgs = socket.recv_multipart()\n    socket.close()\n\n    for m in msgs:\n        try:\n            yield fedmsg.encoding.loads(m.decode('utf-8'))\n        except ValueError:\n            # We assume that if it isn't JSON then it's an error message\n            raise ValueError(m)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck to see if a message needs to be replayed.", "response": "def check_for_replay(name, names_to_seq_id, msg, config, context=None):\n    \"\"\"\n    Check to see if messages need to be replayed.\n\n    Args:\n        name (str): The consumer's name.\n        names_to_seq_id (dict): A dictionary that maps names to the last seen sequence ID.\n        msg (dict): The latest message that has arrived.\n        config (dict): A configuration dictionary. This dictionary should contain, at a\n            minimum, two keys. The first key, 'replay_endpoints', should be a dictionary\n            that maps ``name`` to a ZeroMQ socket. The second key, 'io_threads', is an\n            integer used to initialize the ZeroMQ context.\n        context (zmq.Context): The ZeroMQ context to use. If a context is not provided,\n            one will be created.\n\n    Returns:\n        list: A list of message dictionaries.\n    \"\"\"\n    prev_seq_id = names_to_seq_id.get(name, None)\n    cur_seq_id = msg.get(\"seq_id\", None)\n\n    if prev_seq_id is None or cur_seq_id is None:\n        return [msg]\n\n    if cur_seq_id <= prev_seq_id:\n        # Might have been delayed by network lag or something, in which case\n        # we assume the replay has already been asked for and we dismiss it\n        return []\n\n    if cur_seq_id == prev_seq_id + 1 or prev_seq_id < 0:\n        ret = [msg]\n    else:\n        ret = list(get_replay(name, {\n            \"seq_id_range\": (prev_seq_id, cur_seq_id)\n        }, config, context))\n\n        if len(ret) == 0 or ret[-1]['seq_id'] < msg['seq_id']:\n            ret.append(msg)\n\n    names_to_seq_id[name] = cur_seq_id\n\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nseeing if a message is (probably) a datagrepper message and attempt to mutate it to pass signature validation. Datagrepper adds the 'source_name' and 'source_version' keys. If messages happen to use those keys, they will fail message validation. Additionally, a 'headers' dictionary is present on all responses, regardless of whether it was in the original message or not. This is deleted if it's null, which won't be correct in all cases. Finally, datagrepper turns the 'timestamp' field into a float, but it might have been an integer when the message was signed. A copy of the dictionary is made and returned if altering the message is necessary. I'm so sorry. Args: message (dict): A message to clean up. Returns: dict: A copy of the provided message, with the datagrepper-related keys removed if they were present.", "response": "def fix_datagrepper_message(message):\n    \"\"\"\n    See if a message is (probably) a datagrepper message and attempt to mutate\n    it to pass signature validation.\n\n    Datagrepper adds the 'source_name' and 'source_version' keys. If messages happen\n    to use those keys, they will fail message validation. Additionally, a 'headers'\n    dictionary is present on all responses, regardless of whether it was in the\n    original message or not. This is deleted if it's null, which won't be correct in\n    all cases. Finally, datagrepper turns the 'timestamp' field into a float, but it\n    might have been an integer when the message was signed.\n\n    A copy of the dictionary is made and returned if altering the message is necessary.\n\n    I'm so sorry.\n\n    Args:\n        message (dict): A message to clean up.\n\n    Returns:\n        dict: A copy of the provided message, with the datagrepper-related keys removed\n            if they were present.\n    \"\"\"\n    if not ('source_name' in message and 'source_version' in message):\n        return message\n\n    # Don't mutate the original message\n    message = message.copy()\n\n    del message['source_name']\n    del message['source_version']\n    # datanommer adds the headers field to the message in all cases.\n    # This is a huge problem because if the signature was generated with a 'headers'\n    # key set and we delete it here, messages will fail validation, but if we don't\n    # messages will fail validation if they didn't have a 'headers' key set.\n    #\n    # There's no way to know whether or not the headers field was part of the signed\n    # message or not. Generally, the problem is datanommer is mutating messages.\n    if 'headers' in message and not message['headers']:\n        del message['headers']\n    if 'timestamp' in message:\n        message['timestamp'] = int(message['timestamp'])\n\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks that the sender is allowed to send messages on the given topic.", "response": "def validate_policy(topic, signer, routing_policy, nitpicky=False):\n    \"\"\"\n    Checks that the sender is allowed to emit messages for the given topic.\n\n    Args:\n        topic (str): The message topic the ``signer`` used when sending the message.\n        signer (str): The Common Name of the certificate used to sign the message.\n\n    Returns:\n        bool: True if the policy defined in the settings allows the signer to send\n            messages on ``topic``.\n    \"\"\"\n    if topic in routing_policy:\n        # If so.. is the signer one of those permitted senders?\n        if signer in routing_policy[topic]:\n            # We are good.  The signer of this message is explicitly\n            # whitelisted to send on this topic in our config policy.\n            return True\n        else:\n            # We have a policy for this topic and $homeboy isn't on the list.\n            _log.error(\"Authorization/routing_policy error.  \"\n                       \"Topic %r.  Signer %r.\" % (topic, signer))\n            return False\n    else:\n        # We don't have a policy for this topic.  How we react next for an\n        # underspecified routing_policy is based on a configuration option.\n\n        # Ideally, we are in nitpicky mode.  We leave it disabled while\n        # standing up fedmsg across our environment so that we can build our\n        # policy without having the whole thing come crashing down.\n        if nitpicky:\n            # We *are* in nitpicky mode.  We don't have an entry in the\n            # routing_policy for the topic of this message.. and *nobody*\n            # gets in without a pass.  That means that we fail the message.\n            _log.error(\"Authorization/routing_policy underspecified.\")\n            return False\n        else:\n            # We are *not* in nitpicky mode.  We don't have an entry in the\n            # routing_policy for the topic of this message.. but we don't\n            # really care.\n            _log.warning('No routing policy defined for \"{t}\" but routing_nitpicky is '\n                         'False so the message is being treated as authorized.'.format(t=topic))\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_certificates(ca_location, crl_location=None, invalidate_cache=False):\n    if crl_location is None:\n        crl_location = ''\n\n    try:\n        if invalidate_cache:\n            del _cached_certificates[ca_location + crl_location]\n        else:\n            return _cached_certificates[ca_location + crl_location]\n    except KeyError:\n        pass\n\n    ca, crl = None, None\n    if ca_location:\n        ca = _load_certificate(ca_location)\n    if crl_location:\n        crl = _load_certificate(crl_location)\n\n    _cached_certificates[ca_location + crl_location] = ca, crl\n    return ca, crl", "response": "Load the CA and CRL certificates and cache them for future use."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload a certificate from the given location.", "response": "def _load_certificate(location):\n    \"\"\"\n    Load a certificate from the given location.\n\n    Args:\n        location (str): The location to load. This can either be an HTTPS URL or an absolute file\n            path. This is intended to be used with PEM-encoded certificates and therefore assumes\n            ASCII encoding.\n\n    Returns:\n        str: The PEM-encoded certificate as a unicode string.\n\n    Raises:\n        requests.exception.RequestException: Any exception requests could raise.\n        IOError: If the location provided could not be opened and read.\n    \"\"\"\n    if location.startswith('https://'):\n        _log.info('Downloading x509 certificate from %s', location)\n        with requests.Session() as session:\n            session.mount('https://', requests.adapters.HTTPAdapter(max_retries=3))\n            response = session.get(location, timeout=30)\n            response.raise_for_status()\n            return response.text\n    else:\n        _log.info('Loading local x509 certificate from %s', location)\n        with open(location, 'rb') as fd:\n            return fd.read().decode('ascii')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the list of file paths for fedmsg configuration files.", "response": "def _get_config_files():\n    \"\"\"\n    Load the list of file paths for fedmsg configuration files.\n\n    Returns:\n        list: List of files containing fedmsg configuration.\n    \"\"\"\n    config_paths = []\n    if os.environ.get('FEDMSG_CONFIG'):\n        config_location = os.environ['FEDMSG_CONFIG']\n    else:\n        config_location = '/etc/fedmsg.d'\n\n    if os.path.isfile(config_location):\n        config_paths.append(config_location)\n    elif os.path.isdir(config_location):\n        # list dir and add valid files\n        possible_config_files = [os.path.join(config_location, p)\n                                 for p in os.listdir(config_location) if p.endswith('.py')]\n        for p in possible_config_files:\n            if os.path.isfile(p):\n                config_paths.append(p)\n    if not config_paths:\n        _log.info('No configuration files found in %s', config_location)\n    return config_paths"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a validator that checks if a setting is either None or a given type.", "response": "def _validate_none_or_type(t):\n    \"\"\"\n    Create a validator that checks if a setting is either None or a given type.\n\n    Args:\n        t: The type to assert.\n\n    Returns:\n        callable: A callable that will validate a setting for that type.\n    \"\"\"\n    def _validate(setting):\n        \"\"\"\n        Check the setting to make sure it's the right type.\n\n        Args:\n            setting (object): The setting to check.\n\n        Returns:\n            object: The unmodified object if it's the proper type.\n\n        Raises:\n            ValueError: If the setting is the wrong type.\n        \"\"\"\n        if setting is not None and not isinstance(setting, t):\n            raise ValueError('\"{}\" is not \"{}\"'.format(setting, t))\n        return setting\n    return _validate"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating a setting is a bool.", "response": "def _validate_bool(value):\n    \"\"\"\n    Validate a setting is a bool.\n\n    Returns:\n        bool: The value as a boolean.\n\n    Raises:\n        ValueError: If the value can't be parsed as a bool string or isn't already bool.\n    \"\"\"\n    if isinstance(value, six.text_type):\n        if value.strip().lower() == 'true':\n            value = True\n        elif value.strip().lower() == 'false':\n            value = False\n        else:\n            raise ValueError('\"{}\" must be a boolean (\"True\" or \"False\")'.format(value))\n\n    if not isinstance(value, bool):\n        raise ValueError('\"{}\" is not a boolean value.'.format(value))\n\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_config(extra_args=None,\n                doc=None,\n                filenames=None,\n                invalidate_cache=False,\n                fedmsg_command=False,\n                disable_defaults=False):\n    \"\"\" Setup a runtime config dict by integrating the following sources\n    (ordered by precedence):\n\n      - defaults (unless disable_defaults = True)\n      - config file\n      - command line arguments\n\n    If the ``fedmsg_command`` argument is False, no command line arguments are\n    checked.\n\n    \"\"\"\n    warnings.warn('Using \"load_config\" is deprecated and will be removed in a future release;'\n                  ' use the \"fedmsg.config.conf\" dictionary instead.', DeprecationWarning)\n    global __cache\n\n    if invalidate_cache:\n        __cache = {}\n\n    if __cache:\n        return __cache\n\n    # Coerce defaults if arguments are not supplied.\n    extra_args = extra_args or []\n    doc = doc or \"\"\n\n    if not disable_defaults:\n        config = copy.deepcopy(defaults)\n    else:\n        config = {}\n\n    config.update(_process_config_file(filenames=filenames))\n\n    # This is optional (and defaults to false) so that only 'fedmsg-*' commands\n    # are required to provide these arguments.\n    # For instance, the moksha-hub command takes a '-v' argument and internally\n    # makes calls to fedmsg.  We don't want to impose all of fedmsg's CLI\n    # option constraints on programs that use fedmsg, so we make it optional.\n    if fedmsg_command:\n        config.update(_process_arguments(extra_args, doc, config))\n\n    # If the user specified a config file on the command line, then start over\n    # but read in that file instead.\n    if not filenames and config.get('config_filename', None):\n        return load_config(extra_args, doc,\n                           filenames=[config['config_filename']],\n                           fedmsg_command=fedmsg_command,\n                           disable_defaults=disable_defaults)\n\n    # Just a little debug option.  :)\n    if config.get('print_config'):\n        print(pretty_dumps(config))\n        sys.exit(0)\n\n    if not disable_defaults and 'endpoints' not in config:\n        raise ValueError(\"No config value 'endpoints' found.\")\n\n    if not isinstance(config.get('endpoints', {}), dict):\n        raise ValueError(\"The 'endpoints' config value must be a dict.\")\n\n    if 'endpoints' in config:\n        config['endpoints'] = dict([\n            (k, list(iterate(v))) for k, v in config['endpoints'].items()\n        ])\n\n    if 'srv_endpoints' in config and len(config['srv_endpoints']) > 0:\n        from dns.resolver import query, NXDOMAIN, Timeout, NoNameservers\n        for e in config['srv_endpoints']:\n            urls = []\n            try:\n                records = query('_fedmsg._tcp.{0}'.format(e), 'SRV')\n            except NXDOMAIN:\n                warnings.warn(\"There is no appropriate SRV records \" +\n                              \"for {0}\".format(e))\n                continue\n            except Timeout:\n                warnings.warn(\"The DNS query for the SRV records of\" +\n                              \" {0} timed out.\".format(e))\n                continue\n            except NoNameservers:\n                warnings.warn(\"No name server is available, please \" +\n                              \"check the configuration\")\n                break\n\n            for rec in records:\n                urls.append('tcp://{hostname}:{port}'.format(\n                    hostname=rec.target.to_text(),\n                    port=rec.port\n                ))\n            config['endpoints'][e] = list(iterate(urls))\n\n    if 'topic_prefix_re' not in config and 'topic_prefix' in config:\n        # Turn \"org.fedoraproject\" into \"org\\.fedoraproject\\.[^\\W\\d_]+\"\n        config['topic_prefix_re'] = config['topic_prefix'].replace('.', '\\.')\\\n            + '\\.[^\\W\\d_]+'\n\n    __cache = config\n    return config", "response": "Load a config file from a list of files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an argument parser for all fedmsg commands.", "response": "def build_parser(declared_args, doc, config=None, prog=None):\n    \"\"\" Return the global :class:`argparse.ArgumentParser` used by all fedmsg\n    commands.\n\n    Extra arguments can be supplied with the `declared_args` argument.\n    \"\"\"\n\n    config = config or copy.deepcopy(defaults)\n    prog = prog or sys.argv[0]\n\n    parser = argparse.ArgumentParser(\n        description=textwrap.dedent(doc),\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        prog=prog,\n    )\n\n    parser.add_argument(\n        '--io-threads',\n        dest='io_threads',\n        type=int,\n        help=\"Number of io threads for 0mq to use\",\n        default=config['io_threads'],\n    )\n    parser.add_argument(\n        '--topic-prefix',\n        dest='topic_prefix',\n        type=str,\n        help=\"Prefix for the topic of each message sent.\",\n        default=config['topic_prefix'],\n    )\n    parser.add_argument(\n        '--post-init-sleep',\n        dest='post_init_sleep',\n        type=float,\n        help=\"Number of seconds to sleep after initializing.\",\n        default=config['post_init_sleep'],\n    )\n    parser.add_argument(\n        '--config-filename',\n        dest='config_filename',\n        help=\"Config file to use.\",\n        default=None,\n    )\n    parser.add_argument(\n        '--print-config',\n        dest='print_config',\n        help='Simply print out the configuration and exit.  No action taken.',\n        default=False,\n        action='store_true',\n    )\n    parser.add_argument(\n        '--timeout',\n        dest='timeout',\n        help=\"Timeout in seconds for any blocking zmq operations.\",\n        type=float,\n        default=config['timeout'],\n    )\n    parser.add_argument(\n        '--high-water-mark',\n        dest='high_water_mark',\n        help=\"Limit on the number of messages in the queue before blocking.\",\n        type=int,\n        default=config['high_water_mark'],\n    )\n    parser.add_argument(\n        '--linger',\n        dest='zmq_linger',\n        help=\"Number of milliseconds to wait before timing out connections.\",\n        type=int,\n        default=config['zmq_linger'],\n    )\n\n    for args, kwargs in declared_args:\n        # Replace the hard-coded extra_args default with the config file value\n        # (if it exists)\n        if all([k in kwargs for k in ['dest', 'default']]):\n            kwargs['default'] = config.get(\n                kwargs['dest'], kwargs['default'])\n\n        # Having slurped smart defaults from the config file, add the CLI arg.\n        parser.add_argument(*args, **kwargs)\n\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _gather_configs_in(directory):\n    try:\n        return sorted([\n            os.path.join(directory, fname)\n            for fname in os.listdir(directory)\n            if fname.endswith('.py')\n        ])\n    except OSError:\n        return []", "response": "Return list of fully qualified python filenames in the given dir"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _recursive_update(d1, d2):\n\n    for k in set(d1).intersection(d2):\n        if isinstance(d1[k], dict) and isinstance(d2[k], dict):\n            d1[k] = _recursive_update(d1[k], d2[k])\n        else:\n            d1[k] = d2[k]\n\n    for k in set(d2).difference(d1):\n        d1[k] = d2[k]\n\n    return d1", "response": "Recursively updates d1 with d2."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes a file and return a dict of the result.", "response": "def execfile(fname, variables):\n    \"\"\" This is builtin in python2, but we have to roll our own on py3. \"\"\"\n    with open(fname) as f:\n        code = compile(f.read(), fname, 'exec')\n        exec(code, variables)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the configuration if necessary and forward the call to the parent.", "response": "def get(self, *args, **kw):\n        \"\"\"Load the configuration if necessary and forward the call to the parent.\"\"\"\n        if not self._loaded:\n            self.load_config()\n        return super(FedmsgConfig, self).get(*args, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy(self, *args, **kw):\n        if not self._loaded:\n            self.load_config()\n        return super(FedmsgConfig, self).copy(*args, **kw)", "response": "Copy the configuration to the parent."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads the configuration from the config file or from the given settings.", "response": "def load_config(self, settings=None):\n        \"\"\"\n        Load the configuration either from the config file, or from the given settings.\n\n        Args:\n            settings (dict): If given, the settings are pulled from this dictionary. Otherwise, the\n                config file is used.\n        \"\"\"\n        self._load_defaults()\n        if settings:\n            self.update(settings)\n        else:\n            config_paths = _get_config_files()\n            for p in config_paths:\n                conf = _process_config_file([p])\n                self.update(conf)\n        self._loaded = True\n        self._validate()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _load_defaults(self):\n        for k, v in self._defaults.items():\n            self[k] = v['default']", "response": "Iterate over self. _defaults and set all default values on self."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates the configuration values.", "response": "def _validate(self):\n        \"\"\"\n        Run the validators found in self._defaults on all the corresponding values.\n\n        Raises:\n            ValueError: If the configuration contains an invalid configuration value.\n        \"\"\"\n        errors = []\n        for k in self._defaults.keys():\n            try:\n                validator = self._defaults[k]['validator']\n                if validator is not None:\n                    self[k] = validator(self[k])\n            except ValueError as e:\n                errors.append('\\t{}: {}'.format(k, six.text_type(e)))\n\n        if errors:\n            raise ValueError(\n                'Invalid configuration values were set: \\n{}'.format('\\n'.join(errors)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_processors(**config):\n    global processors\n\n    # If they're already initialized, then fine.\n    if processors:\n        return\n\n    import pkg_resources\n    processors = []\n    for processor in pkg_resources.iter_entry_points('fedmsg.meta'):\n        try:\n            processors.append(processor.load()(_, **config))\n        except Exception as e:\n            log.warn(\"Failed to load %r processor.\" % processor.name)\n            log.exception(e)\n\n    # This should always be last\n    processors.append(DefaultProcessor(_, **config))\n\n    # By default we have three builtin processors:  Default, Logger, and\n    # Announce.  If these are the only three, then we didn't find any\n    # externally provided ones.  calls to msg2subtitle and msg2link likely will\n    # not work the way the user is expecting.\n    if len(processors) == 3:\n        log.warn(\"No fedmsg.meta plugins found.  fedmsg.meta.msg2* crippled\")", "response": "Initialize all of the text processors."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef msg2processor(msg, **config):\n    for processor in processors:\n        if processor.handle_msg(msg, **config) is not None:\n            return processor\n    else:\n        return processors[-1]", "response": "Return the most appropriate text processor that can handle a given message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of messages with some of them grouped into a conglomerate sequence.", "response": "def conglomerate(messages, subject=None, lexers=False, **config):\n    \"\"\" Return a list of messages with some of them grouped into conglomerate\n    messages.  Conglomerate messages represent several other messages.\n\n    For example, you might pass this function a list of 40 messages.\n    38 of those are git.commit messages, 1 is a bodhi.update message, and 1 is\n    a badge.award message.  This function could return a list of three\n    messages, one representing the 38 git commit messages, one representing the\n    bodhi.update message, and one representing the badge.award message.\n\n    The ``subject`` argument is optional and will return \"subjective\"\n    representations if possible (see msg2subjective(...)).\n\n    Functionality is provided by fedmsg.meta plugins on a \"best effort\" basis.\n    \"\"\"\n\n    # First, give every registered processor a chance to do its work\n    for processor in processors:\n        messages = processor.conglomerate(messages, subject=subject, **config)\n\n    # Then, just fake it for every other ungrouped message.\n    for i, message in enumerate(messages):\n        # If these were successfully grouped, then skip\n        if 'msg_ids' in message:\n            continue\n\n        # For ungrouped ones, replace them with a fake conglomerate\n        messages[i] = BaseConglomerator.produce_template(\n            [message], subject=subject, lexers=lexers, **config)\n        # And fill out the fields that fully-implemented conglomerators would\n        # normally fill out.\n        messages[i].update({\n            'link': msg2link(message, **config),\n            'subtitle': msg2subtitle(message, **config),\n            'subjective': msg2subjective(message, subject=subject, **config),\n            'secondary_icon': msg2secondary_icon(message, **config),\n        })\n\n    return messages"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a human - readable or natural language representation of a fedmsg message.", "response": "def msg2repr(msg, processor, **config):\n    \"\"\" Return a human-readable or \"natural language\" representation of a\n    dict-like fedmsg message.  Think of this as the 'top-most level' function\n    in this module.\n\n    \"\"\"\n    fmt = u\"{title} -- {subtitle} {link}\"\n    title = msg2title(msg, **config)\n    subtitle = processor.subtitle(msg, **config)\n    link = processor.link(msg, **config) or ''\n    return fmt.format(**locals())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef msg2long_form(msg, processor, **config):\n    result = processor.long_form(msg, **config)\n    if not result:\n        result = processor.subtitle(msg, **config)\n    return result", "response": "Return a long form text representation of a message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef msg2usernames(msg, processor=None, legacy=False, **config):\n    return processor.usernames(msg, **config)", "response": "Return a set of FAS usernames associated with a message."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef msg2agent(msg, processor=None, legacy=False, **config):\n\n    if processor.agent is not NotImplemented:\n        return processor.agent(msg, **config)\n    else:\n        usernames = processor.usernames(msg, **config)\n        # usernames is a set(), which doesn't support indexing.\n        if usernames:\n            return usernames.pop()\n\n    # default to None if we can't find anything\n    return None", "response": "Return the single username who is the agent for a message."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef msg2subjective(msg, processor, subject, **config):\n    text = processor.subjective(msg, subject, **config)\n    if not text:\n        text = processor.subtitle(msg, **config)\n    return text", "response": "Return a human - readable text representation of a fedmsg message from the subjective perspective of a user."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run_command(self, command, message):\n        proc = subprocess.Popen([\n            'echo \\'%s\\' | %s' % (fedmsg.encoding.dumps(message), command)\n        ], shell=True, executable='/bin/bash')\n        return proc.wait()", "response": "Use subprocess to feed the message to our command over stdin"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsigns a message with the M2Crypto library.", "response": "def _m2crypto_sign(message, ssldir=None, certname=None, **config):\n    \"\"\" Insert two new fields into the message dict and return it.\n\n    Those fields are:\n\n        - 'signature' - the computed RSA message digest of the JSON repr.\n        - 'certificate' - the base64 X509 certificate of the sending host.\n    \"\"\"\n    if ssldir is None or certname is None:\n        error = \"You must set the ssldir and certname keyword arguments.\"\n        raise ValueError(error)\n\n    message['crypto'] = 'x509'\n\n    certificate = M2Crypto.X509.load_cert(\n        \"%s/%s.crt\" % (ssldir, certname)).as_pem()\n    # Opening this file requires elevated privileges in stg/prod.\n    rsa_private = M2Crypto.RSA.load_key(\n        \"%s/%s.key\" % (ssldir, certname))\n\n    digest = M2Crypto.EVP.MessageDigest('sha1')\n    digest.update(fedmsg.encoding.dumps(message))\n\n    signature = rsa_private.sign(digest.digest())\n\n    # Return a new dict containing the pairs in the original message as well\n    # as the new authn fields.\n    return dict(message.items() + [\n        ('signature', signature.encode('base64').decode('ascii')),\n        ('certificate', certificate.encode('base64').decode('ascii')),\n    ])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate the message and return True or False if the message is signed appropriately.", "response": "def _m2crypto_validate(message, ssldir=None, **config):\n    \"\"\" Return true or false if the message is signed appropriately.\n\n    Four things must be true:\n\n      1) The X509 cert must be signed by our CA\n      2) The cert must not be in our CRL.\n      3) We must be able to verify the signature using the RSA public key\n         contained in the X509 cert.\n      4) The topic of the message and the CN on the cert must appear in the\n         :ref:`conf-routing-policy` dict.\n\n    \"\"\"\n\n    if ssldir is None:\n        raise ValueError(\"You must set the ssldir keyword argument.\")\n\n    def fail(reason):\n        _log.warn(\"Failed validation.  %s\" % reason)\n        return False\n\n    # Some sanity checking\n    for field in ['signature', 'certificate']:\n        if field not in message:\n            return fail(\"No %r field found.\" % field)\n        if not isinstance(message[field], six.text_type):\n            _log.error('msg[%r] is not a unicode string' % field)\n            try:\n                # Make an effort to decode it, it's very likely utf-8 since that's what\n                # is hardcoded throughout fedmsg. Worst case scenario is it'll cause a\n                # validation error when there shouldn't be one.\n                message[field] = message[field].decode('utf-8')\n            except UnicodeError as e:\n                _log.error(\"Unable to decode the message '%s' field: %s\", field, str(e))\n                return False\n\n    # Peal off the auth datums\n    signature = message['signature'].decode('base64')\n    certificate = message['certificate'].decode('base64')\n    message = fedmsg.crypto.strip_credentials(message)\n\n    # Build an X509 object\n    cert = M2Crypto.X509.load_cert_string(certificate)\n\n    # Validate the cert.  Make sure it is signed by our CA.\n    #   validate_certificate will one day be a part of M2Crypto.SSL.Context\n    #   https://bugzilla.osafoundation.org/show_bug.cgi?id=11690\n\n    ca_location = config.get('ca_cert_location', 'https://fedoraproject.org/fedmsg/ca.crt')\n    crl_location = config.get('crl_location', 'https://fedoraproject.org/fedmsg/crl.pem')\n    fd, cafile = tempfile.mkstemp()\n    try:\n        ca_certificate, crl = utils.load_certificates(ca_location, crl_location)\n        os.write(fd, ca_certificate.encode('ascii'))\n        os.fsync(fd)\n        ctx = m2ext.SSL.Context()\n        ctx.load_verify_locations(cafile=cafile)\n        if not ctx.validate_certificate(cert):\n            ca_certificate, crl = utils.load_certificates(\n                ca_location, crl_location, invalidate_cache=True)\n            with open(cafile, 'w') as f:\n                f.write(ca_certificate)\n            ctx = m2ext.SSL.Context()\n            ctx.load_verify_locations(cafile=cafile)\n            if not ctx.validate_certificate(cert):\n                return fail(\"X509 certificate is not valid.\")\n    except (IOError, RequestException) as e:\n        _log.error(str(e))\n        return False\n    finally:\n        os.close(fd)\n        os.remove(cafile)\n\n    if crl:\n        try:\n            fd, crlfile = tempfile.mkstemp(text=True)\n            os.write(fd, crl.encode('ascii'))\n            os.fsync(fd)\n            crl = M2Crypto.X509.load_crl(crlfile)\n        finally:\n            os.close(fd)\n            os.remove(crlfile)\n        # FIXME -- We need to check that the CRL is signed by our own CA.\n        # See https://bugzilla.osafoundation.org/show_bug.cgi?id=12954#c2\n        # if not ctx.validate_certificate(crl):\n        #    return fail(\"X509 CRL is not valid.\")\n\n        # FIXME -- we check the CRL, but by doing string comparison ourselves.\n        # This is not what we want to be doing.\n        # There is a patch into M2Crypto to handle this for us.  We should use it\n        # once its integrated upstream.\n        # See https://bugzilla.osafoundation.org/show_bug.cgi?id=12954#c2\n        revoked_serials = [long(line.split(': ')[1].strip(), base=16)\n                           for line in crl.as_text().split('\\n')\n                           if 'Serial Number:' in line]\n        if cert.get_serial_number() in revoked_serials:\n            subject = cert.get_subject()\n\n            signer = '(no CN)'\n            if subject.nid.get('CN'):\n                entry = subject.get_entries_by_nid(subject.nid['CN'])[0]\n                if entry:\n                    signer = entry.get_data().as_text()\n\n            return fail(\"X509 cert %r, %r is in the Revocation List (CRL)\" % (\n                signer, cert.get_serial_number()))\n\n    # If the cert is good, then test to see if the signature in the messages\n    # matches up with the provided cert.\n    rsa_public = cert.get_pubkey().get_rsa()\n    digest = M2Crypto.EVP.MessageDigest('sha1')\n    digest.update(fedmsg.encoding.dumps(message))\n    try:\n        if not rsa_public.verify(digest.digest(), signature):\n            raise M2Crypto.RSA.RSAError(\"RSA signature failed to validate.\")\n    except M2Crypto.RSA.RSAError as e:\n        return fail(str(e))\n\n    # Now we know that the cert is valid.  The message is *authenticated*.\n    # * Next step:  Authorization *\n\n    # Load our policy from the config dict.\n    routing_policy = config.get('routing_policy', {})\n\n    # Determine the name of the signer of the message.\n    # This will be something like \"shell-pkgs01.stg.phx2.fedoraproject.org\"\n    subject = cert.get_subject()\n    signer = subject.get_entries_by_nid(subject.nid['CN'])[0]\\\n        .get_data().as_text()\n\n    return utils.validate_policy(\n        message.get('topic'), signer, routing_policy, config.get('routing_nitpicky', False))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives N messages return another list that has some of them AttributeNames grouped together into a common item.", "response": "def conglomerate(self, messages, **config):\n        \"\"\" Given N messages, return another list that has some of them\n        grouped together into a common 'item'.\n\n        A conglomeration of messages should be of the following form::\n\n          {\n            'subtitle': 'relrod pushed commits to ghc and 487 other packages',\n            'link': None,  # This could be something.\n            'icon': 'https://that-git-logo',\n            'secondary_icon': 'https://that-relrod-avatar',\n            'start_time': some_timestamp,\n            'end_time': some_other_timestamp,\n            'human_time': '5 minutes ago',\n            'usernames': ['relrod'],\n            'packages': ['ghc', 'nethack', ... ],\n            'topics': ['org.fedoraproject.prod.git.receive'],\n            'categories': ['git'],\n            'msg_ids': {\n                '2014-abcde': {\n                    'subtitle': 'relrod pushed some commits to ghc',\n                    'title': 'git.receive',\n                    'link': 'http://...',\n                    'icon': 'http://...',\n                },\n                '2014-bcdef': {\n                    'subtitle': 'relrod pushed some commits to nethack',\n                    'title': 'git.receive',\n                    'link': 'http://...',\n                    'icon': 'http://...',\n                },\n            },\n          }\n\n        The telltale sign that an entry in a list of messages represents a\n        conglomerate message is the presence of the plural ``msg_ids`` field.\n        In contrast, ungrouped singular messages should bear a singular\n        ``msg_id`` field.\n        \"\"\"\n        for conglomerator in self.conglomerator_objects:\n            messages = conglomerator.conglomerate(messages, **config)\n        return messages"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the topic name of the message.", "response": "def handle_msg(self, msg, **config):\n        \"\"\"\n        If we can handle the given message, return the remainder of the topic.\n\n        Returns None if we can't handle the message.\n        \"\"\"\n        match = self.__prefix__.match(msg['topic'])\n        if match:\n            return match.groups()[-1] or \"\""}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parseExtensionArgs(self, args):\n\n        # preferred_auth_policies is a space-separated list of policy URIs\n        self.preferred_auth_policies = []\n\n        policies_str = args.get('preferred_auth_policies')\n        if policies_str:\n            if isinstance(policies_str, bytes):\n                policies_str = str(policies_str, encoding=\"utf-8\")\n            for uri in policies_str.split(' '):\n                if uri not in self.preferred_auth_policies:\n                    self.preferred_auth_policies.append(uri)\n\n        # max_auth_age is base-10 integer number of seconds\n        max_auth_age_str = args.get('max_auth_age')\n        self.max_auth_age = None\n\n        if max_auth_age_str:\n            try:\n                self.max_auth_age = int(max_auth_age_str)\n            except ValueError:\n                pass", "response": "Parse the arguments passed to the PAPE extension method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting the OpenID authentication process. See steps 1-2 in the overview at the top of this file. @param user_url: Identity URL given by the user. This method performs a textual transformation of the URL to try and make sure it is normalized. For example, a user_url of example.com will be normalized to http://example.com/ normalizing and resolving any redirects the server might issue. @type user_url: unicode @param anonymous: Whether to make an anonymous request of the OpenID provider. Such a request does not ask for an authorization assertion for an OpenID identifier, but may be used with extensions to pass other data. e.g. \"I don't care who you are, but I'd like to know your time zone.\" @type anonymous: bool @returns: An object containing the discovered information will be returned, with a method for building a redirect URL to the server, as described in step 3 of the overview. This object may also be used to add extension arguments to the request, using its L{addExtensionArg<openid.consumer.consumer.AuthRequest.addExtensionArg>} method. @returntype: L{AuthRequest<openid.consumer.consumer.AuthRequest>} @raises openid.consumer.discover.DiscoveryFailure: when I fail to find an OpenID server for this URL. If the C{yadis} package is available, L{openid.consumer.discover.DiscoveryFailure} is an alias for C{yadis.discover.DiscoveryFailure}.", "response": "def begin(self, user_url, anonymous=False):\n        \"\"\"Start the OpenID authentication process. See steps 1-2 in\n        the overview at the top of this file.\n\n        @param user_url: Identity URL given by the user. This method\n            performs a textual transformation of the URL to try and\n            make sure it is normalized. For example, a user_url of\n            example.com will be normalized to http://example.com/\n            normalizing and resolving any redirects the server might\n            issue.\n\n        @type user_url: unicode\n\n        @param anonymous: Whether to make an anonymous request of the OpenID\n            provider.  Such a request does not ask for an authorization\n            assertion for an OpenID identifier, but may be used with\n            extensions to pass other data.  e.g. \"I don't care who you are,\n            but I'd like to know your time zone.\"\n\n        @type anonymous: bool\n\n        @returns: An object containing the discovered information will\n            be returned, with a method for building a redirect URL to\n            the server, as described in step 3 of the overview. This\n            object may also be used to add extension arguments to the\n            request, using its\n            L{addExtensionArg<openid.consumer.consumer.AuthRequest.addExtensionArg>}\n            method.\n\n        @returntype: L{AuthRequest<openid.consumer.consumer.AuthRequest>}\n\n        @raises openid.consumer.discover.DiscoveryFailure: when I fail to\n            find an OpenID server for this URL.  If the C{yadis} package\n            is available, L{openid.consumer.discover.DiscoveryFailure} is\n            an alias for C{yadis.discover.DiscoveryFailure}.\n        \"\"\"\n        disco = Discovery(self.session, user_url, self.session_key_prefix)\n        try:\n            service = disco.getNextService(self._discover)\n        except fetchers.HTTPFetchingError as why:\n            raise DiscoveryFailure('Error fetching XRDS document: %s' %\n                                   (why.why, ), None)\n\n        if service is None:\n            raise DiscoveryFailure('No usable OpenID services found for %s' %\n                                   (user_url, ), None)\n        else:\n            return self.beginWithoutDiscovery(service, anonymous)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef beginWithoutDiscovery(self, service, anonymous=False):\n        auth_req = self.consumer.begin(service)\n        self.session[self._token_key] = auth_req.endpoint\n\n        try:\n            auth_req.setAnonymous(anonymous)\n        except ValueError as why:\n            raise ProtocolError(str(why))\n\n        return auth_req", "response": "Start OpenID verification without doing OpenID server\n        discovery."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _checkReturnTo(self, message, return_to):\n        # Check the openid.return_to args against args in the original\n        # message.\n        try:\n            self._verifyReturnToArgs(message.toPostArgs())\n        except ProtocolError as why:\n            logging.exception(\"Verifying return_to arguments: %s\" % (why, ))\n            return False\n\n        # Check the return_to base URL against the one in the message.\n        msg_return_to = message.getArg(OPENID_NS, 'return_to')\n\n        # The URL scheme, authority, and path MUST be the same between\n        # the two URLs.\n        app_parts = urlparse(urinorm.urinorm(return_to))\n        msg_parts = urlparse(urinorm.urinorm(msg_return_to))\n\n        # (addressing scheme, network location, path) must be equal in\n        # both URLs.\n        for part in range(0, 3):\n            if app_parts[part] != msg_parts[part]:\n                return False\n\n        return True", "response": "Check an OpenID message and its OpenID. return_to value against a return_to URL from an application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nverify that the discovery of the given services matches the assertion.", "response": "def _verifyDiscoveredServices(self, claimed_id, services,\n                                  to_match_endpoints):\n        \"\"\"See @L{_discoverAndVerify}\"\"\"\n\n        # Search the services resulting from discovery to find one\n        # that matches the information from the assertion\n        failure_messages = []\n        for endpoint in services:\n            for to_match_endpoint in to_match_endpoints:\n                try:\n                    self._verifyDiscoverySingle(endpoint, to_match_endpoint)\n                except ProtocolError as why:\n                    failure_messages.append(str(why))\n                else:\n                    # It matches, so discover verification has\n                    # succeeded. Return this endpoint.\n                    return endpoint\n        else:\n            logging.error('Discovery verification failure for %s' %\n                          (claimed_id, ))\n            for failure_message in failure_messages:\n                logging.error(' * Endpoint mismatch: ' + failure_message)\n\n            raise DiscoveryFailure(\n                'No matching endpoint found after discovering %s' %\n                (claimed_id, ), None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _checkAuth(self, message, server_url):\n        logging.info('Using OpenID check_authentication')\n        request = self._createCheckAuthRequest(message)\n        if request is None:\n            return False\n        try:\n            response = self._makeKVPost(request, server_url)\n        except (fetchers.HTTPFetchingError, ServerError) as e:\n            e0 = e.args[0]\n            logging.exception('check_authentication failed: %s' % e0)\n            return False\n        else:\n            return self._processCheckAuthResponse(response, server_url)", "response": "Make a check_authentication request to verify this message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a check_authentication request message given an ancipline id_res message.", "response": "def _createCheckAuthRequest(self, message):\n        \"\"\"Generate a check_authentication request message given an\n        id_res message.\n        \"\"\"\n        signed = message.getArg(OPENID_NS, 'signed')\n        if signed:\n            if isinstance(signed, bytes):\n                signed = str(signed, encoding=\"utf-8\")\n            for k in signed.split(','):\n                logging.info(k)\n                val = message.getAliasedArg(k)\n\n                # Signed value is missing\n                if val is None:\n                    logging.info('Missing signed field %r' % (k, ))\n                    return None\n\n        check_auth_message = message.copy()\n        check_auth_message.setArg(OPENID_NS, 'mode', 'check_authentication')\n        return check_auth_message"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _negotiateAssociation(self, endpoint):\n        # Get our preferred session/association type from the negotiatior.\n        assoc_type, session_type = self.negotiator.getAllowedType()\n\n        try:\n            assoc = self._requestAssociation(endpoint, assoc_type,\n                                             session_type)\n        except ServerError as why:\n            supportedTypes = self._extractSupportedAssociationType(\n                why, endpoint, assoc_type)\n            if supportedTypes is not None:\n                assoc_type, session_type = supportedTypes\n                # Attempt to create an association from the assoc_type\n                # and session_type that the server told us it\n                # supported.\n                try:\n                    assoc = self._requestAssociation(endpoint, assoc_type,\n                                                     session_type)\n                except ServerError as why:\n                    # Do not keep trying, since it rejected the\n                    # association type that it told us to use.\n                    logging.error(\n                        'Server %s refused its suggested association '\n                        'type: session_type=%s, assoc_type=%s' % (\n                            endpoint.server_url, session_type, assoc_type))\n                    return None\n                else:\n                    return assoc\n        else:\n            return assoc", "response": "Attempts to create a new association from the server and returns the association object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive an association response message extract the OpenID 1. X session type.", "response": "def _getOpenID1SessionType(self, assoc_response):\n        \"\"\"Given an association response message, extract the OpenID\n        1.X session type.\n\n        This function mostly takes care of the 'no-encryption' default\n        behavior in OpenID 1.\n\n        If the association type is plain-text, this function will\n        return 'no-encryption'\n\n        @returns: The association type for this message\n        @rtype: str\n\n        @raises KeyError: when the session_type field is absent.\n        \"\"\"\n        # If it's an OpenID 1 message, allow session_type to default\n        # to None (which signifies \"no-encryption\")\n        session_type = assoc_response.getArg(OPENID1_NS, 'session_type')\n\n        # Handle the differences between no-encryption association\n        # respones in OpenID 1 and 2:\n\n        # no-encryption is not really a valid session type for\n        # OpenID 1, but we'll accept it anyway, while issuing a\n        # warning.\n        if session_type == 'no-encryption':\n            logging.warning('OpenID server sent \"no-encryption\"'\n                            'for OpenID 1.X')\n\n        # Missing or empty session type is the way to flag a\n        # 'no-encryption' response. Change the session type to\n        # 'no-encryption' so that it can be handled in the same\n        # way as OpenID 2 'no-encryption' respones.\n        elif session_type == '' or session_type is None:\n            session_type = 'no-encryption'\n\n        return session_type"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nnormalizes a URL converting normalization failures to DiscoveryFailure", "response": "def normalizeURL(url):\n    \"\"\"Normalize a URL, converting normalization failures to\n    DiscoveryFailure\"\"\"\n    try:\n        normalized = urinorm.urinorm(url)\n    except ValueError as why:\n        raise DiscoveryFailure('Normalizing identifier: %s' % (why, ), None)\n    else:\n        return urllib.parse.urldefrag(normalized)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getDisplayIdentifier(self):\n        if self.display_identifier is not None:\n            return self.display_identifier\n        if self.claimed_id is None:\n            return None\n        else:\n            return urllib.parse.urldefrag(self.claimed_id)[0]", "response": "Return the display identifier if set else return the claimed_id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the given text as an XRDS document.", "response": "def parseXRDS(text):\n    \"\"\"Parse the given text as an XRDS document.\n\n    @return: ElementTree containing an XRDS document\n\n    @raises XRDSError: When there is a parse error or the document does\n        not contain an XRDS.\n    \"\"\"\n    try:\n        # lxml prefers to parse bytestrings, and occasionally chokes on a\n        # combination of text strings and declared XML encodings -- see\n        # https://github.com/necaris/python3-openid/issues/19\n        # To avoid this, we ensure that the 'text' we're parsing is actually\n        # a bytestring\n        bytestring = text.encode('utf8') if isinstance(text, str) else text\n        element = SafeElementTree.XML(bytestring)\n    except (SystemExit, MemoryError, AssertionError, ImportError):\n        raise\n    except Exception as why:\n        exc = XRDSError('Error parsing document as XML')\n        exc.reason = why\n        raise exc\n    else:\n        tree = ElementTree.ElementTree(element)\n        if not isXRDS(tree):\n            raise XRDSError('Not an XRDS document')\n\n        return tree"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prioSort(elements):\n    # Randomize the services before sorting so that equal priority\n    # elements are load-balanced.\n    random.shuffle(elements)\n\n    sorted_elems = sorted(elements, key=getPriority)\n    return sorted_elems", "response": "Sort a list of elements that have priority attributes"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind a working ElementTree implementation that is not vulnerable to XXE using defusedxml.", "response": "def importSafeElementTree(module_names=None):\n    \"\"\"Find a working ElementTree implementation that is not vulnerable\n    to XXE, using `defusedxml`.\n\n    >>> XXESafeElementTree = importSafeElementTree()\n\n    @param module_names: The names of modules to try to use as\n        a safe ElementTree. Defaults to C{L{xxe_safe_elementtree_modules}}\n\n    @returns: An ElementTree module that is not vulnerable to XXE.\n    \"\"\"\n    if module_names is None:\n        module_names = xxe_safe_elementtree_modules\n    try:\n        return importElementTree(module_names)\n    except ImportError:\n        raise ImportError('Unable to find a ElementTree module '\n                          'that is not vulnerable to XXE. '\n                          'Tried importing %r' % (module_names, ))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nappend query arguments to a URL.", "response": "def appendArgs(url, args):\n    \"\"\"Append query arguments to a HTTP(s) URL. If the URL already has\n    query arguemtns, these arguments will be added, and the existing\n    arguments will be preserved. Duplicate arguments will not be\n    detected or collapsed (both will appear in the output).\n\n    @param url: The url to which the arguments will be appended\n    @type url: str\n\n    @param args: The query arguments to add to the URL. If a\n        dictionary is passed, the items will be sorted before\n        appending them to the URL. If a sequence of pairs is passed,\n        the order of the sequence will be preserved.\n    @type args: A dictionary from string to string, or a sequence of\n        pairs of strings.\n\n    @returns: The URL with the parameters added\n    @rtype: str\n    \"\"\"\n    if hasattr(args, 'items'):\n        args = sorted(args.items())\n    else:\n        args = list(args)\n\n    if not isinstance(url, str):\n        url = str(url, encoding=\"utf-8\")\n\n    if not args:\n        return url\n\n    if '?' in url:\n        sep = '&'\n    else:\n        sep = '?'\n\n    # Map unicode to UTF-8 if present. Do not make any assumptions\n    # about the encodings of plain bytes (str).\n    i = 0\n    for k, v in args:\n        if not isinstance(k, bytes):\n            k = k.encode('utf-8')\n\n        if not isinstance(v, bytes):\n            v = v.encode('utf-8')\n\n        args[i] = (k, v)\n        i += 1\n\n    return '%s%s%s' % (url, sep, urlencode(args))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrepresenting string / bytes s as base64 omitting newlines", "response": "def toBase64(s):\n    \"\"\"Represent string / bytes s as base64, omitting newlines\"\"\"\n    if isinstance(s, str):\n        s = s.encode(\"utf-8\")\n    return binascii.b2a_base64(s)[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves expired associations. @return: tuple of (removed associations, remaining associations)", "response": "def cleanup(self):\n        \"\"\"Remove expired associations.\n\n        @return: tuple of (removed associations, remaining associations)\n        \"\"\"\n        remove = []\n        for handle, assoc in self.assocs.items():\n            if assoc.expiresIn == 0:\n                remove.append(handle)\n        for handle in remove:\n            del self.assocs[handle]\n        return len(remove), len(self.assocs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _checkMode(self, ax_args):\n        mode = ax_args.get('mode')\n        if isinstance(mode, bytes):\n            mode = str(mode, encoding=\"utf-8\")\n        if mode != self.mode:\n            if not mode:\n                raise NotAXMessage()\n            else:\n                raise AXError('Expected mode %r; got %r' % (self.mode, mode))", "response": "Raise an exception if the mode in the attribute exchange\n        arguments does not match what is expected for this class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getExtensionArgs(self):\n        aliases = NamespaceMap()\n\n        required = []\n        if_available = []\n\n        ax_args = self._newArgs()\n\n        for type_uri, attribute in self.requested_attributes.items():\n            if attribute.alias is None:\n                alias = aliases.add(type_uri)\n            else:\n                # This will raise an exception when the second\n                # attribute with the same alias is added. I think it\n                # would be better to complain at the time that the\n                # attribute is added to this object so that the code\n                # that is adding it is identified in the stack trace,\n                # but it's more work to do so, and it won't be 100%\n                # accurate anyway, since the attributes are\n                # mutable. So for now, just live with the fact that\n                # we'll learn about the error later.\n                #\n                # The other possible approach is to hide the error and\n                # generate a new alias on the fly. I think that would\n                # probably be bad.\n                alias = aliases.addAlias(type_uri, attribute.alias)\n\n            if attribute.required:\n                required.append(alias)\n            else:\n                if_available.append(alias)\n\n            if attribute.count != 1:\n                ax_args['count.' + alias] = str(attribute.count)\n\n            ax_args['type.' + alias] = type_uri\n\n        if required:\n            ax_args['required'] = ','.join(required)\n\n        if if_available:\n            ax_args['if_available'] = ','.join(if_available)\n\n        return ax_args", "response": "Returns the serialized form of this attribute fetch request."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the type URIs for all attributes that have been marked as required.", "response": "def getRequiredAttrs(self):\n        \"\"\"Get the type URIs for all attributes that have been marked\n        as required.\n\n        @returns: A list of the type URIs for attributes that have\n            been marked as required.\n        @rtype: [str]\n        \"\"\"\n        required = []\n        for type_uri, attribute in self.requested_attributes.items():\n            if attribute.required:\n                required.append(type_uri)\n\n        return required"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextracting a FetchRequest from an OpenID message containing the attribute fetch request .", "response": "def fromOpenIDRequest(cls, openid_request):\n        \"\"\"Extract a FetchRequest from an OpenID message\n\n        @param openid_request: The OpenID authentication request\n            containing the attribute fetch request\n        @type openid_request: C{L{openid.server.server.CheckIDRequest}}\n\n        @rtype: C{L{FetchRequest}} or C{None}\n        @returns: The FetchRequest extracted from the message or None, if\n            the message contained no AX extension.\n\n        @raises KeyError: if the AuthRequest is not consistent in its use\n            of namespace aliases.\n\n        @raises AXError: When parseExtensionArgs would raise same.\n\n        @see: L{parseExtensionArgs}\n        \"\"\"\n        message = openid_request.message\n        ax_args = message.getArgs(cls.ns_uri)\n        self = cls()\n        try:\n            self.parseExtensionArgs(ax_args)\n        except NotAXMessage as err:\n            return None\n\n        if self.update_url:\n            # Update URL must match the openid.realm of the underlying\n            # OpenID 2 message.\n            realm = message.getArg(OPENID_NS, 'realm',\n                                   message.getArg(OPENID_NS, 'return_to'))\n\n            if not realm:\n                raise AXError(\n                    (\"Cannot validate update_url %r \" + \"against absent realm\")\n                    % (self.update_url, ))\n\n            tr = TrustRoot.parse(realm)\n            if not tr.validateURL(self.update_url):\n                raise AXError(\n                    \"Update URL %r failed validation against realm %r\" %\n                    (self.update_url, realm, ))\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the arguments from the message and populate this FetchRequest.", "response": "def parseExtensionArgs(self, ax_args):\n        \"\"\"Given attribute exchange arguments, populate this FetchRequest.\n\n        @param ax_args: Attribute Exchange arguments from the request.\n            As returned from L{Message.getArgs<openid.message.Message.getArgs>}.\n        @type ax_args: dict\n\n        @raises KeyError: if the message is not consistent in its use\n            of namespace aliases.\n\n        @raises NotAXMessage: If ax_args does not include an Attribute Exchange\n            mode.\n\n        @raises AXError: If the data to be parsed does not follow the\n            attribute exchange specification. At least when\n            'if_available' or 'required' is not specified for a\n            particular attribute type.\n        \"\"\"\n        # Raises an exception if the mode is not the expected value\n        self._checkMode(ax_args)\n\n        aliases = NamespaceMap()\n\n        for key, value in ax_args.items():\n            if key.startswith('type.'):\n                alias = key[5:]\n                type_uri = value\n                aliases.addAlias(type_uri, alias)\n\n                count_key = 'count.' + alias\n                count_s = ax_args.get(count_key)\n                if count_s:\n                    try:\n                        count = int(count_s)\n                        if count <= 0:\n                            raise AXError(\n                                \"Count %r must be greater than zero, got %r\" %\n                                (count_key, count_s, ))\n                    except ValueError:\n                        if count_s != UNLIMITED_VALUES:\n                            raise AXError(\"Invalid count value for %r: %r\" %\n                                          (count_key, count_s, ))\n                        count = count_s\n                else:\n                    count = 1\n\n                self.add(AttrInfo(type_uri, alias=alias, count=count))\n\n        required = toTypeURIs(aliases, ax_args.get('required'))\n\n        for type_uri in required:\n            self.requested_attributes[type_uri].required = True\n\n        if_available = toTypeURIs(aliases, ax_args.get('if_available'))\n\n        all_type_uris = required + if_available\n\n        for type_uri in aliases.iterNamespaceURIs():\n            if type_uri not in all_type_uris:\n                raise AXError('Type URI %r was in the request but not '\n                              'present in \"required\" or \"if_available\"' %\n                              (type_uri, ))\n\n        self.update_url = ax_args.get('update_url')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef findLinksRel(link_attrs_list, target_rel):\n    # XXX: TESTME\n    matchesTarget = lambda attrs: linkHasRel(attrs, target_rel)\n    return list(filter(matchesTarget, link_attrs_list))", "response": "Filter the list of link attributes on whether it has target_rel as a relationship."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef txn_getAssociation(self, server_url, handle=None):\n        if handle is not None:\n            self.db_get_assoc(server_url, handle)\n        else:\n            self.db_get_assocs(server_url)\n\n        rows = self.cur.fetchall()\n        if len(rows) == 0:\n            return None\n        else:\n            associations = []\n            for values in rows:\n                values = list(values)\n                values[1] = self.blobDecode(values[1])\n                assoc = Association(*values)\n                if assoc.expiresIn == 0:\n                    self.txn_removeAssociation(server_url, assoc.handle)\n                else:\n                    associations.append((assoc.issued, assoc))\n\n            if associations:\n                associations.sort()\n                return associations[-1][1]\n            else:\n                return None", "response": "Get the most recent association that has been set for this server URL and handle."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconstructing an HTTPResponse from the urllib2 response.", "response": "def _makeResponse(self, urllib2_response):\n        '''\n        Construct an HTTPResponse from the the urllib response. Attempt to\n        decode the response body from bytes to str if the necessary information\n        is available.\n        '''\n        resp = HTTPResponse()\n        resp.body = urllib2_response.read(MAX_RESPONSE_KB * 1024)\n        resp.final_url = urllib2_response.geturl()\n        resp.headers = self._lowerCaseKeys(\n            dict(list(urllib2_response.info().items())))\n\n        if hasattr(urllib2_response, 'code'):\n            resp.status = urllib2_response.code\n        else:\n            resp.status = 200\n\n        _, extra_dict = self._parseHeaderValue(\n            resp.headers.get(\"content-type\", \"\"))\n        # Try to decode the response body to a string, if there's a\n        # charset known; fall back to ISO-8859-1 otherwise, since that's\n        # what's suggested in HTTP/1.1\n        charset = extra_dict.get('charset', 'latin1')\n        try:\n            resp.body = resp.body.decode(charset)\n        except Exception:\n            pass\n\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parseHeaderValue(self, header_value):\n        values = header_value.split(';', 1)\n        if len(values) == 1:\n            # There's no extra info -- return the main value and an empty dict\n            return values[0], {}\n        main_value, extra_values = values[0], values[1].split(';')\n        extra_dict = {}\n        for value_string in extra_values:\n            try:\n                key, value = value_string.split('=', 1)\n                extra_dict[key.strip()] = value.strip()\n            except ValueError:\n                # Can't unpack it -- must be malformed. Ignore\n                pass\n        return main_value, extra_dict", "response": "Parse out a complex header value such as Content - Type charset = utf - 8 and return the main value and extra information dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters a namespace URI and alias mapping in a global namespace alias map.", "response": "def registerNamespaceAlias(namespace_uri, alias):\n    \"\"\"\n    Registers a (namespace URI, alias) mapping in a global namespace\n    alias map.  Raises NamespaceAliasRegistrationError if either the\n    namespace URI or alias has already been registered with a\n    different value.  This function is required if you want to use a\n    namespace with an OpenID 1 message.\n    \"\"\"\n    global registered_aliases\n\n    if registered_aliases.get(alias) == namespace_uri:\n        return\n\n    if namespace_uri in list(registered_aliases.values()):\n        raise NamespaceAliasRegistrationError(\n            'Namespace uri %r already registered' % (namespace_uri, ))\n\n    if alias in registered_aliases:\n        raise NamespaceAliasRegistrationError('Alias %r already registered' %\n                                              (alias, ))\n\n    registered_aliases[alias] = namespace_uri"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setOpenIDNamespace(self, openid_ns_uri, implicit):\n        if isinstance(openid_ns_uri, bytes):\n            openid_ns_uri = str(openid_ns_uri, encoding=\"utf-8\")\n        if openid_ns_uri not in self.allowed_openid_namespaces:\n            raise InvalidOpenIDNamespace(openid_ns_uri)\n\n        self.namespaces.addAlias(openid_ns_uri, NULL_NAMESPACE, implicit)\n        self._openid_ns_uri = openid_ns_uri", "response": "Sets the OpenID namespace URI used in this message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef toPostArgs(self):\n        args = {}\n\n        # Add namespace definitions to the output\n        for ns_uri, alias in self.namespaces.items():\n            if self.namespaces.isImplicit(ns_uri):\n                continue\n            if alias == NULL_NAMESPACE:\n                ns_key = 'openid.ns'\n            else:\n                ns_key = 'openid.ns.' + alias\n            args[ns_key] = oidutil.toUnicode(ns_uri)\n\n        for (ns_uri, ns_key), value in self.args.items():\n            key = self.getKey(ns_uri, ns_key)\n            # Ensure the resulting value is an UTF-8 encoded *bytestring*.\n            args[key] = oidutil.toUnicode(value)\n\n        return args", "response": "Return all arguments with openid. in front of namespaced arguments."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef toArgs(self):\n        # FIXME - undocumented exception\n        post_args = self.toPostArgs()\n        kvargs = {}\n        for k, v in post_args.items():\n            if not k.startswith('openid.'):\n                raise ValueError(\n                    'This message can only be encoded as a POST, because it '\n                    'contains arguments that are not prefixed with \"openid.\"')\n            else:\n                kvargs[k[7:]] = v\n\n        return kvargs", "response": "Return all namespaced arguments failing if any\n        non - namespaced arguments exist."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef toFormMarkup(self,\n                     action_url,\n                     form_tag_attrs=None,\n                     submit_text=\"Continue\"):\n        \"\"\"Generate HTML form markup that contains the values in this\n        message, to be HTTP POSTed as x-www-form-urlencoded UTF-8.\n\n        @param action_url: The URL to which the form will be POSTed\n        @type action_url: str\n\n        @param form_tag_attrs: Dictionary of attributes to be added to\n            the form tag. 'accept-charset' and 'enctype' have defaults\n            that can be overridden. If a value is supplied for\n            'action' or 'method', it will be replaced.\n        @type form_tag_attrs: {unicode: unicode}\n\n        @param submit_text: The text that will appear on the submit\n            button for this form.\n        @type submit_text: unicode\n\n        @returns: A string containing (X)HTML markup for a form that\n            encodes the values in this Message object.\n        @rtype: str\n        \"\"\"\n        if ElementTree is None:\n            raise RuntimeError('This function requires ElementTree.')\n\n        assert action_url is not None\n\n        form = ElementTree.Element('form')\n\n        if form_tag_attrs:\n            for name, attr in form_tag_attrs.items():\n                form.attrib[name] = attr\n\n        form.attrib['action'] = oidutil.toUnicode(action_url)\n        form.attrib['method'] = 'post'\n        form.attrib['accept-charset'] = 'UTF-8'\n        form.attrib['enctype'] = 'application/x-www-form-urlencoded'\n\n        for name, value in self.toPostArgs().items():\n            attrs = {\n                'type': 'hidden',\n                'name': oidutil.toUnicode(name),\n                'value': oidutil.toUnicode(value)\n            }\n            form.append(ElementTree.Element('input', attrs))\n\n        submit = ElementTree.Element(\n            'input',\n            {'type': 'submit',\n             'value': oidutil.toUnicode(submit_text)})\n        form.append(submit)\n\n        return str(ElementTree.tostring(form, encoding='utf-8'),\n                   encoding=\"utf-8\")", "response": "Generates an HTML form markup that contains the values in this Message object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating an x - www - urlencoded string", "response": "def toURLEncoded(self):\n        \"\"\"Generate an x-www-urlencoded string\"\"\"\n        args = sorted(self.toPostArgs().items())\n        return urllib.parse.urlencode(args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts an input value into the internally used values of this object is returned.", "response": "def _fixNS(self, namespace):\n        \"\"\"Convert an input value into the internally used values of\n        this object\n\n        @param namespace: The string or constant to convert\n        @type namespace: str or unicode or BARE_NS or OPENID_NS\n        \"\"\"\n        if isinstance(namespace, bytes):\n            namespace = str(namespace, encoding=\"utf-8\")\n\n        if namespace == OPENID_NS:\n            if self._openid_ns_uri is None:\n                raise UndefinedOpenIDNamespace('OpenID namespace not set')\n            else:\n                namespace = self._openid_ns_uri\n\n        if namespace != BARE_NS and not isinstance(namespace, str):\n            raise TypeError(\n                \"Namespace must be BARE_NS, OPENID_NS or a string. got %r\" %\n                (namespace, ))\n\n        if namespace != BARE_NS and ':' not in namespace:\n            fmt = 'OpenID 2.0 namespace identifiers SHOULD be URIs. Got %r'\n            warnings.warn(fmt % (namespace, ), DeprecationWarning)\n\n            if namespace == 'sreg':\n                fmt = 'Using %r instead of \"sreg\" as namespace'\n                warnings.warn(\n                    fmt % (SREG_URI, ),\n                    DeprecationWarning, )\n                return SREG_URI\n\n        return namespace"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the arguments that are defined for this namespace URI", "response": "def getArgs(self, namespace):\n        \"\"\"Get the arguments that are defined for this namespace URI\n\n        @returns: mapping from namespaced keys to values\n        @returntype: dict of {str:bytes}\n        \"\"\"\n        namespace = self._fixNS(namespace)\n        args = []\n        for ((pair_ns, ns_key), value) in self.args.items():\n            if pair_ns == namespace:\n                if isinstance(ns_key, bytes):\n                    k = str(ns_key, encoding=\"utf-8\")\n                else:\n                    k = ns_key\n                if isinstance(value, bytes):\n                    v = str(value, encoding=\"utf-8\")\n                else:\n                    v = value\n                args.append((k, v))\n        return dict(args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset a single argument in this namespace", "response": "def setArg(self, namespace, key, value):\n        \"\"\"Set a single argument in this namespace\"\"\"\n        assert key is not None\n        assert value is not None\n        namespace = self._fixNS(namespace)\n        # try to ensure that internally it's consistent, at least: str -> str\n        if isinstance(value, bytes):\n            value = str(value, encoding=\"utf-8\")\n        self.args[(namespace, key)] = value\n        if not (namespace is BARE_NS):\n            self.namespaces.add(namespace)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding an alias from this namespace URI to the desired alias.", "response": "def addAlias(self, namespace_uri, desired_alias, implicit=False):\n        \"\"\"Add an alias from this namespace URI to the desired alias\n        \"\"\"\n        if isinstance(namespace_uri, bytes):\n            namespace_uri = str(namespace_uri, encoding=\"utf-8\")\n        # Check that desired_alias is not an openid protocol field as\n        # per the spec.\n        assert desired_alias not in OPENID_PROTOCOL_FIELDS, \\\n               \"%r is not an allowed namespace alias\" % (desired_alias,)\n\n        # Check that desired_alias does not contain a period as per\n        # the spec.\n        if isinstance(desired_alias, str):\n            assert '.' not in desired_alias, \\\n                   \"%r must not contain a dot\" % (desired_alias,)\n\n        # Check that there is not a namespace already defined for\n        # the desired alias\n        current_namespace_uri = self.alias_to_namespace.get(desired_alias)\n        if (current_namespace_uri is not None and\n                current_namespace_uri != namespace_uri):\n\n            fmt = ('Cannot map %r to alias %r. '\n                   '%r is already mapped to alias %r')\n\n            msg = fmt % (namespace_uri, desired_alias, current_namespace_uri,\n                         desired_alias)\n            raise KeyError(msg)\n\n        # Check that there is not already a (different) alias for\n        # this namespace URI\n        alias = self.namespace_to_alias.get(namespace_uri)\n        if alias is not None and alias != desired_alias:\n            fmt = ('Cannot map %r to alias %r. '\n                   'It is already mapped to alias %r')\n            raise KeyError(fmt % (namespace_uri, desired_alias, alias))\n\n        assert (desired_alias == NULL_NAMESPACE or\n                type(desired_alias) in [str, str]), repr(desired_alias)\n        assert namespace_uri not in self.implicit_namespaces\n        self.alias_to_namespace[desired_alias] = namespace_uri\n        self.namespace_to_alias[namespace_uri] = desired_alias\n        if implicit:\n            self.implicit_namespaces.append(namespace_uri)\n        return desired_alias"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _appendArgs(url, args):\n    # to be merged with oidutil.appendArgs when we combine the projects.\n    if hasattr(args, 'items'):\n        args = list(args.items())\n        args.sort()\n\n    if len(args) == 0:\n        return url\n\n    # According to XRI Resolution section \"QXRI query parameters\":\n    #\n    # \"\"\"If the original QXRI had a null query component (only a leading\n    #    question mark), or a query component consisting of only question\n    #    marks, one additional leading question mark MUST be added when\n    #    adding any XRI resolution parameters.\"\"\"\n\n    if '?' in url.rstrip('?'):\n        sep = '&'\n    else:\n        sep = '?'\n\n    return '%s%s%s' % (url, sep, urlencode(args))", "response": "Append some arguments to an HTTP query."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an OpenID association store object based on the database engine chosen for this Django application.", "response": "def getOpenIDStore(filestore_path, table_prefix):\n    \"\"\"\n    Returns an OpenID association store object based on the database\n    engine chosen for this Django application.\n\n    * If no database engine is chosen, a filesystem-based store will\n      be used whose path is filestore_path.\n\n    * If a database engine is chosen, a store object for that database\n      type will be returned.\n\n    * If the chosen engine is not supported by the OpenID library,\n      raise ImproperlyConfigured.\n\n    * If a database store is used, this will create the tables\n      necessary to use it.  The table names will be prefixed with\n      table_prefix.  DO NOT use the same table prefix for both an\n      OpenID consumer and an OpenID server in the same database.\n\n    The result of this function should be passed to the Consumer\n    constructor as the store parameter.\n    \"\"\"\n\n    db_engine = settings.DATABASES['default']['ENGINE']\n    if not db_engine:\n        return FileOpenIDStore(filestore_path)\n\n    # Possible side-effect: create a database connection if one isn't\n    # already open.\n    connection.cursor()\n\n    # Create table names to specify for SQL-backed stores.\n    tablenames = {\n        'associations_table': table_prefix + 'openid_associations',\n        'nonces_table': table_prefix + 'openid_nonces',\n    }\n\n    types = {\n        'django.db.backends.postgresql_psycopg2': sqlstore.PostgreSQLStore,\n        'django.db.backends.mysql': sqlstore.MySQLStore,\n        'django.db.backends.sqlite3': sqlstore.SQLiteStore,\n    }\n\n    if db_engine not in types:\n        raise ImproperlyConfigured(\n            \"Database engine %s not supported by OpenID library\" % db_engine)\n\n    s = types[db_engine](connection.connection, **tablenames)\n\n    try:\n        s.createTables()\n    except (SystemExit, KeyboardInterrupt, MemoryError):\n        raise\n    except:\n        # XXX This is not the Right Way to do this, but because the\n        # underlying database implementation might differ in behavior\n        # at this point, we can't reliably catch the right\n        # exception(s) here.  Ideally, the SQL store in the OpenID\n        # library would catch exceptions that it expects and fail\n        # silently, but that could be bad, too.  More ideally, the SQL\n        # store would not attempt to create tables it knows already\n        # exists.\n        pass\n\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering an XRDS page with the specified type URIs and endpoint_urls in one service block and return a response with the appropriate content - type.", "response": "def renderXRDS(request, type_uris, endpoint_urls):\n    \"\"\"Render an XRDS page with the specified type URIs and endpoint\n    URLs in one service block, and return a response with the\n    appropriate content-type.\n    \"\"\"\n    response = render_to_response(\n        'xrds.xml', {'type_uris': type_uris,\n                     'endpoint_urls': endpoint_urls},\n        context_instance=RequestContext(request))\n    response['Content-Type'] = YADIS_CONTENT_TYPE\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _pct_escape_handler(err):\n    '''\n    Encoding error handler that does percent-escaping of Unicode, to be used\n    with codecs.register_error\n    TODO: replace use of this with urllib.parse.quote as appropriate\n    '''\n    chunk = err.object[err.start:err.end]\n    replacements = _pct_encoded_replacements(chunk)\n    return (\"\".join(replacements), err.end)", "response": "Decode a percent - escaped Unicode chunk into a sequence of percent - encoded characters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a sequence of strings as newline - terminated key - value pairs into a single string.", "response": "def seqToKV(seq, strict=False):\n    \"\"\"Represent a sequence of pairs of strings as newline-terminated\n    key:value pairs. The pairs are generated in the order given.\n\n    @param seq: The pairs\n    @type seq: [(str, (unicode|str))]\n\n    @return: A string representation of the sequence\n    @rtype: bytes\n    \"\"\"\n\n    def err(msg):\n        formatted = 'seqToKV warning: %s: %r' % (msg, seq)\n        if strict:\n            raise KVFormError(formatted)\n        else:\n            logging.warning(formatted)\n\n    lines = []\n    for k, v in seq:\n        if isinstance(k, bytes):\n            k = k.decode('utf-8')\n        elif not isinstance(k, str):\n            err('Converting key to string: %r' % k)\n            k = str(k)\n\n        if '\\n' in k:\n            raise KVFormError(\n                'Invalid input for seqToKV: key contains newline: %r' % (k, ))\n\n        if ':' in k:\n            raise KVFormError(\n                'Invalid input for seqToKV: key contains colon: %r' % (k, ))\n\n        if k.strip() != k:\n            err('Key has whitespace at beginning or end: %r' % (k, ))\n\n        if isinstance(v, bytes):\n            v = v.decode('utf-8')\n        elif not isinstance(v, str):\n            err('Converting value to string: %r' % (v, ))\n            v = str(v)\n\n        if '\\n' in v:\n            raise KVFormError(\n                'Invalid input for seqToKV: value contains newline: %r' %\n                (v, ))\n\n        if v.strip() != v:\n            err('Value has whitespace at beginning or end: %r' % (v, ))\n\n        lines.append(k + ':' + v + '\\n')\n\n    return ''.join(lines).encode('utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iriToURI(iri):\n    # According to RFC 3987, section 3.1, \"Mapping of IRIs to URIs\"\n    if isinstance(iri, bytes):\n        iri = str(iri, encoding=\"utf-8\")\n    return iri.encode('ascii', errors='oid_percent_escape').decode()", "response": "Transform an IRI to a URI by escaping unicode."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef urinorm(uri):\n    '''\n    Normalize a URI\n    '''\n    # TODO: use urllib.parse instead of these complex regular expressions\n    if isinstance(uri, bytes):\n        uri = str(uri, encoding='utf-8')\n\n    uri = uri.encode('ascii', errors='oid_percent_escape').decode('utf-8')\n    # _escapeme_re.sub(_pct_escape_unicode, uri).encode('ascii').decode()\n\n    illegal_mo = uri_illegal_char_re.search(uri)\n    if illegal_mo:\n        raise ValueError('Illegal characters in URI: %r at position %s' %\n                         (illegal_mo.group(), illegal_mo.start()))\n\n    uri_mo = uri_re.match(uri)\n\n    scheme = uri_mo.group(2)\n    if scheme is None:\n        raise ValueError('No scheme specified')\n\n    scheme = scheme.lower()\n    if scheme not in ('http', 'https'):\n        raise ValueError('Not an absolute HTTP or HTTPS URI: %r' % (uri, ))\n\n    authority = uri_mo.group(4)\n    if authority is None:\n        raise ValueError('Not an absolute URI: %r' % (uri, ))\n\n    authority_mo = authority_re.match(authority)\n    if authority_mo is None:\n        raise ValueError('URI does not have a valid authority: %r' % (uri, ))\n\n    userinfo, host, port = authority_mo.groups()\n\n    if userinfo is None:\n        userinfo = ''\n\n    if '%' in host:\n        host = host.lower()\n        host = pct_encoded_re.sub(_pct_encoded_replace, host)\n        host = host.encode('idna').decode()\n    else:\n        host = host.lower()\n\n    if port:\n        if (port == ':' or (scheme == 'http' and port == ':80') or\n            (scheme == 'https' and port == ':443')):\n            port = ''\n    else:\n        port = ''\n\n    authority = userinfo + host + port\n\n    path = uri_mo.group(5)\n    path = pct_encoded_re.sub(_pct_encoded_replace_unreserved, path)\n    path = remove_dot_segments(path)\n    if not path:\n        path = '/'\n\n    query = uri_mo.group(6)\n    if query is None:\n        query = ''\n\n    fragment = uri_mo.group(8)\n    if fragment is None:\n        fragment = ''\n\n    return scheme + '://' + authority + path + query + fragment", "response": "Normalize a URI into a set of URI components."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef server(request):\n    return render_to_response(\n        'server/index.html', {\n            'user_url': getViewURL(request, idPage),\n            'server_xrds_url': getViewURL(request, idpXrds),\n        },\n        context_instance=RequestContext(request))", "response": "Respond to requests for the server s primary web page."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndisplays an OpenID response.", "response": "def displayResponse(request, openid_response):\n    \"\"\"\n    Display an OpenID response.  Errors will be displayed directly to\n    the user; successful responses and other protocol-level messages\n    will be sent using the proper mechanism (i.e., direct response,\n    redirection, etc.).\n    \"\"\"\n    s = getServer(request)\n\n    # Encode the response into something that is renderable.\n    try:\n        webresponse = s.encodeResponse(openid_response)\n    except EncodingError as why:\n        # If it couldn't be encoded, display an error.\n        text = why.response.encodeToKVForm()\n        return render_to_response(\n            'server/endpoint.html', {'error': cgi.escape(text)},\n            context_instance=RequestContext(request))\n\n    # Construct the appropriate django framework response.\n    r = http.HttpResponse(webresponse.body)\n    r.status_code = webresponse.code\n\n    for header, value in webresponse.headers.items():\n        r[header] = value\n\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nattempts to remove a file and return whether the file existed at the time of the call.", "response": "def _removeIfPresent(filename):\n    \"\"\"Attempt to remove a file, returning whether the file existed at\n    the time of the call.\n\n    str -> bool\n    \"\"\"\n    try:\n        os.unlink(filename)\n    except OSError as why:\n        if why.errno == ENOENT:\n            # Someone beat us to it, but it's gone, so that's OK\n            return 0\n        else:\n            raise\n    else:\n        # File was present\n        return 1"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstoring an association in the association directory.", "response": "def storeAssociation(self, server_url, association):\n        \"\"\"Store an association in the association directory.\n\n        (str, Association) -> NoneType\n        \"\"\"\n        association_s = association.serialize()  # NOTE: UTF-8 encoded bytes\n        filename = self.getAssociationFilename(server_url, association.handle)\n        tmp_file, tmp = self._mktemp()\n\n        try:\n            try:\n                tmp_file.write(association_s)\n                os.fsync(tmp_file.fileno())\n            finally:\n                tmp_file.close()\n\n            try:\n                os.rename(tmp, filename)\n            except OSError as why:\n                if why.errno != EEXIST:\n                    raise\n\n                # We only expect EEXIST to happen only on Windows. It's\n                # possible that we will succeed in unlinking the existing\n                # file, but not in putting the temporary file in place.\n                try:\n                    os.unlink(filename)\n                except OSError as why:\n                    if why.errno == ENOENT:\n                        pass\n                    else:\n                        raise\n\n                # Now the target should not exist. Try renaming again,\n                # giving up if it fails.\n                os.rename(tmp, filename)\n        except:\n            # If there was an error, don't leave the temporary file\n            # around.\n            _removeIfPresent(tmp)\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef doVerify(self):\n\n        # First, make sure that the user entered something\n        openid_url = self.query.get('openid_identifier')\n        if not openid_url:\n            self.render(\n                'Enter an OpenID Identifier to verify.',\n                css_class='error',\n                form_contents=openid_url)\n            return\n\n        immediate = 'immediate' in self.query\n        use_sreg = 'use_sreg' in self.query\n        use_pape = 'use_pape' in self.query\n        use_stateless = 'use_stateless' in self.query\n        oidconsumer = self.getConsumer(stateless=use_stateless)\n        try:\n            request = oidconsumer.begin(openid_url)\n        except consumer.DiscoveryFailure as exc:\n            fetch_error_string = 'Error in discovery: %s' % (\n                cgi.escape(str(exc)))\n            self.render(\n                fetch_error_string,\n                css_class='error',\n                form_contents=openid_url)\n        else:\n            if request is None:\n                msg = 'No OpenID services found for <code>%s</code>' % (\n                    cgi.escape(openid_url), )\n                self.render(msg, css_class='error', form_contents=openid_url)\n            else:\n                # Then, ask the library to begin the authorization.\n                # Here we find out the identity server that will verify the\n                # user's identity, and get a token that allows us to\n                # communicate securely with the identity server.\n                if use_sreg:\n                    self.requestRegistrationData(request)\n\n                if use_pape:\n                    self.requestPAPEDetails(request)\n\n                trust_root = self.server.base_url\n                return_to = self.buildURL('process')\n                if request.shouldSendRedirect():\n                    redirect_url = request.redirectURL(\n                        trust_root, return_to, immediate=immediate)\n                    self.send_response(302)\n                    self.send_header('Location', redirect_url)\n                    self.writeUserHeader()\n                    self.end_headers()\n                else:\n                    form_html = request.htmlMarkup(\n                        trust_root,\n                        return_to,\n                        form_tag_attrs={'id': 'openid_message'},\n                        immediate=immediate)\n\n                    self.wfile.write(bytes(form_html, 'utf-8'))", "response": "This method is called by the OpenID server when the user is authorized to verify the user s identity."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef buildURL(self, action, **query):\n        base = urllib.parse.urljoin(self.server.base_url, action)\n        return appendArgs(base, query)", "response": "Build a URL relative to the server base_url with the given action and query parameters added."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef answer(self, assoc):\n        response = OpenIDResponse(self)\n        response.fields.updateArgs(OPENID_NS, {\n            'expires_in': str(assoc.expiresIn),\n            'assoc_type': self.assoc_type,\n            'assoc_handle': assoc.handle,\n        })\n        response.fields.updateArgs(OPENID_NS,\n                                   self.session.answer(assoc.secret))\n\n        if not (self.session.session_type == 'no-encryption' and\n                self.message.isOpenID1()):\n            # The session type \"no-encryption\" did not have a name\n            # in OpenID v1, it was just omitted.\n            response.fields.setArg(OPENID_NS, 'session_type',\n                                   self.session.session_type)\n\n        return response", "response": "Respond to this request with an X { association."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef whichEncoding(self):\n        if self.request.mode in BROWSER_REQUEST_MODES:\n            if self.fields.getOpenIDNamespace() == OPENID2_NS and \\\n               len(self.encodeToURL()) > OPENID1_URL_LIMIT:\n                return ENCODE_HTML_FORM\n            else:\n                return ENCODE_URL\n        else:\n            return ENCODE_KVFORM", "response": "How should I be encoded?"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates an unused auth level alias", "response": "def _generateAlias(self):\n        \"\"\"Return an unused auth level alias\"\"\"\n        for i in range(1000):\n            alias = 'cust%d' % (i, )\n            if alias not in self.auth_level_aliases:\n                return alias\n\n        raise RuntimeError('Could not find an unused alias (tried 1000!)')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the alias for the specified auth level URI.", "response": "def _getAlias(self, auth_level_uri):\n        \"\"\"Return the alias for the specified auth level URI.\n\n        @raises KeyError: if no alias is defined\n        \"\"\"\n        for (alias, existing_uri) in self.auth_level_aliases.items():\n            if auth_level_uri == existing_uri:\n                return alias\n\n        raise KeyError(auth_level_uri)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a compound filter out of a list of filter - like things Used by mkFilter", "response": "def mkCompoundFilter(parts):\n    \"\"\"Create a filter out of a list of filter-like things\n\n    Used by mkFilter\n\n    @param parts: list of filter, endpoint, callable or list of any of these\n    \"\"\"\n    # Separate into a list of callables and a list of filter objects\n    transformers = []\n    filters = []\n    for subfilter in parts:\n        try:\n            subfilter = list(subfilter)\n        except TypeError:\n            # If it's not an iterable\n            if hasattr(subfilter, 'getServiceEndpoints'):\n                # It's a full filter\n                filters.append(subfilter)\n            elif hasattr(subfilter, 'fromBasicServiceEndpoint'):\n                # It's an endpoint object, so put its endpoint\n                # conversion attribute into the list of endpoint\n                # transformers\n                transformers.append(subfilter.fromBasicServiceEndpoint)\n            elif isinstance(subfilter, collections.Callable):\n                # It's a simple callable, so add it to the list of\n                # endpoint transformers\n                transformers.append(subfilter)\n            else:\n                raise filter_type_error\n        else:\n            filters.append(mkCompoundFilter(subfilter))\n\n    if transformers:\n        filters.append(TransformFilterMaker(transformers))\n\n    if len(filters) == 1:\n        return filters[0]\n    else:\n        return CompoundFilter(filters)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cron(cronline, venusian_category='irc3.plugins.cron'):\n    def wrapper(func):\n        def callback(context, name, ob):\n            obj = context.context\n            crons = obj.get_plugin(Crons)\n            if info.scope == 'class':\n                callback = getattr(\n                    obj.get_plugin(ob),\n                    func.__name__)\n            else:\n                callback = irc3.utils.wraps_with_context(func, obj)\n            crons.add_cron(cronline, callback)\n        info = venusian.attach(func, callback, category=venusian_category)\n        return func\n    return wrapper", "response": "cronline is a string that can be used to add a cronline to the current object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetermining mimetype to response based on Accept header.", "response": "def _response_mimetype_based_on_accept_header(self):\n        \"\"\"Determines mimetype to response based on Accept header.\n\n        If mimetype is not found, it returns ``None``.\n\n        \"\"\"\n        response_mimetype = None\n\n        if not request.accept_mimetypes:\n            response_mimetype = self.default_mimetype\n        else:\n            all_media_types_wildcard = '*/*'\n\n            for mimetype, q in request.accept_mimetypes:\n                if mimetype == all_media_types_wildcard:\n                    response_mimetype = self.default_mimetype\n                    break\n                if mimetype in self.response_formatters:\n                    response_mimetype = mimetype\n                    break\n\n        return response_mimetype"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_response(self, rv):\n        status = headers = None\n        if isinstance(rv, tuple):\n            rv, status, headers = rv + (None,) * (3 - len(rv))\n\n        response_mimetype = self._response_mimetype_based_on_accept_header()\n        if response_mimetype is None:\n            # Return 406, list of available mimetypes in default format.\n            default_formatter = self.response_formatters.get(\n                self.default_mimetype\n            )\n            available_mimetypes = default_formatter(\n                mimetypes=list(self.response_formatters)\n            )\n\n            rv = self.response_class(\n                response=available_mimetypes,\n                status=406,\n                mimetype=self.default_mimetype,\n            )\n        elif isinstance(rv, dict):\n            formatter = self.response_formatters.get(response_mimetype)\n            rv = self.response_class(\n                response=formatter(**rv),\n                mimetype=response_mimetype,\n            )\n\n        return super(ResponsiveFlask, self).make_response(\n            rv=(rv, status, headers)\n        )", "response": "Returns a response based on Accept header."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nworks like event but occurs during DCC CHATs", "response": "def dcc_event(regexp, callback=None, iotype='in',\n              venusian_category='irc3.dcc'):\n    \"\"\"Work like :class:`~irc3.dec.event` but occurs during DCC CHATs\"\"\"\n    return event(regexp, callback=callback, iotype='dcc_' + iotype,\n                 venusian_category=venusian_category)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extend(func):\n    def callback(context, name, ob):\n        obj = context.context\n        if info.scope == 'class':\n            f = getattr(obj.get_plugin(ob), func.__name__)\n        else:\n            f = func\n        setattr(obj, f.__name__, f.__get__(obj, obj.__class__))\n    info = venusian.attach(func, callback, category='irc3.extend')\n    return func", "response": "Allow to extend a bot"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef notice(self, client, message):\n        if client and message:\n            messages = utils.split_message(message, self.config.max_length)\n            for msg in messages:\n                client.fwrite(':{c.srv} NOTICE {c.nick} :{msg}', msg=msg)", "response": "send a notice to client"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef client_key_loader(self, f):\n        @wraps(f)\n        def wrapped_f(client_id):\n            client_key = f(client_id)\n            return {\n                'id': client_id,\n                'key': client_key,\n                'algorithm': current_app.config['HAWK_ALGORITHM']\n            }\n\n        self._client_key_loader_func = wrapped_f\n        return wrapped_f", "response": "Registers a function to be called to find a client key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsign a response if it s possible.", "response": "def _sign_response(self, response):\n        \"\"\"Signs a response if it's possible.\"\"\"\n        if 'Authorization' not in request.headers:\n            return response\n\n        try:\n            mohawk_receiver = mohawk.Receiver(\n                credentials_map=self._client_key_loader_func,\n                request_header=request.headers['Authorization'],\n                url=request.url,\n                method=request.method,\n                content=request.get_data(),\n                content_type=request.mimetype,\n                accept_untrusted_content=current_app.config['HAWK_ACCEPT_UNTRUSTED_CONTENT'],\n                localtime_offset_in_seconds=current_app.config['HAWK_LOCALTIME_OFFSET_IN_SECONDS'],\n                timestamp_skew_in_seconds=current_app.config['HAWK_TIMESTAMP_SKEW_IN_SECONDS']\n            )\n        except mohawk.exc.HawkFail:\n            return response\n\n        response.headers['Server-Authorization'] = mohawk_receiver.respond(\n            content=response.data,\n            content_type=response.mimetype\n        )\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, name_or_class, mask, filepath=None, **kwargs):\n        if isinstance(name_or_class, type):\n            name = name_or_class.type\n            protocol = name_or_class\n        else:\n            name = name_or_class\n            protocol = self.protocols[name]\n        assert name in DCC_TYPES\n        if filepath:\n            kwargs.setdefault('limit_rate',\n                              self.config['send_limit_rate'])\n            kwargs['filepath'] = filepath\n            if protocol.type == DCCSend.type:\n                kwargs.setdefault('offset', 0)\n                kwargs.update(\n                    filename_safe=slugify(os.path.basename(filepath)),\n                    filesize=os.path.getsize(filepath),\n                )\n            elif protocol.type == DCCGet.type:\n                try:\n                    offset = os.path.getsize(filepath)\n                except OSError:\n                    offset = 0\n                kwargs.setdefault('offset', offset)\n                kwargs.setdefault('resume', False)\n        kwargs.setdefault('port', None)\n        f = protocol(\n            mask=mask, ip=int(self.bot.ip),\n            bot=self.bot, loop=self.loop, **kwargs)\n\n        if kwargs['port']:\n            if self.bot.config.get('dcc_sock_factory'):\n                sock_factory = maybedotted(self.bot.config.dcc_sock_factory)\n                args = dict(sock=sock_factory(self.bot, f.host, f.port))\n            else:\n                args = dict(host=f.host, port=f.port)\n            task = self.bot.create_task(\n                self.loop.create_connection(f.factory, **args))\n            task.add_done_callback(partial(self.created, f))\n        else:\n            task = self.bot.create_task(\n                self.loop.create_server(\n                    f.factory, '0.0.0.0', 0, backlog=1))\n            task.add_done_callback(partial(self.created, f))\n        return f", "response": "Create a new DCC connection."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresuming a DCC send", "response": "def resume(self, mask, filename, port, pos):\n        \"\"\"Resume a DCC send\"\"\"\n        self.connections['send']['masks'][mask][port].offset = pos\n        message = 'DCC ACCEPT %s %d %d' % (filename, port, pos)\n        self.bot.ctcp(mask, message)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_allowed(self, name_or_class, mask):  # pragma: no cover\n        if isinstance(name_or_class, type):\n            name = name_or_class.type\n        else:\n            name = name_or_class\n        info = self.connections[name]\n        limit = self.config[name + '_limit']\n        if limit and info['total'] >= limit:\n            msg = (\n                \"Sorry, there is too much DCC %s active. Please try again \"\n                \"later.\") % name.upper()\n            self.bot.notice(mask, msg)\n            return False\n        if mask not in info['masks']:\n            return True\n        limit = self.config[name + '_user_limit']\n        if limit and info['masks'][mask] >= limit:\n            msg = (\n                \"Sorry, you have too many DCC %s active. Close the other \"\n                \"connection(s) or wait a few seconds and try again.\"\n            ) % name.upper()\n            self.bot.notice(mask, msg)\n            return False\n        return True", "response": "Return True is a new connection is allowed"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns all keys with the same prefix without the prefix", "response": "def extract_config(config, prefix):\n    \"\"\"return all keys with the same prefix without the prefix\"\"\"\n    prefix = prefix.strip('.') + '.'\n    plen = len(prefix)\n    value = {}\n    for k, v in config.items():\n        if k.startswith(prefix):\n            value[k[plen:]] = v\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef as_list(value):\n    if isinstance(value, (list, tuple)):\n        return value\n    if not value:\n        return []\n    for c in '\\n ':\n        if c in value:\n            value = value.split(c)\n            return [v.strip() for v in value if v.strip()]\n    return [value]", "response": "clever string spliting:\n\n    .. code-block:: python\n\n        >>> print(as_list('value'))\n        ['value']\n        >>> print(as_list('v1 v2'))\n        ['v1', 'v2']\n        >>> print(as_list(None))\n        []\n        >>> print(as_list(['v1']))\n        ['v1']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the list of modes into a list of lists.", "response": "def parse_modes(modes, targets=None, noargs=''):\n    \"\"\"Parse channel modes:\n\n    .. code-block:: python\n\n        >>> parse_modes('+c-n', noargs='cn')\n        [('+', 'c', None), ('-', 'n', None)]\n        >>> parse_modes('+c-v', ['gawel'], noargs='c')\n        [('+', 'c', None), ('-', 'v', 'gawel')]\n    \"\"\"\n    if not targets:\n        targets = []\n    cleaned = []\n    for mode in modes:\n        if mode in '-+':\n            char = mode\n            continue\n        target = targets.pop(0) if mode not in noargs else None\n        cleaned.append((char, mode, target))\n    return cleaned"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a wrapped partial func with context context.", "response": "def wraps_with_context(func, context):\n    \"\"\"Return a wrapped partial(func, context)\"\"\"\n    wrapped = functools.partial(func, context)\n    wrapped = functools.wraps(func)(wrapped)\n    if asyncio.iscoroutinefunction(func):\n        wrapped = asyncio.coroutine(wrapped)\n    return wrapped"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nresolve dotted names: .. code-block:: python >>> maybedotted('irc3.config') <module 'irc3.config' from '...'> >>> maybedotted('irc3.utils.IrcString') <class 'irc3.utils.IrcString'> ..", "response": "def maybedotted(name):\n    \"\"\"Resolve dotted names:\n\n    .. code-block:: python\n\n        >>> maybedotted('irc3.config')\n        <module 'irc3.config' from '...'>\n        >>> maybedotted('irc3.utils.IrcString')\n        <class 'irc3.utils.IrcString'>\n\n    ..\n    \"\"\"\n    if not name:\n        raise LookupError(\n            'Not able to resolve %s' % name)\n    if not hasattr(name, '__name__'):\n        try:\n            mod = importlib.import_module(name)\n        except ImportError:\n            attr = None\n            if '.' in name:\n                names = name.split('.')\n                attr = names.pop(-1)\n                try:\n                    mod = maybedotted('.'.join(names))\n                except LookupError:\n                    attr = None\n                else:\n                    attr = getattr(mod, attr, None)\n            if attr is not None:\n                return attr\n            raise LookupError(\n                'Not able to resolve %s' % name)\n        else:\n            return mod\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nick(self):\n        if '!' in self:\n            return self.split('!', 1)[0]\n        if not self.is_channel and not self.is_server:\n            return self", "response": "return nick name:\n\n        .. code-block:: py\n\n            >>> print(IrcString('foo').nick)\n            foo\n            >>> print(IrcString('foo!user@host').nick)\n            foo\n            >>> IrcString('#foo').nick is None\n            True\n            >>> IrcString('irc.freenode.net').nick is None\n            True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dict converted from this string interpreted as a tag - string .. code - block :: py", "response": "def tagdict(self):\n        \"\"\"return a dict converted from this string interpreted as a tag-string\n\n        .. code-block:: py\n\n            >>> from pprint import pprint\n            >>> dict_ = IrcString('aaa=bbb;ccc;example.com/ddd=eee').tagdict\n            >>> pprint({str(k): str(v) for k, v in dict_.items()})\n            {'aaa': 'bbb', 'ccc': 'None', 'example.com/ddd': 'eee'}\n        \"\"\"\n        tagdict = getattr(self, '_tagdict', None)\n        if tagdict is None:\n            try:\n                self._tagdict = tags.decode(self)\n            except ValueError:\n                self._tagdict = {}\n        return self._tagdict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a handler using bot and log to targets", "response": "def set_irc_targets(self, bot, *targets):\n        \"\"\"Add a irc Handler using bot and log to targets (can be nicks or\n        channels:\n\n        ..\n            >>> bot = None\n\n        .. code-block:: python\n\n            >>> log = logging.getLogger('irc.mymodule')\n            >>> log.set_irc_targets(bot, '#chan', 'admin')\n        \"\"\"\n        # get formatter initialized by config (usualy on a NullHandler)\n        ll = logging.getLogger('irc')\n        formatter = ll.handlers[0].formatter\n        # add a handler for the sub logger\n        handler = Handler(bot, *targets)\n        handler.setFormatter(formatter)\n        self.addHandler(handler)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends a line to the server. replace CR by spaces", "response": "def send_line(self, data, nowait=False):\n        \"\"\"send a line to the server. replace CR by spaces\"\"\"\n        data = data.replace('\\n', ' ').replace('\\r', ' ')\n        f = asyncio.Future(loop=self.loop)\n        if self.queue is not None and nowait is False:\n            self.queue.put_nowait((f, data))\n        else:\n            self.send(data.replace('\\n', ' ').replace('\\r', ' '))\n            f.set_result(True)\n        return f"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a privmsg to target", "response": "def privmsg(self, target, message, nowait=False):\n        \"\"\"send a privmsg to target\"\"\"\n        if message:\n            messages = utils.split_message(message, self.config.max_length)\n            if isinstance(target, DCCChat):\n                for message in messages:\n                    target.send_line(message)\n            elif target:\n                f = None\n                for message in messages:\n                    f = self.send_line('PRIVMSG %s :%s' % (target, message),\n                                       nowait=nowait)\n                return f"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a ctcp to target", "response": "def ctcp(self, target, message, nowait=False):\n        \"\"\"send a ctcp to target\"\"\"\n        if target and message:\n            messages = utils.split_message(message, self.config.max_length)\n            f = None\n            for message in messages:\n                f = self.send_line('PRIVMSG %s :\\x01%s\\x01' % (target,\n                                                               message),\n                                   nowait=nowait)\n            return f"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mode(self, target, *data):\n        self.send_line('MODE %s %s' % (target, ' '.join(data)), nowait=True)", "response": "set user or channel mode"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef kick(self, channel, target, reason=None):\n        if reason:\n            target += ' :' + reason\n        self.send_line('KICK %s %s' % (channel, target), nowait=True)", "response": "kick target from channel"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange or request the topic of a channel", "response": "def topic(self, channel, topic=None):\n        \"\"\"change or request the topic of a channel\"\"\"\n        if topic:\n            channel += ' :' + topic\n        self.send_line('TOPIC %s' % channel)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmarks ourself as away", "response": "def away(self, message=None):\n        \"\"\"mark ourself as away\"\"\"\n        cmd = 'AWAY'\n        if message:\n            cmd += ' :' + message\n        self.send_line(cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn bot s ip as an ip_address object", "response": "def ip(self):\n        \"\"\"return bot's ip as an ``ip_address`` object\"\"\"\n        if not self._ip:\n            if 'ip' in self.config:\n                ip = self.config['ip']\n            else:\n                ip = self.protocol.transport.get_extra_info('sockname')[0]\n            ip = ip_address(ip)\n            if ip.version == 4:\n                self._ip = ip\n            else:  # pragma: no cover\n                response = urlopen('http://ipv4.icanhazip.com/')\n                ip = response.read().strip().decode()\n                ip = ip_address(ip)\n                self._ip = ip\n        return self._ip"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dcc(self):\n        if self._dcc is None:\n            self._dcc = DCCManager(self)\n        return self._dcc", "response": "return the : class : ~irc3. dcc. DCCManager object"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nopens a DCC CHAT whith mask.", "response": "def dcc_chat(self, mask, host=None, port=None):\n        \"\"\"Open a DCC CHAT whith mask. If host/port are specified then connect\n        to a server. Else create a server\"\"\"\n        return self.dcc.create(\n            'chat', mask, host=host, port=port).ready"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dcc_send(self, mask, filepath):\n        return self.dcc.create('send', mask, filepath=filepath).ready", "response": "Send a file to mask. filepath must be an absolute path to the existing file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dcc_accept(self, mask, filepath, port, pos):\n        return self.dcc.resume(mask, filepath, port, pos)", "response": "accept a DCC RESUME for an axisting DCC SEND"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nencodes a dictionary of tags to fit into an IRC - message.", "response": "def encode(tags):\n    '''Encodes a dictionary of tags to fit into an IRC-message.\n    See IRC Message Tags: http://ircv3.net/specs/core/message-tags-3.2.html\n\n    >>> from collections import OrderedDict\n    >>> encode({'key': 'value'})\n    'key=value'\n\n    >>> d = {'aaa': 'bbb', 'ccc': None, 'example.com/ddd': 'eee'}\n    >>> d_ordered = OrderedDict(sorted(d.items(), key=lambda t: t[0]))\n    >>> encode(d_ordered)\n    'aaa=bbb;ccc;example.com/ddd=eee'\n\n    >>> d = {'key': 'value;with special\\\\\\\\characters', 'key2': 'with=equals'}\n    >>> d_ordered = OrderedDict(sorted(d.items(), key=lambda t: t[0]))\n    >>> print(encode(d_ordered))\n    key=value\\\\:with\\\\sspecial\\\\\\characters;key2=with=equals\n\n    >>> print(encode({'key': r'\\\\something'}))\n    key=\\\\\\\\something\n\n    '''\n    tagstrings = []\n    for key, value in tags.items():\n        if not _valid_key.match(key):\n            raise ValueError(\"dictionary key is invalid as tag key: \" + key)\n        # if no value, just append the key\n        if value:\n            tagstrings.append(key + \"=\" + _escape(value))\n        else:\n            tagstrings.append(key)\n    return \";\".join(tagstrings)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decode(tagstring):\n    '''Decodes a tag-string from an IRC-message into a python dictionary.\n    See IRC Message Tags: http://ircv3.net/specs/core/message-tags-3.2.html\n\n    >>> from pprint import pprint\n    >>> pprint(decode('key=value'))\n    {'key': 'value'}\n\n    >>> pprint(decode('aaa=bbb;ccc;example.com/ddd=eee'))\n    {'aaa': 'bbb', 'ccc': None, 'example.com/ddd': 'eee'}\n\n    >>> s = r'key=value\\\\:with\\\\sspecial\\\\\\\\characters;key2=with=equals'\n    >>> pprint(decode(s))\n    {'key': 'value;with special\\\\\\\\characters', 'key2': 'with=equals'}\n    >>> print(decode(s)['key'])\n    value;with special\\\\characters\n\n    >>> print(decode(r'key=\\\\\\\\something')['key'])\n    \\\\something\n\n    '''\n    if not tagstring:\n        # None/empty = no tags\n        return {}\n\n    tags = {}\n\n    for tag in tagstring.split(\";\"):\n        # value is either everything after \"=\", or None\n        key, value = (tag.split(\"=\", 1) + [None])[:2]\n        if not _valid_key.match(key):\n            raise ValueError(\"invalid tag key: \" + key)\n        if value:\n            if not _valid_escaped_value.match(value):\n                raise ValueError(\"invalid escaped tag value: \" + value)\n            value = _unescape(value)\n        tags[key] = value\n\n    return tags", "response": "Decodes a tag - string from an IRC - message into a python dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the challenge auth hash for the user and password.", "response": "def challenge_auth(username, password, challenge, lower, digest='sha256'):\n    \"\"\"Calculates quakenet's challenge auth hash\n\n    .. code-block:: python\n\n        >>> challenge_auth(\"mooking\", \"0000000000\",\n        ...     \"12345678901234567890123456789012\", str.lower, \"md5\")\n        '2ed1a1f1d2cd5487d2e18f27213286b9'\n    \"\"\"\n    def hdig(x):\n        return fdigest(x).hexdigest()\n\n    fdigest = get_digest(digest)\n    luser = lower(username)\n    tpass = password[:10].encode(\"ascii\")\n    hvalue = hdig(\"{0}:{1}\".format(luser, hdig(tpass)).encode(\"ascii\"))\n    bhvalue = hvalue.encode(\"ascii\")\n    bchallenge = challenge.encode(\"ascii\")\n    return hmac.HMAC(bhvalue, bchallenge, digestmod=fdigest).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef filter_travis(self, entry):\n        fstate = entry.filename + '.state'\n        if os.path.isfile(fstate):\n            with open(fstate) as fd:\n                state = fd.read().strip()\n        else:\n            state = None\n        if 'failed' in entry.summary:\n            nstate = 'failed'\n        else:\n            nstate = 'success'\n        with open(fstate, 'w') as fd:\n            fd.write(nstate)\n        if state != nstate:\n            build = entry.title.split('#')[1]\n            entry['title'] = 'Build #{0} {1}'.format(build, nstate)\n            return True", "response": "Only show the latest entry iif this entry is in a new state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfilter out only usefull packages", "response": "def filter_pypi(self, entry):\n        \"\"\"Show only usefull packages\"\"\"\n        for package in self.packages:\n            if entry.title.lower().startswith(package):\n                return entry"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake results list of all events and put them in a dict", "response": "def process_results(self, results=None, **value):\n        \"\"\"take results list of all events and put them in a dict\"\"\"\n        channels = []\n        for res in results:\n            channels.extend(res.pop('channels', '').split())\n            value.update(res)\n        value['channels'] = channels\n        value['success'] = value.get('retcode') == '318'\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes results list of all events and return first dict", "response": "def process_results(self, results=None, **value):\n        \"\"\"take results list of all events and return first dict\"\"\"\n        for res in results:\n            if 'mask' in res:\n                res['mask'] = utils.IrcString(res['mask'])\n            value['success'] = res.pop('retcode', None) != '486'\n            value.update(res)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ping(bot, mask, target, args):\n    bot.send('NOTICE %(nick)s :PONG %(nick)s!' % dict(nick=mask.nick))", "response": "ping is a hack to send a NOTICE message to the bot."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a quote to the server %%quote <args >...", "response": "def quote(bot, mask, target, args):\n    \"\"\"send quote to the server\n\n        %%quote <args>...\n    \"\"\"\n    msg = ' '.join(args['<args>'])\n    bot.log.info('quote> %r', msg)\n    bot.send(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connected(self, **kwargs):\n        self.bot.log.info('Server config: %r', self.bot.server_config)\n\n        # recompile when I'm sure of my nickname\n        self.bot.config['nick'] = kwargs['me']\n        self.bot.recompile()\n\n        # Let all plugins know that server can handle commands\n        self.bot.notify('server_ready')\n\n        # detach useless events\n        self.bot.detach_events(*self.before_connect_events)", "response": "triger the server_ready event"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef recompile(self, nick=None, new_nick=None, **kw):\n        if self.bot.nick == nick.nick:\n            self.bot.config['nick'] = new_nick\n            self.bot.recompile()", "response": "recompile regexp on new nick"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef badnick(self, me=None, nick=None, **kw):\n        if me == '*':\n            self.bot.set_nick(self.bot.nick + '_')\n        self.bot.log.debug('Trying to regain nickname in 30s...')\n        self.nick_handle = self.bot.loop.call_later(\n            30, self.bot.set_nick, self.bot.original_nick)", "response": "Use alt nick on nick error"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a feed using feedparser", "response": "def parse(feedparser, args):\n    \"\"\"parse a feed using feedparser\"\"\"\n    entries = []\n    args = irc3.utils.Config(args)\n    max_date = datetime.datetime.now() - datetime.timedelta(days=2)\n\n    for filename in args['filenames']:\n        try:\n            with open(filename + '.updated') as fd:\n                updated = fd.read().strip()\n        except (OSError, IOError):\n            updated = '0'\n\n        feed = feedparser.parse(filename)\n        for e in feed.entries:\n            if e.updated <= updated:\n                # skip already sent entries\n                continue\n            try:\n                updated_parsed = e.updated_parsed\n            except AttributeError:\n                continue\n            if datetime.datetime(*updated_parsed[:7]) < max_date:\n                # skip entries older than 2 days\n                continue\n            e['filename'] = filename\n            e['feed'] = args\n            entries.append((e.updated, e))\n        if entries:\n            entries = sorted(entries, key=itemgetter(0))\n            with open(filename + '.updated', 'w') as fd:\n                fd.write(str(entries[-1][0]))\n    return entries"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nattach one or more events to the bot instance", "response": "def attach_events(self, *events, **kwargs):\n        \"\"\"Attach one or more events to the bot instance\"\"\"\n        reg = self.registry\n        insert = 'insert' in kwargs\n        for e in events:\n            cregexp = e.compile(self.config)\n            regexp = getattr(e.regexp, 're', e.regexp)\n            if regexp not in reg.events[e.iotype]:\n                if insert:\n                    reg.events_re[e.iotype].insert(0, (regexp, cregexp))\n                else:\n                    reg.events_re[e.iotype].append((regexp, cregexp))\n            if insert:\n                reg.events[e.iotype][regexp].insert(0, e)\n            else:\n                reg.events[e.iotype][regexp].append(e)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetaching one or more events from the bot instance", "response": "def detach_events(self, *events):\n        \"\"\"Detach one or more events from the bot instance\"\"\"\n        reg = self.registry\n        delete = defaultdict(list)\n\n        # remove from self.events\n        all_events = reg.events\n        for e in events:\n            regexp = getattr(e.regexp, 're', e.regexp)\n            iotype = e.iotype\n            if e in all_events[iotype].get(regexp, []):\n                all_events[iotype][regexp].remove(e)\n                if not all_events[iotype][regexp]:\n                    del all_events[iotype][regexp]\n                    # need to delete from self.events_re\n                    delete[iotype].append(regexp)\n\n        # delete from events_re\n        for iotype, regexps in delete.items():\n            reg.events_re[iotype] = [r for r in reg.events_re[iotype]\n                                     if r[0] not in regexps]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reload(self, *modules):\n        self.notify('before_reload')\n\n        if 'configfiles' in self.config:\n            # reload configfiles\n            self.log.info('Reloading configuration...')\n            cfg = utils.parse_config(\n                self.server and 'server' or 'bot', *self.config['configfiles'])\n            self.config.update(cfg)\n\n        self.log.info('Reloading python code...')\n        if not modules:\n            modules = self.registry.includes\n        scanned = list(reversed(self.registry.scanned))\n\n        # reset includes and events\n        self.registry.reset()\n\n        to_scan = []\n        for module_name, categories in scanned:\n            if module_name in modules:\n                module = utils.maybedotted(module_name)\n                reload_module(module)\n            to_scan.append((module_name, categories))\n\n        # rescan all modules\n        for module_name, categories in to_scan:\n            self.include(module_name, venusian_categories=categories)\n\n        self.registry.reloading = {}\n\n        self.notify('after_reload')", "response": "Reload one or more modules"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_signal_handlers(self):\n        try:\n            self.loop.add_signal_handler(signal.SIGHUP, self.SIGHUP)\n        except (RuntimeError, AttributeError):  # pragma: no cover\n            # windows\n            pass\n        try:\n            self.loop.add_signal_handler(signal.SIGINT, self.SIGINT)\n        except (RuntimeError, NotImplementedError):  # pragma: no cover\n            # annaconda\n            pass", "response": "Register handlers for UNIX signals ( SIGGHUP and SIGINT."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an instance configured with the cfg dict", "response": "def from_config(cls, cfg, **kwargs):\n        \"\"\"return an instance configured with the ``cfg`` dict\"\"\"\n        cfg = dict(cfg, **kwargs)\n        pythonpath = cfg.get('pythonpath', [])\n        if 'here' in cfg:\n            pythonpath.append(cfg['here'])\n        for path in pythonpath:\n            sys.path.append(os.path.expanduser(path))\n        prog = cls.server and 'irc3d' or 'irc3'\n        if cfg.get('debug'):\n            cls.venusian_categories.append(prog + '.debug')\n        if cfg.get('interactive'):  # pragma: no cover\n            import irc3.testing\n            context = getattr(irc3.testing, cls.__name__)(**cfg)\n        else:\n            context = cls(**cfg)\n        if cfg.get('raw'):\n            context.include('irc3.plugins.log',\n                            venusian_categories=[prog + '.debug'])\n        return context"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef async_run(self, keyword, *args, **kwargs):\n        ''' Executes the provided Robot Framework keyword in a separate thread and immediately returns a handle to be used with async_get '''\n        handle = self._last_thread_handle\n        thread = self._threaded(keyword, *args, **kwargs)\n        thread.start()\n        self._thread_pool[handle] = thread\n        self._last_thread_handle += 1\n        return handle", "response": "Executes the provided Robot Framework keyword in a separate thread and immediately returns a handle to be used with async_get"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nblocking until the thread created by async_run returns", "response": "def async_get(self, handle):\n        ''' Blocks until the thread created by async_run returns '''\n        assert handle in self._thread_pool, 'Invalid async call handle'\n        result = self._thread_pool[handle].result_queue.get()\n        del self._thread_pool[handle]\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the handler associated with the given keyword", "response": "def _get_handler_from_keyword(self, keyword):\n        ''' Gets the Robot Framework handler associated with the given keyword '''\n        if EXECUTION_CONTEXTS.current is None:\n            raise RobotNotRunningError('Cannot access execution context')\n        return EXECUTION_CONTEXTS.current.get_handler(keyword)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the _PMMail__custom_headers attribute.", "response": "def _set_custom_headers(self, value):\n        '''\n        A special set function to ensure\n        we're setting with a dictionary\n        '''\n        if value is None:\n            setattr(self, '_PMMail__custom_headers', {})\n        elif isinstance(value, dict):\n            setattr(self, '_PMMail__custom_headers', value)\n        else:\n            raise TypeError('Custom headers must be a dictionary of key-value pairs')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_metadata(self, value):\n        '''\n        A special set function to ensure\n        we're setting with a dictionary\n        '''\n        if value is None:\n            setattr(self, '_PMMail__metadata', {})\n        elif isinstance(value, dict):\n            for k, v in value.items():\n                if (not isinstance(k, str) and not isinstance(k, int)) \\\n                    or (not isinstance(v, str) and not isinstance(v, int)):\n                    raise TypeError('Metadata keys and values can only be strings or integers')\n            setattr(self, '_PMMail__metadata', value)\n        else:\n            raise TypeError('Metadata must be a dictionary of key-value pairs')", "response": "Set the metadata of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the _PMMail__attachments attribute.", "response": "def _set_attachments(self, value):\n        '''\n        A special set function to ensure\n        we're setting with a list\n        '''\n        if value is None:\n            setattr(self, '_PMMail__attachments', [])\n        elif isinstance(value, list):\n            setattr(self, '_PMMail__attachments', value)\n        else:\n            raise TypeError('Attachments must be a list')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking that all values are of the appropriate type and are not missing.", "response": "def _check_values(self):\n        '''\n        Make sure all values are of the appropriate\n        type and are not missing.\n        '''\n        if not self.__api_key:\n            raise PMMailMissingValueException('Cannot send an e-mail without a Postmark API Key')\n        elif not self.__sender:\n            raise PMMailMissingValueException('Cannot send an e-mail without a sender (.sender field)')\n        elif not self.__to:\n            raise PMMailMissingValueException('Cannot send an e-mail without at least one recipient (.to field)')\n        elif (self.__template_id or self.__template_model) and not all([self.__template_id, self.__template_model]):\n            raise PMMailMissingValueException(\n                'Cannot send a template e-mail without a both template_id and template_model set')\n        elif not any([self.__template_id, self.__template_model, self.__subject]):\n            raise PMMailMissingValueException('Cannot send an e-mail without a subject')\n        elif not self.__html_body and not self.__text_body and not self.__template_id:\n            raise PMMailMissingValueException('Cannot send an e-mail without either an HTML or text version of your e-mail body')\n        if self.__track_opens and not self.__html_body:\n            print('WARNING: .track_opens set to True with no .html_body set. Tracking opens will not work; message will still send.')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, test=None):\n        '''\n        Send the email through the Postmark system.\n        Pass test=True to just print out the resulting\n        JSON message being sent to Postmark\n        '''\n        self._check_values()\n\n        # Set up message dictionary\n        json_message = self.to_json_message()\n\n        # if (self.__html_body and not self.__text_body) and self.__multipart:\n        #     # TODO: Set up regex to strip html\n        #     pass\n\n        # If test is not specified, attempt to read the Django setting\n        if test is None:\n            try:\n                from django.conf import settings as django_settings\n                test = getattr(django_settings, \"POSTMARK_TEST_MODE\", None)\n            except ImportError:\n                pass\n\n        # If this is a test, just print the message\n        if test:\n            print('JSON message is:\\n%s' % json.dumps(json_message, cls=PMJSONEncoder))\n            return\n\n        if self.__template_id:\n            endpoint_url = __POSTMARK_URL__ + 'email/withTemplate/'\n        else:\n            endpoint_url = __POSTMARK_URL__ + 'email'\n\n        # Set up the url Request\n        req = Request(\n            endpoint_url,\n            json.dumps(json_message, cls=PMJSONEncoder).encode('utf8'),\n            {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json',\n                'X-Postmark-Server-Token': self.__api_key,\n                'User-agent': self.__user_agent\n            }\n        )\n\n        # Attempt send\n        try:\n            # print 'sending request to postmark: %s' % json_message\n            result = urlopen(req)\n            jsontxt = result.read().decode('utf8')\n            result.close()\n            if result.code == 200:\n                self.message_id = json.loads(jsontxt).get('MessageID', None)\n                return True\n            else:\n                raise PMMailSendException('Return code %d: %s' % (result.code, result.msg))\n        except HTTPError as err:\n            if err.code == 401:\n                raise PMMailUnauthorizedException('Sending Unauthorized - incorrect API key.', err)\n            elif err.code == 422:\n                try:\n                    jsontxt = err.read().decode('utf8')\n                    jsonobj = json.loads(jsontxt)\n                    desc = jsonobj['Message']\n                    error_code = jsonobj['ErrorCode']\n                except KeyError:\n                    raise PMMailUnprocessableEntityException('Unprocessable Entity: Description not given')\n\n                if error_code == 406:\n                    raise PMMailInactiveRecipientException('You tried to send email to a recipient that has been marked as inactive.')\n\n                raise PMMailUnprocessableEntityException('Unprocessable Entity: %s' % desc)\n            elif err.code == 500:\n                raise PMMailServerErrorException('Internal server error at Postmark. Admins have been alerted.', err)\n        except URLError as err:\n            if hasattr(err, 'reason'):\n                raise PMMailURLException('URLError: Failed to reach the server: %s (See \"inner_exception\" for details)' % err.reason, err)\n            elif hasattr(err, 'code'):\n                raise PMMailURLException('URLError: %d: The server couldn\\'t fufill the request. (See \"inner_exception\" for details)' % err.code, err)\n            else:\n                raise PMMailURLException('URLError: The server couldn\\'t fufill the request. (See \"inner_exception\" for details)', err)", "response": "Send the email through the Postmark system. Pass test = True to just print out the resulting\n            JSON message being sent to Postmark."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving a message from the batch.", "response": "def remove_message(self, message):\n        '''\n        Remove a message from the batch\n        '''\n        if message in self.__messages:\n            self.__messages.remove(message)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a summary of inactive emails and bounces by type.", "response": "def delivery_stats(self):\n        '''\n        Returns a summary of inactive emails and bounces by type.\n        '''\n        self._check_values()\n\n        req = Request(\n            __POSTMARK_URL__ + 'deliverystats',\n            None,\n            {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json',\n                'X-Postmark-Server-Token': self.__api_key,\n                'User-agent': self.__user_agent\n            }\n        )\n\n        # Attempt send\n        try:\n            # print 'sending request to postmark:'\n            result = urlopen(req)\n            with closing(result):\n                if result.code == 200:\n                    return json.loads(result.read())\n                else:\n                    raise PMMailSendException('Return code %d: %s' % (result.code, result.msg))\n\n        except HTTPError as err:\n            return err"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches a portion of bounces according to the input criteria.", "response": "def get_all(self, inactive='', email_filter='', tag='', count=25, offset=0):\n        '''\n        Fetches a portion of bounces according to the specified input criteria. The count and offset\n        parameters are mandatory. You should never retrieve all bounces as that could be excessively\n        slow for your application. To know how many bounces you have, you need to request a portion\n        first, usually the first page, and the service will return the count in the TotalCount property\n        of the response.\n        '''\n\n        self._check_values()\n\n        params = '?inactive=' + inactive + '&emailFilter=' + email_filter +'&tag=' + tag\n        params += '&count=' + str(count) + '&offset=' + str(offset)\n\n        req = Request(\n            __POSTMARK_URL__ + 'bounces' + params,\n            None,\n            {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json',\n                'X-Postmark-Server-Token': self.__api_key,\n                'User-agent': self.__user_agent\n            }\n        )\n\n        # Attempt send\n        try:\n            # print 'sending request to postmark:'\n            result = urlopen(req)\n            with closing(result):\n                if result.code == 200:\n                    return json.loads(result.read())\n                else:\n                    raise PMMailSendException('Return code %d: %s' % (result.code, result.msg))\n\n        except HTTPError as err:\n            return err"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nactivates a deactivated bounce.", "response": "def activate(self, bounce_id):\n        '''\n        Activates a deactivated bounce.\n        '''\n        self._check_values()\n        req_url = '/bounces/' + str(bounce_id) + '/activate'\n        # print req_url\n        h1 = HTTPConnection('api.postmarkapp.com')\n        dta = urlencode({\"data\": \"blank\"}).encode('utf8')\n        req = h1.request(\n            'PUT',\n            req_url,\n            dta,\n            {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json',\n                'X-Postmark-Server-Token': self.__api_key,\n                'User-agent': self.__user_agent\n            }\n        )\n        r = h1.getresponse()\n        return json.loads(r.read())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_messages(self, email_messages):\n        if not email_messages:\n            return\n        sent = self._send(email_messages)\n        if sent:\n            return len(email_messages)\n        return 0", "response": "Sends one or more EmailMessage objects and returns the number of messages sent."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _build_message(self, message):\n        if not message.recipients():\n            return False\n        recipients = ','.join(message.to)\n        recipients_cc = ','.join(message.cc)\n        recipients_bcc = ','.join(message.bcc)\n\n        text_body = message.body\n        html_body = None\n        if isinstance(message, EmailMultiAlternatives):\n            for alt in message.alternatives:\n                if alt[1] == \"text/html\":\n                    html_body = alt[0]\n                    break\n\n        elif getattr(message, 'content_subtype', None) == 'html':\n            # Don't send html content as plain text\n            text_body = None\n            html_body = message.body\n\n        reply_to = ','.join(message.reply_to)\n        custom_headers = {}\n        if message.extra_headers and isinstance(message.extra_headers, dict):\n            if 'Reply-To' in message.extra_headers:\n                reply_to = message.extra_headers.pop('Reply-To')\n            if len(message.extra_headers):\n                custom_headers = message.extra_headers\n        attachments = []\n        if message.attachments and isinstance(message.attachments, list):\n            if len(message.attachments):\n                for item in message.attachments:\n                    if isinstance(item, tuple):\n                        (f, content, m) = item\n                        content = base64.b64encode(content)\n                        # b64decode returns bytes on Python 3. PMMail needs a\n                        # str (for JSON serialization). Convert on Python 3\n                        # only to avoid a useless performance hit on Python 2.\n                        if not isinstance(content, str):\n                            content = content.decode()\n                        attachments.append((f, content, m))\n                    else:\n                        attachments.append(item)\n\n        postmark_message = PMMail(api_key=self.api_key,\n                                  subject=message.subject,\n                                  sender=message.from_email,\n                                  to=recipients,\n                                  cc=recipients_cc,\n                                  bcc=recipients_bcc,\n                                  text_body=text_body,\n                                  html_body=html_body,\n                                  reply_to=reply_to,\n                                  custom_headers=custom_headers,\n                                  attachments=attachments)\n\n        postmark_message.tag = getattr(message, 'tag', None)\n        postmark_message.track_opens = getattr(message, 'track_opens', False)\n\n        return postmark_message", "response": "Convert a PMEmailMessage to a PMMail object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_starttag(self, tag, attrs):\n    '''\n    PDF link handler; never gets explicitly called by user\n    '''\n    if tag == 'a' and ( ('class', 'download-pdf') in attrs or ('id', 'download-pdf') in attrs ):\n        for attr in attrs:\n          if attr[0] == 'href':\n            self.download_link = 'http://www.nature.com' + attr[1]", "response": "handle_starttag - Handle start tag of the PDF link"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a password with random chararcters", "response": "def genpass(pattern=r'[\\w]{32}'):\n    \"\"\"generates a password with random chararcters\n    \"\"\"\n    try:\n        return rstr.xeger(pattern)\n    except re.error as e:\n        raise ValueError(str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unpack(self, string):\n        if string is None:\n            string = CHAR_ZERO * self.__size__\n        data = struct.unpack(self.__fmt__, string)\n        i = 0\n        for field in self.__fields__:\n            (vtype, vlen) = self.__fields_types__[field]\n            if vtype == 'char': # string\n                setattr(self, field, data[i])\n                i = i + 1\n            elif isinstance(vtype, CStructMeta):\n                num = int(vlen / vtype.size)\n                if num == 1: # single struct\n                    sub_struct = vtype()\n                    sub_struct.unpack(EMPTY_BYTES_STRING.join(data[i:i+sub_struct.size]))\n                    setattr(self, field, sub_struct)\n                    i = i + sub_struct.size\n                else: # multiple struct\n                    sub_structs = []\n                    for j in range(0, num):\n                        sub_struct = vtype()\n                        sub_struct.unpack(EMPTY_BYTES_STRING.join(data[i:i+sub_struct.size]))\n                        i = i + sub_struct.size\n                        sub_structs.append(sub_struct)\n                    setattr(self, field, sub_structs)\n            elif vlen == 1:\n                setattr(self, field, data[i])\n                i = i + vlen\n            else:\n                setattr(self, field, list(data[i:i+vlen]))\n                i = i + vlen", "response": "Unpack the string containing packed C structure data into the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npacking the structure data into a string", "response": "def pack(self):\n        \"\"\"\n        Pack the structure data into a string\n        \"\"\"\n        data = []\n        for field in self.__fields__:\n            (vtype, vlen) = self.__fields_types__[field]\n            if vtype == 'char': # string\n                data.append(getattr(self, field))\n            elif isinstance(vtype, CStructMeta):\n                num = int(vlen / vtype.size)\n                if num == 1: # single struct\n                    v = getattr(self, field, vtype())\n                    v = v.pack()\n                    if sys.version_info >= (3, 0):\n                        v = ([bytes([x]) for x in v])\n                    data.extend(v)\n                else: # multiple struct\n                    values = getattr(self, field, [])\n                    for j in range(0, num):\n                        try:\n                            v = values[j]\n                        except:\n                            v = vtype()\n                        v = v.pack()\n                        if sys.version_info >= (3, 0):\n                            v = ([bytes([x]) for x in v])\n                        data.extend(v)\n            elif vlen == 1:\n                data.append(getattr(self, field))\n            else:\n                v = getattr(self, field)\n                v = v[:vlen] + [0] * (vlen - len(v))\n                data.extend(v)\n        return struct.pack(self.__fmt__, *data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint info about the current object.", "response": "def print_info(self):\n        \"andreax  + pts/0        2013-08-21 08:58   .         32341 (l26.box)\"\n        \"           pts/34       2013-06-12 15:04             26396 id=s/34  term=0 exit=0\"\n#        if self.ut_type not in [6,7]:\n#            return\n        print(\"%-10s %-12s %15s %15s %-8s\" % (\n                    str_from_c(self.ut_user),\n                    str_from_c(self.ut_line),\n                    time.strftime(\"%Y-%m-%d %H:%M\", time.gmtime(self.ut_tv.tv_sec)),\n                    self.ut_pid,\n                    str_from_c(self.ut_host) and \"(%s)\" % str_from_c(self.ut_host) or str_from_c(self.ut_id) and \"id=%s\" % str_from_c(self.ut_id) or \"\"))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all subclasses of BaseImporter from module and return and generator", "response": "def get_all():\n    \"\"\"Get all subclasses of BaseImporter from module and return and generator\n    \"\"\"\n\n    _import_all_importer_files()\n\n    for module in (value for key, value in globals().items()\n                   if key in __all__):\n        for klass_name, klass in inspect.getmembers(module, inspect.isclass):\n            if klass is not BaseImporter and issubclass(klass, BaseImporter):\n                yield klass\n\n    for klass in _get_importers_from_entry_points():\n        yield klass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_database(db):\n    credentials = db.credentials()\n    if credentials:\n        table = Table(\n            db.config['headers'],\n            table_format=db.config['table_format'],\n            colors=db.config['colors'],\n            hidden=db.config['hidden'],\n            hidden_string=db.config['hidden_string'],\n        )\n        click.echo(table.render(credentials))", "response": "Print credential as a table"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nshows current configuration for shell", "response": "def check_config(db, level):\n    \"\"\"Show current configuration for shell\"\"\"\n    if level == 'global':\n        configuration = config.read(config.HOMEDIR, '.passpierc')\n    elif level == 'local':\n        configuration = config.read(os.path.join(db.path))\n    elif level == 'current':\n        configuration = db.config\n\n    if configuration:\n        click.echo(yaml.safe_dump(configuration, default_flow_style=False))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process(self, data=None, **kwargs):\n        self.data = self.handle(data, **kwargs)\n        return self", "response": "Process the provided data and invoke the handler method for this\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch incoming data from the Flask request object when no data is supplied is assumed to be JSON.", "response": "def process(self, data=None):\n        \"\"\"Fetch incoming data from the Flask request object when no data is supplied\n        to the process method.  By default, the RequestHandler expects the\n        incoming data to be sent as JSON.\n        \"\"\"\n\n        return super(RequestHandler, self).process(data=data or self.get_request_data())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self, obj):\n        session = self.get_db_session()\n        session.add(obj)\n        session.commit()\n\n        return obj", "response": "Save the object to the SQLAlchemy database and commit the changes back to\n        the database."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter_by_id(self, query):\n        if self.model is None:\n            raise ArrestedException('DBObjectMixin requires a model to be set.')\n\n        idfield = getattr(self.model, self.model_id_param, None)\n        if not idfield:\n            raise ArrestedException('DBObjectMixin could not find a valid Model.id.')\n\n        return query.filter(idfield == self.kwargs[self.url_id_param])", "response": "Apply the primary key filter to query to filter the results for a specific\n        instance by id."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nimplement the GetObjectMixin interface and calls the DBALchemy Query method to get the object.", "response": "def get_object(self):\n        \"\"\"Implements the GetObjectMixin interface and calls\n        :meth:`DBObjectMixin.get_query`.  Using this mixin requires usage of\n        a response handler capable of serializing SQLAlchemy query result objects.\n\n        :returns: Typically a SQLALchemy Query result.\n        :rtype: mixed\n\n        .. seealso::\n            :meth:`DBObjectMixin.get_query`\n            :meth:`DBObjectMixin.filter_by_id`\n            :meth:`DBObjectMixin.get_result`\n        \"\"\"\n\n        query = self.get_query()\n        query = self.filter_by_id(query)\n        return self.get_result(query)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_object(self, obj):\n        session = self.get_db_session()\n        session.delete(obj)\n        session.commit()", "response": "Deletes an object from the session by calling session. delete and then commits\n        the changes to the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef init_app(self, app):\n\n        self.app = app\n        if self.deferred:\n            self.register_all(self.deferred)", "response": "Initialise the ArrestedAPI object by storing a pointer to a Flask app object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_resource(self, resource, defer=False):\n        if defer:\n            self.deferred.append(resource)\n        else:\n            resource.init_api(self)\n            self.app.register_blueprint(resource, url_prefix=self.url_prefix)", "response": "Register a resource against the Arrested API."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess the list of before_{method}_hooks and the before_all_hooks.", "response": "def process_before_request_hooks(self):\n        \"\"\"Process the list of before_{method}_hooks and the before_all_hooks. The hooks\n        will be processed in the following order\n\n        1 - any before_all_hooks defined on the :class:`arrested.ArrestedAPI` object\n        2 - any before_all_hooks defined on the :class:`arrested.Resource` object\n        3 - any before_all_hooks defined on the :class:`arrested.Endpoint` object\n        4 - any before_{method}_hooks defined on the :class:`arrested.Endpoint` object\n        \"\"\"\n\n        hooks = []\n\n        if self.resource:\n            hooks.extend(self.resource.api.before_all_hooks)\n            hooks.extend(self.resource.before_all_hooks)\n\n        hooks.extend(self.before_all_hooks)\n        hooks.extend(\n            getattr(\n                self,\n                'before_{method}_hooks'.format(method=self.meth),\n                []\n            )\n        )\n\n        for hook in chain(hooks):\n            hook(self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses the list of before_{method}_hooks and the after_all_hooks.", "response": "def process_after_request_hooks(self, resp):\n        \"\"\"Process the list of before_{method}_hooks and the before_all_hooks. The hooks\n        will be processed in the following order\n\n        1 - any after_{method}_hooks defined on the :class:`arrested.Endpoint` object\n        2 - any after_all_hooks defined on the :class:`arrested.Endpoint` object\n        2 - any after_all_hooks defined on the :class:`arrested.Resource` object\n        4 - any after_all_hooks defined on the :class:`arrested.ArrestedAPI` object\n        \"\"\"\n\n        hooks = []\n        meth_hooks = getattr(\n            self,\n            'after_{method}_hooks'.format(method=self.meth),\n            []\n        )\n\n        hooks.extend(meth_hooks)\n        hooks.extend(self.after_all_hooks)\n\n        if self.resource:\n            hooks.extend(self.resource.after_all_hooks)\n            hooks.extend(self.resource.api.after_all_hooks)\n\n        for hook in chain(hooks):\n            resp = hook(self, resp)\n\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndispatches the incoming HTTP request to the appropriate handler.", "response": "def dispatch_request(self, *args, **kwargs):\n        \"\"\"Dispatch the incoming HTTP request to the appropriate handler.\n        \"\"\"\n        self.args = args\n        self.kwargs = kwargs\n        self.meth = request.method.lower()\n        self.resource = current_app.blueprints.get(request.blueprint, None)\n\n        if not any([self.meth in self.methods, self.meth.upper() in self.methods]):\n            return self.return_error(405)\n\n        self.process_before_request_hooks()\n\n        resp = super(Endpoint, self).dispatch_request(*args, **kwargs)\n        resp = self.make_response(resp)\n\n        resp = self.process_after_request_hooks(resp)\n\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a response object from the given response value.", "response": "def make_response(self, rv, status=200, headers=None, mime='application/json'):\n        \"\"\"Create a response object using the :class:`flask.Response` class.\n\n        :param rv: Response value.  If the value is not an instance\n            of :class:`werkzeug.wrappers.Response` it will be converted\n            into a Response object.\n        :param status: specify the HTTP status code for this response.\n        :param mime: Specify the mimetype for this request.\n        :param headers: Specify dict of headers for the response.\n\n        \"\"\"\n        if not isinstance(rv, Response):\n            resp = Response(\n                response=rv,\n                headers=headers,\n                mimetype=mime,\n                status=status\n            )\n        else:\n            resp = rv\n\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_response_handler(self):\n        assert self.response_handler is not None, \\\n            'Please define a response_handler ' \\\n            ' for Endpoint: %s' % self.__class__.__name__\n\n        return self.response_handler(self, **self.get_response_handler_params())", "response": "Returns the Endpoints defined : attr : Endpoint. response_handler."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_request_handler(self):\n        assert self.request_handler is not None, \\\n            'Please define a request_handler ' \\\n            ' for Endpoint: %s' % self.__class__.__name__\n\n        return self.request_handler(self, **self.get_request_handler_params())", "response": "Returns the Endpoint s request_handler function."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle(self, data, **kwargs):\n        if self.many:\n            return self.mapper.many(raw=self.raw, **self.mapper_kwargs).serialize(\n                data, role=self.role\n            )\n        else:\n            return self.mapper(obj=data, raw=self.raw, **self.mapper_kwargs).serialize(\n                role=self.role\n            )", "response": "Run serialization for the specified mapper_class."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle_error(self, exp):\n        payload = {\n            \"message\": \"Invalid or incomplete data provided.\",\n            \"errors\": exp.errors\n        }\n        self.endpoint.return_error(self.error_status, payload=payload)", "response": "Called if a Mapper returns an error. Should handle the error and return it in the appropriate format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun marshalling for the specified mapper_class.", "response": "def handle(self, data, **kwargs):\n        \"\"\"Run marshalling for the specified mapper_class.\n\n        Supports both .marshal and .many().marshal Kim interfaces.  Handles errors raised\n        during marshalling and automatically returns a HTTP error response.\n\n        :param data: Data to be marshaled.\n        :returns: Marshaled object according to mapper configuration\n        :raises: :class:`werkzeug.exceptions.UnprocessableEntity`\n        \"\"\"\n        try:\n            if self.many:\n                return self.mapper.many(raw=self.raw, **self.mapper_kwargs).marshal(\n                    data, role=self.role\n                )\n            else:\n                return self.mapper(\n                    data=data,\n                    obj=self.obj,\n                    partial=self.partial,\n                    **self.mapper_kwargs\n                ).marshal(role=self.role)\n        except MappingInvalid as e:\n            self.handle_error(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary that will be used to configure the KimResponseHandler", "response": "def get_response_handler_params(self, **params):\n        \"\"\"Return a config object that will be used to configure the KimResponseHandler\n\n        :returns: a dictionary of config options\n        :rtype: dict\n        \"\"\"\n\n        params = super(KimEndpoint, self).get_response_handler_params(**params)\n        params['mapper_class'] = self.mapper_class\n        params['role'] = self.serialize_role\n\n        # After a successfull attempt to marshal an object has been made, a response\n        # is generated using the RepsonseHandler.  Rather than taking the class level\n        # setting for many by default, pull it from the request handler params config to\n        # ensure Marshaling and Serializing are run the same way.\n        if self._is_marshal_request():\n            req_params = self.get_request_handler_params()\n            params['many'] = req_params.get('many', self.many)\n        else:\n            params['many'] = self.many\n\n        return params"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_request_handler_params(self, **params):\n\n        params = super(KimEndpoint, self).get_request_handler_params(**params)\n        params['mapper_class'] = self.mapper_class\n        params['role'] = self.marshal_role\n        params['many'] = False\n        # when handling a PUT or PATCH request, self.obj will be set.. There might be a\n        # more robust way to handle this?\n        params['obj'] = getattr(self, 'obj', None)\n        params['partial'] = self.is_partial()\n\n        return params", "response": "Return a dictionary of config object that will be used to configure the KimRequestHandler\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npulls the processed data from the response_handler and return a response.", "response": "def list_response(self, status=200):\n        \"\"\"Pull the processed data from the response_handler and return a response.\n\n        :param status: The HTTP status code returned with the response\n\n        .. seealso:\n            :meth:`Endpoint.make_response`\n            :meth:`Endpoint.handle_get_request`\n        \"\"\"\n\n        return self._response(self.response.get_response_data(), status=status)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling incoming GET requests to an Endpoint and return an array of results by calling self. list_response.", "response": "def handle_get_request(self):\n        \"\"\"Handle incoming GET request to an Endpoint and return an\n        array of results by calling :meth:`.GetListMixin.get_objects`.\n\n        .. seealso::\n            :meth:`GetListMixin.get_objects`\n            :meth:`Endpoint.get`\n        \"\"\"\n        self.objects = self.get_objects()\n        self.response = self.get_response_handler()\n\n        self.response.process(self.objects)\n\n        return self.list_response()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_response(self, status=201):\n        self.response = self.get_response_handler()\n        self.response.process(self.obj)\n\n        return self._response(self.response.get_response_data(), status=status)", "response": "Generate a Response object for a POST request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle incoming POST request to an Endpoint and marshal the request data", "response": "def handle_post_request(self):\n        \"\"\"Handle incoming POST request to an Endpoint and marshal the request data\n        via the specified RequestHandler.  :meth:`.CreateMixin.save_object`. is then\n        called and must be implemented by mixins implementing this interfce.\n\n        .. seealso::\n            :meth:`CreateMixin.save_object`\n            :meth:`Endpoint.post`\n        \"\"\"\n        self.request = self.get_request_handler()\n        self.obj = self.request.process().data\n\n        self.save_object(self.obj)\n        return self.create_response()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef obj(self):\n        if not getattr(self, '_obj', None):\n            self._obj = self.get_object()\n            if self._obj is None and not self.allow_none:\n                self.return_error(404)\n\n        return self._obj", "response": "Returns the value of ObjectMixin. get_object and sets a private\n        property called _obj."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncrawling several FSMs in parallel, mapping the states of a larger meta-FSM. To determine whether a state in the larger FSM is final, pass all of the finality statuses (e.g. [True, False, False] to `test`.", "response": "def parallel(fsms, test):\n\t'''\n\t\tCrawl several FSMs in parallel, mapping the states of a larger meta-FSM.\n\t\tTo determine whether a state in the larger FSM is final, pass all of the\n\t\tfinality statuses (e.g. [True, False, False] to `test`.\n\t'''\n\talphabet = set().union(*[fsm.alphabet for fsm in fsms])\n\n\tinitial = dict([(i, fsm.initial) for (i, fsm) in enumerate(fsms)])\n\n\t# dedicated function accepts a \"superset\" and returns the next \"superset\"\n\t# obtained by following this transition in the new FSM\n\tdef follow(current, symbol):\n\t\tnext = {}\n\t\tfor i in range(len(fsms)):\n\t\t\tif symbol not in fsms[i].alphabet and anything_else in fsms[i].alphabet:\n\t\t\t\tactual_symbol = anything_else\n\t\t\telse:\n\t\t\t\tactual_symbol = symbol\n\t\t\tif i in current \\\n\t\t\tand current[i] in fsms[i].map \\\n\t\t\tand actual_symbol in fsms[i].map[current[i]]:\n\t\t\t\tnext[i] = fsms[i].map[current[i]][actual_symbol]\n\t\tif len(next.keys()) == 0:\n\t\t\traise OblivionError\n\t\treturn next\n\n\t# Determine the \"is final?\" condition of each substate, then pass it to the\n\t# test to determine finality of the overall FSM.\n\tdef final(state):\n\t\taccepts = [i in state and state[i] in fsm.finals for (i, fsm) in enumerate(fsms)]\n\t\treturn test(accepts)\n\n\treturn crawl(alphabet, initial, final, follow).reduce()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef crawl(alphabet, initial, final, follow):\n\t'''\n\t\tGiven the above conditions and instructions, crawl a new unknown FSM,\n\t\tmapping its states, final states and transitions. Return the new FSM.\n\t\tThis is a pretty powerful procedure which could potentially go on\n\t\tforever if you supply an evil version of follow().\n\t'''\n\n\tstates = [initial]\n\tfinals = set()\n\tmap = {}\n\n\t# iterate over a growing list\n\ti = 0\n\twhile i < len(states):\n\t\tstate = states[i]\n\n\t\t# add to finals\n\t\tif final(state):\n\t\t\tfinals.add(i)\n\n\t\t# compute map for this state\n\t\tmap[i] = {}\n\t\tfor symbol in sorted(alphabet, key=key):\n\t\t\ttry:\n\t\t\t\tnext = follow(state, symbol)\n\n\t\t\t\ttry:\n\t\t\t\t\tj = states.index(next)\n\t\t\t\texcept ValueError:\n\t\t\t\t\tj = len(states)\n\t\t\t\t\tstates.append(next)\n\n\t\t\texcept OblivionError:\n\t\t\t\t# Reached an oblivion state. Don't list it.\n\t\t\t\tcontinue\n\n\t\t\tmap[i][symbol] = j\n\n\t\ti += 1\n\n\treturn fsm(\n\t\talphabet = alphabet,\n\t\tstates   = range(len(states)),\n\t\tinitial  = 0,\n\t\tfinals   = finals,\n\t\tmap      = map,\n\t)", "response": "This function is a pretty powerful procedure which can be used to crawl unknown FSM states and transitions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef accepts(self, input):\n\t\t'''\n\t\t\tTest whether the present FSM accepts the supplied string (iterable of\n\t\t\tsymbols). Equivalently, consider `self` as a possibly-infinite set of\n\t\t\tstrings and test whether `string` is a member of it.\n\t\t\tThis is actually mainly used for unit testing purposes.\n\t\t\tIf `fsm.anything_else` is in your alphabet, then any symbol not in your\n\t\t\talphabet will be converted to `fsm.anything_else`.\n\t\t'''\n\t\tstate = self.initial\n\t\tfor symbol in input:\n\t\t\tif anything_else in self.alphabet and not symbol in self.alphabet:\n\t\t\t\tsymbol = anything_else\n\n\t\t\t# Missing transition = transition to dead state\n\t\t\tif not (state in self.map and symbol in self.map[state]):\n\t\t\t\treturn False\n\n\t\t\tstate = self.map[state][symbol]\n\t\treturn state in self.finals", "response": "Tests whether the present FSM accepts the supplied string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef concatenate(*fsms):\n\t\t'''\n\t\t\tConcatenate arbitrarily many finite state machines together.\n\t\t'''\n\t\talphabet = set().union(*[fsm.alphabet for fsm in fsms])\n\n\t\tdef connect_all(i, substate):\n\t\t\t'''\n\t\t\t\tTake a state in the numbered FSM and return a set containing it, plus\n\t\t\t\t(if it's final) the first state from the next FSM, plus (if that's\n\t\t\t\tfinal) the first state from the next but one FSM, plus...\n\t\t\t'''\n\t\t\tresult = {(i, substate)}\n\t\t\twhile i < len(fsms) - 1 and substate in fsms[i].finals:\n\t\t\t\ti += 1\n\t\t\t\tsubstate = fsms[i].initial\n\t\t\t\tresult.add((i, substate))\n\t\t\treturn result\n\n\t\t# Use a superset containing states from all FSMs at once.\n\t\t# We start at the start of the first FSM. If this state is final in the\n\t\t# first FSM, then we are also at the start of the second FSM. And so on.\n\t\tinitial = set()\n\t\tif len(fsms) > 0:\n\t\t\tinitial.update(connect_all(0, fsms[0].initial))\n\t\tinitial = frozenset(initial)\n\n\t\tdef final(state):\n\t\t\t'''If you're in a final state of the final FSM, it's final'''\n\t\t\tfor (i, substate) in state:\n\t\t\t\tif i == len(fsms) - 1 and substate in fsms[i].finals:\n\t\t\t\t\treturn True\n\t\t\treturn False\n\n\t\tdef follow(current, symbol):\n\t\t\t'''\n\t\t\t\tFollow the collection of states through all FSMs at once, jumping to the\n\t\t\t\tnext FSM if we reach the end of the current one\n\t\t\t\tTODO: improve all follow() implementations to allow for dead metastates?\n\t\t\t'''\n\t\t\tnext = set()\n\t\t\tfor (i, substate) in current:\n\t\t\t\tfsm = fsms[i]\n\t\t\t\tif substate in fsm.map and symbol in fsm.map[substate]:\n\t\t\t\t\tnext.update(connect_all(i, fsm.map[substate][symbol]))\n\t\t\tif len(next) == 0:\n\t\t\t\traise OblivionError\n\t\t\treturn frozenset(next)\n\n\t\treturn crawl(alphabet, initial, final, follow).reduce()", "response": "Concatenate arbitrarily many finite state machines together."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an FSM that accepts X returns an FSM accepting X *", "response": "def star(self):\n\t\t'''\n\t\t\tIf the present FSM accepts X, returns an FSM accepting X* (i.e. 0 or\n\t\t\tmore Xes). This is NOT as simple as naively connecting the final states\n\t\t\tback to the initial state: see (b*ab)* for example.\n\t\t'''\n\t\talphabet = self.alphabet\n\n\t\tinitial = {self.initial}\n\n\t\tdef follow(state, symbol):\n\t\t\tnext = set()\n\t\t\tfor substate in state:\n\t\t\t\tif substate in self.map and symbol in self.map[substate]:\n\t\t\t\t\tnext.add(self.map[substate][symbol])\n\n\t\t\t\t# If one of our substates is final, then we can also consider\n\t\t\t\t# transitions from the initial state of the original FSM.\n\t\t\t\tif substate in self.finals \\\n\t\t\t\tand self.initial in self.map \\\n\t\t\t\tand symbol in self.map[self.initial]:\n\t\t\t\t\tnext.add(self.map[self.initial][symbol])\n\n\t\t\tif len(next) == 0:\n\t\t\t\traise OblivionError\n\n\t\t\treturn frozenset(next)\n\n\t\tdef final(state):\n\t\t\treturn any(substate in self.finals for substate in state)\n\n\t\treturn crawl(alphabet, initial, final, follow) | epsilon(alphabet)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives an FSM and a multiplier, return the multiplied FSM.", "response": "def times(self, multiplier):\n\t\t'''\n\t\t\tGiven an FSM and a multiplier, return the multiplied FSM.\n\t\t'''\n\t\tif multiplier < 0:\n\t\t\traise Exception(\"Can't multiply an FSM by \" + repr(multiplier))\n\n\t\talphabet = self.alphabet\n\n\t\t# metastate is a set of iterations+states\n\t\tinitial = {(self.initial, 0)}\n\n\t\tdef final(state):\n\t\t\t'''If the initial state is final then multiplying doesn't alter that'''\n\t\t\tfor (substate, iteration) in state:\n\t\t\t\tif substate == self.initial \\\n\t\t\t\tand (self.initial in self.finals or iteration == multiplier):\n\t\t\t\t\treturn True\n\t\t\treturn False\n\n\t\tdef follow(current, symbol):\n\t\t\tnext = []\n\t\t\tfor (substate, iteration) in current:\n\t\t\t\tif iteration < multiplier \\\n\t\t\t\tand substate in self.map \\\n\t\t\t\tand symbol in self.map[substate]:\n\t\t\t\t\tnext.append((self.map[substate][symbol], iteration))\n\t\t\t\t\t# final of self? merge with initial on next iteration\n\t\t\t\t\tif self.map[substate][symbol] in self.finals:\n\t\t\t\t\t\tnext.append((self.initial, iteration + 1))\n\t\t\tif len(next) == 0:\n\t\t\t\traise OblivionError\n\t\t\treturn frozenset(next)\n\n\t\treturn crawl(alphabet, initial, final, follow).reduce()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a finite state machine which will accept any string NOT accepted by self and will not accept any string NOT accepted by self.", "response": "def everythingbut(self):\n\t\t'''\n\t\t\tReturn a finite state machine which will accept any string NOT\n\t\t\taccepted by self, and will not accept any string accepted by self.\n\t\t\tThis is more complicated if there are missing transitions, because the\n\t\t\tmissing \"dead\" state must now be reified.\n\t\t'''\n\t\talphabet = self.alphabet\n\n\t\tinitial = {0 : self.initial}\n\n\t\tdef follow(current, symbol):\n\t\t\tnext = {}\n\t\t\tif 0 in current and current[0] in self.map and symbol in self.map[current[0]]:\n\t\t\t\tnext[0] = self.map[current[0]][symbol]\n\t\t\treturn next\n\n\t\t# state is final unless the original was\n\t\tdef final(state):\n\t\t\treturn not (0 in state and state[0] in self.finals)\n\n\t\treturn crawl(alphabet, initial, final, follow).reduce()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reversed(self):\n\t\t'''\n\t\t\tReturn a new FSM such that for every string that self accepts (e.g.\n\t\t\t\"beer\", the new FSM accepts the reversed string (\"reeb\").\n\t\t'''\n\t\talphabet = self.alphabet\n\n\t\t# Start from a composite \"state-set\" consisting of all final states.\n\t\t# If there are no final states, this set is empty and we'll find that\n\t\t# no other states get generated.\n\t\tinitial = frozenset(self.finals)\n\n\t\t# Find every possible way to reach the current state-set\n\t\t# using this symbol.\n\t\tdef follow(current, symbol):\n\t\t\tnext = frozenset([\n\t\t\t\tprev\n\t\t\t\tfor prev in self.map\n\t\t\t\tfor state in current\n\t\t\t\tif symbol in self.map[prev] and self.map[prev][symbol] == state\n\t\t\t])\n\t\t\tif len(next) == 0:\n\t\t\t\traise OblivionError\n\t\t\treturn next\n\n\t\t# A state-set is final if the initial state is in it.\n\t\tdef final(state):\n\t\t\treturn self.initial in state\n\n\t\t# Man, crawl() is the best!\n\t\treturn crawl(alphabet, initial, final, follow)", "response": "Returns a new FSM that accepts the reversed string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef strings(self):\n\t\t'''\n\t\t\tGenerate strings (lists of symbols) that this FSM accepts. Since there may\n\t\t\tbe infinitely many of these we use a generator instead of constructing a\n\t\t\tstatic list. Strings will be sorted in order of length and then lexically.\n\t\t\tThis procedure uses arbitrary amounts of memory but is very fast. There\n\t\t\tmay be more efficient ways to do this, that I haven't investigated yet.\n\t\t\tYou can use this in list comprehensions.\n\t\t'''\n\n\t\t# Many FSMs have \"dead states\". Once you reach a dead state, you can no\n\t\t# longer reach a final state. Since many strings may end up here, it's\n\t\t# advantageous to constrain our search to live states only.\n\t\tlivestates = set(state for state in self.states if self.islive(state))\n\n\t\t# We store a list of tuples. Each tuple consists of an input string and the\n\t\t# state that this input string leads to. This means we don't have to run the\n\t\t# state machine from the very beginning every time we want to check a new\n\t\t# string.\n\t\tstrings = []\n\n\t\t# Initial entry (or possibly not, in which case this is a short one)\n\t\tcstate = self.initial\n\t\tcstring = []\n\t\tif cstate in livestates:\n\t\t\tif cstate in self.finals:\n\t\t\t\tyield cstring\n\t\t\tstrings.append((cstring, cstate))\n\n\t\t# Fixed point calculation\n\t\ti = 0\n\t\twhile i < len(strings):\n\t\t\t(cstring, cstate) = strings[i]\n\t\t\tif cstate in self.map:\n\t\t\t\tfor symbol in sorted(self.map[cstate], key=key):\n\t\t\t\t\tnstate = self.map[cstate][symbol]\n\t\t\t\t\tnstring = cstring + [symbol]\n\t\t\t\t\tif nstate in livestates:\n\t\t\t\t\t\tif nstate in self.finals:\n\t\t\t\t\t\t\tyield nstring\n\t\t\t\t\t\tstrings.append((nstring, nstate))\n\t\t\ti += 1", "response": "Yields all the strings that this FSM accepts."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cardinality(self):\n\t\t'''\n\t\t\tConsider the FSM as a set of strings and return the cardinality of that\n\t\t\tset, or raise an OverflowError if there are infinitely many\n\t\t'''\n\t\tnum_strings = {}\n\t\tdef get_num_strings(state):\n\t\t\t# Many FSMs have at least one oblivion state\n\t\t\tif self.islive(state):\n\t\t\t\tif state in num_strings:\n\t\t\t\t\tif num_strings[state] is None: # \"computing...\"\n\t\t\t\t\t\t# Recursion! There are infinitely many strings recognised\n\t\t\t\t\t\traise OverflowError(state)\n\t\t\t\t\treturn num_strings[state]\n\t\t\t\tnum_strings[state] = None # i.e. \"computing...\"\n\n\t\t\t\tn = 0\n\t\t\t\tif state in self.finals:\n\t\t\t\t\tn += 1\n\t\t\t\tif state in self.map:\n\t\t\t\t\tfor symbol in self.map[state]:\n\t\t\t\t\t\tn += get_num_strings(self.map[state][symbol])\n\t\t\t\tnum_strings[state] = n\n\n\t\t\telse:\n\t\t\t\t# Dead state\n\t\t\t\tnum_strings[state] = 0\n\n\t\t\treturn num_strings[state]\n\n\t\treturn get_num_strings(self.initial)", "response": "Returns the cardinality of the FSM."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy(self):\n\t\t'''\n\t\t\tFor completeness only, since `set.copy()` also exists. FSM objects are\n\t\t\timmutable, so I can see only very odd reasons to need this.\n\t\t'''\n\t\treturn fsm(\n\t\t\talphabet = self.alphabet,\n\t\t\tstates   = self.states,\n\t\t\tinitial  = self.initial,\n\t\t\tfinals   = self.finals,\n\t\t\tmap      = self.map,\n\t\t)", "response": "Returns a copy of the FSM."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef derive(self, input):\n\t\t'''\n\t\t\tCompute the Brzozowski derivative of this FSM with respect to the input\n\t\t\tstring of symbols. <https://en.wikipedia.org/wiki/Brzozowski_derivative>\n\t\t\tIf any of the symbols are not members of the alphabet, that's a KeyError.\n\t\t\tIf you fall into oblivion, then the derivative is an FSM accepting no\n\t\t\tstrings.\n\t\t'''\n\t\ttry:\n\t\t\t# Consume the input string.\n\t\t\tstate = self.initial\n\t\t\tfor symbol in input:\n\t\t\t\tif not symbol in self.alphabet:\n\t\t\t\t\tif not anything_else in self.alphabet:\n\t\t\t\t\t\traise KeyError(symbol)\n\t\t\t\t\tsymbol = anything_else\n\n\t\t\t\t# Missing transition = transition to dead state\n\t\t\t\tif not (state in self.map and symbol in self.map[state]):\n\t\t\t\t\traise OblivionError\n\n\t\t\t\tstate = self.map[state][symbol]\n\n\t\t\t# OK so now we have consumed that string, use the new location as the\n\t\t\t# starting point.\n\t\t\treturn fsm(\n\t\t\t\talphabet = self.alphabet,\n\t\t\t\tstates   = self.states,\n\t\t\t\tinitial  = state,\n\t\t\t\tfinals   = self.finals,\n\t\t\t\tmap      = self.map,\n\t\t\t)\n\n\t\texcept OblivionError:\n\t\t\t# Fell out of the FSM. The derivative of this FSM is the empty FSM.\n\t\t\treturn null(self.alphabet)", "response": "Derive the state of this FSM from the input string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering an endpoint aginst this resource.", "response": "def add_endpoint(self, endpoint):\n        \"\"\"Register an :class:`.Endpoint` aginst this resource.\n\n        :param endpoint: :class:`.Endpoint` API Endpoint class\n\n        Usage::\n\n            foo_resource = Resource('example', __name__)\n            class MyEndpoint(Endpoint):\n\n                url = '/example'\n                name = 'myendpoint'\n\n            foo_resource.add_endpoint(MyEndpoint)\n        \"\"\"\n\n        if self.url_prefix:\n            url = '{prefix}{url}'.format(prefix=self.url_prefix, url=endpoint.url)\n        else:\n            url = endpoint.url\n\n        self.add_url_rule(\n            url,\n            view_func=endpoint.as_view(endpoint.get_name()),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreduces the result of this method call ( unless you already reduced it.", "response": "def reduce_after(method):\n\t'''reduce() the result of this method call (unless you already reduced it).'''\n\tdef new_method(self, *args, **kwargs):\n\t\tresult = method(self, *args, **kwargs)\n\t\tif result == self:\n\t\t\treturn result\n\t\treturn result.reduce()\n\treturn new_method"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef call_fsm(method):\n\t'''\n\t\tTake a method which acts on 0 or more regular expression objects... return a\n\t\tnew method which simply converts them all to FSMs, calls the FSM method\n\t\ton them instead, then converts the result back to a regular expression.\n\t\tWe do this for several of the more annoying operations.\n\t'''\n\tfsm_method = getattr(fsm.fsm, method.__name__)\n\tdef new_method(*legos):\n\t\talphabet = set().union(*[lego.alphabet() for lego in legos])\n\t\treturn from_fsm(fsm_method(*[lego.to_fsm(alphabet) for lego in legos]))\n\treturn new_method", "response": "A method which converts all of the given legos to FSMs and returns a new method which simply calls the FSM methodon them instead."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_fsm(f):\n\t'''\n\t\tTurn the supplied finite state machine into a `lego` object. This is\n\t\taccomplished using the Brzozowski algebraic method.\n\t'''\n\t# Make sure the supplied alphabet is kosher. It must contain only single-\n\t# character strings or `fsm.anything_else`.\n\tfor symbol in f.alphabet:\n\t\tif symbol == fsm.anything_else:\n\t\t\tcontinue\n\t\tif isinstance(symbol, str) and len(symbol) == 1:\n\t\t\tcontinue\n\t\traise Exception(\"Symbol \" + repr(symbol) + \" cannot be used in a regular expression\")\n\n\t# We need a new state not already used\n\toutside = object()\n\n\t# The set of strings that would be accepted by this FSM if you started\n\t# at state i is represented by the regex R_i.\n\t# If state i has a sole transition \"a\" to state j, then we know R_i = a R_j.\n\t# If state i is final, then the empty string is also accepted by this regex.\n\t# And so on...\n\n\t# From this we can build a set of simultaneous equations in len(f.states)\n\t# variables. This system is easily solved for all variables, but we only\n\t# need one: R_a, where a is the starting state.\n\n\t# The first thing we need to do is organise the states into order of depth,\n\t# so that when we perform our back-substitutions, we can start with the\n\t# last (deepest) state and therefore finish with R_a.\n\tstates = [f.initial]\n\ti = 0\n\twhile i < len(states):\n\t\tcurrent = states[i]\n\t\tif current in f.map:\n\t\t\tfor symbol in sorted(f.map[current], key=fsm.key):\n\t\t\t\tnext = f.map[current][symbol]\n\t\t\t\tif next not in states:\n\t\t\t\t\tstates.append(next)\n\t\ti += 1\n\n\t# Our system of equations is represented like so:\n\tbrz = {}\n\tfor a in f.states:\n\t\tbrz[a] = {}\n\t\tfor b in f.states | {outside}:\n\t\t\tbrz[a][b] = nothing\n\n\t# Populate it with some initial data.\n\tfor a in f.map:\n\t\tfor symbol in f.map[a]:\n\t\t\tb = f.map[a][symbol]\n\t\t\tif symbol == fsm.anything_else:\n\t\t\t\tbrz[a][b] |= ~charclass(f.alphabet - {fsm.anything_else})\n\t\t\telse:\n\t\t\t\tbrz[a][b] |= charclass({symbol})\n\t\tif a in f.finals:\n\t\t\tbrz[a][outside] |= emptystring\n\n\t# Now perform our back-substitution\n\tfor i in reversed(range(len(states))):\n\t\ta = states[i]\n\n\t\t# Before the equation for R_a can be substituted into the other\n\t\t# equations, we need to resolve the self-transition (if any).\n\t\t# e.g.    R_a = 0 R_a |   1 R_b |   2 R_c\n\t\t# becomes R_a =         0*1 R_b | 0*2 R_c\n\t\tloop = brz[a][a] * star # i.e. \"0*\"\n\t\tdel brz[a][a]\n\n\t\tfor right in brz[a]:\n\t\t\tbrz[a][right] = loop + brz[a][right]\n\n\t\t# Note: even if we're down to our final equation, the above step still\n\t\t# needs to be performed before anything is returned.\n\n\t\t# Now we can substitute this equation into all of the previous ones.\n\t\tfor j in range(i):\n\t\t\tb = states[j]\n\n\t\t\t# e.g. substituting R_a =  0*1 R_b |      0*2 R_c\n\t\t\t# into              R_b =    3 R_a |        4 R_c | 5 R_d\n\t\t\t# yields            R_b = 30*1 R_b | (30*2|4) R_c | 5 R_d\n\t\t\tuniv = brz[b][a] # i.e. \"3\"\n\t\t\tdel brz[b][a]\n\n\t\t\tfor right in brz[a]:\n\t\t\t\tbrz[b][right] |= univ + brz[a][right]\n\n\treturn brz[f.initial][outside].reduce()", "response": "Convert a finite state machine into a lego object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(cls, string):\n\t\t'''\n\t\t\tParse the entire supplied string as an instance of the present class.\n\t\t\tMainly for internal use in unit tests because it drops through to match()\n\t\t\tin a convenient way.\n\t\t'''\n\t\tobj, i = cls.match(string, 0)\n\t\tif i != len(string):\n\t\t\traise Exception(\"Could not parse '\" + string + \"' beyond index \" + str(i))\n\t\treturn obj", "response": "Parses the supplied string as an instance of the present class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef strings(self, otherchar=None):\n\t\t'''\n\t\t\tEach time next() is called on this iterator, a new string is returned\n\t\t\twhich will the present lego piece can match. StopIteration is raised once\n\t\t\tall such strings have been returned, although a regex with a * in may\n\t\t\tmatch infinitely many strings.\n\t\t'''\n\n\t\t# In the case of a regex like \"[^abc]\", there are infinitely many (well, a\n\t\t# very large finite number of) single characters which will match. It's not\n\t\t# productive to iterate over all of these giving every single example.\n\t\t# You must supply your own \"otherchar\" to stand in for all of these\n\t\t# possibilities.\n\t\tfor string in self.to_fsm().strings():\n\n\t\t\t# Have to represent `fsm.anything_else` somehow.\n\t\t\tif fsm.anything_else in string:\n\t\t\t\tif otherchar == None:\n\t\t\t\t\traise Exception(\"Please choose an 'otherchar'\")\n\t\t\t\tstring = [\n\t\t\t\t\totherchar if char == fsm.anything_else else char\n\t\t\t\t\tfor char in string\n\t\t\t\t]\n\n\t\t\tyield \"\".join(string)", "response": "Iterate over the string in this iterator."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if this multipliers can intersect other.", "response": "def canintersect(self, other):\n\t\t'''\n\t\t\tIntersection is not well-defined for all pairs of multipliers.\n\t\t\tFor example:\n\t\t\t\t{2,3} & {3,4} = {3}\n\t\t\t\t{2,} & {1,7} = {2,7}\n\t\t\t\t{2} & {5} = ERROR\n\t\t'''\n\t\treturn not (self.max < other.min or other.max < self.min)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if this multiplier can be unioned with the other.", "response": "def canunion(self, other):\n\t\t'''Union is not defined for all pairs of multipliers. e.g. {0,1} | {3,4}'''\n\t\treturn not (self.max + bound(1) < other.min or other.max + bound(1) < self.min)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef common(self, other):\n\t\t'''\n\t\t\tFind the shared part of two multipliers. This is the largest multiplier\n\t\t\twhich can be safely subtracted from both the originals. This may\n\t\t\treturn the \"zero\" multiplier.\n\t\t'''\n\t\tmandatory = min(self.mandatory, other.mandatory)\n\t\toptional = min(self.optional, other.optional)\n\t\treturn multiplier(mandatory, mandatory + optional)", "response": "Find the common part of two multipliers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndock self from other and return the result.", "response": "def dock(self, other):\n\t\t'''\n\t\t\t\"Dock\" another mult from this one (i.e. remove part of the tail) and\n\t\t\treturn the result. The reverse of concatenation. This is a lot trickier.\n\t\t\te.g. a{4,5} - a{3} = a{1,2}\n\t\t'''\n\t\tif other.multiplicand != self.multiplicand:\n\t\t\traise Exception(\"Can't subtract \" + repr(other) + \" from \" + repr(self))\n\t\treturn mult(self.multiplicand, self.multiplier - other.multiplier)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef common(self, other):\n\t\t'''\n\t\t\tReturn the common part of these two mults. This is the largest mult\n\t\t\twhich can be safely subtracted from both the originals. The multiplier\n\t\t\ton this mult could be zero: this is the case if, for example, the\n\t\t\tmultiplicands disagree.\n\t\t'''\n\t\tif self.multiplicand == other.multiplicand:\n\t\t\treturn mult(self.multiplicand, self.multiplier.common(other.multiplier))\n\n\t\t# Multiplicands disagree, no common part at all.\n\t\treturn mult(nothing, zero)", "response": "Return the common part of two multiplicands."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the common prefix of two multiplicands.", "response": "def common(self, other, suffix=False):\n\t\t'''\n\t\t\tReturn the common prefix of these two concs; that is, the largest conc\n\t\t\twhich can be safely beheaded() from the front of both.\n\t\t\tThe result could be emptystring.\n\t\t\t\"ZYAA, ZYBB\" -> \"ZY\"\n\t\t\t\"CZ, CZ\" -> \"CZ\"\n\t\t\t\"YC, ZC\" -> \"\"\n\n\t\t\tWith the \"suffix\" flag set, works from the end. E.g.:\n\t\t\t\"AAZY, BBZY\" -> \"ZY\"\n\t\t\t\"CZ, CZ\" -> \"CZ\"\n\t\t\t\"CY, CZ\" -> \"\"\n\t\t'''\n\t\tmults = []\n\n\t\tindices = range(min(len(self.mults), len(other.mults))) # e.g. [0, 1, 2, 3]\n\n\t\t# Work backwards from the end of both concs instead.\n\t\tif suffix:\n\t\t\tindices = [-i - 1 for i in indices] # e.g. [-1, -2, -3, -4]\n\n\t\tfor i in indices:\n\n\t\t\tcommon = self.mults[i].common(other.mults[i])\n\n\t\t\t# Happens when multiplicands disagree (e.g. \"A.common(B)\") or if\n\t\t\t# the multiplicand is shared but the common multiplier is zero\n\t\t\t# (e.g. \"ABZ*.common(CZ)\".)\n\t\t\tif common.multiplier == zero:\n\t\t\t\tbreak\n\n\t\t\tmults.append(common)\n\n\t\t\t# If we did not remove the entirety of both mults, we cannot continue.\n\t\t\tif common != self.mults[i] or common != other.mults[i]:\n\t\t\t\tbreak\n\n\t\tif suffix:\n\t\t\tmults = reversed(mults)\n\n\t\treturn conc(*mults)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsubtracting another conc from this one. This is the opposite of concatenation. For example, if ABC + DEF = ABCDEF, then logically ABCDEF - DEF = ABC.", "response": "def dock(self, other):\n\t\t'''\n\t\t\tSubtract another conc from this one.\n\t\t\tThis is the opposite of concatenation. For example, if ABC + DEF = ABCDEF,\n\t\t\tthen logically ABCDEF - DEF = ABC.\n\t\t'''\n\n\t\t# e.g. self has mults at indices [0, 1, 2, 3, 4, 5, 6] len=7\n\t\t# e.g. other has mults at indices [0, 1, 2] len=3\n\t\tnew = list(self.mults)\n\t\tfor i in reversed(range(len(other.mults))): # [2, 1, 0]\n\t\t\t# e.g. i = 1, j = 7 - 3 + 1 = 5\n\t\t\tj = len(self.mults) - len(other.mults) + i\n\t\t\tnew[j] = new[j].dock(other.mults[i])\n\n\t\t\tif new[j].multiplier == zero:\n\t\t\t\t# omit that mult entirely since it has been factored out\n\t\t\t\tdel new[j]\n\n\t\t\t# If the subtraction is incomplete but there is more to\n\t\t\t# other.mults, then we have a problem. For example, \"ABC{2} - BC\"\n\t\t\t# subtracts the C successfully but leaves something behind,\n\t\t\t# then tries to subtract the B too, which isn't possible\n\t\t\telse:\n\t\t\t\tif i != 0:\n\t\t\t\t\traise Exception(\"Can't subtract \" + repr(other) + \" from \" + repr(self))\n\n\t\treturn conc(*new)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dock(self, other):\n\t\t'''\n\t\t\tThe opposite of concatenation. Remove a common suffix from the present\n\t\t\tpattern; that is, from each of its constituent concs.\n\t\t\tAYZ|BYZ|CYZ - YZ = A|B|C.\n\t\t'''\n\t\treturn pattern(*[c.dock(other) for c in self.concs])", "response": "The opposite of concatenation. Remove common suffix from the present\n\t\t\tpattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the behead pattern for this node and other.", "response": "def behead(self, other):\n\t\t'''\n\t\t\tLike dock() but the other way around. Remove a common prefix from the\n\t\t\tpresent pattern; that is, from each of its constituent concs.\n\t\t\tZA|ZB|ZC.behead(Z) = A|B|C\n\t\t'''\n\t\treturn pattern(*[c.behead(other) for c in self.concs])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _commonconc(self, suffix=False):\n\t\t'''\n\t\t\tFind the longest conc which acts as prefix to every conc in this pattern.\n\t\t\tThis could be the empty string. Return the common prefix along with all\n\t\t\tthe leftovers after truncating that common prefix from each conc.\n\t\t\t\"ZA|ZB|ZC\" -> \"Z\", \"(A|B|C)\"\n\t\t\t\"ZA|ZB|ZC|Z\" -> \"Z\", \"(A|B|C|)\"\n\t\t\t\"CZ|CZ\" -> \"CZ\", \"()\"\n\n\t\t\tIf \"suffix\" is True, the same result but for suffixes.\n\t\t'''\n\t\tif len(self.concs) == 0:\n\t\t\traise Exception(\"Can't call _commonconc on \" + repr(self))\n\n\t\tfrom functools import reduce\n\t\treturn reduce(\n\t\t\tlambda x, y: x.common(y, suffix=suffix),\n\t\t\tself.concs\n\t\t)", "response": "Return the common prefix of each conc of this pattern."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_name(name):\n    ''' This function don't use the plugin. '''\n    session = create_session()\n    try:\n        user = session.query(User).filter_by(name=name).first()\n        session.delete(user)\n        session.commit()\n    except SQLAlchemyError, e:\n        session.rollback()\n        raise bottle.HTTPError(500, \"Database Error\", e)\n    finally:\n        session.close()", "response": "This function don t use the plugin."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup(self, app):\n        ''' Make sure that other installed plugins don't affect the same\n            keyword argument and check if metadata is available.'''\n        for other in app.plugins:\n            if not isinstance(other, SQLAlchemyPlugin):\n                continue\n            if other.keyword == self.keyword:\n                raise bottle.PluginError(\"Found another SQLAlchemy plugin with \"\\\n                                  \"conflicting settings (non-unique keyword).\")\n            elif other.name == self.name:\n                self.name += '_%s' % self.keyword\n        if self.create and not self.metadata:\n            raise bottle.PluginError('Define metadata value to create database.')", "response": "Make sure that other installed plugins don t affect the same\n            keyword argument and check if metadata is available."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_multipart(self, *args, **kwargs):\n        self.__in_send_multipart = True\n        try:\n            msg = super(GreenSocket, self).send_multipart(*args, **kwargs)\n        finally:\n            self.__in_send_multipart = False\n            self.__state_changed()\n        return msg", "response": "wrap send_multipart to prevent state_changed on each partial send"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef recv_multipart(self, *args, **kwargs):\n        self.__in_recv_multipart = True\n        try:\n            msg = super(GreenSocket, self).recv_multipart(*args, **kwargs)\n        finally:\n            self.__in_recv_multipart = False\n            self.__state_changed()\n        return msg", "response": "wrap recv_multipart to prevent state_changed on each partial recv"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_all(path, include_core=True, subfolders=None, path_in_arc=None):\n    def clean(varStr):\n        \"\"\" get valid python name from folder\n        \"\"\"\n        return re.sub('\\W|^(?=\\d)', '_', str(varStr))\n\n    path = Path(path)\n\n    if zipfile.is_zipfile(str(path)):\n        with zipfile.ZipFile(file=str(path), mode='r') as zz:\n            zipcontent = zz.namelist()\n        if path_in_arc:\n            path_in_arc = str(path_in_arc)\n            if path_in_arc not in zipcontent:\n                path_in_arc = os.path.join(path_in_arc,\n                                           DEFAULT_FILE_NAMES['filepara'])\n                if path_in_arc not in zipcontent:\n                    raise ReadError('File parameter file {} not found in {}. '\n                                    'Tip: specify fileparameter filename '\n                                    'through \"path_in_arc\" if different '\n                                    'from default.'.format(\n                                        DEFAULT_FILE_NAMES['filepara'], path))\n\n        else:\n            with zipfile.ZipFile(file=str(path), mode='r') as zz:\n                fpfiles = [\n                    f for f in zz.namelist()\n                    if\n                    os.path.basename(f) == DEFAULT_FILE_NAMES['filepara'] and\n                    json.loads(zz.read(f).decode('utf-8')\n                               )['systemtype'] == 'IOSystem']\n            if len(fpfiles) == 0:\n                raise ReadError('File parameter file {} not found in {}. '\n                                'Tip: specify fileparameter filename '\n                                'through \"path_in_arc\" if different '\n                                'from default.'.format(\n                                    DEFAULT_FILE_NAMES['filepara'], path))\n            elif len(fpfiles) > 1:\n                raise ReadError('Mulitple mrio archives found in {}. '\n                                'Specify one by the '\n                                'parameter \"path_in_arc\"'.format(path))\n            else:\n                path_in_arc = os.path.dirname(fpfiles[0])\n\n        logging.debug(\"Expect file parameter-file at {} in {}\".format(\n            path_in_arc, path))\n\n    io = load(path, include_core=include_core, path_in_arc=path_in_arc)\n\n    if zipfile.is_zipfile(str(path)):\n        root_in_zip = os.path.dirname(path_in_arc)\n        if subfolders is None:\n            subfolders = {\n                os.path.relpath(os.path.dirname(p), root_in_zip)\n                for p in zipcontent\n                if p.startswith(root_in_zip) and\n                os.path.dirname(p) != root_in_zip}\n\n        for subfolder_name in subfolders:\n            if subfolder_name not in zipcontent + list({\n                    os.path.dirname(p) for p in zipcontent}):\n                subfolder_full = os.path.join(root_in_zip, subfolder_name)\n            else:\n                subfolder_full = subfolder_name\n            subfolder_name = os.path.basename(os.path.normpath(subfolder_name))\n\n            if subfolder_name not in zipcontent:\n                subfolder_full_meta = os.path.join(\n                    subfolder_full, DEFAULT_FILE_NAMES['filepara'])\n            else:\n                subfolder_full_meta = subfolder_full\n\n            if subfolder_full_meta in zipcontent:\n                ext = load(path,\n                           include_core=include_core,\n                           path_in_arc=subfolder_full_meta)\n                setattr(io, clean(subfolder_name), ext)\n                io.meta._add_fileio(\"Added satellite account \"\n                                    \"from {}\".format(subfolder_full))\n            else:\n                continue\n\n    else:\n        if subfolders is None:\n            subfolders = [d for d in path.iterdir() if d.is_dir()]\n\n        for subfolder_name in subfolders:\n            if not os.path.exists(str(subfolder_name)):\n                subfolder_full = path / subfolder_name\n            else:\n                subfolder_full = subfolder_name\n            subfolder_name = os.path.basename(os.path.normpath(subfolder_name))\n\n            if not os.path.isfile(str(subfolder_full)):\n                subfolder_full_meta = (subfolder_full /\n                                       DEFAULT_FILE_NAMES['filepara'])\n            else:\n                subfolder_full_meta = subfolder_full\n\n            if subfolder_full_meta.exists():\n                ext = load(subfolder_full, include_core=include_core)\n                setattr(io, clean(subfolder_name), ext)\n                io.meta._add_fileio(\"Added satellite account \"\n                                    \"from {}\".format(subfolder_full))\n            else:\n                continue\n\n    return io", "response": "Loads a full IO system with all extension in path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load(path, include_core=True, path_in_arc=''):\n    path = Path(path)\n\n    if not path.exists():\n        raise ReadError('Given path does not exist')\n\n    file_para = get_file_para(path=path, path_in_arc=path_in_arc)\n\n    if file_para.content['systemtype'] == GENERIC_NAMES['iosys']:\n        if zipfile.is_zipfile(str(path)):\n            ret_system = IOSystem(meta=MRIOMetaData(\n                location=path,\n                path_in_arc=os.path.join(file_para.folder,\n                                         DEFAULT_FILE_NAMES['metadata'])))\n            ret_system.meta._add_fileio(\n                \"Loaded IO system from {} - {}\".format(path, path_in_arc))\n        else:\n            ret_system = IOSystem(meta=MRIOMetaData(\n                location=path / DEFAULT_FILE_NAMES['metadata']))\n            ret_system.meta._add_fileio(\n                \"Loaded IO system from {}\".format(path))\n\n    elif file_para.content['systemtype'] == GENERIC_NAMES['ext']:\n        ret_system = Extension(file_para.content['name'])\n\n    else:\n        raise ReadError('Type of system no defined in the file parameters')\n        return None\n\n    for key in file_para.content['files']:\n        if not include_core and key not in ['A', 'L', 'Z']:\n                continue\n\n        file_name = file_para.content['files'][key]['name']\n        nr_index_col = file_para.content['files'][key]['nr_index_col']\n        nr_header = file_para.content['files'][key]['nr_header']\n        _index_col = list(range(int(nr_index_col)))\n        _header = list(range(int(nr_header)))\n        _index_col = 0 if _index_col == [0] else _index_col\n        _header = 0 if _header == [0] else _header\n\n        if zipfile.is_zipfile(str(path)):\n            full_file_name = os.path.join(file_para.folder, file_name)\n            logging.info('Load data from {}'.format(full_file_name))\n\n            with zipfile.ZipFile(file=str(path)) as zf:\n                if (os.path.splitext(str(full_file_name))[1] == '.pkl' or\n                        os.path.splitext(str(full_file_name))[1] == '.pickle'):\n                    setattr(ret_system, key,\n                            pd.read_pickle(zf.open(full_file_name)))\n                else:\n                    setattr(ret_system, key,\n                            pd.read_table(zf.open(full_file_name),\n                                          index_col=_index_col,\n                                          header=_header))\n        else:\n            full_file_name = path / file_name\n            logging.info('Load data from {}'.format(full_file_name))\n\n            if (os.path.splitext(str(full_file_name))[1] == '.pkl' or\n                    os.path.splitext(str(full_file_name))[1] == '.pickle'):\n                setattr(ret_system, key,\n                        pd.read_pickle(full_file_name))\n            else:\n                setattr(ret_system, key,\n                        pd.read_table(full_file_name,\n                                      index_col=_index_col,\n                                      header=_header))\n    return ret_system", "response": "Loads a specific IOSystem or Extension from a JSON file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef archive(source, archive, path_in_arc=None, remove_source=False,\n            compression=zipfile.ZIP_DEFLATED, compresslevel=-1):\n    \"\"\"Archives a MRIO database as zip file\n\n    This function is a wrapper around zipfile.write,\n    to ease the writing of an archive and removing the source data.\n\n    Note\n    ----\n    In contrast to zipfile.write, this function raises an\n    error if the data (path + filename) are identical in the zip archive.\n    Background: the zip standard allows that files with the same name and path\n    are stored side by side in a zip file. This becomes an issue when unpacking\n    this files as they overwrite each other upon extraction.\n\n    Parameters\n    ----------\n\n    source: str or pathlib.Path or list of these\n        Location of the mrio data (folder).\n        If not all data should be archived, pass a list of\n        all files which should be included in the archive (absolute path)\n\n    archive: str or pathlib.Path\n        Full path with filename for the archive.\n\n    path_in_arc: string, optional\n        Path within the archive zip file where data should be stored.\n        'path_in_arc' must be given without leading dot and slash.\n        Thus to point to the data in the root of the compressed file pass '',\n        for data in e.g. the folder 'mrio_v1' pass 'mrio_v1/'.\n        If None (default) data will be stored in the root of the archive.\n\n    remove_source: boolean, optional\n        If True, deletes the source file from the disk (all files\n        specified in 'source' or the specified directory, depending if a\n        list of files or directory was passed). If False, leaves the\n        original files on disk. Also removes all empty directories\n        in source including source.\n\n    compression: ZIP compression method, optional\n        This is passed to zipfile.write. By default it is set to ZIP_DEFLATED.\n        NB: This is different from the zipfile default (ZIP_STORED) which would\n        not give any compression. See\n        https://docs.python.org/3/library/zipfile.html#zipfile-objects for\n        further information. Depending on the value given here additional\n        modules might be necessary (e.g. zlib for ZIP_DEFLATED). Futher\n        information on this can also be found in the zipfile python docs.\n\n    compresslevel: int, optional\n        This is passed to zipfile.write and specifies the compression level.\n        Acceptable values depend on the method specified at the parameter\n        'compression'.  By default, it is set to -1 which gives a compromise\n        between speed and size for the ZIP_DEFLATED compression (this is\n        internally interpreted as 6 as described here:\n        https://docs.python.org/3/library/zlib.html#zlib.compressobj )\n        NB: This is only used if python version >= 3.7\n\n    Raises\n    ------\n    FileExistsError: In case a file to be archived already present in the\n    archive.\n\n    \"\"\"\n    archive = Path(archive)\n\n    if type(source) is not list:\n        source_root = str(source)\n        source_files = [f for f in Path(source).glob('**/*') if f.is_file()]\n    else:\n        source_root = os.path.commonpath([str(f) for f in source])\n        source_files = [Path(f) for f in source]\n\n    path_in_arc = '' if not path_in_arc else path_in_arc\n\n    arc_file_names = {\n        str(f): os.path.join(path_in_arc, str(f.relative_to(source_root)))\n        for f in source_files}\n\n    if archive.exists():\n        with zipfile.ZipFile(file=str(archive), mode='r') as zf:\n            already_present = zf.namelist()\n        duplicates = {ff: zf for ff, zf in arc_file_names.items()\n                      if zf in already_present}\n\n        if duplicates:\n            raise FileExistsError(\n                'These files already exists in {arc} for '\n                'path_in_arc \"{pa}\":\\n  {filelist}'.format(\n                    pa=path_in_arc, arc=archive,\n                    filelist='\\n  '.join(duplicates.values())))\n\n    if sys.version_info.major == 3 and sys.version_info.minor >= 7:\n        zip_open_para = dict(file=str(archive), mode='a',\n                             compression=compression,\n                             compresslevel=compresslevel)\n    else:\n        zip_open_para = dict(file=str(archive), mode='a',\n                             compression=compression)\n\n    with zipfile.ZipFile(**zip_open_para) as zz:\n        for fullpath, zippath in arc_file_names.items():\n            zz.write(str(fullpath), str(zippath))\n\n    if remove_source:\n        for f in source_files:\n            os.remove(str(f))\n\n        for root, dirs, files in os.walk(source_root, topdown=False):\n            for name in dirs:\n                dir_path = os.path.join(root, name)\n                if not os.listdir(dir_path):\n                    os.rmdir(os.path.join(root, name))\n        try:\n            os.rmdir(source_root)\n        except OSError:\n            pass", "response": "Archives a MRIO database as a zip file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _load_ini_based_io(path, recursive=False, ini=None,\n                       subini={}, include_core=True,\n                       only_coefficients=False):\n    \"\"\" DEPRECATED: For convert a previous version to the new json format\n\n    Loads a IOSystem or Extension from a ini files\n\n    This function can be used to load a IOSystem or Extension specified in a\n    ini file. DataFrames (tables) are loaded from text or binary pickle files.\n    For the latter, the extension .pkl or .pickle is assumed, in all other case\n    the tables are assumed to be in .txt format.\n\n    Parameters\n    ----------\n\n    path : string\n        path or ini file name for the data to load\n\n    recursive : boolean, optional\n        If True, load also the data in the subfolders and add them as\n        extensions to the IOSystem (in that case path must point to the root).\n        Only first order subfolders are considered (no subfolders in\n        subfolders) and if a folder does not contain a ini file it's skipped.\n        Use the subini parameter in case of multiple ini files in a subfolder.\n        Attribute name of the extension in the IOSystem are based on the\n        subfolder name.  Default is False\n\n    ini : string, optional\n        If there are several ini files in the root folder, take this one for\n        loading the data If None (default) take the ini found in the folder,\n        error if several are found\n\n    subini : dict, optional\n        If there are multiple ini in the subfolder, use the ini given in the\n        dict.  Format: 'subfoldername':'ininame' If a key for a subfolder is\n        not found or None (default), the ini found in the folder will be taken,\n        error if several are found\n\n    include_core : boolean, optional\n        If False the load method does not include A, L and Z matrix. This\n        significantly reduces the required memory if the purpose is only\n        to analyse the results calculated beforehand.\n\n    Returns\n    -------\n\n        IOSystem or Extension class depending on systemtype in the ini file\n        None in case of errors\n\n    \"\"\"\n\n    # check path and given parameter\n    ini_file_name = None\n\n    path = os.path.abspath(os.path.normpath(path))\n\n    if os.path.splitext(path)[1] == '.ini':\n        (path, ini_file_name) = os.path.split(path)\n\n    if ini:\n        ini_file_name = ini\n\n    if not os.path.exists(path):\n        raise ReadError('Given path does not exist')\n        return None\n\n    if not ini_file_name:\n        _inifound = False\n        for file in os.listdir(path):\n            if os.path.splitext(file)[1] == '.ini':\n                if _inifound:\n                    raise ReadError(\n                            'Found multiple ini files in folder - specify one')\n                    return None\n                ini_file_name = file\n                _inifound = True\n\n    # read the ini\n    io_ini = configparser.RawConfigParser()\n    io_ini.optionxform = lambda option: option\n\n    io_ini.read(os.path.join(path, ini_file_name))\n\n    systemtype = io_ini.get('systemtype', 'systemtype', fallback=None)\n    name = io_ini.get('meta', 'name',\n                      fallback=os.path.splitext(ini_file_name)[0])\n\n    if systemtype == 'IOSystem':\n        ret_system = IOSystem(name=name)\n    elif systemtype == 'Extension':\n        ret_system = Extension(name=name)\n    else:\n        raise ReadError('System not defined in ini')\n        return None\n\n    for key in io_ini['meta']:\n        setattr(ret_system, key, io_ini.get('meta', key, fallback=None))\n\n    for key in io_ini['files']:\n        if '_nr_index_col' in key:\n            continue\n        if '_nr_header' in key:\n            continue\n\n        if not include_core:\n            not_to_load = ['A', 'L', 'Z']\n            if key in not_to_load:\n                continue\n\n        if only_coefficients:\n            _io = IOSystem()\n            if key not in _io.__coefficients__ + ['unit']:\n                continue\n\n        file_name = io_ini.get('files', key)\n        nr_index_col = io_ini.get(\n            'files', key + '_nr_index_col', fallback=None)\n        nr_header = io_ini.get('files', key + '_nr_header', fallback=None)\n\n        if (nr_index_col is None) or (nr_header is None):\n            raise ReadError(\n                    'Index or column specification missing for {}'.\n                    format(str(file_name)))\n            return None\n\n        _index_col = list(range(int(nr_index_col)))\n        _header = list(range(int(nr_header)))\n\n        if _index_col == [0]:\n            _index_col = 0\n        if _header == [0]:\n            _header = 0\n        file = os.path.join(path, file_name)\n        logging.info('Load data from {}'.format(file))\n\n        if (os.path.splitext(file)[1] == '.pkl' or\n                os.path.splitext(file)[1] == '.pickle'):\n            setattr(ret_system, key,\n                    pd.read_pickle(file))\n        else:\n            setattr(ret_system, key,\n                    pd.read_table(file,\n                                  index_col=_index_col,\n                                  header=_header))\n\n    if recursive:\n        # look for subfolder in the given path\n        subfolder_list = os.walk(path).__next__()[1]\n\n        # loop all subfolder and append extension based on\n        # ini file in subfolder\n        for subfolder in subfolder_list:\n            subini_file_name = subini.get(subfolder)\n            subpath = os.path.abspath(os.path.join(path, subfolder))\n\n            if not subini_file_name:\n                _inifound = False\n                for file in os.listdir(subpath):\n                    if os.path.splitext(file)[1] == '.ini':\n                        if _inifound:\n                            raise ReadError(\n                                'Found multiple ini files in subfolder '\n                                '{} - specify one'.format(subpath))\n                            return None\n                        subini_file_name = file\n                        _inifound = True\n            if not _inifound:\n                continue\n\n            # read the ini\n            subio_ini = configparser.RawConfigParser()\n            subio_ini.optionxform = lambda option: option\n\n            subio_ini.read(os.path.join(subpath, subini_file_name))\n\n            systemtype = subio_ini.get('systemtype', 'systemtype',\n                                       fallback=None)\n            name = subio_ini.get('meta', 'name',\n                                 fallback=os.path.splitext(\n                                     subini_file_name)[0])\n\n            if systemtype == 'IOSystem':\n                raise ReadError('IOSystem found in subfolder {} - '\n                                'only extensions expected'.format(subpath))\n                return None\n            elif systemtype == 'Extension':\n                sub_system = Extension(name=name)\n            else:\n                raise ReadError('System not defined in ini')\n                return None\n\n            for key in subio_ini['meta']:\n                setattr(sub_system, key, subio_ini.get('meta', key,\n                                                       fallback=None))\n\n            for key in subio_ini['files']:\n                if '_nr_index_col' in key:\n                    continue\n                if '_nr_header' in key:\n                    continue\n\n                if only_coefficients:\n                    _ext = Extension('temp')\n                    if key not in _ext.__coefficients__ + ['unit']:\n                        continue\n\n                file_name = subio_ini.get('files', key)\n                nr_index_col = subio_ini.get('files', key + '_nr_index_col',\n                                             fallback=None)\n                nr_header = subio_ini.get('files', key + '_nr_header',\n                                          fallback=None)\n\n                if (nr_index_col is None) or (nr_header is None):\n                    raise ReadError('Index or column specification missing '\n                                    'for {}'.format(str(file_name)))\n                    return None\n\n                _index_col = list(range(int(nr_index_col)))\n                _header = list(range(int(nr_header)))\n\n                if _index_col == [0]:\n                    _index_col = 0\n                if _header == [0]:\n                    _header = 0\n                file = os.path.join(subpath, file_name)\n                logging.info('Load data from {}'.format(file))\n                if (os.path.splitext(file)[1] == '.pkl' or\n                        os.path.splitext(file)[1] == '.pickle'):\n                    setattr(sub_system, key,\n                            pd.read_pickle(file))\n                else:\n                    setattr(sub_system, key,\n                            pd.read_table(file,\n                                          index_col=_index_col,\n                                          header=_header))\n\n                # get valid python name from folder\n                def clean(varStr):\n                    return re.sub('\\W|^(?=\\d)', '_', str(varStr))\n\n                setattr(ret_system, clean(subfolder), sub_system)\n\n    return ret_system", "response": "This function loads a new json file from a ini file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing an EXIOBASE version 1 or 2 like extension file into a single entry in the index.", "response": "def parse_exio12_ext(ext_file, index_col, name, drop_compartment=True,\n                     version=None, year=None, iosystem=None, sep=','):\n    \"\"\" Parse an EXIOBASE version 1 or 2 like extension file into pymrio.Extension\n\n    EXIOBASE like extensions files are assumed to have two\n    rows which are used as columns multiindex (region and sector)\n    and up to three columns for the row index (see Parameters).\n\n    For EXIOBASE 3 - extension can be loaded directly with pymrio.load\n\n    Notes\n    -----\n    So far this only parses factor of production extensions F (not\n    final demand extensions FY nor coeffiecents S).\n\n    Parameters\n    ----------\n\n    ext_file : string or pathlib.Path\n        File to parse\n\n    index_col : int\n        The number of columns (1 to 3) at the beginning of the file\n        to use as the index. The order of the index_col must be\n        - 1 index column: ['stressor']\n        - 2 index columns: ['stressor', 'unit']\n        - 3 index columns: ['stressor', 'compartment', 'unit']\n        - > 3: everything up to three index columns will be removed\n\n    name : string\n        Name of the extension\n\n    drop_compartment : boolean, optional\n        If True (default) removes the compartment from the index.\n\n    version : string, optional\n        see pymrio.Extension\n\n    iosystem : string, optional\n        see pymrio.Extension\n\n    year : string or int\n        see pymrio.Extension\n\n    sep : string, optional\n        Delimiter to use; default ','\n\n    Returns\n    -------\n    pymrio.Extension\n        with F (and unit if available)\n\n    \"\"\"\n\n    ext_file = os.path.abspath(str(ext_file))\n\n    F = pd.read_table(\n        ext_file,\n        header=[0, 1],\n        index_col=list(range(index_col)),\n        sep=sep)\n\n    F.columns.names = ['region', 'sector']\n\n    if index_col == 1:\n        F.index.names = ['stressor']\n\n    elif index_col == 2:\n        F.index.names = ['stressor', 'unit']\n\n    elif index_col == 3:\n        F.index.names = ['stressor', 'compartment', 'unit']\n\n    else:\n        F.reset_index(level=list(range(3, index_col)),\n                      drop=True,\n                      inplace=True)\n        F.index.names = ['stressor', 'compartment', 'unit']\n\n    unit = None\n    if index_col > 1:\n        unit = pd.DataFrame(F.iloc[:, 0].\n                            reset_index(level='unit').unit)\n        F.reset_index(level='unit', drop=True, inplace=True)\n\n    if drop_compartment:\n        F.reset_index(level='compartment',\n                      drop=True, inplace=True)\n        unit.reset_index(level='compartment',\n                         drop=True, inplace=True)\n\n    return Extension(name=name,\n                     F=F,\n                     unit=unit,\n                     iosystem=iosystem,\n                     version=version,\n                     year=year,\n                     )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the EXIOBASE version for the given filename None if not found", "response": "def get_exiobase12_version(filename):\n    \"\"\" Returns the EXIOBASE version for the given filename,\n        None if not found\n    \"\"\"\n    try:\n        ver_match = re.search(r'(\\d+\\w*(\\.|\\-|\\_))*\\d+\\w*', filename)\n        version = ver_match.string[ver_match.start():ver_match.end()]\n        if re.search('\\_\\d\\d\\d\\d', version[-5:]):\n            version = version[:-5]\n    except AttributeError:\n        version = None\n\n    return version"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_exiobase_files(path, coefficients=True):\n    path = os.path.normpath(str(path))\n    if coefficients:\n        exio_core_regex = dict(\n            # don\u2019t match file if starting with _\n            A=re.compile('(?<!\\_)mrIot.*txt'),\n            Y=re.compile('(?<!\\_)mrFinalDemand.*txt'),\n            S_factor_inputs=re.compile('(?<!\\_)mrFactorInputs.*txt'),\n            S_emissions=re.compile('(?<!\\_)mrEmissions.*txt'),\n            S_materials=re.compile('(?<!\\_)mrMaterials.*txt'),\n            S_resources=re.compile('(?<!\\_)mrResources.*txt'),\n            FY_resources=re.compile('(?<!\\_)mrFDResources.*txt'),\n            FY_emissions=re.compile('(?<!\\_)mrFDEmissions.*txt'),\n            FY_materials=re.compile('(?<!\\_)mrFDMaterials.*txt'),\n            )\n    else:\n        exio_core_regex = dict(\n            # don\u2019t match file if starting with _\n            Z=re.compile('(?<!\\_)mrIot.*txt'),\n            Y=re.compile('(?<!\\_)mrFinalDemand.*txt'),\n            F_fac=re.compile('(?<!\\_)mrFactorInputs.*txt'),\n            F_emissions=re.compile('(?<!\\_)mrEmissions.*txt'),\n            F_materials=re.compile('(?<!\\_)mrMaterials.*txt'),\n            F_resources=re.compile('(?<!\\_)mrResources.*txt'),\n            FY_emissions=re.compile('(?<!\\_)mrFDEmissions.*txt'),\n            FY_materials=re.compile('(?<!\\_)mrFDMaterials.*txt'),\n            )\n\n    repo_content = get_repo_content(path)\n\n    exio_files = dict()\n    for kk, vv in exio_core_regex.items():\n        found_file = [vv.search(ff).string for ff in repo_content.filelist\n                      if vv.search(ff)]\n        if len(found_file) > 1:\n            logging.warning(\n                \"Multiple files found for {}: {}\"\n                \" - USING THE FIRST ONE\".format(kk, found_file))\n            found_file = found_file[0:1]\n        elif len(found_file) == 0:\n            continue\n        else:\n            if repo_content.iszip:\n                format_para = sniff_csv_format(found_file[0],\n                                               zip_file=path)\n            else:\n                format_para = sniff_csv_format(os.path.join(path,\n                                                            found_file[0]))\n            exio_files[kk] = dict(\n                root_repo=path,\n                file_path=found_file[0],\n                version=get_exiobase12_version(\n                    os.path.basename(found_file[0])),\n                index_rows=format_para['nr_header_row'],\n                index_col=format_para['nr_index_col'],\n                unit_col=format_para['nr_index_col'] - 1,\n                sep=format_para['sep'])\n\n    return exio_files", "response": "Returns a dict of all EXIOBASE files in path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generic_exiobase12_parser(exio_files, system=None):\n\n    version = ' & '.join({dd.get('version', '')\n                          for dd in exio_files.values()\n                          if dd.get('version', '')})\n\n    meta_rec = MRIOMetaData(system=system,\n                            name=\"EXIOBASE\",\n                            version=version)\n\n    if len(version) == 0:\n        meta_rec.note(\"No version information found, assuming exiobase 1\")\n        meta_rec.change_meta('version', 1)\n        version = '1'\n\n    core_components = ['A', 'Y', 'Z']\n\n    core_data = dict()\n    ext_data = dict()\n    for tt, tpara in exio_files.items():\n        full_file_path = os.path.join(tpara['root_repo'], tpara['file_path'])\n        logging.debug(\"Parse {}\".format(full_file_path))\n        if tpara['root_repo'][-3:] == 'zip':\n            with zipfile.ZipFile(tpara['root_repo'], 'r') as zz:\n                raw_data = pd.read_table(\n                    zz.open(tpara['file_path']),\n                    index_col=list(range(tpara['index_col'])),\n                    header=list(range(tpara['index_rows'])))\n        else:\n            raw_data = pd.read_table(\n                full_file_path,\n                index_col=list(range(tpara['index_col'])),\n                header=list(range(tpara['index_rows'])))\n\n        meta_rec._add_fileio('EXIOBASE data {} parsed from {}'.format(\n            tt, full_file_path))\n        if tt in core_components:\n            core_data[tt] = raw_data\n        else:\n            ext_data[tt] = raw_data\n\n    for table in core_data:\n        core_data[table].index.names = ['region', 'sector', 'unit']\n        if table == 'A' or table == 'Z':\n            core_data[table].columns.names = ['region', 'sector']\n            _unit = pd.DataFrame(\n                    core_data[table].iloc[:, 0]).reset_index(\n                        level='unit').unit\n            _unit = pd.DataFrame(_unit)\n            _unit.columns = ['unit']\n        if table == 'Y':\n            core_data[table].columns.names = ['region', 'category']\n        core_data[table].reset_index(level='unit', drop=True, inplace=True)\n\n    core_data['unit'] = _unit\n\n    mon_unit = core_data['unit'].iloc[0, 0]\n    if '/' in mon_unit:\n        mon_unit = mon_unit.split('/')[0]\n        core_data['unit'].unit = mon_unit\n\n    extensions = dict()\n    for tt, tpara in exio_files.items():\n        if tt in core_components:\n            continue\n        ext_name = '_'.join(tt.split('_')[1:])\n        table_type = tt.split('_')[0]\n\n        if tpara['index_col'] == 3:\n            ext_data[tt].index.names = [\n                'stressor', 'compartment', 'unit']\n        elif tpara['index_col'] == 2:\n            ext_data[tt].index.names = [\n                'stressor', 'unit']\n        else:\n            raise ParserError('Unknown EXIOBASE file structure')\n\n        if table_type == 'FY':\n            ext_data[tt].columns.names = [\n                'region', 'category']\n        else:\n            ext_data[tt].columns.names = [\n                'region', 'sector']\n        try:\n            _unit = pd.DataFrame(\n                ext_data[tt].iloc[:, 0]\n            ).reset_index(level='unit').unit\n        except IndexError:\n            _unit = pd.DataFrame(\n                ext_data[tt].iloc[:, 0])\n            _unit.columns = ['unit']\n            _unit['unit'] = 'undef'\n            _unit.reset_index(level='unit', drop=True, inplace=True)\n            _unit = pd.DataFrame(_unit)\n            _unit.columns = ['unit']\n        _unit = pd.DataFrame(_unit)\n        _unit.columns = ['unit']\n        _new_unit = _unit.unit.str.replace('/'+mon_unit, '')\n        _new_unit[_new_unit == ''] = _unit.unit[\n            _new_unit == ''].str.replace('/', '')\n        _unit.unit = _new_unit\n\n        ext_data[tt].reset_index(level='unit', drop=True, inplace=True)\n        ext_dict = extensions.get(ext_name, dict())\n        ext_dict.update({table_type: ext_data[tt],\n                         'unit': _unit,\n                         'name': ext_name})\n        extensions.update({ext_name: ext_dict})\n\n    if version[0] == '1':\n        year = 2000\n    elif version[0] == '2':\n        year = 2000\n    elif version[0] == '3':\n        raise ParserError(\n            \"This function can not be used to parse EXIOBASE 3\")\n    else:\n        logging.warning(\"Unknown EXIOBASE version\")\n        year = None\n\n    return IOSystem(version=version,\n                    price='current',\n                    year=year,\n                    meta=meta_rec,\n                    **dict(core_data, **extensions))", "response": "Generic parser for EXIOBASE version 1 and 2."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_MRIO_system(path):\n    ispxp = True if re.search('pxp', path, flags=re.IGNORECASE) else False\n    isixi = True if re.search('ixi', path, flags=re.IGNORECASE) else False\n\n    if ispxp == isixi:\n        system = None\n    else:\n        system = 'pxp' if ispxp else 'ixi'\n    return system", "response": "Extract system information from file path."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_exiobase1(path):\n    path = os.path.abspath(os.path.normpath(str(path)))\n\n    exio_files = get_exiobase_files(path)\n    if len(exio_files) == 0:\n        raise ParserError(\"No EXIOBASE files found at {}\".format(path))\n\n    system = _get_MRIO_system(path)\n    if not system:\n        logging.warning(\"Could not determine system (pxp or ixi)\"\n                        \" set system parameter manually\")\n\n    io = generic_exiobase12_parser(exio_files, system=system)\n    return io", "response": "Parses the EXIOBASE 1 data files and returns a pymrio. IOSystem with the parsed data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_exiobase2(path, charact=True, popvector='exio2'):\n    path = os.path.abspath(os.path.normpath(str(path)))\n\n    exio_files = get_exiobase_files(path)\n    if len(exio_files) == 0:\n        raise ParserError(\"No EXIOBASE files found at {}\".format(path))\n\n    system = _get_MRIO_system(path)\n    if not system:\n        logging.warning(\"Could not determine system (pxp or ixi)\"\n                        \" set system parameter manually\")\n\n    io = generic_exiobase12_parser(exio_files, system=system)\n\n    # read the characterisation matrices if available\n    # and build one extension with the impacts\n    if charact:\n        logging.debug('Parse characterisation matrix')\n        # dict with correspondence to the extensions\n        Qsheets = {'Q_factorinputs': 'factor_inputs',\n                   'Q_emission': 'emissions',\n                   'Q_materials': 'materials',\n                   'Q_resources': 'resources'}\n\n        Q_head_col = dict()\n        Q_head_row = dict()\n        Q_head_col_rowname = dict()\n        Q_head_col_rowunit = dict()\n        # Q_head_col_metadata = dict()\n        # number of cols containing row headers at the beginning\n        Q_head_col['Q_emission'] = 4\n        # number of rows containing col headers at the top - this will be\n        # skipped\n        Q_head_row['Q_emission'] = 3\n        # assuming the same classification as in the extensions\n        Q_head_col['Q_factorinputs'] = 2\n        Q_head_row['Q_factorinputs'] = 2\n        Q_head_col['Q_resources'] = 2\n        Q_head_row['Q_resources'] = 3\n        Q_head_col['Q_materials'] = 2\n        Q_head_row['Q_materials'] = 2\n\n        #  column to use as name for the rows\n        Q_head_col_rowname['Q_emission'] = 1\n        Q_head_col_rowname['Q_factorinputs'] = 0\n        Q_head_col_rowname['Q_resources'] = 0\n        Q_head_col_rowname['Q_materials'] = 0\n\n        # column to use as unit for the rows which gives also the last column\n        # before the data\n        Q_head_col_rowunit['Q_emission'] = 3\n        Q_head_col_rowunit['Q_factorinputs'] = 1\n        Q_head_col_rowunit['Q_resources'] = 1\n        Q_head_col_rowunit['Q_materials'] = 1\n\n        if charact is str:\n            charac_data = {Qname: pd.read_excel(\n                           charact,\n                           sheet_name=Qname,\n                           skiprows=list(range(0, Q_head_row[Qname])),\n                           header=None)\n                           for Qname in Qsheets}\n        else:\n            _content = get_repo_content(path)\n            charac_regex = re.compile('(?<!\\_)(?<!\\.)characterisation.*xlsx')\n            charac_files = [ff for ff in _content.filelist if\n                            re.search(charac_regex, ff)]\n            if len(charac_files) > 1:\n                raise ParserError(\n                    \"Found multiple characcterisation files \"\n                    \"in {} - specify one: {}\".format(path, charac_files))\n            elif len(charac_files) == 0:\n                raise ParserError(\n                    \"No characcterisation file found \"\n                    \"in {}\".format(path))\n            else:\n                if _content.iszip:\n                    with zipfile.ZipFile(path, 'r') as zz:\n                        charac_data = {Qname: pd.read_excel(\n                                       zz.open(charac_files[0]),\n                                       sheet_name=Qname,\n                                       skiprows=list(\n                                           range(0, Q_head_row[Qname])),\n                                       header=None)\n                                       for Qname in Qsheets}\n\n                else:\n                    charac_data = {Qname: pd.read_excel(\n                                   os.path.join(path, charac_files[0]),\n                                   sheet_name=Qname,\n                                   skiprows=list(range(0, Q_head_row[Qname])),\n                                   header=None)\n                                   for Qname in Qsheets}\n\n        _unit = dict()\n        # temp for the calculated impacts which than\n        # get summarized in the 'impact'\n        _impact = dict()\n        impact = dict()\n        for Qname in Qsheets:\n            # unfortunately the names in Q_emissions are\n            # not completely unique - fix that\n            if Qname is 'Q_emission':\n                _index = charac_data[Qname][Q_head_col_rowname[Qname]].copy()\n                _index.iloc[42] = _index.iloc[42] + ' 2008'\n                _index.iloc[43] = _index.iloc[43] + ' 2008'\n                _index.iloc[44] = _index.iloc[44] + ' 2010'\n                _index.iloc[45] = _index.iloc[45] + ' 2010'\n                charac_data[Qname][Q_head_col_rowname[Qname]] = _index\n\n            charac_data[Qname].index = (\n                charac_data[Qname][Q_head_col_rowname[Qname]])\n\n            _unit[Qname] = pd.DataFrame(\n                    charac_data[Qname].iloc[:, Q_head_col_rowunit[Qname]])\n            _unit[Qname].columns = ['unit']\n            _unit[Qname].index.name = 'impact'\n            charac_data[Qname] = charac_data[Qname].ix[\n                :, Q_head_col_rowunit[Qname]+1:]\n            charac_data[Qname].index.name = 'impact'\n\n            try:\n                _FY = io.__dict__[Qsheets[Qname]].FY.values\n            except AttributeError:\n                _FY = np.zeros([io.__dict__[Qsheets[Qname]].S.shape[0],\n                                io.Y.shape[1]])\n\n            _impact[Qname] = {'S': charac_data[Qname].dot(\n                                   io.__dict__[Qsheets[Qname]].S.values),\n                              'FY': charac_data[Qname].dot(_FY),\n                              'unit': _unit[Qname]\n                              }\n\n        impact['S'] = (_impact['Q_factorinputs']['S']\n                       .append(_impact['Q_emission']['S'])\n                       .append(_impact['Q_materials']['S'])\n                       .append(_impact['Q_resources']['S']))\n        impact['FY'] = (_impact['Q_factorinputs']['FY']\n                        .append(_impact['Q_emission']['FY'])\n                        .append(_impact['Q_materials']['FY'])\n                        .append(_impact['Q_resources']['FY']))\n        impact['S'].columns = io.emissions.S.columns\n        impact['FY'].columns = io.emissions.FY.columns\n        impact['unit'] = (_impact['Q_factorinputs']['unit']\n                          .append(_impact['Q_emission']['unit'])\n                          .append(_impact['Q_materials']['unit'])\n                          .append(_impact['Q_resources']['unit']))\n        impact['name'] = 'impact'\n        io.impact = Extension(**impact)\n\n    if popvector is 'exio2':\n        logging.debug('Read population vector')\n        io.population = pd.read_table(os.path.join(PYMRIO_PATH['exio20'],\n                                                   './misc/population.txt'),\n                                      index_col=0).astype(float)\n    else:\n        io.population = popvector\n\n    return io", "response": "Parses the EXIOBASE 2. 2 source files and returns a dictionary with the parsed data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_exiobase3(path):\n    io = load_all(path)\n    # need to rename the final demand satellite,\n    # wrong name in the standard distribution\n    try:\n        io.satellite.FY = io.satellite.F_hh.copy()\n        del io.satellite.F_hh\n    except AttributeError:\n        pass\n\n    # some ixi in the exiobase 3.4 official distribution\n    # have a country name mixup. Clean it here:\n    io.rename_regions(\n        {'AUS': 'AU',\n         'AUT': 'AT',\n         'BEL': 'BE',\n         'BGR': 'BG',\n         'BRA': 'BR',\n         'CAN': 'CA',\n         'CHE': 'CH',\n         'CHN': 'CN',\n         'CYP': 'CY',\n         'CZE': 'CZ',\n         'DEU': 'DE',\n         'DNK': 'DK',\n         'ESP': 'ES',\n         'EST': 'EE',\n         'FIN': 'FI',\n         'FRA': 'FR',\n         'GBR': 'GB',\n         'GRC': 'GR',\n         'HRV': 'HR',\n         'HUN': 'HU',\n         'IDN': 'ID',\n         'IND': 'IN',\n         'IRL': 'IE',\n         'ITA': 'IT',\n         'JPN': 'JP',\n         'KOR': 'KR',\n         'LTU': 'LT',\n         'LUX': 'LU',\n         'LVA': 'LV',\n         'MEX': 'MX',\n         'MLT': 'MT',\n         'NLD': 'NL',\n         'NOR': 'NO',\n         'POL': 'PL',\n         'PRT': 'PT',\n         'ROM': 'RO',\n         'RUS': 'RU',\n         'SVK': 'SK',\n         'SVN': 'SI',\n         'SWE': 'SE',\n         'TUR': 'TR',\n         'TWN': 'TW',\n         'USA': 'US',\n         'ZAF': 'ZA',\n         'WWA': 'WA',\n         'WWE': 'WE',\n         'WWF': 'WF',\n         'WWL': 'WL',\n         'WWM': 'WM'})\n\n    return io", "response": "Parses the public EXIOBASE 3 system and returns a dictionary with the parsed population and characterization data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_wiod(path, year=None, names=('isic', 'c_codes'),\n               popvector=None):\n    \"\"\" Parse the wiod source files for the IOSystem\n\n    WIOD provides the MRIO tables in excel - format (xlsx) at\n    http://www.wiod.org/new_site/database/wiots.htm (release November 2013).\n    To use WIOD in pymrio these (for the year of analysis) must be downloaded.\n    The interindustry matrix of these files gets parsed in IOSystem.Z, the\n    additional information is included as factor_input extension (value\n    added,...)\n\n    The folder with these xslx must than be passed to the WIOD parsing\n    function. This folder may contain folders with the extension data. Every\n    folder within the wiod root folder will be parsed for extension data and\n    will be added to the IOSystem. The WIOD database offers the download of\n    the environmental extensions as zip files. These can be read directly by\n    the parser. In case a zip file and a folder with the same name are\n    available, the data is read from the folder. If the zip files are\n    extracted into folder, the folders must have the same name as the\n    corresponding zip file (without the 'zip' extension).\n\n    If a WIOD SEA file is present (at the root of path or in a folder named\n    'SEA' - only one file!), the labor data of this file gets included in the\n    factor_input extension (calculated for the the three skill levels\n    available). The monetary data in this file is not added because it is only\n    given in national currency.\n\n    Since the \"World Input-Output Tables in previous years' prices\" are still\n    under construction (20141129), no parser for these is provided.\n\n    Some of the meta-parameter of the IOSystem are set automatically based on\n    the values given in the first four cells and the name of the WIOD data\n    files (base year, version, price, iosystem).\n    These can be overwritten afterwards if needed.\n\n    Parameters\n    ----------\n    path : string or pathlib.Path\n        Path to the folder with the WIOD source files. In case that the path\n        to a specific file is given, only this will be parsed irrespective of\n        the values given in year.\n    year : int or str\n        Which year in the path should be parsed. The years can be given with\n        four or two digits (eg [2012 or 12]). If the given path contains a\n        specific file, the value of year will not be used (but inferred from\n        the meta data)- otherwise it must be given For the monetary data the\n        parser searches for files with 'wiot - two digit year'.\n    names : string or tuple, optional\n        WIOD provides three different sector/final demand categories naming\n        schemes. These can can be specified for the IOSystem. Pass:\n\n            1) 'isic': ISIC rev 3 Codes - available for interindustry flows\n               and final demand rows.\n            2) 'full': Full names - available for final demand rows and\n               final demand columns (categories) and interindustry flows.\n            3) 'c_codes' : WIOD specific sector numbers, available for final\n               demand rows and columns (categories) and interindustry flows.\n\n        Internally, the parser relies on 1) for the interindustry flows and 3)\n        for the final demand categories. This is the default and will also be\n        used if just 'isic' gets passed ('c_codes' also replace 'isic' if this\n        was passed for final demand categories). To specify different finial\n        consumption category names, pass a tuple with (sectors/interindustry\n        classification, fd categories), eg ('isic', 'full'). Names are case\n        insensitive and passing the first character is sufficient.\n    TODO popvector : TO BE IMPLEMENTED (consistent with EXIOBASE)\n\n    Yields\n    -------\n    IOSystem\n\n    Raises\n    ------\n    ParserError\n        If the WIOD source file are not complete or inconsistent\n\n    \"\"\"\n\n    # Path manipulation, should work cross platform\n    path = os.path.abspath(os.path.normpath(str(path)))\n\n    # wiot start and end\n    wiot_ext = '.xlsx'\n    wiot_start = 'wiot'\n\n    # determine which wiod file to be parsed\n    if not os.path.isdir(path):\n        # 1. case - one file specified in path\n        if os.path.isfile(path):\n            wiot_file = path\n        else:\n            # just in case the ending was forgotten\n            wiot_file = path + wiot_ext\n    else:\n        # 2. case: directory given-build wiot_file with the value given in year\n        if not year:\n            raise ParserError('No year specified '\n                              '(either specify a specific file '\n                              'or a path and year)')\n        year_two_digit = str(year)[-2:]\n        wiot_file_list = [fl for fl in os.listdir(path)\n                          if (fl[:6] == wiot_start + year_two_digit and\n                          os.path.splitext(fl)[1] == wiot_ext)]\n        if len(wiot_file_list) != 1:\n            raise ParserError('Multiple files for a given year or file not '\n                              'found (specify a specific file in paramters)')\n\n        wiot_file = os.path.join(path, wiot_file_list[0])\n\n    wiot_file = wiot_file\n    root_path = os.path.split(wiot_file)[0]\n    if not os.path.exists(wiot_file):\n        raise ParserError('WIOD file not found in the specified folder.')\n\n    meta_rec = MRIOMetaData(location=root_path)\n\n    # wiot file structure\n    wiot_meta = {\n            'col': 0,   # column of the meta information\n            'year': 0,  # rest: rows with the data\n            'iosystem': 2,\n            'unit': 3,\n            'end_row': 4,\n            }\n    wiot_header = {\n            # the header indexes are the same for rows after removing the first\n            # two lines (wiot_empty_top_rows)\n            'code': 0,\n            'sector_names': 1,\n            'region': 2,\n            'c_code': 3,\n            }\n    wiot_empty_top_rows = [0, 1]\n\n    wiot_marks = {   # special marks\n        'last_interindsec': 'c35',     # last sector of the interindustry\n        'tot_facinp': ['r60', 'r69'],  # useless totals to remove from factinp\n        'total_column': [-1],          # the total column in the whole data\n        }\n\n    wiot_sheet = 0   # assume the first one is the one with the data.\n\n    # Wiod has an unfortunate file structure with overlapping metadata and\n    # header. In order to deal with that first the full file is read.\n    wiot_data = pd.read_excel(wiot_file,\n                              sheet_name=wiot_sheet,\n                              header=None)\n\n    meta_rec._add_fileio('WIOD data parsed from {}'.format(wiot_file))\n    # get meta data\n    wiot_year = wiot_data.iloc[wiot_meta['year'], wiot_meta['col']][-4:]\n    wiot_iosystem = wiot_data.iloc[\n            wiot_meta['iosystem'], wiot_meta['col']].rstrip(')').lstrip('(')\n    meta_rec.change_meta('system', wiot_iosystem)\n    _wiot_unit = wiot_data.iloc[\n            wiot_meta['unit'], wiot_meta['col']].rstrip(')').lstrip('(')\n\n    # remove meta data, empty rows, total column\n    wiot_data.iloc[0:wiot_meta['end_row'], wiot_meta['col']] = np.NaN\n    wiot_data.drop(wiot_empty_top_rows,\n                   axis=0, inplace=True)\n    wiot_data.drop(wiot_data.columns[wiot_marks['total_column']],\n                   axis=1, inplace=True)\n    # at this stage row and column header should have the same size but\n    # the index starts now at two - replace/reset to row numbers\n    wiot_data.index = range(wiot_data.shape[0])\n\n    # Early years in WIOD tables have a different name for Romania:\n    # 'ROM' which should be 'ROU'. The latter is also consistent with\n    # the environmental extensions names.\n    wiot_data.iloc[wiot_header['region'], :] = wiot_data.iloc[\n        wiot_header['region'], :].str.replace('ROM', 'ROU')\n    wiot_data.iloc[:, wiot_header['region']] = wiot_data.iloc[\n        :, wiot_header['region']].str.replace('ROM', 'ROU')\n\n    # get the end of the interindustry matrix\n    _lastZcol = wiot_data[\n        wiot_data.iloc[\n            :, wiot_header['c_code']] == wiot_marks['last_interindsec']\n        ].index[-1]\n    _lastZrow = wiot_data[\n        wiot_data[wiot_header['c_code']] == wiot_marks['last_interindsec']\n        ].index[-1]\n\n    if _lastZcol != _lastZrow:\n        raise ParserError(\n            'Interindustry matrix not symetric in the WIOD source file')\n    else:\n        Zshape = (_lastZrow, _lastZcol)\n\n    # separate factor input extension and remove\n    # totals in the first and last row\n    facinp = wiot_data.iloc[Zshape[0]+1:, :]\n    facinp = facinp.drop(\n        facinp[facinp[wiot_header['c_code']].isin(\n            wiot_marks['tot_facinp'])].index, axis=0\n        )\n\n    Z = wiot_data.iloc[:Zshape[0]+1, :Zshape[1]+1].copy()\n    Y = wiot_data.iloc[:Zshape[0]+1, Zshape[1]+1:].copy()\n    F_fac = facinp.iloc[:, :Zshape[1]+1].copy()\n    FY_fac = facinp.iloc[:, Zshape[1]+1:].copy()\n\n    index_wiot_headers = [nr for nr in wiot_header.values()]\n    # Save lookup of sectors and codes - to be used at the end of the parser\n    # Assuming USA is present in every WIOT year\n    wiot_sector_lookup = wiot_data[\n        wiot_data[wiot_header['region']] == 'USA'].iloc[\n            :, 0:max(index_wiot_headers)+1].applymap(str)\n    wiot_sector_lookup.columns = [\n        entry[1] for entry in sorted(\n            zip(wiot_header.values(), wiot_header.keys()))]\n    wiot_sector_lookup.set_index('code', inplace=True, drop=False)\n    _Y = Y.T.iloc[:, [\n        wiot_header['code'],  # Included to be consistent with  wiot_header\n        wiot_header['sector_names'],\n        wiot_header['region'],\n        wiot_header['c_code'],\n        ]]\n    wiot_fd_lookup = _Y[_Y.iloc[\n        :, wiot_header['region']] == 'USA'].applymap(str)\n    wiot_fd_lookup.columns = [\n        entry[1] for entry in\n        sorted(zip(wiot_header.values(), wiot_header.keys()))]\n    wiot_fd_lookup.set_index('c_code', inplace=True, drop=False)\n    wiot_fd_lookup.index.name = 'code'\n\n    # set the index/columns, work with code b/c these are also used in the\n    # extensions\n    Z[wiot_header['code']] = Z[wiot_header['code']].astype(str)\n    Z.set_index([wiot_header['region'],\n                wiot_header['code']], inplace=True, drop=False)\n    Z = Z.iloc[max(index_wiot_headers)+1:, max(index_wiot_headers)+1:]\n    Z.index.names = IDX_NAMES['Z_col']\n    Z.columns = Z.index\n\n    indexY_col_head = Y.iloc[[wiot_header['region'],\n                              wiot_header['c_code']], :]\n    Y.columns = pd.MultiIndex.from_arrays(indexY_col_head.values,\n                                          names=IDX_NAMES['Y_col2'])\n    Y = Y.iloc[max(index_wiot_headers)+1:, :]\n    Y.index = Z.index\n\n    F_fac.set_index([wiot_header['sector_names']],\n                    inplace=True, drop=False)  # c_code missing, use names\n    F_fac.index.names = ['inputtype']\n    F_fac = F_fac.iloc[:, max(index_wiot_headers)+1:]\n    F_fac.columns = Z.columns\n    FY_fac.columns = Y.columns\n    FY_fac.index = F_fac.index\n\n    # convert from object to float (was object because mixed float,str)\n    Z = Z.astype('float')\n    Y = Y.astype('float')\n    F_fac = F_fac.astype('float')\n    FY_fac = FY_fac.astype('float')\n\n    # save the units\n    Z_unit = pd.DataFrame(Z.iloc[:, 0])\n    Z_unit.columns = ['unit']\n    Z_unit['unit'] = _wiot_unit\n\n    F_fac_unit = pd.DataFrame(F_fac.iloc[:, 0])\n    F_fac_unit.columns = ['unit']\n    F_fac_unit['unit'] = _wiot_unit\n\n    ll_countries = list(Z.index.get_level_values('region').unique())\n\n    # Finalize the factor inputs extension\n    ext = dict()\n\n    ext['factor_inputs'] = {'F': F_fac,\n                            'FY': FY_fac,\n                            'year': wiot_year,\n                            'iosystem': wiot_iosystem,\n                            'unit': F_fac_unit,\n                            'name': 'factor input',\n                            }\n\n    # SEA extension\n    _F_sea_data, _F_sea_unit = __get_WIOD_SEA_extension(\n                            root_path=root_path, year=year)\n    if _F_sea_data is not None:\n        # None if no SEA file present\n        _FY_sea = pd.DataFrame(index=_F_sea_data.index,\n                               columns=FY_fac.columns, data=0)\n        _FY_sea = _FY_sea.astype('float')\n\n        ext['SEA'] = {'F': _F_sea_data,\n                      'FY': _FY_sea,\n                      'year': wiot_year,\n                      'iosystem': wiot_iosystem,\n                      'unit': _F_sea_unit,\n                      'name': 'SEA',\n                      }\n        meta_rec._add_fileio('SEA file extension parsed from {}'.format(\n            root_path))\n\n    # Environmental extensions, names follow the name given\n    # in the meta sheet (except for CO2 to get a better description).\n    # Units are hardcoded if no consistent place to read them\n    # within the files (for all extensions in upper case).\n    # The units names must exactly match!\n    # Start must identify exactly one folder or a zip file to\n    # read the extension.\n    # Within the folder, the routine looks for xls files\n    # starting with the country code.\n    dl_envext_para = {\n            'AIR': {'name': 'Air Emission Accounts',\n                    'start': 'AIR_',\n                    'ext': '.xls',\n                    'unit': {\n                            'CO2': 'Gg',\n                            'CH4': 't',\n                            'N2O': 't',\n                            'NOx': 't',\n                            'SOx': 't',\n                            'CO': 't',\n                            'NMVOC': 't',\n                            'NH3': 't',\n                            },\n                    },\n            'CO2': {'name': 'CO2 emissions - per source',\n                    'start': 'CO2_',\n                    'ext': '.xls',\n                    'unit': {\n                        'all': 'Gg'}\n                    },\n\n            'EM': {'name': 'Emission relevant energy use',\n                   'start': 'EM_',\n                   'ext': '.xls',\n                   'unit': {\n                        'all': 'TJ'}\n                   },\n            'EU': {'name': 'Gross energy use',\n                   'start': 'EU_',\n                   'ext': '.xls',\n                   'unit': {\n                        'all': 'TJ'}\n                   },\n            'lan': {'name': 'land use',\n                    'start': 'lan_',\n                    'ext': '.xls',\n                    'unit': {\n                        'all': None}\n                    },\n            'mat': {'name': 'material use',\n                    'start': 'mat_',\n                    'ext': '.xls',\n                    'unit': {\n                        'all': None}\n                    },\n            'wat': {'name': 'water use',\n                    'start': 'wat_',\n                    'ext': '.xls',\n                    'unit': {\n                        'all': None}\n                    },\n            }\n\n    _FY_template = pd.DataFrame(columns=FY_fac.columns)\n    _ss_FY_pressure_column = 'c37'\n    for ik_ext in dl_envext_para:\n        _dl_ex = __get_WIOD_env_extension(root_path=root_path,\n                                          year=year,\n                                          ll_co=ll_countries,\n                                          para=dl_envext_para[ik_ext])\n        if _dl_ex is not None:\n            # None if extension not available\n            _FY = _dl_ex['FY']\n\n            _FY.columns = pd.MultiIndex.from_product([\n                                _FY.columns, [_ss_FY_pressure_column]])\n            _FY = _FY_template.append(_FY)\n            _FY.fillna(0, inplace=True)\n            _FY.index.names = _dl_ex['F'].index.names\n            _FY.columns.names = _FY_template.columns.names\n            _FY = _FY[ll_countries]\n            _FY = _FY.astype('float')\n\n            ext[ik_ext] = {\n                    'F': _dl_ex['F'],\n                    'FY': _FY,\n                    'year': wiot_year,\n                    'iosystem': wiot_iosystem,\n                    'unit': _dl_ex['unit'],\n                    'name': dl_envext_para[ik_ext]['name'],\n                    }\n            meta_rec._add_fileio('Extension {} parsed from {}'.format(\n                ik_ext, root_path))\n\n    # Build system\n    wiod = IOSystem(Z=Z, Y=Y,\n                    unit=Z_unit,\n                    meta=meta_rec,\n                    **ext)\n\n    # Replace sector/final demand category names\n    if type(names) is str:\n        names = (names, names)\n    ll_names = [w[0].lower() for w in names]\n\n    if ll_names[0] == 'c':\n        dd_sec_rename = wiot_sector_lookup.c_code.to_dict()\n    elif ll_names[0] == 'i':\n        dd_sec_rename = wiot_sector_lookup.code.to_dict()\n    elif ll_names[0] == 'f':\n        dd_sec_rename = wiot_sector_lookup.sector_names.to_dict()\n    else:\n        dd_sec_rename = wiot_sector_lookup.code.to_dict()\n        warnings.warn('Parameter for names not understood - '\n                      'used ISIC codes as sector names')\n\n    if ll_names[1] == 'c':\n        dd_fd_rename = wiot_fd_lookup.c_code.to_dict()\n    elif ll_names[1] == 'i':\n        dd_fd_rename = wiot_fd_lookup.c_code.to_dict()\n    elif ll_names[1] == 'f':\n        dd_fd_rename = wiot_fd_lookup.sector_names.to_dict()\n    else:\n        warnings.warn('Parameter for names not understood - '\n                      'used c_codes as final demand category names')\n\n    wiod.Z.rename(columns=dd_sec_rename, index=dd_sec_rename, inplace=True)\n    wiod.Y.rename(columns=dd_fd_rename, index=dd_sec_rename, inplace=True)\n    for ext in wiod.get_extensions(data=True):\n        ext.F.rename(columns=dd_sec_rename, inplace=True)\n        ext.FY.rename(columns=dd_fd_rename, inplace=True)\n\n    return wiod", "response": "Parses the WIOD source files for the IOSystem and returns a tuple of the base year version price and popvector."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the WIOD environmental extension and returns the dictionary of the extension data for the given year.", "response": "def __get_WIOD_env_extension(root_path, year, ll_co, para):\n    \"\"\" Parses the wiod environmental extension\n\n    Extension can either be given as original .zip files or as extracted\n    data in a folder with the same name as the corresponding zip file (with-\n    out the extension).\n\n    This function is based on the structure of the extensions from _may12.\n\n    Note\n    ----\n    The function deletes 'secQ' which is not present in the economic tables.\n\n    Parameters\n    ----------\n    root_path : string\n        Path to the WIOD data or the path with the\n        extension data folder or zip file.\n    year : str or int\n        Year to return for the extension = valid sheetname for the xls file.\n    ll_co : list like\n        List of countries in WIOD - used for finding and matching\n        extension data in the given folder.\n    para : dict\n        Defining the parameters for reading the extension.\n\n    Returns\n    -------\n    dict with keys\n        F : pd.DataFrame with index 'stressor' and columns 'region', 'sector'\n        FY : pd.Dataframe with index 'stressor' and column 'region'\n            This data is for household stressors - must be applied to the right\n            final demand column afterwards.\n        unit : pd.DataFrame with index 'stressor' and column 'unit'\n\n\n    \"\"\"\n\n    ll_root_content = [ff for ff in os.listdir(root_path) if\n                       ff.startswith(para['start'])]\n    if len(ll_root_content) < 1:\n        warnings.warn(\n            'Extension data for {} not found - '\n            'Extension not included'.format(para['start']), ParserWarning)\n        return None\n\n    elif len(ll_root_content) > 1:\n        raise ParserError(\n            'Several raw data for extension'\n            '{} available - clean extension folder.'.format(para['start']))\n\n    pf_env = os.path.join(root_path, ll_root_content[0])\n\n    if pf_env.endswith('.zip'):\n        rf_zip = zipfile.ZipFile(pf_env)\n        ll_env_content = [ff for ff in rf_zip.namelist() if\n                          ff.endswith(para['ext'])]\n    else:\n        ll_env_content = [ff for ff in os.listdir(pf_env) if\n                          ff.endswith(para['ext'])]\n\n    dl_env = dict()\n    dl_env_hh = dict()\n    for co in ll_co:\n        ll_pff_read = [ff for ff in ll_env_content if\n                       ff.endswith(para['ext']) and\n                       (ff.startswith(co.upper()) or\n                        ff.startswith(co.lower()))]\n\n        if len(ll_pff_read) < 1:\n            raise ParserError('Country data not complete for Extension '\n                              '{} - missing {}.'.format(para['start'], co))\n\n        elif len(ll_pff_read) > 1:\n            raise ParserError('Multiple country data for Extension '\n                              '{} - country {}.'.format(para['start'], co))\n\n        pff_read = ll_pff_read[0]\n\n        if pf_env.endswith('.zip'):\n            ff_excel = pd.ExcelFile(rf_zip.open(pff_read))\n        else:\n            ff_excel = pd.ExcelFile(os.path.join(pf_env, pff_read))\n        if str(year) in ff_excel.sheet_names:\n            df_env = ff_excel.parse(sheet_name=str(year),\n                                    index_col=None,\n                                    header=0\n                                    )\n        else:\n            warnings.warn('Extension {} does not include'\n                          'data for the year {} - '\n                          'Extension not included'.format(para['start'], year),\n                          ParserWarning)\n            return None\n\n        if not df_env.index.is_numeric():\n            # upper case letter extensions gets parsed with multiindex, not\n            # quite sure why...\n            df_env.reset_index(inplace=True)\n\n        # unit can be taken from the first cell in the excel sheet\n        if df_env.columns[0] != 'level_0':\n            para['unit']['all'] = df_env.columns[0]\n\n        # two clean up cases - can be identified by lower/upper case extension\n        # description\n        if para['start'].islower():\n            pass\n        elif para['start'].isupper():\n            df_env = df_env.iloc[:, 1:]\n        else:\n            raise ParserError('Format of extension not given.')\n\n        df_env.dropna(axis=0, how='all', inplace=True)\n        df_env = df_env[df_env.iloc[:, 0] != 'total']\n        df_env = df_env[df_env.iloc[:, 0] != 'secTOT']\n        df_env = df_env[df_env.iloc[:, 0] != 'secQ']\n        df_env.iloc[:, 0].astype(str, inplace=True)\n        df_env.iloc[:, 0].replace(to_replace='sec',\n                                  value='',\n                                  regex=True,\n                                  inplace=True)\n\n        df_env.set_index([df_env.columns[0]], inplace=True)\n        df_env.index.names = ['sector']\n        df_env = df_env.T\n\n        ikc_hh = 'FC_HH'\n        dl_env_hh[co] = df_env[ikc_hh]\n        del df_env[ikc_hh]\n        dl_env[co] = df_env\n\n    df_F = pd.concat(dl_env, axis=1)[ll_co]\n    df_FY = pd.concat(dl_env_hh, axis=1)[ll_co]\n    df_F.fillna(0, inplace=True)\n    df_FY.fillna(0, inplace=True)\n\n    df_F.columns.names = IDX_NAMES['F_col']\n    df_F.index.names = IDX_NAMES['F_row_single']\n\n    df_FY.columns.names = IDX_NAMES['Y_col1']\n    df_FY.index.names = IDX_NAMES['F_row_single']\n\n    # build the unit df\n    df_unit = pd.DataFrame(index=df_F.index, columns=['unit'])\n    _ss_unit = para['unit'].get('all', 'undef')\n    for ikr in df_unit.index:\n        df_unit.ix[ikr, 'unit'] = para['unit'].get(ikr, _ss_unit)\n\n    df_unit.columns.names = ['unit']\n    df_unit.index.names = ['stressor']\n\n    if pf_env.endswith('.zip'):\n        rf_zip.close()\n\n    return {'F': df_F,\n            'FY': df_FY,\n            'unit': df_unit\n            }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the Eora26 database file and returns a dictionary of statistical disrecpancy columns.", "response": "def parse_eora26(path, year=None, price='bp', country_names='eora'):\n    \"\"\" Parse the Eora26 database\n\n    Note\n    ----\n\n    This parser deletes the statistical disrecpancy columns from\n    the parsed Eora system (reports the amount of loss in the\n    meta recors).\n\n    Eora does not provide any information on the unit of the\n    monetary values. Based on personal communication the unit\n    is set to Mill USD manually.\n\n\n    Parameters\n    ----------\n\n    path : string or pathlib.Path\n       Path to the eora raw storage folder or a specific eora zip file to\n       parse.  There are several options to specify the data for parsing:\n\n       1) Pass the name of eora zip file. In this case the parameters 'year'\n          and 'price' will not be used\n       2) Pass a folder which eiter contains eora zip files or unpacked eora\n          data In that case, a year must be given\n       3) Pass a folder which contains subfolders in the format 'YYYY', e.g.\n          '1998' This subfolder can either contain an Eora zip file or an\n          unpacked Eora system\n\n    year : int or str\n        4 digit year spec. This will not be used if a zip file\n        is specified in 'path'\n\n    price : str, optional\n        'bp' or 'pp'\n\n    country_names: str, optional\n        Which country names to use:\n        'eora' = Eora flavoured ISO 3 varian\n        'full' = Full country names as provided by Eora\n        Passing the first letter suffice.\n\n\n    \"\"\"\n    path = os.path.abspath(os.path.normpath(str(path)))\n\n    if country_names[0].lower() == 'e':\n        country_names = 'eora'\n    elif country_names[0].lower() == 'f':\n        country_names = 'full'\n    else:\n        raise ParserError('Parameter country_names must be eora or full')\n\n    row_name = 'ROW'\n    eora_zip_ext = '.zip'\n    is_zip = False\n\n    # determine which eora file to be parsed\n    if os.path.splitext(path)[1] == eora_zip_ext:\n        # case direct pass of eora zipfile\n        year = re.search(r'\\d\\d\\d\\d',\n                         os.path.basename(path)).group(0)\n        price = re.search(r'bp|pp',\n                          os.path.basename(path)).group(0)\n        eora_loc = path\n        root_path = os.path.split(path)[0]\n        is_zip = True\n    else:\n        root_path = path\n        if str(year) in os.listdir(path):\n            path = os.path.join(path, str(year))\n\n        eora_file_list = [fl for fl in os.listdir(path)\n                          if os.path.splitext(fl)[1] == eora_zip_ext and\n                          str(year) in fl and\n                          str(price) in fl\n                          ]\n\n        if len(eora_file_list) > 1:\n            raise ParserError('Multiple files for a given year '\n                              'found (specify a specific file in paramters)')\n        elif len(eora_file_list) == 1:\n            eora_loc = os.path.join(path, eora_file_list[0])\n            is_zip = True\n        else:\n            # Just a path was given, no zip file found,\n            # continue with only the path information - assumed an\n            # unpacked zip file\n            eora_loc = path\n            is_zip = False\n\n    meta_rec = MRIOMetaData(location=root_path)\n\n    # Eora file specs\n    eora_sep = '\\t'\n    ZY_col = namedtuple('ZY', 'full eora system name')(0, 1, 2, 3)\n\n    eora_files = {\n        'Z': 'Eora26_{year}_{price}_T.txt'.format(\n            year=str(year), price=price),\n        'Q': 'Eora26_{year}_{price}_Q.txt'.format(\n            year=str(year), price=price),\n        'QY': 'Eora26_{year}_{price}_QY.txt'.format(\n            year=str(year), price=price),\n        'VA': 'Eora26_{year}_{price}_VA.txt'.format(\n            year=str(year), price=price),\n        'Y': 'Eora26_{year}_{price}_FD.txt'.format(\n            year=str(year), price=price),\n        'labels_Z': 'labels_T.txt',\n        'labels_Y': 'labels_FD.txt',\n        'labels_Q': 'labels_Q.txt',\n        'labels_VA': 'labels_VA.txt',\n        }\n\n    header = namedtuple('header', 'index columns index_names, column_names')\n\n    eora_header_spec = {\n        'Z': header(index='labels_Z',\n                    columns='labels_Z',\n                    index_names=IDX_NAMES['Z_row'],\n                    column_names=IDX_NAMES['Z_col'],\n                    ),\n        'Q': header(index='labels_Q',\n                    columns='labels_Z',\n                    index_names=IDX_NAMES['F_row_src'],\n                    column_names=IDX_NAMES['F_col']),\n        'QY': header(index='labels_Q',\n                     columns='labels_Y',\n                     index_names=IDX_NAMES['F_row_src'],\n                     column_names=IDX_NAMES['Y_col2'],\n                     ),\n        'VA': header(index='labels_VA',\n                     columns='labels_Z',\n                     index_names=IDX_NAMES['VA_row_unit_cat'],\n                     column_names=IDX_NAMES['F_col']\n                     ),\n        'Y': header(index='labels_Z',\n                    columns='labels_Y',\n                    index_names=IDX_NAMES['Y_row'],\n                    column_names=IDX_NAMES['Y_col2'],\n                    ),\n        }\n\n    if is_zip:\n        zip_file = zipfile.ZipFile(eora_loc)\n        eora_data = {\n            key: pd.read_table(\n                zip_file.open(filename),\n                sep=eora_sep,\n                header=None\n                ) for\n            key, filename in eora_files.items()}\n        zip_file.close()\n    else:\n        eora_data = {\n            key: pd.read_table(\n                os.path.join(eora_loc, filename),\n                sep=eora_sep,\n                header=None\n                ) for\n            key, filename in eora_files.items()}\n    meta_rec._add_fileio(\n        'Eora26 for {year}-{price} data parsed from {loc}'.format(\n            year=year, price=price, loc=eora_loc))\n\n    eora_data['labels_Z'] = eora_data[\n        'labels_Z'].loc[:, [getattr(ZY_col, country_names), ZY_col.name]]\n    eora_data['labels_Y'] = eora_data[\n        'labels_Y'].loc[:, [getattr(ZY_col, country_names), ZY_col.name]]\n    eora_data['labels_VA'] = eora_data[\n        'labels_VA'].iloc[:, :len(eora_header_spec['VA'].column_names)]\n    labQ = eora_data[\n        'labels_Q'].iloc[:, :len(eora_header_spec['Q'].column_names)]\n    labQ.columns = IDX_NAMES['F_row_src']\n    Q_unit = labQ['stressor'].str.extract(r'\\((.*)\\)', expand=False)\n    Q_unit.columns = IDX_NAMES['unit']\n\n    labQ['stressor'] = labQ['stressor'].str.replace(r'\\s\\((.*)\\)', '')\n    eora_data['labels_Q'] = labQ\n\n    for key in eora_header_spec.keys():\n        eora_data[key].columns = (\n            eora_data[eora_header_spec[key].columns].set_index(list(\n                eora_data[eora_header_spec[key].columns])).index)\n        eora_data[key].columns.names = eora_header_spec[key].column_names\n        eora_data[key].index = (\n            eora_data[eora_header_spec[key].index].set_index(list(\n                eora_data[eora_header_spec[key].index])).index)\n        eora_data[key].index.names = eora_header_spec[key].index_names\n\n        try:\n            meta_rec._add_modify(\n                'Remove Rest of the World ({name}) '\n                'row from {table} - loosing {amount}'.format(\n                    name=row_name,\n                    table=key,\n                    amount=eora_data[key].loc[:, row_name].sum().values[0]))\n            eora_data[key].drop(row_name, axis=1, inplace=True)\n        except KeyError:\n            pass\n\n        try:\n            meta_rec._add_modify(\n                'Remove Rest of the World ({name}) column '\n                'from {table} - loosing {amount}'.format(\n                    name=row_name,\n                    table=key,\n                    amount=eora_data[key].loc[row_name, :].sum().values[0]))\n            eora_data[key].drop(row_name, axis=0, inplace=True)\n        except KeyError:\n            pass\n\n    Q_unit.index = eora_data['Q'].index\n\n    meta_rec.note('Set Eora moneatry units to Mill USD manually')\n    Z_unit = pd.DataFrame(data=['Mill USD'] * len(eora_data['Z'].index),\n                          index=eora_data['Z'].index,\n                          columns=['unit'])\n    VA_unit = pd.DataFrame(data=['Mill USD'] * len(eora_data['VA'].index),\n                           index=eora_data['VA'].index,\n                           columns=['unit'])\n\n    eora = IOSystem(\n        Z=eora_data['Z'],\n        Y=eora_data['Y'],\n        unit=Z_unit,\n        Q={\n            'name': 'Q',\n            'unit': Q_unit,\n            'F': eora_data['Q'],\n            'FY': eora_data['QY']\n            },\n        VA={\n            'name': 'VA',\n            'F': eora_data['VA'],\n            'unit': VA_unit,\n             },\n        meta=meta_rec)\n\n    return eora"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _add_history(self, entry_type, entry):\n        meta_string = \"{time} - {etype} -  {entry}\".format(\n            time=self._time(),\n            etype=entry_type.upper(),\n            entry=entry)\n\n        self._content['history'].insert(0, meta_string)\n        self.logger(meta_string)", "response": "Generic method to add entry as entry_type to the history"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchanges the meta data entry to a new value.", "response": "def change_meta(self, para, new_value, log=True):\n        \"\"\" Changes the meta data\n\n        This function does nothing if None is passed as new_value.\n        To set a certain value to None pass the str 'None'\n\n        Parameters\n        ----------\n        para: str\n            Meta data entry to change\n\n        new_value: str\n            New value\n\n        log: boolean, optional\n            If True (default) records the meta data change\n            in the history\n\n        \"\"\"\n        if not new_value:\n            return\n        para = para.lower()\n        if para == 'history':\n            raise ValueError(\n                'History can only be extended - use method \"note\"')\n        old_value = self._content.get(para, None)\n        if new_value == old_value:\n            return\n        self._content[para] = new_value\n        if old_value and log:\n            self._add_history(entry_type=\"METADATA_CHANGE\",\n                              entry='Changed parameter \"{para}\" '\n                                    'from \"{old}\" to \"{new}\"'.format(\n                                        para=para,\n                                        old=old_value,\n                                        new=new_value))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _read_content(self):\n        if self._path_in_arc:\n            with zipfile.ZipFile(file=str(self._metadata_file)) as zf:\n                self._content = json.loads(\n                    zf.read(self._path_in_arc).decode('utf-8'),\n                    object_pairs_hook=OrderedDict)\n        else:\n            with self._metadata_file.open('r') as mdf:\n                self._content = json.load(mdf,\n                                          object_pairs_hook=OrderedDict)", "response": "Reads the content of the object from the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the current status of the metadata to the given location.", "response": "def save(self, location=None):\n        \"\"\" Saves the current status of the metadata\n\n        This saves the metadata at the location of the previously loaded\n        metadata or at the file/path given in location.\n\n        Specify a location if the metadata should be stored in a different\n        location or was never stored before. Subsequent saves will use the\n        location set here.\n\n        Parameters\n        ----------\n        location: str, optional\n            Path or file for saving the metadata.\n            This can be the full file path or just the storage folder.\n            In the latter case, the filename defined in\n            DEFAULT_FILE_NAMES['metadata'] (currently 'metadata.json') is\n            assumed.\n        \"\"\"\n        if location:\n            location = Path(location)\n            if os.path.splitext(str(location))[1] == '':\n                self._metadata_file = location / DEFAULT_FILE_NAMES['metadata']\n            else:\n                self._metadata_file = location\n\n        if self._metadata_file:\n            with self._metadata_file.open(mode='w') as mdf:\n                json.dump(self._content, mdf, indent=4)\n        else:\n            logging.error(\"No metadata file given for storing the file\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the industry output x from the Z and Y matrix.", "response": "def calc_x(Z, Y):\n    \"\"\" Calculate the industry output x from the Z and Y matrix\n\n    Parameters\n    ----------\n    Z : pandas.DataFrame or numpy.array\n        Symmetric input output table (flows)\n    Y : pandas.DataFrame or numpy.array\n        final demand with categories (1.order) for each country (2.order)\n\n    Returns\n    -------\n    pandas.DataFrame or numpy.array\n        Industry output x as column vector\n        The type is determined by the type of Z. If DataFrame index as Z\n\n    \"\"\"\n    x = np.reshape(np.sum(np.hstack((Z, Y)), 1), (-1, 1))\n    if type(Z) is pd.DataFrame:\n        x = pd.DataFrame(x, index=Z.index, columns=['indout'])\n    if type(x) is pd.Series:\n        x = pd.DataFrame(x)\n    if type(x) is pd.DataFrame:\n        x.columns = ['indout']\n    return x"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the industry output x from a symmetric output Leontief table L and a column vector y", "response": "def calc_x_from_L(L, y):\n    \"\"\" Calculate the industry output x from L and a y vector\n\n    Parameters\n    ----------\n    L : pandas.DataFrame or numpy.array\n        Symmetric input output Leontief table\n    y : pandas.DataFrame or numpy.array\n        a column vector of the total final demand\n\n    Returns\n    -------\n    pandas.DataFrame or numpy.array\n        Industry output x as column vector\n        The type is determined by the type of L. If DataFrame index as L\n\n    \"\"\"\n    x = L.dot(y)\n    if type(x) is pd.Series:\n        x = pd.DataFrame(x)\n    if type(x) is pd.DataFrame:\n        x.columns = ['indout']\n    return x"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calc_Z(A, x):\n    if (type(x) is pd.DataFrame) or (type(x) is pd.Series):\n        x = x.values\n    x = x.reshape((1, -1))   # use numpy broadcasting - much faster\n    # (but has to ensure that x is a row vector)\n    # old mathematical form:\n    # return A.dot(np.diagflat(x))\n    if type(A) is pd.DataFrame:\n        return pd.DataFrame(A.values * x, index=A.index, columns=A.columns)\n    else:\n        return A*x", "response": "Calculates the Z matrix from A and x"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the A matrix from Z and x.", "response": "def calc_A(Z, x):\n    \"\"\" Calculate the A matrix (coefficients) from Z and x\n\n    Parameters\n    ----------\n    Z : pandas.DataFrame or numpy.array\n        Symmetric input output table (flows)\n    x : pandas.DataFrame or numpy.array\n        Industry output column vector\n\n    Returns\n    -------\n    pandas.DataFrame or numpy.array\n        Symmetric input output table (coefficients) A\n        The type is determined by the type of Z.\n        If DataFrame index/columns as Z\n\n    \"\"\"\n    if (type(x) is pd.DataFrame) or (type(x) is pd.Series):\n        x = x.values\n    if (type(x) is not np.ndarray) and (x == 0):\n        recix = 0\n    else:\n        with warnings.catch_warnings():\n            # catch the divide by zero warning\n            # we deal wit that by setting to 0 afterwards\n            warnings.simplefilter('ignore')\n            recix = 1/x\n        recix[recix == np.inf] = 0\n        recix = recix.reshape((1, -1))\n    # use numpy broadcasting - factor ten faster\n    # Mathematical form - slow\n    # return Z.dot(np.diagflat(recix))\n    if type(Z) is pd.DataFrame:\n        return pd.DataFrame(Z.values * recix, index=Z.index, columns=Z.columns)\n    else:\n        return Z*recix"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calc_L(A):\n    I = np.eye(A.shape[0])   # noqa\n    if type(A) is pd.DataFrame:\n        return pd.DataFrame(np.linalg.inv(I-A),\n                            index=A.index, columns=A.columns)\n    else:\n        return np.linalg.inv(I-A)", "response": "Calculates the Leontief L from A"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating Multipliers based on footprints.", "response": "def recalc_M(S, D_cba, Y, nr_sectors):\n    \"\"\" Calculate Multipliers based on footprints.\n\n    Parameters\n    ----------\n    D_cba : pandas.DataFrame or numpy array\n        Footprint per sector and country\n    Y : pandas.DataFrame or numpy array\n        Final demand: aggregated across categories or just one category, one\n        column per country. This will be diagonalized per country block.\n        The diagonolized form must be invertable for this method to work.\n    nr_sectors : int\n        Number of sectors in the MRIO\n\n    Returns\n    -------\n\n    pandas.DataFrame or numpy.array\n        Multipliers M\n        The type is determined by the type of D_cba.\n        If DataFrame index/columns as D_cba\n\n\n    \"\"\"\n\n    Y_diag = ioutil.diagonalize_blocks(Y.values, blocksize=nr_sectors)\n    Y_inv = np.linalg.inv(Y_diag)\n    M = D_cba.dot(Y_inv)\n    if type(D_cba) is pd.DataFrame:\n        M.columns = D_cba.columns\n        M.index = D_cba.index\n\n    return M"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the total cba and pba based accounts imp and exp accounts for a given set of sectors in the MRIO.", "response": "def calc_accounts(S, L, Y, nr_sectors):\n    \"\"\" Calculate sector specific cba and pba based accounts, imp and exp accounts\n\n    The total industry output x for the calculation\n    is recalculated from L and y\n\n    Parameters\n    ----------\n    L : pandas.DataFrame\n        Leontief input output table L\n    S : pandas.DataFrame\n        Direct impact coefficients\n    Y : pandas.DataFrame\n        Final demand: aggregated across categories or just one category, one\n        column per country\n    nr_sectors : int\n        Number of sectors in the MRIO\n\n\n    Returns\n    -------\n    Tuple\n        (D_cba, D_pba, D_imp, D_exp)\n\n        Format: D_row x L_col (=nr_countries*nr_sectors)\n\n        - D_cba        Footprint per sector and country\n        - D_pba      Total factur use per sector and country\n        - D_imp       Total global factor use to satisfy total final demand in\n                      the country per sector\n        - D_exp       Total factor use in one country to satisfy final demand\n                      in all other countries (per sector)\n    \"\"\"\n    # diagonalize each sector block per country\n    # this results in a disaggregated y with final demand per country per\n    # sector in one column\n    Y_diag = ioutil.diagonalize_blocks(Y.values, blocksize=nr_sectors)\n    x_diag = L.dot(Y_diag)\n    x_tot = x_diag.values.sum(1)\n    del Y_diag\n\n    D_cba = pd.DataFrame(S.values.dot(x_diag),\n                         index=S.index,\n                         columns=S.columns)\n    # D_pba = S.dot(np.diagflat(x_tot))\n    # faster broadcasted calculation:\n    D_pba = pd.DataFrame(S.values*x_tot.reshape((1, -1)),\n                         index=S.index,\n                         columns=S.columns)\n\n    # for the traded accounts set the domestic industry output to zero\n    dom_block = np.zeros((nr_sectors, nr_sectors))\n    x_trade = ioutil.set_block(x_diag.values, dom_block)\n    D_imp = pd.DataFrame(S.values.dot(x_trade),\n                         index=S.index,\n                         columns=S.columns)\n\n    x_exp = x_trade.sum(1)\n    # D_exp = S.dot(np.diagflat(x_exp))\n    # faster broadcasted version:\n    D_exp = pd.DataFrame(S.values * x_exp.reshape((1, -1)),\n                         index=S.index,\n                         columns=S.columns)\n\n    return (D_cba, D_pba, D_imp, D_exp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the url datafiles from the database", "response": "def _get_url_datafiles(url_db_view, url_db_content,\n                       mrio_regex, access_cookie=None):\n    \"\"\" Urls of mrio files by parsing url content for mrio_regex\n\n    Parameters\n    ----------\n\n    url_db_view: url str\n        Url which shows the list of mrios in the db\n\n    url_db_content: url str\n        Url which needs to be appended before the url parsed from the\n        url_db_view to get a valid download link\n\n    mrio_regex: regex str\n        Regex to parse the mrio datafile from url_db_view\n\n    access_cookie: dict, optional\n        If needed, cookie to access the database\n\n    Returns\n    -------\n    Named tuple:\n    .raw_text: content of url_db_view for later use\n    .data_urls: list of url\n\n    \"\"\"\n    # Use post here - NB: get could be necessary for some other pages\n    # but currently works for wiod and eora\n    returnvalue = namedtuple('url_content',\n                             ['raw_text', 'data_urls'])\n    url_text = requests.post(url_db_view, cookies=access_cookie).text\n    data_urls = [url_db_content + ff\n                 for ff in re.findall(mrio_regex, url_text)]\n    return returnvalue(raw_text=url_text, data_urls=data_urls)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndownloads a list of urls to the storage_folder", "response": "def _download_urls(url_list, storage_folder, overwrite_existing,\n                   meta_handler, access_cookie=None):\n    \"\"\" Save url from url_list to storage_folder\n\n    Parameters\n    ----------\n    url_list: list of str\n        Valid url to download\n\n    storage_folder: str, valid path\n        Location to store the download, folder will be created if\n        not existing. If the file is already present in the folder,\n        the download depends on the setting in 'overwrite_existing'.\n\n    overwrite_existing: boolean, optional\n        If False, skip download of file already existing in\n        the storage folder (default). Set to True to replace\n        files.\n\n    meta_handler: instance of MRIOMetaData\n\n    Returns\n    -------\n\n    The meta_handler is passed back\n\n    \"\"\"\n    for url in url_list:\n        filename = os.path.basename(url)\n        if not overwrite_existing and filename in os.listdir(storage_folder):\n            continue\n        storage_file = os.path.join(storage_folder, filename)\n\n        # Using requests here - tried with aiohttp but was actually slower\n        # Also don\u2019t use shutil.copyfileobj - corrupts zips from Eora\n        req = requests.post(url, stream=True, cookies=access_cookie)\n        with open(storage_file, 'wb') as lf:\n            for chunk in req.iter_content(1024*5):\n                lf.write(chunk)\n\n        meta_handler._add_fileio('Downloaded {} to {}'.format(url, filename))\n        meta_handler.save()\n\n    return meta_handler"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndownloading the 2013 wiod release and store it in the given storage folder.", "response": "def download_wiod2013(storage_folder, years=None, overwrite_existing=False,\n                      satellite_urls=WIOD_CONFIG['satellite_urls']):\n    \"\"\" Downloads the 2013 wiod release\n\n    Note\n    ----\n    Currently, pymrio only works with the 2013 release of the wiod tables. The\n    more recent 2016 release so far (October 2017) lacks the environmental and\n    social extensions.\n\n\n    Parameters\n    ----------\n    storage_folder: str, valid path\n        Location to store the download, folder will be created if\n        not existing. If the file is already present in the folder,\n        the download of the specific file will be skipped.\n\n\n    years: list of int or str, optional\n        If years is given only downloads the specific years. This\n        only applies to the IO tables because extensions are stored\n        by country and not per year.\n        The years can be given in 2 or 4 digits.\n\n    overwrite_existing: boolean, optional\n        If False, skip download of file already existing in\n        the storage folder (default). Set to True to replace\n        files.\n\n    satellite_urls : list of str (urls), optional\n        Which satellite accounts to download.  Default: satellite urls defined\n        in WIOD_CONFIG - list of all available urls Remove items from this list\n        to only download a subset of extensions\n\n    \"\"\"\n\n    try:\n        os.makedirs(storage_folder)\n    except FileExistsError:\n        pass\n\n    if type(years) is int or type(years) is str:\n        years = [years]\n    years = years if years else range(1995, 2012)\n    years = [str(yy).zfill(2)[-2:] for yy in years]\n\n    wiod_web_content = _get_url_datafiles(\n        url_db_view=WIOD_CONFIG['url_db_view'],\n        url_db_content=WIOD_CONFIG['url_db_content'],\n        mrio_regex='protected.*?wiot\\d\\d.*?xlsx')\n\n    restricted_wiod_io_urls = [url for url in wiod_web_content.data_urls if\n                               re.search(r\"(wiot)(\\d\\d)\",\n                                         os.path.basename(url)).group(2)\n                               in years]\n\n    meta = MRIOMetaData(location=storage_folder,\n                        description='WIOD metadata file for pymrio',\n                        name='WIOD',\n                        system='ixi',\n                        version='data13')\n\n    meta = _download_urls(url_list=restricted_wiod_io_urls + satellite_urls,\n                          storage_folder=storage_folder,\n                          overwrite_existing=overwrite_existing,\n                          meta_handler=meta)\n\n    meta.save()\n    return meta"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a timestamp of length in string", "response": "def get_timestamp(length):\n    \"\"\"Get a timestamp of `length` in string\"\"\"\n    s = '%.6f' % time.time()\n    whole, frac = map(int, s.split('.'))\n    res = '%d%d' % (whole, frac)\n    return res[:length]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef monkey_patch():\n    ozmq = __import__('zmq')\n    ozmq.Socket = zmq.Socket\n    ozmq.Context = zmq.Context\n    ozmq.Poller = zmq.Poller\n    ioloop = __import__('zmq.eventloop.ioloop')\n    ioloop.Poller = zmq.Poller", "response": "Monkey patches zmq. Context and zmq. Socket with zmq. Poller and zmq. EventLoop"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef concate_extension(*extensions, name):\n    if type(extensions[0]) is tuple or type(extensions[0]) is list:\n        extensions = extensions[0]\n\n    # check if fd extensions is present in one of the given extensions\n    FY_present = False\n    SY_present = False\n    SFY_columns = None\n    for ext in extensions:\n        if 'FY' in ext.get_DataFrame(data=False):\n            FY_present = True\n            SFY_columns = ext.FY.columns\n        if 'SY' in ext.get_DataFrame(data=False):\n            SY_present = True\n            SFY_columns = ext.SY.columns\n\n    # get the intersection of the available dataframes\n    set_dfs = [set(ext.get_DataFrame(data=False)) for ext in extensions]\n    df_dict = {key: None for key in set.intersection(*set_dfs)}\n    if FY_present:\n        df_dict['FY'] = None\n    if SY_present:\n        df_dict['SY'] = None\n    empty_df_dict = df_dict.copy()\n    attr_dict = {}\n\n    # get data from each extension\n    first_run = True\n    for ext in extensions:\n        # get corresponding attributes of all extensions\n        for key in ext.__dict__:\n            if type(ext.__dict__[key]) is not pd.DataFrame:\n                if attr_dict.get(key, -99) == -99:\n                    attr_dict[key] = ext.__dict__[key]\n                elif attr_dict[key] == ext.__dict__[key]:\n                    continue\n                else:\n                    attr_dict[key] = None\n\n        # get DataFrame data\n        cur_dict = empty_df_dict.copy()\n\n        for df in cur_dict:\n            cur_dict[df] = getattr(ext, df)\n\n        # add zero final demand extension if final demand extension present in\n        # one extension\n        if FY_present:\n            # doesn't work with getattr b/c FY can be present as attribute but\n            # not as DataFrame\n            if 'FY' in ext.get_DataFrame(data=False):\n                cur_dict['FY'] = getattr(ext, 'FY')\n            else:\n                cur_dict['FY'] = pd.DataFrame(data=0,\n                                              index=ext.get_index(),\n                                              columns=SFY_columns)\n        if SY_present:\n            # doesn't work with getattr b/c SY can be present as attribute but\n            # not as DataFrame\n            if 'SY' in ext.get_DataFrame(data=False):\n                cur_dict['SY'] = getattr(ext, 'SY')\n            else:\n                cur_dict['SY'] = pd.DataFrame(data=0,\n                                              index=ext.get_index(),\n                                              columns=SFY_columns)\n\n        # append all df data\n        for key in cur_dict:\n            if not first_run:\n                if cur_dict[key].index.names != df_dict[key].index.names:\n                    cur_ind_names = list(cur_dict[key].index.names)\n                    df_ind_names = list(df_dict[key].index.names)\n                    cur_ind_names[0] = 'indicator'\n                    df_ind_names[0] = cur_ind_names[0]\n                    cur_dict[key].index.set_names(cur_ind_names,\n                                                  inplace=True)\n                    df_dict[key].index.set_names(df_ind_names,\n                                                 inplace=True)\n\n                    for ind in cur_ind_names:\n                        if ind not in df_ind_names:\n                            df_dict[key] = (df_dict[key].\n                                            set_index(pd.DataFrame(\n                                                data=None,\n                                                index=df_dict[key].index,\n                                                columns=[ind])[ind],\n                                                append=True))\n                    for ind in df_ind_names:\n                        if ind not in cur_ind_names:\n                            cur_dict[key] = (cur_dict[key].set_index(\n                                                pd.DataFrame(\n                                                    data=None,\n                                                    index=cur_dict[key].index,\n                                                    columns=[ind])\n                                                [ind], append=True))\n\n            df_dict[key] = pd.concat([df_dict[key], cur_dict[key]])\n\n        first_run = False\n\n        all_dict = dict(list(attr_dict.items()) + list(df_dict.items()))\n        all_dict['name'] = name\n\n    return Extension(**all_dict)", "response": "Concatenate a list of extensions into a single list of new extensions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reset_to_flows(self, force=False, _meta=None):\n        # Development note: The attributes which should be removed are\n        # defined in self.__non_agg_attributes__\n        strwarn = None\n        for df in self.__basic__:\n            if (getattr(self, df)) is None:\n                if force:\n                    strwarn = (\"Reset system warning - Recalculation after \"\n                               \"reset not possible \"\n                               \"because {} missing\".format(df))\n                    warnings.warn(strwarn, ResetWarning)\n\n                else:\n                    raise ResetError(\"To few tables to recalculate the \"\n                                     \"system after reset ({} missing) \"\n                                     \"- reset can be forced by passing \"\n                                     \"'force=True')\".format(df))\n\n        if _meta:\n            _meta._add_modify(\"Reset to absolute flows\")\n            if strwarn:\n                _meta._add_modify(strwarn)\n\n        [setattr(self, key, None) for key in self.__non_agg_attributes__]\n        return self", "response": "Resets the internal object to absolute values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nresetting the coefficient attributes of the current object to the coefficient values of the current object.", "response": "def reset_to_coefficients(self):\n        \"\"\" Keeps only the coefficient.\n\n        This can be used to recalculate the IO tables for a new finald demand.\n\n        Note\n        -----\n\n        The system can not be reconstructed after this steps\n        because all absolute data is removed. Save the Y data in case\n        a reconstruction might be necessary.\n\n        \"\"\"\n        # Development note: The coefficient attributes are\n        # defined in self.__coefficients__\n        [setattr(self, key, None)\n         for key in self.get_DataFrame(\n             data=False,\n             with_unit=False,\n             with_population=False)\n         if key not in self.__coefficients__]\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a deep copy of the system", "response": "def copy(self, new_name=None):\n        \"\"\" Returns a deep copy of the system\n\n        Parameters\n        -----------\n\n        new_name: str, optional\n            Set a new meta name parameter.\n            Default: <old_name>_copy\n        \"\"\"\n        _tmp = copy.deepcopy(self)\n        if not new_name:\n            new_name = self.name + '_copy'\n        if str(type(self)) == \"<class 'pymrio.core.mriosystem.IOSystem'>\":\n            _tmp.meta.note('IOSystem copy {new} based on {old}'.format(\n                new=new_name, old=self.meta.name))\n            _tmp.meta.change_meta('name', new_name, log=False)\n        else:\n            _tmp.name = new_name\n        return _tmp"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning names of y cat. of the IOSystem as unique names in order is available.", "response": "def get_Y_categories(self, entries=None):\n        \"\"\" Returns names of y cat. of the IOSystem as unique names in order\n\n        Parameters\n        ----------\n        entries : List, optional\n            If given, retuns an list with None for all values not in entries.\n\n        Returns\n        -------\n        Index\n            List of categories, None if no attribute to determine\n            list is available\n        \"\"\"\n        possible_dataframes = ['Y', 'FY']\n\n        for df in possible_dataframes:\n            if (df in self.__dict__) and (getattr(self, df) is not None):\n                try:\n                    ind = getattr(self, df).columns.get_level_values(\n                        'category').unique()\n                except (AssertionError, KeyError):\n                    ind = getattr(self, df).columns.get_level_values(\n                        1).unique()\n                if entries:\n                    if type(entries) is str:\n                        entries = [entries]\n                    ind = ind.tolist()\n                    return [None if ee not in entries else ee for ee in ind]\n                else:\n                    return ind\n        else:\n            logging.warn(\"No attributes available to get Y categories\")\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_index(self, as_dict=False, grouping_pattern=None):\n\n        possible_dataframes = ['A', 'L', 'Z', 'Y', 'F', 'FY', 'M', 'S',\n                               'D_cba', 'D_pba',  'D_imp', 'D_exp',\n                               'D_cba_reg', 'D_pba_reg',\n                               'D_imp_reg', 'D_exp_reg',\n                               'D_cba_cap', 'D_pba_cap',\n                               'D_imp_cap', 'D_exp_cap', ]\n        for df in possible_dataframes:\n            if (df in self.__dict__) and (getattr(self, df) is not None):\n                orig_idx = getattr(self, df).index\n                break\n        else:\n            logging.warn(\"No attributes available to get index\")\n            return None\n\n        if as_dict:\n            dd = {k: k for k in orig_idx}\n            if grouping_pattern:\n                for pattern, new_group in grouping_pattern.items():\n                    if type(pattern) is str:\n                        dd.update({k: new_group for k, v in dd.items() if\n                                   re.match(pattern, k)})\n                    else:\n                        dd.update({k: new_group for k, v in dd.items() if\n                                   all([re.match(pat, k[nr])\n                                        for nr, pat in enumerate(pattern)])})\n            return dd\n\n        else:\n            return orig_idx", "response": "Returns the index of the dataframes in the system."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the pd dataframe index of all dataframes in the system to index", "response": "def set_index(self, index):\n        \"\"\" Sets the pd dataframe index of all dataframes in the system to index\n        \"\"\"\n        for df in self.get_DataFrame(data=True, with_population=False):\n            df.index = index"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a generator which yields all panda. DataFrames or there names of the DataFrames.", "response": "def get_DataFrame(self, data=False, with_unit=True, with_population=True):\n        \"\"\" Yields all panda.DataFrames or there names\n\n        Notes\n        -----\n        For IOSystem this does not include the DataFrames in the extensions.\n\n        Parameters\n        ----------\n        data : boolean, optional\n            If True, returns a generator which yields the DataFrames.\n            If False, returns a generator which\n            yields only the names of the DataFrames\n\n        with_unit: boolean, optional\n            If True, includes the 'unit' DataFrame\n            If False, does not include the 'unit' DataFrame.\n            The method than only yields the numerical data tables\n\n        with_population: boolean, optional\n            If True, includes the 'population' vector\n            If False, does not include the 'population' vector.\n\n        Returns\n        -------\n            DataFrames or string generator, depending on parameter data\n\n        \"\"\"\n\n        for key in self.__dict__:\n            if (key is 'unit') and not with_unit:\n                continue\n            if (key is 'population') and not with_population:\n                continue\n            if type(self.__dict__[key]) is pd.DataFrame:\n                if data:\n                    yield getattr(self, key)\n                else:\n                    yield key"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave the system to path.", "response": "def save(self, path, table_format='txt', sep='\\t',\n             table_ext=None, float_format='%.12g'):\n        \"\"\" Saving the system to path\n\n\n        Parameters\n        ----------\n        path : pathlib.Path or string\n            path for the saved data (will be created if necessary, data\n            within will be overwritten).\n\n        table_format : string\n            Format to save the DataFrames:\n\n                - 'pkl' : Binary pickle files,\n                          alias: 'pickle', 'bin', 'binary'\n                - 'txt' : Text files (default), alias: 'text', 'csv'\n\n        table_ext : string, optional\n            File extension,\n            default depends on table_format(.pkl for pickle, .txt for text)\n\n        sep : string, optional\n            Field delimiter for the output file, only for txt files.\n            Default: tab ('\\t')\n\n        float_format : string, optional\n            Format for saving the DataFrames,\n            default = '%.12g', only for txt files\n        \"\"\"\n\n        if type(path) is str:\n            path = path.rstrip('\\\\')\n            path = Path(path)\n\n        path.mkdir(parents=True, exist_ok=True)\n\n        para_file_path = path / DEFAULT_FILE_NAMES['filepara']\n        file_para = dict()\n        file_para['files'] = dict()\n\n        if table_format in ['text', 'csv', 'txt']:\n            table_format = 'txt'\n        elif table_format in ['pickle', 'bin', 'binary', 'pkl']:\n            table_format = 'pkl'\n        else:\n            raise ValueError('Unknown table format \"{}\" - '\n                             'must be \"txt\" or \"pkl\"'.format(table_format))\n            return None\n\n        if not table_ext:\n            if table_format == 'txt':\n                table_ext = '.txt'\n            if table_format == 'pkl':\n                table_ext = '.pkl'\n\n        if str(type(self)) == \"<class 'pymrio.core.mriosystem.IOSystem'>\":\n            file_para['systemtype'] = GENERIC_NAMES['iosys']\n        elif str(type(self)) == \"<class 'pymrio.core.mriosystem.Extension'>\":\n            file_para['systemtype'] = GENERIC_NAMES['ext']\n            file_para['name'] = self.name\n        else:\n            logging.warn('Unknown system type {} - set to \"undef\"'.format(\n                str(type(self))))\n            file_para['systemtype'] = 'undef'\n\n        for df, df_name in zip(self.get_DataFrame(data=True),\n                               self.get_DataFrame()):\n            if type(df.index) is pd.MultiIndex:\n                nr_index_col = len(df.index.levels)\n            else:\n                nr_index_col = 1\n\n            if type(df.columns) is pd.MultiIndex:\n                nr_header = len(df.columns.levels)\n            else:\n                nr_header = 1\n\n            save_file = df_name + table_ext\n            save_file_with_path = path / save_file\n            logging.info('Save file {}'.format(save_file_with_path))\n            if table_format == 'txt':\n                df.to_csv(save_file_with_path, sep=sep,\n                          float_format=float_format)\n            else:\n                df.to_pickle(save_file_with_path)\n\n            file_para['files'][df_name] = dict()\n            file_para['files'][df_name]['name'] = save_file\n            file_para['files'][df_name]['nr_index_col'] = str(nr_index_col)\n            file_para['files'][df_name]['nr_header'] = str(nr_header)\n\n        with para_file_path.open(mode='w') as pf:\n            json.dump(file_para, pf, indent=4)\n\n        if file_para['systemtype'] == GENERIC_NAMES['iosys']:\n            if not self.meta:\n                self.meta = MRIOMetaData(name=self.name,\n                                         location=path)\n\n            self.meta._add_fileio(\"Saved {} to {}\".format(self.name, path))\n            self.meta.save(location=path)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets new names for the regions in the current object", "response": "def rename_regions(self, regions):\n        \"\"\" Sets new names for the regions\n\n        Parameters\n        ----------\n        regions : list or dict\n            In case of dict: {'old_name' :  'new_name'} with a\n                entry for each old_name which should be renamed\n            In case of list: List of new names in order and complete\n                without repetition\n\n        \"\"\"\n\n        if type(regions) is list:\n            regions = {old: new for old, new in\n                       zip(self.get_regions(), regions)}\n\n        for df in self.get_DataFrame(data=True):\n            df.rename(index=regions, columns=regions, inplace=True)\n\n        try:\n            for ext in self.get_extensions(data=True):\n                for df in ext.get_DataFrame(data=True):\n                    df.rename(index=regions, columns=regions, inplace=True)\n        except:\n            pass\n\n        self.meta._add_modify(\"Changed country names\")\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rename_sectors(self, sectors):\n\n        if type(sectors) is list:\n            sectors = {old: new for old, new in\n                       zip(self.get_sectors(), sectors)}\n\n        for df in self.get_DataFrame(data=True):\n            df.rename(index=sectors, columns=sectors, inplace=True)\n\n        try:\n            for ext in self.get_extensions(data=True):\n                for df in ext.get_DataFrame(data=True):\n                    df.rename(index=sectors, columns=sectors, inplace=True)\n        except:\n            pass\n        self.meta._add_modify(\"Changed sector names\")\n        return self", "response": "Sets new names for the sectors in the current instance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rename_Y_categories(self, Y_categories):\n\n        if type(Y_categories) is list:\n            Y_categories = {old: new for old, new in\n                            zip(self.get_Y_categories(), Y_categories)}\n\n        for df in self.get_DataFrame(data=True):\n            df.rename(index=Y_categories, columns=Y_categories, inplace=True)\n\n        try:\n            for ext in self.get_extensions(data=True):\n                for df in ext.get_DataFrame(data=True):\n                    df.rename(index=Y_categories,\n                              columns=Y_categories,\n                              inplace=True)\n        except:\n            pass\n\n        self.meta._add_modify(\"Changed Y category names\")\n        return self", "response": "Sets new names for the Y_categories column in the DataFrame and all extensions."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calc_system(self, x, Y, Y_agg=None, L=None, population=None):\n\n        if Y_agg is None:\n            try:\n                Y_agg = Y.sum(level='region',\n                              axis=1).reindex(self.get_regions(),\n                                              axis=1)\n\n            except (AssertionError, KeyError):\n                Y_agg = Y.sum(level=0,\n                              axis=1,).reindex(self.get_regions(),\n                                               axis=1)\n\n        y_vec = Y.sum(axis=0)\n\n        if self.F is None:\n            self.F = calc_F(self.S, x)\n            logging.debug(\n                '{} - F calculated'.format(self.name))\n\n        if self.S is None:\n            self.S = calc_S(self.F, x)\n            logging.debug('{} - S calculated'.format(self.name))\n\n        if (self.FY is None) and (self.SY is not None):\n            self.FY = calc_FY(self.SY, y_vec)\n            logging.debug('{} - FY calculated'.format(self.name))\n\n        if (self.SY is None) and (self.FY is not None):\n            self.SY = calc_SY(self.FY, y_vec)\n            logging.debug('{} - SY calculated'.format(self.name))\n\n        if self.M is None:\n            if L is not None:\n                self.M = calc_M(self.S, L)\n                logging.debug('{} - M calculated based on L'.format(\n                    self.name))\n            else:\n                try:\n                    self.M = recalc_M(self.S, self.D_cba,\n                                      Y=Y_agg,\n                                      nr_sectors=self.get_sectors().size)\n                    logging.debug(\n                        '{} - M calculated based on '\n                        'D_cba and Y'.format(self.name))\n                except Exception as ex:\n                    logging.debug(\n                            'Recalculation of M not possible - cause: {}'.\n                            format(ex))\n\n        FY_agg = 0\n        if self.FY is not None:\n            # FY_agg = ioutil.agg_columns(\n            # ext['FY'], self.get_Y_categories().size)\n            try:\n                FY_agg = (self.FY.sum(level='region', axis=1).\n                          reindex(self.get_regions(), axis=1))\n            except (AssertionError, KeyError):\n                FY_agg = (self.FY.sum(level=0, axis=1).\n                          reindex(self.get_regions(), axis=1))\n\n        if ((self.D_cba is None) or\n                (self.D_pba is None) or\n                (self.D_imp is None) or\n                (self.D_exp is None)):\n            if L is None:\n                logging.debug(\n                    'Not possilbe to calculate D accounts - L not present')\n                return\n            else:\n                self.D_cba, self.D_pba, self.D_imp, self.D_exp = (\n                    calc_accounts(self.S, L, Y_agg, self.get_sectors().size))\n                logging.debug(\n                    '{} - Accounts D calculated'.format(self.name))\n\n        # aggregate to country\n        if ((self.D_cba_reg is None) or (self.D_pba_reg is None) or\n                (self.D_imp_reg is None) or (self.D_exp_reg is None)):\n            try:\n                self.D_cba_reg = (\n                        self.D_cba.sum(level='region', axis=1).\n                        reindex(self.get_regions(), axis=1) + FY_agg)\n            except (AssertionError, KeyError):\n                self.D_cba_reg = (\n                        self.D_cba.sum(level=0, axis=1).\n                        reindex(self.get_regions(), axis=1) + FY_agg)\n            try:\n                self.D_pba_reg = (\n                        self.D_pba.sum(level='region', axis=1).\n                        reindex(self.get_regions(), axis=1) + FY_agg)\n            except (AssertionError, KeyError):\n                self.D_pba_reg = (\n                        self.D_pba.sum(level=0, axis=1).\n                        reindex(self.get_regions(), axis=1) + FY_agg)\n            try:\n                self.D_imp_reg = (\n                        self.D_imp.sum(level='region', axis=1).\n                        reindex(self.get_regions(), axis=1))\n            except (AssertionError, KeyError):\n                self.D_imp_reg = (\n                        self.D_imp.sum(level=0, axis=1).\n                        reindex(self.get_regions(), axis=1))\n            try:\n                self.D_exp_reg = (\n                        self.D_exp.sum(level='region', axis=1).\n                        reindex(self.get_regions(), axis=1))\n            except (AssertionError, KeyError):\n                self.D_exp_reg = (\n                        self.D_exp.sum(level=0, axis=1).\n                        reindex(self.get_regions(), axis=1))\n\n            logging.debug(\n                '{} - Accounts D for regions calculated'.format(self.name))\n\n        # calc accounts per capita if population data is available\n        if population is not None:\n            if type(population) is pd.DataFrame:\n                # check for right order:\n                if (population.columns.tolist() !=\n                        self.D_cba_reg.columns.tolist()):\n                    logging.warning(\n                        'Population regions are inconsistent with IO regions')\n                population = population.values\n\n            if ((self.D_cba_cap is None) or (self.D_pba_cap is None) or\n                    (self.D_imp_cap is None) or (self.D_exp_cap is None)):\n                self.D_cba_cap = self.D_cba_reg.dot(\n                        np.diagflat(1./population))\n                self.D_pba_cap = self.D_pba_reg.dot(\n                        np.diagflat(1./population))\n                self.D_imp_cap = self.D_imp_reg.dot(\n                        np.diagflat(1./population))\n                self.D_exp_cap = self.D_exp_reg.dot(\n                        np.diagflat(1./population))\n\n                self.D_cba_cap.columns = self.D_cba_reg.columns\n                self.D_pba_cap.columns = self.D_pba_reg.columns\n                self.D_imp_cap.columns = self.D_imp_reg.columns\n                self.D_exp_cap.columns = self.D_exp_reg.columns\n\n                logging.debug(\n                    '{} - Accounts D per capita calculated'.format(self.name))\n        return self", "response": "Calculates the missing part of the extension plus accounts"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot_account(self, row, per_capita=False, sector=None,\n                     file_name=False, file_dpi=600,\n                     population=None, **kwargs):\n        \"\"\" Plots D_pba, D_cba, D_imp and D_exp for the specified row (account)\n\n        Plot either the total country accounts or for a specific sector,\n        depending on the 'sector' parameter.\n\n        Per default the accounts are plotted as bar charts.\n        However, any valid keyword for the pandas.DataFrame.plot\n        method can be passed.\n\n        Notes\n        -----\n            This looks prettier with the seaborn module\n            (import seaborn before calling this method)\n\n        Parameters\n        ----------\n        row : string, tuple or int\n            A valid index for the row in the extension which\n            should be plotted (one(!) row - no list allowed)\n        per_capita : boolean, optional\n            Plot the per capita accounts instead of the absolute values\n            default is False\n        sector: string, optional\n            Plot the results for a specific sector of the IO table. If\n            None is given (default), the total regional accounts are plotted.\n        population : pandas.DataFrame or np.array, optional\n            Vector with population per region. This must be given if\n            values should be plotted per_capita for a specific sector since\n            these values are calculated on the fly.\n        file_name : path string, optional\n            If given, saves the plot to the given filename\n        file_dpi : int, optional\n            Dpi for saving the figure, default 600\n\n        **kwargs : key word arguments, optional\n            This will be passed directly to the pd.DataFrame.plot method\n\n        Returns\n        -------\n        Axis as given by pandas.DataFrame.plot, None in case of errors\n\n        \"\"\"\n        # necessary if row is given for Multiindex without brackets\n        if type(per_capita) is not bool:\n            logging.error('per_capita parameter must be boolean')\n            return None\n\n        if type(row) is int:\n            row = self.D_cba.ix[row].name\n\n        name_row = (str(row).\n                    replace('(', '').\n                    replace(')', '').\n                    replace(\"'\", \"\").\n                    replace('[', '').\n                    replace(']', ''))\n        if sector:\n            graph_name = name_row + ' for sector ' + sector\n        else:\n            graph_name = name_row + ' total account'\n        if per_capita:\n            graph_name = graph_name + ' - per capita'\n\n        graph_name = self.name + ' - ' + graph_name\n\n        if self.unit is not None:\n            try:\n                # for multiindex the entry is given with header,\n                # for single index just the entry\n                y_label_name = (name_row +\n                                ' (' +\n                                str(self.unit.ix[row, 'unit'].tolist()[0]) +\n                                ')')\n            except:\n                y_label_name = (name_row + ' (' +\n                                str(self.unit.ix[row, 'unit']) + ')')\n        else:\n            y_label_name = name_row\n\n        if 'kind' not in kwargs:\n            kwargs['kind'] = 'bar'\n\n        if 'colormap' not in kwargs:\n            kwargs['colormap'] = 'Spectral'\n\n        accounts = collections.OrderedDict()\n\n        if sector:\n            accounts['Footprint'] = 'D_cba'\n            accounts['Territorial'] = 'D_pba'\n            accounts['Imports'] = 'D_imp'\n            accounts['Exports'] = 'D_exp'\n        else:\n            if per_capita:\n                accounts['Footprint'] = 'D_cba_cap'\n                accounts['Territorial'] = 'D_pba_cap'\n                accounts['Imports'] = 'D_imp_cap'\n                accounts['Exports'] = 'D_exp_cap'\n            else:\n                accounts['Footprint'] = 'D_cba_reg'\n                accounts['Territorial'] = 'D_pba_reg'\n                accounts['Imports'] = 'D_imp_reg'\n                accounts['Exports'] = 'D_exp_reg'\n\n        data_row = pd.DataFrame(columns=[key for key in accounts])\n        for key in accounts:\n            if sector:\n                try:\n                    _data = pd.DataFrame(\n                             getattr(self, accounts[key]).xs(\n                                 key=sector, axis=1, level='sector').ix[row].T)\n                except (AssertionError, KeyError):\n                    _data = pd.DataFrame(\n                             getattr(self, accounts[key]).xs(\n                                 key=sector, axis=1, level=1).ix[row].T)\n\n                if per_capita:\n                    if population is not None:\n                        if type(population) is pd.DataFrame:\n                            # check for right order:\n                            if (population.columns.tolist() !=\n                                    self.D_cba_reg.columns.tolist()):\n                                logging.warning(\n                                    'Population regions are inconsistent '\n                                    'with IO regions')\n                            population = population.values\n                            population = population.reshape((-1, 1))\n                            _data = _data / population\n                    else:\n                        logging.error('Population must be given for sector '\n                                      'results per capita')\n                        return\n            else:\n                _data = pd.DataFrame(getattr(self, accounts[key]).ix[row].T)\n            _data.columns = [key]\n            data_row[key] = _data[key]\n\n        if 'title' not in kwargs:\n            kwargs['title'] = graph_name\n\n        ax = data_row.plot(**kwargs)\n        plt.xlabel('Regions')\n        plt.ylabel(y_label_name)\n        plt.legend(loc='best')\n        try:\n            plt.tight_layout()\n        except:\n            pass\n\n        if file_name:\n            plt.savefig(file_name, dpi=file_dpi)\n        return ax", "response": "Plots the total country accounts for the specified account."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef report_accounts(self, path, per_region=True, per_capita=False,\n                        pic_size=1000, format='rst', ffname=None,  **kwargs):\n        \"\"\" Writes a report to the given path for the regional accounts\n\n        The report consists of a text file and a folder with the pics\n        (both names following parameter name)\n\n        Notes\n        ----\n            This looks prettier with the seaborn module\n            (import seaborn before calling this method)\n\n\n        Parameters\n        ----------\n        path : pathlib.Path or string\n            Root path for the report\n        per_region : boolean, optional\n            If true, reports the accounts per region\n        per_capita : boolean, optional\n            If true, reports the accounts per capita\n            If per_capita and per_region are False, nothing will be done\n        pic_size : int, optional\n            size for the figures in px, 1000 by default\n        format : string, optional\n            file format of the report:\n            'rst'(default), 'html', 'latex', ...\n            except for rst all depend on the module docutils (all writer_name\n            from docutils can be used as format)\n        ffname : string, optional\n            root file name (without extension, per_capita or per_region will be\n            attached) and folder names If None gets passed (default), self.name\n            with be modified to get a valid name for the operation system\n            without blanks\n        **kwargs : key word arguments, optional\n            This will be passed directly to the pd.DataFrame.plot method\n            (through the self.plot_account method)\n\n        \"\"\"\n\n        if not per_region and not per_capita:\n            return\n\n        _plt = plt.isinteractive()\n        _rcParams = mpl.rcParams.copy()\n        rcParams = {\n            'figure.figsize': (10, 5),\n            'figure.dpi': 350,\n            'axes.titlesize': 20,\n            'axes.labelsize': 20,\n        }\n        plt.ioff()\n\n        if type(path) is str:\n            path = path.rstrip('\\\\')\n            path = Path(path)\n\n        path.mkdir(parents=True, exist_ok=True)\n\n        if ffname is None:\n            valid_char = string.ascii_letters + string.digits + '_'\n            ffname = self.name.replace(' ', '_')\n            ffname = \"\".join([r for r in ffname if r in valid_char])\n\n        rep_spec = collections.namedtuple('rep_spec',\n                                          ['make',\n                                           'spec_string',\n                                           'is_per_capita'])\n\n        reports_to_write = {'per region accounts': rep_spec(\n            per_region, '_per_region', False),\n                            'per capita accounts': rep_spec(\n            per_capita, '_per_capita', True)}\n        logging.info('Write report for {}'.format(self.name))\n        fig_name_list = []\n        for arep in reports_to_write:\n            if not reports_to_write[arep].make:\n                continue\n\n            report_txt = []\n            report_txt.append('###########')\n            report_txt.append('MRIO report')\n            report_txt.append('###########')\n            report_txt.append('\\n')\n            _ext = 'Extension: ' + self.name + ' - ' + str(arep)\n            report_txt.append(_ext)\n            report_txt.append('='*len(_ext))\n\n            report_txt.append('.. contents::\\n\\n')\n\n            curr_ffname = ffname + reports_to_write[arep].spec_string\n            subfolder = path / curr_ffname\n\n            subfolder.mkdir(parents=True, exist_ok=True)\n\n            for row in self.get_rows():\n                name_row = (str(row).\n                            replace('(', '').\n                            replace(')', '').\n                            replace(\"'\", \"\").\n                            replace(' ', '_').\n                            replace(', ', '_').\n                            replace('__', '_'))\n                graph_name = (self.name + ' - ' + str(row).\n                              replace('(', '').\n                              replace(')', '').\n                              replace(\"'\", \"\"))\n\n                # get valid file name\n                def clean(varStr):\n                    return re.sub('\\W|^(?=\\d)', '_', varStr)\n                file_name = (clean(name_row +\n                                   reports_to_write[arep].spec_string))\n                # possibility of still having __ in there:\n                file_name = re.sub('_+', '_', file_name)\n\n                # restrict file length\n                file_name = file_name[:50]\n\n                def file_name_nr(a, c):\n                    return a + '_' + str(c)\n                _loopco = 0\n                while file_name_nr(file_name, _loopco) in fig_name_list:\n                    _loopco += 1\n                file_name = file_name_nr(file_name, _loopco)\n                fig_name_list.append(file_name)\n                file_name = file_name + '.png'\n\n                file_name = subfolder / file_name\n                file_name_rel = file_name.relative_to(path)\n\n                self.plot_account(row, file_name=file_name,\n                                  per_capita=reports_to_write[arep].\n                                  is_per_capita, **kwargs)\n                plt.close()\n\n                report_txt.append(graph_name)\n                report_txt.append('-'*len(graph_name) + '\\n\\n')\n\n                report_txt.append('.. image:: ' + file_name_rel)\n                report_txt.append('   :width: {} \\n'.format(int(pic_size)))\n\n            # write report file and convert to given format\n            report_txt.append('\\nReport written on ' +\n                              time.strftime(\"%Y%m%d %H%M%S\"))\n            fin_txt = '\\n'.join(report_txt)\n            if format is not 'rst':\n                try:\n                    import docutils.core as dc\n                    if format == 'tex':\n                        format == 'latex'\n                    fin_txt = dc.publish_string(\n                        fin_txt, writer_name=format,\n                        settings_overrides={'output_encoding': 'unicode'})\n                except:\n                    logging.warn(\n                        'Module docutils not available - write rst instead')\n                    format = 'rst'\n            format_str = {'latex': 'tex',\n                          'tex': 'tex',\n                          'rst': 'txt',\n                          'txt': 'txt',\n                          'html': 'html'}\n            _repfile = curr_ffname + '.' + format_str.get(format, str(format))\n            with open(path / _repfile, 'w') as out_file:\n                out_file.write(fin_txt)\n            logging.info('Report for {what} written to {file_where}'.\n                         format(what=arep, file_where=str(_repfile)))\n\n        # restore plot status\n        mpl.rcParams.update(_rcParams)\n        if _plt:\n            plt.ion()", "response": "Writes a report of the regional accounts for the given path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_rows(self):\n        possible_dataframes = ['F', 'FY', 'M', 'S',\n                               'D_cba', 'D_pba',  'D_imp', 'D_exp',\n                               'D_cba_reg', 'D_pba_reg',\n                               'D_imp_reg', 'D_exp_reg',\n                               'D_cba_cap', 'D_pba_cap',\n                               'D_imp_cap', 'D_exp_cap', ]\n        for df in possible_dataframes:\n            if (df in self.__dict__) and (getattr(self, df) is not None):\n                return getattr(self, df).index.get_values()\n        else:\n            logging.warn(\"No attributes available to get row names\")\n            return None", "response": "Returns the names of the rows of the extension"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dict with all available data for a specific row in the extension", "response": "def get_row_data(self, row, name=None):\n        \"\"\" Returns a dict with all available data for a row in the extension\n\n        Parameters\n        ----------\n        row : tuple, list, string\n            A valid index for the extension DataFrames\n        name : string, optional\n            If given, adds a key 'name' with the given value to the dict. In\n            that case the dict can be\n            used directly to build a new extension.\n\n        Returns\n        -------\n        dict object with the data (pandas DataFrame)for the specific rows\n        \"\"\"\n        retdict = {}\n        for rowname, data in zip(self.get_DataFrame(),\n                                 self.get_DataFrame(data=True)):\n            retdict[rowname] = pd.DataFrame(data.ix[row])\n        if name:\n            retdict['name'] = name\n        return retdict"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the missing part of the core IOSystem.", "response": "def calc_system(self):\n        \"\"\"\n        Calculates the missing part of the core IOSystem\n\n        The method checks Z, x, A, L and calculates all which are None\n        \"\"\"\n\n        # Possible cases:\n        # 1) Z given, rest can be None and calculated\n        # 2) A and x given, rest can be calculated\n        # 3) A and Y , calc L (if not given) - calc x and the rest\n\n        # this catches case 3\n        if self.x is None and self.Z is None:\n            # in that case we need L or at least A to calculate it\n            if self.L is None:\n                self.L = calc_L(self.A)\n                logging.info('Leontief matrix L calculated')\n            self.x = calc_x_from_L(self.L, self.Y.sum(axis=1))\n            self.meta._add_modify('Industry Output x calculated')\n\n        # this chains of ifs catch cases 1 and 2\n        if self.Z is None:\n            self.Z = calc_Z(self.A, self.x)\n            self.meta._add_modify('Flow matrix Z calculated')\n\n        if self.x is None:\n            self.x = calc_x(self.Z, self.Y)\n            self.meta._add_modify('Industry output x calculated')\n\n        if self.A is None:\n                self.A = calc_A(self.Z, self.x)\n                self.meta._add_modify('Coefficient matrix A calculated')\n\n        if self.L is None:\n                self.L = calc_L(self.A)\n                self.meta._add_modify('Leontief matrix L calculated')\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the extension and their accounts for each extension.", "response": "def calc_extensions(self, extensions=None, Y_agg=None):\n        \"\"\" Calculates the extension and their accounts\n\n        For the calculation, y is aggregated across specified y categories\n        The method calls .calc_system of each extension (or these given in the\n        extensions parameter)\n\n        Parameters\n        ----------\n        extensions : list of strings, optional\n            A list of key names of extensions which shall be calculated.\n            Default: all dictionaries of IOSystem are assumed to be extensions\n        Y_agg : pandas.DataFrame or np.array, optional\n            The final demand aggregated (one category per country).  Can be\n            used to restrict the calculation of CBA of a specific category\n            (e.g. households). Default: y is aggregated over all categories\n        \"\"\"\n\n        ext_list = list(self.get_extensions(data=False))\n        extensions = extensions or ext_list\n        if type(extensions) == str:\n            extensions = [extensions]\n\n        for ext_name in extensions:\n            self.meta._add_modify(\n                'Calculating accounts for extension {}'.format(ext_name))\n            ext = getattr(self, ext_name)\n            ext.calc_system(x=self.x,\n                            Y=self.Y,\n                            L=self.L,\n                            Y_agg=Y_agg,\n                            population=self.population\n                            )\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef report_accounts(self, path, per_region=True,\n                        per_capita=False, pic_size=1000,\n                        format='rst', **kwargs):\n        \"\"\" Generates a report to the given path for all extension\n\n        This method calls .report_accounts for all extensions\n\n        Notes\n        -----\n            This looks prettier with the seaborn module (import seaborn before\n            calling this method)\n\n        Parameters\n        ----------\n        path : string\n            Root path for the report\n        per_region : boolean, optional\n            If true, reports the accounts per region\n        per_capita : boolean, optional\n            If true, reports the accounts per capita\n            If per_capita and per_region are False, nothing will be done\n        pic_size : int, optional\n            size for the figures in px, 1000 by default\n        format : string, optional\n            file format of the report:\n            'rst'(default), 'html', 'latex', ...\n            except for rst all depend on the module docutils (all writer_name\n            from docutils can be used as format)\n        ffname : string, optional\n            root file name (without extension, per_capita or per_region will be\n            attached) and folder names If None gets passed (default), self.name\n            with be modified to get a valid name for the operation system\n            without blanks\n        **kwargs : key word arguments, optional\n            This will be passed directly to the pd.DataFrame.plot method\n            (through the self.plot_account method)\n\n        \"\"\"\n\n        for ext in self.get_extensions(data=True):\n            ext.report_accounts(path=path,\n                                per_region=per_region,\n                                per_capita=per_capita,\n                                pic_size=pic_size,\n                                format=format,\n                                **kwargs)", "response": "Generates a report for all the key word accounts in the given path for all extensions and the given format."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_extensions(self, data=False):\n\n        ext_list = [key for key in\n                    self.__dict__ if type(self.__dict__[key]) is Extension]\n        for key in ext_list:\n            if data:\n                yield getattr(self, key)\n            else:\n                yield key", "response": "Yields the extensions or their names"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresetting all accounts that can be recalculated for all extensions and core system and all extension.", "response": "def reset_all_full(self, force=False):\n        \"\"\" Removes all accounts that can be recalculated (IOSystem and extensions)\n\n        This calls reset_full for the core system and all extension.\n\n        Parameters\n        ----------\n\n        force: boolean, optional\n            If True, reset to flows although the system can not be\n            recalculated. Default: False\n\n        \"\"\"\n        self.reset_full()\n        [ee.reset_full() for ee in self.get_extensions(data=True)]\n        self.meta._add_modify(\"Reset all calculated data\")\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reset_to_flows(self, force=False):\n        super().reset_to_flows(force=force, _meta=self.meta)\n        return self", "response": "Resets all the absolute values of the internal data structures to flows."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reset_all_to_flows(self, force=False):\n        self.reset_to_flows(force=force)\n        [ee.reset_to_flows(force=force)\n         for ee in self.get_extensions(data=True)]\n        self.meta._add_modify(\"Reset full system to absolute flows\")\n        return self", "response": "Resets the IOSystem and all extensions to absolute flows"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset_all_to_coefficients(self):\n        self.reset_to_coefficients()\n        [ee.reset_to_coefficients() for ee in self.get_extensions(data=True)]\n        self.meta._add_modify(\"Reset full system to coefficients\")\n        return self", "response": "Resets all IOSystem and all extensions to coefficients."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving the system and all extensions in a separate folder.", "response": "def save_all(self, path, table_format='txt', sep='\\t',\n                 table_ext=None, float_format='%.12g'):\n        \"\"\" Saves the system and all extensions\n\n        Extensions are saved in separate folders (names based on extension)\n\n        Parameters are passed to the .save methods of the IOSystem and\n        Extensions. See parameters description there.\n        \"\"\"\n\n        if type(path) is str:\n            path = path.rstrip('\\\\')\n            path = Path(path)\n\n        path.mkdir(parents=True, exist_ok=True)\n\n        self.save(path=path,\n                  table_format=table_format,\n                  sep=sep,\n                  table_ext=table_ext,\n                  float_format=float_format)\n\n        for ext, ext_name in zip(self.get_extensions(data=True),\n                                 self.get_extensions()):\n            ext_path = path / ext_name\n\n            ext.save(path=ext_path,\n                     table_format=table_format,\n                     sep=sep,\n                     table_ext=table_ext,\n                     float_format=float_format)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naggregate the IO system.", "response": "def aggregate(self, region_agg=None, sector_agg=None,\n                  region_names=None, sector_names=None,\n                  inplace=True, pre_aggregation=False):\n        \"\"\" Aggregates the IO system.\n\n            Aggregation can be given as vector (use pymrio.build_agg_vec) or\n            aggregation matrix. In the case of a vector this must be of length\n            self.get_regions() / self.get_sectors() respectively with the new\n            position as integer or a string of the new name. In the case of\n            strings the final output order can be specified in region_dict and\n            sector_dict in the format {str1 = int_pos, str2 = int_pos, ...}.\n\n            If the sector / region concordance is given as matrix or numerical\n            vector, generic names will be used for the new sectors/regions. One\n            can define specific names by defining the aggregation as string\n            vector\n\n            Parameters\n            ----------\n            region_agg : list, array or string, optional\n                The aggregation vector or matrix for the regions (np.ndarray or\n                list). If string: aggregates to one total region and names is\n                to the given string.\n                Pandas Dataframe with columns 'orignal' and 'aggregated'.\n                This is the output from the country_converter.agg_conc\n            sector_agg : list, arrays or string, optional\n                The aggregation vector or matrix for the sectors (np.ndarray or\n                list).If string: aggregates to one total region and names is\n                to the given string.\n            region_names : list, optional\n                Names for the aggregated regions.\n                If concordance matrix - in order of rows in this matrix\n                If concordance vector - in order or num. values in this vector\n                If string based - same order as the passed string\n                Not considered if passing a DataFrame - in this case give the\n                names in the column 'aggregated'\n\n            sector_names : list, optional\n                Names for the aggregated sectors. Same behaviour as\n                'region_names'\n\n            inplace : boolean, optional\n                If True, aggregates the IOSystem in place (default),\n                otherwise aggregation happens on a copy of the IOSystem.\n                Regardless of the setting, the IOSystem is returned to\n                allow for chained operations.\n\n            Returns\n            -------\n            IOSystem\n                Aggregated IOSystem (if inplace is False)\n\n        \"\"\"\n        # Development note: This can not be put in the CoreSystem b/c\n        # than the recalculation of the extension coefficients would not\n        # work.\n\n        if not inplace:\n            self = self.copy()\n\n        try:\n            self.reset_to_flows()\n        except ResetError:\n            raise AggregationError(\"System under-defined for aggregation - \"\n                                   \"do a 'calc_all' before aggregation\")\n\n        if type(region_names) is str:\n            region_names = [region_names]\n        if type(sector_names) is str:\n            sector_names = [sector_names]\n\n        if type(region_agg) is pd.DataFrame:\n            if (('original' not in region_agg.columns) or\n                    ('aggregated' not in region_agg.columns)):\n                raise ValueError('Passed DataFrame must include the columns '\n                                 '\"original\" and \"aggregated\"')\n            region_agg = (region_agg\n                          .set_index('original')\n                          .reindex(self.get_regions(),\n                                   fill_value=MISSING_AGG_ENTRY['region'])\n                          .loc[:, 'aggregated'])\n\n        if type(sector_agg) is pd.DataFrame:\n            if (('original' not in sector_agg.columns) or\n                    ('aggregated' not in sector_agg.columns)):\n                raise ValueError('Passed DataFrame must include the columns '\n                                 '\"original\" and \"aggregated\"')\n            sector_agg = (sector_agg\n                          .set_index('original')\n                          .reindex(self.get_sectors(),\n                                   fill_value=MISSING_AGG_ENTRY['sector'])\n                          .loc[:, 'aggregated'])\n\n        # fill the aggregation matrix with 1:1 mapping\n        # if input not given and get names if not given\n        _same_regions = False\n        _same_sectors = False\n        if region_agg is None:\n            region_agg = self.get_regions()\n            region_names = region_names or self.get_regions()\n            _same_regions = True\n        if sector_agg is None:\n            sector_agg = self.get_sectors()\n            sector_names = sector_names or self.get_sectors()\n            _same_sectors = True\n\n        # capture total aggregation case\n        if type(region_agg) is str:\n            region_agg = [region_agg] * len(self.get_regions())\n        if type(sector_agg) is str:\n            sector_agg = [sector_agg] * len(self.get_sectors())\n\n        if ioutil.is_vector(region_agg):\n            region_conc = ioutil.build_agg_matrix(region_agg)\n        else:\n            region_conc = region_agg\n        if ioutil.is_vector(sector_agg):\n            sector_conc = ioutil.build_agg_matrix(sector_agg)\n        else:\n            sector_conc = sector_agg\n\n        # build the new names\n        if (not _same_regions) and (not region_names):\n                if isinstance(region_agg, np.ndarray):\n                    region_agg = region_agg.flatten().tolist()\n                if type(region_agg[0]) is str:\n                    region_names = ioutil.unique_element(region_agg)\n                else:\n                    # rows in the concordance matrix give the new number of\n                    # regions\n                    region_names = [GENERIC_NAMES['region'] +\n                                    str(nr) for nr in\n                                    range(region_conc.shape[0])]\n\n        if (not _same_sectors) and (not sector_names):\n                if isinstance(sector_agg, np.ndarray):\n                    sector_agg = (sector_agg.flatten().tolist())\n                if type(sector_agg[0]) is str:\n                    sector_names = ioutil.unique_element(sector_agg)\n                else:\n                    sector_names = [GENERIC_NAMES['sector'] +\n                                    str(nr) for nr in\n                                    range(sector_conc.shape[0])]\n\n        # Assert right shapes\n        if not sector_conc.shape[1] == len(self.get_sectors()):\n            raise ValueError('Sector aggregation does not '\n                             'correspond to the number of sectors.')\n        if not region_conc.shape[1] == len(self.get_regions()):\n            raise ValueError('Region aggregation does not '\n                             'correspond to the number of regions.')\n        if not len(sector_names) == sector_conc.shape[0]:\n            raise ValueError('New sector names do not '\n                             'match sector aggregation.')\n        if not len(region_names) == region_conc.shape[0]:\n            raise ValueError('New region names do not '\n                             'match region aggregation.')\n\n        # build pandas.MultiIndex for the aggregated system\n        _reg_list_for_sec = [[r] * sector_conc.shape[0] for r in region_names]\n        _reg_list_for_sec = [entry for entrylist in\n                             _reg_list_for_sec for entry in entrylist]\n\n        _reg_list_for_Ycat = [[r] * len(self.get_Y_categories()) for r in\n                              region_names]\n        _reg_list_for_Ycat = [entry for entrylist in\n                              _reg_list_for_Ycat for entry in entrylist]\n\n        _sec_list = list(sector_names) * region_conc.shape[0]\n        _Ycat_list = list(self.get_Y_categories()) * region_conc.shape[0]\n\n        mi_reg_sec = pd.MultiIndex.from_arrays(\n                [_reg_list_for_sec, _sec_list],\n                names=['region', 'sector'])\n        mi_reg_Ycat = pd.MultiIndex.from_arrays(\n                [_reg_list_for_Ycat, _Ycat_list],\n                names=['region', 'category'])\n\n        # arrange the whole concordance matrix\n        conc = np.kron(region_conc, sector_conc)\n        conc_y = np.kron(region_conc, np.eye(len(self.get_Y_categories())))\n\n        # Aggregate\n        self.meta._add_modify('Aggregate final demand y')\n        self.Y = pd.DataFrame(\n                    data=conc.dot(self.Y).dot(conc_y.T),\n                    index=mi_reg_sec,\n                    columns=mi_reg_Ycat,\n                    )\n\n        self.meta._add_modify('Aggregate transaction matrix Z')\n        self.Z = pd.DataFrame(\n                    data=conc.dot(self.Z).dot(conc.T),\n                    index=mi_reg_sec,\n                    columns=mi_reg_sec,\n                    )\n\n        if self.x is not None:\n            # x could also be obtained from the\n            # aggregated Z, but aggregate if available\n            self.x = pd.DataFrame(\n                        data=conc.dot(self.x),\n                        index=mi_reg_sec,\n                        columns=self.x.columns,\n                        )\n            self.meta._add_modify('Aggregate industry output x')\n        else:\n            self.x = calc_x(self.Z, self.Y)\n\n        if self.population is not None:\n            self.meta._add_modify('Aggregate population vector')\n            self.population = pd.DataFrame(\n                data=region_conc.dot(self.population.T).T,\n                columns=region_names,\n                index=self.population.index,\n                )\n\n        for extension in self.get_extensions(data=True):\n            self.meta._add_modify('Aggregate extensions...')\n            extension.reset_to_flows()\n            st_redo_unit = False\n            for ik_name, ik_df in zip(\n                    extension.get_DataFrame(data=False, with_unit=False),\n                    extension.get_DataFrame(data=True, with_unit=False)):\n\n                # Without unit - this is reset aftwards if necessary\n                if ik_df.index.names == ['region',\n                                         'sector'] == ik_df.columns.names:\n                    # Full disaggregated extensions - aggregate both axis\n                    # (this is the case if the extions shows the flows from\n                    # pda to cba)\n                    extension.__dict__[ik_name] = pd.DataFrame(\n                        data=conc.dot(ik_df).dot(conc.T))\n\n                    # next step must be done afterwards due to unknown reasons\n                    extension.__dict__[ik_name].columns = mi_reg_sec\n                    extension.__dict__[ik_name].index = mi_reg_sec\n                    st_redo_unit = True\n                elif (ik_df.index.names == ['region', 'sector'] and\n                      ik_df.columns.names == ['region', 'category']):\n\n                    # Full disaggregated finald demand satellite account.\n                    # Thats not implemented yet - but aggregation is in place\n                    extension.__dict__[ik_name] = pd.DataFrame(\n                        data=conc.dot(ik_df).dot(conc_y.T))\n                    # next step must be done afterwards due to unknown reasons\n                    extension.__dict__[ik_name].columns = mi_reg_Ycat\n                    extension.__dict__[ik_name].index = mi_reg_sec\n\n                elif ik_df.columns.names == ['region', 'category']:\n                    # Satellite account connected to final demand (e.g. FY)\n                    extension.__dict__[ik_name] = pd.DataFrame(\n                        data=ik_df.dot(conc_y.T))\n                    # next step must be done afterwards due to unknown reasons\n                    extension.__dict__[ik_name].columns = mi_reg_Ycat\n                    extension.__dict__[ik_name].index = ik_df.index\n\n                else:\n                    # Standard case - aggregated columns, keep stressor rows\n                    extension.__dict__[ik_name] = pd.DataFrame(\n                        data=ik_df.dot(conc.T))\n                    # next step must be done afterwards due to unknown reasons\n                    extension.__dict__[ik_name].columns = mi_reg_sec\n                    extension.__dict__[ik_name].index = ik_df.index\n\n                if st_redo_unit:\n                    try:\n                        _value = extension.unit.iloc[0].tolist()[0]\n                        extension.unit = pd.DataFrame(\n                                index=mi_reg_sec,\n                                columns=extension.unit.columns,\n                                data=_value)\n                    except AttributeError:\n                        # could fail if no unit available\n                        extension.unit = None\n        self.calc_extensions()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the extension from the IOSystem.", "response": "def remove_extension(self, ext=None):\n        \"\"\" Remove extension from IOSystem\n\n        For single Extensions the same can be achieved with del\n        IOSystem_name.Extension_name\n\n        Parameters\n        ----------\n        ext : string or list, optional\n            The extension to remove, this can be given as the name of the\n            instance or of Extension.name (the latter will be checked if no\n            instance was found)\n            If ext is None (default) all Extensions will be removed\n        \"\"\"\n        if ext is None:\n            ext = list(self.get_extensions())\n        if type(ext) is str:\n            ext = [ext]\n\n        for ee in ext:\n            try:\n                del self.__dict__[ee]\n            except KeyError:\n                for exinstancename, exdata in zip(\n                        self.get_extensions(data=False),\n                        self.get_extensions(data=True)):\n                    if exdata.name == ee:\n                        del self.__dict__[exinstancename]\n            finally:\n                self.meta._add_modify(\"Removed extension {}\".format(ee))\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn true if the input can be interpreted as a true vector Note that this function is only used for arrays and arrays.", "response": "def is_vector(inp):\n    \"\"\" Returns true if the input can be interpreted as a 'true' vector\n\n    Note\n    ----\n    Does only check dimensions, not if type is numeric\n\n    Parameters\n    ----------\n    inp : numpy.ndarray or something that can be converted into ndarray\n\n    Returns\n    -------\n    Boolean\n        True for vectors: ndim = 1 or ndim = 2 and shape of one axis = 1\n        False for all other arrays\n    \"\"\"\n    inp = np.asarray(inp)\n    nr_dim = np.ndim(inp)\n    if nr_dim == 1:\n        return True\n    elif (nr_dim == 2) and (1 in inp.shape):\n        return True\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_repo_content(path):\n    path = Path(path)\n\n    if zipfile.is_zipfile(str(path)):\n        with zipfile.ZipFile(str(path)) as zz:\n            filelist = [info.filename for info in zz.infolist()]\n        iszip = True\n    else:\n        iszip = False\n        filelist = [str(f) for f in path.glob('**/*') if f.is_file()]\n    return namedtuple('repocontent', ['iszip', 'filelist'])(iszip, filelist)", "response": "Returns a namedtuple with the iszip and filelist as a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_file_para(path, path_in_arc=''):\n    if type(path) is str:\n        path = Path(path.rstrip('\\\\'))\n\n    if zipfile.is_zipfile(str(path)):\n        para_file_folder = str(path_in_arc)\n        with zipfile.ZipFile(file=str(path)) as zf:\n            files = zf.namelist()\n    else:\n        para_file_folder = str(path)\n        files = [str(f) for f in path.glob('**/*')]\n\n    if para_file_folder not in files:\n        para_file_full_path = os.path.join(\n            para_file_folder, DEFAULT_FILE_NAMES['filepara'])\n    else:\n        para_file_full_path = para_file_folder\n        para_file_folder = os.path.dirname(para_file_full_path)\n\n    if para_file_full_path not in files:\n        raise FileNotFoundError(\n            'File parameter file {} not found'.format(\n                para_file_full_path))\n\n    if zipfile.is_zipfile(str(path)):\n        with zipfile.ZipFile(file=str(path)) as zf:\n            para_file_content = json.loads(\n                zf.read(para_file_full_path).decode('utf-8'))\n    else:\n        with open(para_file_full_path, 'r') as pf:\n            para_file_content = json.load(pf)\n\n    return namedtuple('file_parameter',\n                      ['folder', 'name', 'content'])(\n                       para_file_folder,\n                       os.path.basename(para_file_full_path),\n                       para_file_content)", "response": "This function is used to read the file parameter file in a consistent manner."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding an aggregation matrix for the given list of mappings.", "response": "def build_agg_matrix(agg_vector, pos_dict=None):\n    \"\"\" Agg. matrix based on mapping given in input as numerical or str vector.\n\n    The aggregation matrix has the from nxm with\n\n    -n  new classificaction\n    -m  old classification\n\n    Parameters\n    ----------\n        agg_vector : list or vector like numpy ndarray\n            This can be row or column vector.\n            Length m with position given for n and -1 if values\n            should not be included\n            or\n            length m with id_string for the aggregation\n\n        pos_dict : dictionary\n            (only possible if agg_vector is given as string)\n            output order for the new matrix\n            must be given as dict with\n            'string in agg_vector' = pos\n            (as int, -1 if value should not be included in the aggregation)\n\n    Example 1:\n        input vector: np.array([0, 1, 1, 2]) or ['a', 'b', 'b', 'c']\n\n        agg matrix:\n\n           m0  m1  m2  m3\n        n0 1   0   0   0\n        n1 0   1   1   0\n        n2 0   0   0   1\n\n    Example 2:\n        input vector: np.array([1, 0, 0, 2]) or\n                      (['b', 'a', 'a', 'c'], dict(a=0,b=1,c=2))\n\n        agg matrix:\n\n           m0  m1  m2  m3\n        n0 0   1   1   0\n        n1 1   0   0   0\n        n2 0   0   0   1\n    \"\"\"\n    if isinstance(agg_vector, np.ndarray):\n        agg_vector = agg_vector.flatten().tolist()\n\n    if type(agg_vector[0]) == str:\n        str_vector = agg_vector\n        agg_vector = np.zeros(len(str_vector))\n        if pos_dict:\n            if len(pos_dict.keys()) != len(set(str_vector)):\n                raise ValueError(\n                    'Posistion elements inconsistent with aggregation vector')\n            seen = pos_dict\n        else:\n            seen = {}\n        counter = 0\n        for ind, item in enumerate(str_vector):\n            if item not in seen:\n                seen[item] = counter\n                counter += 1\n            agg_vector[ind] = seen[item]\n\n    agg_vector = np.array(agg_vector, dtype=int)\n    agg_vector = agg_vector.reshape((1, -1))\n    row_corr = agg_vector\n    col_corr = np.arange(agg_vector.size)\n\n    agg_matrix = np.zeros((row_corr.max()+1, col_corr.max()+1))\n    agg_matrix[row_corr, col_corr] = 1\n\n    # set columns with -1 value to 0\n    agg_matrix[np.tile(agg_vector == -1, (np.shape(agg_matrix)[0], 1))] = 0\n\n    return agg_matrix"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_block(arr, arr_block):\n    nr_col = arr.shape[1]\n    nr_row = arr.shape[0]\n\n    nr_col_block = arr_block.shape[1]\n    nr_row_block = arr_block.shape[0]\n\n    if np.mod(nr_row, nr_row_block) or np.mod(nr_col, nr_col_block):\n        raise ValueError('Number of rows/columns of the input array '\n                         'must be a multiple of block shape')\n    if nr_row/nr_row_block != nr_col/nr_col_block:\n        raise ValueError('Block array can not be filled as '\n                         'diagonal blocks in the given array')\n\n    arr_out = arr.copy()\n\n    for row_ind in range(int(nr_row/nr_row_block)):\n        row_start = row_ind*nr_row_block\n        row_end = nr_row_block+nr_row_block*row_ind\n        col_start = row_ind*nr_col_block\n        col_end = nr_col_block+nr_col_block*row_ind\n\n        arr_out[row_start:row_end, col_start:col_end] = arr_block\n\n    return arr_out", "response": "Sets the diagonal blocks of an array to a given array."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of unique elements from a list preserving the original order", "response": "def unique_element(ll):\n    \"\"\" returns unique elements from a list preserving the original order \"\"\"\n    seen = {}\n    result = []\n    for item in ll:\n        if item in seen:\n            continue\n        seen[item] = 1\n        result.append(item)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_agg_vec(agg_vec, **source):\n\n    # build a dict with aggregation vectors in source and folder\n    if type(agg_vec) is str:\n        agg_vec = [agg_vec]\n    agg_dict = dict()\n    for entry in agg_vec:\n        try:\n            agg_dict[entry] = source[entry]\n        except KeyError:\n            folder = source.get('path', './')\n            folder = os.path.join(PYMRIO_PATH[folder], 'concordance')\n            for file in os.listdir(folder):\n                if entry == os.path.splitext(file)[0]:\n                    _tmp = np.genfromtxt(os.path.join(folder, file), dtype=str)\n                    if _tmp.ndim == 1:\n                        agg_dict[entry] = [None if ee == 'None'\n                                           else ee for ee in _tmp.tolist()]\n                    else:\n                        agg_dict[entry] = [None if ee == 'None'\n                                           else ee\n                                           for ee in _tmp[:, -1].tolist()]\n                    break\n            else:\n                logging.error(\n                        'Aggregation vector -- {} -- not found'\n                        .format(str(entry)))\n\n    # build the summary aggregation vector\n    def _rep(ll, ii, vv): ll[ii] = vv\n    miss_val = source.get('miss', 'REST')\n\n    vec_list = [agg_dict[ee] for ee in agg_vec]\n    out = [None, ] * len(vec_list[0])\n    for currvec in vec_list:\n        if len(currvec) != len(out):\n            logging.warn('Inconsistent vector length')\n        [_rep(out, ind, val) for ind, val in\n         enumerate(currvec) if not out[ind]]\n\n    [_rep(out, ind, miss_val) for ind, val in enumerate(out) if not val]\n\n    return out", "response": "Builds an aggregation vector based on the order in the source list."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_first_number(ll):\n    for nr, entry in enumerate(ll):\n        try:\n            float(entry)\n        except (ValueError, TypeError) as e:\n            pass\n        else:\n            return nr\n    return None", "response": "Returns nr of first entry parseable to float in ll None otherwise"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntry to get the separator, nr of index cols and header rows in a csv file Parameters ---------- csv_file: str Path to a csv file potential_sep: list, optional List of potential separators (delimiters) to test. Default: '\\t', ',', ';', '|', '-', '_' max_test_lines: int, optional How many lines to test, default: 10 or available lines in csv_file zip_file: str, optional Path to a zip file containing the csv file (if any, default: None). If a zip file is given, the path given at 'csv_file' is assumed to be the path to the file within the zip_file. Returns ------- dict with sep: string (separator) nr_index_col: int nr_header_row: int Entries are set to None if inconsistent information in the file", "response": "def sniff_csv_format(csv_file,\n                     potential_sep=['\\t', ',', ';', '|', '-', '_'],\n                     max_test_lines=10,\n                     zip_file=None):\n    \"\"\" Tries to get the separator, nr of index cols and header rows in a csv file\n\n    Parameters\n    ----------\n\n    csv_file: str\n        Path to a csv file\n\n    potential_sep: list, optional\n        List of potential separators (delimiters) to test.\n        Default: '\\t', ',', ';', '|', '-', '_'\n\n    max_test_lines: int, optional\n        How many lines to test, default: 10 or available lines in csv_file\n\n    zip_file: str, optional\n        Path to a zip file containing the csv file (if any, default: None).\n        If a zip file is given, the path given at 'csv_file' is assumed\n        to be the path to the file within the zip_file.\n\n    Returns\n    -------\n        dict with\n            sep: string (separator)\n            nr_index_col: int\n            nr_header_row: int\n\n        Entries are set to None if inconsistent information in the file\n    \"\"\"\n\n    def read_first_lines(filehandle):\n        lines = []\n        for i in range(max_test_lines):\n            line = ff.readline()\n            if line == '':\n                break\n            try:\n                line = line.decode('utf-8')\n            except AttributeError:\n                pass\n            lines.append(line[:-1])\n        return lines\n\n    if zip_file:\n        with zipfile.ZipFile(zip_file, 'r') as zz:\n            with zz.open(csv_file, 'r') as ff:\n                test_lines = read_first_lines(ff)\n    else:\n        with open(csv_file, 'r') as ff:\n            test_lines = read_first_lines(ff)\n\n    sep_aly_lines = [sorted([(line.count(sep), sep)\n                     for sep in potential_sep if line.count(sep) > 0],\n                     key=lambda x: x[0], reverse=True) for line in test_lines]\n\n    for nr, (count, sep) in enumerate(sep_aly_lines[0]):\n        for line in sep_aly_lines:\n            if line[nr][0] == count:\n                break\n        else:\n            sep = None\n\n        if sep:\n            break\n\n    nr_header_row = None\n    nr_index_col = None\n\n    if sep:\n        nr_index_col = find_first_number(test_lines[-1].split(sep))\n        if nr_index_col:\n            for nr_header_row, line in enumerate(test_lines):\n                if find_first_number(line.split(sep)) == nr_index_col:\n                    break\n\n    return dict(sep=sep,\n                nr_header_row=nr_header_row,\n                nr_index_col=nr_index_col)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning three elements tuple with socket descriptors ready for gevent. select. select", "response": "def _get_descriptors(self):\n        \"\"\"Returns three elements tuple with socket descriptors ready\n        for gevent.select.select\n        \"\"\"\n        rlist = []\n        wlist = []\n        xlist = []\n\n        for socket, flags in self.sockets.items():\n            if isinstance(socket, zmq.Socket):\n                rlist.append(socket.getsockopt(zmq.FD))\n                continue\n            elif isinstance(socket, int):\n                fd = socket\n            elif hasattr(socket, 'fileno'):\n                try:\n                    fd = int(socket.fileno())\n                except:\n                    raise ValueError('fileno() must return an valid integer fd')\n            else:\n                raise TypeError('Socket must be a 0MQ socket, an integer fd '\n                                'or have a fileno() method: %r' % socket)\n\n            if flags & zmq.POLLIN:\n                rlist.append(fd)\n            if flags & zmq.POLLOUT:\n                wlist.append(fd)\n            if flags & zmq.POLLERR:\n                xlist.append(fd)\n\n        return (rlist, wlist, xlist)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef poll(self, timeout=-1):\n\n        if timeout is None:\n            timeout = -1\n\n        if timeout < 0:\n            timeout = -1\n\n        rlist = None\n        wlist = None\n        xlist = None\n\n        if timeout > 0:\n            tout = gevent.Timeout.start_new(timeout/1000.0)\n\n        try:\n            # Loop until timeout or events available\n            rlist, wlist, xlist = self._get_descriptors()\n            while True:\n                events = super(GreenPoller, self).poll(0)\n                if events or timeout == 0:\n                    return events\n\n                # wait for activity on sockets in a green way\n                select.select(rlist, wlist, xlist)\n\n        except gevent.Timeout, t:\n            if t is not tout:\n                raise\n            return []\n        finally:\n           if timeout > 0:\n               tout.cancel()", "response": "This method returns a list of events from the green poller."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _instantiate_task(api, kwargs):\n    file_id = kwargs['file_id']\n    kwargs['file_id'] = file_id if str(file_id).strip() else None\n    kwargs['cid'] = kwargs['file_id'] or None\n    kwargs['rate_download'] = kwargs['rateDownload']\n    kwargs['percent_done'] = kwargs['percentDone']\n    kwargs['add_time'] = get_utcdatetime(kwargs['add_time'])\n    kwargs['last_update'] = get_utcdatetime(kwargs['last_update'])\n    is_transferred = (kwargs['status'] == 2 and kwargs['move'] == 1)\n    if is_transferred:\n        kwargs['pid'] = api.downloads_directory.cid\n    else:\n        kwargs['pid'] = None\n    del kwargs['rateDownload']\n    del kwargs['percentDone']\n    if 'url' in kwargs:\n        if not kwargs['url']:\n            kwargs['url'] = None\n    else:\n        kwargs['url'] = None\n    task = Task(api, **kwargs)\n    if is_transferred:\n        task._parent = api.downloads_directory\n    return task", "response": "Instantiates a Task object from raw kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, url, params=None):\n        r = self.session.get(url, params=params)\n        return self._response_parser(r, expect_json=False)", "response": "Initiate a GET request"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef post(self, url, data, params=None):\n        r = self.session.post(url, data=data, params=params)\n        return self._response_parser(r, expect_json=False)", "response": "Initiate a POST request"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a formatted API request to the specified object.", "response": "def send(self, request, expect_json=True, ignore_content=False):\n        \"\"\"\n        Send a formatted API request\n\n        :param request: a formatted request object\n        :type request: :class:`.Request`\n        :param bool expect_json: if True, raise :class:`.InvalidAPIAccess` if\n            response is not in JSON format\n        :param bool ignore_content: whether to ignore setting content of the\n            Response object\n        \"\"\"\n        r = self.session.request(method=request.method,\n                                 url=request.url,\n                                 params=request.params,\n                                 data=request.data,\n                                 files=request.files,\n                                 headers=request.headers)\n        return self._response_parser(r, expect_json, ignore_content)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _response_parser(self, r, expect_json=True, ignore_content=False):\n        if r.ok:\n            try:\n                j = r.json()\n                return Response(j.get('state'), j)\n            except ValueError:\n                # No JSON-encoded data returned\n                if expect_json:\n                    logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n                    logger.debug(r.text)\n                    raise InvalidAPIAccess('Invalid API access.')\n                # Raw response\n                if ignore_content:\n                    res = Response(True, None)\n                else:\n                    res = Response(True, r.text)\n                return res\n        else:\n            r.raise_for_status()", "response": "Parse the response object of the Requests\n            library."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_cookies(self, ignore_discard=True, ignore_expires=True):\n        self._init_cookies()\n        if os.path.exists(self.cookies.filename):\n            self.cookies.load(ignore_discard=ignore_discard,\n                              ignore_expires=ignore_expires)\n            self._reset_cache()", "response": "Load cookies from the file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave cookies to the file.", "response": "def save_cookies(self, ignore_discard=True, ignore_expires=True):\n        \"\"\"Save cookies to the file :attr:`.API.cookies_filename`\"\"\"\n        if not isinstance(self.cookies, cookielib.FileCookieJar):\n            m = 'Cookies must be a cookielib.FileCookieJar object to be saved.'\n            raise APIError(m)\n        self.cookies.save(ignore_discard=ignore_discard,\n                          ignore_expires=ignore_expires)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef login(self, username=None, password=None,\n              section='default'):\n        \"\"\"\n        Created the passport with ``username`` and ``password`` and log in.\n        If either ``username`` or ``password`` is None or omitted, the\n        credentials file will be parsed.\n\n        :param str username: username to login (email, phone number or user ID)\n        :param str password: password\n        :param str section: section name in the credential file\n        :raise: raises :class:`.AuthenticationError` if failed to login\n        \"\"\"\n        if self.has_logged_in:\n            return True\n        if username is None or password is None:\n            credential = conf.get_credential(section)\n            username = credential['username']\n            password = credential['password']\n\n        passport = Passport(username, password)\n        r = self.http.post(LOGIN_URL, passport.form)\n\n        if r.state is True:\n            # Bind this passport to API\n            self.passport = passport\n            passport.data = r.content['data']\n            self._user_id = r.content['data']['USER_ID']\n            return True\n        else:\n            msg = None\n            if 'err_name' in r.content:\n                if r.content['err_name'] == 'account':\n                    msg = 'Account does not exist.'\n                elif r.content['err_name'] == 'passwd':\n                    msg = 'Password is incorrect.'\n            raise AuthenticationError(msg)", "response": "Log in to the user with the given username and password."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef user_id(self):\n        if self._user_id is None:\n            if self.has_logged_in:\n                self._user_id = self._req_get_user_aq()['data']['uid']\n            else:\n                raise AuthenticationError('Not logged in.')\n        return self._user_id", "response": "Return the user id of the current API"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the username of the current API.", "response": "def username(self):\n        \"\"\"\n        Username of the current API user\n        \"\"\"\n        if self._username is None:\n            if self.has_logged_in:\n                self._username = self._get_username()\n            else:\n                raise AuthenticationError('Not logged in.')\n        return self._username"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_logged_in(self):\n        r = self.http.get(CHECKPOINT_URL)\n        if r.state is False:\n            return True\n        # If logged out, flush cache\n        self._reset_cache()\n        return False", "response": "Check whether the API has logged in"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef receiver_directory(self):\n        if self._receiver_directory is None:\n            self._receiver_directory = self.downloads_directory.parent\n        return self._receiver_directory", "response": "Parent directory of the downloads directory"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_task_bt(self, filename, select=False):\n        filename = eval_path(filename)\n        u = self.upload(filename, self.torrents_directory)\n        t = self._load_torrent(u)\n        if select:\n            return t\n        return t.submit()", "response": "Add a new BT to the torrents directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_storage_info(self, human=False):\n        res = self._req_get_storage_info()\n        if human:\n            res['total'] = humanize.naturalsize(res['total'], binary=True)\n            res['used'] = humanize.naturalsize(res['used'], binary=True)\n        return res", "response": "Get storage info for the current node."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef upload(self, filename, directory=None):\n        filename = eval_path(filename)\n        if directory is None:\n            directory = self.downloads_directory\n\n        # First request\n        res1 = self._req_upload(filename, directory)\n        data1 = res1['data']\n        file_id = data1['file_id']\n\n        # Second request\n        res2 = self._req_file(file_id)\n        data2 = res2['data'][0]\n        data2.update(**data1)\n        return _instantiate_uploaded_file(self, data2)", "response": "Uploads a file to a directory and returns the uploaded file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download(self, obj, path=None, show_progress=True, resume=True,\n                 auto_retry=True, proapi=False):\n        \"\"\"\n        Download a file\n\n        :param obj: :class:`.File` object\n        :param str path: local path\n        :param bool show_progress: whether to show download progress\n        :param bool resume: whether to resume on unfinished downloads\n            identified by filename\n        :param bool auto_retry: whether to retry automatically upon closed\n            transfer until the file's download is finished\n        :param bool proapi: whether to use pro API\n        \"\"\"\n        url = obj.get_download_url(proapi)\n        download(url, path=path, session=self.http.session,\n                 show_progress=show_progress, resume=resume,\n                 auto_retry=auto_retry)", "response": "Download a file from the object to local path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching files or directories or directories for a specific keyword.", "response": "def search(self, keyword, count=30):\n        \"\"\"\n        Search files or directories\n\n        :param str keyword: keyword\n        :param int count: number of entries to be listed\n        \"\"\"\n        kwargs = {}\n        kwargs['search_value'] = keyword\n        root = self.root_directory\n        entries = root._load_entries(func=self._req_files_search,\n                                     count=count, page=1, **kwargs)\n\n        res = []\n        for entry in entries:\n            if 'pid' in entry:\n                res.append(_instantiate_directory(self, entry))\n            else:\n                res.append(_instantiate_file(self, entry))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmove one or more entries to the destination directory.", "response": "def move(self, entries, directory):\n        \"\"\"\n        Move one or more entries (file or directory) to the destination\n        directory\n\n        :param list entries: a list of source entries (:class:`.BaseFile`\n            object)\n        :param directory: destination directory\n        :return: whether the action is successful\n        :raise: :class:`.APIError` if something bad happened\n        \"\"\"\n        fcids = []\n        for entry in entries:\n            if isinstance(entry, File):\n                fcid = entry.fid\n            elif isinstance(entry, Directory):\n                fcid = entry.cid\n            else:\n                raise APIError('Invalid BaseFile instance for an entry.')\n            fcids.append(fcid)\n        if not isinstance(directory, Directory):\n            raise APIError('Invalid destination directory.')\n        if self._req_files_move(directory.cid, fcids):\n            for entry in entries:\n                if isinstance(entry, File):\n                    entry.cid = directory.cid\n                entry.reload()\n            return True\n        else:\n            raise APIError('Error moving entries.')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef edit(self, entry, name, mark=False):\n        fcid = None\n        if isinstance(entry, File):\n            fcid = entry.fid\n        elif isinstance(entry, Directory):\n            fcid = entry.cid\n        else:\n            raise APIError('Invalid BaseFile instance for an entry.')\n        is_mark = 0\n        if mark is True:\n            is_mark = 1\n        if self._req_files_edit(fcid, name, is_mark):\n            entry.reload()\n            return True\n        else:\n            raise APIError('Error editing the entry.')", "response": "Edit an entry (file or directory)\n\n        :param entry: :class:`.BaseFile` object\n        :param str name: new name for the entry\n        :param bool mark: whether to bookmark the entry"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new directory.", "response": "def mkdir(self, parent, name):\n        \"\"\"\n        Create a directory\n\n        :param parent: the parent directory\n        :param str name: the name of the new directory\n        :return: the new directory\n        :rtype: :class:`.Directory`\n\n        \"\"\"\n        pid = None\n        cid = None\n        if isinstance(parent, Directory):\n            pid = parent.cid\n        else:\n            raise('Invalid Directory instance.')\n        cid = self._req_files_add(pid, name)['cid']\n        return self._load_directory(cid)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrequire before accessing lixian tasks", "response": "def _req_offline_space(self):\n        \"\"\"Required before accessing lixian tasks\"\"\"\n        url = 'http://115.com/'\n        params = {\n            'ct': 'offline',\n            'ac': 'space',\n            '_': get_timestamp(13)\n        }\n        _sign = os.environ.get('U115_BROWSER_SIGN')\n        if _sign is not None:\n            _time = os.environ.get('U115_BROWSER_TIME')\n            if _time is None:\n                msg = 'U115_BROWSER_TIME is required given U115_BROWSER_SIGN.'\n                raise APIError(msg)\n            params['sign'] = _sign\n            params['time'] = _time\n            params['uid'] = self.user_id\n        req = Request(url=url, params=params)\n        r = self.http.send(req)\n        if r.state:\n            self._signatures['offline_space'] = r.content['sign']\n            self._lixian_timestamp = r.content['time']\n        else:\n            msg = 'Failed to retrieve signatures.'\n            raise RequestFailure(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrequests the list of tasks from the Lixian.", "response": "def _req_lixian_task_lists(self, page=1):\n        \"\"\"\n        This request will cause the system to create a default downloads\n        directory if it does not exist\n        \"\"\"\n        url = 'http://115.com/lixian/'\n        params = {'ct': 'lixian', 'ac': 'task_lists'}\n        self._load_signatures()\n        data = {\n            'page': page,\n            'uid': self.user_id,\n            'sign': self._signatures['offline_space'],\n            'time': self._lixian_timestamp,\n        }\n        req = Request(method='POST', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            self._task_count = res.content['count']\n            self._task_quota = res.content['quota']\n            return res.content['tasks']\n        else:\n            msg = 'Failed to get tasks.'\n            raise RequestFailure(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting cid of lixian space directory", "response": "def _req_lixian_get_id(self, torrent=False):\n        \"\"\"Get `cid` of lixian space directory\"\"\"\n        url = 'http://115.com/'\n        params = {\n            'ct': 'lixian',\n            'ac': 'get_id',\n            'torrent': 1 if torrent else None,\n            '_': get_timestamp(13)\n        }\n        req = Request(method='GET', url=url, params=params)\n        res = self.http.send(req)\n        return res.content"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _req_lixian_torrent(self, u):\n\n        self._load_signatures()\n        url = 'http://115.com/lixian/'\n        params = {\n            'ct': 'lixian',\n            'ac': 'torrent',\n        }\n        data = {\n            'pickcode': u.pickcode,\n            'sha1': u.sha,\n            'uid': self.user_id,\n            'sign': self._signatures['offline_space'],\n            'time': self._lixian_timestamp,\n        }\n        req = Request(method='POST', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            msg = res.content.get('error_msg')\n            self.logger.error(msg)\n            raise RequestFailure('Failed to open torrent.')", "response": "Request a new liXian torrent."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nediting a file or directory", "response": "def _req_files_edit(self, fid, file_name=None, is_mark=0):\n        \"\"\"Edit a file or directory\"\"\"\n        url = self.web_api_url + '/edit'\n        data = locals()\n        del data['self']\n        req = Request(method='POST', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            raise RequestFailure('Failed to access files API.')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a directory to the files API.", "response": "def _req_files_add(self, pid, cname):\n        \"\"\"\n        Add a directory\n        :param str pid: parent directory id\n        :param str cname: directory name\n        \"\"\"\n        url = self.web_api_url + '/add'\n        data = locals()\n        del data['self']\n        req = Request(method='POST', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure('Failed to access files API.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _req_files_move(self, pid, fids):\n        url = self.web_api_url + '/move'\n        data = {}\n        data['pid'] = pid\n        for i, fid in enumerate(fids):\n            data['fid[%d]' % i] = fid\n        req = Request(method='POST', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            raise RequestFailure('Failed to access files API.')", "response": "Move files or directories or directories to destination directory id\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning name and pid of by cid", "response": "def _req_directory(self, cid):\n        \"\"\"Return name and pid of by cid\"\"\"\n        res = self._req_files(cid=cid, offset=0, limit=1, show_dir=1)\n        path = res['path']\n        count = res['count']\n        for d in path:\n            if str(d['cid']) == str(cid):\n                res = {\n                    'cid': d['cid'],\n                    'name': d['name'],\n                    'pid': d['pid'],\n                    'count': count,\n                }\n                return res\n        else:\n            raise RequestFailure('No directory found.')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _req_upload(self, filename, directory):\n        self._upload_url = self._load_upload_url()\n        self.http.get('http://upload.115.com/crossdomain.xml')\n        b = os.path.basename(filename)\n        target = 'U_1_' + str(directory.cid)\n        files = {\n            'Filename': ('', quote(b), ''),\n            'target': ('', target, ''),\n            'Filedata': (quote(b), open(filename, 'rb'), ''),\n            'Upload': ('', 'Submit Query', ''),\n        }\n        req = Request(method='POST', url=self._upload_url, files=files)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            msg = None\n            if res.content['code'] == 990002:\n                msg = 'Invalid parameter.'\n            elif res.content['code'] == 1001:\n                msg = 'Torrent upload failed. Please try again later.'\n            raise RequestFailure(msg)", "response": "Request to upload a file to a Torrent."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load_root_directory(self):\n        kwargs = self._req_directory(0)\n        self._root_directory = Directory(api=self, **kwargs)", "response": "Load the root directory which has a cid of 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _load_torrents_directory(self):\n        r = self._req_lixian_get_id(torrent=True)\n        self._downloads_directory = self._load_directory(r['cid'])", "response": "Load torrents directory\n\n        If it does not exist yet, this request will cause the system to create\n        one"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading downloads directory If it does not exist yet, this request will cause the system to create one", "response": "def _load_downloads_directory(self):\n        \"\"\"\n        Load downloads directory\n\n        If it does not exist yet, this request will cause the system to create\n        one\n        \"\"\"\n        r = self._req_lixian_get_id(torrent=False)\n        self._downloads_directory = self._load_directory(r['cid'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses JavaScript variables in the source page", "response": "def _parse_src_js_var(self, variable):\n        \"\"\"Parse JavaScript variables in the source page\"\"\"\n\n        src_url = 'http://115.com'\n        r = self.http.get(src_url)\n        soup = BeautifulSoup(r.content)\n        scripts = [script.text for script in soup.find_all('script')]\n        text = '\\n'.join(scripts)\n        pattern = \"%s\\s*=\\s*(.*);\" % (variable.upper())\n        m = re.search(pattern, text)\n        if not m:\n            msg = 'Cannot parse source JavaScript for %s.' % variable\n            raise APIError(msg)\n        return json.loads(m.group(1).strip())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete this file or directory.", "response": "def delete(self):\n        \"\"\"\n        Delete this file or directory\n\n        :return: whether deletion is successful\n        :raise: :class:`.APIError` if this file or directory is already deleted\n\n        \"\"\"\n        fcid = None\n        pid = None\n\n        if isinstance(self, File):\n            fcid = self.fid\n            pid = self.cid\n        elif isinstance(self, Directory):\n            fcid = self.cid\n            pid = self.pid\n        else:\n            raise APIError('Invalid BaseFile instance.')\n\n        if not self._deleted:\n            if self.api._req_rb_delete(fcid, pid):\n                self._deleted = True\n                return True\n        else:\n            raise APIError('This file or directory is already deleted.')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef edit(self, name, mark=False):\n        self.api.edit(self, name, mark)", "response": "Edit this file or directory entry\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the directory that holds this file", "response": "def directory(self):\n        \"\"\"Directory that holds this file\"\"\"\n        if self._directory is None:\n            self._directory = self.api._load_directory(self.cid)\n        return self._directory"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_download_url(self, proapi=False):\n        if self._download_url is None:\n            self._download_url = \\\n                self.api._req_files_download_url(self.pickcode, proapi)\n        return self._download_url", "response": "Get this file s download URL."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reload(self):\n        res = self.api._req_file(self.fid)\n        data = res['data'][0]\n        self.name = data['file_name']\n        self.sha = data['sha1']\n        self.pickcode = data['pick_code']", "response": "Reload the file info and metadata of this object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parent(self):\n        if self._parent is None:\n            if self.pid is not None:\n                self._parent = self.api._load_directory(self.pid)\n        return self._parent", "response": "Parent directory that holds this directory"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reload(self):\n        r = self.api._req_directory(self.cid)\n        self.pid = r['pid']\n        self.name = r['name']\n        self._count = r['count']", "response": "Reload the current object s metadata"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads entries from the API.", "response": "def _load_entries(self, func, count, page=1, entries=None, **kwargs):\n        \"\"\"\n        Load entries\n\n        :param function func: function (:meth:`.API._req_files` or\n            :meth:`.API._req_search`) that returns entries\n        :param int count: number of entries to load. This value should never\n            be greater than self.count\n        :param int page: page number (starting from 1)\n\n        \"\"\"\n        if entries is None:\n            entries = []\n        res = \\\n            func(offset=(page - 1) * self.max_entries_per_load,\n                 limit=self.max_entries_per_load,\n                 **kwargs)\n        loaded_entries = [\n            entry for entry in res['data'][:count]\n        ]\n        #total_count = res['count']\n        total_count = self.count\n        # count should never be greater than total_count\n        if count > total_count:\n            count = total_count\n        if count <= self.max_entries_per_load:\n            return entries + loaded_entries\n        else:\n            cur_count = count - self.max_entries_per_load\n            return self._load_entries(\n                func=func, count=cur_count, page=page + 1,\n                entries=entries + loaded_entries, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist the contents of the receiver directory.", "response": "def list(self, count=30, order='user_ptime', asc=False, show_dir=True,\n             natsort=True):\n        \"\"\"\n        List directory contents\n\n        :param int count: number of entries to be listed\n        :param str order: order of entries, originally named `o`. This value\n            may be one of `user_ptime` (default), `file_size` and `file_name`\n        :param bool asc: whether in ascending order\n        :param bool show_dir: whether to show directories\n        :param bool natsort: whether to use natural sort\n\n        Return a list of :class:`.File` or :class:`.Directory` objects\n        \"\"\"\n        if self.cid is None:\n            return False\n        self.reload()\n        kwargs = {}\n        # `cid` is the only required argument\n        kwargs['cid'] = self.cid\n        kwargs['asc'] = 1 if asc is True else 0\n        kwargs['show_dir'] = 1 if show_dir is True else 0\n        kwargs['natsort'] = 1 if natsort is True else 0\n        kwargs['o'] = order\n\n        # When the downloads directory exists along with its parent directory,\n        # the receiver directory, its parent's count (receiver directory's\n        # count) does not include the downloads directory. This behavior is\n        # similar to its parent's parent (root), the count of which does not\n        # include the receiver directory.\n        # The following code fixed this behavior so that a directory's\n        # count correctly reflects the actual number of entries in it\n        # The side-effect that this code may ensure that downloads directory\n        # exists, causing the system to create the receiver directory and\n        # downloads directory, if they do not exist.\n\n        if self.is_root or self == self.api.receiver_directory:\n            self._count += 1\n\n        if self.count <= count:\n            # count should never be greater than self.count\n            count = self.count\n        try:\n            entries = self._load_entries(func=self.api._req_files,\n                                         count=count, page=1, **kwargs)\n        # When natsort=1 and order='file_name', API access will fail\n        except RequestFailure as e:\n            if natsort is True and order == 'file_name':\n                entries = \\\n                    self._load_entries(func=self.api._req_aps_natsort_files,\n                                       count=count, page=1, **kwargs)\n            else:\n                raise e\n        res = []\n        for entry in entries:\n            if 'pid' in entry:\n                res.append(_instantiate_directory(self.api, entry))\n            else:\n                res.append(_instantiate_file(self.api, entry))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_directory(self):\n        if self.cid is None:\n            msg = 'Cannot determine whether this task is a directory.'\n            if not self.is_transferred:\n                msg += ' This task has not been transferred.'\n            raise TaskError(msg)\n        return self.api.downloads_directory.cid != self.cid", "response": "Returns whether this task is associated with a directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self):\n        if not self._deleted:\n            if self.api._req_lixian_task_del(self):\n                self._deleted = True\n                return True\n        raise TaskError('This task is already deleted.')", "response": "Delete the task from the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a human readable status of the current task.", "response": "def status_human(self):\n        \"\"\"\n        Human readable status\n\n        :return:\n\n            * `DOWNLOADING`: the task is downloading files\n            * `BEING TRANSFERRED`: the task is being transferred\n            * `TRANSFERRED`: the task has been transferred to downloads \\\n                    directory\n            * `SEARCHING RESOURCES`: the task is searching resources\n            * `FAILED`: the task is failed\n            * `DELETED`: the task is deleted\n            * `UNKNOWN STATUS`\n\n        :rtype: str\n\n        \"\"\"\n        res = None\n        if self._deleted:\n            return 'DELETED'\n        if self.status == 1:\n            res = 'DOWNLOADING'\n        elif self.status == 2:\n            if self.move == 0:\n                res = 'BEING TRANSFERRED'\n            elif self.move == 1:\n                res = 'TRANSFERRED'\n            elif self.move == 2:\n                res = 'PARTIALLY TRANSFERRED'\n        elif self.status == 4:\n            res = 'SEARCHING RESOURCES'\n        elif self.status == -1:\n            res = 'FAILED'\n        if res is not None:\n            return res\n        return 'UNKNOWN STATUS'"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the directory that this task is associated with.", "response": "def directory(self):\n        \"\"\"Associated directory, if any, with this task\"\"\"\n        if not self.is_directory:\n            msg = 'This task is a file task with no associated directory.'\n            raise TaskError(msg)\n        if self._directory is None:\n            if self.is_transferred:\n                self._directory = self.api._load_directory(self.cid)\n        if self._directory is None:\n            msg = 'No directory assciated with this task: Task is %s.' % \\\n                self.status_human.lower()\n            raise TaskError(msg)\n        return self._directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists the files of the associated directory to this task.", "response": "def list(self, count=30, order='user_ptime', asc=False, show_dir=True,\n             natsort=True):\n        \"\"\"\n        List files of the associated directory to this task.\n\n        :param int count: number of entries to be listed\n        :param str order: originally named `o`\n        :param bool asc: whether in ascending order\n        :param bool show_dir: whether to show directories\n\n        \"\"\"\n        return self.directory.list(count, order, asc, show_dir, natsort)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsubmit this torrent and create a new task", "response": "def submit(self):\n        \"\"\"Submit this torrent and create a new task\"\"\"\n        if self.api._req_lixian_add_task_bt(self):\n            self.submitted = True\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_needful_files(self):\n        manifest = self.storage.load_manifest()\n        if self.keep_unhashed_files:\n            if PY3:\n                needful_files = set(manifest.keys() | manifest.values())\n            else:\n                needful_files = set(manifest.keys() + manifest.values())\n            needful_files = {self.storage.clean_name(file) for file in needful_files}\n        else:\n            needful_files = set(manifest.values())\n        return {self.process_file(file) for file in needful_files}", "response": "Returns currently used static files."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef model_file_fields(self, model):\n        for field in model._meta.fields:\n            if isinstance(field, models.FileField):\n                yield field", "response": "Generator yielding all FileFields of a model."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_resource_types(self):\n        resource_types = set()\n        for model in self.models():\n            for field in self.model_file_fields(model):\n                resource_type = field.storage.RESOURCE_TYPE\n                resource_types.add(resource_type)\n        return resource_types", "response": "Returns set of resource types of all registered FileFields."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_needful_files(self):\n        needful_files = []\n        for model in self.models():\n            media_fields = []\n            for field in self.model_file_fields(model):\n                media_fields.append(field.name)\n            if media_fields:\n                exclude_options = {media_field: '' for media_field in media_fields}\n                model_uploaded_media = model.objects.exclude(**exclude_options).values_list(*media_fields)\n                needful_files.extend(model_uploaded_media)\n        return set(chain.from_iterable(needful_files))", "response": "Returns set of media files associated with models. Those files won t be deleted."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of orphaned media files to be removed grouped by resource type.", "response": "def get_files_to_remove(self):\n        \"\"\"\n        Returns orphaned media files to be removed grouped by resource type.\n        All files which paths start with any of exclude paths are ignored.\n        \"\"\"\n        files_to_remove = {}\n        needful_files = self.get_needful_files()\n        for resources_type, resources in self.get_uploaded_resources():\n            exclude_paths = self.get_exclude_paths()\n            resources = {resource for resource in resources if not resource.startswith(exclude_paths)}\n            files_to_remove[resources_type] = resources - needful_files\n        return files_to_remove"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_resource_type(self, name):\n        extension = self._get_file_extension(name)\n        if extension is None:\n            return self.RESOURCE_TYPE\n        elif extension in app_settings.STATIC_IMAGES_EXTENSIONS:\n            return RESOURCE_TYPES['IMAGE']\n        elif extension in app_settings.STATIC_VIDEOS_EXTENSIONS:\n            return RESOURCE_TYPES['VIDEO']\n        else:\n            return self.RESOURCE_TYPE", "response": "Returns the resource type of the given file name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _remove_extension_for_non_raw_file(self, name):\n        file_resource_type = self._get_resource_type(name)\n        if file_resource_type is None or file_resource_type == self.RESOURCE_TYPE:\n            return name\n        else:\n            extension = self._get_file_extension(name)\n            return name[:-len(extension) - 1]", "response": "Removes extension from name if file is not raw file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck whether a file with a name and a content is already uploaded to Cloudinary.", "response": "def _exists_with_etag(self, name, content):\n        \"\"\"\n        Checks whether a file with a name and a content is already uploaded to Cloudinary.\n        Uses ETAG header and MD5 hash for the content comparison.\n        \"\"\"\n        url = self._get_url(name)\n        response = requests.head(url)\n        if response.status_code == 404:\n            return False\n        etag = response.headers['ETAG'].split('\"')[1]\n        hash = self.file_hash(name, content)\n        return etag.startswith(hash)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave only when a file with a name and content is not already uploaded to Cloudinary.", "response": "def _save(self, name, content):\n        \"\"\"\n        Saves only when a file with a name and a content is not already uploaded to Cloudinary.\n        \"\"\"\n        name = self.clean_name(name)  # to change to UNIX style path on windows if necessary\n        if not self._exists_with_etag(name, content):\n            content.seek(0)\n            super(StaticCloudinaryStorage, self)._save(name, content)\n        return self._prepend_prefix(name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd an item to the cart.", "response": "def add(self, pk, quantity=1, **kwargs):\n        \"\"\"Add an item to the cart.\n\n        If the item is already in the cart, then its quantity will be\n        increased by `quantity` units.\n\n        Parameters\n        ----------\n        pk : str or int\n            The primary key of the item.\n        quantity : int-convertible\n            A number of units of to add.\n        **kwargs\n            Extra keyword arguments to pass to the item class\n            constructor.\n\n        Raises\n        ------\n        ItemNotInDatabase\n        NegativeItemQuantity\n        NonConvertibleItemQuantity\n        TooLargeItemQuantity\n        ZeroItemQuantity\n\n        \"\"\"\n        pk = str(pk)\n        if pk in self.items:\n            existing_item = self.items[pk]\n            existing_item.quantity += _clean_quantity(quantity)\n        else:\n            queryset = self.get_queryset([pk])\n            try:\n                obj = queryset[0]\n            except IndexError:\n                raise ItemNotInDatabase(pk=pk)\n            obj = self.process_object(obj)\n            self.items[pk] = self.item_class(obj, quantity, **kwargs)\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef change_quantity(self, pk, quantity):\n        pk = str(pk)\n        try:\n            item = self.items[pk]\n        except KeyError:\n            raise ItemNotInCart(pk=pk)\n        item.quantity = quantity\n        self.update()", "response": "Change the quantity of an item in the cart."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove an item from the cart.", "response": "def remove(self, pk):\n        \"\"\"Remove an item from the cart.\n\n        Parameters\n        ----------\n        pk : str or int\n            The primary key of the item.\n\n        Raises\n        ------\n        ItemNotInCart\n\n        \"\"\"\n        pk = str(pk)\n        try:\n            del self.items[pk]\n        except KeyError:\n            raise ItemNotInCart(pk=pk)\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of cart items.", "response": "def list_items(self, sort_key=None, reverse=False):\n        \"\"\"Return a list of cart items.\n\n        Parameters\n        ----------\n        sort_key : func\n            A function to customize the list order, same as the 'key'\n            argument to the built-in :func:`sorted`.\n        reverse: bool\n            If set to True, the sort order will be reversed.\n\n        Returns\n        -------\n        list\n            List of :attr:`item_class` instances.\n\n        Examples\n        --------\n        >>> cart = Cart(request)\n        >>> cart.list_items(lambda item: item.obj.name)\n        [<CartItem: obj=bar, quantity=3>,\n         <CartItem: obj=foo, quantity=1>,\n         <CartItem: obj=nox, quantity=5>]\n        >>> cart.list_items(lambda item: item.quantity, reverse=True)\n        [<CartItem: obj=nox, quantity=5>,\n         <CartItem: obj=bar, quantity=3>,\n         <CartItem: obj=foo, quantity=1>]\n\n        \"\"\"\n        items = list(self.items.values())\n        if sort_key:\n            items.sort(key=sort_key, reverse=reverse)\n        return items"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode(self, formatter=None):\n        items = {}\n        # The prices are converted to strings, because they may have a\n        # type that can't be serialized to JSON (e.g. Decimal).\n        for item in self.items.values():\n            pk = str(item.obj.pk)\n            items[pk] = {\n                'price': str(item.price),\n                'quantity': item.quantity,\n                'total': item.total,\n            }\n        cart_repr = {\n            'items': items,\n            'itemCount': self.item_count,\n            'totalPrice': str(self.total_price),\n        }\n        if formatter:\n            cart_repr = formatter(cart_repr)\n        return JsonResponse(cart_repr)", "response": "Return a representation of the cart as a JSON - response."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_items(self, session_items):\n        pks = list(session_items.keys())\n        items = {}\n        item_class = self.item_class\n        process_object = self.process_object\n        for obj in self.get_queryset(pks):\n            pk = str(obj.pk)\n            obj = process_object(obj)\n            items[pk] = item_class(obj, **session_items[pk])\n        if len(items) < len(session_items):\n            self._stale_pks = set(session_items).difference(items)\n        return items", "response": "Instantiate items from session data."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the cart s items and items attributes based on the items attribute.", "response": "def update(self):\n        \"\"\"Update the cart.\n\n        First this method updates attributes dependent on the cart's\n        `items`, such as `total_price` or `item_count`.\n        After that, it saves the new cart state to the session.\n\n        Generally, you'll need to call this method by yourself, only\n        when implementing new methods that directly change the `items`\n        attribute.\n\n        \"\"\"\n        self.item_count = self.count_items()\n        self.total_price = self.count_total_price()\n        # Update the session\n        session = self.request.session\n        session_items = {}\n        for pk, item in self.items.items():\n            session_items[pk] = dict(quantity=item.quantity, **item._kwargs)\n        session_data = session[session_key]\n        session_data['items'] = session_items\n        session_data['itemCount'] = self.item_count\n        # The price can be of a type that can't be serialized to JSON\n        session_data['totalPrice'] = str(self.total_price)\n        session.modified = True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef count_items(self, unique=True):\n        if unique:\n            return len(self.items)\n        return sum([item.quantity for item in self.items.values()])", "response": "Count the number of items in the cart."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy_file(self, path, prefixed_path, source_storage):\n        if (settings.STATICFILES_STORAGE == 'cloudinary_storage.storage.StaticCloudinaryStorage' or\n                self.upload_unhashed_files):\n            super(Command, self).copy_file(path, prefixed_path, source_storage)", "response": "Overwritten to execute only with upload_unhashed_files param or StaticCloudinaryStorage"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nimplements a basic hill climbing algorithm. Has two stopping conditions: 1. Maximum number of iterations; 2. A known lower bound, a none is passed then this is not used. If acceptance_criteria (a callable) is not None then this is used to obtain an upper bound on some other measure (different to the objective function). In practice this is used when optimising the objective function to ensure that we don't accept a solution that improves the objective function but tht adds more constraint violations.", "response": "def hill_climber(objective_function,\n                 initial_array,\n                 lower_bound=-float('inf'),\n                 acceptance_criteria=None,\n                 max_iterations=10 ** 3):\n    \"\"\"\n    Implement a basic hill climbing algorithm.\n\n    Has two stopping conditions:\n\n    1. Maximum number of iterations;\n    2. A known lower bound, a none is passed then this is not used.\n\n    If acceptance_criteria (a callable) is not None then this is used to obtain\n    an upper bound on some other measure (different to the objective function).\n    In practice this is used when optimising the objective function to ensure\n    that we don't accept a solution that improves the objective function but tht\n    adds more constraint violations.\n    \"\"\"\n\n    X = initial_array\n    if acceptance_criteria is not None:\n        acceptance_bound = acceptance_criteria(X)\n\n    iterations = 0\n    current_energy = objective_function(X)\n\n    while current_energy > lower_bound and iterations <= max_iterations:\n\n        iterations += 1\n        candidate = element_from_neighbourhood(X)\n        candidate_energy = objective_function(candidate)\n\n        if (candidate_energy < current_energy and\n            (acceptance_criteria is None or\n             acceptance_criteria(candidate) <= acceptance_bound)):\n\n            X = candidate\n            current_energy = candidate_energy\n\n    if lower_bound > -float('inf') and current_energy != lower_bound:\n        warnings.warn(f\"Lower bound {lower_bound} not achieved after {max_iterations} iterations\")\n\n    return X"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nimplement a simulated annealing algorithm with exponential cooling", "response": "def simulated_annealing(objective_function,\n                        initial_array,\n                        initial_temperature=10 ** 4,\n                        cooldown_rate=0.7,\n                        acceptance_criteria=None,\n                        lower_bound=-float('inf'),\n                        max_iterations=10 ** 3):\n    \"\"\"\n    Implement a simulated annealing algorithm with exponential cooling\n\n    Has two stopping conditions:\n\n    1. Maximum number of iterations;\n    2. A known lower bound, a none is passed then this is not used.\n\n    Note that starting with an initial_temperature corresponds to a hill\n    climbing algorithm\n    \"\"\"\n\n    X = initial_array\n    if acceptance_criteria is not None:\n        acceptance_bound = acceptance_criteria(X)\n    best_X = X\n\n    iterations = 0\n    current_energy = objective_function(X)\n    best_energy = current_energy\n    temperature = initial_temperature\n\n    while current_energy > lower_bound and iterations <= max_iterations:\n\n        iterations += 1\n        candidate = element_from_neighbourhood(X)\n        candidate_energy = objective_function(candidate)\n\n        delta = candidate_energy - current_energy\n\n        if (candidate_energy < best_energy and\n            (acceptance_criteria is None or\n             acceptance_criteria(candidate) <= acceptance_bound)):\n\n            best_energy = candidate_energy\n            best_X = candidate\n\n        if delta < 0 or (temperature > 0 and\n                         np.random.random() < np.exp(-delta / temperature)):\n            X = candidate\n            current_energy = candidate_energy\n\n        temperature *= (cooldown_rate) ** iterations\n\n    if lower_bound > -float('inf') and current_energy != lower_bound:\n        warnings.warn(f\"Lower bound {lower_bound} not achieved after {max_iterations} iterations\")\n\n    return best_X"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _events_available_during_other_events(\n    events, slots, X, summation_type=None, **kwargs\n):\n    \"\"\"\n    Constraint that ensures that an event is not scheduled at the same time as\n    another event for which it is unavailable. Unavailability of events is\n    either because it is explicitly defined or because they share a tag.\n    \"\"\"\n    summation = lpu.summation_functions[summation_type]\n    event_availability_array = lpu.event_availability_array(events)\n\n    label = 'Event clashes with another event'\n    for slot1, slot2 in lpu.concurrent_slots(slots):\n        for row, event in enumerate(event_availability_array):\n            if events[row].unavailability:\n                for col, availability in enumerate(event):\n                    if availability == 0:\n                        yield Constraint(\n                            f'{label} - event: {row} and event: {col}',\n                            summation(\n                                (X[row, slot1], X[col, slot2])\n                            ) <= 1 + availability\n                        )", "response": "A constraint that ensures that an event is not scheduled at the same time as another event."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef heuristic(events,\n              slots,\n              objective_function=None,\n              algorithm=heu.hill_climber,\n              initial_solution=None,\n              initial_solution_algorithm_kwargs={},\n              objective_function_algorithm_kwargs={},\n              **kwargs):\n    \"\"\"\n    Compute a schedule using a heuristic\n\n    Parameters\n    ----------\n    events : list or tuple\n        of :py:class:`resources.Event` instances\n    slots : list or tuple\n        of :py:class:`resources.Slot` instances\n    algorithm : callable\n       a heuristic algorithm from conference_scheduler.heuristics\n    initial_solution_algorithm_kwargs : dict\n       kwargs for the heuristic algorithm for the initial solution\n    objective_function_algorithm_kwargs : dict\n       kwargs for the heuristic algorithm for the objective function (if\n       necessary.\n    objective_function: callable\n        from lp_problem.objective_functions\n    kwargs : keyword arguments\n        arguments for the objective function\n\n    Returns\n    -------\n    list\n        A list of tuples giving the event and slot index (for the given\n        events and slots lists) for all scheduled items.\n\n    Example\n    -------\n    For a solution where\n\n        * event 0 is scheduled in slot 1\n        * event 1 is scheduled in slot 4\n        * event 2 is scheduled in slot 5\n\n    the resulting list would be::\n\n        [(0, 1), (1, 4), (2, 5)]\n    \"\"\"\n    def count_violations(array):\n        return len(list(val.array_violations(array, events, slots)))\n\n    if initial_solution is None:\n        X = heu.get_initial_array(events=events, slots=slots)\n        X = algorithm(initial_array=X,\n                      objective_function=count_violations,\n                      lower_bound=0,\n                      **initial_solution_algorithm_kwargs)\n    else:\n        X = initial_solution\n\n    if objective_function is not None:\n\n        kwargs[\"beta\"] = float('inf')\n        def func(array):\n            return objective_function(\n                events=events, slots=slots, X=array, **kwargs)\n\n        X = algorithm(initial_array=X,\n                      objective_function=func,\n                      acceptance_criteria=count_violations,\n                      **objective_function_algorithm_kwargs)\n\n    return list(zip(*np.nonzero(X)))", "response": "Compute a schedule using a heuristic algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef solution(events, slots, objective_function=None, solver=None, **kwargs):\n    shape = Shape(len(events), len(slots))\n    problem = pulp.LpProblem()\n    X = lp.utils.variables(shape)\n    beta = pulp.LpVariable(\"upper_bound\")\n\n    for constraint in lp.constraints.all_constraints(\n        events, slots, X, beta, 'lpsum'\n    ):\n        problem += constraint.condition\n\n    if objective_function is not None:\n        problem += objective_function(events=events, slots=slots, X=X,\n                                      beta=beta,\n                                      **kwargs)\n\n    status = problem.solve(solver=solver)\n    if status == 1:\n        return [item for item, variable in X.items() if variable.value() > 0]\n    else:\n        raise ValueError('No valid solution found')", "response": "Compute a schedule in solution form"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef array(events, slots, objective_function=None, solver=None, **kwargs):\n    return conv.solution_to_array(\n        solution(events, slots, objective_function, solver=solver, **kwargs),\n        events, slots\n    )", "response": "Compute a schedule in array form"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute a schedule in schedule form.", "response": "def schedule(events, slots, objective_function=None, solver=None, **kwargs):\n    \"\"\"Compute a schedule in schedule form\n\n    Parameters\n    ----------\n    events : list or tuple\n        of :py:class:`resources.Event` instances\n    slots : list or tuple\n        of :py:class:`resources.Slot` instances\n    solver : pulp.solver\n        a pulp solver\n    objective_function : callable\n        from lp_problem.objective_functions\n    kwargs : keyword arguments\n        arguments for the objective function\n\n    Returns\n    -------\n    list\n        A list of instances of :py:class:`resources.ScheduledItem`\n    \"\"\"\n    return conv.solution_to_schedule(\n        solution(events, slots, objective_function, solver=solver, **kwargs),\n        events, slots\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef event_schedule_difference(old_schedule, new_schedule):\n    old = {item.event.name: item for item in old_schedule}\n    new = {item.event.name: item for item in new_schedule}\n\n    common_events = set(old.keys()).intersection(new.keys())\n    added_events = new.keys() - old.keys()\n    removed_events = old.keys() - new.keys()\n\n    changed = [\n        ChangedEventScheduledItem(\n            old[event].event, old[event].slot, new[event].slot)\n        for event in common_events\n        if old[event].slot != new[event].slot\n    ]\n    added = [\n        ChangedEventScheduledItem(new[event].event, None, new[event].slot)\n        for event in added_events\n    ]\n    removed = [\n        ChangedEventScheduledItem(old[event].event, old[event].slot, None)\n        for event in removed_events\n    ]\n    return sorted(changed + added + removed, key=lambda item: item.event.name)", "response": "Compute the difference between two schedules from an event perspective\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef slot_schedule_difference(old_schedule, new_schedule):\n    old = {item.slot: item for item in old_schedule}\n    new = {item.slot: item for item in new_schedule}\n\n    common_slots = set(old.keys()).intersection(new.keys())\n    added_slots = new.keys() - old.keys()\n    removed_slots = old.keys() - new.keys()\n\n    changed = [\n        ChangedSlotScheduledItem(\n            old[slot].slot, old[slot].event, new[slot].event)\n        for slot in common_slots\n        if old[slot].event != new[slot].event\n    ]\n    added = [\n        ChangedSlotScheduledItem(new[slot].slot, None, new[slot].event)\n        for slot in added_slots\n    ]\n    removed = [\n        ChangedSlotScheduledItem(old[slot].slot, old[slot].event, None)\n        for slot in removed_slots\n    ]\n    return sorted(\n        changed + added + removed,\n        key=lambda item: (item.slot.venue, item.slot.starts_at)\n    )", "response": "Compute the difference between two schedules from a slot perspective\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef array_violations(array, events, slots, beta=None):\n    return (\n        c.label\n        for c in constraints.all_constraints(events, slots, array, beta=beta)\n        if not c.condition\n    )", "response": "Take a schedule in array form and return any violated constraints\nAttributeNames"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_valid_array(array, events, slots):\n\n    if len(array) == 0:\n        return False\n    violations = sum(1 for c in (array_violations(array, events, slots)))\n    return violations == 0", "response": "Take a schedule in array form and return whether it is a valid\n    solution for the given constraints\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking a solution and return whether it is valid for the given constraints", "response": "def is_valid_solution(solution, events, slots):\n    \"\"\"Take a solution and return whether it is valid for the\n    given constraints\n\n    Parameters\n    ----------\n        solution: list or tuple\n            a schedule in solution form\n        events : list or tuple\n            of resources.Event instances\n        slots : list or tuple\n            of resources.Slot instances\n\n    Returns\n    -------\n        bool\n            True if schedule is a valid solution\n    \"\"\"\n    if len(solution) == 0:\n        return False\n    array = converter.solution_to_array(solution, events, slots)\n    return is_valid_array(array, events, slots)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes a solution and return a list of violated constraints", "response": "def solution_violations(solution, events, slots):\n    \"\"\"Take a solution and return a list of violated constraints\n\n    Parameters\n    ----------\n        solution: list or tuple\n            a schedule in solution form\n        events : list or tuple\n            of resources.Event instances\n        slots : list or tuple\n            of resources.Slot instances\n\n    Returns\n    -------\n        Generator\n            of a list of strings indicating the nature of the violated\n            constraints\n    \"\"\"\n    array = converter.solution_to_array(solution, events, slots)\n    return array_violations(array, events, slots)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntaking a schedule and return whether it is a valid solution for the given constraints", "response": "def is_valid_schedule(schedule, events, slots):\n    \"\"\"Take a schedule and return whether it is a valid solution for the\n    given constraints\n\n    Parameters\n    ----------\n        schedule : list or tuple\n            a schedule in schedule form\n        events : list or tuple\n            of resources.Event instances\n        slots : list or tuple\n            of resources.Slot instances\n\n    Returns\n    -------\n        bool\n            True if schedule is a valid solution\n    \"\"\"\n    if len(schedule) == 0:\n        return False\n    array = converter.schedule_to_array(schedule, events, slots)\n    return is_valid_array(array, events, slots)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake a schedule and return a list of violated constraints", "response": "def schedule_violations(schedule, events, slots):\n    \"\"\"Take a schedule and return a list of violated constraints\n\n    Parameters\n    ----------\n        schedule : list or tuple\n            a schedule in schedule form\n        events : list or tuple\n            of resources.Event instances\n        slots : list or tuple\n            of resources.Slot instances\n\n    Returns\n    -------\n        Generator\n            of a list of strings indicating the nature of the violated\n            constraints\n    \"\"\"\n    array = converter.schedule_to_array(schedule, events, slots)\n    return array_violations(array, events, slots)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a numpy array mapping events to tags", "response": "def tag_array(events):\n    \"\"\"\n    Return a numpy array mapping events to tags\n\n    - Rows corresponds to events\n    - Columns correspond to tags\n    \"\"\"\n    all_tags = sorted(set(tag for event in events for tag in event.tags))\n    array = np.zeros((len(events), len(all_tags)))\n    for row, event in enumerate(events):\n        for tag in event.tags:\n            array[row, all_tags.index(tag)] = 1\n    return array"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a numpy array mapping sessions to slots", "response": "def session_array(slots):\n    \"\"\"\n    Return a numpy array mapping sessions to slots\n\n    - Rows corresponds to sessions\n    - Columns correspond to slots\n    \"\"\"\n    # Flatten the list: this assumes that the sessions do not share slots\n    sessions = sorted(set([slot.session for slot in slots]))\n    array = np.zeros((len(sessions), len(slots)))\n    for col, slot in enumerate(slots):\n        array[sessions.index(slot.session), col] = 1\n    return array"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a numpy array mapping events to slots", "response": "def slot_availability_array(events, slots):\n    \"\"\"\n    Return a numpy array mapping events to slots\n\n    - Rows corresponds to events\n    - Columns correspond to stags\n\n    Array has value 0 if event cannot be scheduled in a given slot\n    (1 otherwise)\n    \"\"\"\n    array = np.ones((len(events), len(slots)))\n    for row, event in enumerate(events):\n        for col, slot in enumerate(slots):\n            if slot in event.unavailability or event.duration > slot.duration:\n                array[row, col] = 0\n    return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a numpy array mapping events to events", "response": "def event_availability_array(events):\n    \"\"\"\n    Return a numpy array mapping events to events\n\n    - Rows corresponds to events\n    - Columns correspond to events\n\n    Array has value 0 if event cannot be scheduled at same time as other event\n    (1 otherwise)\n    \"\"\"\n    array = np.ones((len(events), len(events)))\n    for row, event in enumerate(events):\n        for col, other_event in enumerate(events):\n            if row != col:\n                tags = set(event.tags)\n                events_share_tag = len(tags.intersection(other_event.tags)) > 0\n                if (other_event in event.unavailability) or events_share_tag:\n                    array[row, col] = 0\n                    array[col, row] = 0\n    return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns whether or not two events overlap", "response": "def slots_overlap(slot, other_slot):\n    \"\"\"\n    Return boolean: whether or not two events overlap\n    \"\"\"\n    slot_ends_at = ends_at(slot)\n    other_ends_at = ends_at(other_slot)\n    if (slot.starts_at >= other_slot.starts_at and\n        slot_ends_at <= other_ends_at\n    ):\n        return True\n    if (other_slot.starts_at >= slot.starts_at and\n        other_ends_at <= slot_ends_at\n    ):\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef concurrent_slots(slots):\n    for i, slot in enumerate(slots):\n        for j, other_slot in enumerate(slots[i + 1:]):\n            if slots_overlap(slot, other_slot):\n                yield (i, j + i + 1)", "response": "Yields all concurrent slot indices."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the indices of the events with a different tag in common as tag", "response": "def _events_with_diff_tag(talk, tag_array):\n    \"\"\"\n    Return the indices of the events with no tag in common as tag\n    \"\"\"\n    event_categories = np.nonzero(tag_array[talk])[0]\n    return np.nonzero(sum(tag_array.transpose()[event_categories]) == 0)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef solution_to_array(solution, events, slots):\n    array = np.zeros((len(events), len(slots)), dtype=np.int8)\n    for item in solution:\n        array[item[0], item[1]] = 1\n    return array", "response": "Convert a schedule from solution to array form\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef solution_to_schedule(solution, events, slots):\n    return [\n        ScheduledItem(\n            event=events[item[0]],\n            slot=slots[item[1]]\n        )\n        for item in solution\n    ]", "response": "Convert a schedule from solution to schedule form\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a schedule from schedule to array form", "response": "def schedule_to_array(schedule, events, slots):\n    \"\"\"Convert a schedule from schedule to array form\n\n    Parameters\n    ----------\n    schedule : list or tuple\n        of instances of :py:class:`resources.ScheduledItem`\n    events : list or tuple\n        of :py:class:`resources.Event` instances\n    slots : list or tuple\n        of :py:class:`resources.Slot` instances\n\n    Returns\n    -------\n    np.array\n        An E by S array (X) where E is the number of events and S the\n        number of slots. Xij is 1 if event i is scheduled in slot j and\n        zero otherwise\n    \"\"\"\n    array = np.zeros((len(events), len(slots)), dtype=np.int8)\n    for item in schedule:\n        array[events.index(item.event), slots.index(item.slot)] = 1\n    return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef array_to_schedule(array, events, slots):\n    scheduled = np.transpose(np.nonzero(array))\n    return [\n        ScheduledItem(event=events[item[0]], slot=slots[item[1]])\n        for item in scheduled\n    ]", "response": "Convert a schedule from array to schedule form\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nappend one line of generated reST to the output.", "response": "def add_line(self, line, source, *lineno):\n    \"\"\"Append one line of generated reST to the output.\"\"\"\n    if 'conference_scheduler.scheduler' in source:\n        module = 'scheduler'\n    else:\n        module = 'resources'\n    rst[module].append(line)\n    self.directive.result.append(self.indent + line, source, *lineno)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef efficiency_capacity_demand_difference(slots, events, X, **kwargs):\n    overflow = 0\n    for row, event in enumerate(events):\n        for col, slot in enumerate(slots):\n            overflow += (event.demand - slot.capacity) * X[row, col]\n    return overflow", "response": "A function that calculates the total difference between demand for an event and the slot capacity it is scheduled in."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef number_of_changes(slots, events, original_schedule, X, **kwargs):\n    changes = 0\n    original_array = schedule_to_array(original_schedule, events=events,\n                                       slots=slots)\n    for row, event in enumerate(original_array):\n        for col, slot in enumerate(event):\n            if slot == 0:\n                changes += X[row, col]\n            else:\n                changes += 1 - X[row, col]\n    return changes", "response": "A function that counts the number of changes between a given schedule and an array of events."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef element_from_neighbourhood(X):\n\n    m, n = X.shape\n    new_X = np.copy(X)\n\n    event_to_move = np.random.randint(m)\n    current_event_slot = np.where(new_X[event_to_move, :] == 1)[0][0]\n\n    slot_to_move_to = np.random.randint(n - 1)\n    if slot_to_move_to >= current_event_slot:\n        slot_to_move_to += 1\n    scheduled_events_in_slot = np.where(new_X[:, slot_to_move_to] == 1)[0]\n\n    if len(scheduled_events_in_slot) == 0:  # No event in that slot\n        new_X[event_to_move] = np.zeros(n)\n        new_X[event_to_move, slot_to_move_to] = 1\n\n    else: # There is an event in that slot\n        swap_rows = [event_to_move, scheduled_events_in_slot[0]]\n        new_X[swap_rows] = new_X[swap_rows[::-1]]\n\n    return new_X", "response": "Randomly move an event to a random slot or to an empty event"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nobtain a random initial array.", "response": "def get_initial_array(events, slots, seed=None):\n    \"\"\"\n    Obtain a random initial array.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n\n    m = len(events)\n    n = len(slots)\n    X = np.zeros((m, n))\n    for i, row in enumerate(X):\n        X[i, i] = 1\n    np.random.shuffle(X)\n    return X"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates bitstream of FCS CRC checksum for given bits.", "response": "def fcs(bits):\n\t'''\n\tAppend running bitwise FCS CRC checksum to end of generator\n\t'''\n\tfcs = FCS()\n\tfor bit in bits:\n\t\tyield bit\n\t\tfcs.update_bit(bit)\n\n#\ttest = bitarray()\n#\tfor byte in (digest & 0xff, digest >> 8):\n#\t\tprint byte\n#\t\tfor i in range(8):\n#\t\t\tb = (byte >> i) & 1 == 1\n#\t\t\ttest.append(b)\n#\t\t\tyield b\n\n\t# append fcs digest to bit stream\n\n\t# n.b. wire format is little-bit-endianness in addition to little-endian\n\tdigest = bitarray(endian=\"little\")\n\tdigest.frombytes(fcs.digest())\n\tfor bit in digest:\n\t\tyield bit"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encode(binary_data):\n\t'''\n\tEncode binary data using Bell-202 AFSK\n\t\n\tExpects a bitarray.bitarray() object of binary data as its argument.\n\tReturns a generator of sound samples suitable for use with the \n\taudiogen module.\n\t'''\n\tframed_data = frame(binary_data)\n\n\t# set volume to 1/2, preceed packet with 1/20 s silence to allow for startup glitches\n\tfor sample in itertools.chain(\n\t\taudiogen.silence(1.05), \n\t\tmultiply(modulate(framed_data), constant(0.5)), \n\t\taudiogen.silence(1.05), \n\t):\n\t\tyield sample", "response": "Encode the given binary data using Bell - 202 AFSK\n\t."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmodulates the AFSK samples for the given symbol generator and produce AFSK samples for the given raw wire symbols.", "response": "def modulate(data):\n\t'''\n\tGenerate Bell 202 AFSK samples for the given symbol generator\n\n\tConsumes raw wire symbols and produces the corresponding AFSK samples. \n\t'''\n\tseconds_per_sample = 1.0 / audiogen.sampler.FRAME_RATE\n\tphase, seconds, bits = 0, 0, 0\n\n\t# construct generators\n\tclock = (x / BAUD_RATE for x in itertools.count(1))\n\ttones = (MARK_HZ if bit else SPACE_HZ for bit in data)\n\n\tfor boundary, frequency in itertools.izip(clock, tones):\n\t\t# frequency of current symbol is determined by how much \n\t\t# we advance the signal's phase in each audio frame\n\t\tphase_change_per_sample = TWO_PI / (audiogen.sampler.FRAME_RATE / frequency)\n\n\t\t# produce samples for the current symbol \n\t\t# until we reach the next clock boundary\n\t\twhile seconds < boundary:\n\t\t\tyield math.sin(phase)\n\n\t\t\tseconds += seconds_per_sample\n\t\t\tphase += phase_change_per_sample\n\n\t\t\tif phase > TWO_PI:\n\t\t\t\tphase -= TWO_PI\n\n\t\tbits += 1\n\t\tlogger.debug(\"bits = %d, time = %.7f ms, expected time = %.7f ms, error = %.7f ms, baud rate = %.6f Hz\" \\\n\t\t\t% (bits, 1000 * seconds, 1000 * bits / BAUD_RATE, 1000 * (seconds - bits / BAUD_RATE), bits / seconds))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npacketing uses NRZI (non-return to zero inverted) encoding, which means that a 0 is encoded as a change in tone, and a 1 is encoded as no change in tone.", "response": "def nrzi(data):\n\t'''\n\tPacket uses NRZI (non-return to zero inverted) encoding, which means \n\tthat a 0 is encoded as a change in tone, and a 1 is encoded as \n\tno change in tone.\n\t'''\n\tcurrent = True\n\tfor bit in data:\n\t\tif not bit:\n\t\t\tcurrent = not current \n\t\tyield current"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_sync(self, url):\n        response = self.session.get(url)\n        if response.status_code == requests.codes.ok:\n            return response.json()\n        else:\n            raise HTTPError", "response": "Internal method used for GET requests to retrieve the information about the specified Individual URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_item(self, item_id, expand=False):\n        url = urljoin(self.item_url, F\"{item_id}.json\")\n        response = self._get_sync(url)\n\n        if not response:\n            raise InvalidItemID\n\n        item = Item(response)\n        if expand:\n            item.by = self.get_user(item.by)\n            item.kids = self.get_items_by_ids(item.kids) if item.kids else None\n            item.parent = self.get_item(item.parent) if item.parent else None\n            item.poll = self.get_item(item.poll) if item.poll else None\n            item.parts = (\n                self.get_items_by_ids(item.parts) if item.parts else None\n            )\n\n        return item", "response": "Fetches the data from the Hacker News item API."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a list of item ids return all the Item objects for that list of item IDs and item type", "response": "def get_items_by_ids(self, item_ids, item_type=None):\n        \"\"\"Given a list of item ids, return all the Item objects\n\n        Args:\n            item_ids (obj): List of item IDs to query\n            item_type (str): (optional) Item type to filter results with\n\n        Returns:\n            List of `Item` objects for given item IDs and given item type\n\n        \"\"\"\n        urls = [urljoin(self.item_url, F\"{i}.json\") for i in item_ids]\n        result = self._run_async(urls=urls)\n        items = [Item(r) for r in result if r]\n        if item_type:\n            return [item for item in items if item.item_type == item_type]\n        else:\n            return items"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_user(self, user_id, expand=False):\n        url = urljoin(self.user_url, F\"{user_id}.json\")\n        response = self._get_sync(url)\n\n        if not response:\n            raise InvalidUserID\n\n        user = User(response)\n        if expand and user.submitted:\n            items = self.get_items_by_ids(user.submitted)\n            user_opt = {\n                'stories': 'story',\n                'comments': 'comment',\n                'jobs': 'job',\n                'polls': 'poll',\n                'pollopts': 'pollopt'\n            }\n            for key, value in user_opt.items():\n                setattr(\n                    user,\n                    key,\n                    [i for i in items if i.item_type == value]\n                )\n\n        return user", "response": "Fetches a user from the Hacker News API and returns a User object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_users_by_ids(self, user_ids):\n        urls = [urljoin(self.user_url, F\"{i}.json\") for i in user_ids]\n        result = self._run_async(urls=urls)\n        return [User(r) for r in result if r]", "response": "Given a list of user ids return all the User objects that match the given list of user ids"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef top_stories(self, raw=False, limit=None):\n        top_stories = self._get_stories('topstories', limit)\n        if raw:\n            top_stories = [story.raw for story in top_stories]\n        return top_stories", "response": "Returns a list of item ids of current top stories."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning list of item ids of current new stories.", "response": "def new_stories(self, raw=False, limit=None):\n        \"\"\"Returns list of item ids of current new stories\n\n        Args:\n            limit (int): specifies the number of stories to be returned.\n            raw (bool): Flag to indicate whether to transform all\n                objects into raw json.\n\n        Returns:\n            `list` object containing ids of new stories.\n\n        \"\"\"\n        new_stories = self._get_stories('newstories', limit)\n        if raw:\n            new_stories = [story.raw for story in new_stories]\n        return new_stories"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns list of item ids of latest Ask HN stories.", "response": "def ask_stories(self, raw=False, limit=None):\n        \"\"\"Returns list of item ids of latest Ask HN stories\n\n        Args:\n            limit (int): specifies the number of stories to be returned.\n            raw (bool): Flag to indicate whether to transform all\n                objects into raw json.\n\n        Returns:\n            `list` object containing ids of Ask HN stories.\n\n        \"\"\"\n        ask_stories = self._get_stories('askstories', limit)\n        if raw:\n            ask_stories = [story.raw for story in ask_stories]\n        return ask_stories"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn list of item ids of latest Show HN stories.", "response": "def show_stories(self, raw=False, limit=None):\n        \"\"\"Returns list of item ids of latest Show HN stories\n\n        Args:\n            limit (int): specifies the number of stories to be returned.\n            raw (bool): Flag to indicate whether to transform all\n                objects into raw json.\n\n        Returns:\n            `list` object containing ids of Show HN stories.\n\n        \"\"\"\n        show_stories = self._get_stories('showstories', limit)\n        if raw:\n            show_stories = [story.raw for story in show_stories]\n        return show_stories"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns list of item ids of latest Job stories.", "response": "def job_stories(self, raw=False, limit=None):\n        \"\"\"Returns list of item ids of latest Job stories\n\n        Args:\n            limit (int): specifies the number of stories to be returned.\n            raw (bool): Flag to indicate whether to transform all\n                objects into raw json.\n\n        Returns:\n            `list` object containing ids of Job stories.\n\n        \"\"\"\n        job_stories = self._get_stories('jobstories', limit)\n        if raw:\n            job_stories = [story.raw for story in job_stories]\n        return job_stories"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn list of item ids and user ids that have been changed / updated recently.", "response": "def updates(self):\n        \"\"\"Returns list of item ids and user ids that have been\n        changed/updated recently.\n\n        Fetches data from URL:\n            https://hacker-news.firebaseio.com/v0/updates.json\n\n        Returns:\n            `dict` with two keys whose values are `list` objects\n\n        \"\"\"\n        url = urljoin(self.base_url, 'updates.json')\n        response = self._get_sync(url)\n        return {\n            'items': self.get_items_by_ids(item_ids=response['items']),\n            'profiles': self.get_users_by_ids(user_ids=response['profiles'])\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_max_item(self, expand=False):\n        url = urljoin(self.base_url, 'maxitem.json')\n        response = self._get_sync(url)\n        if expand:\n            return self.get_item(response)\n        else:\n            return response", "response": "Gets the current largest item id."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_last(self, num=10):\n        max_item = self.get_max_item()\n        urls = [urljoin(self.item_url, F\"{i}.json\") for i in range(\n            max_item - num + 1, max_item + 1)]\n        result = self._run_async(urls=urls)\n        return [Item(r) for r in result if r]", "response": "Download all the HN articles and return them as Item objects"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(self, path):\n        self.dct = wrapper.Dictionary.load(path)\n        return self", "response": "Loads a DAWG from a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn all variants of key in this DAWG according to replaces.", "response": "def similar_keys(self, key, replaces):\n        \"\"\"\n        Returns all variants of ``key`` in this DAWG according to\n        ``replaces``.\n\n        ``replaces`` is an object obtained from\n        ``DAWG.compile_replaces(mapping)`` where mapping is a dict\n        that maps single-char unicode sitrings to another single-char\n        unicode strings.\n\n        This may be useful e.g. for handling single-character umlauts.\n        \"\"\"\n        return self._similar_keys(\"\", key, self.dct.ROOT, replaces)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prefixes(self, key):\n        '''\n        Returns a list with keys of this DAWG that are prefixes of the ``key``.\n        '''\n        res = []\n        index = self.dct.ROOT\n        if not isinstance(key, bytes):\n            key = key.encode('utf8')\n\n        pos = 1\n\n        for ch in key:\n            index = self.dct.follow_char(int_from_byte(ch), index)\n            if not index:\n                break\n\n            if self._has_value(index):\n                res.append(key[:pos].decode('utf8'))\n            pos += 1\n\n        return res", "response": "Returns a list with keys of this DAWG that are prefixes of the key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload a DAWG from a file.", "response": "def load(self, path):\n        \"\"\"\n        Loads DAWG from a file.\n        \"\"\"\n        self.dct = wrapper.Dictionary()\n        self.guide = wrapper.Guide()\n\n        with open(path, 'rb') as f:\n            self.dct.read(f)\n            self.guide.read(f)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, key, default=None):\n        if not isinstance(key, bytes):\n            key = key.encode('utf8')\n\n        return self.b_get_value(key) or default", "response": "Returns a list of payloads for a given key."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of tuples for all variants of key and value that are similar to the key in this DAWG.", "response": "def similar_items(self, key, replaces):\n        \"\"\"\n        Returns a list of (key, value) tuples for all variants of ``key``\n        in this DAWG according to ``replaces``.\n\n        ``replaces`` is an object obtained from\n        ``DAWG.compile_replaces(mapping)`` where mapping is a dict\n        that maps single-char unicode sitrings to another single-char\n        unicode strings.\n        \"\"\"\n        return self._similar_items(\"\", key, self.dct.ROOT, replaces)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of values for all variants of the key that are similar to the key in this DAWG.", "response": "def similar_item_values(self, key, replaces):\n        \"\"\"\n        Returns a list of values for all variants of the ``key``\n        in this DAWG according to ``replaces``.\n\n        ``replaces`` is an object obtained from\n        ``DAWG.compile_replaces(mapping)`` where mapping is a dict\n        that maps single-char unicode sitrings to another single-char\n        unicode strings.\n        \"\"\"\n        return self._similar_item_values(0, key, self.dct.ROOT, replaces)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef value(self, index):\n        \"Gets a value from a given index.\"\n        offset = units.offset(self._units[index])\n        value_index = (index ^ offset) & units.PRECISION_MASK\n        return units.value(self._units[value_index])", "response": "Gets a value from a given index."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread a dictionary from an input stream.", "response": "def read(self, fp):\n        \"Reads a dictionary from an input stream.\"\n        base_size = struct.unpack(str(\"=I\"), fp.read(4))[0]\n        self._units.fromfile(fp, base_size)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find(self, key):\n        \"Exact matching (returns value)\"\n        index = self.follow_bytes(key, self.ROOT)\n        if index is None:\n            return -1\n        if not self.has_value(index):\n            return -1\n        return self.value(index)", "response": "Exact matching ( returns value )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the next key", "response": "def next(self):\n        \"Gets the next key\"\n\n        if not self._index_stack:\n            return False\n\n        index = self._index_stack[-1]\n\n        if self._last_index != self._dic.ROOT:\n\n            child_label = self._guide.child(index)  # UCharType\n\n            if child_label:\n                # Follows a transition to the first child.\n                index = self._follow(child_label, index)\n                if index is None:\n                    return False\n            else:\n                while True:\n                    sibling_label = self._guide.sibling(index)\n                    # Moves to the previous node.\n                    if len(self.key) > 0:\n                        self.key.pop()\n                        #self.key[-1] = 0\n\n                    self._index_stack.pop()\n                    if not self._index_stack:\n                        return False\n\n                    index = self._index_stack[-1]\n                    if sibling_label:\n                        # Follows a transition to the next sibling.\n                        index = self._follow(sibling_label, index)\n                        if index is None:\n                            return False\n                        break\n\n        return self._find_terminal(index)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert_response(check_response, project_id):\n    if not check_response or not check_response.checkErrors:\n        return _IS_OK\n\n    # only check the first error for now, as per ESP\n    theError = check_response.checkErrors[0]\n    error_tuple = _CHECK_ERROR_CONVERSION.get(theError.code, _IS_UNKNOWN)\n    if error_tuple[1].find(u'{') == -1:  # no replacements needed:\n        return error_tuple\n\n    updated_msg = error_tuple[1].format(project_id=project_id, detail=theError.detail or u'')\n    return error_tuple[0], updated_msg, error_tuple[2]", "response": "Converts a CheckResponse to a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a secure hash for an operation in a CheckRequest.", "response": "def sign(check_request):\n    \"\"\"Obtains a signature for an operation in a `CheckRequest`\n\n    Args:\n       op (:class:`endpoints_management.gen.servicecontrol_v1_messages.Operation`): an\n         operation used in a `CheckRequest`\n\n    Returns:\n       string: a secure hash generated from the operation\n    \"\"\"\n    if not isinstance(check_request, sc_messages.CheckRequest):\n        raise ValueError(u'Invalid request')\n    op = check_request.operation\n    if op is None or op.operationName is None or op.consumerId is None:\n        logging.error(u'Bad %s: not initialized => not signed', check_request)\n        raise ValueError(u'check request must be initialized with an operation')\n    md5 = hashlib.md5()\n    md5.update(op.operationName.encode('utf-8'))\n    md5.update(b'\\x00')\n    md5.update(op.consumerId.encode('utf-8'))\n    if op.labels:\n        signing.add_dict_to_hash(md5, encoding.MessageToPyValue(op.labels))\n    for value_set in op.metricValueSets:\n        md5.update(b'\\x00')\n        md5.update(value_set.metricName.encode('utf-8'))\n        for mv in value_set.metricValues:\n            metric_value.update_hash(md5, mv)\n\n    md5.update(b'\\x00')\n    if op.quotaProperties:\n        # N.B: this differs form cxx implementation, which serializes the\n        # protobuf. This should be OK as the exact hash used does not need to\n        # match across implementations.\n        md5.update(repr(op.quotaProperties).encode('utf-8'))\n\n    md5.update(b'\\x00')\n    return md5.digest()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake a ServicecontrolServicesCheckRequest from this instance.", "response": "def as_check_request(self, timer=datetime.utcnow):\n        \"\"\"Makes a `ServicecontrolServicesCheckRequest` from this instance\n\n        Returns:\n          a ``ServicecontrolServicesCheckRequest``\n\n        Raises:\n          ValueError: if the fields in this instance are insufficient to\n            to create a valid ``ServicecontrolServicesCheckRequest``\n\n        \"\"\"\n        if not self.service_name:\n            raise ValueError(u'the service name must be set')\n        if not self.operation_id:\n            raise ValueError(u'the operation id must be set')\n        if not self.operation_name:\n            raise ValueError(u'the operation name must be set')\n        op = super(Info, self).as_operation(timer=timer)\n        labels = {}\n        if self.android_cert_fingerprint:\n            labels[_KNOWN_LABELS.SCC_ANDROID_CERT_FINGERPRINT.label_name] = self.android_cert_fingerprint\n\n        if self.android_package_name:\n            labels[_KNOWN_LABELS.SCC_ANDROID_PACKAGE_NAME.label_name] = self.android_package_name\n\n        if self.client_ip:\n            labels[_KNOWN_LABELS.SCC_CALLER_IP.label_name] = self.client_ip\n\n        if self.ios_bundle_id:\n            labels[_KNOWN_LABELS.SCC_IOS_BUNDLE_ID.label_name] = self.ios_bundle_id\n\n        if self.referer:\n            labels[_KNOWN_LABELS.SCC_REFERER.label_name] = self.referer\n\n        # Forcibly add system label reporting here, as the base service\n        # config does not specify it as a label.\n        labels[_KNOWN_LABELS.SCC_SERVICE_AGENT.label_name] = SERVICE_AGENT\n        labels[_KNOWN_LABELS.SCC_USER_AGENT.label_name] = USER_AGENT\n\n        op.labels = encoding.PyValueToMessage(\n            sc_messages.Operation.LabelsValue, labels)\n        check_request = sc_messages.CheckRequest(operation=op)\n        return sc_messages.ServicecontrolServicesCheckRequest(\n            serviceName=self.service_name,\n            checkRequest=check_request)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flush(self):\n        if self._cache is None:\n            return []\n        with self._cache as c:\n            flushed_items = list(c.out_deque)\n            c.out_deque.clear()\n            cached_reqs = [item.extract_request() for item in flushed_items]\n            cached_reqs = [req for req in cached_reqs if req is not None]\n            return cached_reqs", "response": "Flushes this instance s cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear(self):\n        if self._cache is not None:\n            with self._cache as c:\n                c.clear()\n                c.out_deque.clear()", "response": "Clears this instance s cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_response(self, req, resp):\n        if self._cache is None:\n            return\n        signature = sign(req.checkRequest)\n        with self._cache as c:\n            now = self._timer()\n            quota_scale = 0  # WIP\n            item = c.get(signature)\n            if item is None:\n                c[signature] = CachedItem(\n                    resp, self.service_name, now, quota_scale)\n            else:\n                # Update the cached item to reflect that it is updated\n                item.last_check_time = now\n                item.response = resp\n                item.quota_scale = quota_scale\n                item.is_flushing = False\n                c[signature] = item", "response": "Adds the response from sending to req to this instance s cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the request is in the cache and returns a CheckResponse.", "response": "def check(self, req):\n        \"\"\"Determine if ``req`` is in this instances cache.\n\n        Determine if there are cache hits for the request in this aggregator\n        instance.\n\n        Not in the cache\n\n        If req is not in the cache, it returns ``None`` to indicate that the\n        caller should send the request.\n\n        Cache Hit; response has errors\n\n        When a cached CheckResponse has errors, it's assumed that ``req`` would\n        fail as well, so the cached CheckResponse is returned.  However, the\n        first CheckRequest after the flush interval has elapsed should be sent\n        to the server to refresh the CheckResponse, though until it's received,\n        subsequent CheckRequests should fail with the cached CheckResponse.\n\n        Cache behaviour - response passed\n\n        If the cached CheckResponse has no errors, it's assumed that ``req``\n        will succeed as well, so the CheckResponse is returned, with the quota\n        info updated to the same as requested.  The requested tokens are\n        aggregated until flushed.\n\n        Args:\n          req (``ServicecontrolServicesCheckRequest``): to be sent to\n            the service control service\n\n        Raises:\n           ValueError: if the ``req`` service_name is not the same as\n             this instances\n\n        Returns:\n           ``CheckResponse``: if an applicable response is cached by this\n             instance is available for use or None, if there is no applicable\n             response\n\n        \"\"\"\n        if self._cache is None:\n            return None  # no cache, send request now\n        if not isinstance(req, sc_messages.ServicecontrolServicesCheckRequest):\n            raise ValueError(u'Invalid request')\n        if req.serviceName != self.service_name:\n            _logger.error(u'bad check(): service_name %s does not match ours %s',\n                          req.serviceName, self.service_name)\n            raise ValueError(u'Service name mismatch')\n        check_request = req.checkRequest\n        if check_request is None:\n            _logger.error(u'bad check(): no check_request in %s', req)\n            raise ValueError(u'Expected operation not set')\n        op = check_request.operation\n        if op is None:\n            _logger.error(u'bad check(): no operation in %s', req)\n            raise ValueError(u'Expected operation not set')\n        if op.importance != sc_messages.Operation.ImportanceValueValuesEnum.LOW:\n            return None  # op is important, send request now\n\n        signature = sign(check_request)\n        with self._cache as cache:\n            _logger.debug(u'checking the cache for %r\\n%s', signature, cache)\n            item = cache.get(signature)\n            if item is None:\n                return None  # signal to caller to send req\n            else:\n                return self._handle_cached_response(req, item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compare(a, b):\n    a_is_text = isinstance(a, basestring)\n    b_is_text = isinstance(b, basestring)\n    if type(a) != type(b) and not (a_is_text and b_is_text):\n        _logger.error(u'Cannot compare %s to %s, types differ %s!=%s',\n                      a, b, type(a), type(b))\n        raise ValueError(u'cannot compare inputs of differing types')\n\n    if a_is_text:\n        a = from_rfc3339(a, with_nanos=True)\n        b = from_rfc3339(b, with_nanos=True)\n\n    if a < b:\n        return -1\n    elif a > b:\n        return 1\n    else:\n        return 0", "response": "Compares two timestamps.\n\n    ``a`` and ``b`` must be the same type, in addition to normal\n    representations of timestamps that order naturally, they can be rfc3339\n    formatted strings.\n\n    Args:\n      a (string|object): a timestamp\n      b (string|object): another timestamp\n\n    Returns:\n      int: -1 if a < b, 0 if a == b or 1 if a > b\n\n    Raises:\n      ValueError: if a or b are not the same type\n      ValueError: if a or b strings but not in valid rfc3339 format"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_rfc3339(timestamp):\n    if isinstance(timestamp, datetime.datetime):\n        timestamp = timestamp - _EPOCH_START\n    if not isinstance(timestamp, datetime.timedelta):\n        _logger.error(u'Could not convert %s to a rfc3339 time,', timestamp)\n        raise ValueError(u'Invalid timestamp type')\n    return strict_rfc3339.timestamp_to_rfc3339_utcoffset(\n        timestamp.total_seconds())", "response": "Converts a datetime. datetime object to an RFC 3339 date string format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a RFC 3339 date string format to a datetime. date object.", "response": "def from_rfc3339(rfc3339_text, with_nanos=False):\n    \"\"\"Parse a RFC 3339 date string format to datetime.date.\n\n    Example of accepted format: '1972-01-01T10:00:20.021-05:00'\n\n    - By default, the result is a datetime.datetime\n    - If with_nanos is true, the result is a 2-tuple, (datetime.datetime,\n    nanos), where the second field represents the possible nanosecond\n    resolution component of the second field.\n\n    Args:\n      rfc3339_text (string): An rfc3339 formatted date string\n      with_nanos (bool): Determines if nanoseconds should be parsed from the\n        string\n\n    Raises:\n      ValueError: if ``rfc3339_text`` is invalid\n\n    Returns:\n      :class:`datetime.datetime`: when with_nanos is False\n      tuple(:class:`datetime.datetime`, int): when with_nanos is True\n\n    \"\"\"\n    timestamp = strict_rfc3339.rfc3339_to_timestamp(rfc3339_text)\n    result = datetime.datetime.utcfromtimestamp(timestamp)\n    if with_nanos:\n        return (result, int((timestamp - int(timestamp)) * 1e9))\n    else:\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef as_operation(self, timer=datetime.utcnow):\n        now = timer()\n        op = sc_messages.Operation(\n            endTime=timestamp.to_rfc3339(now),\n            startTime=timestamp.to_rfc3339(now),\n            importance=sc_messages.Operation.ImportanceValueValuesEnum.LOW)\n        if self.operation_id:\n            op.operationId = self.operation_id\n        if self.operation_name:\n            op.operationName = self.operation_name\n        if self.api_key and self.api_key_valid:\n            op.consumerId = u'api_key:' + self.api_key\n        elif self.consumer_project_id:\n            op.consumerId = u'project:' + self.consumer_project_id\n        return op", "response": "Makes an Operation from this instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nobtain a single Operation representing this instances contents.", "response": "def as_operation(self):\n        \"\"\"Obtains a single `Operation` representing this instances contents.\n\n        Returns:\n           :class:`endpoints_management.gen.servicecontrol_v1_messages.Operation`\n        \"\"\"\n        result = encoding.CopyProtoMessage(self._op)\n        names = sorted(self._metric_values_by_name_then_sign.keys())\n        for name in names:\n            mvs = self._metric_values_by_name_then_sign[name]\n            result.metricValueSets.append(\n                sc_messages.MetricValueSet(\n                    metricName=name, metricValues=mvs.values()))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncombines other_op with the operation held by this aggregator.", "response": "def add(self, other_op):\n        \"\"\"Combines `other_op` with the operation held by this aggregator.\n\n        N.B. It merges the operations log entries and metric values, but makes\n        the assumption the operation is consistent.  It's the callers\n        responsibility to ensure consistency\n\n        Args:\n           other_op (\n             class:`endpoints_management.gen.servicecontrol_v1_messages.Operation`):\n             an operation merge into this one\n\n        \"\"\"\n        self._op.logEntries.extend(other_op.logEntries)\n        self._merge_timestamps(other_op)\n        self._merge_metric_values(other_op)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_exponential(num_finite_buckets, growth_factor, scale):\n    if num_finite_buckets <= 0:\n        raise ValueError(_BAD_NUM_FINITE_BUCKETS)\n    if growth_factor <= 1.0:\n        raise ValueError(_BAD_FLOAT_ARG % (u'growth factor', 1.0))\n    if scale <= 0.0:\n        raise ValueError(_BAD_FLOAT_ARG % (u'scale', 0.0))\n    return sc_messages.Distribution(\n        bucketCounts=[0] * (num_finite_buckets + 2),\n        exponentialBuckets=sc_messages.ExponentialBuckets(\n            numFiniteBuckets=num_finite_buckets,\n            growthFactor=growth_factor,\n            scale=scale))", "response": "Creates an instance of distribution with exponential buckets."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_linear(num_finite_buckets, width, offset):\n    if num_finite_buckets <= 0:\n        raise ValueError(_BAD_NUM_FINITE_BUCKETS)\n    if width <= 0.0:\n        raise ValueError(_BAD_FLOAT_ARG % (u'width', 0.0))\n    return sc_messages.Distribution(\n        bucketCounts=[0] * (num_finite_buckets + 2),\n        linearBuckets=sc_messages.LinearBuckets(\n            numFiniteBuckets=num_finite_buckets,\n            width=width,\n            offset=offset))", "response": "Creates a new instance of distribution with linear buckets."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an explicit distribution with explicit buckets.", "response": "def create_explicit(bounds):\n    \"\"\"Creates a new instance of distribution with explicit buckets.\n\n    bounds is an iterable of ordered floats that define the explicit buckets\n\n    Args:\n       bounds (iterable[float]): initializes the bounds\n\n    Return:\n       :class:`endpoints_management.gen.servicecontrol_v1_messages.Distribution`\n\n    Raises:\n       ValueError: if the args are invalid for creating an instance\n    \"\"\"\n    safe_bounds = sorted(float(x) for x in bounds)\n    if len(safe_bounds) != len(set(safe_bounds)):\n        raise ValueError(u'Detected two elements of bounds that are the same')\n    return sc_messages.Distribution(\n        bucketCounts=[0] * (len(safe_bounds) + 1),\n        explicitBuckets=sc_messages.ExplicitBuckets(bounds=safe_bounds))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a sample to the current distribution and updates its existing buckets.", "response": "def add_sample(a_float, dist):\n    \"\"\"Adds `a_float` to `dist`, updating its existing buckets.\n\n    Args:\n      a_float (float): a new value\n      dist (:class:`endpoints_management.gen.servicecontrol_v1_messages.Distribution`):\n        the Distribution being updated\n\n    Raises:\n      ValueError: if `dist` does not have known bucket options defined\n      ValueError: if there are not enough bucket count fields in `dist`\n    \"\"\"\n    dist_type, _ = _detect_bucket_option(dist)\n    if dist_type == u'exponentialBuckets':\n        _update_general_statistics(a_float, dist)\n        _update_exponential_bucket_count(a_float, dist)\n    elif dist_type == u'linearBuckets':\n        _update_general_statistics(a_float, dist)\n        _update_linear_bucket_count(a_float, dist)\n    elif dist_type == u'explicitBuckets':\n        _update_general_statistics(a_float, dist)\n        _update_explicit_bucket_count(a_float, dist)\n    else:\n        _logger.error(u'Could not determine bucket option type for %s', dist)\n        raise ValueError(u'Unknown bucket option type')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef merge(prior, latest):\n    if not _buckets_nearly_equal(prior, latest):\n        _logger.error(u'Bucket options do not match. From %s To: %s',\n                      prior,\n                      latest)\n        raise ValueError(u'Bucket options do not match')\n    if len(prior.bucketCounts) != len(latest.bucketCounts):\n        _logger.error(u'Bucket count sizes do not match. From %s To: %s',\n                      prior,\n                      latest)\n        raise ValueError(u'Bucket count sizes do not match')\n    if prior.count <= 0:\n        return\n\n    old_count = latest.count\n    old_mean = latest.mean\n    old_summed_variance = latest.sumOfSquaredDeviation\n    bucket_counts = latest.bucketCounts\n\n    # Update the latest\n    latest.count += prior.count\n    latest.maximum = max(prior.maximum, latest.maximum)\n    latest.minimum = min(prior.minimum, latest.minimum)\n    latest.mean = ((old_count * old_mean + prior.count * prior.mean) /\n                   latest.count)\n    latest.sumOfSquaredDeviation = (\n        old_summed_variance + prior.sumOfSquaredDeviation +\n        old_count * (latest.mean - old_mean) ** 2 +\n        prior.count * (latest.mean - prior.mean) ** 2)\n    for i, (x, y) in enumerate(zip(prior.bucketCounts, bucket_counts)):\n        bucket_counts[i] = x + y", "response": "Merges prior into latest."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine if two Distributions are approximately equal.", "response": "def _buckets_nearly_equal(a_dist, b_dist):\n    \"\"\"Determines whether two `Distributions` are nearly equal.\n\n    Args:\n      a_dist (:class:`Distribution`): an instance\n      b_dist (:class:`Distribution`): another instance\n\n    Return:\n      boolean: `True` if the two instances are approximately equal, otherwise\n        False\n\n    \"\"\"\n    a_type, a_buckets = _detect_bucket_option(a_dist)\n    b_type, b_buckets = _detect_bucket_option(b_dist)\n    if a_type != b_type:\n        return False\n    elif a_type == u'linearBuckets':\n        return _linear_buckets_nearly_equal(a_buckets, b_buckets)\n    elif a_type == u'exponentialBuckets':\n        return _exponential_buckets_nearly_equal(a_buckets, b_buckets)\n    elif a_type == u'explicitBuckets':\n        return _explicit_buckets_nearly_equal(a_buckets, b_buckets)\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _update_general_statistics(a_float, dist):\n    if not dist.count:\n        dist.count = 1\n        dist.maximum = a_float\n        dist.minimum = a_float\n        dist.mean = a_float\n        dist.sumOfSquaredDeviation = 0\n    else:\n        old_count = dist.count\n        old_mean = dist.mean\n        new_mean = ((old_count * old_mean) + a_float) / (old_count + 1)\n        delta_sum_squares = (a_float - old_mean) * (a_float - new_mean)\n        dist.count += 1\n        dist.mean = new_mean\n        dist.maximum = max(a_float, dist.maximum)\n        dist.minimum = min(a_float, dist.minimum)\n        dist.sumOfSquaredDeviation += delta_sum_squares", "response": "Adds a_float to the distribution and updates the statistics fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _update_exponential_bucket_count(a_float, dist):\n    buckets = dist.exponentialBuckets\n    if buckets is None:\n        raise ValueError(_BAD_UNSET_BUCKETS % (u'exponential buckets'))\n    bucket_counts = dist.bucketCounts\n    num_finite_buckets = buckets.numFiniteBuckets\n    if len(bucket_counts) < num_finite_buckets + 2:\n        raise ValueError(_BAD_LOW_BUCKET_COUNT)\n    scale = buckets.scale\n    factor = buckets.growthFactor\n    if (a_float <= scale):\n        index = 0\n    else:\n        index = 1 + int((math.log(a_float / scale) / math.log(factor)))\n        index = min(index, num_finite_buckets + 1)\n    bucket_counts[index] += 1\n    _logger.debug(u'scale:%f, factor:%f, sample:%f, index:%d',\n                  scale, factor, a_float, index)", "response": "Adds a_float to dist updating its exponential buckets."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a_float to dist updating the linear buckets count field.", "response": "def _update_linear_bucket_count(a_float, dist):\n    \"\"\"Adds `a_float` to `dist`, updating the its linear buckets.\n\n    Args:\n      a_float (float): a new value\n      dist (:class:`endpoints_management.gen.servicecontrol_v1_messages.Distribution`):\n        the Distribution being updated\n\n    Raises:\n      ValueError: if `dist` does not already have linear buckets defined\n      ValueError: if there are not enough bucket count fields in `dist`\n    \"\"\"\n    buckets = dist.linearBuckets\n    if buckets is None:\n        raise ValueError(_BAD_UNSET_BUCKETS % (u'linear buckets'))\n    bucket_counts = dist.bucketCounts\n    num_finite_buckets = buckets.numFiniteBuckets\n    if len(bucket_counts) < num_finite_buckets + 2:\n        raise ValueError(_BAD_LOW_BUCKET_COUNT)\n    width = buckets.width\n    lower = buckets.offset\n    upper = lower + (num_finite_buckets * width)\n    if a_float < lower:\n        index = 0\n    elif a_float >= upper:\n        index = num_finite_buckets + 1\n    else:\n        index = 1 + int(((a_float - lower) / width))\n    bucket_counts[index] += 1\n    _logger.debug(u'upper:%f, lower:%f, width:%f, sample:%f, index:%d',\n                  upper, lower, width, a_float, index)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a_float to dist updating its explicit buckets.", "response": "def _update_explicit_bucket_count(a_float, dist):\n    \"\"\"Adds `a_float` to `dist`, updating its explicit buckets.\n\n    Args:\n      a_float (float): a new value\n      dist (:class:`endpoints_management.gen.servicecontrol_v1_messages.Distribution`):\n        the Distribution being updated\n\n    Raises:\n      ValueError: if `dist` does not already have explict buckets defined\n      ValueError: if there are not enough bucket count fields in `dist`\n    \"\"\"\n    buckets = dist.explicitBuckets\n    if buckets is None:\n        raise ValueError(_BAD_UNSET_BUCKETS % (u'explicit buckets'))\n    bucket_counts = dist.bucketCounts\n    bounds = buckets.bounds\n    if len(bucket_counts) < len(bounds) + 1:\n        raise ValueError(_BAD_LOW_BUCKET_COUNT)\n    bucket_counts[bisect.bisect(bounds, a_float)] += 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nenter a new event at an absolute time.", "response": "def enterabs(self, time, priority, action, argument=(), kwargs=_sentinel):\n        \"\"\"Enter a new event in the queue at an absolute time.\n\n        Returns an ID for the event which can be used to remove it,\n        if necessary.\n\n        \"\"\"\n        if kwargs is _sentinel:\n            kwargs = {}\n        event = Event(time, priority, action, argument, kwargs)\n        with self._lock:\n            heapq.heappush(self._queue, event)\n        return event"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cancel(self, event):\n        with self._lock:\n            self._queue.remove(event)\n            heapq.heapify(self._queue)", "response": "Cancel an event from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexecutes the scheduled events until the queue is empty and return the deadline of the next scheduled call in the scheduler.", "response": "def run(self, blocking=True):\n        \"\"\"Execute events until the queue is empty.\n        If blocking is False executes the scheduled events due to\n        expire soonest (if any) and then return the deadline of the\n        next scheduled call in the scheduler.\n\n        When there is a positive delay until the first event, the\n        delay function is called and the event is left in the queue;\n        otherwise, the event is removed from the queue and executed\n        (its action function is called, passing it the argument).  If\n        the delay function returns prematurely, it is simply\n        restarted.\n\n        It is legal for both the delay function and the action\n        function to modify the queue or to raise an exception;\n        exceptions are not caught but the scheduler's state remains\n        well-defined so run() may be called again.\n\n        A questionable hack is added to allow other threads to run:\n        just after an event is executed, a delay of 0 is executed, to\n        avoid monopolizing the CPU when other threads are also\n        runnable.\n\n        \"\"\"\n        # localize variable access to minimize overhead\n        # and to improve thread safety\n        lock = self._lock\n        q = self._queue\n        delayfunc = self.delayfunc\n        timefunc = self.timefunc\n        pop = heapq.heappop\n        while True:\n            with lock:\n                if not q:\n                    break\n                time, priority, action, argument, kwargs = q[0]\n                now = timefunc()\n                if time > now:\n                    delay = True\n                else:\n                    delay = False\n                    pop(q)\n            if delay:\n                if not blocking:\n                    return time - now\n                delayfunc(time - now)\n            else:\n                action(*argument, **kwargs)\n                delayfunc(0)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_valid(money):\n    if not isinstance(money, sc_messages.Money):\n        raise ValueError(u'Inputs should be of type %s' % (sc_messages.Money,))\n    currency = money.currencyCode\n    if not currency or len(currency) != 3:\n        raise ValueError(_MSG_3_LETTERS_LONG)\n    units = money.units\n    nanos = money.nanos\n    if ((units > 0) and (nanos < 0)) or ((units < 0) and (nanos > 0)):\n        raise ValueError(_MSG_UNITS_NANOS_MISMATCH)\n    if abs(nanos) > MAX_NANOS:\n        raise ValueError(_MSG_NANOS_OOB)", "response": "Checks if an instance of Money is valid."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding two instances of Money to the internal list of services.", "response": "def add(a, b, allow_overflow=False):\n    \"\"\"Adds two instances of `Money`.\n\n    Args:\n      a (:class:`endpoints_management.gen.servicecontrol_v1_messages.Money`): one money\n        value\n      b (:class:`endpoints_management.gen.servicecontrol_v1_messages.Money`): another\n        money value\n      allow_overflow: determines if the addition is allowed to overflow\n\n    Return:\n      `Money`: an instance of Money\n\n    Raises:\n      ValueError: if the inputs do not have the same currency code\n      OverflowError: if the sum overflows and allow_overflow is not `True`\n    \"\"\"\n    for m in (a, b):\n        if not isinstance(m, sc_messages.Money):\n            raise ValueError(u'Inputs should be of type %s' % (sc_messages.Money,))\n    if a.currencyCode != b.currencyCode:\n        raise ValueError(u'Money values need the same currency to be summed')\n    nano_carry, nanos_sum = _sum_nanos(a, b)\n    units_sum_no_carry = a.units + b.units\n    units_sum = units_sum_no_carry + nano_carry\n\n    # Adjust when units_sum and nanos_sum have different signs\n    if units_sum > 0 and nanos_sum < 0:\n        units_sum -= 1\n        nanos_sum += _BILLION\n    elif units_sum < 0 and nanos_sum > 0:\n        units_sum += 1\n        nanos_sum -= _BILLION\n\n    # Return the result, detecting overflow if it occurs\n    sign_a = _sign_of(a)\n    sign_b = _sign_of(b)\n    if sign_a > 0 and sign_b > 0 and units_sum >= _INT64_MAX:\n        if not allow_overflow:\n            raise OverflowError(u'Money addition positive overflow')\n        else:\n            return sc_messages.Money(units=_INT64_MAX,\n                                     nanos=MAX_NANOS,\n                                     currencyCode=a.currencyCode)\n    elif (sign_a < 0 and sign_b < 0 and\n          (units_sum_no_carry <= -_INT64_MAX or units_sum <= -_INT64_MAX)):\n        if not allow_overflow:\n            raise OverflowError(u'Money addition negative overflow')\n        else:\n            return sc_messages.Money(units=_INT64_MIN,\n                                     nanos=-MAX_NANOS,\n                                     currencyCode=a.currencyCode)\n    else:\n        return sc_messages.Money(units=units_sum,\n                                 nanos=nanos_sum,\n                                 currencyCode=a.currencyCode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _sign_of(money):\n    units = money.units\n    nanos = money.nanos\n    if units:\n        if units > 0:\n            return 1\n        elif units < 0:\n            return -1\n    if nanos:\n        if nanos > 0:\n            return 1\n        elif nanos < 0:\n            return -1\n    return 0", "response": "Determines the amount sign of a money instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _check_jwt_claims(jwt_claims):\n    current_time = time.time()\n\n    expiration = jwt_claims[u\"exp\"]\n    if not isinstance(expiration, INT_TYPES):\n        raise suppliers.UnauthenticatedException(u'Malformed claim: \"exp\" must be an integer')\n    if current_time >= expiration:\n        raise suppliers.UnauthenticatedException(u\"The auth token has already expired\")\n\n    if u\"nbf\" not in jwt_claims:\n        return\n\n    not_before_time = jwt_claims[u\"nbf\"]\n    if not isinstance(not_before_time, INT_TYPES):\n        raise suppliers.UnauthenticatedException(u'Malformed claim: \"nbf\" must be an integer')\n    if current_time < not_before_time:\n        raise suppliers.UnauthenticatedException(u'Current time is less than the \"nbf\" time')", "response": "Checks whether the JWT claims should be accepted."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _verify_required_claims_exist(jwt_claims):\n    for claim_name in [u\"aud\", u\"exp\", u\"iss\", u\"sub\"]:\n        if claim_name not in jwt_claims:\n            raise suppliers.UnauthenticatedException(u'Missing \"%s\" claim' % claim_name)", "response": "Verifies that the required claims exist."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nauthenticating the current auth token.", "response": "def authenticate(self, auth_token, auth_info, service_name):\n        \"\"\"Authenticates the current auth token.\n\n        Args:\n          auth_token: the auth token.\n          auth_info: the auth configurations of the API method being called.\n          service_name: the name of this service.\n\n        Returns:\n          A constructed UserInfo object representing the identity of the caller.\n\n        Raises:\n          UnauthenticatedException: When\n            * the issuer is not allowed;\n            * the audiences are not allowed;\n            * the auth token has already expired.\n        \"\"\"\n        try:\n            jwt_claims = self.get_jwt_claims(auth_token)\n        except Exception as error:\n            raise suppliers.UnauthenticatedException(u\"Cannot decode the auth token\",\n                                                     error)\n        _check_jwt_claims(jwt_claims)\n\n        user_info = UserInfo(jwt_claims)\n\n        issuer = user_info.issuer\n        if issuer not in self._issuers_to_provider_ids:\n            raise suppliers.UnauthenticatedException(u\"Unknown issuer: \" + issuer)\n        provider_id = self._issuers_to_provider_ids[issuer]\n\n        if not auth_info.is_provider_allowed(provider_id):\n            raise suppliers.UnauthenticatedException(u\"The requested method does not \"\n                                                     u\"allow provider id: \" + provider_id)\n\n        # Check the audiences decoded from the auth token. The auth token is\n        # allowed when 1) an audience is equal to the service name, or 2) at least\n        # one audience is allowed in the method configuration.\n        audiences = user_info.audiences\n        has_service_name = service_name in audiences\n\n        allowed_audiences = auth_info.get_allowed_audiences(provider_id)\n        intersected_audiences = set(allowed_audiences).intersection(audiences)\n        if not has_service_name and not intersected_audiences:\n            raise suppliers.UnauthenticatedException(u\"Audiences not allowed\")\n\n        return user_info"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecode the auth_token into a JSON object and returns the result.", "response": "def get_jwt_claims(self, auth_token):\n        \"\"\"Decodes the auth_token into JWT claims represented as a JSON object.\n\n        This method first tries to look up the cache and returns the result\n        immediately in case of a cache hit. When cache misses, the method tries to\n        decode the given auth token, verify its signature, and check the existence\n        of required JWT claims. When successful, the decoded JWT claims are loaded\n        into the cache and then returned.\n\n        Args:\n          auth_token: the auth token to be decoded.\n\n        Returns:\n          The decoded JWT claims.\n\n        Raises:\n          UnauthenticatedException: When the signature verification fails, or when\n            required claims are missing.\n        \"\"\"\n\n        def _decode_and_verify():\n            jwt_claims = jwt.JWT().unpack(auth_token).payload()\n            _verify_required_claims_exist(jwt_claims)\n\n            issuer = jwt_claims[u\"iss\"]\n            keys = self._jwks_supplier.supply(issuer)\n            try:\n                return jws.JWS().verify_compact(auth_token, keys)\n            except (jwkest.BadSignature, jws.NoSuitableSigningKeys,\n                    jws.SignerAlgError) as exception:\n                raise suppliers.UnauthenticatedException(u\"Signature verification failed\",\n                                                         exception)\n\n        return self._cache.get_or_create(auth_token, _decode_and_verify)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(options, timer=None, use_deque=True):\n    if options is None:  # no options, don't create cache\n        return None\n\n    if not isinstance(options, (CheckOptions, QuotaOptions, ReportOptions)):\n        _logger.error(u'make_cache(): bad options %s', options)\n        raise ValueError(u'Invalid options')\n\n    if (options.num_entries <= 0):\n        _logger.debug(u\"did not create cache, options was %s\", options)\n        return None\n\n    _logger.debug(u\"creating a cache from %s\", options)\n    if (options.flush_interval > ZERO_INTERVAL):\n        # options always has a flush_interval, but may have an expiration\n        # field. If the expiration is present, use that instead of the\n        # flush_interval for the ttl\n        ttl = getattr(options, u'expiration', options.flush_interval)\n        cache_cls = DequeOutTTLCache if use_deque else cachetools.TTLCache\n        return LockedObject(\n            cache_cls(\n                options.num_entries,\n                ttl=ttl.total_seconds(),\n                timer=to_cache_timer(timer)\n            ))\n\n    cache_cls = DequeOutLRUCache if use_deque else cachetools.LRUCache\n    return LockedObject(cache_cls(options.num_entries))", "response": "Create a new cache with the specified options."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_cache_timer(datetime_func):\n    if datetime_func is None:\n        datetime_func = datetime.utcnow\n\n    def _timer():\n        \"\"\"Return the timestamp since the epoch.\"\"\"\n        return (datetime_func() - datetime(1970, 1, 1)).total_seconds()\n\n    return _timer", "response": "Converts a datetime_func to a timestamp_func."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef out_deque(self):\n        self.expire()\n        expired = {k: v for (k, v) in self._tracking.items() if self.get(k) is None}\n        for k, v in expired.items():\n            del self._tracking[k]\n            self._out_deque.append(v)\n        return self._out_deque", "response": "The : class : collections. deque to which expired items are added."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndistributes the uranium package", "response": "def distribute(build):\n    \"\"\" distribute the uranium package \"\"\"\n    build.packages.install(\"wheel\")\n    build.packages.install(\"twine\")\n    build.executables.run([\n        \"python\", \"setup.py\",\n        \"sdist\", \"bdist_wheel\", \"--universal\", \"upload\",\n    ])\n    build.executables.run([\n        \"twine\", \"upload\", \"dist/*\"\n    ])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking Client s started after this use the appengine thread class.", "response": "def use_gae_thread():\n    \"\"\"Makes ``Client``s started after this use the appengine thread class.\"\"\"\n    global _THREAD_CLASS  # pylint: disable=global-statement\n    try:\n        from google.appengine.api.background_thread import background_thread\n        _THREAD_CLASS = background_thread.BackgroundThread\n    except ImportError:\n        _logger.error(\n            u'Could not install appengine background threads!'\n            u' Please install the python AppEngine SDK and use this from there')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting processing the current instance of the class.", "response": "def start(self):\n        \"\"\"Starts processing.\n\n        Calling this method\n\n        - starts the thread that regularly flushes all enabled caches.\n        - enables the other methods on the instance to be called successfully\n        \"\"\"\n        with self._lock:\n            if self._running:\n                return\n\n            self._stopped = False\n            self._running = True\n            self._start_idle_timer()\n            _logger.debug(u'starting thread of type %s to run the scheduler',\n                          _THREAD_CLASS)\n            self._thread = create_thread(target=self._schedule_flushes)\n            try:\n                self._thread.start()\n            except Exception:  # pylint: disable=broad-except\n                _logger.warn(\n                    u'no scheduler thread, scheduler.run() will be invoked by report(...)',\n                    exc_info=True)\n                self._thread = None\n                self._initialize_flushing()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhalt processing This will lead to the reports being flushed, the caches being cleared and a stop to the current processing thread.", "response": "def stop(self):\n        \"\"\"Halts processing\n\n        This will lead to the reports being flushed, the caches being cleared\n        and a stop to the current processing thread.\n\n        \"\"\"\n        with self._lock:\n            if self._stopped:\n                _logger.debug(u'%s is already stopped', self)\n                return\n\n            self._flush_all_reports()\n            self._stopped = True\n            if self._run_scheduler_directly:\n                self._cleanup_if_stopped()\n\n            if self._scheduler and self._scheduler.empty():\n                # if there are events scheduled, then _running will subsequently\n                # be set False by the scheduler thread.  This handles the\n                # case where there are no events, e.g because all aggreagation\n                # was disabled\n                self._running = False\n            self._scheduler = None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check(self, check_req):\n\n        self.start()\n        res = self._check_aggregator.check(check_req)\n        if res:\n            _logger.debug(u'using cached check response for %s: %s',\n                          check_request, res)\n            return res\n\n        # Application code should not fail because check request's don't\n        # complete, They should fail open, so here simply log the error and\n        # return None to indicate that no response was obtained\n        try:\n            transport = self._create_transport()\n            resp = transport.services.Check(check_req)\n            self._check_aggregator.add_response(check_req, resp)\n            return resp\n        except exceptions.Error:  # only sink apitools errors\n            _logger.error(u'direct send of check request failed %s',\n                          check_request, exc_info=True)\n            return None", "response": "Process a check_request and return a CheckResponse object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef report(self, report_req):\n        self.start()\n\n        # no thread running, run the scheduler to ensure any pending\n        # flush tasks are executed.\n        if self._run_scheduler_directly:\n            self._scheduler.run(blocking=False)\n\n        if not self._report_aggregator.report(report_req):\n            _logger.debug(u'need to send a report request directly')\n            try:\n                transport = self._create_transport()\n                transport.services.Report(report_req)\n            except exceptions.Error:  # only sink apitools errors\n                _logger.error(u'direct send for report request failed',\n                              exc_info=True)", "response": "Processes a report request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconstruct a new metric value.", "response": "def create(labels=None, **kw):\n    \"\"\"Constructs a new metric value.\n\n    This acts as an alternate to MetricValue constructor which\n    simplifies specification of labels.  Rather than having to create\n    a MetricValue.Labels instance, all that's necessary to specify the\n    required string.\n\n    Args:\n      labels (dict([string, [string]]):\n      **kw: any other valid keyword args valid in the MetricValue constructor\n\n    Returns\n      :class:`MetricValue`: the created instance\n\n    \"\"\"\n    if labels is not None:\n        kw[u'labels'] = encoding.PyValueToMessage(MetricValue.LabelsValue,\n                                                  labels)\n    return MetricValue(**kw)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef merge(metric_kind, prior, latest):\n    prior_type, _ = _detect_value(prior)\n    latest_type, _ = _detect_value(latest)\n    if prior_type != latest_type:\n        _logger.warn(u'Metric values are not compatible: %s, %s',\n                     prior, latest)\n        raise ValueError(u'Incompatible delta metric values')\n    if prior_type is None:\n        _logger.warn(u'Bad metric values, types not known for : %s, %s',\n                     prior, latest)\n        raise ValueError(u'Unsupported delta metric types')\n\n    if metric_kind == MetricKind.DELTA:\n        return _merge_delta_metric(prior, latest)\n    else:\n        return _merge_cumulative_or_gauge_metrics(prior, latest)", "response": "Merges two sets of metrics into one set of objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a metric value to the hash", "response": "def update_hash(a_hash, mv):\n    \"\"\"Adds ``mv`` to ``a_hash``\n\n    Args:\n       a_hash (`Hash`): the secure hash, e.g created by hashlib.md5\n       mv (:class:`MetricValue`): the instance to add to the hash\n\n    \"\"\"\n    if mv.labels:\n        signing.add_dict_to_hash(a_hash, encoding.MessageToPyValue(mv.labels))\n    money_value = mv.get_assigned_value(u'moneyValue')\n    if money_value is not None:\n        a_hash.update(b'\\x00')\n        a_hash.update(money_value.currencyCode.encode('utf-8'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sign(mv):\n    md5 = hashlib.md5()\n    update_hash(md5, mv)\n    return md5.digest()", "response": "Obtains a unique signature for a metric value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsupplies the jwks_uri for the given issuer.", "response": "def supply(self, issuer):\n        \"\"\"Supplies the `jwks_uri` for the given issuer.\n\n        Args:\n          issuer: the issuer.\n\n        Returns:\n          The `jwks_uri` that is either statically configured or retrieved via\n          OpenId discovery. None is returned when the issuer is unknown or the\n          OpenId discovery fails.\n        \"\"\"\n        issuer_uri_config = self._issuer_uri_configs.get(issuer)\n\n        if not issuer_uri_config:\n            # The issuer is unknown.\n            return\n\n        jwks_uri = issuer_uri_config.jwks_uri\n        if jwks_uri:\n            # When jwks_uri is set, return it directly.\n            return jwks_uri\n\n        # When jwksUri is empty, we try to retrieve it through the OpenID\n        # discovery.\n        open_id_valid = issuer_uri_config.open_id_valid\n        if open_id_valid:\n            discovered_jwks_uri = _discover_jwks_uri(issuer)\n            self._issuer_uri_configs[issuer] = IssuerUriConfig(False,\n                                                               discovered_jwks_uri)\n            return discovered_jwks_uri"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef supply(self, issuer):\n        def _retrieve_jwks():\n            \"\"\"Retrieve the JWKS from the given jwks_uri when cache misses.\"\"\"\n            jwks_uri = self._key_uri_supplier.supply(issuer)\n\n            if not jwks_uri:\n                raise UnauthenticatedException(u\"Cannot find the `jwks_uri` for issuer \"\n                                               u\"%s: either the issuer is unknown or \"\n                                               u\"the OpenID discovery failed\" % issuer)\n\n            try:\n                response = requests.get(jwks_uri)\n                json_response = response.json()\n            except Exception as exception:\n                message = u\"Cannot retrieve valid verification keys from the `jwks_uri`\"\n                raise UnauthenticatedException(message, exception)\n\n            if u\"keys\" in json_response:\n                # De-serialize the JSON as a JWKS object.\n                jwks_keys = jwk.KEYS()\n                jwks_keys.load_jwks(response.text)\n                return jwks_keys._keys\n            else:\n                # The JSON is a dictionary mapping from key id to X.509 certificates.\n                # Thus we extract the public key from the X.509 certificates and\n                # construct a JWKS object.\n                return _extract_x509_certificates(json_response)\n\n        return self._jwks_cache.get_or_create(issuer, _retrieve_jwks)", "response": "Supplies the Json Web Key Set for the given issuer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetermining if a given label descriptor matches this enum instance", "response": "def matches(self, desc):\n        \"\"\"Determines if a given label descriptor matches this enum instance\n\n        Args:\n           desc (:class:`endpoints_management.gen.servicemanagement_v1_messages.LabelDescriptor`):\n              the instance to test\n\n        Return:\n           `True` if desc is supported, otherwise `False`\n\n        \"\"\"\n        desc_value_type = desc.valueType or ValueType.STRING  # default not parsed\n        return (self.label_name == desc.key and\n                self.value_type == desc_value_type)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate a dictionary of labels using the assigned update_op_func", "response": "def do_labels_update(self, info, labels):\n        \"\"\"Updates a dictionary of labels using the assigned update_op_func\n\n        Args:\n           info (:class:`endpoints_management.control.report_request.Info`): the\n              info instance to update\n           labels (dict[string[string]]): the labels dictionary\n\n        Return:\n           `True` if desc is supported, otherwise `False`\n\n        \"\"\"\n        if self.update_label_func:\n            self.update_label_func(self.label_name, info, labels)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetermining if the given label descriptor is supported.", "response": "def is_supported(cls, desc):\n        \"\"\"Determines if the given label descriptor is supported.\n\n        Args:\n           desc (:class:`endpoints_management.gen.servicemanagement_v1_messages.LabelDescriptor`):\n             the label descriptor to test\n\n        Return:\n           `True` if desc is supported, otherwise `False`\n\n        \"\"\"\n        for l in cls:\n            if l.matches(desc):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extract_report_spec(\n        service,\n        label_is_supported=label_descriptor.KnownLabels.is_supported,\n        metric_is_supported=metric_descriptor.KnownMetrics.is_supported):\n    \"\"\"Obtains the used logs, metrics and labels from a service.\n\n    label_is_supported and metric_is_supported are filter functions used to\n    determine if label_descriptors or metric_descriptors found in the service\n    are supported.\n\n    Args:\n       service (:class:`endpoints_management.gen.servicecontrol_v1_messages.Service`):\n          a service instance\n       label_is_supported (:func): determines if a given label is supported\n       metric_is_supported (:func): determines if a given metric is supported\n\n    Return:\n       tuple: (\n         logs (set[string}), # the logs to report to\n         metrics (list[string]), # the metrics to use\n         labels (list[string]) # the labels to add\n       )\n    \"\"\"\n    resource_descs = service.monitoredResources\n    labels_dict = {}\n    logs = set()\n    if service.logging:\n        logs = _add_logging_destinations(\n            service.logging.producerDestinations,\n            resource_descs,\n            service.logs,\n            labels_dict,\n            label_is_supported\n        )\n    metrics_dict = {}\n    monitoring = service.monitoring\n    if monitoring:\n        for destinations in (monitoring.consumerDestinations,\n                             monitoring.producerDestinations):\n            _add_monitoring_destinations(destinations,\n                                         resource_descs,\n                                         service.metrics,\n                                         metrics_dict,\n                                         metric_is_supported,\n                                         labels_dict,\n                                         label_is_supported)\n    return logs, metrics_dict.keys(), labels_dict.keys()", "response": "Extracts the log metrics and labels from a service."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract the authentication configurations from the service.", "response": "def _extract_auth_config(self):\n        \"\"\"Obtains the authentication configurations.\"\"\"\n\n        service = self._service\n        if not service.authentication:\n            return {}\n\n        auth_infos = {}\n        for auth_rule in service.authentication.rules:\n            selector = auth_rule.selector\n            provider_ids_to_audiences = {}\n            for requirement in auth_rule.requirements:\n                provider_id = requirement.providerId\n                if provider_id and requirement.audiences:\n                    audiences = requirement.audiences.split(u\",\")\n                    provider_ids_to_audiences[provider_id] = audiences\n            auth_infos[selector] = AuthInfo(provider_ids_to_audiences)\n        return auth_infos"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _extract_methods(self):\n        service = self._service\n        all_urls = set()\n        urls_with_options = set()\n        if not service.http:\n            return\n        for rule in service.http.rules:\n            http_method, url = _detect_pattern_option(rule)\n            if not url or not http_method or not rule.selector:\n                _logger.error(u'invalid HTTP binding encountered')\n                continue\n\n            # Obtain the method info\n            method_info = self._get_or_create_method_info(rule.selector)\n            if rule.body:\n                method_info.body_field_path = rule.body\n            if not self._register(http_method, url, method_info):\n                continue  # detected an invalid url\n            all_urls.add(url)\n\n            if http_method == self._OPTIONS:\n                urls_with_options.add(url)\n\n        self._add_cors_options_selectors(all_urls - urls_with_options)\n        self._update_usage()\n        self._update_system_parameters()", "response": "Extracts the methods used in the service."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def get_blueprint_params(request, left: int, right: int) -> str:\n    res = left * right\n    return \"{left}*{right}={res}\".format(left=left, right=right, res=res)", "response": "Multiplies left and right by left and right."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch the service config from the Service Management API.", "response": "def fetch_service_config(service_name=None, service_version=None):\n    \"\"\"Fetches the service config from Google Service Management API.\n\n    Args:\n      service_name: the service name. When this argument is unspecified, this\n        method uses the value of the \"SERVICE_NAME\" environment variable as the\n        service name, and raises ValueError if the environment variable is unset.\n      service_version: the service version. When this argument is unspecified,\n        this method uses the value of the \"SERVICE_VERSION\" environment variable\n        as the service version, and raises ValueError if the environment variable\n        is unset.\n\n    Returns: the fetched service config JSON object.\n\n    Raises:\n      ValueError: when the service name/version is neither provided as an\n        argument or set as an environment variable; or when the fetched service\n        config fails validation.\n      Exception: when the Google Service Management API returns non-200 response.\n    \"\"\"\n    if not service_name:\n        service_name = _get_env_var_or_raise(_SERVICE_NAME_ENV_KEY)\n    if not service_version:\n        service_version = _get_service_version(_SERVICE_VERSION_ENV_KEY,\n                                               service_name)\n\n    _logger.debug(u'Contacting Service Management API for service %s version %s',\n                  service_name, service_version)\n    response = _make_service_config_request(service_name, service_version)\n    _logger.debug(u'obtained service json from the management api:\\n%s', response.data)\n    service = encoding.JsonToMessage(messages.Service, response.data)\n    _validate_service_config(service, service_name, service_version)\n    return service"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds all endpoints middleware to a wsgi application.", "response": "def add_all(application, project_id, control_client,\n            loader=service.Loaders.FROM_SERVICE_MANAGEMENT):\n    \"\"\"Adds all endpoints middleware to a wsgi application.\n\n    Sets up application to use all default endpoints middleware.\n\n    Example:\n\n      >>> application = MyWsgiApp()  # an existing WSGI application\n      >>>\n      >>> # the name of the controlled service\n      >>> service_name = 'my-service-name'\n      >>>\n      >>> # A GCP project  with service control enabled\n      >>> project_id = 'my-project-id'\n      >>>\n      >>> # wrap the app for service control\n      >>> from endpoints_management.control import wsgi\n      >>> control_client = client.Loaders.DEFAULT.load(service_name)\n      >>> control_client.start()\n      >>> wrapped_app = add_all(application, project_id, control_client)\n      >>>\n      >>> # now use wrapped_app in place of app\n\n    Args:\n       application: the wrapped wsgi application\n       project_id: the project_id thats providing service control support\n       control_client: the service control client instance\n       loader (:class:`endpoints_management.control.service.Loader`): loads the service\n          instance that configures this instance's behaviour\n    \"\"\"\n    return ConfigFetchWrapper(application, project_id, control_client, loader)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create_authenticator(a_service):\n    if not isinstance(a_service, sm_messages.Service):\n        raise ValueError(u\"service is None or not an instance of Service\")\n\n    authentication = a_service.authentication\n    if not authentication:\n        _logger.info(u\"authentication is not configured in service, \"\n                     u\"authentication checks will be disabled\")\n        return\n\n    issuers_to_provider_ids = {}\n    issuer_uri_configs = {}\n    for provider in authentication.providers:\n        issuer = provider.issuer\n        jwks_uri = provider.jwksUri\n\n        # Enable openID discovery if jwks_uri is unset\n        open_id = jwks_uri is None\n        issuer_uri_configs[issuer] = suppliers.IssuerUriConfig(open_id, jwks_uri)\n        issuers_to_provider_ids[issuer] = provider.id\n\n    key_uri_supplier = suppliers.KeyUriSupplier(issuer_uri_configs)\n    jwks_supplier = suppliers.JwksSupplier(key_uri_supplier)\n    authenticator = tokens.Authenticator(issuers_to_provider_ids, jwks_supplier)\n    return authenticator", "response": "Create an instance of google. auth. tokens. Authenticator."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nobtains a unique signature for an operation in a ReportRequest.", "response": "def _sign_operation(op):\n    \"\"\"Obtains a signature for an operation in a ReportRequest.\n\n    Args:\n       op (:class:`endpoints_management.gen.servicecontrol_v1_messages.Operation`): an\n         operation used in a `ReportRequest`\n\n    Returns:\n       string: a unique signature for that operation\n    \"\"\"\n    md5 = hashlib.md5()\n    md5.update(op.consumerId.encode('utf-8'))\n    md5.update(b'\\x00')\n    md5.update(op.operationName.encode('utf-8'))\n    if op.labels:\n        signing.add_dict_to_hash(md5, encoding.MessageToPyValue(op.labels))\n    return md5.digest()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake a LogEntry from this instance with the given log_name and the given datetime.", "response": "def _as_log_entry(self, name, now):\n        \"\"\"Makes a `LogEntry` from this instance for the given log_name.\n\n        Args:\n          rules (:class:`ReportingRules`): determines what labels, metrics and\n            logs to include in the report request.\n          now (:class:`datetime.DateTime`): the current time\n\n        Return:\n          a ``LogEntry`` generated from this instance with the given name\n          and timestamp\n\n        Raises:\n          ValueError: if the fields in this instance are insufficient to\n            to create a valid ``ServicecontrolServicesReportRequest``\n\n        \"\"\"\n        # initialize the struct with fields that are always present\n        d = {\n            u'http_response_code': self.response_code,\n            u'timestamp': time.mktime(now.timetuple())\n        }\n\n        # compute the severity\n        severity = _SEVERITY.INFO\n        if self.response_code >= 400:\n            severity = _SEVERITY.ERROR\n            d[u'error_cause'] = self.error_cause.name\n\n        # add 'optional' fields to the struct\n        if self.request_size > 0:\n            d[u'request_size'] = self.request_size\n        if self.response_size > 0:\n            d[u'response_size'] = self.response_size\n        if self.method:\n            d[u'http_method'] = self.method\n        if self.request_time:\n            d[u'request_latency_in_ms'] = self.request_time.total_seconds() * 1000\n\n        # add 'copyable' fields to the struct\n        for key in self.COPYABLE_LOG_FIELDS:\n            value = getattr(self, key, None)\n            if value:\n                d[key] = value\n\n        return sc_messages.LogEntry(\n            name=name,\n            timestamp=timestamp.to_rfc3339(now),\n            severity=severity,\n            structPayload=_struct_payload_from(d))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a ServicecontrolServicesReportRequest object from this instance and the provided rules.", "response": "def as_report_request(self, rules, timer=datetime.utcnow):\n        \"\"\"Makes a `ServicecontrolServicesReportRequest` from this instance\n\n        Args:\n          rules (:class:`ReportingRules`): determines what labels, metrics and\n            logs to include in the report request.\n          timer: a function that determines the current time\n\n        Return:\n          a ``ServicecontrolServicesReportRequest`` generated from this instance\n          governed by the provided ``rules``\n\n        Raises:\n          ValueError: if the fields in this instance cannot be used to create\n            a valid ``ServicecontrolServicesReportRequest``\n\n        \"\"\"\n        if not self.service_name:\n            raise ValueError(u'the service name must be set')\n        op = super(Info, self).as_operation(timer=timer)\n\n        # Populate metrics and labels if they can be associated with a\n        # method/operation\n        if op.operationId and op.operationName:\n            labels = {}\n            for known_label in rules.labels:\n                known_label.do_labels_update(self, labels)\n\n            # Forcibly add system label reporting here, as the base service\n            # config does not specify it as a label.\n            labels[_KNOWN_LABELS.SCC_PLATFORM.label_name] = (\n                self.platform.friendly_string())\n            labels[_KNOWN_LABELS.SCC_SERVICE_AGENT.label_name] = (\n                SERVICE_AGENT)\n            labels[_KNOWN_LABELS.SCC_USER_AGENT.label_name] = USER_AGENT\n\n            if labels:\n                op.labels = encoding.PyValueToMessage(\n                    sc_messages.Operation.LabelsValue,\n                    labels)\n            for known_metric in rules.metrics:\n                known_metric.do_operation_update(self, op)\n\n        # Populate the log entries\n        now = timer()\n        op.logEntries = [self._as_log_entry(l, now) for l in rules.logs]\n\n        return sc_messages.ServicecontrolServicesReportRequest(\n            serviceName=self.service_name,\n            reportRequest=sc_messages.ReportRequest(operations=[op]))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nflushing this instance s cache.", "response": "def flush(self):\n        \"\"\"Flushes this instance's cache.\n\n        The driver of this instance should call this method every\n        `flush_interval`.\n\n        Returns:\n          list[``ServicecontrolServicesReportRequest``]: corresponding to the\n            pending cached operations\n\n        \"\"\"\n        if self._cache is None:\n            return _NO_RESULTS\n        with self._cache as c:\n            flushed_ops = [x.as_operation() for x in c.out_deque]\n            c.out_deque.clear()\n            reqs = []\n            max_ops = self.MAX_OPERATION_COUNT\n            for x in range(0, len(flushed_ops), max_ops):\n                report_request = sc_messages.ReportRequest(\n                    operations=flushed_ops[x:x + max_ops])\n                reqs.append(\n                    sc_messages.ServicecontrolServicesReportRequest(\n                        serviceName=self.service_name,\n                        reportRequest=report_request))\n\n            return reqs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a report request to the cache.", "response": "def report(self, req):\n        \"\"\"Adds a report request to the cache.\n\n        Returns ``None`` if it could not be aggregated, and callers need to\n        send the request to the server, otherwise it returns ``CACHED_OK``.\n\n        Args:\n           req (:class:`sc_messages.ReportRequest`): the request\n             to be aggregated\n\n        Result:\n           ``None`` if the request as not cached, otherwise ``CACHED_OK``\n\n        \"\"\"\n        if self._cache is None:\n            return None  # no cache, send request now\n        if not isinstance(req, sc_messages.ServicecontrolServicesReportRequest):\n            raise ValueError(u'Invalid request')\n        if req.serviceName != self.service_name:\n            _logger.error(u'bad report(): service_name %s does not match ours %s',\n                          req.serviceName, self.service_name)\n            raise ValueError(u'Service name mismatch')\n        report_req = req.reportRequest\n        if report_req is None:\n            _logger.error(u'bad report(): no report_request in %s', req)\n            raise ValueError(u'Expected report_request not set')\n        if _has_high_important_operation(report_req) or self._cache is None:\n            return None\n        ops_by_signature = _key_by_signature(report_req.operations,\n                                             _sign_operation)\n\n        # Concurrency:\n        #\n        # This holds a lock on the cache while updating it.  No i/o operations\n        # are performed, so any waiting threads see minimal delays\n        with self._cache as cache:\n            for key, op in ops_by_signature.items():\n                agg = cache.get(key)\n                if agg is None:\n                    cache[key] = operation.Aggregator(op, self._kinds)\n                else:\n                    agg.add(op)\n\n        return self.CACHED_OK"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts an AllocateQuotaResponse to a tuple.", "response": "def convert_response(allocate_quota_response, project_id):\n    \"\"\"Computes a http status code and message `AllocateQuotaResponse`\n\n    The return value a tuple (code, message) where\n\n    code: is the http status code\n    message: is the message to return\n\n    Args:\n       allocate_quota_response (:class:`endpoints_management.gen.servicecontrol_v1_messages.AllocateQuotaResponse`):\n         the response from calling an api\n\n    Returns:\n       tuple(code, message)\n    \"\"\"\n    if not allocate_quota_response or not allocate_quota_response.allocateErrors:\n        return _IS_OK\n\n    # only allocate_quota the first error for now, as per ESP\n    theError = allocate_quota_response.allocateErrors[0]\n    error_tuple = _QUOTA_ERROR_CONVERSION.get(theError.code, _IS_UNKNOWN)\n    if error_tuple[1].find(u'{') == -1:  # no replacements needed:\n        return error_tuple\n\n    updated_msg = error_tuple[1].format(project_id=project_id, detail=theError.description or u'')\n    return error_tuple[0], updated_msg"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sign(allocate_quota_request):\n    if not isinstance(allocate_quota_request, sc_messages.AllocateQuotaRequest):\n        raise ValueError(u'Invalid request')\n    op = allocate_quota_request.allocateOperation\n    if op is None or op.methodName is None or op.consumerId is None:\n        logging.error(u'Bad %s: not initialized => not signed', allocate_quota_request)\n        raise ValueError(u'allocate_quota request must be initialized with an operation')\n    md5 = hashlib.md5()\n    md5.update(op.methodName.encode('utf-8'))\n    md5.update(b'\\x00')\n    md5.update(op.consumerId.encode('utf-8'))\n    if op.labels:\n        signing.add_dict_to_hash(md5, encoding.MessageToPyValue(op.labels))\n    for value_set in op.quotaMetrics:\n        md5.update(b'\\x00')\n        md5.update(value_set.metricName.encode('utf-8'))\n        for mv in value_set.metricValues:\n            metric_value.update_hash(md5, mv)\n\n    md5.update(b'\\x00')\n    return md5.digest()", "response": "Gets a secure hash for an operation in a AllocateQuotaRequest."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking a ServicecontrolServicesAllocateQuotaRequest from this instance.", "response": "def as_allocate_quota_request(self, timer=datetime.utcnow):\n        \"\"\"Makes a `ServicecontrolServicesAllocateQuotaRequest` from this instance\n\n        Returns:\n          a ``ServicecontrolServicesAllocateQuotaRequest``\n\n        Raises:\n          ValueError: if the fields in this instance are insufficient to\n            to create a valid ``ServicecontrolServicesAllocateQuotaRequest``\n\n        \"\"\"\n        if not self.service_name:\n            raise ValueError(u'the service name must be set')\n        if not self.operation_id:\n            raise ValueError(u'the operation id must be set')\n        if not self.operation_name:\n            raise ValueError(u'the operation name must be set')\n        op = super(Info, self).as_operation(timer=timer)\n        labels = {}\n        if self.client_ip:\n            labels[_KNOWN_LABELS.SCC_CALLER_IP.label_name] = self.client_ip\n\n        if self.referer:\n            labels[_KNOWN_LABELS.SCC_REFERER.label_name] = self.referer\n\n        qop = sc_messages.QuotaOperation(\n            operationId=op.operationId,\n            methodName=op.operationName,\n            consumerId=op.consumerId,\n            quotaMode=sc_messages.QuotaOperation.QuotaModeValueValuesEnum.BEST_EFFORT,\n        )\n        qop.labels = encoding.PyValueToMessage(\n            sc_messages.QuotaOperation.LabelsValue, labels)\n\n        quota_info = self.quota_info if self.quota_info else {}\n        qop.quotaMetrics = [\n            sc_messages.MetricValueSet(\n                metricName=name, metricValues=[sc_messages.MetricValue(int64Value=cost)])\n            for name, cost in quota_info.items()\n        ]\n\n        allocate_quota_request = sc_messages.AllocateQuotaRequest(allocateOperation=qop)\n        if self.config_id:\n            allocate_quota_request.serviceConfigId = self.config_id\n        return sc_messages.ServicecontrolServicesAllocateQuotaRequest(\n            serviceName=self.service_name,\n            allocateQuotaRequest=allocate_quota_request)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef flush(self):\n        if self._cache is None:\n            return []\n        with self._cache as c, self._out as out:\n            c.expire()\n            now = self._timer()\n            for item in c.values():\n                if (not self._in_flush_all) and (not self._should_expire(item)):\n                    if (not item.is_in_flight) and item._op_aggregator is not None:\n                        item.is_in_flight = True\n                        item.last_refresh_timestamp = now\n                        out.append(item.extract_request())  # pylint: disable=no-member\n            flushed_items = list(out)\n            out.clear()  # pylint: disable=no-member\n            for req in flushed_items:\n                assert isinstance(req, sc_messages.ServicecontrolServicesAllocateQuotaRequest)\n            return flushed_items", "response": "Flushes this instance s cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclears this instance s cache.", "response": "def clear(self):\n        \"\"\"Clears this instance's cache.\"\"\"\n        if self._cache is not None:\n            with self._cache as c, self._out as out:\n                self.in_flush_all = True\n                c.clear()\n                out.clear()  # pylint: disable=no-member\n                self.in_flush_all = False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd the response from sending to req to this instance s cache.", "response": "def add_response(self, req, resp):\n        \"\"\"Adds the response from sending to `req` to this instance's cache.\n\n        Args:\n          req (`ServicecontrolServicesAllocateQuotaRequest`): the request\n          resp (AllocateQuotaResponse): the response from sending the request\n        \"\"\"\n        if self._cache is None:\n            return\n        signature = sign(req.allocateQuotaRequest)\n        with self._cache as c:\n            now = self._timer()\n            item = c.get(signature)\n            if item is None:\n                c[signature] = CachedItem(\n                    req, resp, self.service_name, now)\n            else:\n                # Update the cached item to reflect that it is updated\n                item.last_check_time = now\n                item.response = resp\n                item.is_in_flight = False\n                c[signature] = item"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_route(app_or_blueprint, fn, context=default_context):\n    transmute_func = TransmuteFunction(\n        fn,\n        args_not_from_request=[\"request\"]\n    )\n    handler = create_handler(transmute_func, context=context)\n    get_swagger_spec(app_or_blueprint).add_func(transmute_func, context)\n    for p in transmute_func.paths:\n        sanic_path = _convert_to_sanic_path(p)\n        app_or_blueprint.add_route(handler, sanic_path, methods=list(transmute_func.methods))", "response": "A decorator that adds a transmute route to the application."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef matches(self, desc):\n        return (self.metric_name == desc.name and\n                self.kind == desc.metricKind and\n                self.value_type == desc.valueType)", "response": "Determines if a given metric descriptor matches this enum instance instance\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating an operation using the assigned update_op_func", "response": "def do_operation_update(self, info, an_op):\n        \"\"\"Updates an operation using the assigned update_op_func\n\n        Args:\n           info: (:class:`endpoints_management.control.report_request.Info`): the\n              info instance to update\n           an_op: (:class:`endpoints_management.control.report_request.Info`):\n              the info instance to update\n\n        Return:\n           `True` if desc is supported, otherwise `False`\n\n        \"\"\"\n        self.update_op_func(self.metric_name, info, an_op)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines if the given metric descriptor is supported.", "response": "def is_supported(cls, desc):\n        \"\"\"Determines if the given metric descriptor is supported.\n\n        Args:\n           desc (:class:`endpoints_management.gen.servicecontrol_v1_messages.MetricDescriptor`): the\n             metric descriptor to test\n\n        Return:\n           `True` if desc is supported, otherwise `False`\n\n        \"\"\"\n        for m in cls:\n            if m.matches(desc):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_dict_to_hash(a_hash, a_dict):\n    if a_dict is None:\n        return\n    for k, v in a_dict.items():\n        a_hash.update(b'\\x00' + k.encode('utf-8') + b'\\x00' + v.encode('utf-8'))", "response": "Adds a_dict to a_hash"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_swagger(app, json_route, html_route):\n    app.add_route(create_swagger_json_handler(app), json_route, methods=[\"GET\"])\n    add_swagger_api_route(app, html_route, json_route)", "response": "add a swagger. json route and a swagger. html route"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_swagger_api_route(app, target_route, swagger_json_route):\n    static_root = get_swagger_static_root()\n    swagger_body = generate_swagger_html(\n        STATIC_ROOT, swagger_json_route\n    ).encode(\"utf-8\")\n\n    async def swagger_ui(request):\n        return HTTPResponse(body_bytes=swagger_body, content_type=\"text/html\")\n\n    bp = Blueprint('swagger')\n    bp.static(STATIC_ROOT, static_root)\n\n    app.add_route(swagger_ui, target_route, methods=[\"GET\"])\n    app.blueprint(bp)", "response": "Add a route to the sanic app that will serve the swagger json file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_swagger_json_handler(app, **kwargs):\n\n    spec = get_swagger_spec(app)\n    _add_blueprint_specs(app, spec)\n    spec_dict = spec.swagger_definition(**kwargs)\n    encoded_spec = json.dumps(spec_dict).encode(\"UTF-8\")\n\n    async def swagger(request):\n        return HTTPResponse(\n            body_bytes=encoded_spec,\n            headers={\n                \"Access-Control-Allow-Origin\": \"*\"\n            },\n            content_type=\"application/json\",\n        )\n\n    return swagger", "response": "Create a handler that returns the swagger definition for an application."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compute_to_fields(self, to_fields):\n        # for problem in trim_join, we must try to give the fields in a consistent order with others models...\n        # see #26515 at  https://code.djangoproject.com/ticket/26515\n\n        return OrderedDict(\n            (k, (v if isinstance(v, CompositePart) else LocalFieldValue(v)))\n            for k, v in (to_fields.items() if isinstance(to_fields, dict) else zip(to_fields, to_fields))\n        )", "response": "compute the to_fields parameterse to make it uniformly a dict of CompositePart objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_lookup(self, main_field, for_remote, alias):\n        lookup_class = for_remote.get_lookup(\"exact\")\n        return lookup_class(for_remote.get_col(alias), self.value)", "response": "create a fake field for the lookup capability\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_valid(self):\n        length = len(self.fqdn)\n        if self.fqdn.endswith('.'):\n            length -= 1\n        if length > 253:\n            return False\n        return bool(self.FQDN_REGEX.match(self.fqdn))", "response": "Returns True if the FQDN is valid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the FQDN as a string in relative form.", "response": "def relative(self):\n        \"\"\"\n        The FQDN as a string in relative form\n        \"\"\"\n        if not self.is_valid:\n            raise ValueError('invalid FQDN `{0}`'.format(self.fqdn))\n\n        if self.is_valid_absolute:\n            return self.fqdn[:-1]\n\n        return self.fqdn"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _available_cpu_count():\n    try:\n        return len(os.sched_getaffinity(0))\n    except AttributeError:\n        pass\n    import re\n    try:\n        with open('/proc/self/status') as f:\n            status = f.read()\n        m = re.search(r'(?m)^Cpus_allowed:\\s*(.*)$', status)\n        if m:\n            res = bin(int(m.group(1).replace(',', ''), 16)).count('1')\n            if res > 0:\n                return res\n    except IOError:\n        pass\n    try:\n        import multiprocessing\n        return multiprocessing.cpu_count()\n    except (ImportError, NotImplementedError):\n        return 1", "response": "Returns the number of available CPUs on this system"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef xopen(filename, mode='r', compresslevel=6, threads=None):\n    if mode in ('r', 'w', 'a'):\n        mode += 't'\n    if mode not in ('rt', 'rb', 'wt', 'wb', 'at', 'ab'):\n        raise ValueError(\"mode '{0}' not supported\".format(mode))\n    if not _PY3:\n        mode = mode[0]\n    filename = fspath(filename)\n    if not isinstance(filename, basestring):\n        raise ValueError(\"the filename must be a string\")\n    if compresslevel not in range(1, 10):\n        raise ValueError(\"compresslevel must be between 1 and 9\")\n\n    if filename == '-':\n        return _open_stdin_or_out(mode)\n    elif filename.endswith('.bz2'):\n        return _open_bz2(filename, mode)\n    elif filename.endswith('.xz'):\n        return _open_xz(filename, mode)\n    elif filename.endswith('.gz'):\n        return _open_gz(filename, mode, compresslevel, threads)\n    else:\n        # Python 2.6 and 2.7 have io.open, which we could use to make the returned\n        # object consistent with the one returned in Python 3, but reading a file\n        # with io.open() is 100 times slower (!) on Python 2.6, and still about\n        # three times slower on Python 2.7 (tested with \"for _ in io.open(path): pass\")\n        return open(filename, mode)", "response": "A replacement for the open function that can also open files that have been compressed with gzip bzip2 or xz."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nraise IOError if process is not running anymore and the process exit code is nonzero.", "response": "def _raise_if_error(self):\n        \"\"\"\n        Raise IOError if process is not running anymore and the\n        exit code is nonzero.\n        \"\"\"\n        retcode = self.process.poll()\n        if retcode is not None and retcode != 0:\n            message = self._stderr.read().strip()\n            raise IOError(message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self, trials=100, strategy=None, parameters=None):\n        '''\n        Run MAB test with T trials.\n\n        Parameters\n        ----------\n        trials : int\n            Number of trials to run.\n        strategy : str\n            Name of selected strategy.\n        parameters : dict\n            Parameters for selected strategy.\n\n        Available strategies:\n            - Epsilon-greedy (\"eps_greedy\")\n            - Softmax (\"softmax\")\n            - Upper confidence bound (\"ucb\")\n\n        Returns\n        -------\n        None\n        '''\n\n        if trials < 1:\n            raise Exception('MAB.run: Number of trials cannot be less than 1!')\n        if not strategy:\n            strategy = 'eps_greedy'\n        else:\n            if strategy not in self.strategies:\n                raise Exception('MAB,run: Strategy name invalid. Choose from:'\n                                ' {}'.format(', '.join(self.strategies)))\n\n        # Run strategy\n        for n in range(trials):\n            self._run(strategy, parameters)", "response": "Run MAB test with T trials."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _run(self, strategy, parameters=None):\n        '''\n        Run single trial of MAB strategy.\n\n        Parameters\n        ----------\n        strategy : function\n        parameters : dict\n\n        Returns\n        -------\n        None\n        '''\n\n        choice = self.run_strategy(strategy, parameters)\n        self.choices.append(choice)\n        payout = self.bandits.pull(choice)\n        if payout is None:\n            print('Trials exhausted. No more values for bandit', choice)\n            return None\n        else:\n            self.wins[choice] += payout\n        self.pulls[choice] += 1", "response": "Run a single trial of MAB strategy."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun the Bayesian Bandit algorithm which utilizes a beta distribution for exploration and exploitation. Parameters ---------- params : None For API consistency, this function can take a parameters argument, but it is ignored. Returns ------- int Index of chosen bandit", "response": "def bayesian(self, params=None):\n        '''\n        Run the Bayesian Bandit algorithm which utilizes a beta distribution\n        for exploration and exploitation.\n\n        Parameters\n        ----------\n        params : None\n            For API consistency, this function can take a parameters argument,\n            but it is ignored.\n\n        Returns\n        -------\n        int\n            Index of chosen bandit\n        '''\n        p_success_arms = [\n            np.random.beta(self.wins[i] + 1, self.pulls[i] - self.wins[i] + 1)\n            for i in range(len(self.wins))\n            ]\n\n        return np.array(p_success_arms).argmax()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns the epsilon - greedy strategy and update self. max_mean", "response": "def eps_greedy(self, params):\n        '''\n        Run the epsilon-greedy strategy and update self.max_mean()\n\n        Parameters\n        ----------\n        Params : dict\n            Epsilon\n\n        Returns\n        -------\n        int\n            Index of chosen bandit\n        '''\n\n        if params and type(params) == dict:\n            eps = params.get('epsilon')\n        else:\n            eps = 0.1\n\n        r = np.random.rand()\n\n        if r < eps:\n            return np.random.choice(list(set(range(len(self.wins))) -\n                                    {self.max_mean()}))\n        else:\n            return self.max_mean()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the softmax selection strategy.", "response": "def softmax(self, params):\n        '''\n        Run the softmax selection strategy.\n\n        Parameters\n        ----------\n        Params : dict\n            Tau\n\n        Returns\n        -------\n        int\n            Index of chosen bandit\n        '''\n\n        default_tau = 0.1\n\n        if params and type(params) == dict:\n            tau = params.get('tau')\n            try:\n                float(tau)\n            except ValueError:\n                'slots: softmax: Setting tau to default'\n                tau = default_tau\n        else:\n            tau = default_tau\n\n        # Handle cold start. Not all bandits tested yet.\n        if True in (self.pulls < 3):\n            return np.random.choice(range(len(self.pulls)))\n        else:\n            payouts = self.wins / (self.pulls + 0.1)\n            norm = sum(np.exp(payouts/tau))\n\n        ps = np.exp(payouts/tau)/norm\n\n        # Randomly choose index based on CMF\n        cmf = [sum(ps[:i+1]) for i in range(len(ps))]\n\n        rand = np.random.rand()\n\n        found = False\n        found_i = None\n        i = 0\n        while not found:\n            if rand < cmf[i]:\n                found_i = i\n                found = True\n            else:\n                i += 1\n\n        return found_i"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ucb(self, params=None):\n        '''\n        Run the upper confidence bound MAB selection strategy.\n\n        This is the UCB1 algorithm described in\n        https://homes.di.unimi.it/~cesabian/Pubblicazioni/ml-02.pdf\n\n        Parameters\n        ----------\n        params : None\n            For API consistency, this function can take a parameters argument,\n            but it is ignored.\n\n        Returns\n        -------\n        int\n            Index of chosen bandit\n        '''\n\n        # UCB = j_max(payout_j + sqrt(2ln(n_tot)/n_j))\n\n        # Handle cold start. Not all bandits tested yet.\n        if True in (self.pulls < 3):\n            return np.random.choice(range(len(self.pulls)))\n        else:\n            n_tot = sum(self.pulls)\n            payouts = self.wins / (self.pulls + 0.1)\n            ubcs = payouts + np.sqrt(2*np.log(n_tot)/self.pulls)\n\n            return np.argmax(ubcs)", "response": "Run the upper confidence bound MAB selection strategy."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn current best choice of bandit.", "response": "def best(self):\n        '''\n        Return current 'best' choice of bandit.\n\n        Returns\n        -------\n        int\n            Index of bandit\n        '''\n\n        if len(self.choices) < 1:\n            print('slots: No trials run so far.')\n            return None\n        else:\n            return np.argmax(self.wins/(self.pulls+0.1))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate current estimate of average payout for each bandit.", "response": "def est_payouts(self):\n        '''\n        Calculate current estimate of average payout for each bandit.\n\n        Returns\n        -------\n        array of floats or None\n        '''\n\n        if len(self.choices) < 1:\n            print('slots: No trials run so far.')\n            return None\n        else:\n            return self.wins/(self.pulls+0.1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef regret(self):\n        '''\n        Calculate expected regret, where expected regret is\n        maximum optimal reward - sum of collected rewards, i.e.\n\n        expected regret = T*max_k(mean_k) - sum_(t=1-->T) (reward_t)\n\n        Returns\n        -------\n        float\n        '''\n\n        return (sum(self.pulls)*np.max(np.nan_to_num(self.wins/self.pulls)) -\n                sum(self.wins)) / sum(self.pulls)", "response": "Calculate expected regret for the current set of records"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndetermine if stopping criterion has been met.", "response": "def crit_met(self):\n        '''\n        Determine if stopping criterion has been met.\n\n        Returns\n        -------\n        bool\n        '''\n\n        if True in (self.pulls < 3):\n            return False\n        else:\n            return self.criteria[self.criterion](self.stop_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines if regret criterion has been met.", "response": "def regret_met(self, threshold=None):\n        '''\n        Determine if regret criterion has been met.\n\n        Parameters\n        ----------\n        threshold : float\n\n        Returns\n        -------\n        bool\n        '''\n\n        if not threshold:\n            return self.regret() <= self.stop_value\n        elif self.regret() <= threshold:\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the bandits with the results of the previous live, online trial. Next run a the selection algorithm. If the stopping criteria is met, return the best arm estimate. Otherwise return the next arm to try. Parameters ---------- bandit : int Bandit index payout : float Payout value strategy : string Name of update strategy parameters : dict Parameters for update strategy function Returns ------- dict Format: {'new_trial': boolean, 'choice': int, 'best': int}", "response": "def online_trial(self, bandit=None, payout=None, strategy='eps_greedy',\n                     parameters=None):\n        '''\n        Update the bandits with the results of the previous live, online trial.\n            Next run a the selection algorithm. If the stopping criteria is\n            met, return the best arm estimate. Otherwise return the next arm to\n            try.\n\n        Parameters\n        ----------\n        bandit : int\n            Bandit index\n        payout : float\n            Payout value\n        strategy : string\n            Name of update strategy\n        parameters : dict\n            Parameters for update strategy function\n\n        Returns\n        -------\n        dict\n            Format: {'new_trial': boolean, 'choice': int, 'best': int}\n        '''\n\n        if bandit is not None and payout is not None:\n            self.update(bandit=bandit, payout=payout)\n        else:\n            raise Exception('slots.online_trial: bandit and/or payout value'\n                            ' missing.')\n\n        if self.crit_met():\n            return {'new_trial': False, 'choice': self.best(),\n                    'best': self.best()}\n        else:\n            return {'new_trial': True,\n                    'choice': self.run_strategy(strategy, parameters),\n                    'best': self.best()}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate trials and payouts for given bandit.", "response": "def update(self, bandit, payout):\n        '''\n        Update bandit trials and payouts for given bandit.\n\n        Parameters\n        ----------\n        bandit : int\n            Bandit index\n        payout : float\n\n        Returns\n        -------\n        None\n        '''\n\n        self.choices.append(bandit)\n        self.pulls[bandit] += 1\n        self.wins[bandit] += payout\n        self.bandits.payouts[bandit] += payout"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the payout from a single pull of the bandit i s arm.", "response": "def pull(self, i):\n        '''\n        Return the payout from a single pull of the bandit i's arm.\n\n        Parameters\n        ----------\n        i : int\n            Index of bandit.\n\n        Returns\n        -------\n        float or None\n        '''\n\n        if self.live:\n            if len(self.payouts[i]) > 0:\n                return self.payouts[i].pop()\n            else:\n                return None\n        else:\n            if np.random.rand() < self.probs[i]:\n                return self.payouts[i]\n            else:\n                return 0.0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef click_table_printer(headers, _filter, data):\n    _filter = [h.lower() for h in _filter] + [h.upper() for h in _filter]\n    headers = [h for h in headers if not _filter or h in _filter]\n    # Maximum header width\n    header_widths = [len(h) for h in headers]\n\n    for row in data:\n        for idx in range(len(headers)):\n            # If a row contains an element which is wider update maximum width\n            if header_widths[idx] < len(str(row[idx])):\n                header_widths[idx] = len(str(row[idx]))\n    # Prepare the format string with the maximum widths\n    formatted_output_parts = ['{{:<{0}}}'.format(hw)\n                              for hw in header_widths]\n    formatted_output = '   '.join(formatted_output_parts)\n    # Print the table with the headers capitalized\n    click.echo(formatted_output.format(*[h.upper() for h in headers]))\n    for row in data:\n        click.echo(formatted_output.format(*row))", "response": "Generate space separated output for click commands."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates hash of directory.", "response": "def calculate_hash_of_dir(directory, file_list=None):\n    \"\"\"Calculate hash of directory.\"\"\"\n    md5_hash = md5()\n    if not os.path.exists(directory):\n        return -1\n\n    try:\n        for subdir, dirs, files in os.walk(directory):\n            for _file in files:\n                file_path = os.path.join(subdir, _file)\n                if file_list is not None and file_path not in file_list:\n                    continue\n                try:\n                    _file_object = open(file_path, 'rb')\n                except Exception:\n                    # You can't open the file for some reason\n                    _file_object.close()\n                    # We return -1 since we cannot ensure that the file that\n                    # can not be read, will not change from one execution to\n                    # another.\n                    return -1\n                while 1:\n                    # Read file in little chunks\n                    buf = _file_object.read(4096)\n                    if not buf:\n                        break\n                    md5_hash.update(md5(buf).hexdigest().encode())\n                _file_object.close()\n    except Exception:\n        return -1\n    return md5_hash.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef calculate_job_input_hash(job_spec, workflow_json):\n    if 'workflow_workspace' in job_spec:\n        del job_spec['workflow_workspace']\n    job_md5_buffer = md5()\n    job_md5_buffer.update(json.dumps(job_spec).encode('utf-8'))\n    job_md5_buffer.update(json.dumps(workflow_json).encode('utf-8'))\n    return job_md5_buffer.hexdigest()", "response": "Calculate md5 hash of job specification and workflow json."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates access times of files in workspace.", "response": "def calculate_file_access_time(workflow_workspace):\n    \"\"\"Calculate access times of files in workspace.\"\"\"\n    access_times = {}\n    for subdir, dirs, files in os.walk(workflow_workspace):\n        for file in files:\n            file_path = os.path.join(subdir, file)\n            access_times[file_path] = os.stat(file_path).st_atime\n    return access_times"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncopy generated and validated openapi specs to reana - commons module.", "response": "def copy_openapi_specs(output_path, component):\n    \"\"\"Copy generated and validated openapi specs to reana-commons module.\"\"\"\n    if component == 'reana-server':\n        file = 'reana_server.json'\n    elif component == 'reana-workflow-controller':\n        file = 'reana_workflow_controller.json'\n    elif component == 'reana-job-controller':\n        file = 'reana_job_controller.json'\n    if os.environ.get('REANA_SRCDIR'):\n        reana_srcdir = os.environ.get('REANA_SRCDIR')\n    else:\n        reana_srcdir = os.path.join('..')\n    try:\n        reana_commons_specs_path = os.path.join(\n            reana_srcdir,\n            'reana-commons',\n            'reana_commons',\n            'openapi_specifications')\n        if os.path.exists(reana_commons_specs_path):\n            if os.path.isfile(output_path):\n                shutil.copy(output_path,\n                            os.path.join(reana_commons_specs_path,\n                                         file))\n                # copy openapi specs file as well to docs\n                shutil.copy(output_path,\n                            os.path.join('docs', 'openapi.json'))\n    except Exception as e:\n        click.echo('Something went wrong, could not copy openapi '\n                   'specifications to reana-commons \\n{0}'.format(e))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving the correct verb conjugation depending on status tense.", "response": "def get_workflow_status_change_verb(status):\n    \"\"\"Give the correct verb conjugation depending on status tense.\n\n    :param status: String which represents the status the workflow changed to.\n    \"\"\"\n    verb = ''\n    if status.endswith('ing'):\n        verb = 'is'\n    elif status.endswith('ed'):\n        verb = 'has been'\n    else:\n        raise ValueError('Unrecognised status {}'.format(status))\n\n    return verb"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_progress_message(total=None,\n                           running=None,\n                           finished=None,\n                           failed=None,\n                           cached=None):\n    \"\"\"Build the progress message with correct formatting.\"\"\"\n    progress_message = {}\n    if total:\n        progress_message['total'] = total\n    if running:\n        progress_message['running'] = running\n    if finished:\n        progress_message['finished'] = finished\n    if failed:\n        progress_message['failed'] = failed\n    if cached:\n        progress_message['cached'] = cached\n    return progress_message", "response": "Build the progress message with correct formatting."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_caching_info_message(job_spec,\n                               job_id,\n                               workflow_workspace,\n                               workflow_json,\n                               result_path):\n    \"\"\"Build the caching info message with correct formatting.\"\"\"\n    caching_info_message = {\n        \"job_spec\": job_spec,\n        \"job_id\": job_id,\n        \"workflow_workspace\": workflow_workspace,\n        \"workflow_json\": workflow_json,\n        \"result_path\": result_path\n    }\n    return caching_info_message", "response": "Build the caching info message with correct formatting."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_workspace_disk_usage(workspace, summarize=False):\n    command = ['du', '-h']\n    if summarize:\n        command.append('-s')\n    else:\n        command.append('-a')\n    command.append(workspace)\n    disk_usage_info = subprocess.check_output(command).decode().split()\n    # create pairs of (size, filename)\n    filesize_pairs = list(zip(disk_usage_info[::2], disk_usage_info[1::2]))\n    filesizes = []\n    for filesize_pair in filesize_pairs:\n        size, name = filesize_pair\n        # trim workspace path in every file name\n        filesizes.append({'name': name[len(workspace):],\n                          'size': size})\n    return filesizes", "response": "Retrieve disk usage information of a workspace."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating CVMFS storage class.", "response": "def create_cvmfs_storage_class(cvmfs_volume):\n    \"\"\"Create CVMFS storage class.\"\"\"\n    from kubernetes.client.rest import ApiException\n    from reana_commons.k8s.api_client import current_k8s_storagev1_api_client\n\n    try:\n        current_k8s_storagev1_api_client.\\\n            create_storage_class(\n                render_cvmfs_sc(cvmfs_volume)\n            )\n    except ApiException as e:\n        if e.status != 409:\n            raise e"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_cvmfs_persistent_volume_claim(cvmfs_volume):\n    from kubernetes.client.rest import ApiException\n    from reana_commons.k8s.api_client import current_k8s_corev1_api_client\n\n    try:\n        current_k8s_corev1_api_client.\\\n            create_namespaced_persistent_volume_claim(\n                \"default\",\n                render_cvmfs_pvc(cvmfs_volume)\n            )\n    except ApiException as e:\n        if e.status != 409:\n            raise e", "response": "Create CVMFS persistent volume claim."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates Kubernetes API client using config.", "response": "def create_api_client(api='BatchV1'):\n    \"\"\"Create Kubernetes API client using config.\n\n    :param api: String which represents which Kubernetes API to spawn. By\n        default BatchV1.\n    :returns: Kubernetes python client object for a specific API i.e. BatchV1.\n    \"\"\"\n    k8s_config.load_incluster_config()\n    api_configuration = client.Configuration()\n    api_configuration.verify_ssl = False\n    if api == 'extensions/v1beta1':\n        api_client = client.ExtensionsV1beta1Api()\n    elif api == 'CoreV1':\n        api_client = client.CoreV1Api()\n    elif api == 'StorageV1':\n        api_client = client.StorageV1Api()\n    else:\n        api_client = client.BatchV1Api()\n    return api_client"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __error_callback(self, exception, interval):\n        logging.error('Error while publishing {}'.format(\n            exception))\n        logging.info('Retry in %s seconds.', interval)", "response": "Execute when there is an error while trying to send a message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _publish(self, msg):\n        connection = self._connection.clone()\n        publish = connection.ensure(self.producer, self.producer.publish,\n                                    errback=self.__error_callback,\n                                    max_retries=MQ_PRODUCER_MAX_RETRIES)\n        publish(json.dumps(msg), exchange=self._exchange,\n                routing_key=self._routing_key, declare=[self._queue])\n        logging.debug('Publisher: message sent: %s', msg)", "response": "Publish a message in the queue."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npublishing the status of a workflow.", "response": "def publish_workflow_status(self, workflow_uuid, status,\n                                logs='', message=None):\n        \"\"\"Publish workflow status using the configured.\n\n        :param workflow_uudid: String which represents the workflow UUID.\n        :param status: Integer which represents the status of the workflow,\n            this is defined in the `reana-db` `Workflow` models.\n        :param logs: String which represents the logs which the workflow\n            has produced as output.\n        :param message: Dictionary which includes additional information\n            can be attached such as the overall progress of the workflow.\n        \"\"\"\n        msg = {\n            \"workflow_uuid\": workflow_uuid,\n            \"logs\": logs,\n            \"status\": status,\n            \"message\": message\n        }\n        self._publish(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef publish_workflow_submission(self,\n                                    user_id,\n                                    workflow_id_or_name,\n                                    parameters):\n        \"\"\"Publish workflow submission parameters.\"\"\"\n        msg = {\n            \"user\": user_id,\n            \"workflow_id_or_name\": workflow_id_or_name,\n            \"parameters\": parameters\n        }\n        self._publish(msg)", "response": "Publish workflow submission parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates and return a REANA Serial workflow specification.", "response": "def serial_load(workflow_file, specification, parameters=None, original=None):\n    \"\"\"Validate and return a expanded REANA Serial workflow specification.\n\n    :param workflow_file: A specification file compliant with\n        REANA Serial workflow specification.\n    :returns: A dictionary which represents the valid Serial workflow with all\n        parameters expanded.\n    \"\"\"\n    parameters = parameters or {}\n\n    if not specification:\n        with open(workflow_file, 'r') as f:\n            specification = json.loads(f.read())\n\n    expanded_specification = _expand_parameters(specification,\n                                                parameters,\n                                                original)\n\n    validate(specification, serial_workflow_schema)\n\n    return expanded_specification"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexpand parameters inside a Serial workflow specification.", "response": "def _expand_parameters(specification, parameters, original=None):\n    \"\"\"Expand parameters inside comands for Serial workflow specifications.\n\n    :param specification: Full valid Serial workflow specification.\n    :param parameters: Parameters to be extended on a Serial specification.\n    :param original: Flag which, determins type of specifications to return.\n    :returns: If 'original' parameter is set, a copy of the specification\n        whithout expanded parametrers will be returned. If 'original' is not\n        set, a copy of the specification with expanded parameters (all $varname\n        and ${varname} will be expanded with their value). Otherwise an error\n        will be thrown if the parameters can not be expanded.\n    :raises: jsonschema.ValidationError\n    \"\"\"\n    expanded_specification = deepcopy(specification)\n\n    try:\n        for step_num, step in enumerate(expanded_specification['steps']):\n            current_step = expanded_specification['steps'][step_num]\n            for command_num, command in enumerate(step['commands']):\n                current_step['commands'][command_num] = \\\n                    Template(command).substitute(parameters)\n        # if call is done from client, original==True and original\n        # specifications withtout applied parameters are returned.\n        if original:\n            return specification\n        else:\n            return expanded_specification\n    except KeyError as e:\n        raise ValidationError('Workflow parameter(s) could not '\n                              'be expanded. Please take a look '\n                              'to {params}'.format(params=str(e)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reana_ready():\n    from reana_commons.config import REANA_READY_CONDITIONS\n    for module_name, condition_list in REANA_READY_CONDITIONS.items():\n        for condition_name in condition_list:\n            module = importlib.import_module(module_name)\n            condition_func = getattr(module, condition_name)\n            if not condition_func():\n                return False\n    return True", "response": "Check if reana can start new workflows."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks k8s predefined conditions for the nodes.", "response": "def check_predefined_conditions():\n    \"\"\"Check k8s predefined conditions for the nodes.\"\"\"\n    try:\n        node_info = current_k8s_corev1_api_client.list_node()\n        for node in node_info.items:\n            # check based on the predefined conditions about the\n            # node status: MemoryPressure, OutOfDisk, KubeletReady\n            #              DiskPressure, PIDPressure,\n            for condition in node.status.conditions:\n                if not condition.status:\n                    return False\n    except ApiException as e:\n        log.error('Something went wrong while getting node information.')\n        log.error(e)\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck upper limit on running jobs.", "response": "def check_running_job_count():\n    \"\"\"Check upper limit on running jobs.\"\"\"\n    try:\n        job_list = current_k8s_batchv1_api_client.\\\n            list_job_for_all_namespaces()\n        if len(job_list.items) > K8S_MAXIMUM_CONCURRENT_JOBS:\n            return False\n    except ApiException as e:\n        log.error('Something went wrong while getting running job list.')\n        log.error(e)\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget json specification from package data.", "response": "def _get_spec(self, spec_file):\n        \"\"\"Get json specification from package data.\"\"\"\n        spec_file_path = os.path.join(\n            pkg_resources.\n            resource_filename(\n                'reana_commons',\n                'openapi_specifications'),\n            spec_file)\n\n        with open(spec_file_path) as f:\n            json_spec = json.load(f)\n        return json_spec"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef submit(self,\n               workflow_uuid='',\n               experiment='',\n               image='',\n               cmd='',\n               prettified_cmd='',\n               workflow_workspace='',\n               job_name='',\n               cvmfs_mounts='false'):\n        \"\"\"Submit a job to RJC API.\n\n        :param name: Name of the job.\n        :param experiment: Experiment the job belongs to.\n        :param image: Identifier of the Docker image which will run the job.\n        :param cmd: String which represents the command to execute. It can be\n            modified by the workflow engine i.e. prepending ``cd /some/dir/``.\n        :prettified_cmd: Original command submitted by the user.\n        :workflow_workspace: Path to the workspace of the workflow.\n        :cvmfs_mounts: String with CVMFS volumes to mount in job pods.\n        :return: Returns a dict with the ``job_id``.\n        \"\"\"\n        job_spec = {\n            'experiment': experiment,\n            'docker_img': image,\n            'cmd': cmd,\n            'prettified_cmd': prettified_cmd,\n            'env_vars': {},\n            'workflow_workspace': workflow_workspace,\n            'job_name': job_name,\n            'cvmfs_mounts': cvmfs_mounts,\n            'workflow_uuid': workflow_uuid\n        }\n\n        response, http_response = self._client.jobs.create_job(job=job_spec).\\\n            result()\n        if http_response.status_code == 400:\n            raise HTTPBadRequest('Bad request to create a job. Error: {}'.\n                                 format(http_response.data))\n        elif http_response.status_code == 500:\n            raise HTTPInternalServerError('Internal Server Error. Error: {}'.\n                                          format(http_response.data))\n        return response", "response": "Submit a job to RJC API."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_status(self, job_id):\n        response, http_response = self._client.jobs.get_job(job_id=job_id).\\\n            result()\n        if http_response.status_code == 404:\n            raise HTTPNotFound('The given job ID was not found. Error: {}'.\n                               format(http_response.data))\n        return response", "response": "Check status of a job."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets logs of a job.", "response": "def get_logs(self, job_id):\n        \"\"\"Get logs of a job.\"\"\"\n        response, http_response = self._client.jobs.get_logs(job_id=job_id).\\\n            result()\n        if http_response.status_code == 404:\n            raise HTTPNotFound('The given job ID was not found. Error: {}'.\n                               format(http_response.data))\n        return http_response.text"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if job result is in cache.", "response": "def check_if_cached(self, job_spec, step, workflow_workspace):\n        \"\"\"Check if job result is in cache.\"\"\"\n        response, http_response = self._client.job_cache.check_if_cached(\n            job_spec=json.dumps(job_spec),\n            workflow_json=json.dumps(step),\n            workflow_workspace=workflow_workspace).\\\n            result()\n        if http_response.status_code == 400:\n            raise HTTPBadRequest('Bad request to check cache. Error: {}'.\n                                 format(http_response.data))\n        elif http_response.status_code == 500:\n            raise HTTPInternalServerError('Internal Server Error. Error: {}'.\n                                          format(http_response.data))\n        return http_response"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the Kubernetes volumeMount and volume for a given job spec.", "response": "def get_shared_volume(workflow_workspace, shared_volume_root):\n    \"\"\"Get shared CephFS/hostPath volume to a given job spec.\n\n    :param workflow_workspace: Absolute path to the job's workflow workspace.\n    :param shared_volume_root: Root path in the underlying storage backend.\n    :returns: Tuple consisting of the Kubernetes volumeMount and the volume.\n    \"\"\"\n    workflow_workspace_relative_to_owner = workflow_workspace\n    if os.path.isabs(workflow_workspace):\n        workflow_workspace_relative_to_owner = \\\n            os.path.relpath(workflow_workspace, shared_volume_root)\n    mount_path = os.path.join(shared_volume_root,\n                              workflow_workspace_relative_to_owner)\n    volume_mount = {\n        \"name\": REANA_SHARED_VOLUME_NAME,\n        \"mountPath\": mount_path,\n        \"subPath\": workflow_workspace_relative_to_owner}\n\n    if REANA_STORAGE_BACKEND == \"CEPHFS\":\n        volume = get_k8s_cephfs_volume()\n    else:\n        volume = get_k8s_hostpath_volume(shared_volume_root)\n\n    return volume_mount, volume"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self, name, cache_key,\n            local_path, remote_path,\n            local_options, remote_options, **kwargs):\n        \"\"\"\n        The main work horse of the transfer task. Calls the transfer\n        method with the local and remote storage backends as given\n        with the parameters.\n\n        :param name: name of the file to transfer\n        :type name: str\n        :param local_path: local storage class to transfer from\n        :type local_path: str\n        :param local_options: options of the local storage class\n        :type local_options: dict\n        :param remote_path: remote storage class to transfer to\n        :type remote_path: str\n        :param remote_options: options of the remote storage class\n        :type remote_options: dict\n        :param cache_key: cache key to set after a successful transfer\n        :type cache_key: str\n        :rtype: task result\n        \"\"\"\n        local = import_attribute(local_path)(**local_options)\n        remote = import_attribute(remote_path)(**remote_options)\n        result = self.transfer(name, local, remote, **kwargs)\n\n        if result is True:\n            cache.set(cache_key, True)\n            file_transferred.send(sender=self.__class__,\n                                  name=name, local=local, remote=remote)\n        elif result is False:\n            args = [name, cache_key, local_path,\n                    remote_path, local_options, remote_options]\n            self.retry(args=args, kwargs=kwargs)\n        else:\n            raise ValueError(\"Task '%s' did not return True/False but %s\" %\n                             (self.__class__, result))\n        return result", "response": "This method is the main work horse of the transfer task."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef transfer(self, name, local, remote, **kwargs):\n        try:\n            remote.save(name, local.open(name))\n            return True\n        except Exception as e:\n            logger.error(\"Unable to save '%s' to remote storage. \"\n                         \"About to retry.\" % name)\n            logger.exception(e)\n            return False", "response": "Transfers the file with the given name from the local storage backend to the remote storage backend."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_string(cfunc, *args):\n    cstr = get_ctype(\"const char**\", cfunc, *args)\n    return backend.ffi.string(cstr).decode() if cstr else None", "response": "Call a C function and return its return value as a Python string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling a function that takes a pointer as its last argument and returns the C object that it contains after the function has finished.", "response": "def get_ctype(rtype, cfunc, *args):\n    \"\"\" Call a C function that takes a pointer as its last argument and\n        return the C object that it contains after the function has finished.\n\n    :param rtype:   C data type is filled by the function\n    :param cfunc:   C function to call\n    :param args:    Arguments to call function with\n    :return:        A pointer to the specified data type\n    \"\"\"\n    val_p = backend.ffi.new(rtype)\n    args = args + (val_p,)\n    cfunc(*args)\n    return val_p[0]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an indirect pointer to a GPhoto2 type call its matching constructor function and return the pointer to it.", "response": "def new_gp_object(typename):\n    \"\"\" Create an indirect pointer to a GPhoto2 type, call its matching\n        constructor function and return the pointer to it.\n\n    :param typename:    Name of the type to create.\n    :return:            A pointer to the specified data type.\n    \"\"\"\n    obj_p = backend.ffi.new(\"{0}**\".format(typename))\n    backend.CONSTRUCTORS[typename](obj_p)\n    return obj_p[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_library_version():\n    version_str = ffi.string(lib.gp_library_version(True)[0]).decode()\n    return tuple(int(x) for x in version_str.split('.'))", "response": "Get the version number of the underlying gphoto2 library."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_cameras():\n    ctx = lib.gp_context_new()\n    camlist_p = new_gp_object(\"CameraList\")\n    port_list_p = new_gp_object(\"GPPortInfoList\")\n    lib.gp_port_info_list_load(port_list_p)\n    abilities_list_p = new_gp_object(\"CameraAbilitiesList\")\n    lib.gp_abilities_list_load(abilities_list_p, ctx)\n    lib.gp_abilities_list_detect(abilities_list_p, port_list_p,\n                                 camlist_p, ctx)\n    out = []\n    for idx in range(lib.gp_list_count(camlist_p)):\n        name = get_string(lib.gp_list_get_name, camlist_p, idx)\n        value = get_string(lib.gp_list_get_value, camlist_p, idx)\n\n        # Skip iteration if no matches\n        matches = re.match(r\"usb:(\\d+),(\\d+)\", value)\n        if not matches:\n            continue\n\n        bus_no, device_no = (int(x) for x in matches.groups())\n        abilities = ffi.new(\"CameraAbilities*\")\n        ability_idx = lib.gp_abilities_list_lookup_model(\n            abilities_list_p, name.encode())\n        lib.gp_abilities_list_get_abilities(abilities_list_p, ability_idx,\n                                            abilities)\n        if abilities.device_type == lib.GP_DEVICE_STILL_CAMERA:\n            out.append(Camera(bus_no, device_no, lazy=True,\n                              _abilities=abilities))\n    lib.gp_list_free(camlist_p)\n    lib.gp_port_info_list_free(port_list_p)\n    lib.gp_abilities_list_free(abilities_list_p)\n    return out", "response": "Return a list of all USB cameras that are supported by libgphoto2."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef supported_cameras():\n    ctx = lib.gp_context_new()\n    abilities_list_p = new_gp_object(\"CameraAbilitiesList\")\n    lib.gp_abilities_list_load(abilities_list_p, ctx)\n    abilities = ffi.new(\"CameraAbilities*\")\n    out = []\n    for idx in range(lib.gp_abilities_list_count(abilities_list_p)):\n        lib.gp_abilities_list_get_abilities(abilities_list_p, idx, abilities)\n        if abilities.device_type == lib.GP_DEVICE_STILL_CAMERA:\n            libname = os.path.basename(ffi.string(abilities.library)\n                                       .decode())\n            out.append((ffi.string(abilities.model).decode(), libname))\n    lib.gp_abilities_list_free(abilities_list_p)\n    key_func = lambda name, driver: driver\n    out = sorted(out, key=key_func)\n    return {k: tuple(x[0] for x in v)\n            for k, v in itertools.groupby(out, key_func)}\n    return out", "response": "List the names of all cameras supported by libgphoto2 grouped by the\n    name of their driver."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef path(self):\n        if self.parent is None:\n            return \"/\"\n        else:\n            return os.path.join(self.parent.path, self.name)", "response": "Absolute path to the camera s filesystem."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking whether the directory exists on the camera.", "response": "def exists(self):\n        \"\"\" Check whether the directory exists on the camera. \"\"\"\n        if self.name in (\"\", \"/\") and self.parent is None:\n            return True\n        else:\n            return self in self.parent.directories"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a generator that yields all files in the directory.", "response": "def files(self):\n        \"\"\" Get a generator that yields all files in the directory. \"\"\"\n        filelist_p = new_gp_object(\"CameraList\")\n        lib.gp_camera_folder_list_files(self._cam._cam, self.path.encode(),\n                                        filelist_p, self._cam._ctx)\n        for idx in range(lib.gp_list_count(filelist_p)):\n            fname = get_string(lib.gp_list_get_name, filelist_p, idx)\n            yield File(name=fname, directory=self, camera=self._cam)\n        lib.gp_list_free(filelist_p)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a generator that yields all subdirectories in the directory.", "response": "def directories(self):\n        \"\"\" Get a generator that yields all subdirectories in the directory.\n        \"\"\"\n        dirlist_p = new_gp_object(\"CameraList\")\n        lib.gp_camera_folder_list_folders(self._cam._cam, self.path.encode(),\n                                          dirlist_p, self._cam._ctx)\n        for idx in range(lib.gp_list_count(dirlist_p)):\n            name = os.path.join(\n                self.path, get_string(lib.gp_list_get_name, dirlist_p, idx))\n            yield Directory(name=name, parent=self, camera=self._cam)\n        lib.gp_list_free(dirlist_p)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nuploading a file to the camera s permanent storage.", "response": "def upload(self, local_path):\n        \"\"\" Upload a file to the camera's permanent storage.\n\n        :param local_path: Path to file to copy\n        :type local_path:  str/unicode\n        \"\"\"\n        camerafile_p = ffi.new(\"CameraFile**\")\n        with open(local_path, 'rb') as fp:\n            lib.gp_file_new_from_fd(camerafile_p, fp.fileno())\n            lib.gp_camera_folder_put_file(\n                self._cam._cam, self.path.encode() + b\"/\",\n                os.path.basename(local_path).encode(),\n                backend.FILE_TYPES['normal'], camerafile_p[0],\n                self._cam.ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef supported_operations(self):\n        return tuple(op for op in backend.FILE_OPS if self._operations & op)", "response": "All file operations supported by the camera."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the image dimensions.", "response": "def dimensions(self):\n        \"\"\" Dimensions of the image.\n\n        :rtype: :py:class:`ImageDimensions`\n        \"\"\"\n        return ImageDimensions(self._info.file.width, self._info.file.height)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the permissions of the file.", "response": "def permissions(self):\n        \"\"\" Permissions of the file.\n\n        Can be \"r-\" (read-only), \"-w\" (write-only), \"rw\" (read-write)\n        or \"--\" (no rights).\n\n        :rtype: str\n        \"\"\"\n        can_read = self._info.file.permissions & lib.GP_FILE_PERM_READ\n        can_write = self._info.file.permissions & lib.GP_FILE_PERM_DELETE\n        return \"{0}{1}\".format(\"r\" if can_read else \"-\",\n                               \"w\" if can_write else \"-\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves the content of the current object to a local file.", "response": "def save(self, target_path, ftype='normal'):\n        \"\"\" Save file content to a local file.\n\n        :param target_path: Path to save remote file as.\n        :type target_path:  str/unicode\n        :param ftype:       Select 'view' on file.\n        :type ftype:        str\n        \"\"\"\n        camfile_p = ffi.new(\"CameraFile**\")\n        with open(target_path, 'wb') as fp:\n            lib.gp_file_new_from_fd(camfile_p, fp.fileno())\n            lib.gp_camera_file_get(\n                self._cam._cam, self.directory.path.encode(),\n                self.name.encode(), backend.FILE_TYPES[ftype], camfile_p[0],\n                self._cam._ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the content of the file as a bytestring.", "response": "def get_data(self, ftype='normal'):\n        \"\"\" Get file content as a bytestring.\n\n        :param ftype:       Select 'view' on file.\n        :type ftype:        str\n        :return:            File content\n        :rtype:             bytes\n        \"\"\"\n        camfile_p = ffi.new(\"CameraFile**\")\n        lib.gp_file_new(camfile_p)\n        lib.gp_camera_file_get(\n            self._cam._cam, self.directory.path.encode(), self.name.encode(),\n            backend.FILE_TYPES[ftype], camfile_p[0], self._cam._ctx)\n        data_p = ffi.new(\"char**\")\n        length_p = ffi.new(\"unsigned long*\")\n        lib.gp_file_get_data_and_size(camfile_p[0], data_p, length_p)\n        byt = bytes(ffi.buffer(data_p[0], length_p[0]))\n        # gphoto2 camera files MUST be freed.\n        lib.gp_file_free(camfile_p[0])\n        # just to be safe.\n        del data_p, length_p, camfile_p\n        return byt"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget an iterator that yields the contents of the file.", "response": "def iter_data(self, chunk_size=2**16, ftype='normal'):\n        \"\"\" Get an iterator that yields chunks of the file content.\n\n        :param chunk_size:  Size of yielded chunks in bytes\n        :type chunk_size:   int\n        :param ftype:       Select 'view' on file.\n        :type ftype:        str\n        :return:            Iterator\n        \"\"\"\n        self._check_type_supported(ftype)\n        buf_p = ffi.new(\"char[{0}]\".format(chunk_size))\n        size_p = ffi.new(\"uint64_t*\")\n        offset_p = ffi.new(\"uint64_t*\")\n        for chunk_idx in range(int(math.ceil(self.size/chunk_size))):\n            size_p[0] = chunk_size\n            lib.gp_camera_file_read(\n                self._cam._cam, self.directory.path.encode(),\n                self.name.encode(), backend.FILE_TYPES[ftype], offset_p[0],\n                buf_p, size_p, self._cam._ctx)\n            yield ffi.buffer(buf_p, size_p[0])[:]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove(self):\n        lib.gp_camera_file_delete(self._cam._cam, self.directory.path.encode(),\n                                  self.name.encode(), self._cam._ctx)", "response": "Remove file from device."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the value of the option.", "response": "def set(self, value):\n        \"\"\" Update value of the option.\n\n        Only possible for options with :py:attr:`readonly` set to `False`.\n        If :py:attr:`type` is `choice`, the value must be one of the\n        :py:attr:`choices`.\n        If :py:attr:`type` is `range`, the value must be in the range\n        described by :py:attr:`range`.\n\n        :param value:   Value to set\n        \"\"\"\n        if self.readonly:\n            raise ValueError(\"Option is read-only.\")\n        val_p = None\n        if self.type == 'selection':\n            if value not in self.choices:\n                raise ValueError(\"Invalid choice (valid: {0})\".format(\n                                 repr(self.choices)))\n            val_p = ffi.new(\"const char[]\", value.encode())\n        elif self.type == 'text':\n            if not isinstance(value, basestring):\n                raise ValueError(\"Value must be a string.\")\n            val_p = ffi.new(\"char**\")\n            val_p[0] = ffi.new(\"char[]\", value.encode())\n        elif self.type == 'range':\n            if value < self.range.min or value > self.range.max:\n                raise ValueError(\"Value exceeds valid range ({0}-{1}.\"\n                                 .format(self.range.min, self.range.max))\n            if value % self.range.step:\n                raise ValueError(\"Value can only be changed in steps of {0}.\"\n                                 .format(self.range.step))\n            val_p = ffi.new(\"float*\")\n            val_p[0] = value\n        elif self.type == 'toggle':\n            if not isinstance(value, bool):\n                raise ValueError(\"Value must be bool.\")\n            val_p = ffi.new(\"int*\")\n            val_p[0] = int(value)\n        elif self.type == 'date':\n            val_p = ffi.new(\"int*\")\n            val_p[0] = value\n        lib.gp_widget_set_value(self._widget, val_p)\n        lib.gp_camera_set_config(self._cam._cam, self._root, self._cam._ctx)\n        self.value = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a tuple of all operations supported by the camera.", "response": "def supported_operations(self):\n        \"\"\" All operations supported by the camera. \"\"\"\n        return tuple(op for op in backend.CAM_OPS\n                     if self._abilities.operations & op)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the configuration parameters.", "response": "def config(self):\n        \"\"\" Writeable configuration parameters.\n\n        :rtype:     dict\n        \"\"\"\n        config = self._get_config()\n        return {section: {itm.name: itm for itm in config[section].values()\n                          if not itm.readonly}\n                for section in config\n                if 'settings' in section or section == 'other'}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef status(self):\n        config = self._get_config()\n        is_hex = lambda name: (len(name) == 4 and\n                               all(c in string.hexdigits for c in name))\n        out = SimpleNamespace()\n        for sect in config:\n            for itm in config[sect].values():\n                if (itm.readonly or sect == 'status') and not is_hex(itm.name):\n                    setattr(out, itm.name, itm.value)\n        return out", "response": "Status information ( read - only."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of all camera s storage information.", "response": "def storage_info(self):\n        \"\"\" Information about the camera's storage. \"\"\"\n        info_p = ffi.new(\"CameraStorageInformation**\")\n        num_info_p = ffi.new(\"int*\")\n        lib.gp_camera_get_storageinfo(self._cam, info_p, num_info_p, self._ctx)\n        infos = []\n        for idx in range(num_info_p[0]):\n            out = SimpleNamespace()\n            struc = (info_p[0] + idx)\n            fields = struc.fields\n            if lib.GP_STORAGEINFO_BASE & fields:\n                out.directory = next(\n                    (d for d in self.list_all_directories()\n                     if d.path == ffi.string(struc.basedir).decode()),\n                    None)\n            if lib.GP_STORAGEINFO_LABEL & fields:\n                out.label = ffi.string(struc.label).decode()\n            if lib.GP_STORAGEINFO_DESCRIPTION & fields:\n                out.description = ffi.string(struc.description).decode()\n            if lib.GP_STORAGEINFO_STORAGETYPE & fields:\n                stype = struc.type\n                if lib.GP_STORAGEINFO_ST_FIXED_ROM & stype:\n                    out.type = 'fixed_rom'\n                elif lib.GP_STORAGEINFO_ST_REMOVABLE_ROM & stype:\n                    out.type = 'removable_rom'\n                elif lib.GP_STORAGEINFO_ST_FIXED_RAM & stype:\n                    out.type = 'fixed_ram'\n                elif lib.GP_STORAGEINFO_ST_REMOVABLE_RAM & stype:\n                    out.type = 'removable_ram'\n                else:\n                    out.type = 'unknown'\n            if lib.GP_STORAGEINFO_ACCESS & fields:\n                if lib.GP_STORAGEINFO_AC_READWRITE & struc.access:\n                    out.access = 'read-write'\n                elif lib.GP_STORAGEINFO_AC_READONLY & struc.access:\n                    out.access = 'read-only'\n                elif lib.GP_STORAGEINFO_AC_READONLY_WITH_DELETE & struc.access:\n                    out.access = 'read-delete'\n            if lib.GP_STORAGEINFO_MAXCAPACITY & fields:\n                out.capacity = int(struc.capacitykbytes)\n            if lib.GP_STORAGEINFO_FREESPACEKBYTES & fields:\n                out.free_space = int(struc.freekbytes)\n            if lib.GP_STORAGEINFO_FREESPACEIMAGES & fields:\n                out.remaining_images = int(struc.freeimages)\n            infos.append(out)\n        return infos"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_all_files(self):\n        def list_files_recursively(directory):\n            f_gen = itertools.chain(\n                directory.files,\n                *tuple(list_files_recursively(d)\n                       for d in directory.directories))\n            for f in f_gen:\n                yield f\n        return list_files_recursively(self.filesystem)", "response": "Utility method that yields all files on the device s file\n            systems."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef capture(self, to_camera_storage=False):\n        target = self.config['settings']['capturetarget']\n        if to_camera_storage and target.value != \"Memory card\":\n            target.set(\"Memory card\")\n        elif not to_camera_storage and target.value != \"Internal RAM\":\n            target.set(\"Internal RAM\")\n        lib.gp_camera_trigger_capture(self._cam, self._ctx)\n\n        fobj = self._wait_for_event(event_type=lib.GP_EVENT_FILE_ADDED)\n        if to_camera_storage:\n            self._logger.info(\"File written to storage at {0}.\".format(fobj))\n            return fobj\n        else:\n            data = fobj.get_data()\n            try:\n                fobj.remove()\n            except errors.CameraIOError:\n                # That probably means the file is already gone from RAM,\n                # so nothing to worry about.\n                pass\n            return data", "response": "Capture an image.\n\n        Some cameras (mostly Canon and Nikon) support capturing to internal\n        RAM. On these devices, you have to specify `to_camera_storage` if\n        you want to save the images to the memory card. On devices that\n        do not support saving to RAM, the only difference is that the file\n        is automatically downloaded and deleted when set to `False`.\n\n        :param to_camera_storage:   Save image to the camera's internal storage\n        :type to_camera_storage:    bool\n        :return:    A :py:class:`File` if `to_camera_storage` was `True`,\n                    otherwise the captured image as a bytestring.\n        :rtype:     :py:class:`File` or bytes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncapturing a video. This always writes to the memory card, since internal RAM is likely to run out of space very quickly. Currently this only works with Nikon cameras. :param length: Length of the video to capture in seconds. :type length: int :return: Video file :rtype: :py:class:`File`", "response": "def capture_video(self, length):\n        \"\"\" Capture a video.\n\n        This always writes to the memory card, since internal RAM is likely\n        to run out of space very quickly.\n\n        Currently this only works with Nikon cameras.\n\n        :param length:      Length of the video to capture in seconds.\n        :type length:       int\n        :return:            Video file\n        :rtype:             :py:class:`File`\n        \"\"\"\n        with self.capture_video_context() as ctx:\n            time.sleep(length)\n        return ctx.videofile"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a preview image from the camera s viewport.", "response": "def get_preview(self):\n        \"\"\" Get a preview from the camera's viewport.\n\n        This will usually be a JPEG image with the dimensions depending on\n        the camera.  You will need to call the exit() method manually after\n        you are done capturing a live preview.\n\n        :return:    The preview image as a bytestring\n        :rtype:     bytes\n        \"\"\"\n        lib.gp_camera_capture_preview(self._cam, self.__camfile_p[0], self._ctx)\n        lib.gp_file_get_data_and_size(self.__camfile_p[0], self.__data_p, self.__length_p)\n        return ffi.buffer(self.__data_p[0], self.__length_p[0])[:]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_storage(self, name):\n        cache_result = cache.get(self.get_cache_key(name))\n        if cache_result:\n            return self.remote\n        elif cache_result is None and self.remote.exists(name):\n            cache.set(self.get_cache_key(name), True)\n            return self.remote\n        else:\n            return self.local", "response": "Returns the storage instance responsible for the given file name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open(self, name, mode='rb'):\n        return self.get_storage(name).open(name, mode)", "response": "Retrieves the specified file from the storage."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save(self, name, content, max_length=None):\n        cache_key = self.get_cache_key(name)\n        cache.set(cache_key, False)\n\n        # Use a name that is available on both the local and remote storage\n        # systems and save locally.\n        name = self.get_available_name(name)\n        try:\n            name = self.local.save(name, content, max_length=max_length)\n        except TypeError:\n            # Django < 1.10\n            name = self.local.save(name, content)\n\n        # Pass on the cache key to prevent duplicate cache key creation,\n        # we save the result in the storage to be able to test for it\n        if not self.delayed:\n            self.result = self.transfer(name, cache_key=cache_key)\n        return name", "response": "Saves the given content with the given name using the local storage."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntransfer the file with the given name to the remote storage backend by queuing the task. :param name: file name :type name: str :param cache_key: the cache key to set after a successful task run :type cache_key: str :rtype: task result", "response": "def transfer(self, name, cache_key=None):\n        \"\"\"\n        Transfers the file with the given name to the remote storage\n        backend by queuing the task.\n\n        :param name: file name\n        :type name: str\n        :param cache_key: the cache key to set after a successful task run\n        :type cache_key: str\n        :rtype: task result\n        \"\"\"\n        if cache_key is None:\n            cache_key = self.get_cache_key(name)\n        return self.task.delay(name, cache_key,\n                               self.local_path, self.remote_path,\n                               self.local_options, self.remote_options)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a filename that s free on both the local and remote storage structures and available for new content to be written to.", "response": "def get_available_name(self, name):\n        \"\"\"\n        Returns a filename that's free on both the local and remote storage\n        systems, and available for new content to be written to.\n\n        :param name: file name\n        :type name: str\n        :rtype: str\n        \"\"\"\n        local_available_name = self.local.get_available_name(name)\n        remote_available_name = self.remote.get_available_name(name)\n\n        if remote_available_name > local_available_name:\n            return remote_available_name\n        return local_available_name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_query_report(self, db_uri, parsed_query, db_name, collection_name):\n        index_analysis = None\n        recommendation = None\n        namespace = parsed_query['ns']\n        indexStatus = \"unknown\"\n\n        index_cache_entry = self._ensure_index_cache(db_uri,\n                                                     db_name,\n                                                     collection_name)\n\n\n        query_analysis = self._generate_query_analysis(parsed_query,\n                                                       db_name,\n                                                       collection_name)\n        if ((query_analysis['analyzedFields'] != []) and\n             query_analysis['supported']):\n            index_analysis = self._generate_index_analysis(query_analysis,\n                                                           index_cache_entry['indexes'])\n            indexStatus = index_analysis['indexStatus']\n            if index_analysis['indexStatus'] != 'full':\n                recommendation = self._generate_recommendation(query_analysis,\n                                                               db_name,\n                                                               collection_name)\n                # a temporary fix to suppress faulty parsing of $regexes.\n                # if the recommendation cannot be re-parsed into yaml, we assume\n                # it is invalid.\n                if not validate_yaml(recommendation['index']):\n                    recommendation = None\n                    query_analysis['supported'] = False\n\n\n        # QUERY REPORT\n        return OrderedDict({\n            'queryMask': parsed_query['queryMask'],\n            'indexStatus': indexStatus,\n            'parsed': parsed_query,\n            'namespace': namespace,\n            'queryAnalysis': query_analysis,\n            'indexAnalysis': index_analysis,\n            'recommendation': recommendation\n        })", "response": "Generates a comprehensive query report on the raw query"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _ensure_index_cache(self, db_uri, db_name, collection_name):\n        if not self._check_indexes or db_uri is None:\n            return {'indexes': None}\n        if db_name not in self.get_cache():\n            self._internal_map[db_name] = {}\n        if collection_name not in self._internal_map[db_name]:\n            indexes = []\n            try:\n                if self._index_cache_connection is None:\n                    self._index_cache_connection = pymongo.MongoClient(db_uri,\n                                                                       document_class=OrderedDict,\n                                                                       read_preference=pymongo.ReadPreference.PRIMARY_PREFERRED)\n\n                db = self._index_cache_connection[db_name]\n                indexes = db[collection_name].index_information()\n            except:\n                warning = 'Warning: unable to connect to ' + db_uri + \"\\n\"\n            else:\n                internal_map_entry = {'indexes': indexes}\n                self.get_cache()[db_name][collection_name] = internal_map_entry\n        return self.get_cache()[db_name][collection_name]", "response": "Adds a collections index entries to the cache if not present"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a Dex query analysis from a raw query object.", "response": "def _generate_query_analysis(self, parsed_query, db_name, collection_name):\n        \"\"\"Translates a raw query object into a Dex query analysis\"\"\"\n\n        analyzed_fields = []\n        field_count = 0\n        supported = True\n        sort_fields = []\n        query_mask = None\n\n        if 'command' in parsed_query and parsed_query['command'] not in SUPPORTED_COMMANDS:\n            supported = False\n        else:\n            #if 'orderby' in parsed_query:\n            sort_component = parsed_query['orderby'] if 'orderby' in parsed_query else []\n            sort_seq = 0\n            for key in sort_component:\n                sort_field = {'fieldName': key,\n                              'fieldType': SORT_TYPE,\n                              'seq': sort_seq}\n                sort_fields.append(key)\n                analyzed_fields.append(sort_field)\n                field_count += 1\n                sort_seq += 1\n\n            query_component = parsed_query['query'] if 'query' in parsed_query else {}\n            for key in query_component:\n                if key not in sort_fields:\n                    field_type = UNSUPPORTED_TYPE\n                    if ((key not in UNSUPPORTED_QUERY_OPERATORS) and\n                            (key not in COMPOSITE_QUERY_OPERATORS)):\n                        try:\n                            if query_component[key] == {}:\n                                raise\n                            nested_field_list = query_component[key].keys()\n                        except:\n                            field_type = EQUIV_TYPE\n                        else:\n                            for nested_field in nested_field_list:\n                                if ((nested_field in RANGE_QUERY_OPERATORS) and\n                                    (nested_field not in UNSUPPORTED_QUERY_OPERATORS)):\n                                    field_type = RANGE_TYPE\n                                else:\n                                    supported = False\n                                    field_type = UNSUPPORTED_TYPE\n                                    break\n\n                    if field_type is UNSUPPORTED_TYPE:\n                        supported = False\n\n                    analyzed_field = {'fieldName': key,\n                                      'fieldType': field_type}\n                    analyzed_fields.append(analyzed_field)\n                    field_count += 1\n\n        query_mask = parsed_query['queryMask']\n\n        # QUERY ANALYSIS\n        return OrderedDict({\n            'analyzedFields': analyzed_fields,\n            'fieldCount': field_count,\n            'supported': supported,\n            'queryMask': query_mask\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _generate_index_analysis(self, query_analysis, indexes):\n        needs_recommendation = True\n        full_indexes = []\n        partial_indexes = []\n        coverage = \"unknown\"\n\n        if indexes is not None:\n            for index_key in indexes.keys():\n                index = indexes[index_key]\n                index_report = self._generate_index_report(index,\n                                                           query_analysis)\n                if index_report['supported'] is True:\n                    if index_report['coverage'] == 'full':\n                        full_indexes.append(index_report)\n                        if index_report['idealOrder']:\n                            needs_recommendation = False\n                    elif index_report['coverage'] == 'partial':\n                        partial_indexes.append(index_report)\n\n        if len(full_indexes) > 0:\n            coverage = \"full\"\n        elif (len(partial_indexes)) > 0:\n            coverage = \"partial\"\n        elif query_analysis['supported']:\n            coverage = \"none\"\n\n        # INDEX ANALYSIS\n        return OrderedDict([('indexStatus', coverage),\n                            ('fullIndexes', full_indexes),\n                            ('partialIndexes', partial_indexes)])", "response": "Compares a query signature to the index cache to identify complete\n            and partial indexes available to the query"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _generate_index_report(self, index, query_analysis):\n\n        all_fields = []\n        equiv_fields = []\n        sort_fields = []\n        range_fields = []\n\n        for query_field in query_analysis['analyzedFields']:\n            all_fields.append(query_field['fieldName'])\n            if query_field['fieldType'] is EQUIV_TYPE:\n                equiv_fields.append(query_field['fieldName'])\n            elif query_field['fieldType'] is SORT_TYPE:\n                sort_fields.append(query_field['fieldName'])\n            elif query_field['fieldType'] is RANGE_TYPE:\n                range_fields.append(query_field['fieldName'])\n\n        max_equiv_seq = len(equiv_fields)\n        max_sort_seq = max_equiv_seq + len(sort_fields)\n        max_range_seq = max_sort_seq + len(range_fields)\n\n        coverage = 'none'\n        query_fields_covered = 0\n        query_field_count = query_analysis['fieldCount']\n        supported = True\n        ideal_order = True\n        for index_field in index['key']:\n            field_name = index_field[0]\n\n            if index_field[1] == '2d':\n                supported = False\n                break\n\n            if field_name not in all_fields:\n                break\n\n            if query_fields_covered == 0:\n                coverage = 'partial'\n\n            if query_fields_covered < max_equiv_seq:\n                if field_name not in equiv_fields:\n                    ideal_order = False\n            elif query_fields_covered < max_sort_seq:\n                if field_name not in sort_fields:\n                    ideal_order = False\n            elif query_fields_covered < max_range_seq:\n                if field_name not in range_fields:\n                    ideal_order = False\n            query_fields_covered += 1\n        if query_fields_covered == query_field_count:\n            coverage = 'full'\n\n        # INDEX REPORT\n        return OrderedDict({\n            'coverage': coverage,\n            'idealOrder': ideal_order,\n            'queryFieldsCovered': query_fields_covered,\n            'index': index,\n            'supported': supported\n        })", "response": "Generates a report for an index based on the query analysis."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _generate_recommendation(self,\n                                 query_analysis,\n                                 db_name,\n                                 collection_name):\n        \"\"\"Generates an ideal query recommendation\"\"\"\n        index_rec = '{'\n        for query_field in query_analysis['analyzedFields']:\n            if query_field['fieldType'] is EQUIV_TYPE:\n                if len(index_rec) is not 1:\n                    index_rec += ', '\n                index_rec += '\"' + query_field['fieldName'] + '\": 1'\n        for query_field in query_analysis['analyzedFields']:\n            if query_field['fieldType'] is SORT_TYPE:\n                if len(index_rec) is not 1:\n                    index_rec += ', '\n                index_rec += '\"' + query_field['fieldName'] + '\": 1'\n        for query_field in query_analysis['analyzedFields']:\n            if query_field['fieldType'] is RANGE_TYPE:\n                if len(index_rec) is not 1:\n                    index_rec += ', '\n                index_rec += '\"' + query_field['fieldName'] + '\": 1'\n        index_rec += '}'\n\n        # RECOMMENDATION\n        return OrderedDict([('index',index_rec),\n                            ('shellCommand', self.generate_shell_command(collection_name, index_rec))])", "response": "Generates an ideal query recommendation"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_query_occurrence(self, report):\n\n        initial_millis = int(report['parsed']['stats']['millis'])\n        mask = report['queryMask']\n\n        existing_report = self._get_existing_report(mask, report)\n\n        if existing_report is not None:\n            self._merge_report(existing_report, report)\n        else:\n            time = None\n            if 'ts' in report['parsed']:\n                time = report['parsed']['ts']\n            self._reports.append(OrderedDict([\n                ('namespace', report['namespace']),\n                ('lastSeenDate', time),\n                ('queryMask', mask),\n                ('supported', report['queryAnalysis']['supported']),\n                ('indexStatus', report['indexStatus']),\n                ('recommendation', report['recommendation']),\n                ('stats', OrderedDict([('count', 1),\n                                       ('totalTimeMillis', initial_millis),\n                                       ('avgTimeMillis', initial_millis)]))]))", "response": "Adds a report to the aggregation"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_reports(self):\n        return sorted(self._reports,\n                      key=lambda x: x['stats']['totalTimeMillis'],\n                      reverse=True)", "response": "Returns a minimized version of the aggregation"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the aggregated report that matches report", "response": "def _get_existing_report(self, mask, report):\n        \"\"\"Returns the aggregated report that matches report\"\"\"\n        for existing_report in self._reports:\n            if existing_report['namespace'] == report['namespace']:\n                if mask == existing_report['queryMask']:\n                    return existing_report\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmerges a new report into the target report", "response": "def _merge_report(self, target, new):\n        \"\"\"Merges a new report into the target report\"\"\"\n        time = None\n        if 'ts' in new['parsed']:\n            time = new['parsed']['ts']\n\n        if (target.get('lastSeenDate', None) and\n                time and\n                    target['lastSeenDate'] < time):\n            target['lastSeenDate'] = time\n\n        query_millis = int(new['parsed']['stats']['millis'])\n        target['stats']['totalTimeMillis'] += query_millis\n        target['stats']['count'] += 1\n        target['stats']['avgTimeMillis'] = target['stats']['totalTimeMillis'] / target['stats']['count']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse input into a sequence of items.", "response": "def parse(self, input):\n        \"\"\"Passes input to each QueryLineHandler in use\"\"\"\n        query = None\n        for handler in self._line_handlers:\n            try:\n                query = handler.handle(input)\n            except Exception as e:\n                query = None\n            finally:\n                if query is not None:\n                    return query\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nanalyzes a single query and generates a report of the results.", "response": "def generate_query_report(self, db_uri, query, db_name, collection_name):\n        \"\"\"Analyzes a single query\"\"\"\n        return self._query_analyzer.generate_query_report(db_uri,\n                                                          query,\n                                                          db_name,\n                                                          collection_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nanalyze queries from a given log file", "response": "def analyze_profile(self):\n        \"\"\"Analyzes queries from a given log file\"\"\"\n        profile_parser = ProfileParser()\n        databases = self._get_requested_databases()\n        connection = pymongo.MongoClient(self._db_uri,\n                                         document_class=OrderedDict,\n                                         read_preference=pymongo.ReadPreference.PRIMARY_PREFERRED)\n\n        if databases == []:\n            try:\n                databases = connection.database_names()\n            except:\n                message = \"Error: Could not list databases on server. Please \" \\\n                          +         \"check the auth components of your URI or provide \" \\\n                          +         \"a namespace filter with -n.\\n\"\n                sys.stderr.write(message)\n                databases = []\n\n            for ignore_db in IGNORE_DBS:\n                if ignore_db in databases:\n                    databases.remove(ignore_db)\n\n        for database in databases:\n\n            db = connection[database]\n\n            profile_entries = db['system.profile'].find()\n\n            for profile_entry in profile_entries:\n                self._process_query(profile_entry,\n                                    profile_parser)\n\n        self._output_aggregated_report(sys.stdout)\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef watch_profile(self):\n        profile_parser = ProfileParser()\n        databases = self._get_requested_databases()\n        connection = pymongo.MongoClient(self._db_uri,\n                                         document_class=OrderedDict,\n                                         read_preference=pymongo.ReadPreference.PRIMARY_PREFERRED)\n        enabled_profile = False\n\n        if databases == []:\n            try:\n                databases = connection.database_names()\n            except:\n                message = \"Error: Could not list databases on server. Please \" \\\n                          +         \"check the auth components of your URI.\\n\"\n                sys.stderr.write(message)\n                databases = []\n\n            for ignore_db in IGNORE_DBS:\n                if ignore_db in databases:\n                    databases.remove(ignore_db)\n\n        if len(databases) != 1:\n            message = \"Error: Please use namespaces (-n) to specify a single \" \\\n                      +         \"database for profile watching.\\n\"\n            sys.stderr.write(message)\n            return 1\n\n        database = databases[0]\n        db = connection[database]\n\n        initial_profile_level = db.profiling_level()\n\n        if initial_profile_level is pymongo.OFF:\n            message = \"Profile level currently 0. Dex is setting profile \" \\\n                      +         \"level 1. To run --watch at profile level 2, \" \\\n                      +         \"enable profile level 2 before running Dex.\\n\"\n            sys.stderr.write(message)\n            db.set_profiling_level(DEFAULT_PROFILE_LEVEL)\n\n        output_time = time.time() + WATCH_DISPLAY_REFRESH_SECONDS\n        try:\n            for profile_entry in self._tail_profile(db, WATCH_INTERVAL_SECONDS):\n                self._process_query(profile_entry,\n                                    profile_parser)\n                if time.time() >= output_time:\n                    self._output_aggregated_report(sys.stderr)\n                    output_time = time.time() + WATCH_DISPLAY_REFRESH_SECONDS\n        except KeyboardInterrupt:\n            sys.stderr.write(\"Interrupt received\\n\")\n        finally:\n            self._output_aggregated_report(sys.stdout)\n            if initial_profile_level is pymongo.OFF:\n                message = \"Dex is resetting profile level to initial value \" \\\n                          +         \"of 0. You may wish to drop the system.profile \" \\\n                          +         \"collection.\\n\"\n                sys.stderr.write(message)\n                db.set_profiling_level(initial_profile_level)\n\n        return 0", "response": "Analyzes queries from a given log file and writes them to the output file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nanalyzes queries from a given log file", "response": "def analyze_logfile(self, logfile_path):\n        self._run_stats['logSource'] = logfile_path\n        \"\"\"Analyzes queries from a given log file\"\"\"\n        with open(logfile_path) as obj:\n            self.analyze_logfile_object(obj)\n\n        self._output_aggregated_report(sys.stdout)\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nanalyze queries from a given log file object", "response": "def analyze_logfile_object(self, file_object):\n        \"\"\"Analyzes queries from a given log file\"\"\"\n        log_parser = LogParser()\n\n        if self._start_time is None:\n            self._start_time = datetime.now()\n            if self._timeout != 0:\n                self._end_time = self._start_time + timedelta(minutes=self._timeout)\n            else:\n                self._end_time = None\n\n        # For each line in the logfile ...\n        for line in file_object:\n            if self._end_time is not None and datetime.now() > self._end_time:\n                self._run_stats['timedOut'] = True\n                self._run_stats['timeoutInMinutes'] = self._timeout\n                break\n            self._process_query(line, log_parser)\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nanalyze queries from the tail of a given log file and writes them to the output", "response": "def watch_logfile(self, logfile_path):\n        \"\"\"Analyzes queries from the tail of a given log file\"\"\"\n        self._run_stats['logSource'] = logfile_path\n        log_parser = LogParser()\n\n        # For each new line in the logfile ...\n        output_time = time.time() + WATCH_DISPLAY_REFRESH_SECONDS\n        try:\n            firstLine = True\n            for line in self._tail_file(open(logfile_path),\n                                        WATCH_INTERVAL_SECONDS):\n                if firstLine:\n                    self._run_stats['timeRange']['start'] = get_line_time(line)\n                self._process_query(line, log_parser)\n                self._run_stats['timeRange']['end'] = get_line_time(line)\n                if time.time() >= output_time:\n                    self._output_aggregated_report(sys.stderr)\n                    output_time = time.time() + WATCH_DISPLAY_REFRESH_SECONDS\n        except KeyboardInterrupt:\n            sys.stderr.write(\"Interrupt received\\n\")\n        finally:\n            self._output_aggregated_report(sys.stdout)\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntailing the system. profile collection", "response": "def _tail_profile(self, db, interval):\n        \"\"\"Tails the system.profile collection\"\"\"\n        latest_doc = None\n        while latest_doc is None:\n            time.sleep(interval)\n            latest_doc = db['system.profile'].find_one()\n\n        current_time = latest_doc['ts']\n\n        while True:\n            time.sleep(interval)\n            cursor = db['system.profile'].find({'ts': {'$gte': current_time}}).sort('ts', pymongo.ASCENDING)\n            for doc in cursor:\n                current_time = doc['ts']\n                yield doc"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _tuplefy_namespace(self, namespace):\n        namespace_split = namespace.split('.', 1)\n        if len(namespace_split) is 1:\n            # we treat a single element as a collection name.\n            # this also properly tuplefies '*'\n            namespace_tuple = ('*', namespace_split[0])\n        elif len(namespace_split) is 2:\n            namespace_tuple = (namespace_split[0],namespace_split[1])\n        else:\n            return None\n        return namespace_tuple", "response": "Converts a mongodb namespace to a db collection tuple"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a list of db namespaces to a list of namespace tuples supporting basic commandline wildcards", "response": "def _validate_namespaces(self, input_namespaces):\n        \"\"\"Converts a list of db namespaces to a list of namespace tuples,\n            supporting basic commandline wildcards\"\"\"\n        output_namespaces = []\n        if input_namespaces == []:\n            return output_namespaces\n        elif '*' in input_namespaces:\n            if len(input_namespaces) > 1:\n                warning = 'Warning: Multiple namespaces are '\n                warning += 'ignored when one namespace is \"*\"\\n'\n                sys.stderr.write(warning)\n            return output_namespaces\n        else:\n            for namespace in input_namespaces:\n                if not isinstance(namespace, unicode):\n                    namespace = unicode(namespace)\n                namespace_tuple = self._tuplefy_namespace(namespace)\n                if namespace_tuple is None:\n                    warning = 'Warning: Invalid namespace ' + namespace\n                    warning += ' will be ignored\\n'\n                    sys.stderr.write(warning)\n                else:\n                    if namespace_tuple not in output_namespaces:\n                        output_namespaces.append(namespace_tuple)\n                    else:\n                        warning = 'Warning: Duplicate namespace ' + namespace\n                        warning += ' will be ignored\\n'\n                        sys.stderr.write(warning)\n        return output_namespaces"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _namespace_requested(self, namespace):\n        if namespace is None:\n            return False\n        namespace_tuple = self._tuplefy_namespace(namespace)\n        if namespace_tuple[0] in IGNORE_DBS:\n            return False\n        elif namespace_tuple[1] in IGNORE_COLLECTIONS:\n            return False\n        else:\n            return self._tuple_requested(namespace_tuple)", "response": "Checks whether the requested_namespaces contain the provided namespace"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _tuple_requested(self, namespace_tuple):\n        if not isinstance(namespace_tuple[0], unicode):\n            encoded_db = unicode(namespace_tuple[0])\n        else:\n            encoded_db = namespace_tuple[0]\n        if not isinstance(namespace_tuple[1], unicode):\n            encoded_coll = unicode(namespace_tuple[1])\n        else:\n            encoded_coll = namespace_tuple[1]\n\n        if namespace_tuple is None:\n            return False\n        elif len(self._requested_namespaces) is 0:\n            return True\n        for requested_namespace in self._requested_namespaces:\n            if  ((((requested_namespace[0]) == u'*') or\n                 (encoded_db == requested_namespace[0])) and\n                (((requested_namespace[1]) == u'*') or\n                 (encoded_coll == requested_namespace[1]))):\n                return True\n        return False", "response": "Helper for _namespace_requested. Supports limited wildcards"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of databases requested not including ignored dbs", "response": "def _get_requested_databases(self):\n        \"\"\"Returns a list of databases requested, not including ignored dbs\"\"\"\n        requested_databases = []\n        if ((self._requested_namespaces is not None) and\n                (self._requested_namespaces != [])):\n            for requested_namespace in self._requested_namespaces:\n                if requested_namespace[0] is '*':\n                    return []\n                elif requested_namespace[0] not in IGNORE_DBS:\n                    requested_databases.append(requested_namespace[0])\n        return requested_databases"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef retrieve(self, state=None, favorite=None, tag=None, contentType=None,\n                 sort=None, detailType=None, search=None, domain=None,\n                 since=None, count=None, offset=None):\n        \"\"\"\n        Retrieve the list of your articles\n        See: https://getpocket.com/developer/docs/v3/retrieve\n        :param state: filter by state\n        :param favorite: only fetch favorite\n        :param tag: filter by tag or _untagged_\n        :param contentType: get article, video or image\n        :param sort: sort by provided value\n        :param detailType: defines the response details to return\n        :param search: search term\n        :param domain: search domain\n        :param since: search modified since unix timestamp\n        :param count: the number of required items\n        :param offset: the position to start results from\n        :return: A dictionary containing the response result\n        :rtype: dict\n        \"\"\"\n        return self._make_request('get')", "response": "Retrieve the list of your articles with optional parameters"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bulk_add(self, item_id, ref_id=None, tags=None,\n                 time=None, title=None, url=None):\n        \"\"\"\n        Add an item to list\n        See: https://getpocket.com/developer/docs/v3/modify\n        :param item_id: int\n        :param ref_id: tweet_id\n        :param tags: list of tags\n        :param time: time of action\n        :param title: given title\n        :param url: item url\n        :return: self for chaining\n        :rtype: Pocket\n        \"\"\"\n        self._add_action('add')\n        return self", "response": "Add an item to the list of items"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister an action into bulk_actions", "response": "def _add_action(self, action):\n        \"\"\"\n        Register an action into bulk\n        :param action: action name\n        \"\"\"\n        kwargs = self._get_method_params()\n\n        kwargs['action'] = action\n\n        self._bulk_actions.append(kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nperform the request to the specified action name", "response": "def _make_request(self, action):\n        \"\"\"\n        Perform the request\n        :param action: action name\n        :return: a dict containing the request result\n        :rtype: dict\n        \"\"\"\n        if isinstance(action, list):\n            kwargs = {'actions': action}\n            action = 'send'\n        else:\n            kwargs = self._get_method_params()\n\n        kwargs.update({\n            'consumer_key': self._consumer_key,\n            'access_token': self._access_token\n        })\n\n        response = requests.post(\n            self._get_url(action),\n            json=kwargs,\n            headers=self._get_headers()\n        )\n\n        if response.status_code != requests.codes.ok:\n            raise self._make_exception(response)\n\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_method_params(self):\n        caller = sys._getframe(2)\n        var_names = list(caller.f_code.co_varnames)\n        caller_locals = caller.f_locals\n\n        var_names.remove('self')\n        kwargs = {key: value for key, value in caller_locals.items()\n                  if key in var_names and value is not None}\n        return kwargs", "response": "This method reads the caller s parameters and filters the params passed to the caller s make_request method."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _make_exception(self, response):\n        headers = response.headers\n\n        limit_headers = []\n        if 'X-Limit-User-Limit' in headers:\n            limit_headers = [\n                headers['X-Limit-User-Limit'],\n                headers['X-Limit-User-Remaining'],\n                headers['X-Limit-User-Reset'],\n                headers['X-Limit-Key-Limit'],\n                headers['X-Limit-Key-Remaining'],\n                headers['X-Limit-Key-Reset']\n            ]\n\n        x_error_code = int(headers['X-Error-Code'])\n        exc = PocketException\n        if x_error_code in self.auth_error_codes:\n            exc = PocketAutException\n\n        return exc(\n            response.status_code,\n            x_error_code,\n            headers['X-Error'],\n            *limit_headers\n        )", "response": "Construct an exception instance from the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_money_currency(self, money_currency):\n        if money_currency not in self.money_formats:\n            raise CurrencyDoesNotExist\n\n        self.money_currency = money_currency", "response": "Sets the money currency for the log entry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the money format for a given amount", "response": "def get_money_format(self, amount):\n        \"\"\"\n        :type amount: int or float or str\n\n        Usage:\n        >>> currency = Currency('USD')\n        >>> currency.get_money_format(13)\n        >>> '$13'\n        >>> currency.get_money_format(13.99)\n        >>> '$13.99'\n        >>> currency.get_money_format('13,2313,33')\n        >>> '$13,2313,33'\n\n        :rtype: str\n        \"\"\"\n        return self.money_formats[\n            self.get_money_currency()\n        ]['money_format'].format(amount=amount)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_money_with_currency_format(self, amount):\n        return self.money_formats[\n            self.get_money_currency()\n        ]['money_with_currency_format'].format(amount=amount)", "response": "Get money with currency format"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconnect to the Deluge instance and logs in to Deluge.", "response": "def connect(self):\n        \"\"\"\n        Connects to the Deluge instance\n        \"\"\"\n        self._connect()\n        logger.debug('Connected to Deluge, detecting daemon version')\n        self._detect_deluge_version()\n        logger.debug('Daemon version {} detected, logging in'.format(self.deluge_version))\n        if self.deluge_version == 2:\n            result = self.call('daemon.login', self.username, self.password, client_version='deluge-client')\n        else:\n            result = self.call('daemon.login', self.username, self.password)\n        logger.debug('Logged in with value %r' % result)\n        self.connected = True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling an RPC function and returns the response.", "response": "def call(self, method, *args, **kwargs):\n        \"\"\"\n        Calls an RPC function\n        \"\"\"\n        tried_reconnect = False\n        for _ in range(2):\n            try:\n                self._send_call(self.deluge_version, self.deluge_protocol_version, method, *args, **kwargs)\n                return self._receive_response(self.deluge_version, self.deluge_protocol_version)\n            except (socket.error, ConnectionLostException, CallTimeoutException):\n                if self.automatic_reconnect:\n                    if tried_reconnect:\n                        raise FailedToReconnectException()\n                    else:\n                        try:\n                            self.reconnect()\n                        except (socket.error, ConnectionLostException, CallTimeoutException):\n                            raise FailedToReconnectException()\n\n                    tried_reconnect = True\n                else:\n                    raise"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nserialize this StickerSet to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this StickerSet to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(StickerSet, self).to_array()\n        array['name'] = u(self.name)  # py2: type unicode, py3: type str\n\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        array['contains_masks'] = bool(self.contains_masks)  # type bool\n        array['stickers'] = self._as_array(self.stickers)  # type list of Sticker\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.media import Sticker\n        \n\n        data = {}\n        data['name'] = u(array.get('name'))\n        data['title'] = u(array.get('title'))\n        data['contains_masks'] = bool(array.get('contains_masks'))\n        data['stickers'] = Sticker.from_array_list(array.get('stickers'), list_level=1)\n        data['_raw'] = array\n        return StickerSet(**data)", "response": "Deserialize a new StickerSet from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nserialize this MaskPosition to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this MaskPosition to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(MaskPosition, self).to_array()\n        array['point'] = u(self.point)  # py2: type unicode, py3: type str\n\n        array['x_shift'] = float(self.x_shift)  # type float\n        array['y_shift'] = float(self.y_shift)  # type float\n        array['scale'] = float(self.scale)  # type float\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuses ACE to compile a grammar.", "response": "def compile(cfg_path, out_path, executable=None, env=None, log=None):\n    \"\"\"\n    Use ACE to compile a grammar.\n\n    Args:\n        cfg_path (str): the path to the ACE config file\n        out_path (str): the path where the compiled grammar will be\n            written\n        executable (str, optional): the path to the ACE binary; if\n            `None`, the `ace` command will be used\n        env (dict, optional): environment variables to pass to the ACE\n            subprocess\n        log (file, optional): if given, the file, opened for writing,\n            or stream to write ACE's stdout and stderr compile messages\n    \"\"\"\n    try:\n        check_call(\n            [(executable or 'ace'), '-g', cfg_path, '-G', out_path],\n            stdout=log, stderr=log, close_fds=True,\n            env=(env or os.environ)\n        )\n    except (CalledProcessError, OSError):\n        logging.error(\n            'Failed to compile grammar with ACE. See {}'\n            .format(log.name if log is not None else '<stderr>')\n        )\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_from_iterable(grm, data, **kwargs):\n    with AceParser(grm, **kwargs) as parser:\n        for datum in data:\n            yield parser.interact(datum)", "response": "Parse each sentence in data with ACE using grammar grm."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntransfers from each MRS in data with ACE using grammar grm.", "response": "def transfer_from_iterable(grm, data, **kwargs):\n    \"\"\"\n    Transfer from each MRS in *data* with ACE using grammar *grm*.\n\n    Args:\n        grm (str): path to a compiled grammar image\n        data (iterable): source MRSs as SimpleMRS strings\n        **kwargs: additional keyword arguments to pass to the\n            AceTransferer\n    Yields:\n        :class:`~delphin.interfaces.ParseResponse`\n    \"\"\"\n    with AceTransferer(grm, **kwargs) as transferer:\n        for datum in data:\n            yield transferer.interact(datum)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate from each MRS in data using ACE using grammar grm.", "response": "def generate_from_iterable(grm, data, **kwargs):\n    \"\"\"\n    Generate from each MRS in *data* with ACE using grammar *grm*.\n\n    Args:\n        grm (str): path to a compiled grammar image\n        data (iterable): MRSs as SimpleMRS strings\n        **kwargs: additional keyword arguments to pass to the\n            AceGenerator\n    Yields:\n        :class:`~delphin.interfaces.ParseResponse`\n    \"\"\"\n    with AceGenerator(grm, **kwargs) as generator:\n        for datum in data:\n            yield generator.interact(datum)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a string to the ACE.", "response": "def send(self, datum):\n        \"\"\"\n        Send *datum* (e.g. a sentence or MRS) to ACE.\n\n        Warning:\n          Sending data without reading (e.g., via :meth:`receive`) can\n          fill the buffer and cause data to be lost. Use the\n          :meth:`interact` method for most data-processing tasks with\n          ACE.\n        \"\"\"\n        try:\n            self._p.stdin.write((datum.rstrip() + '\\n'))\n            self._p.stdin.flush()\n        except (IOError, OSError):  # ValueError if file was closed manually\n            logging.info(\n                'Attempted to write to a closed process; attempting to reopen'\n            )\n            self._open()\n            self._p.stdin.write((datum.rstrip() + '\\n'))\n            self._p.stdin.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef interact(self, datum):\n        validated = self._validate_input(datum)\n        if validated:\n            self.send(validated)\n            result = self.receive()\n        else:\n            result, lines = _make_response(\n                [('NOTE: PyDelphin could not validate the input and '\n                  'refused to send it to ACE'),\n                 'SKIP: {}'.format(datum)],\n                self.run_info)\n        result['input'] = datum\n        return result", "response": "Send a datum to ACE and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a datum to ACE and return the response with context.", "response": "def process_item(self, datum, keys=None):\n        \"\"\"\n        Send *datum* to ACE and return the response with context.\n\n        The *keys* parameter can be used to track item identifiers\n        through an ACE interaction. If the `task` member is set on\n        the AceProcess instance (or one of its subclasses), it is\n        kept in the response as well.\n        Args:\n            datum (str): the input sentence or MRS\n            keys (dict): a mapping of item identifier names and values\n        Returns:\n            :class:`~delphin.interfaces.ParseResponse`\n        \"\"\"\n        response = self.interact(datum)\n        if keys is not None:\n            response['keys'] = keys\n        if 'task' not in response and self.task is not None:\n            response['task'] = self.task\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef close(self):\n        self.run_info['end'] = datetime.now()\n        self._p.stdin.close()\n        for line in self._p.stdout:\n            if line.startswith('NOTE: tsdb run:'):\n                self._read_run_info(line)\n            else:\n                logging.debug('ACE cleanup: {}'.format(line.rstrip()))\n        retval = self._p.wait()\n        return retval", "response": "Close the ACE process and return the process s exit code."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(fh, single=False):\n    ms = deserialize(fh)\n    if single:\n        ms = next(ms)\n    return ms", "response": "Deserialize DMRX from a file handle or filename."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef derivation(self):\n        drv = self.get('derivation')\n        if drv is not None:\n            if isinstance(drv, dict):\n                drv = Derivation.from_dict(drv)\n            elif isinstance(drv, stringtypes):\n                drv = Derivation.from_string(drv)\n        return drv", "response": "Deserialize and return a Derivation object for UDF - or\n        JSON - formatted derivation data ; otherwise return the original\n        string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mrs(self):\n        mrs = self.get('mrs')\n        if mrs is not None:\n            if isinstance(mrs, dict):\n                mrs = Mrs.from_dict(mrs)\n            elif isinstance(mrs, stringtypes):\n                mrs = simplemrs.loads_one(mrs)\n        return mrs", "response": "Deserialize and return an Mrs object for simplemrs or\n        JSON - formatted MRS data ; otherwise return the original string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef eds(self):\n        _eds = self.get('eds')\n        if _eds is not None:\n            if isinstance(_eds, dict):\n                _eds = eds.Eds.from_dict(_eds)\n            elif isinstance(_eds, stringtypes):\n                _eds = eds.loads_one(_eds)\n        return _eds", "response": "Deserialize and return an Eds object for native - or\n        JSON - formatted EDS data ; otherwise return the original string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dmrs(self):\n        dmrs = self.get('dmrs')\n        if dmrs is not None:\n            if isinstance(dmrs, dict):\n                dmrs = Dmrs.from_dict(dmrs)\n        return dmrs", "response": "Deserialize and return a Dmrs object for JSON - formatted DMRS\n        data ; otherwise return the original string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef map(self, response):\n        inserts = []\n\n        parse = {}\n        # custom remapping, cleanup, and filling in holes\n        parse['i-id'] = response.get('keys', {}).get('i-id', -1)\n        self._parse_id = max(self._parse_id + 1, parse['i-id'])\n        parse['parse-id'] = self._parse_id\n        parse['run-id'] = response.get('run', {}).get('run-id', -1)\n        if 'tokens' in response:\n            parse['p-input'] = response['tokens'].get('initial')\n            parse['p-tokens'] = response['tokens'].get('internal')\n            if 'ninputs' not in response:\n                toks = response.tokens('initial')\n                if toks is not None:\n                    response['ninputs'] = len(toks.tokens)\n            if 'ntokens' not in response:\n                toks = response.tokens('internal')\n                if toks is not None:\n                    response['ntokens'] = len(toks.tokens)\n        if 'readings' not in response and 'results' in response:\n            response['readings'] = len(response['results'])\n        # basic mapping\n        for key in self._parse_keys:\n            if key in response:\n                parse[key] = response[key]\n        inserts.append(('parse', parse))\n\n        for result in response.get('results', []):\n            d = {'parse-id': self._parse_id}\n            if 'flags' in result:\n                d['flags'] = SExpr.format(result['flags'])\n            for key in self._result_keys:\n                if key in result:\n                    d[key] = result[key]\n            inserts.append(('result', d))\n\n        if 'run' in response:\n            run_id = response['run'].get('run-id', -1)\n            # check if last run was not closed properly\n            if run_id not in self._runs and self._last_run_id in self._runs:\n                last_run = self._runs[self._last_run_id]\n                if 'end' not in last_run:\n                    last_run['end'] = datetime.now()\n            self._runs[run_id] = response['run']\n            self._last_run_id = run_id\n\n        return inserts", "response": "Process a response dict and return a list of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn aggregated ( table rowdata ) tuples and clear the state.", "response": "def cleanup(self):\n        \"\"\"\n        Return aggregated (table, rowdata) tuples and clear the state.\n        \"\"\"\n        inserts = []\n\n        last_run = self._runs[self._last_run_id]\n        if 'end' not in last_run:\n            last_run['end'] = datetime.now()\n\n        for run_id in sorted(self._runs):\n            run = self._runs[run_id]\n            d = {'run-id': run.get('run-id', -1)}\n            for key in self._run_keys:\n                if key in run:\n                    d[key] = run[key]\n            inserts.append(('run', d))\n\n        # reset for next task\n        self._parse_id = -1\n        self._runs = {}\n        self._last_run_id = -1\n\n        return inserts"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(GameHighScore, self).to_array()\n        array['position'] = int(self.position)  # type int\n        array['user'] = self.user.to_array()  # type User\n        array['score'] = int(self.score)  # type int\n        return array", "response": "Serializes this GameHighScore to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        from pytgbot.api_types.receivable.peer import User\n\n        data = {}\n        data['position'] = int(array.get('position'))\n        data['user'] = User.from_array(array.get('user'))\n        data['score'] = int(array.get('score'))\n        data['_raw'] = array\n        return GameHighScore(**data)", "response": "Deserialize a new GameHighScore instance from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dmrs_tikz_dependency(xs, **kwargs):\n    def link_label(link):\n        return '{}/{}'.format(link.rargname or '', link.post)\n\n    def label_edge(link):\n        if link.post == H_POST and link.rargname == RSTR_ROLE:\n            return 'rstr'\n        elif link.post == EQ_POST:\n            return 'eq'\n        else:\n            return 'arg'\n\n    if isinstance(xs, Xmrs):\n        xs = [xs]\n\n    lines = \"\"\"\\\\documentclass{standalone}\n\n\\\\usepackage{tikz-dependency}\n\\\\usepackage{relsize}\n\n%%%\n%%% style for dmrs graph\n%%%\n\\\\depstyle{dmrs}{edge unit distance=1.5ex, \n  label style={above, scale=.9, opacity=0, text opacity=1},\n  baseline={([yshift=-0.7\\\\baselineskip]current bounding box.north)}}\n%%% set text opacity=0 to hide text, opacity = 0 to hide box\n\\\\depstyle{root}{edge unit distance=3ex, label style={opacity=1}}\n\\\\depstyle{arg}{edge above}\n\\\\depstyle{rstr}{edge below, dotted, label style={text opacity=1}}\n\\\\depstyle{eq}{edge below, label style={text opacity=1}}\n\\\\depstyle{icons}{edge below, dashed}\n\\\\providecommand{\\\\named}{}  \n\\\\renewcommand{\\\\named}{named}\n\n%%% styles for predicates and roles (from mrs.sty)\n\\\\providecommand{\\\\spred}{} \n\\\\renewcommand{\\\\spred}[1]{\\\\mbox{\\\\textsf{#1}}}\n\\\\providecommand{\\\\srl}{} \n\\\\renewcommand{\\\\srl}[1]{\\\\mbox{\\\\textsf{\\\\smaller #1}}}\n%%%\n\n\\\\begin{document}\"\"\".split(\"\\n\")\n    \n    for ix, x in enumerate(xs):\n        lines.append(\"%%%\\n%%% {}\\n%%%\".format(ix+1)) \n        lines.append(\"\\\\begin{dependency}[dmrs]\")\n        ns = nodes(x)\n        ### predicates\n        lines.append(\"  \\\\begin{deptext}[column sep=10pt]\")\n        for i, n in enumerate(ns):\n            sep = \"\\\\&\"  if  (i < len(ns) - 1) else  \"\\\\\\\\\"\n            pred = _latex_escape(n.pred.short_form())\n            pred = \"\\\\named{}\" if pred == 'named' else pred\n            if n.carg is not None:\n                print(n.carg.strip('\"'))\n                pred += \"\\\\smaller ({})\".format(n.carg.strip('\"'))\n            lines.append(\"    \\\\spred{{{}}} {}     % node {}\".format(\n                pred, sep, i+1))\n        lines.append(\"  \\\\end{deptext}\")\n        nodeidx = {n.nodeid: i+1 for i, n in enumerate(ns)}\n        ### links\n        for link in links(x):\n            if link.start == 0:\n                lines.append(\n                    '  \\\\deproot[root]{{{}}}{{{}}}'.format(\n                        nodeidx[link.end],\n                        '\\\\srl{TOP}'  # _latex_escape('/' + link.post)\n                    )\n                )\n            else:\n                lines.append('  \\\\depedge[{}]{{{}}}{{{}}}{{\\\\srl{{{}}}}}'.format(\n                    label_edge(link),\n                    nodeidx[link.start],\n                    nodeidx[link.end],\n                    _latex_escape(link_label(link))\n                ))\n        ### placeholder for icons\n        lines.append('%  \\\\depedge[icons]{f}{t}{FOCUS}')\n        lines.append('\\\\end{dependency}\\n')\n    lines.append('\\\\end{document}')\n    return '\\n'.join(lines)", "response": "Returns a LaTeX document with each Xmrs in xs rendered as dmrs - tikz - dependency."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef valuemap(f):\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        if 'value' in kwargs:\n            val = kwargs['value']\n            del kwargs['value']\n            _f = f(*args, **kwargs)\n            def valued_f(*args, **kwargs):\n                result = _f(*args, **kwargs)\n                s, obj, span = result\n                if callable(val):\n                    return PegreResult(s, val(obj), span)\n                else:\n                    return PegreResult(s, val, span)\n            return valued_f\n        else:\n            return f(*args, **kwargs)\n    return wrapper", "response": "Decorator to help PEG functions handle value conversions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef literal(x):\n    xlen = len(x)\n    msg = 'Expected: \"{}\"'.format(x)\n    def match_literal(s, grm=None, pos=0):\n        if s[:xlen] == x:\n            return PegreResult(s[xlen:], x, (pos, pos+xlen))\n        raise PegreError(msg, pos)\n    return match_literal", "response": "Create a PEG function to consume a literal."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a PEG function to match a regular expression.", "response": "def regex(r):\n    \"\"\"\n    Create a PEG function to match a regular expression.\n    \"\"\"\n    if isinstance(r, stringtypes):\n        p = re.compile(r)\n    else:\n        p = r\n    msg = 'Expected to match: {}'.format(p.pattern)\n    def match_regex(s, grm=None, pos=0):\n        m = p.match(s)\n        if m is not None:\n            start, end = m.span()\n            data = m.groupdict() if p.groupindex else m.group()\n            return PegreResult(s[m.end():], data, (pos+start, pos+end))\n        raise PegreError(msg, pos)\n    return match_regex"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a PEG function to match a nonterminal.", "response": "def nonterminal(n):\n    \"\"\"\n    Create a PEG function to match a nonterminal.\n    \"\"\"\n    def match_nonterminal(s, grm=None, pos=0):\n        if grm is None: grm = {}\n        expr = grm[n]\n        return expr(s, grm, pos)\n    return match_nonterminal"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef and_next(e):\n    def match_and_next(s, grm=None, pos=0):\n        try:\n            e(s, grm, pos)\n        except PegreError as ex:\n            raise PegreError('Positive lookahead failed', pos)\n        else:\n            return PegreResult(s, Ignore, (pos, pos))\n    return match_and_next", "response": "Create a PEG function for positive lookahead."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef not_next(e):\n    def match_not_next(s, grm=None, pos=0):\n        try:\n            e(s, grm, pos)\n        except PegreError as ex:\n            return PegreResult(s, Ignore, (pos, pos))\n        else:\n            raise PegreError('Negative lookahead failed', pos)\n    return match_not_next", "response": "Create a PEG function for negative lookahead."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sequence(*es):\n    def match_sequence(s, grm=None, pos=0):\n        data = []\n        start = pos\n        for e in es:\n            s, obj, span = e(s, grm, pos)\n            pos = span[1]\n            if obj is not Ignore:\n                data.append(obj)\n        return PegreResult(s, data, (start, pos))\n    return match_sequence", "response": "Create a PEG function to match a sequence."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a PEG function to match an ordered choice.", "response": "def choice(*es):\n    \"\"\"\n    Create a PEG function to match an ordered choice.\n    \"\"\"\n    msg = 'Expected one of: {}'.format(', '.join(map(repr, es)))\n    def match_choice(s, grm=None, pos=0):\n        errs = []\n        for e in es:\n            try:\n                return e(s, grm, pos)\n            except PegreError as ex:\n                errs.append((ex.message, ex.position))\n        if errs:\n            raise PegreChoiceError(errs, pos)\n    return match_choice"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a PEG function to optionally match an expression.", "response": "def optional(e, default=Ignore):\n    \"\"\"\n    Create a PEG function to optionally match an expression.\n    \"\"\"\n    def match_optional(s, grm=None, pos=0):\n        try:\n            return e(s, grm, pos)\n        except PegreError:\n            return PegreResult(s, default, (pos, pos))\n    return match_optional"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef zero_or_more(e, delimiter=None):\n    if delimiter is None:\n        delimiter = lambda s, grm, pos: (s, Ignore, (pos, pos))\n    def match_zero_or_more(s, grm=None, pos=0):\n        start = pos\n        try:\n            s, obj, span = e(s, grm, pos)\n            pos = span[1]\n            data = [] if obj is Ignore else [obj]\n        except PegreError:\n            return PegreResult(s, [], (pos, pos))\n        try:\n            while True:\n                s, obj, span = delimiter(s, grm, pos)\n                pos = span[1]\n                if obj is not Ignore:\n                    data.append(obj)\n                s, obj, span = e(s, grm, pos)\n                pos = span[1]\n                if obj is not Ignore:\n                    data.append(obj)\n        except PegreError:\n            pass\n        return PegreResult(s, data, (start, pos))\n    return match_zero_or_more", "response": "Create a PEG function to match zero or more expressions."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a PEG function to match one or more expressions.", "response": "def one_or_more(e, delimiter=None):\n    \"\"\"\n    Create a PEG function to match one or more expressions.\n\n    Args:\n        e: the expression to match\n        delimiter: an optional expression to match between the\n            primary *e* matches.\n    \"\"\"\n    if delimiter is None:\n        delimiter = lambda s, grm, pos: (s, Ignore, (pos, pos))\n    msg = 'Expected one or more of: {}'.format(repr(e))\n    def match_one_or_more(s, grm=None, pos=0):\n        start = pos\n        s, obj, span = e(s, grm, pos)\n        pos = span[1]\n        data = [] if obj is Ignore else [obj]\n        try:\n            while True:\n                s, obj, span = delimiter(s, grm, pos)\n                pos = span[1]\n                if obj is not Ignore:\n                    data.append(obj)\n                s, obj, span = e(s, grm, pos)\n                pos = span[1]\n                if obj is not Ignore:\n                    data.append(obj)\n        except PegreError:\n            pass\n        return PegreResult(s, data, (start, pos))\n    return match_one_or_more"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef merge(base, obj, location=None):\n    # pump object to it's location with dummy nodes\n    while location:\n        axis = location.pop()\n        obj = XmrsPathNode(None, None, links={axis: obj})\n    if base is None:\n        return obj\n    _merge(base, obj)\n    # if isinstance(base, XmrsPath):\n    #     base.calculate_metrics()\n    return base", "response": "merge two objects into a single object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _prepare_axes(node, sort_key):\n    links = node.links\n    o_links = node._overlapping_links\n    overlap = {ax2 for ax in links for ax2 in o_links.get(ax, [])}\n    axes = []\n    for axis in sorted(links.keys(), key=sort_key):\n        if axis in overlap: continue\n        tgt = links[axis]\n        if axis in o_links:\n            s, e = axis[0], axis[-1]\n            axis = '%s%s%s' % (\n                s, '&'.join(a[1:-1] for a in [axis] + o_links[axis]), e\n            )\n        axes.append((axis, tgt))\n    return axes", "response": "Sort axes and combine those that point to the same target and go\n    in the same direction."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the value for a key.", "response": "def get(self, key, default=None):\n        \"\"\"\n        Return the value for *key* if it exists, otherwise *default*.\n        \"\"\"\n        try:\n            val = self[key]\n        except KeyError:\n            val = default\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the list of tuples of feature paths and feature values.", "response": "def features(self, expand=False):\n        \"\"\"\n        Return the list of tuples of feature paths and feature values.\n\n        Args:\n            expand (bool): if `True`, expand all feature paths\n        Example:\n            >>> fs = FeatureStructure([('A.B', 1), ('A.C', 2)])\n            >>> fs.features()\n            [('A', <FeatureStructure object at ...>)]\n            >>> fs.features(expand=True)\n            [('A.B', 1), ('A.C', 2)]\n        \"\"\"\n        fs = []\n        if self._avm is not None:\n            if len(self._feats) == len(self._avm):\n                feats = self._feats\n            else:\n                feats = list(self._avm)\n            for feat in feats:\n                val = self._avm[feat]\n                if isinstance(val, FeatureStructure):\n                    if not expand and val._is_notable():\n                        fs.append((feat, val))\n                    else:\n                        for subfeat, subval in val.features(expand=expand):\n                            fs.append(('{}.{}'.format(feat, subfeat), subval))\n                else:\n                    fs.append((feat, val))\n        return fs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the ancestors of the given type.", "response": "def ancestors(self, typename):\n        \"\"\"Return the ancestor types of *typename*.\"\"\"\n        xs = []\n        for parent in self._hier[typename][0]:\n            xs.append(parent)\n            xs.extend(self.ancestors(parent))\n        return xs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef descendants(self, typename):\n        xs = []\n        for child in self._hier[typename][1]:\n            xs.append(child)\n            xs.extend(self.descendants(child))\n        return xs", "response": "Return the descendant types of typename."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef subsumes(self, a, b):\n        return a == b or b in self.descendants(a)", "response": "Return True if type a subsumes type b."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if type a is compatible with type b.", "response": "def compatible(self, a, b):\n        \"\"\"Return `True` if type *a* is compatible with type *b*.\"\"\"\n        return len(set([a] + self.descendants(a))\n                   .intersection([b] + self.descendants(b))) > 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if Xmrs objects q and g are isomorphic.", "response": "def isomorphic(q, g, check_varprops=True):\n    \"\"\"\n    Return `True` if Xmrs objects *q* and *g* are isomorphic.\n\n    Isomorphicity compares the predicates of an Xmrs, the variable\n    properties of their predications (if `check_varprops=True`),\n    constant arguments, and the argument structure between\n    predications. Node IDs and Lnk values are ignored.\n\n    Args:\n        q: the left Xmrs to compare\n        g: the right Xmrs to compare\n        check_varprops: if `True`, make sure variable properties are\n            equal for mapped predications\n    \"\"\"\n\n    qdg = _make_digraph(q, check_varprops)\n    gdg = _make_digraph(g, check_varprops)\n    def nem(qd, gd):  # node-edge-match\n        return qd.get('sig') == gd.get('sig')\n    return nx.is_isomorphic(qdg, gdg, node_match=nem, edge_match=nem)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if a given Xmrs q is isomorphic to given Xmrs g.", "response": "def _turbo_isomorphic(q, g, check_varprops=True):\n    \"\"\"\n    Query Xmrs q is isomorphic to given Xmrs g if there exists an\n    isomorphism (bijection of eps and vars) from q to g.\n    \"\"\"\n    # first some quick checks\n    if len(q.eps()) != len(g.eps()): return False\n    if len(q.variables()) != len(g.variables()): return False\n    #if len(a.hcons()) != len(b.hcons()): return False\n    try:\n        next(_isomorphisms(q, g, check_varprops=check_varprops))\n        return True\n    except StopIteration:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninspire by Turbo_ISO: http://dl.acm.org/citation.cfm?id=2465300", "response": "def _isomorphisms(q, g, check_varprops=True):\n    \"\"\"\n    Inspired by Turbo_ISO: http://dl.acm.org/citation.cfm?id=2465300\n    \"\"\"\n    # convert MRSs to be more graph-like, and add some indices\n    qig = _IsoGraph(q, varprops=check_varprops)  # qig = q isograph\n    gig = _IsoGraph(g, varprops=check_varprops)  # gig = q isograph\n    # qsigs, qsigidx = _isomorphism_sigs(q, check_varprops)\n    # gsigs, gsigidx = _isomorphism_sigs(g, check_varprops)\n    # (it would be nice to not have to do this... maybe later)\n    # qadj = _isomorphism_adj(q, qsigidx)\n    # gadj = _isomorphism_adj(g, gsigidx)\n    # the degree of each node is useful (but can it be combined with adj?)\n    # qdeg = _isomorphism_deg(qadj)\n    # gdeg = _isomorphism_deg(gadj)\n\n    u_s = _isomorphism_choose_start_q_vertex(qig, gig, subgraph=False)\n    q_ = _isomorphism_rewrite_to_NECtree(u_s, qig)\n    for v_s in gsigs.get(qsigidx[u_s], []):\n        cr = _isomorphism_explore_CR(q_, {v_s}, qig, gig)\n        if cr is None:\n            continue\n        order = _isomorphism_determine_matching_order(q_, cr)\n        update_state(M,F,{u_s}, {v_s})\n        subraph_search(q, q_, g, order, 1)  # 1=\"the first query vertex to match\"\n        restore_state(M, F, {u_s}, {v_s})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrewriting the isomorphism to NEC tree", "response": "def _isomorphism_rewrite_to_NECtree(q_s, qgraph):\n    \"\"\"\n    Neighborhood Equivalence Class tree (see Turbo_ISO paper)\n    \"\"\"\n    qadj = qgraph.adj\n    adjsets = lambda x: set(chain.from_iterable(qadj[x].values()))\n    t = ([q_s], [])  # (NEC_set, children)\n    visited = {q_s}\n    vcur, vnext = [t], []\n    while vcur:\n        for (nec, children) in vcur:\n            c = defaultdict(list)\n            for u in nec:\n                for sig, adjlist in qadj[u].items():\n                    c[sig].extend(x for x, _, _ in adjlist if x not in visited)\n            for sig, c_adjlist in c.items():\n                visited.update(c_adjlist)\n                # these are already grouped by label; now group by adjacents\n                for key, grp in groupby(c_adjlist, key=adjsets):\n                    grp = list(grp)\n                    if len(grp) > 1:\n                        children.append((list(grp), []))\n                    else:\n                        # NOTE: the paper says to look for mergeable things,\n                        # but I don't know what else to merge by.\n                        children.append((list(grp), []))\n            vnext.extend(children)\n        vcur, vnext = vnext, []\n    return t"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if two Xmrs objects are isomorphic.", "response": "def _node_isomorphic(a, b, check_varprops=True):\n    \"\"\"\n    Two Xmrs objects are isomorphic if they have the same structure as\n    determined by variable linkages between preds.\n    \"\"\"\n    # first some quick checks\n    a_var_refs = sorted(len(vd['refs']) for vd in a._vars.values())\n    b_var_refs = sorted(len(vd['refs']) for vd in b._vars.values())\n    if a_var_refs != b_var_refs:\n        return False\n    print()\n\n    # these signature: [node] indices are meant to avoid unnecessary\n    # comparisons; they also take care of \"semantic feasibility\"\n    # constraints (comparing node values and properties). All that's\n    # left is the \"syntactic feasibility\", or node-edge shapes.\n    # nodedicts are {sig: [(id, edges), ...], ...}\n    a_nd = _node_isomorphic_build_nodedict(a, check_varprops)\n    #print('a', a_nd)\n    b_nd = _node_isomorphic_build_nodedict(b, check_varprops)\n    #print('b', b_nd)\n    #return\n\n    a_sigs = {}  # for node -> sig mapping\n    # don't recurse when things are unique\n    agenda = []\n    isomap = {}\n    for sig, a_pairs in sorted(a_nd.items(), key=lambda x: len(x[1])):\n        b_pairs = b_nd.get(sig, [])\n        if len(a_pairs) != len(b_pairs):\n            return False\n        if len(a_pairs) == 1:\n            a_, a_edges = a_pairs[0]\n            b_, b_edges = b_pairs[0]\n            if len(a_edges) != len(b_edges):\n                return False\n            a_sigs[a_] = sig\n            isomap[a_] = b_\n            for edge, a_tgt in a_edges.items():\n                if edge not in b_edges:\n                    return False\n                isomap[a_tgt] = b_edges[edge]\n        else:\n            for a_, ed in a_pairs:\n                a_sigs[a_] = sig\n                agenda.append((a_, sig, ed))\n    #print(agenda)\n    #return\n    isomaps = _node_isomorphic(agenda, a_sigs, b_nd, isomap, {})\n    # for sig, a_candidates in sorted(a_nodes.items(), key=lambda x: len(x[1])):\n    #     b_candidates = b_nodes.get(sig, [])\n    #     if len(a_candidates) != len(b_candidates): return False\n    #     candidates.append((a_candidates, b_candidates))\n    #\n    # nodemaps = _isomorphic(a, b, candidates, {})\n    try:\n        next(isomaps)\n        return True\n    except StopIteration:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if two Xmrs objects are isomorphic.", "response": "def _var_isomorphic(a, b, check_varprops=True):\n    \"\"\"\n    Two Xmrs objects are isomorphic if they have the same structure as\n    determined by variable linkages between preds.\n    \"\"\"\n    # first some quick checks\n    if len(a.eps()) != len(b.eps()): return False\n    if len(a.variables()) != len(b.variables()): return False\n    #if len(a.hcons()) != len(b.hcons()): return False\n\n    # pre-populate varmap; first top variables\n    varmap = {}\n    for pair in [(a.top, b.top), (a.index, b.index), (a.xarg, b.xarg)]:\n        if pair != (None, None):\n            v1, v2 = pair\n            if None in pair:\n                return False\n            if check_varprops and a.properties(v1) != b.properties(v2):\n                return False\n            varmap[v1] = v2\n\n    # find permutations of variables, grouped by those that share the\n    # same signature.\n\n    a_sigs = defaultdict(list)\n    for var, vd in a._vars.items():\n        if var not in varmap:\n            var_sig = _isomorphic_var_signature(vd, a, check_varprops)\n            a_sigs[var_sig].append(var)\n    b_sigs = defaultdict(list)\n    tgtmapped = set(varmap.values())\n    for var, vd in b._vars.items():\n        if var not in tgtmapped:\n            var_sig = _isomorphic_var_signature(vd, b, check_varprops)\n            b_sigs[var_sig].append(var)\n\n    candidates = []\n    for sig, a_vars in sorted(a_sigs.items(), key=lambda x: len(x[1])):\n        b_vars = b_sigs.get(sig, [])\n        if len(a_vars) != len(b_vars):\n            return False\n        print(sig, a_vars, b_vars)\n        candidates.append((a_vars, b_vars))\n\n    varmaps = _var_isomorphic(a, b, candidates, varmap)\n\n    # double check HCONS (it's hard to do with var signatures)\n    for vm in varmaps:\n        if all(vm[lo] == b._hcons.get(vm[hi], (None, None, None))[2]\n               for hi, _, lo in a.hcons()):\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomparing two bags of Xmrs objects returning a triple of the unique in test shared and unique in gold.", "response": "def compare_bags(testbag, goldbag, count_only=True):\n    \"\"\"\n    Compare two bags of Xmrs objects, returning a triple of\n    (unique in test, shared, unique in gold).\n\n    Args:\n        testbag: An iterable of Xmrs objects to test.\n        goldbag: An iterable of Xmrs objects to compare against.\n        count_only: If True, the returned triple will only have the\n            counts of each; if False, a list of Xmrs objects will be\n            returned for each (using the ones from testbag for the\n            shared set)\n    Returns:\n        A triple of (unique in test, shared, unique in gold), where\n        each of the three items is an integer count if the count_only\n        parameter is True, or a list of Xmrs objects otherwise.\n    \"\"\"\n    gold_remaining = list(goldbag)\n    test_unique = []\n    shared = []\n    for test in testbag:\n        gold_match = None\n        for gold in gold_remaining:\n            if isomorphic(test, gold):\n                gold_match = gold\n                break\n        if gold_match is not None:\n            gold_remaining.remove(gold_match)\n            shared.append(test)\n        else:\n            test_unique.append(test)\n    if count_only:\n        return (len(test_unique), len(shared), len(gold_remaining))\n    else:\n        return (test_unique, shared, gold_remaining)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying the specified TSQL query string on the specified testsuite.", "response": "def query(query, ts, **kwargs):\n    \"\"\"\n    Perform *query* on the testsuite *ts*.\n\n    Note: currently only 'select' queries are supported.\n\n    Args:\n        query (str): TSQL query string\n        ts (:class:`delphin.itsdb.TestSuite`): testsuite to query over\n        kwargs: keyword arguments passed to the more specific query\n            function (e.g., :func:`select`)\n    Example:\n        >>> list(tsql.query('select i-id where i-length < 4', ts))\n        [[142], [1061]]\n    \"\"\"\n    queryobj = _parse_query(query)\n\n    if queryobj['querytype'] in ('select', 'retrieve'):\n        return _select(\n            queryobj['projection'],\n            queryobj['tables'],\n            queryobj['where'],\n            ts,\n            mode=kwargs.get('mode', 'list'),\n            cast=kwargs.get('cast', True))\n    else:\n        # not really a syntax error; replace with TSQLError or something\n        # when the proper exception class exists\n        raise TSQLSyntaxError(queryobj['querytype'] +\n                              ' queries are not supported')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef select(query, ts, mode='list', cast=True):\n    queryobj = _parse_select(query)\n    return _select(\n        queryobj['projection'],\n        queryobj['tables'],\n        queryobj['where'],\n        ts,\n        mode,\n        cast)", "response": "Perform the TSQL select query on the specified testsuite."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nuse this method to receive incoming updates using long polling (wiki). An Array of Update objects is returned. Notes1. This method will not work if an outgoing webhook is set up.2. In order to avoid getting duplicate updates, recalculate offset after each server response. https://core.telegram.org/bots/api#getupdates Optional keyword parameters: :param offset: Identifier of the first update to be returned. Must be greater by one than the highest among the identifiers of previously received updates. By default, updates starting with the earliest unconfirmed update are returned. An update is considered confirmed as soon as getUpdates is called with an offset higher than its update_id. The negative offset can be specified to retrieve updates starting from -offset update from the end of the updates queue. All previous updates will forgotten. :type offset: int :param limit: Limits the number of updates to be retrieved. Values between 1\u2014100 are accepted. Defaults to 100. :type limit: int :param timeout: Timeout in seconds for long polling. Defaults to 0, i.e. usual short polling. Should be positive, short polling should be used for testing purposes only. :type timeout: int :param allowed_updates: List the types of updates you want your bot to receive. For example, specify [\u201cmessage\u201d, \u201cedited_channel_post\u201d, \u201ccallback_query\u201d] to only receive updates of these types. See Update for a complete list of available update types. Specify an empty list to receive all updates regardless of type (default). If not specified, the previous setting will be used.Please note that this parameter doesn't affect updates created before the call to the getUpdates, so unwanted updates may be received for a short period of time. :type allowed_updates: list of str|unicode Returns: :return: An Array of Update objects is returned :rtype: list of pytgbot.api_types.receivable.updates.Update", "response": "def get_updates(self, offset=None, limit=None, timeout=None, allowed_updates=None):\n        \"\"\"\n        Use this method to receive incoming updates using long polling (wiki). An Array of Update objects is returned.\n\n        Notes1. This method will not work if an outgoing webhook is set up.2. In order to avoid getting duplicate updates, recalculate offset after each server response.\n\n\n        https://core.telegram.org/bots/api#getupdates\n\n        \n        Optional keyword parameters:\n        \n        :param offset: Identifier of the first update to be returned. Must be greater by one than the highest among the identifiers of previously received updates. By default, updates starting with the earliest unconfirmed update are returned. An update is considered confirmed as soon as getUpdates is called with an offset higher than its update_id. The negative offset can be specified to retrieve updates starting from -offset update from the end of the updates queue. All previous updates will forgotten.\n        :type  offset: int\n        \n        :param limit: Limits the number of updates to be retrieved. Values between 1\u2014100 are accepted. Defaults to 100.\n        :type  limit: int\n        \n        :param timeout: Timeout in seconds for long polling. Defaults to 0, i.e. usual short polling. Should be positive, short polling should be used for testing purposes only.\n        :type  timeout: int\n        \n        :param allowed_updates: List the types of updates you want your bot to receive. For example, specify [\u201cmessage\u201d, \u201cedited_channel_post\u201d, \u201ccallback_query\u201d] to only receive updates of these types. See Update for a complete list of available update types. Specify an empty list to receive all updates regardless of type (default). If not specified, the previous setting will be used.Please note that this parameter doesn't affect updates created before the call to the getUpdates, so unwanted updates may be received for a short period of time.\n        :type  allowed_updates: list of str|unicode\n        \n        Returns:\n\n        :return: An Array of Update objects is returned\n        :rtype:  list of pytgbot.api_types.receivable.updates.Update\n        \"\"\"\n        assert_type_or_raise(offset, None, int, parameter_name=\"offset\")\n        \n        assert_type_or_raise(limit, None, int, parameter_name=\"limit\")\n        \n        assert_type_or_raise(timeout, None, int, parameter_name=\"timeout\")\n        \n        assert_type_or_raise(allowed_updates, None, list, parameter_name=\"allowed_updates\")\n        \n        result = self.do(\"getUpdates\", offset=offset, limit=limit, timeout=timeout, allowed_updates=allowed_updates)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.updates import Update\n            try:\n                return Update.from_array_list(result, list_level=1)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type Update\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nuse this method to specify a url and receive incoming updates via an outgoing webhook. Whenever there is an update for the bot, we will send an HTTPS POST request to the specified url, containing a JSON-serialized Update. In case of an unsuccessful request, we will give up after a reasonable amount of attempts. Returns True on success. If you'd like to make sure that the Webhook request comes from Telegram, we recommend using a secret path in the URL, e.g. https://www.example.com/<token>. Since nobody else knows your bot\u2018s token, you can be pretty sure it\u2019s us. Notes1. You will not be able to receive updates using getUpdates for as long as an outgoing webhook is set up.2. To use a self-signed certificate, you need to upload your public key certificate using certificate parameter. Please upload as InputFile, sending a String will not work.3. Ports currently supported for Webhooks: 443, 80, 88, 8443. NEW! If you're having any trouble setting up webhooks, please check out this amazing guide to Webhooks. https://core.telegram.org/bots/api#setwebhook Parameters: :param url: HTTPS url to send updates to. Use an empty string to remove webhook integration :type url: str|unicode Optional keyword parameters: :param certificate: Upload your public key certificate so that the root certificate in use can be checked. See our self-signed guide for details. :type certificate: pytgbot.api_types.sendable.files.InputFile :param max_connections: Maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery, 1-100. Defaults to 40. Use lower values to limit the load on your bot\u2018s server, and higher values to increase your bot\u2019s throughput. :type max_connections: int :param allowed_updates: List the types of updates you want your bot to receive. For example, specify [\u201cmessage\u201d, \u201cedited_channel_post\u201d, \u201ccallback_query\u201d] to only receive updates of these types. See Update for a complete list of available update types. Specify an empty list to receive all updates regardless of type (default). If not specified, the previous setting will be used.Please note that this parameter doesn't affect updates created before the call to the setWebhook, so unwanted updates may be received for a short period of time. :type allowed_updates: list of str|unicode Returns: :return: Returns True on success :rtype: bool", "response": "def set_webhook(self, url, certificate=None, max_connections=None, allowed_updates=None):\n        \"\"\"\n        Use this method to specify a url and receive incoming updates via an outgoing webhook. Whenever there is an update for the bot, we will send an HTTPS POST request to the specified url, containing a JSON-serialized Update. In case of an unsuccessful request, we will give up after a reasonable amount of attempts. Returns True on success.\n        If you'd like to make sure that the Webhook request comes from Telegram, we recommend using a secret path in the URL, e.g. https://www.example.com/<token>. Since nobody else knows your bot\u2018s token, you can be pretty sure it\u2019s us.\n\n        Notes1. You will not be able to receive updates using getUpdates for as long as an outgoing webhook is set up.2. To use a self-signed certificate, you need to upload your public key certificate using certificate parameter. Please upload as InputFile, sending a String will not work.3. Ports currently supported for Webhooks: 443, 80, 88, 8443.\n        NEW! If you're having any trouble setting up webhooks, please check out this amazing guide to Webhooks.\n\n\n        https://core.telegram.org/bots/api#setwebhook\n\n        \n        Parameters:\n        \n        :param url: HTTPS url to send updates to. Use an empty string to remove webhook integration\n        :type  url: str|unicode\n        \n        \n        Optional keyword parameters:\n        \n        :param certificate: Upload your public key certificate so that the root certificate in use can be checked. See our self-signed guide for details.\n        :type  certificate: pytgbot.api_types.sendable.files.InputFile\n        \n        :param max_connections: Maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery, 1-100. Defaults to 40. Use lower values to limit the load on your bot\u2018s server, and higher values to increase your bot\u2019s throughput.\n        :type  max_connections: int\n        \n        :param allowed_updates: List the types of updates you want your bot to receive. For example, specify [\u201cmessage\u201d, \u201cedited_channel_post\u201d, \u201ccallback_query\u201d] to only receive updates of these types. See Update for a complete list of available update types. Specify an empty list to receive all updates regardless of type (default). If not specified, the previous setting will be used.Please note that this parameter doesn't affect updates created before the call to the setWebhook, so unwanted updates may be received for a short period of time.\n        :type  allowed_updates: list of str|unicode\n        \n        Returns:\n\n        :return: Returns True on success\n        :rtype:  bool\n        \"\"\"\n        from pytgbot.api_types.sendable.files import InputFile\n        \n        assert_type_or_raise(url, unicode_type, parameter_name=\"url\")\n        \n        assert_type_or_raise(certificate, None, InputFile, parameter_name=\"certificate\")\n        \n        assert_type_or_raise(max_connections, None, int, parameter_name=\"max_connections\")\n        \n        assert_type_or_raise(allowed_updates, None, list, parameter_name=\"allowed_updates\")\n        \n        result = self.do(\"setWebhook\", url=url, certificate=certificate, max_connections=max_connections, allowed_updates=allowed_updates)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nusing this method to remove webhook integration if you decide to switch back to getUpdates. Returns True on success. Requires no parameters. https://core.telegram.org/bots/api#deletewebhook Returns: :return: Returns True on success :rtype: bool", "response": "def delete_webhook(self, ):\n        \"\"\"\n        Use this method to remove webhook integration if you decide to switch back to getUpdates. Returns True on success. Requires no parameters.\n\n        https://core.telegram.org/bots/api#deletewebhook\n\n        \n        Returns:\n\n        :return: Returns True on success\n        :rtype:  bool\n        \"\"\"\n        \n        result = self.do(\"deleteWebhook\", )\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nuse this method to get current webhook status. Requires no parameters. On success, returns a WebhookInfo object. If the bot is using getUpdates, will return an object with the url field empty. https://core.telegram.org/bots/api#getwebhookinfo Returns: :return: On success, returns a WebhookInfo object :rtype: pytgbot.api_types.receivable.updates.WebhookInfo", "response": "def get_webhook_info(self, ):\n        \"\"\"\n        Use this method to get current webhook status. Requires no parameters. On success, returns a WebhookInfo object. If the bot is using getUpdates, will return an object with the url field empty.\n\n        https://core.telegram.org/bots/api#getwebhookinfo\n\n        \n        Returns:\n\n        :return: On success, returns a WebhookInfo object\n        :rtype:  pytgbot.api_types.receivable.updates.WebhookInfo\n        \"\"\"\n        \n        result = self.do(\"getWebhookInfo\", )\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.updates import WebhookInfo\n            try:\n                return WebhookInfo.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type WebhookInfo\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_photo(self, chat_id, photo, caption=None, parse_mode=None, disable_notification=None, reply_to_message_id=None, reply_markup=None):\n        from pytgbot.api_types.sendable.files import InputFile\n        from pytgbot.api_types.sendable.reply_markup import ForceReply\n        from pytgbot.api_types.sendable.reply_markup import InlineKeyboardMarkup\n        from pytgbot.api_types.sendable.reply_markup import ReplyKeyboardMarkup\n        from pytgbot.api_types.sendable.reply_markup import ReplyKeyboardRemove\n        \n        assert_type_or_raise(chat_id, (int, unicode_type), parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(photo, (InputFile, unicode_type), parameter_name=\"photo\")\n        \n        assert_type_or_raise(caption, None, unicode_type, parameter_name=\"caption\")\n        \n        assert_type_or_raise(parse_mode, None, unicode_type, parameter_name=\"parse_mode\")\n        \n        assert_type_or_raise(disable_notification, None, bool, parameter_name=\"disable_notification\")\n        \n        assert_type_or_raise(reply_to_message_id, None, int, parameter_name=\"reply_to_message_id\")\n        \n        assert_type_or_raise(reply_markup, None, (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply), parameter_name=\"reply_markup\")\n        \n        result = self.do(\"sendPhoto\", chat_id=chat_id, photo=photo, caption=caption, parse_mode=parse_mode, disable_notification=disable_notification, reply_to_message_id=reply_to_message_id, reply_markup=reply_markup)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.updates import Message\n            try:\n                return Message.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type Message\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "Use this method to send photos. You must be an administrator in the chat for this to work and must have the appropriate admin rights."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing this method to send a group of photos or videos as an album. You must be an administrator in the chat for this to work and must have the appropriate admin rights. You must have the appropriate admin rights. You must have the appropriate admin rights.", "response": "def send_media_group(self, chat_id, media, disable_notification=None, reply_to_message_id=None):\n        \"\"\"\n        Use this method to send a group of photos or videos as an album. On success, an array of the sent Messages is returned.\n\n        https://core.telegram.org/bots/api#sendmediagroup\n\n        \n        Parameters:\n        \n        :param chat_id: Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n        :type  chat_id: int | str|unicode\n        \n        :param media: A JSON-serialized array describing photos and videos to be sent, must include 2\u201310 items\n        :type  media: list of pytgbot.api_types.sendable.input_media.InputMediaPhoto | list of pytgbot.api_types.sendable.input_media.InputMediaVideo\n        \n        \n        Optional keyword parameters:\n        \n        :param disable_notification: Sends the messages silently. Users will receive a notification with no sound.\n        :type  disable_notification: bool\n        \n        :param reply_to_message_id: If the messages are a reply, ID of the original message\n        :type  reply_to_message_id: int\n        \n        Returns:\n\n        :return: On success, an array of the sent Messages is returned\n        :rtype:  list of pytgbot.api_types.receivable.updates.Message\n        \"\"\"\n        from pytgbot.api_types.sendable.input_media import InputMediaPhoto\n        from pytgbot.api_types.sendable.input_media import InputMediaVideo\n        \n        assert_type_or_raise(chat_id, (int, unicode_type), parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(media, (list, list), parameter_name=\"media\")\n        \n        assert_type_or_raise(disable_notification, None, bool, parameter_name=\"disable_notification\")\n        \n        assert_type_or_raise(reply_to_message_id, None, int, parameter_name=\"reply_to_message_id\")\n        \n        result = self.do(\"sendMediaGroup\", chat_id=chat_id, media=media, disable_notification=disable_notification, reply_to_message_id=reply_to_message_id)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.updates import Message\n            try:\n                return Message.from_array_list(result, list_level=1)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type Message\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_location(self, chat_id, latitude, longitude, live_period=None, disable_notification=None, reply_to_message_id=None, reply_markup=None):\n        from pytgbot.api_types.sendable.reply_markup import ForceReply\n        from pytgbot.api_types.sendable.reply_markup import InlineKeyboardMarkup\n        from pytgbot.api_types.sendable.reply_markup import ReplyKeyboardMarkup\n        from pytgbot.api_types.sendable.reply_markup import ReplyKeyboardRemove\n        \n        assert_type_or_raise(chat_id, (int, unicode_type), parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(latitude, float, parameter_name=\"latitude\")\n        \n        assert_type_or_raise(longitude, float, parameter_name=\"longitude\")\n        \n        assert_type_or_raise(live_period, None, int, parameter_name=\"live_period\")\n        \n        assert_type_or_raise(disable_notification, None, bool, parameter_name=\"disable_notification\")\n        \n        assert_type_or_raise(reply_to_message_id, None, int, parameter_name=\"reply_to_message_id\")\n        \n        assert_type_or_raise(reply_markup, None, (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply), parameter_name=\"reply_markup\")\n        \n        result = self.do(\"sendLocation\", chat_id=chat_id, latitude=latitude, longitude=longitude, live_period=live_period, disable_notification=disable_notification, reply_to_message_id=reply_to_message_id, reply_markup=reply_markup)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.updates import Message\n            try:\n                return Message.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type Message\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "Use this method to send a location on the map."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing this method to send phone contacts. You must be an administrator in the chat for this to work and must have the appropriate admin rights.", "response": "def send_contact(self, chat_id, phone_number, first_name, last_name=None, vcard=None, disable_notification=None, reply_to_message_id=None, reply_markup=None):\n        \"\"\"\n        Use this method to send phone contacts. On success, the sent Message is returned.\n\n        https://core.telegram.org/bots/api#sendcontact\n\n        \n        Parameters:\n        \n        :param chat_id: Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n        :type  chat_id: int | str|unicode\n        \n        :param phone_number: Contact's phone number\n        :type  phone_number: str|unicode\n        \n        :param first_name: Contact's first name\n        :type  first_name: str|unicode\n        \n        \n        Optional keyword parameters:\n        \n        :param last_name: Contact's last name\n        :type  last_name: str|unicode\n        \n        :param vcard: Additional data about the contact in the form of a vCard, 0-2048 bytes\n        :type  vcard: str|unicode\n        \n        :param disable_notification: Sends the message silently. Users will receive a notification with no sound.\n        :type  disable_notification: bool\n        \n        :param reply_to_message_id: If the message is a reply, ID of the original message\n        :type  reply_to_message_id: int\n        \n        :param reply_markup: Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove keyboard or to force a reply from the user.\n        :type  reply_markup: pytgbot.api_types.sendable.reply_markup.InlineKeyboardMarkup | pytgbot.api_types.sendable.reply_markup.ReplyKeyboardMarkup | pytgbot.api_types.sendable.reply_markup.ReplyKeyboardRemove | pytgbot.api_types.sendable.reply_markup.ForceReply\n        \n        Returns:\n\n        :return: On success, the sent Message is returned\n        :rtype:  pytgbot.api_types.receivable.updates.Message\n        \"\"\"\n        from pytgbot.api_types.sendable.reply_markup import ForceReply\n        from pytgbot.api_types.sendable.reply_markup import InlineKeyboardMarkup\n        from pytgbot.api_types.sendable.reply_markup import ReplyKeyboardMarkup\n        from pytgbot.api_types.sendable.reply_markup import ReplyKeyboardRemove\n        \n        assert_type_or_raise(chat_id, (int, unicode_type), parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(phone_number, unicode_type, parameter_name=\"phone_number\")\n        \n        assert_type_or_raise(first_name, unicode_type, parameter_name=\"first_name\")\n        \n        assert_type_or_raise(last_name, None, unicode_type, parameter_name=\"last_name\")\n        \n        assert_type_or_raise(vcard, None, unicode_type, parameter_name=\"vcard\")\n        \n        assert_type_or_raise(disable_notification, None, bool, parameter_name=\"disable_notification\")\n        \n        assert_type_or_raise(reply_to_message_id, None, int, parameter_name=\"reply_to_message_id\")\n        \n        assert_type_or_raise(reply_markup, None, (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply), parameter_name=\"reply_markup\")\n        \n        result = self.do(\"sendContact\", chat_id=chat_id, phone_number=phone_number, first_name=first_name, last_name=last_name, vcard=vcard, disable_notification=disable_notification, reply_to_message_id=reply_to_message_id, reply_markup=reply_markup)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.updates import Message\n            try:\n                return Message.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type Message\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_user_profile_photos(self, user_id, offset=None, limit=None):\n        assert_type_or_raise(user_id, int, parameter_name=\"user_id\")\n        \n        assert_type_or_raise(offset, None, int, parameter_name=\"offset\")\n        \n        assert_type_or_raise(limit, None, int, parameter_name=\"limit\")\n        \n        result = self.do(\"getUserProfilePhotos\", user_id=user_id, offset=offset, limit=limit)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.media import UserProfilePhotos\n            try:\n                return UserProfilePhotos.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type UserProfilePhotos\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "This method returns a list of profile pictures for a user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing this method to get basic info about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a File object is returned. The file can then be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>, where <file_path> is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile again. Note: This function may not preserve the original file name and MIME type. You should save the file's MIME type and name (if available) when the File object is received. https://core.telegram.org/bots/api#getfile Parameters: :param file_id: File identifier to get info about :type file_id: str|unicode Returns: :return: On success, a File object is returned :rtype: pytgbot.api_types.receivable.media.File", "response": "def get_file(self, file_id):\n        \"\"\"\n        Use this method to get basic info about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a File object is returned. The file can then be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>, where <file_path> is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile again.\n        Note: This function may not preserve the original file name and MIME type. You should save the file's MIME type and name (if available) when the File object is received.\n\n        https://core.telegram.org/bots/api#getfile\n\n        \n        Parameters:\n        \n        :param file_id: File identifier to get info about\n        :type  file_id: str|unicode\n        \n        \n        Returns:\n\n        :return: On success, a File object is returned\n        :rtype:  pytgbot.api_types.receivable.media.File\n        \"\"\"\n        assert_type_or_raise(file_id, unicode_type, parameter_name=\"file_id\")\n        \n        result = self.do(\"getFile\", file_id=file_id)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.media import File\n            try:\n                return File.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type File\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef restrict_chat_member(self, chat_id, user_id, until_date=None, can_send_messages=None, can_send_media_messages=None, can_send_other_messages=None, can_add_web_page_previews=None):\n        assert_type_or_raise(chat_id, (int, unicode_type), parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(user_id, int, parameter_name=\"user_id\")\n        \n        assert_type_or_raise(until_date, None, int, parameter_name=\"until_date\")\n        \n        assert_type_or_raise(can_send_messages, None, bool, parameter_name=\"can_send_messages\")\n        \n        assert_type_or_raise(can_send_media_messages, None, bool, parameter_name=\"can_send_media_messages\")\n        \n        assert_type_or_raise(can_send_other_messages, None, bool, parameter_name=\"can_send_other_messages\")\n        \n        assert_type_or_raise(can_add_web_page_previews, None, bool, parameter_name=\"can_add_web_page_previews\")\n        \n        result = self.do(\"restrictChatMember\", chat_id=chat_id, user_id=user_id, until_date=until_date, can_send_messages=can_send_messages, can_send_media_messages=can_send_media_messages, can_send_other_messages=can_send_other_messages, can_add_web_page_previews=can_add_web_page_previews)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "Use this method to restrict a user in a supergroup."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npromoting a user in a supergroup or a channel.", "response": "def promote_chat_member(self, chat_id, user_id, can_change_info=None, can_post_messages=None, can_edit_messages=None, can_delete_messages=None, can_invite_users=None, can_restrict_members=None, can_pin_messages=None, can_promote_members=None):\n        \"\"\"\n        Use this method to promote or demote a user in a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights. Pass False for all boolean parameters to demote a user. Returns True on success.\n\n        https://core.telegram.org/bots/api#promotechatmember\n\n        \n        Parameters:\n        \n        :param chat_id: Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n        :type  chat_id: int | str|unicode\n        \n        :param user_id: Unique identifier of the target user\n        :type  user_id: int\n        \n        \n        Optional keyword parameters:\n        \n        :param can_change_info: Pass True, if the administrator can change chat title, photo and other settings\n        :type  can_change_info: bool\n        \n        :param can_post_messages: Pass True, if the administrator can create channel posts, channels only\n        :type  can_post_messages: bool\n        \n        :param can_edit_messages: Pass True, if the administrator can edit messages of other users and can pin messages, channels only\n        :type  can_edit_messages: bool\n        \n        :param can_delete_messages: Pass True, if the administrator can delete messages of other users\n        :type  can_delete_messages: bool\n        \n        :param can_invite_users: Pass True, if the administrator can invite new users to the chat\n        :type  can_invite_users: bool\n        \n        :param can_restrict_members: Pass True, if the administrator can restrict, ban or unban chat members\n        :type  can_restrict_members: bool\n        \n        :param can_pin_messages: Pass True, if the administrator can pin messages, supergroups only\n        :type  can_pin_messages: bool\n        \n        :param can_promote_members: Pass True, if the administrator can add new administrators with a subset of his own privileges or demote administrators that he has promoted, directly or indirectly (promoted by administrators that were appointed by him)\n        :type  can_promote_members: bool\n        \n        Returns:\n\n        :return: Returns True on success\n        :rtype:  bool\n        \"\"\"\n        assert_type_or_raise(chat_id, (int, unicode_type), parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(user_id, int, parameter_name=\"user_id\")\n        \n        assert_type_or_raise(can_change_info, None, bool, parameter_name=\"can_change_info\")\n        \n        assert_type_or_raise(can_post_messages, None, bool, parameter_name=\"can_post_messages\")\n        \n        assert_type_or_raise(can_edit_messages, None, bool, parameter_name=\"can_edit_messages\")\n        \n        assert_type_or_raise(can_delete_messages, None, bool, parameter_name=\"can_delete_messages\")\n        \n        assert_type_or_raise(can_invite_users, None, bool, parameter_name=\"can_invite_users\")\n        \n        assert_type_or_raise(can_restrict_members, None, bool, parameter_name=\"can_restrict_members\")\n        \n        assert_type_or_raise(can_pin_messages, None, bool, parameter_name=\"can_pin_messages\")\n        \n        assert_type_or_raise(can_promote_members, None, bool, parameter_name=\"can_promote_members\")\n        \n        result = self.do(\"promoteChatMember\", chat_id=chat_id, user_id=user_id, can_change_info=can_change_info, can_post_messages=can_post_messages, can_edit_messages=can_edit_messages, can_delete_messages=can_delete_messages, can_invite_users=can_invite_users, can_restrict_members=can_restrict_members, can_pin_messages=can_pin_messages, can_promote_members=can_promote_members)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing this method to set a new profile photo for a chat. Photos can t be changed for private chats.", "response": "def set_chat_photo(self, chat_id, photo):\n        \"\"\"\n        Use this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights. Returns True on success. \n\n        Note: In regular groups (non-supergroups), this method will only work if the \u2018All Members Are Admins\u2019 setting is off in the target group.\n\n\n        https://core.telegram.org/bots/api#setchatphoto\n\n        \n        Parameters:\n        \n        :param chat_id: Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n        :type  chat_id: int | str|unicode\n        \n        :param photo: New chat photo, uploaded using multipart/form-data\n        :type  photo: pytgbot.api_types.sendable.files.InputFile\n        \n        \n        Returns:\n\n        :return: Returns True on success\n        :rtype:  bool\n        \"\"\"\n        from pytgbot.api_types.sendable.files import InputFile\n        \n        assert_type_or_raise(chat_id, (int, unicode_type), parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(photo, InputFile, parameter_name=\"photo\")\n        \n        result = self.do(\"setChatPhoto\", chat_id=chat_id, photo=photo)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nuse this method to get up to date information about a chat.", "response": "def get_chat(self, chat_id):\n        \"\"\"\n        Use this method to get up to date information about the chat (current name of the user for one-on-one conversations, current username of a user, group or channel, etc.). Returns a Chat object on success.\n\n        https://core.telegram.org/bots/api#getchat\n\n        \n        Parameters:\n        \n        :param chat_id: Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)\n        :type  chat_id: int | str|unicode\n        \n        \n        Returns:\n\n        :return: Returns a Chat object on success\n        :rtype:  pytgbot.api_types.receivable.peer.Chat\n        \"\"\"\n        assert_type_or_raise(chat_id, (int, unicode_type), parameter_name=\"chat_id\")\n        \n        result = self.do(\"getChat\", chat_id=chat_id)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.peer import Chat\n            try:\n                return Chat.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type Chat\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_chat_sticker_set(self, chat_id, sticker_set_name):\n        assert_type_or_raise(chat_id, (int, unicode_type), parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(sticker_set_name, unicode_type, parameter_name=\"sticker_set_name\")\n        \n        result = self.do(\"setChatStickerSet\", chat_id=chat_id, sticker_set_name=sticker_set_name)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "Use this method to set a new group sticker set for a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nuses this method to send answers to callback queries sent from inline keyboards. The answer will be displayed to the user as a notification at the top of the chat screen or as an alert. On success, True is returned. Alternatively, the user can be redirected to the specified Game URL. For this option to work, you must first create a game for your bot via @Botfather and accept the terms. Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with a parameter. https://core.telegram.org/bots/api#answercallbackquery Parameters: :param callback_query_id: Unique identifier for the query to be answered :type callback_query_id: str|unicode Optional keyword parameters: :param text: Text of the notification. If not specified, nothing will be shown to the user, 0-200 characters :type text: str|unicode :param show_alert: If true, an alert will be shown by the client instead of a notification at the top of the chat screen. Defaults to false. :type show_alert: bool :param url: URL that will be opened by the user's client. If you have created a Game and accepted the conditions via @Botfather, specify the URL that opens your game \u2013 note that this will only work if the query comes from a callback_game button.Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with a parameter. :type url: str|unicode :param cache_time: The maximum amount of time in seconds that the result of the callback query may be cached client-side. Telegram apps will support caching starting in version 3.14. Defaults to 0. :type cache_time: int Returns: :return: On success, True is returned :rtype: bool", "response": "def answer_callback_query(self, callback_query_id, text=None, show_alert=None, url=None, cache_time=None):\n        \"\"\"\n        Use this method to send answers to callback queries sent from inline keyboards. The answer will be displayed to the user as a notification at the top of the chat screen or as an alert. On success, True is returned.\n\n        Alternatively, the user can be redirected to the specified Game URL. For this option to work, you must first create a game for your bot via @Botfather and accept the terms. Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with a parameter.\n\n\n        https://core.telegram.org/bots/api#answercallbackquery\n\n        \n        Parameters:\n        \n        :param callback_query_id: Unique identifier for the query to be answered\n        :type  callback_query_id: str|unicode\n        \n        \n        Optional keyword parameters:\n        \n        :param text: Text of the notification. If not specified, nothing will be shown to the user, 0-200 characters\n        :type  text: str|unicode\n        \n        :param show_alert: If true, an alert will be shown by the client instead of a notification at the top of the chat screen. Defaults to false.\n        :type  show_alert: bool\n        \n        :param url: URL that will be opened by the user's client. If you have created a Game and accepted the conditions via @Botfather, specify the URL that opens your game \u2013 note that this will only work if the query comes from a callback_game button.Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with a parameter.\n        :type  url: str|unicode\n        \n        :param cache_time: The maximum amount of time in seconds that the result of the callback query may be cached client-side. Telegram apps will support caching starting in version 3.14. Defaults to 0.\n        :type  cache_time: int\n        \n        Returns:\n\n        :return: On success, True is returned\n        :rtype:  bool\n        \"\"\"\n        assert_type_or_raise(callback_query_id, unicode_type, parameter_name=\"callback_query_id\")\n        \n        assert_type_or_raise(text, None, unicode_type, parameter_name=\"text\")\n        \n        assert_type_or_raise(show_alert, None, bool, parameter_name=\"show_alert\")\n        \n        assert_type_or_raise(url, None, unicode_type, parameter_name=\"url\")\n        \n        assert_type_or_raise(cache_time, None, int, parameter_name=\"cache_time\")\n        \n        result = self.do(\"answerCallbackQuery\", callback_query_id=callback_query_id, text=text, show_alert=show_alert, url=url, cache_time=cache_time)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef edit_message_text(self, text, chat_id=None, message_id=None, inline_message_id=None, parse_mode=None, disable_web_page_preview=None, reply_markup=None):\n        from pytgbot.api_types.sendable.reply_markup import InlineKeyboardMarkup\n        \n        assert_type_or_raise(text, unicode_type, parameter_name=\"text\")\n        \n        assert_type_or_raise(chat_id, None, (int, unicode_type), parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(message_id, None, int, parameter_name=\"message_id\")\n        \n        assert_type_or_raise(inline_message_id, None, unicode_type, parameter_name=\"inline_message_id\")\n        \n        assert_type_or_raise(parse_mode, None, unicode_type, parameter_name=\"parse_mode\")\n        \n        assert_type_or_raise(disable_web_page_preview, None, bool, parameter_name=\"disable_web_page_preview\")\n        \n        assert_type_or_raise(reply_markup, None, InlineKeyboardMarkup, parameter_name=\"reply_markup\")\n        \n        result = self.do(\"editMessageText\", text=text, chat_id=chat_id, message_id=message_id, inline_message_id=inline_message_id, parse_mode=parse_mode, disable_web_page_preview=disable_web_page_preview, reply_markup=reply_markup)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.updates import Message\n            try:\n                return Message.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type Message\", exc_info=True)\n            # end try\n        \n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "Use this method to edit text and game messages sent by the bot or via the bot."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nuse this method to get a sticker set. On success, a StickerSet object is returned. https://core.telegram.org/bots/api#getstickerset Parameters: :param name: Name of the sticker set :type name: str|unicode Returns: :return: On success, a StickerSet object is returned :rtype: pytgbot.api_types.receivable.stickers.StickerSet", "response": "def get_sticker_set(self, name):\n        \"\"\"\n        Use this method to get a sticker set. On success, a StickerSet object is returned.\n\n        https://core.telegram.org/bots/api#getstickerset\n\n        \n        Parameters:\n        \n        :param name: Name of the sticker set\n        :type  name: str|unicode\n        \n        \n        Returns:\n\n        :return: On success, a StickerSet object is returned\n        :rtype:  pytgbot.api_types.receivable.stickers.StickerSet\n        \"\"\"\n        assert_type_or_raise(name, unicode_type, parameter_name=\"name\")\n        \n        result = self.do(\"getStickerSet\", name=name)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.stickers import StickerSet\n            try:\n                return StickerSet.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type StickerSet\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upload_sticker_file(self, user_id, png_sticker):\n        from pytgbot.api_types.sendable.files import InputFile\n        \n        assert_type_or_raise(user_id, int, parameter_name=\"user_id\")\n        \n        assert_type_or_raise(png_sticker, InputFile, parameter_name=\"png_sticker\")\n        \n        result = self.do(\"uploadStickerFile\", user_id=user_id, png_sticker=png_sticker)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.media import File\n            try:\n                return File.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type File\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "This method uploads a. png file with a sticker to the Telegram server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_new_sticker_set(self, user_id, name, title, png_sticker, emojis, contains_masks=None, mask_position=None):\n        from pytgbot.api_types.receivable.stickers import MaskPosition\n        from pytgbot.api_types.sendable.files import InputFile\n        \n        assert_type_or_raise(user_id, int, parameter_name=\"user_id\")\n        \n        assert_type_or_raise(name, unicode_type, parameter_name=\"name\")\n        \n        assert_type_or_raise(title, unicode_type, parameter_name=\"title\")\n        \n        assert_type_or_raise(png_sticker, (InputFile, unicode_type), parameter_name=\"png_sticker\")\n        \n        assert_type_or_raise(emojis, unicode_type, parameter_name=\"emojis\")\n        \n        assert_type_or_raise(contains_masks, None, bool, parameter_name=\"contains_masks\")\n        \n        assert_type_or_raise(mask_position, None, MaskPosition, parameter_name=\"mask_position\")\n        \n        result = self.do(\"createNewStickerSet\", user_id=user_id, name=name, title=title, png_sticker=png_sticker, emojis=emojis, contains_masks=contains_masks, mask_position=mask_position)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "This method creates a new sticker set owned by a user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing this method to move a sticker in a set created by the bot to a specific position . Returns True on success. https://core.telegram.org/bots/api#setstickerpositioninset Parameters: :param sticker: File identifier of the sticker :type sticker: str|unicode :param position: New sticker position in the set, zero-based :type position: int Returns: :return: Returns True on success :rtype: bool", "response": "def set_sticker_position_in_set(self, sticker, position):\n        \"\"\"\n        Use this method to move a sticker in a set created by the bot to a specific position . Returns True on success.\n\n        https://core.telegram.org/bots/api#setstickerpositioninset\n\n        \n        Parameters:\n        \n        :param sticker: File identifier of the sticker\n        :type  sticker: str|unicode\n        \n        :param position: New sticker position in the set, zero-based\n        :type  position: int\n        \n        \n        Returns:\n\n        :return: Returns True on success\n        :rtype:  bool\n        \"\"\"\n        assert_type_or_raise(sticker, unicode_type, parameter_name=\"sticker\")\n        \n        assert_type_or_raise(position, int, parameter_name=\"position\")\n        \n        result = self.do(\"setStickerPositionInSet\", sticker=sticker, position=position)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef answer_inline_query(self, inline_query_id, results, cache_time=None, is_personal=None, next_offset=None, switch_pm_text=None, switch_pm_parameter=None):\n        from pytgbot.api_types.sendable.inline import InlineQueryResult\n        \n        assert_type_or_raise(inline_query_id, unicode_type, parameter_name=\"inline_query_id\")\n        \n        assert_type_or_raise(results, list, parameter_name=\"results\")\n        \n        assert_type_or_raise(cache_time, None, int, parameter_name=\"cache_time\")\n        \n        assert_type_or_raise(is_personal, None, bool, parameter_name=\"is_personal\")\n        \n        assert_type_or_raise(next_offset, None, unicode_type, parameter_name=\"next_offset\")\n        \n        assert_type_or_raise(switch_pm_text, None, unicode_type, parameter_name=\"switch_pm_text\")\n        \n        assert_type_or_raise(switch_pm_parameter, None, unicode_type, parameter_name=\"switch_pm_parameter\")\n        \n        result = self.do(\"answerInlineQuery\", inline_query_id=inline_query_id, results=results, cache_time=cache_time, is_personal=is_personal, next_offset=next_offset, switch_pm_text=switch_pm_text, switch_pm_parameter=switch_pm_parameter)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "This method sends answers to an inline query."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuses this method to send invoices. On success, the sent Message is returned. https://core.telegram.org/bots/api#sendinvoice Parameters: :param chat_id: Unique identifier for the target private chat :type chat_id: int :param title: Product name, 1-32 characters :type title: str|unicode :param description: Product description, 1-255 characters :type description: str|unicode :param payload: Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes. :type payload: str|unicode :param provider_token: Payments provider token, obtained via Botfather :type provider_token: str|unicode :param start_parameter: Unique deep-linking parameter that can be used to generate this invoice when used as a start parameter :type start_parameter: str|unicode :param currency: Three-letter ISO 4217 currency code, see more on currencies :type currency: str|unicode :param prices: Price breakdown, a list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.) :type prices: list of pytgbot.api_types.sendable.payments.LabeledPrice Optional keyword parameters: :param provider_data: JSON-encoded data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider. :type provider_data: str|unicode :param photo_url: URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. People like it better when they see what they are paying for. :type photo_url: str|unicode :param photo_size: Photo size :type photo_size: int :param photo_width: Photo width :type photo_width: int :param photo_height: Photo height :type photo_height: int :param need_name: Pass True, if you require the user's full name to complete the order :type need_name: bool :param need_phone_number: Pass True, if you require the user's phone number to complete the order :type need_phone_number: bool :param need_email: Pass True, if you require the user's email address to complete the order :type need_email: bool :param need_shipping_address: Pass True, if you require the user's shipping address to complete the order :type need_shipping_address: bool :param send_phone_number_to_provider: Pass True, if user's phone number should be sent to provider :type send_phone_number_to_provider: bool :param send_email_to_provider: Pass True, if user's email address should be sent to provider :type send_email_to_provider: bool :param is_flexible: Pass True, if the final price depends on the shipping method :type is_flexible: bool :param disable_notification: Sends the message silently. Users will receive a notification with no sound. :type disable_notification: bool :param reply_to_message_id: If the message is a reply, ID of the original message :type reply_to_message_id: int :param reply_markup: A JSON-serialized object for an inline keyboard. If empty, one 'Pay total price' button will be shown. If not empty, the first button must be a Pay button. :type reply_markup: pytgbot.api_types.sendable.reply_markup.InlineKeyboardMarkup Returns: :return: On success, the sent Message is returned :rtype: pytgbot.api_types.receivable.updates.Message", "response": "def send_invoice(self, chat_id, title, description, payload, provider_token, start_parameter, currency, prices, provider_data=None, photo_url=None, photo_size=None, photo_width=None, photo_height=None, need_name=None, need_phone_number=None, need_email=None, need_shipping_address=None, send_phone_number_to_provider=None, send_email_to_provider=None, is_flexible=None, disable_notification=None, reply_to_message_id=None, reply_markup=None):\n        \"\"\"\n        Use this method to send invoices. On success, the sent Message is returned.\n\n        https://core.telegram.org/bots/api#sendinvoice\n\n        \n        Parameters:\n        \n        :param chat_id: Unique identifier for the target private chat\n        :type  chat_id: int\n        \n        :param title: Product name, 1-32 characters\n        :type  title: str|unicode\n        \n        :param description: Product description, 1-255 characters\n        :type  description: str|unicode\n        \n        :param payload: Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.\n        :type  payload: str|unicode\n        \n        :param provider_token: Payments provider token, obtained via Botfather\n        :type  provider_token: str|unicode\n        \n        :param start_parameter: Unique deep-linking parameter that can be used to generate this invoice when used as a start parameter\n        :type  start_parameter: str|unicode\n        \n        :param currency: Three-letter ISO 4217 currency code, see more on currencies\n        :type  currency: str|unicode\n        \n        :param prices: Price breakdown, a list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)\n        :type  prices: list of pytgbot.api_types.sendable.payments.LabeledPrice\n        \n        \n        Optional keyword parameters:\n        \n        :param provider_data: JSON-encoded data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider.\n        :type  provider_data: str|unicode\n        \n        :param photo_url: URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. People like it better when they see what they are paying for.\n        :type  photo_url: str|unicode\n        \n        :param photo_size: Photo size\n        :type  photo_size: int\n        \n        :param photo_width: Photo width\n        :type  photo_width: int\n        \n        :param photo_height: Photo height\n        :type  photo_height: int\n        \n        :param need_name: Pass True, if you require the user's full name to complete the order\n        :type  need_name: bool\n        \n        :param need_phone_number: Pass True, if you require the user's phone number to complete the order\n        :type  need_phone_number: bool\n        \n        :param need_email: Pass True, if you require the user's email address to complete the order\n        :type  need_email: bool\n        \n        :param need_shipping_address: Pass True, if you require the user's shipping address to complete the order\n        :type  need_shipping_address: bool\n        \n        :param send_phone_number_to_provider: Pass True, if user's phone number should be sent to provider\n        :type  send_phone_number_to_provider: bool\n        \n        :param send_email_to_provider: Pass True, if user's email address should be sent to provider\n        :type  send_email_to_provider: bool\n        \n        :param is_flexible: Pass True, if the final price depends on the shipping method\n        :type  is_flexible: bool\n        \n        :param disable_notification: Sends the message silently. Users will receive a notification with no sound.\n        :type  disable_notification: bool\n        \n        :param reply_to_message_id: If the message is a reply, ID of the original message\n        :type  reply_to_message_id: int\n        \n        :param reply_markup: A JSON-serialized object for an inline keyboard. If empty, one 'Pay total price' button will be shown. If not empty, the first button must be a Pay button.\n        :type  reply_markup: pytgbot.api_types.sendable.reply_markup.InlineKeyboardMarkup\n        \n        Returns:\n\n        :return: On success, the sent Message is returned\n        :rtype:  pytgbot.api_types.receivable.updates.Message\n        \"\"\"\n        from pytgbot.api_types.sendable.payments import LabeledPrice\n        from pytgbot.api_types.sendable.reply_markup import InlineKeyboardMarkup\n        \n        assert_type_or_raise(chat_id, int, parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(title, unicode_type, parameter_name=\"title\")\n        \n        assert_type_or_raise(description, unicode_type, parameter_name=\"description\")\n        \n        assert_type_or_raise(payload, unicode_type, parameter_name=\"payload\")\n        \n        assert_type_or_raise(provider_token, unicode_type, parameter_name=\"provider_token\")\n        \n        assert_type_or_raise(start_parameter, unicode_type, parameter_name=\"start_parameter\")\n        \n        assert_type_or_raise(currency, unicode_type, parameter_name=\"currency\")\n        \n        assert_type_or_raise(prices, list, parameter_name=\"prices\")\n        \n        assert_type_or_raise(provider_data, None, unicode_type, parameter_name=\"provider_data\")\n        \n        assert_type_or_raise(photo_url, None, unicode_type, parameter_name=\"photo_url\")\n        \n        assert_type_or_raise(photo_size, None, int, parameter_name=\"photo_size\")\n        \n        assert_type_or_raise(photo_width, None, int, parameter_name=\"photo_width\")\n        \n        assert_type_or_raise(photo_height, None, int, parameter_name=\"photo_height\")\n        \n        assert_type_or_raise(need_name, None, bool, parameter_name=\"need_name\")\n        \n        assert_type_or_raise(need_phone_number, None, bool, parameter_name=\"need_phone_number\")\n        \n        assert_type_or_raise(need_email, None, bool, parameter_name=\"need_email\")\n        \n        assert_type_or_raise(need_shipping_address, None, bool, parameter_name=\"need_shipping_address\")\n        \n        assert_type_or_raise(send_phone_number_to_provider, None, bool, parameter_name=\"send_phone_number_to_provider\")\n        \n        assert_type_or_raise(send_email_to_provider, None, bool, parameter_name=\"send_email_to_provider\")\n        \n        assert_type_or_raise(is_flexible, None, bool, parameter_name=\"is_flexible\")\n        \n        assert_type_or_raise(disable_notification, None, bool, parameter_name=\"disable_notification\")\n        \n        assert_type_or_raise(reply_to_message_id, None, int, parameter_name=\"reply_to_message_id\")\n        \n        assert_type_or_raise(reply_markup, None, InlineKeyboardMarkup, parameter_name=\"reply_markup\")\n        \n        result = self.do(\"sendInvoice\", chat_id=chat_id, title=title, description=description, payload=payload, provider_token=provider_token, start_parameter=start_parameter, currency=currency, prices=prices, provider_data=provider_data, photo_url=photo_url, photo_size=photo_size, photo_width=photo_width, photo_height=photo_height, need_name=need_name, need_phone_number=need_phone_number, need_email=need_email, need_shipping_address=need_shipping_address, send_phone_number_to_provider=send_phone_number_to_provider, send_email_to_provider=send_email_to_provider, is_flexible=is_flexible, disable_notification=disable_notification, reply_to_message_id=reply_to_message_id, reply_markup=reply_markup)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.updates import Message\n            try:\n                return Message.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type Message\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend an Answer to a shipping query.", "response": "def answer_shipping_query(self, shipping_query_id, ok, shipping_options=None, error_message=None):\n        \"\"\"\n        If you sent an invoice requesting a shipping address and the parameter is_flexible was specified, the Bot API will send an Update with a shipping_query field to the bot. Use this method to reply to shipping queries. On success, True is returned.\n\n        https://core.telegram.org/bots/api#answershippingquery\n\n        \n        Parameters:\n        \n        :param shipping_query_id: Unique identifier for the query to be answered\n        :type  shipping_query_id: str|unicode\n        \n        :param ok: Specify True if delivery to the specified address is possible and False if there are any problems (for example, if delivery to the specified address is not possible)\n        :type  ok: bool\n        \n        \n        Optional keyword parameters:\n        \n        :param shipping_options: Required if ok is True. A JSON-serialized array of available shipping options.\n        :type  shipping_options: list of pytgbot.api_types.sendable.payments.ShippingOption\n        \n        :param error_message: Required if ok is False. Error message in human readable form that explains why it is impossible to complete the order (e.g. \"Sorry, delivery to your desired address is unavailable'). Telegram will display this message to the user.\n        :type  error_message: str|unicode\n        \n        Returns:\n\n        :return: On success, True is returned\n        :rtype:  bool\n        \"\"\"\n        from pytgbot.api_types.sendable.payments import ShippingOption\n        \n        assert_type_or_raise(shipping_query_id, unicode_type, parameter_name=\"shipping_query_id\")\n        \n        assert_type_or_raise(ok, bool, parameter_name=\"ok\")\n        \n        assert_type_or_raise(shipping_options, None, list, parameter_name=\"shipping_options\")\n        \n        assert_type_or_raise(error_message, None, unicode_type, parameter_name=\"error_message\")\n        \n        result = self.do(\"answerShippingQuery\", shipping_query_id=shipping_query_id, ok=ok, shipping_options=shipping_options, error_message=error_message)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef answer_pre_checkout_query(self, pre_checkout_query_id, ok, error_message=None):\n        assert_type_or_raise(pre_checkout_query_id, unicode_type, parameter_name=\"pre_checkout_query_id\")\n        \n        assert_type_or_raise(ok, bool, parameter_name=\"ok\")\n        \n        assert_type_or_raise(error_message, None, unicode_type, parameter_name=\"error_message\")\n        \n        result = self.do(\"answerPreCheckoutQuery\", pre_checkout_query_id=pre_checkout_query_id, ok=ok, error_message=error_message)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "This method sends an answer to a pre - checkout query."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninforms a user that some of the Telegram Passport elements they provided contains errors. The user will not be able to re-submit their Passport to you until the errors are fixed (the contents of the field for which you returned the error must change). Returns True on success. Use this if the data submitted by the user doesn't satisfy the standards your service requires for any reason. For example, if a birthday date seems invalid, a submitted document is blurry, a scan shows evidence of tampering, etc. Supply some details in the error message to make sure the user knows how to correct the issues. https://core.telegram.org/bots/api#setpassportdataerrors Parameters: :param user_id: User identifier :type user_id: int :param errors: A JSON-serialized array describing the errors :type errors: list of pytgbot.api_types.sendable.passport.PassportElementError Returns: :return: Returns True on success :rtype: bool", "response": "def set_passport_data_errors(self, user_id, errors):\n        \"\"\"\n        Informs a user that some of the Telegram Passport elements they provided contains errors. The user will not be able to re-submit their Passport to you until the errors are fixed (the contents of the field for which you returned the error must change). Returns True on success.\n        Use this if the data submitted by the user doesn't satisfy the standards your service requires for any reason. For example, if a birthday date seems invalid, a submitted document is blurry, a scan shows evidence of tampering, etc. Supply some details in the error message to make sure the user knows how to correct the issues.\n\n        https://core.telegram.org/bots/api#setpassportdataerrors\n\n        \n        Parameters:\n        \n        :param user_id: User identifier\n        :type  user_id: int\n        \n        :param errors: A JSON-serialized array describing the errors\n        :type  errors: list of pytgbot.api_types.sendable.passport.PassportElementError\n        \n        \n        Returns:\n\n        :return: Returns True on success\n        :rtype:  bool\n        \"\"\"\n        from pytgbot.api_types.sendable.passport import PassportElementError\n        \n        assert_type_or_raise(user_id, int, parameter_name=\"user_id\")\n        \n        assert_type_or_raise(errors, list, parameter_name=\"errors\")\n        \n        result = self.do(\"setPassportDataErrors\", user_id=user_id, errors=errors)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_game(self, chat_id, game_short_name, disable_notification=None, reply_to_message_id=None, reply_markup=None):\n        from pytgbot.api_types.sendable.reply_markup import InlineKeyboardMarkup\n        \n        assert_type_or_raise(chat_id, int, parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(game_short_name, unicode_type, parameter_name=\"game_short_name\")\n        \n        assert_type_or_raise(disable_notification, None, bool, parameter_name=\"disable_notification\")\n        \n        assert_type_or_raise(reply_to_message_id, None, int, parameter_name=\"reply_to_message_id\")\n        \n        assert_type_or_raise(reply_markup, None, InlineKeyboardMarkup, parameter_name=\"reply_markup\")\n        \n        result = self.do(\"sendGame\", chat_id=chat_id, game_short_name=game_short_name, disable_notification=disable_notification, reply_to_message_id=reply_to_message_id, reply_markup=reply_markup)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.updates import Message\n            try:\n                return Message.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type Message\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "Use this method to send a game."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_game_high_scores(self, user_id, chat_id=None, message_id=None, inline_message_id=None):\n        assert_type_or_raise(user_id, int, parameter_name=\"user_id\")\n        \n        assert_type_or_raise(chat_id, None, int, parameter_name=\"chat_id\")\n        \n        assert_type_or_raise(message_id, None, int, parameter_name=\"message_id\")\n        \n        assert_type_or_raise(inline_message_id, None, unicode_type, parameter_name=\"inline_message_id\")\n        \n        result = self.do(\"getGameHighScores\", user_id=user_id, chat_id=chat_id, message_id=message_id, inline_message_id=inline_message_id)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.game import GameHighScore\n            try:\n                return GameHighScore.from_array_list(result, list_level=1)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type GameHighScore\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "Method to get the high scores for a user in a chat."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do(self, command, files=None, use_long_polling=False, request_timeout=None, **query):\n        import requests\n\n        url, params = self._prepare_request(command, query)\n        r = requests.post(url, params=params, files=files, stream=use_long_polling,\n                          verify=True,  # No self signed certificates. Telegram should be trustworthy anyway...\n                          timeout=request_timeout)\n        return self._postprocess_request(r)", "response": "Send a request to the api."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a url to download the file.", "response": "def get_download_url(self, file):\n        \"\"\"\n        Creates a url to download the file.\n\n        Note: Contains the secret API key, so you should not share this url!\n\n        :param file: The File you want to get the url to download.\n        :type  file: pytgbot.api_types.receivable.media.File\n\n        :return: url\n        :rtype: str\n        \"\"\"\n        from .api_types.receivable.media import File\n        assert isinstance(file, File)\n        return file.get_download_url(self.api_key)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load_info(self):\n        myself = self.get_me()\n        if self.return_python_objects:\n            self._id = myself.id\n            self._username = myself.username\n        else:\n            self._id = myself[\"result\"][\"id\"]\n            self._username = myself[\"result\"][\"username\"]", "response": "This function loads the id and username of the bot."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_request_data(self, var_name, full_data=False):\n        if full_data:\n            data = self.to_array()\n            data['media'], file = self.get_inputfile_data(self.media, var_name, suffix='_media')\n            return data, file\n        # end if\n        return self.get_inputfile_data(self.media, var_name, suffix='_media')", "response": "Get the data for a given variable."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_request_data(self, var_name, full_data=False):\n        if not full_data:\n            raise ArithmeticError('we have a thumbnail, please use `full_data=True`.')\n        # end if\n        file = {}\n        data, file_to_add = super(InputMediaWithThumb, self).get_request_data(var_name, full_data=True)\n        if file_to_add:\n            file.update(file_to_add)\n        # end if\n        data['thumb'], file_to_add = self.get_inputfile_data(self.thumb, var_name, suffix='_thumb')\n        if data['thumb'] is None:\n            del data['thumb']  # having `'thumb': null` in the json produces errors.\n        # end if\n        if file_to_add:\n            file.update(file_to_add)\n        # end if\n        return data, (file or None)", "response": "Get the data for a given variable name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_array(self):\n        from .files import InputFile\n        array = super(InputMediaVideo, self).to_array()\n        # 'type' given by superclass\n        # 'media' given by superclass\n        if self.thumb is not None:\n            if isinstance(self.thumb, InputFile):\n                array['thumb'] = None  # type InputFile\n            elif isinstance(self.thumb, str):\n                array['thumb'] = u(self.thumb)  # py2: type unicode, py3: type str\n            else:\n                raise TypeError('Unknown type, must be one of InputFile, str.')\n            # end if\n        # 'caption' given by superclass\n        # 'parse_mode' given by superclass\n        if self.width is not None:\n            array['width'] = int(self.width)  # type int\n        if self.height is not None:\n            array['height'] = int(self.height)  # type int\n        if self.duration is not None:\n            array['duration'] = int(self.duration)  # type int\n        if self.supports_streaming is not None:\n            array['supports_streaming'] = bool(self.supports_streaming)  # type bool\n        return array", "response": "Serializes this InputMediaVideo to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nserializes this InputMediaAnimation to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InputMediaAnimation to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InputMediaAnimation, self).to_array()\n        # 'type' given by superclass\n        # 'media' given by superclass\n        if self.thumb is not None:\n            if isinstance(self.thumb, InputFile):\n                array['thumb'] = None  # type InputFile\n            elif isinstance(self.thumb, str):\n                array['thumb'] = u(self.thumb)  # py2: type unicode, py3: type str\n            else:\n                raise TypeError('Unknown type, must be one of InputFile, str.')\n            # end if\n        # 'caption' given by superclass\n        # 'parse_mode' given by superclass\n        if self.width is not None:\n            array['width'] = int(self.width)  # type int\n        if self.height is not None:\n            array['height'] = int(self.height)  # type int\n        if self.duration is not None:\n            array['duration'] = int(self.duration)  # type int\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserializes this InputMediaAudio to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InputMediaAudio to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InputMediaAudio, self).to_array()\n        # 'type' given by superclass\n        # 'media' given by superclass\n        if self.thumb is not None:\n            if isinstance(self.thumb, InputFile):\n                array['thumb'] = None  # type InputFile\n            elif isinstance(self.thumb, str):\n                array['thumb'] = u(self.thumb)  # py2: type unicode, py3: type str\n            else:\n                raise TypeError('Unknown type, must be one of InputFile, str.')\n            # end if\n        # 'caption' given by superclass\n        # 'parse_mode' given by superclass\n        if self.duration is not None:\n            array['duration'] = int(self.duration)  # type int\n        if self.performer is not None:\n            array['performer'] = u(self.performer)  # py2: type unicode, py3: type str\n        if self.title is not None:\n            array['title'] = u(self.title)  # py2: type unicode, py3: type str\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(InputMediaDocument, self).to_array()\n        # 'type' given by superclass\n        # 'media' given by superclass\n        if self.thumb is not None:\n            if isinstance(self.thumb, InputFile):\n                array['thumb'] = None  # type InputFile\n            elif isinstance(self.thumb, str):\n                array['thumb'] = u(self.thumb)  # py2: type unicode, py3: type str\n            else:\n                raise TypeError('Unknown type, must be one of InputFile, str.')\n            # end if\n        # 'caption' given by superclass\n        # 'parse_mode' given by superclass\n        return array", "response": "Serializes this InputMediaDocument to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.sendable.files import InputFile\n\n\n        data = {}\n        # 'type' is given by class type\n        data['media'] = u(array.get('media'))\n        if array.get('thumb') is None:\n            data['thumb'] = None\n        elif isinstance(array.get('thumb'), InputFile):\n            data['thumb'] = None  # will be filled later by get_request_data()\n        elif isinstance(array.get('thumb'), str):\n            data['thumb'] = u(array.get('thumb'))\n        else:\n            raise TypeError('Unknown type, must be one of InputFile, str or None.')\n        # end if\n        data['caption'] = u(array.get('caption')) if array.get('caption') is not None else None\n        data['parse_mode'] = u(array.get('parse_mode')) if array.get('parse_mode') is not None else None\n\n        instance = InputMediaDocument(**data)\n        instance._raw = array\n        return instance", "response": "Deserialize a new InputMediaDocument from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmerges two lists of lists.", "response": "def _mergemap(map1, map2):\n    \"\"\"\n    Positions in map2 have an integer indicating the relative shift to\n    the equivalent position in map1. E.g., the i'th position in map2\n    corresponds to the i + map2[i] position in map1.\n    \"\"\"\n    merged = array('i', [0] * len(map2))\n    for i, shift in enumerate(map2):\n        merged[i] = shift + map1[i + shift]\n    return merged"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_config(cls, path, directory=None):\n        if not exists(path):\n            raise REPPError('REPP config file not found: {}'.format(path))\n        confdir = dirname(path)\n\n        # TODO: can TDL parsing be repurposed for this variant?\n        conf = io.open(path, encoding='utf-8').read()\n        conf = re.sub(r';.*', '', conf).replace('\\n',' ')\n        m = re.search(\n            r'repp-modules\\s*:=\\s*((?:[-\\w]+\\s+)*[-\\w]+)\\s*\\.', conf)\n        t = re.search(\n            r'repp-tokenizer\\s*:=\\s*([-\\w]+)\\s*\\.', conf)\n        a = re.search(\n            r'repp-calls\\s*:=\\s*((?:[-\\w]+\\s+)*[-\\w]+)\\s*\\.', conf)\n        f = re.search(\n            r'format\\s*:=\\s*(\\w+)\\s*\\.', conf)\n        d = re.search(\n            r'repp-directory\\s*:=\\s*(.*)\\.\\s*$', conf)\n\n        if m is None:\n            raise REPPError('repp-modules option must be set')\n        if t is None:\n            raise REPPError('repp-tokenizer option must be set')\n\n        mods = m.group(1).split()\n        tok = t.group(1).strip()\n        active = a.group(1).split() if a is not None else None\n        fmt = f.group(1).strip() if f is not None else None\n\n        if directory is None:\n            if d is not None:\n                directory = d.group(1).strip(' \"')\n            elif exists(joinpath(confdir, tok + '.rpp')):\n                directory = confdir\n            elif exists(joinpath(confdir, 'rpp', tok + '.rpp')):\n                directory = joinpath(confdir, 'rpp')\n            elif exists(joinpath(confdir, '../rpp', tok + '.rpp')):\n                directory = joinpath(confdir, '../rpp')\n            else:\n                raise REPPError('Could not find a suitable REPP directory.')\n\n        # ignore repp-modules and format?\n        return REPP.from_file(\n            joinpath(directory, tok + '.rpp'),\n            directory=directory,\n            active=active\n        )", "response": "Instantiate a REPP from a PET - style. set configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_file(cls, path, directory=None, modules=None, active=None):\n        name = basename(path)\n        if name.endswith('.rpp'):\n            name = name[:-4]\n        lines = _repp_lines(path)\n        directory = dirname(path) if directory is None else directory\n        r = cls(name=name, modules=modules, active=active)\n        _parse_repp(lines, r, directory)\n        return r", "response": "Instantiate a REPP from a. rpp file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_string(cls, s, name=None, modules=None, active=None):\n        r = cls(name=name, modules=modules, active=active)\n        _parse_repp(s.splitlines(), r, None)\n        return r", "response": "Instantiate a REPP from a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeactivates an external module.", "response": "def deactivate(self, mod):\n        \"\"\"\n        Set external module *mod* to inactive.\n        \"\"\"\n        if mod in self.active:\n            self.active.remove(mod)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply(self, s, active=None):\n        if active is None:\n            active = self.active\n        return self.group.apply(s, active=active)", "response": "Applies the REPP s rewrite rules to the input string s*."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef trace(self, s, active=None, verbose=False):\n        if active is None:\n            active = self.active\n        return self.group.trace(s, active=active, verbose=verbose)", "response": "Trace the input string s and return a list of REPPStep objects for each intermediate rewrite rule."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrewrites and tokenize the input string s.", "response": "def tokenize(self, s, pattern=None, active=None):\n        \"\"\"\n        Rewrite and tokenize the input string *s*.\n\n        Args:\n            s (str): the input string to process\n            pattern (str, optional): the regular expression pattern on\n                which to split tokens; defaults to `[ \\t]+`\n            active (optional): a collection of external module names\n                that may be applied if called\n        Returns:\n            a :class:`~delphin.tokens.YyTokenLattice` containing the\n            tokens and their characterization information\n        \"\"\"\n        if pattern is None:\n            if self.tokenize_pattern is None:\n                pattern = r'[ \\t]+'\n            else:\n                pattern = self.tokenize_pattern\n        if active is None:\n            active = self.active\n        return self.group.tokenize(s, pattern=pattern, active=active)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _apply_update_receiver(self, receiver, reply_id):\n        if self.receiver is None:\n            self.receiver = receiver\n        # end if\n        if self.reply_id is DEFAULT_MESSAGE_ID:\n            self.reply_id = reply_id", "response": "Applies receiver and reply_id to self. receiver and self. reply_id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending the message via pytgbot.", "response": "def send(self, sender: PytgbotApiBot):\n        \"\"\"\n        Send the message via pytgbot.\n\n        :param sender: The bot instance to send with.\n        :type  sender: pytgbot.bot.Bot\n\n        :rtype: PytgbotApiMessage\n        \"\"\"\n        return sender.send_message(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            text=self.text, chat_id=self.receiver, reply_to_message_id=self.reply_id, parse_mode=self.parse_mode, disable_web_page_preview=self.disable_web_page_preview, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_array(self):\n        array = super(TextMessage, self).to_array()\n        array['text'] = u(self.text)  # py2: type unicode, py3: type str\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.disable_web_page_preview is not None:\n            array['disable_web_page_preview'] = bool(self.disable_web_page_preview)  # type bool\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        if self.reply_markup is not None:\n            if isinstance(self.reply_markup, InlineKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardRemove):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardRemove\n            elif isinstance(self.reply_markup, ForceReply):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ForceReply\n            else:\n                raise TypeError('Unknown type, must be one of InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply.')\n            # end if\n\n        return array", "response": "Serializes this TextMessage to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send(self, sender: PytgbotApiBot):\n        return sender.send_photo(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            photo=self.photo, chat_id=self.receiver, reply_to_message_id=self.reply_id, caption=self.caption, parse_mode=self.parse_mode, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )", "response": "Send the message via pytgbot."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send(self, sender: PytgbotApiBot):\n        return sender.send_audio(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            audio=self.audio, chat_id=self.receiver, reply_to_message_id=self.reply_id, caption=self.caption, parse_mode=self.parse_mode, duration=self.duration, performer=self.performer, title=self.title, thumb=self.thumb, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )", "response": "Send the message via pytgbot."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nserialize this AudioMessage to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this AudioMessage to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(AudioMessage, self).to_array()\n        if isinstance(self.audio, InputFile):\n            array['audio'] = self.audio.to_array()  # type InputFile\n        elif isinstance(self.audio, str):\n            array['audio'] = u(self.audio)  # py2: type unicode, py3: type str\n        else:\n            raise TypeError('Unknown type, must be one of InputFile, str.')\n        # end if\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.duration is not None:\n            array['duration'] = int(self.duration)  # type int\n        if self.performer is not None:\n            array['performer'] = u(self.performer)  # py2: type unicode, py3: type str\n\n        if self.title is not None:\n            array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        if self.thumb is not None:\n            if isinstance(self.thumb, InputFile):\n                array['thumb'] = self.thumb.to_array()  # type InputFile\n            elif isinstance(self.thumb, str):\n                array['thumb'] = u(self.thumb)  # py2: type unicode, py3: type str\n            else:\n                raise TypeError('Unknown type, must be one of InputFile, str.')\n            # end if\n\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        if self.reply_markup is not None:\n            if isinstance(self.reply_markup, InlineKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardRemove):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardRemove\n            elif isinstance(self.reply_markup, ForceReply):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ForceReply\n            else:\n                raise TypeError('Unknown type, must be one of InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply.')\n            # end if\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send(self, sender: PytgbotApiBot):\n        return sender.send_document(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            document=self.document, chat_id=self.receiver, reply_to_message_id=self.reply_id, thumb=self.thumb, caption=self.caption, parse_mode=self.parse_mode, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )", "response": "Send the message via pytgbot."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send(self, sender: PytgbotApiBot):\n        return sender.send_video(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            video=self.video, chat_id=self.receiver, reply_to_message_id=self.reply_id, duration=self.duration, width=self.width, height=self.height, thumb=self.thumb, caption=self.caption, parse_mode=self.parse_mode, supports_streaming=self.supports_streaming, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )", "response": "Send the message via the bot."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends the message via pytgbot.", "response": "def send(self, sender: PytgbotApiBot):\n        \"\"\"\n        Send the message via pytgbot.\n\n        :param sender: The bot instance to send with.\n        :type  sender: pytgbot.bot.Bot\n\n        :rtype: PytgbotApiMessage\n        \"\"\"\n        return sender.send_animation(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            animation=self.animation, chat_id=self.receiver, reply_to_message_id=self.reply_id, duration=self.duration, width=self.width, height=self.height, thumb=self.thumb, caption=self.caption, parse_mode=self.parse_mode, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(AnimationMessage, self).to_array()\n        if isinstance(self.animation, InputFile):\n            array['animation'] = self.animation.to_array()  # type InputFile\n        elif isinstance(self.animation, str):\n            array['animation'] = u(self.animation)  # py2: type unicode, py3: type str\n        else:\n            raise TypeError('Unknown type, must be one of InputFile, str.')\n        # end if\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.duration is not None:\n            array['duration'] = int(self.duration)  # type int\n        if self.width is not None:\n            array['width'] = int(self.width)  # type int\n        if self.height is not None:\n            array['height'] = int(self.height)  # type int\n        if self.thumb is not None:\n            if isinstance(self.thumb, InputFile):\n                array['thumb'] = self.thumb.to_array()  # type InputFile\n            elif isinstance(self.thumb, str):\n                array['thumb'] = u(self.thumb)  # py2: type unicode, py3: type str\n            else:\n                raise TypeError('Unknown type, must be one of InputFile, str.')\n            # end if\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        if self.reply_markup is not None:\n            if isinstance(self.reply_markup, InlineKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardRemove):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardRemove\n            elif isinstance(self.reply_markup, ForceReply):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ForceReply\n            else:\n                raise TypeError('Unknown type, must be one of InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply.')\n            # end if\n\n        return array", "response": "Serializes this AnimationMessage to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, sender: PytgbotApiBot):\n        return sender.send_voice(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            voice=self.voice, chat_id=self.receiver, reply_to_message_id=self.reply_id, caption=self.caption, parse_mode=self.parse_mode, duration=self.duration, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )", "response": "Send the message via pytgbot."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nserializing this VoiceMessage to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this VoiceMessage to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(VoiceMessage, self).to_array()\n        if isinstance(self.voice, InputFile):\n            array['voice'] = self.voice.to_array()  # type InputFile\n        elif isinstance(self.voice, str):\n            array['voice'] = u(self.voice)  # py2: type unicode, py3: type str\n        else:\n            raise TypeError('Unknown type, must be one of InputFile, str.')\n        # end if\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.duration is not None:\n            array['duration'] = int(self.duration)  # type int\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        if self.reply_markup is not None:\n            if isinstance(self.reply_markup, InlineKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardRemove):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardRemove\n            elif isinstance(self.reply_markup, ForceReply):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ForceReply\n            else:\n                raise TypeError('Unknown type, must be one of InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply.')\n            # end if\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, sender: PytgbotApiBot):\n        return sender.send_video_note(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            video_note=self.video_note, chat_id=self.receiver, reply_to_message_id=self.reply_id, duration=self.duration, length=self.length, thumb=self.thumb, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )", "response": "Send the message via pytgbot."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_array(self):\n        array = super(VideoNoteMessage, self).to_array()\n        if isinstance(self.video_note, InputFile):\n            array['video_note'] = self.video_note.to_array()  # type InputFile\n        elif isinstance(self.video_note, str):\n            array['video_note'] = u(self.video_note)  # py2: type unicode, py3: type str\n        else:\n            raise TypeError('Unknown type, must be one of InputFile, str.')\n        # end if\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.duration is not None:\n            array['duration'] = int(self.duration)  # type int\n        if self.length is not None:\n            array['length'] = int(self.length)  # type int\n        if self.thumb is not None:\n            if isinstance(self.thumb, InputFile):\n                array['thumb'] = self.thumb.to_array()  # type InputFile\n            elif isinstance(self.thumb, str):\n                array['thumb'] = u(self.thumb)  # py2: type unicode, py3: type str\n            else:\n                raise TypeError('Unknown type, must be one of InputFile, str.')\n            # end if\n\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        if self.reply_markup is not None:\n            if isinstance(self.reply_markup, InlineKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardRemove):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardRemove\n            elif isinstance(self.reply_markup, ForceReply):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ForceReply\n            else:\n                raise TypeError('Unknown type, must be one of InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply.')\n            # end if\n\n        return array", "response": "Serializes this VideoNoteMessage to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, sender: PytgbotApiBot):\n        return sender.send_media_group(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            media=self.media, chat_id=self.receiver, reply_to_message_id=self.reply_id, disable_notification=self.disable_notification\n        )", "response": "Send the message via pytgbot."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_array(self):\n        array = super(MediaGroupMessage, self).to_array()\n        if isinstance(self.media, InputMediaPhoto):\n            array['media'] = self._as_array(self.media)  # type list of InputMediaPhoto | list of InputMediaVideo\n        elif isinstance(self.media, InputMediaVideo):\n            array['media'] = self._as_array(self.media)  # type list of InputMediaPhoto | list of InputMediaVideo\n        else:\n            raise TypeError('Unknown type, must be one of InputMediaPhoto, InputMediaVideo.')\n        # end if\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        return array", "response": "Serializes this MediaGroupMessage to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send(self, sender: PytgbotApiBot):\n        return sender.send_location(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            latitude=self.latitude, longitude=self.longitude, chat_id=self.receiver, reply_to_message_id=self.reply_id, live_period=self.live_period, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )", "response": "Send the message via pytgbot."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(LocationMessage, self).to_array()\n        array['latitude'] = float(self.latitude)  # type float\n        array['longitude'] = float(self.longitude)  # type float\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.live_period is not None:\n            array['live_period'] = int(self.live_period)  # type int\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        if self.reply_markup is not None:\n            if isinstance(self.reply_markup, InlineKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardRemove):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardRemove\n            elif isinstance(self.reply_markup, ForceReply):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ForceReply\n            else:\n                raise TypeError('Unknown type, must be one of InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply.')\n            # end if\n\n        return array", "response": "Serializes this LocationMessage to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, sender: PytgbotApiBot):\n        return sender.send_venue(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            latitude=self.latitude, longitude=self.longitude, title=self.title, address=self.address, chat_id=self.receiver, reply_to_message_id=self.reply_id, foursquare_id=self.foursquare_id, foursquare_type=self.foursquare_type, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )", "response": "Send the message via the bot."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_array(self):\n        array = super(VenueMessage, self).to_array()\n        array['latitude'] = float(self.latitude)  # type float\n        array['longitude'] = float(self.longitude)  # type float\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        array['address'] = u(self.address)  # py2: type unicode, py3: type str\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.foursquare_id is not None:\n            array['foursquare_id'] = u(self.foursquare_id)  # py2: type unicode, py3: type str\n\n        if self.foursquare_type is not None:\n            array['foursquare_type'] = u(self.foursquare_type)  # py2: type unicode, py3: type str\n\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        if self.reply_markup is not None:\n            if isinstance(self.reply_markup, InlineKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardRemove):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardRemove\n            elif isinstance(self.reply_markup, ForceReply):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ForceReply\n            else:\n                raise TypeError('Unknown type, must be one of InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply.')\n            # end if\n\n        return array", "response": "Serializes this VenueMessage to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend the message via the bot.", "response": "def send(self, sender: PytgbotApiBot):\n        \"\"\"\n        Send the message via pytgbot.\n\n        :param sender: The bot instance to send with.\n        :type  sender: pytgbot.bot.Bot\n\n        :rtype: PytgbotApiMessage\n        \"\"\"\n        return sender.send_contact(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            phone_number=self.phone_number, first_name=self.first_name, chat_id=self.receiver, reply_to_message_id=self.reply_id, last_name=self.last_name, vcard=self.vcard, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_array(self):\n        array = super(ContactMessage, self).to_array()\n        array['phone_number'] = u(self.phone_number)  # py2: type unicode, py3: type str\n\n        array['first_name'] = u(self.first_name)  # py2: type unicode, py3: type str\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.last_name is not None:\n            array['last_name'] = u(self.last_name)  # py2: type unicode, py3: type str\n\n        if self.vcard is not None:\n            array['vcard'] = u(self.vcard)  # py2: type unicode, py3: type str\n\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        if self.reply_markup is not None:\n            if isinstance(self.reply_markup, InlineKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardRemove):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardRemove\n            elif isinstance(self.reply_markup, ForceReply):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ForceReply\n            else:\n                raise TypeError('Unknown type, must be one of InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply.')\n            # end if\n\n        return array", "response": "Serializes this ContactMessage to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending the message via pytgbot.", "response": "def send(self, sender: PytgbotApiBot):\n        \"\"\"\n        Send the message via pytgbot.\n\n        :param sender: The bot instance to send with.\n        :type  sender: pytgbot.bot.Bot\n\n        :rtype: PytgbotApiMessage\n        \"\"\"\n        return sender.send_chat_action(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            action=self.action, chat_id=self.receiver\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_array(self):\n        array = super(ChatActionMessage, self).to_array()\n        array['action'] = u(self.action)  # py2: type unicode, py3: type str\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        return array", "response": "Serializes this ChatActionMessage to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, sender: PytgbotApiBot):\n        return sender.send_sticker(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            sticker=self.sticker, chat_id=self.receiver, reply_to_message_id=self.reply_id, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )", "response": "Send the message via pytgbot."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserialize this StickerMessage to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this StickerMessage to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(StickerMessage, self).to_array()\n        if isinstance(self.sticker, InputFile):\n            array['sticker'] = self.sticker.to_array()  # type InputFile\n        elif isinstance(self.sticker, str):\n            array['sticker'] = u(self.sticker)  # py2: type unicode, py3: type str\n        else:\n            raise TypeError('Unknown type, must be one of InputFile, str.')\n        # end if\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        if self.reply_markup is not None:\n            if isinstance(self.reply_markup, InlineKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardMarkup):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardMarkup\n            elif isinstance(self.reply_markup, ReplyKeyboardRemove):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ReplyKeyboardRemove\n            elif isinstance(self.reply_markup, ForceReply):\n                array['reply_markup'] = self.reply_markup.to_array()  # type ForceReply\n            else:\n                raise TypeError('Unknown type, must be one of InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply.')\n            # end if\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.sendable.files import InputFile\n        from pytgbot.api_types.sendable.reply_markup import ForceReply\n        from pytgbot.api_types.sendable.reply_markup import InlineKeyboardMarkup\n        from pytgbot.api_types.sendable.reply_markup import ReplyKeyboardMarkup\n        from pytgbot.api_types.sendable.reply_markup import ReplyKeyboardRemove\n        \n\n        data = {}\n        if isinstance(array.get('sticker'), InputFile):\n            data['sticker'] = InputFile.from_array(array.get('sticker'))\n        elif isinstance(array.get('sticker'), str):\n            data['sticker'] = u(array.get('sticker'))\n        else:\n            raise TypeError('Unknown type, must be one of InputFile, str.')\n        # end if\n        if array.get('chat_id') is None:\n            data['receiver'] = None\n        elif isinstance(array.get('chat_id'), None):\n            data['receiver'] = None(array.get('chat_id'))\n        elif isinstance(array.get('chat_id'), str):\n            data['receiver'] = u(array.get('chat_id'))\n        elif isinstance(array.get('chat_id'), int):\n            data['receiver'] = int(array.get('chat_id'))\n        else:\n            raise TypeError('Unknown type, must be one of None, str, int or None.')\n        # end if\n        if array.get('reply_to_message_id') is None:\n            data['reply_id'] = None\n        elif isinstance(array.get('reply_to_message_id'), DEFAULT_MESSAGE_ID):\n            data['reply_id'] = DEFAULT_MESSAGE_ID(array.get('reply_to_message_id'))\n        elif isinstance(array.get('reply_to_message_id'), int):\n            data['reply_id'] = int(array.get('reply_to_message_id'))\n        else:\n            raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int or None.')\n        # end if\n        data['disable_notification'] = bool(array.get('disable_notification')) if array.get('disable_notification') is not None else None\n        if array.get('reply_markup') is None:\n            data['reply_markup'] = None\n        elif isinstance(array.get('reply_markup'), InlineKeyboardMarkup):\n            data['reply_markup'] = InlineKeyboardMarkup.from_array(array.get('reply_markup'))\n        elif isinstance(array.get('reply_markup'), ReplyKeyboardMarkup):\n            data['reply_markup'] = ReplyKeyboardMarkup.from_array(array.get('reply_markup'))\n        elif isinstance(array.get('reply_markup'), ReplyKeyboardRemove):\n            data['reply_markup'] = ReplyKeyboardRemove.from_array(array.get('reply_markup'))\n        elif isinstance(array.get('reply_markup'), ForceReply):\n            data['reply_markup'] = ForceReply.from_array(array.get('reply_markup'))\n        else:\n            raise TypeError('Unknown type, must be one of InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply or None.')\n        # end if\n        return StickerMessage(**data)", "response": "Deserialize a new StickerMessage from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send(self, sender: PytgbotApiBot):\n        return sender.send_invoice(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            title=self.title, description=self.description, payload=self.payload, provider_token=self.provider_token, start_parameter=self.start_parameter, currency=self.currency, prices=self.prices, chat_id=self.receiver, reply_to_message_id=self.reply_id, provider_data=self.provider_data, photo_url=self.photo_url, photo_size=self.photo_size, photo_width=self.photo_width, photo_height=self.photo_height, need_name=self.need_name, need_phone_number=self.need_phone_number, need_email=self.need_email, need_shipping_address=self.need_shipping_address, send_phone_number_to_provider=self.send_phone_number_to_provider, send_email_to_provider=self.send_email_to_provider, is_flexible=self.is_flexible, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )", "response": "Send the message via the bot."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nserializes this InvoiceMessage to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InvoiceMessage to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InvoiceMessage, self).to_array()\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        array['description'] = u(self.description)  # py2: type unicode, py3: type str\n\n        array['payload'] = u(self.payload)  # py2: type unicode, py3: type str\n\n        array['provider_token'] = u(self.provider_token)  # py2: type unicode, py3: type str\n\n        array['start_parameter'] = u(self.start_parameter)  # py2: type unicode, py3: type str\n\n        array['currency'] = u(self.currency)  # py2: type unicode, py3: type str\n\n        array['prices'] = self._as_array(self.prices)  # type list of LabeledPrice\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.provider_data is not None:\n            array['provider_data'] = u(self.provider_data)  # py2: type unicode, py3: type str\n\n        if self.photo_url is not None:\n            array['photo_url'] = u(self.photo_url)  # py2: type unicode, py3: type str\n\n        if self.photo_size is not None:\n            array['photo_size'] = int(self.photo_size)  # type int\n        if self.photo_width is not None:\n            array['photo_width'] = int(self.photo_width)  # type int\n        if self.photo_height is not None:\n            array['photo_height'] = int(self.photo_height)  # type int\n        if self.need_name is not None:\n            array['need_name'] = bool(self.need_name)  # type bool\n        if self.need_phone_number is not None:\n            array['need_phone_number'] = bool(self.need_phone_number)  # type bool\n        if self.need_email is not None:\n            array['need_email'] = bool(self.need_email)  # type bool\n        if self.need_shipping_address is not None:\n            array['need_shipping_address'] = bool(self.need_shipping_address)  # type bool\n        if self.send_phone_number_to_provider is not None:\n            array['send_phone_number_to_provider'] = bool(self.send_phone_number_to_provider)  # type bool\n        if self.send_email_to_provider is not None:\n            array['send_email_to_provider'] = bool(self.send_email_to_provider)  # type bool\n        if self.is_flexible is not None:\n            array['is_flexible'] = bool(self.is_flexible)  # type bool\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.sendable.payments import LabeledPrice\n        from pytgbot.api_types.sendable.reply_markup import InlineKeyboardMarkup\n        \n\n        data = {}\n        data['title'] = u(array.get('title'))\n        data['description'] = u(array.get('description'))\n        data['payload'] = u(array.get('payload'))\n        data['provider_token'] = u(array.get('provider_token'))\n        data['start_parameter'] = u(array.get('start_parameter'))\n        data['currency'] = u(array.get('currency'))\n        data['prices'] = LabeledPrice.from_array_list(array.get('prices'), list_level=1)\n        if array.get('chat_id') is None:\n            data['receiver'] = None\n        elif isinstance(array.get('chat_id'), None):\n            data['receiver'] = None(array.get('chat_id'))\n        elif isinstance(array.get('chat_id'), str):\n            data['receiver'] = u(array.get('chat_id'))\n        elif isinstance(array.get('chat_id'), int):\n            data['receiver'] = int(array.get('chat_id'))\n        else:\n            raise TypeError('Unknown type, must be one of None, str, int or None.')\n        # end if\n        if array.get('reply_to_message_id') is None:\n            data['reply_id'] = None\n        elif isinstance(array.get('reply_to_message_id'), DEFAULT_MESSAGE_ID):\n            data['reply_id'] = DEFAULT_MESSAGE_ID(array.get('reply_to_message_id'))\n        elif isinstance(array.get('reply_to_message_id'), int):\n            data['reply_id'] = int(array.get('reply_to_message_id'))\n        else:\n            raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int or None.')\n        # end if\n        data['provider_data'] = u(array.get('provider_data')) if array.get('provider_data') is not None else None\n        data['photo_url'] = u(array.get('photo_url')) if array.get('photo_url') is not None else None\n        data['photo_size'] = int(array.get('photo_size')) if array.get('photo_size') is not None else None\n        data['photo_width'] = int(array.get('photo_width')) if array.get('photo_width') is not None else None\n        data['photo_height'] = int(array.get('photo_height')) if array.get('photo_height') is not None else None\n        data['need_name'] = bool(array.get('need_name')) if array.get('need_name') is not None else None\n        data['need_phone_number'] = bool(array.get('need_phone_number')) if array.get('need_phone_number') is not None else None\n        data['need_email'] = bool(array.get('need_email')) if array.get('need_email') is not None else None\n        data['need_shipping_address'] = bool(array.get('need_shipping_address')) if array.get('need_shipping_address') is not None else None\n        data['send_phone_number_to_provider'] = bool(array.get('send_phone_number_to_provider')) if array.get('send_phone_number_to_provider') is not None else None\n        data['send_email_to_provider'] = bool(array.get('send_email_to_provider')) if array.get('send_email_to_provider') is not None else None\n        data['is_flexible'] = bool(array.get('is_flexible')) if array.get('is_flexible') is not None else None\n        data['disable_notification'] = bool(array.get('disable_notification')) if array.get('disable_notification') is not None else None\n        data['reply_markup'] = InlineKeyboardMarkup.from_array(array.get('reply_markup')) if array.get('reply_markup') is not None else None\n        return InvoiceMessage(**data)", "response": "Deserialize a new InvoiceMessage from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending the message via pytgbot.", "response": "def send(self, sender: PytgbotApiBot):\n        \"\"\"\n        Send the message via pytgbot.\n\n        :param sender: The bot instance to send with.\n        :type  sender: pytgbot.bot.Bot\n\n        :rtype: PytgbotApiMessage\n        \"\"\"\n        return sender.send_game(\n            # receiver, self.media, disable_notification=self.disable_notification, reply_to_message_id=reply_id\n            game_short_name=self.game_short_name, chat_id=self.receiver, reply_to_message_id=self.reply_id, disable_notification=self.disable_notification, reply_markup=self.reply_markup\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(GameMessage, self).to_array()\n        array['game_short_name'] = u(self.game_short_name)  # py2: type unicode, py3: type str\n\n        if self.receiver is not None:\n            if isinstance(self.receiver, None):\n                array['chat_id'] = None(self.receiver)  # type Noneelif isinstance(self.receiver, str):\n                array['chat_id'] = u(self.receiver)  # py2: type unicode, py3: type str\n            elif isinstance(self.receiver, int):\n                array['chat_id'] = int(self.receiver)  # type intelse:\n                raise TypeError('Unknown type, must be one of None, str, int.')\n            # end if\n\n        if self.reply_id is not None:\n            if isinstance(self.reply_id, DEFAULT_MESSAGE_ID):\n                array['reply_to_message_id'] = DEFAULT_MESSAGE_ID(self.reply_id)  # type DEFAULT_MESSAGE_IDelif isinstance(self.reply_id, int):\n                array['reply_to_message_id'] = int(self.reply_id)  # type intelse:\n                raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int.')\n            # end if\n\n        if self.disable_notification is not None:\n            array['disable_notification'] = bool(self.disable_notification)  # type bool\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        return array", "response": "Serializes this GameMessage to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.sendable.reply_markup import InlineKeyboardMarkup\n        \n\n        data = {}\n        data['game_short_name'] = u(array.get('game_short_name'))\n        if array.get('chat_id') is None:\n            data['receiver'] = None\n        elif isinstance(array.get('chat_id'), None):\n            data['receiver'] = None(array.get('chat_id'))\n        elif isinstance(array.get('chat_id'), str):\n            data['receiver'] = u(array.get('chat_id'))\n        elif isinstance(array.get('chat_id'), int):\n            data['receiver'] = int(array.get('chat_id'))\n        else:\n            raise TypeError('Unknown type, must be one of None, str, int or None.')\n        # end if\n        if array.get('reply_to_message_id') is None:\n            data['reply_id'] = None\n        elif isinstance(array.get('reply_to_message_id'), DEFAULT_MESSAGE_ID):\n            data['reply_id'] = DEFAULT_MESSAGE_ID(array.get('reply_to_message_id'))\n        elif isinstance(array.get('reply_to_message_id'), int):\n            data['reply_id'] = int(array.get('reply_to_message_id'))\n        else:\n            raise TypeError('Unknown type, must be one of DEFAULT_MESSAGE_ID, int or None.')\n        # end if\n        data['disable_notification'] = bool(array.get('disable_notification')) if array.get('disable_notification') is not None else None\n        data['reply_markup'] = InlineKeyboardMarkup.from_array(array.get('reply_markup')) if array.get('reply_markup') is not None else None\n        return GameMessage(**data)", "response": "Deserialize a new GameMessage from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef select_nodeids(xmrs, iv=None, label=None, pred=None):\n    def datamatch(nid):\n        ep = xmrs.ep(nid)\n        return ((iv is None or ep.iv == iv) and\n                (pred is None or ep.pred == pred) and\n                (label is None or ep.label == label))\n    return list(filter(datamatch, xmrs.nodeids()))", "response": "Returns a list of nodeids in xmrs that match if their corresponding\n            matches the given intrinsic variable label and predicate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef select_nodes(xmrs, nodeid=None, pred=None):\n    nodematch = lambda n: ((nodeid is None or n.nodeid == nodeid) and\n                           (pred is None or n.pred == pred))\n    return list(filter(nodematch, nodes(xmrs)))", "response": "Return the list of matching nodes in xmrs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nselecting the elements in a base - level elementary pre - predication from a semantic structure.", "response": "def select_eps(xmrs, nodeid=None, iv=None, label=None, pred=None):\n    \"\"\"\n    Return the list of matching elementary predications in *xmrs*.\n\n    :class:`~delphin.mrs.components.ElementaryPredication` objects for\n    *xmrs* match if their `nodeid` matches *nodeid*,\n    `intrinsic_variable` matches *iv*, `label` matches *label*, and\n    `pred` to *pred*. The *nodeid*, *iv*, *label*, and *pred* filters\n    are ignored if they are `None`.\n\n    Args:\n        xmrs (:class:`~delphin.mrs.xmrs.Xmrs`): semantic structure to\n            query\n        nodeid (optional): nodeid to match\n        iv (str, optional): intrinsic variable to match\n        label (str, optional): label to match\n        pred (str, :class:`~delphin.mrs.components.Pred`, optional):\n            predicate to match\n    Returns:\n        list: matching elementary predications\n    \"\"\"\n    epmatch = lambda n: ((nodeid is None or n.nodeid == nodeid) and\n                         (iv is None or n.iv == iv) and\n                         (label is None or n.label == label) and\n                         (pred is None or n.pred == pred))\n    return list(filter(epmatch, xmrs.eps()))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nselecting the arguments from the given xmrs.", "response": "def select_args(xmrs, nodeid=None, rargname=None, value=None):\n    \"\"\"\n    Return the list of matching (nodeid, role, value) triples in *xmrs*.\n\n    Predication arguments in *xmrs* match if the `nodeid` of the\n    :class:`~delphin.mrs.components.ElementaryPredication` they are\n    arguments of match *nodeid*, their role matches *rargname*, and\n    their value matches *value*. The *nodeid*, *rargname*, and *value*\n    filters are ignored if they are `None`.\n\n    Note:\n        The *value* filter matches the variable, handle, or constant\n        that is the overt value for the argument. If you want to find\n        arguments that target a particular nodeid, look into\n        :meth:`Xmrs.incoming_args() <delphin.mrs.xmrs.Xmrs.incoming_args>`.\n        If you want to match a target value to its resolved object, see\n        :func:`find_argument_target`.\n    Args:\n        xmrs (:class:`~delphin.mrs.xmrs.Xmrs`): semantic structure to\n            query\n        nodeid (optional): nodeid to match\n        rargname (str, optional): role name to match\n        value (str, optional): argument value to match\n    Returns:\n        list: matching arguments as (nodeid, role, value) triples\n    \"\"\"\n    argmatch = lambda a: ((nodeid is None or a[0] == nodeid) and\n                          (rargname is None or\n                           a[1].upper() == rargname.upper()) and\n                          (value is None or a[2] == value))\n    all_args = (\n        (nid, role, val)\n        for nid in xmrs.nodeids()\n        for role, val in sorted(\n            xmrs.args(nid).items(),\n            key=lambda i: rargname_sortkey(i[0])\n        )\n    )\n    return list(filter(argmatch, all_args))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nselect the links in the given xmrs.", "response": "def select_links(xmrs, start=None, end=None, rargname=None, post=None):\n    \"\"\"\n    Return the list of matching links for *xmrs*.\n\n    :class:`~delphin.mrs.components.Link` objects for *xmrs* match if\n    their `start` matches *start*, `end` matches *end*, `rargname`\n    matches *rargname*, and `post` matches *post*. The *start*, *end*,\n    *rargname*, and *post* filters are ignored if they are `None`.\n\n    Args:\n        xmrs (:class:`~delphin.mrs.xmrs.Xmrs`): semantic structure to\n            query\n        start (optional): link start nodeid to match\n        end (optional): link end nodeid to match\n        rargname (str, optional): role name to match\n        post (str, optional): Link post-slash label to match\n    Returns:\n        list: matching links\n    \"\"\"\n    linkmatch = lambda l: (\n        (start is None or l.start == start) and\n        (end is None or l.end == end) and\n        (rargname is None or l.rargname == rargname) and\n        (post is None or l.post == post))\n    return list(filter(linkmatch, links(xmrs)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef select_hcons(xmrs, hi=None, relation=None, lo=None):\n    hcmatch = lambda hc: (\n        (hi is None or hc.hi == hi) and\n        (relation is None or hc.relation == relation) and\n        (lo is None or hc.lo == lo))\n    return list(filter(hcmatch, xmrs.hcons()))", "response": "Select the HCONS for the given xmrs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef select_icons(xmrs, left=None, relation=None, right=None):\n    icmatch = lambda ic: (\n        (left is None or ic.left == left) and\n        (relation is None or ic.relation == relation) and\n        (right is None or ic.right == right))\n    return list(filter(icmatch, xmrs.icons()))", "response": "Returns a list of ICONS for xmrs matching left and right variables."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the target of an argument.", "response": "def find_argument_target(xmrs, nodeid, rargname):\n    \"\"\"\n    Return the target of an argument (rather than just the variable).\n\n    Note:\n        If the argument value is an intrinsic variable whose target is\n        an EP that has a quantifier, the non-quantifier EP's nodeid\n        will be returned. With this nodeid, one can then use\n        :meth:`Xmrs.nodeid() <delphin.mrs.xmrs.Xmrs.nodeid>` to get its\n        quantifier's nodeid.\n    Args:\n        xmrs (:class:`~delphin.mrs.xmrs.Xmrs`): semantic structure to\n            use\n        nodeid: nodeid of the argument.\n        rargname: role name of the argument.\n    Returns:\n        The object that is the target of the argument. Possible values\n        include:\n\n        ==================  =====  =============================\n        Argument value      e.g.   Target\n        ------------------  -----  -----------------------------\n        intrinsic variable  x4     nodeid; of the EP with the IV\n        hole variable       h0     nodeid; HCONS's labelset head\n        label               h1     nodeid; label's labelset head\n        unbound variable    i3     the variable itself\n        constant            \"IBM\"  the constant itself\n        ==================  =====  =============================\n    \"\"\"\n    tgt = xmrs.args(nodeid)[rargname]\n    if tgt in xmrs.variables():\n        try:\n            return xmrs.nodeid(tgt)\n        except KeyError:\n            pass\n\n        try:\n            tgt = xmrs.hcon(tgt).lo\n            return next(iter(xmrs.labelset_heads(tgt)), None)\n        except KeyError:\n            pass\n\n        try:\n            return next(iter(xmrs.labelset_heads(tgt)))\n        except (KeyError, StopIteration):\n            pass\n    return tgt"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nyield all subgraphs matching a list of predicates.", "response": "def find_subgraphs_by_preds(xmrs, preds, connected=None):\n    \"\"\"\n    Yield subgraphs matching a list of predicates.\n\n    Predicates may match multiple EPs/nodes in the *xmrs*, meaning that\n    more than one subgraph is possible. Also, predicates in *preds*\n    match in number, so if a predicate appears twice in *preds*, there\n    will be two matching EPs/nodes in each subgraph.\n\n    Args:\n        xmrs (:class:`~delphin.mrs.xmrs.Xmrs`): semantic structure to\n            use\n        preds: iterable of predicates to include in subgraphs\n        connected (bool, optional): if `True`, all yielded subgraphs\n            must be connected, as determined by\n            :meth:`Xmrs.is_connected() <delphin.mrs.xmrs.Xmrs.is_connected>`.\n    Yields:\n        A :class:`~delphin.mrs.xmrs.Xmrs` object for each subgraphs found.\n    \"\"\"\n    preds = list(preds)\n    count = len(preds)\n    # find all lists of nodeids such that the lists have no repeated nids;\n    # keep them as a list (fixme: why not just get sets?)\n    nidsets = set(\n        tuple(sorted(ns))\n        for ns in filter(\n            lambda ns: len(set(ns)) == count,\n            product(*[select_nodeids(xmrs, pred=p) for p in preds])\n        )\n    )\n    for nidset in nidsets:\n        sg = xmrs.subgraph(nidset)\n        if connected is None or sg.is_connected() == connected:\n            yield sg"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef intrinsic_variables(xmrs):\n    ivs = set(\n        ep.intrinsic_variable for ep in xmrs.eps()\n        if not ep.is_quantifier() and ep.intrinsic_variable is not None\n    )\n    return sorted(ivs, key=var_id)", "response": "Return the list of all intrinsic variables in xmrs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bound_variables(xmrs):\n    bvs = set(\n        ep.intrinsic_variable for ep in xmrs.eps()\n        if ep.is_quantifier() and ep.intrinsic_variable is not None\n    )\n    return sorted(bvs, key=var_id)", "response": "Return the list of all bound variables in xmrs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef in_labelset(xmrs, nodeids, label=None):\n    nodeids = set(nodeids)\n    if label is None:\n        label = xmrs.ep(next(iter(nodeids))).label\n    return nodeids.issubset(xmrs._vars[label]['refs']['LBL'])", "response": "Test if all nodeids share a label."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a tuple with the value for the json url argument and a dictionary for the multipart file upload.", "response": "def get_input_media_referenced_files(self, var_name):\n        \"\"\"\n        Generates a tuple with the value for the json/url argument and a dictionary for the multipart file upload.\n        Will return something which might be similar to\n        `('attach://{var_name}', {var_name: ('foo.png', open('foo.png', 'rb'), 'image/png')})`\n\n        or in the case of the :class:`InputFileUseFileID` class, just\n        `('AwADBAADbXXXXXXXXXXXGBdhD2l6_XX', None)`\n\n        :param var_name: name used to reference the file.\n        :type  var_name: str\n\n        :return: tuple of (file_id, dict)\n        :rtype: tuple\n        \"\"\"\n        # file to be uploaded\n        string = 'attach://{name}'.format(name=var_name)\n        return string, self.get_request_files(var_name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new instance of the InputFile subclass.", "response": "def factory(\n            cls, file_id=None, path=None, url=None, blob=None, mime=None,\n            prefer_local_download=True, prefer_str=False, create_instance=True\n    ):\n        \"\"\"\n        Creates a new InputFile subclass instance fitting the given parameters.\n\n        :param prefer_local_download: If `True`, we download the file and send it to telegram. This is the default.\n                                      If `False`, we send Telegram just the URL, and they'll try to download it.\n        :type  prefer_local_download: bool\n\n        :param prefer_str: Return just the `str` instead of a `InputFileUseFileID` or `InputFileUseUrl` object.\n        :type  prefer_str: bool\n\n        :param create_instance: If we should return a instance ready to use (default),\n                                or the building parts being a tuple of `(class, args_tuple, kwargs_dict)`.\n                                Setting this to `False` is probably only ever required for internal usage\n                                by the :class:`InputFile` constructor which uses this very factory.\n        :type  create_instance: bool\n\n\n        :returns: if `create_instance=True` it returns a instance of some InputFile subclass or a string,\n                  if `create_instance=False` it returns a tuple of the needed class, args and kwargs needed\n                  to create a instance.\n        :rtype: InputFile|InputFileFromBlob|InputFileFromDisk|InputFileFromURL|str|tuple\n        \"\"\"\n        if create_instance:\n            clazz, args, kwargs = cls.factory(\n                file_id=file_id,\n                path=path,\n                url=url,\n                blob=blob,\n                mime=mime,\n                create_instance=False,\n            )\n            return clazz(*args, **kwargs)\n        if file_id:\n            if prefer_str:\n                assert_type_or_raise(file_id, str, parameter_name='file_id')\n                return str, (file_id,), dict()\n            # end if\n            return InputFileUseFileID, (file_id,), dict()\n        if blob:\n            name = \"file\"\n            suffix = \".blob\"\n            if path:\n                name = os_path.basename(os_path.normpath(path))  # http://stackoverflow.com/a/3925147/3423324#last-part\n                name, suffix = os_path.splitext(name)  # http://stackoverflow.com/a/541394/3423324#extension\n            elif url:\n                # http://stackoverflow.com/a/18727481/3423324#how-to-extract-a-filename-from-a-url\n                url = urlparse(url)\n                name = os_path.basename(url.path)\n                name, suffix = os_path.splitext(name)\n            # end if\n            if mime:\n                import mimetypes\n                suffix = mimetypes.guess_extension(mime)\n                suffix = '.jpg' if suffix == '.jpe' else suffix  # .jpe -> .jpg\n            # end if\n            if not suffix or not suffix.strip().lstrip(\".\"):\n                logger.debug(\"suffix was empty. Using '.blob'\")\n                suffix = \".blob\"\n            # end if\n            name = \"{filename}{suffix}\".format(filename=name, suffix=suffix)\n            return InputFileFromBlob, (blob,), dict(name=name, mime=mime)\n        if path:\n            return InputFileFromDisk, (path,), dict(mime=mime)\n        if url:\n            if prefer_local_download:\n                return InputFileFromURL, (url,), dict(mime=mime)\n            # end if\n            # else -> so we wanna let telegram handle it\n            if prefer_str:\n                assert_type_or_raise(url, str, parameter_name='url')\n                return str, (url,), dict()\n            # end if\n            return InputFileUseUrl, (url,), dict()\n\n        # end if\n        raise ValueError('Could not find a matching subclass. You might need to do it manually instead.')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_array(self):\n        array = super(PassportData, self).to_array()\n        array['data'] = self._as_array(self.data)  # type list of EncryptedPassportElement\n        array['credentials'] = self.credentials.to_array()  # type EncryptedCredentials\n        return array", "response": "Serializes this PassportData to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_array(self):\n        array = super(PassportFile, self).to_array()\n        array['file_id'] = u(self.file_id)  # py2: type unicode, py3: type str\n        array['file_size'] = int(self.file_size)  # type int\n        array['file_date'] = int(self.file_date)  # type int\n        return array", "response": "Serializes this PassportFile to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_array(self):\n        array = super(EncryptedPassportElement, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['hash'] = u(self.hash)  # py2: type unicode, py3: type str\n\n        if self.data is not None:\n            array['data'] = u(self.data)  # py2: type unicode, py3: type str\n        if self.phone_number is not None:\n            array['phone_number'] = u(self.phone_number)  # py2: type unicode, py3: type str\n        if self.email is not None:\n            array['email'] = u(self.email)  # py2: type unicode, py3: type str\n        if self.files is not None:\n            array['files'] = self._as_array(self.files)  # type list of PassportFile\n        if self.front_side is not None:\n            array['front_side'] = self.front_side.to_array()  # type PassportFile\n        if self.reverse_side is not None:\n            array['reverse_side'] = self.reverse_side.to_array()  # type PassportFile\n        if self.selfie is not None:\n            array['selfie'] = self.selfie.to_array()  # type PassportFile\n        if self.translation is not None:\n            array['translation'] = self._as_array(self.translation)  # type list of PassportFile\n        return array", "response": "Serializes this EncryptedPassportElement to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n\n        data = {}\n        data['type'] = u(array.get('type'))\n        data['hash'] = u(array.get('hash'))\n        data['data'] = u(array.get('data')) if array.get('data') is not None else None\n        data['phone_number'] = u(array.get('phone_number')) if array.get('phone_number') is not None else None\n        data['email'] = u(array.get('email')) if array.get('email') is not None else None\n        data['files'] = PassportFile.from_array_list(array.get('files'), list_level=1) if array.get('files') is not None else None\n        data['front_side'] = PassportFile.from_array(array.get('front_side')) if array.get('front_side') is not None else None\n        data['reverse_side'] = PassportFile.from_array(array.get('reverse_side')) if array.get('reverse_side') is not None else None\n        data['selfie'] = PassportFile.from_array(array.get('selfie')) if array.get('selfie') is not None else None\n        data['translation'] = PassportFile.from_array_list(array.get('translation'), list_level=1) if array.get('translation') is not None else None\n        data['_raw'] = array\n        return EncryptedPassportElement(**data)", "response": "Deserialize a new EncryptedPassportElement from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_array(self):\n        array = super(EncryptedCredentials, self).to_array()\n        array['data'] = u(self.data)  # py2: type unicode, py3: type str\n        array['hash'] = u(self.hash)  # py2: type unicode, py3: type str\n        array['secret'] = u(self.secret)  # py2: type unicode, py3: type str\n        return array", "response": "Serializes this EncryptedCredentials to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['data'] = u(array.get('data'))\n        data['hash'] = u(array.get('hash'))\n        data['secret'] = u(array.get('secret'))\n        data['_raw'] = array\n        return EncryptedCredentials(**data)", "response": "Deserialize a new EncryptedCredentials instance from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_updates(self, offset=None, limit=100, poll_timeout=0, allowed_updates=None, request_timeout=None, delta=timedelta(milliseconds=100), error_as_empty=False):\n        from datetime import datetime\n\n        assert(offset is None or isinstance(offset, int))\n        assert(limit is None or isinstance(limit, int))\n        assert(poll_timeout is None or isinstance(poll_timeout, int))\n        assert(allowed_updates is None or isinstance(allowed_updates, list))\n        if poll_timeout and not request_timeout is None:\n            request_timeout = poll_timeout + 2\n        # end if\n\n        if delta.total_seconds() > poll_timeout:\n            now = datetime.now()\n            if self._last_update - now < delta:\n                wait = ((now - self._last_update) - delta).total_seconds()  # can be 0.2\n                wait = 0 if wait < 0 else wait\n                if wait != 0:\n                    logger.debug(\"Sleeping {i} seconds.\".format(i=wait))\n                # end if\n                sleep(wait)\n            # end if\n        # end if\n        self._last_update = datetime.now()\n        try:\n            result = self.do(\n                \"getUpdates\", offset=offset, limit=limit, timeout=poll_timeout, allowed_updates=allowed_updates,\n                use_long_polling=poll_timeout != 0, request_timeout=request_timeout\n            )\n            if self.return_python_objects:\n                logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n                from pytgbot.api_types.receivable.updates import Update\n                try:\n                    return Update.from_array_list(result, list_level=1)\n                except TgApiParseException:\n                    logger.debug(\"Failed parsing as api_type Update\", exc_info=True)\n                # end try\n                # no valid parsing so far\n                raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n            # end if return_python_objects\n            return result\n        except (requests.RequestException, TgApiException) as e:\n            if error_as_empty:\n                logger.warn(\"Network related error happened in get_updates(), but will be ignored: \" + str(e),\n                            exc_info=True)\n                self._last_update = datetime.now()\n                return DictObject(result=[], exception=e)\n            else:\n                raise", "response": "This method returns a list of updates from the server using long polling."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_me(self):\n        result = self.do(\"getMe\")\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.peer import User\n            try:\n                return User.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type User\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "A simple method for testing your bot s auth token. Requires no parameters. Returns basic information about the bot in form of a User object. Requires no parameters. Returns a User object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nuse this method to forward a message from one chat to another.", "response": "def forward_message(self, chat_id, from_chat_id, message_id, disable_notification=False):\n        \"\"\"\n        Use this method to forward messages of any kind. On success, the sent Message is returned.\n\n        https://core.telegram.org/bots/api#forwardmessage\n\n        Parameters:\n\n        :param chat_id: Unique identifier for the target chat (chat id of user chat or group chat) or username of the\n                        target channel (in the format @channelusername)\n        :type  chat_id: int | str|unicode\n\n        :param from_chat_id: Unique identifier for the chat where the original message was sent\n                             (id for chats or the channel's username in the format @channelusername)\n        :type  from_chat_id: int | str|unicode\n\n        :param message_id: Message identifier in the chat specified in from_chat_id\n        :type  message_id: int\n\n\n        Optional keyword parameters:\n\n        :param disable_notification: Sends the message silently. Users will receive a notification with no sound.\n        :type  disable_notification: bool\n\n\n        Returns:\n\n        :return: On success, the sent Message is returned\n        :rtype:  pytgbot.api_types.receivable.updates.Message\n        \"\"\"\n        assert_type_or_raise(chat_id, (int, unicode_type), parameter_name=\"chat_id\")\n\n        assert_type_or_raise(from_chat_id, (int, unicode_type), parameter_name=\"from_chat_id\")\n\n        assert_type_or_raise(message_id, int, parameter_name=\"message_id\")\n\n        assert_type_or_raise(disable_notification, None, bool, parameter_name=\"disable_notification\")\n\n        result = self.do(\n            \"forwardMessage\", chat_id=chat_id, from_chat_id=from_chat_id, message_id=message_id,\n            disable_notification=disable_notification\n        )\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.updates import Message\n            try:\n                return Message.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type Message\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nusing this method to send a group of photos or videos as an album. You must be an administrator in the chat for this to work and must have the appropriate admin rights. You must have the appropriate admin rights.", "response": "def send_media_group(self, chat_id, media, disable_notification=None, reply_to_message_id=None):\n        \"\"\"\n        Use this method to send a group of photos or videos as an album. On success, an array of the sent Messages is returned.\n\n        https://core.telegram.org/bots/api#sendmediagroup\n\n\n        Parameters:\n\n        :param chat_id: Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n        :type  chat_id: int | str|unicode\n\n        :param media: A array describing photos and videos to be sent, must include 2\u201310 items\n        :type  media: list of (pytgbot.api_types.sendable.input_media.InputMediaPhoto|pytgbot.api_types.sendable.input_media.InputMediaVideo)\n\n\n        Optional keyword parameters:\n\n        :param disable_notification: Sends the messages silently. Users will receive a notification with no sound.\n        :type  disable_notification: bool\n\n        :param reply_to_message_id: If the messages are a reply, ID of the original message\n        :type  reply_to_message_id: int\n\n        Returns:\n\n        :return: On success, an array of the sent Messages is returned\n        :rtype:  Messages\n        \"\"\"\n        assert_type_or_raise(chat_id, (int, unicode_type), parameter_name=\"chat_id\")\n        from .api_types.sendable.input_media import InputMediaPhoto, InputMediaVideo\n\n        files = {}\n        new_media = []\n        assert_type_or_raise(media, list, parameter_name=\"media\")\n        for i, medium in enumerate(media):\n            assert_type_or_raise(medium, InputMediaPhoto, InputMediaVideo, parameter_name=\"media[{i}]\".format(i=i))\n            assert isinstance(medium, (InputMediaPhoto, InputMediaVideo))\n            new_medium, file = medium.get_request_data('pytgbot{i}'.format(i=i), full_data=True)\n            logger.debug('InputMedia {} found.'.format(new_medium))\n            new_media.append(new_medium)\n            if file:\n                files.update(file)\n            # end if\n        # end for\n        new_media = json.dumps(new_media)\n\n        assert_type_or_raise(disable_notification, None, bool, parameter_name=\"disable_notification\")\n\n        assert_type_or_raise(reply_to_message_id, None, int, parameter_name=\"reply_to_message_id\")\n\n        result = self.do(\n            \"sendMediaGroup\", chat_id=chat_id, media=new_media, files=files,\n            disable_notification=disable_notification, reply_to_message_id=reply_to_message_id,\n        )\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))    # no valid parsing so far\n            if not isinstance(result, list):\n                raise TgApiParseException(\"Could not parse result als list.\")  # See debug log for details!\n            # end if\n            from .api_types.receivable.updates import Message\n            return [Message.from_array(msg) for msg in result]  # parse them all as Message.\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nuse this method to send answers to an inline query. On success, True is returned. No more than 50 results per query are allowed. https://core.telegram.org/bots/api#answerinlinequery Parameters: :param inline_query_id: Unique identifier for the answered query :type inline_query_id: str|unicode :param results: A JSON-serialized array of results for the inline query :type results: list of pytgbot.api_types.sendable.inline.InlineQueryResult Optional keyword parameters: :param cache_time: The maximum amount of time in seconds that the result of the inline query may be cached on the server. Defaults to 300. :type cache_time: int :param is_personal: Pass True, if results may be cached on the server side only for the user that sent the query. By default, results may be returned to any user who sends the same query :type is_personal: bool :param next_offset: Pass the offset that a client should send in the next query with the same text to receive more results. Pass an empty string if there are no more results or if you don\u2018t support pagination. Offset length can\u2019t exceed 64 bytes. :type next_offset: str|unicode :param switch_pm_text: If passed, clients will display a button with specified text that switches the user to a private chat with the bot and sends the bot a start message with the parameter switch_pm_parameter :type switch_pm_text: str|unicode :param switch_pm_parameter: Deep-linking parameter for the /start message sent to the bot when user presses the switch button. 1-64 characters, only `A-Z`, `a-z`, `0-9`, `_` and `-` are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a \"Connect your YouTube account\" button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an oauth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities. :type switch_pm_parameter: str|unicode Returns: :return: On success, True is returned :rtype: bool", "response": "def answer_inline_query(self, inline_query_id, results, cache_time=None, is_personal=None, next_offset=None,\n                            switch_pm_text=None, switch_pm_parameter=None):\n        \"\"\"\n        Use this method to send answers to an inline query. On success, True is returned.\n        No more than 50 results per query are allowed.\n\n        https://core.telegram.org/bots/api#answerinlinequery\n\n\n        Parameters:\n\n        :param inline_query_id: Unique identifier for the answered query\n        :type  inline_query_id: str|unicode\n\n        :param results: A JSON-serialized array of results for the inline query\n        :type  results: list of pytgbot.api_types.sendable.inline.InlineQueryResult\n\n\n        Optional keyword parameters:\n\n        :param cache_time: The maximum amount of time in seconds that the result of the inline query may be cached on\n                             the server. Defaults to 300.\n        :type  cache_time: int\n\n        :param is_personal: Pass True, if results may be cached on the server side only for the user that sent the\n                              query. By default, results may be returned to any user who sends the same query\n        :type  is_personal: bool\n\n        :param next_offset: Pass the offset that a client should send in the next query with the same text to receive\n                            more results. Pass an empty string if there are no more results or if you don\u2018t support\n                            pagination. Offset length can\u2019t exceed 64 bytes.\n        :type  next_offset: str|unicode\n\n        :param switch_pm_text: If passed, clients will display a button with specified text that switches\n                               the user to a private chat with the bot and sends the bot a start message with the\n                               parameter switch_pm_parameter\n        :type  switch_pm_text: str|unicode\n\n        :param switch_pm_parameter: Deep-linking parameter for the /start message sent to the bot when user presses\n                                    the switch button. 1-64 characters, only `A-Z`, `a-z`, `0-9`, `_` and `-` are allowed.\n                                      Example:\n                                         An inline bot that sends YouTube videos can ask the user to connect the\n                                         bot to their YouTube account to adapt search results accordingly.\n                                         To do this, it displays a \"Connect your YouTube account\" button above the\n                                         results, or even before showing any.\n                                         The user presses the button, switches to a private chat with the bot and,\n                                         in doing so, passes a start parameter that instructs the bot to return an\n                                         oauth link.\n                                         Once done, the bot can offer a switch_inline button so that\n                                         the user can easily return to the chat where they wanted to use the bot's\n                                         inline capabilities.\n        :type  switch_pm_parameter: str|unicode\n\n        Returns:\n\n        :return: On success, True is returned\n        :rtype: bool\n        \"\"\"\n        assert_type_or_raise(inline_query_id, int, unicode_type, parameter_name=\"inline_query_id\")\n        if isinstance(inline_query_id, int):\n            inline_query_id = u(inline_query_id)\n        # end if\n        assert isinstance(inline_query_id, unicode_type)\n\n        assert_type_or_raise(results, list, tuple, InlineQueryResult, parameter_name=\"results\")\n\n        if isinstance(results, InlineQueryResult):\n            results = [results]\n        assert(isinstance(results, (list, tuple)))  # list of InlineQueryResult\n        result_objects = []\n        for result in results:\n            if not isinstance(result, InlineQueryResult):  # checks all elements of results\n                raise ValueError(\"Parameter results is not list of InlineQueryResult\")\n            # end if\n            result_objects.append(result.to_array())\n        # end for results\n\n        assert_type_or_raise(cache_time, None, int, parameter_name=\"cache_time\")\n\n        assert_type_or_raise(is_personal, None, bool, parameter_name=\"is_personal\")\n\n        assert_type_or_raise(next_offset, None, unicode_type, str, int, parameter_name=\"next_offset\")\n        if next_offset is not None:\n            assert(isinstance(next_offset, (str, unicode_type, int)))\n            next_offset = u(next_offset)\n        # end if\n\n        assert_type_or_raise(switch_pm_text, None, unicode_type, parameter_name=\"switch_pm_text\")\n\n        assert_type_or_raise(switch_pm_parameter, None, unicode_type, parameter_name=\"switch_pm_parameter\")\n\n        result = self.do(\n            \"answerInlineQuery\", inline_query_id=inline_query_id, results=json.dumps(result_objects),\n            cache_time=cache_time, is_personal=is_personal, next_offset=next_offset, switch_pm_text=switch_pm_text,\n            switch_pm_parameter=switch_pm_parameter\n        )\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_game_score(self, user_id, score, force=False, disable_edit_message=False, chat_id=None, message_id=None, inline_message_id=None):\n        assert_type_or_raise(user_id, int, parameter_name=\"user_id\")\n\n        assert_type_or_raise(score, int, parameter_name=\"score\")\n\n        assert_type_or_raise(force, None, bool, parameter_name=\"force\")\n\n        assert_type_or_raise(disable_edit_message, None, bool, parameter_name=\"disable_edit_message\")\n\n        assert_type_or_raise(chat_id, None, int, parameter_name=\"chat_id\")\n\n        assert_type_or_raise(message_id, None, int, parameter_name=\"message_id\")\n\n        assert_type_or_raise(inline_message_id, None, unicode_type, parameter_name=\"inline_message_id\")\n\n        result = self.do(\"setGameScore\", user_id=user_id, score=score, force=force, disable_edit_message=disable_edit_message, chat_id=chat_id, message_id=message_id, inline_message_id=inline_message_id)\n        if self.return_python_objects:\n            logger.debug(\"Trying to parse {data}\".format(data=repr(result)))\n            from pytgbot.api_types.receivable.updates import Message\n            try:\n                return Message.from_array(result)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as api_type Message\", exc_info=True)\n            # end try\n\n            try:\n                return from_array_list(bool, result, list_level=0, is_builtin=True)\n            except TgApiParseException:\n                logger.debug(\"Failed parsing as primitive bool\", exc_info=True)\n            # end try\n            # no valid parsing so far\n            raise TgApiParseException(\"Could not parse result.\")  # See debug log for details!\n        # end if return_python_objects\n        return result", "response": "Use this method to set the score of a user in a game message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _postprocess_request(self, r):\n        from DictObject import DictObject\n        import requests\n\n        assert isinstance(r, requests.Response)\n\n        try:\n            logger.debug(r.json())\n            res = DictObject.objectify(r.json())\n        except Exception as e:\n            raise TgApiResponseException('Parsing answer as json failed.', r, e)\n        # end if\n        res[\"response\"] = r  # TODO: does this failes on json lists? Does TG does that?\n        # TG should always return an dict, with at least a status or something.\n        if self.return_python_objects:\n            if res.ok is not True:\n                raise TgApiServerException(\n                    error_code=res.error_code if \"error_code\" in res else None,\n                    response=res.response if \"response\" in res else None,\n                    description=res.description if \"description\" in res else None,\n                    request=r.request\n                )\n            # end if not ok\n            if \"result\" not in res:\n                raise TgApiParseException('Key \"result\" is missing.')\n            # end if no result\n            return res.result\n        # end if return_python_objects\n        return res", "response": "This method converts the response from the server to either the response or a parsed response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _do_fileupload(self, file_param_name, value, _command=None, _file_is_optional=False, **kwargs):\n        from .api_types.sendable.files import InputFile\n        from luckydonaldUtils.encoding import unicode_type\n        from luckydonaldUtils.encoding import to_native as n\n\n        if value is None and _file_is_optional:\n            # Is None but set optional, so do nothing.\n            pass\n        elif isinstance(value, str):\n            kwargs[file_param_name] = str(value)\n        elif isinstance(value, unicode_type):\n            kwargs[file_param_name] = n(value)\n        elif isinstance(value, InputFile):\n            files = value.get_request_files(file_param_name)\n            if \"files\" in kwargs and kwargs[\"files\"]:\n                # already are some files there, merge them.\n                assert isinstance(kwargs[\"files\"], dict), \\\n                    'The files should be of type dict, but are of type {}.'.format(type(kwargs[\"files\"]))\n                for key in files.keys():\n                    assert key not in kwargs[\"files\"], '{key} would be overwritten!'\n                    kwargs[\"files\"][key] = files[key]\n                # end for\n            else:\n                # no files so far\n                kwargs[\"files\"] = files\n            # end if\n        else:\n            raise TgApiTypeError(\"Parameter {key} is not type (str, {text_type}, {input_file_type}), but type {type}\".format(\n                key=file_param_name, type=type(value), input_file_type=InputFile, text_type=unicode_type))\n        # end if\n        if not _command:\n            # command as camelCase  # \"voice_note\" -> \"sendVoiceNote\"  # https://stackoverflow.com/a/10984923/3423324\n            command = re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), \"send_\" + file_param_name)\n        else:\n            command = _command\n        # end def\n        return self.do(command, **kwargs)", "response": "This method is used to send a file to Telegram servers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nserializing this LabeledPrice to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this LabeledPrice to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(LabeledPrice, self).to_array()\n        array['label'] = u(self.label)  # py2: type unicode, py3: type str\n\n        array['amount'] = int(self.amount)  # type int\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['label'] = u(array.get('label'))\n        data['amount'] = int(array.get('amount'))\n        \n        instance = LabeledPrice(**data)\n        instance._raw = array\n        return instance", "response": "Deserialize a new LabeledPrice from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nserializes this ShippingOption to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this ShippingOption to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(ShippingOption, self).to_array()\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        array['prices'] = self._as_array(self.prices)  # type list of LabeledPrice\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.sendable.payments import LabeledPrice\n        \n\n        data = {}\n        data['id'] = u(array.get('id'))\n        data['title'] = u(array.get('title'))\n        data['prices'] = LabeledPrice.from_array_list(array.get('prices'), list_level=1)\n        \n        instance = ShippingOption(**data)\n        instance._raw = array\n        return instance", "response": "Deserialize a new ShippingOption from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _prepare_target(ts, tables, buffer_size):\n    for tablename in tables:\n        table = ts[tablename]\n        table[:] = []\n        if buffer_size is not None and table.is_attached():\n            table.write(append=False)", "response": "Prepare the target for processing."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nnormalize source rows and selectors.", "response": "def _prepare_source(selector, source):\n    \"\"\"Normalize source rows and selectors.\"\"\"\n    tablename, fields = get_data_specifier(selector)\n    if len(fields) != 1:\n        raise ItsdbError(\n            'Selector must specify exactly one data column: {}'\n            .format(selector)\n        )\n    if isinstance(source, TestSuite):\n        if not tablename:\n            tablename = source.relations.find(fields[0])[0]\n        source = source[tablename]\n    cols = list(source.fields.keys()) + fields\n    return source, cols"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _add_record(table, data, buffer_size):\n    fields = table.fields\n    # remove any keys that aren't relation fields\n    for invalid_key in set(data).difference([f.name for f in fields]):\n        del data[invalid_key]\n    table.append(Record.from_dict(fields, data))\n    # write if requested and possible\n    if buffer_size is not None and table.is_attached():\n        # for now there isn't a public method to get the number of new\n        # records, so use private members\n        if (len(table) - 1) - table._last_synced_index > buffer_size:\n            table.commit()", "response": "Prepare and append a Record into its Table ; flush to disk if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a tuple of table and column names for some [ incr tsdb() ] data specifier.", "response": "def get_data_specifier(string):\n    \"\"\"\n    Return a tuple (table, col) for some [incr tsdb()] data specifier.\n    For example::\n\n        item              -> ('item', None)\n        item:i-input      -> ('item', ['i-input'])\n        item:i-input@i-wf -> ('item', ['i-input', 'i-wf'])\n        :i-input          -> (None, ['i-input'])\n        (otherwise)       -> (None, None)\n    \"\"\"\n    match = data_specifier_re.match(string)\n    if match is None:\n        return (None, None)\n    table = match.group('table')\n    if table is not None:\n        table = table.strip()\n    cols = _split_cols(match.group('cols'))\n    return (table, cols)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decode_row(line, fields=None):\n    cols = line.rstrip('\\n').split(_field_delimiter)\n    cols = list(map(unescape, cols))\n    if fields is not None:\n        if len(cols) != len(fields):\n            raise ItsdbError(\n                'Wrong number of fields: {} != {}'\n                .format(len(cols), len(fields))\n            )\n        for i in range(len(cols)):\n            col = cols[i]\n            if col:\n                field = fields[i]\n                col = _cast_to_datatype(col, field)\n            cols[i] = col\n    return cols", "response": "Decode a raw line from a profile into a list of column values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nencoding a list of column values into a [ incr tsdb ) - encoded string.", "response": "def encode_row(fields):\n    \"\"\"\n    Encode a list of column values into a [incr tsdb()] profile line.\n\n    Encoding involves escaping special characters for each value, then\n    joining the values into a single string with the field delimiter\n    (`\"@\"` by default). It does not fill in default values (see\n    make_row()).\n\n    Args:\n        fields: a list of column values\n    Returns:\n        A [incr tsdb()]-encoded string\n    \"\"\"\n    # NOTE: str(f) only works for Python3\n    unicode_fields = [unicode(f) for f in fields]\n    escaped_fields = map(escape, unicode_fields)\n    return _field_delimiter.join(escaped_fields)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines if the table path should end in. gz or not and return it.", "response": "def _table_filename(tbl_filename):\n    \"\"\"\n    Determine if the table path should end in .gz or not and return it.\n\n    A .gz path is preferred only if it exists and is newer than any\n    regular text file path.\n\n    Raises:\n        :class:`delphin.exceptions.ItsdbError`: when neither the .gz\n            nor text file exist.\n    \"\"\"\n    tbl_filename = str(tbl_filename)  # convert any Path objects\n\n    txfn = _normalize_table_path(tbl_filename)\n    gzfn = txfn + '.gz'\n\n    if os.path.exists(txfn):\n        if (os.path.exists(gzfn) and\n                os.stat(gzfn).st_mtime > os.stat(txfn).st_mtime):\n            tbl_filename = gzfn\n        else:\n            tbl_filename = txfn\n    elif os.path.exists(gzfn):\n        tbl_filename = gzfn\n    else:\n        raise ItsdbError(\n            'Table does not exist at {}(.gz)'\n            .format(tbl_filename)\n        )\n\n    return tbl_filename"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _open_table(tbl_filename, encoding):\n    path = _table_filename(tbl_filename)\n    if path.endswith('.gz'):\n        # gzip.open() cannot use mode='rt' until Python2.7 support\n        # is gone; until then use TextIOWrapper\n        gzfile = GzipFile(path, mode='r')\n        gzfile.read1 = gzfile.read  # Python2 hack\n        with TextIOWrapper(gzfile, encoding=encoding) as f:\n            yield f\n    else:\n        with io.open(path, encoding=encoding) as f:\n            yield f", "response": "Open the compressed or text table file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencoding a mapping of column names to values into a [ incr tsdb ) - encoded string.", "response": "def make_row(row, fields):\n    \"\"\"\n    Encode a mapping of column name to values into a [incr tsdb()]\n    profile line. The *fields* parameter determines what columns are\n    used, and default values are provided if a column is missing from\n    the mapping.\n\n    Args:\n        row: a mapping of column names to values\n        fields: an iterable of :class:`Field` objects\n    Returns:\n        A [incr tsdb()]-encoded string\n    \"\"\"\n    if not hasattr(row, 'get'):\n        row = {f.name: col for f, col in zip(fields, row)}\n\n    row_fields = []\n    for f in fields:\n        val = row.get(f.name, None)\n        if val is None:\n            val = str(f.default_value())\n        row_fields.append(val)\n    return encode_row(row_fields)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef select_rows(cols, rows, mode='list', cast=True):\n    mode = mode.lower()\n    if mode == 'list':\n        modecast = lambda cols, data: data\n    elif mode == 'dict':\n        modecast = lambda cols, data: dict(zip(cols, data))\n    elif mode == 'row':\n        modecast = lambda cols, data: encode_row(data)\n    else:\n        raise ItsdbError('Invalid mode for select operation: {}\\n'\n                         '  Valid options include: list, dict, row'\n                         .format(mode))\n    for row in rows:\n        try:\n            data = [row.get(c, cast=cast) for c in cols]\n        except TypeError:\n            data = [row.get(c) for c in cols]\n        yield modecast(cols, data)", "response": "This function returns a generator that yields the selected data from rows."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nyielding triples of value left_rows right_rows where value left_rows and right_rows are lists of rows that share the same same MimeType column value for key.", "response": "def match_rows(rows1, rows2, key, sort_keys=True):\n    \"\"\"\n    Yield triples of `(value, left_rows, right_rows)` where\n    `left_rows` and `right_rows` are lists of rows that share the same\n    column value for *key*. This means that both *rows1* and *rows2*\n    must have a column with the same name *key*.\n\n    .. warning::\n\n       Both *rows1* and *rows2* will exist in memory for this\n       operation, so it is not recommended for very large tables on\n       low-memory systems.\n\n    Args:\n        rows1: a :class:`Table` or list of :class:`Record` objects\n        rows2: a :class:`Table` or list of :class:`Record` objects\n        key (str): the column name on which to match\n        sort_keys (bool): if `True`, yield matching rows sorted by the\n            matched key instead of the original order\n    \"\"\"\n    matched = OrderedDict()\n    for i, rows in enumerate([rows1, rows2]):\n        for row in rows:\n            val = row[key]\n            try:\n                data = matched[val]\n            except KeyError:\n                matched[val] = ([], [])\n                data = matched[val]\n            data[i].append(row)\n    vals = matched.keys()\n    if sort_keys:\n        vals = sorted(vals, key=safe_int)\n    for val in vals:\n        left, right = matched[val]\n        yield (val, left, right)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\njoin two tables and returns the resulting Table object.", "response": "def join(table1, table2, on=None, how='inner', name=None):\n    \"\"\"\n    Join two tables and return the resulting Table object.\n\n    Fields in the resulting table have their names prefixed with their\n    corresponding table name. For example, when joining `item` and\n    `parse` tables, the `i-input` field of the `item` table will be\n    named `item:i-input` in the resulting Table. Pivot fields (those\n    in *on*) are only stored once without the prefix.\n\n    Both inner and left joins are possible by setting the *how*\n    parameter to `inner` and `left`, respectively.\n\n    .. warning::\n\n       Both *table2* and the resulting joined table will exist in\n       memory for this operation, so it is not recommended for very\n       large tables on low-memory systems.\n\n    Args:\n        table1 (:class:`Table`): the left table to join\n        table2 (:class:`Table`): the right table to join\n        on (str): the shared key to use for joining; if `None`, find\n            shared keys using the schemata of the tables\n        how (str): the method used for joining (`\"inner\"` or `\"left\"`)\n        name (str): the name assigned to the resulting table\n    \"\"\"\n    if how not in ('inner', 'left'):\n        ItsdbError('Only \\'inner\\' and \\'left\\' join methods are allowed.')\n    # validate and normalize the pivot\n    on = _join_pivot(on, table1, table2)\n    # the fields of the joined table\n    fields = _RelationJoin(table1.fields, table2.fields, on=on)\n    # get key mappings to the right side (useful for inner and left joins)\n    get_key = lambda rec: tuple(rec.get(k) for k in on)\n    key_indices = set(table2.fields.index(k) for k in on)\n    right = defaultdict(list)\n    for rec in table2:\n        right[get_key(rec)].append([c for i, c in enumerate(rec)\n                                    if i not in key_indices])\n    # build joined table\n    rfill = [f.default_value() for f in table2.fields if f.name not in on]\n    joined = []\n    for lrec in table1:\n        k = get_key(lrec)\n        if how == 'left' or k in right:\n            joined.extend(lrec + rrec for rrec in right.get(k, [rfill]))\n\n    return Table(fields, joined)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the default value for a column.", "response": "def default_value(fieldname, datatype):\n    \"\"\"\n    Return the default value for a column.\n\n    If the column name (e.g. *i-wf*) is defined to have an idiosyncratic\n    value, that value is returned. Otherwise the default value for the\n    column's datatype is returned.\n\n    Args:\n        fieldname: the column name (e.g. `i-wf`)\n        datatype: the datatype of the column (e.g. `:integer`)\n    Returns:\n        The default value for the column.\n\n    .. deprecated:: v0.7.0\n    \"\"\"\n    if fieldname in tsdb_coded_attributes:\n        return str(tsdb_coded_attributes[fieldname])\n    else:\n        return _default_datatype_values.get(datatype, '')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_skeleton(path, relations, item_rows, gzip=False):\n    try:\n        os.makedirs(path)\n    except OSError:\n        raise ItsdbError('Path already exists: {}.'.format(path))\n\n    import shutil\n    shutil.copyfile(relations, os.path.join(path, _relations_filename))\n    prof = ItsdbProfile(path, index=False)\n    prof.write_table('item', item_rows, gzip=gzip)\n    return prof", "response": "Create a new profile skeleton from an existing relations file and a list of rows\n    for the item table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nyield rows matching all applicable filters.", "response": "def filter_rows(filters, rows):\n    \"\"\"\n    Yield rows matching all applicable filters.\n\n    Filter functions have binary arity (e.g. `filter(row, col)`) where\n    the first parameter is the dictionary of row data, and the second\n    parameter is the data at one particular column.\n\n    Args:\n        filters: a tuple of (cols, filter_func) where filter_func will\n            be tested (filter_func(row, col)) for each col in cols where\n            col exists in the row\n        rows: an iterable of rows to filter\n    Yields:\n        Rows matching all applicable filters\n\n    .. deprecated:: v0.7.0\n    \"\"\"\n    for row in rows:\n        if all(condition(row, row.get(col))\n               for (cols, condition) in filters\n               for col in cols\n               if col is None or col in row):\n            yield row"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef apply_rows(applicators, rows):\n    for row in rows:\n        for (cols, function) in applicators:\n            for col in (cols or []):\n                value = row.get(col, '')\n                row[col] = function(row, value)\n        yield row", "response": "Yield rows after applying the applicator functions to each column of the rows."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the default value of the field.", "response": "def default_value(self):\n        \"\"\"Get the default value of the field.\"\"\"\n        if self.name in tsdb_coded_attributes:\n            return tsdb_coded_attributes[self.name]\n        elif self.datatype == ':integer':\n            return -1\n        else:\n            return ''"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef keys(self):\n        keys = self._keys\n        if keys is None:\n            keys = tuple(self[i].name for i in self.key_indices)\n        return keys", "response": "Return the tuple of field names of key fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_file(cls, source):\n        if hasattr(source, 'read'):\n            relations = cls.from_string(source.read())\n        else:\n            with open(source) as f:\n                relations = cls.from_string(f.read())\n        return relations", "response": "Instantiate Relations from a relations file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_string(cls, s):\n        tables = []\n        seen = set()\n        current_table = None\n        lines = list(reversed(s.splitlines()))  # to pop() in right order\n        while lines:\n            line = lines.pop().strip()\n            table_m = re.match(r'^(?P<table>\\w.+):$', line)\n            field_m = re.match(r'\\s*(?P<name>\\S+)'\n                               r'(\\s+(?P<attrs>[^#]+))?'\n                               r'(\\s*#\\s*(?P<comment>.*)$)?',\n                               line)\n            if table_m is not None:\n                table_name = table_m.group('table')\n                if table_name in seen:\n                    raise ItsdbError(\n                        'Table {} already defined.'.format(table_name)\n                    )\n                current_table = (table_name, [])\n                tables.append(current_table)\n                seen.add(table_name)\n            elif field_m is not None and current_table is not None:\n                name = field_m.group('name')\n                attrs = field_m.group('attrs').split()\n                datatype = attrs.pop(0)\n                key = ':key' in attrs\n                partial = ':partial' in attrs\n                comment = field_m.group('comment')\n                current_table[1].append(\n                    Field(name, datatype, key, partial, comment)\n                )\n            elif line != '':\n                raise ItsdbError('Invalid line: ' + line)\n        return cls(tables)", "response": "Instantiate Relations from a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list of tables that define the field fieldname.", "response": "def find(self, fieldname):\n        \"\"\"\n        Return the list of tables that define the field *fieldname*.\n        \"\"\"\n        tablename, _, column = fieldname.rpartition(':')\n        if tablename and tablename in self._field_map[column]:\n            return tablename\n        else:\n            return self._field_map[fieldname]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef path(self, source, target):\n        visited = set(source.split('+'))  # split on + for joins\n        targets = set(target.split('+')) - visited\n        # ensure sources and targets exists\n        for tablename in visited.union(targets):\n            self[tablename]\n        # base case; nothing to do\n        if len(targets) == 0:\n            return []\n        paths = [[(tablename, None)] for tablename in visited]\n        while True:\n            newpaths = []\n            for path in paths:\n                laststep, pivot = path[-1]\n                if laststep in targets:\n                    return path[1:]\n                else:\n                    for key in self[laststep].keys():\n                        for step in set(self.find(key)) - visited:\n                            visited.add(step)\n                            newpaths.append(path + [(step, key)])\n            if newpaths:\n                paths = newpaths\n            else:\n                break\n\n        raise ItsdbError('no relation path found from {} to {}'\n                         .format(source, target))", "response": "Find the path of id fields connecting two tables."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a Record bound to a table.", "response": "def _make(cls, fields, iterable, table, rowid):\n        \"\"\"\n        Create a Record bound to a :class:`Table`.\n\n        This is a helper method for creating Records from rows of a\n        Table that is attached to a file. It is not meant to be called\n        directly. It specifies the row number and a weak reference to\n        the Table object so that when the Record is modified it is\n        kept in the Table's in-memory list (see Record.__setitem__()),\n        otherwise the changes would not be retained the next time the\n        record is requested from the Table. The use of a weak\n        reference to the Table is to avoid a circular reference and\n        thus allow it to be properly garbage collected.\n        \"\"\"\n        record = cls(fields, iterable)\n        record._tableref = weakref.ref(table)\n        record._rowid = rowid\n        return record"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a Record object from a dictionary of field names to column values.", "response": "def from_dict(cls, fields, mapping):\n        \"\"\"\n        Create a Record from a dictionary of field mappings.\n\n        The *fields* object is used to determine the column indices\n        of fields in the mapping.\n\n        Args:\n            fields: the Relation schema for the table of this record\n            mapping: a dictionary or other mapping from field names to\n                column values\n        Returns:\n            a :class:`Record` object\n        \"\"\"\n        iterable = [None] * len(fields)\n        for key, value in mapping.items():\n            try:\n                index = fields.index(key)\n            except KeyError:\n                raise ItsdbError('Invalid field name(s): ' + key)\n            iterable[index] = value\n        return cls(fields, iterable)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the value of the field with the given key.", "response": "def get(self, key, default=None, cast=True):\n        \"\"\"\n        Return the field data given by field name *key*.\n\n        Args:\n            key: the field name of the data to return\n            default: the value to return if *key* is not in the row\n        \"\"\"\n        tablename, _, key = key.rpartition(':')\n        if tablename and tablename not in self.fields.name.split('+'):\n            raise ItsdbError('column requested from wrong table: {}'\n                             .format(tablename))\n        try:\n            index = self.fields.index(key)\n            value = list.__getitem__(self, index)\n        except (KeyError, IndexError):\n            value = default\n        else:\n            if cast:\n                field = self.fields[index]\n                value = _cast_to_datatype(value, field)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write(self, records=None, path=None, fields=None, append=False,\n              gzip=None):\n        \"\"\"\n        Write the table to disk.\n\n        The basic usage has no arguments and writes the table's data\n        to the attached file. The parameters accommodate a variety of\n        use cases, such as using *fields* to refresh a table to a\n        new schema or *records* and *append* to incrementally build a\n        table.\n\n        Args:\n            records: an iterable of :class:`Record` objects to write;\n                if `None` the table's existing data is used\n            path: the destination file path; if `None` use the\n                path of the file attached to the table\n            fields (:class:`Relation`): table schema to use for\n                writing, otherwise use the current one\n            append: if `True`, append rather than overwrite\n            gzip: compress with gzip if non-empty\n        Examples:\n            >>> table.write()\n            >>> table.write(results, path='new/path/result')\n        \"\"\"\n        if path is None:\n            if not self.is_attached():\n                raise ItsdbError('no path given for detached table')\n            else:\n                path = self.path\n        path = _normalize_table_path(path)\n        dirpath, name = os.path.split(path)\n        if fields is None:\n            fields = self.fields\n        if records is None:\n            records = iter(self)\n        _write_table(\n            dirpath,\n            name,\n            records,\n            fields,\n            append=append,\n            gzip=gzip,\n            encoding=self.encoding)\n\n        if self.is_attached() and path == _normalize_table_path(self.path):\n            self.path = _table_filename(path)\n            self._sync_with_file()", "response": "Writes the table to disk."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncommitting changes to disk if attached.", "response": "def commit(self):\n        \"\"\"\n        Commit changes to disk if attached.\n\n        This method helps normalize the interface for detached and\n        attached tables and makes writing attached tables a bit more\n        efficient. For detached tables nothing is done, as there is no\n        notion of changes, but neither is an error raised (unlike with\n        :meth:`write`). For attached tables, if all changes are new\n        records, the changes are appended to the existing file, and\n        otherwise the whole file is rewritten.\n        \"\"\"\n        if not self.is_attached():\n            return\n        changes = self.list_changes()\n        if changes:\n            indices, records = zip(*changes)\n            if min(indices) > self._last_synced_index:\n                self.write(records, append=True)\n            else:\n                self.write(append=False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nattaching the table to the file at path.", "response": "def attach(self, path, encoding='utf-8'):\n        \"\"\"\n        Attach the Table to the file at *path*.\n\n        Attaching a table to a file means that only changed records\n        are stored in memory, which greatly reduces the memory\n        footprint of large profiles at some cost of\n        performance. Tables created from :meth:`Table.from_file()` or\n        from an attached :class:`TestSuite` are automatically\n        attached. Attaching a file does not immediately flush the\n        contents to disk; after attaching the table must be separately\n        written to commit the in-memory data.\n\n        A non-empty table will fail to attach to a non-empty file to\n        avoid data loss when merging the contents. In this case, you\n        may delete or clear the file, clear the table, or attach to\n        another file.\n\n        Args:\n            path: the path to the table file\n            encoding: the character encoding of the files in the testsuite\n        \"\"\"\n        if self.is_attached():\n            raise ItsdbError('already attached at {}'.format(self.path))\n\n        try:\n            path = _table_filename(path)\n        except ItsdbError:\n            # neither path nor path.gz exist; create new empty file\n            # (note: if the file were non-empty this would be destructive)\n            path = _normalize_table_path(path)\n            open(path, 'w').close()\n        else:\n            # path or path.gz exists; check if merging would be a problem\n            if os.stat(path).st_size > 0 and len(self._records) > 0:\n                raise ItsdbError(\n                    'cannot attach non-empty table to non-empty file')\n\n        self.path = path\n        self.encoding = encoding\n\n        # if _records is not empty then we're attaching to an empty file\n        if len(self._records) == 0:\n            self._sync_with_file()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetaches the table from a file.", "response": "def detach(self):\n        \"\"\"\n        Detach the table from a file.\n\n        Detaching a table reads all data from the file and places it\n        in memory. This is useful when constructing or significantly\n        manipulating table data, or when more speed is needed. Tables\n        created by the default constructor are detached.\n\n        When detaching, only unmodified records are loaded from the\n        file; any uncommited changes in the Table are left as-is.\n\n        .. warning::\n\n           Very large tables may consume all available RAM when\n           detached.  Expect the in-memory table to take up about\n           twice the space of an uncompressed table on disk, although\n           this may vary by system.\n        \"\"\"\n        if not self.is_attached():\n            raise ItsdbError('already detached')\n        records = self._records\n        for i, line in self._enum_lines():\n            if records[i] is None:\n                # check number of columns?\n                records[i] = tuple(decode_row(line))\n        self.path = None\n        self.encoding = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_changes(self):\n        if not self.is_attached():\n            raise ItsdbError('changes are not tracked for detached tables.')\n        return [(i, self[i]) for i, row in enumerate(self._records)\n                if row is not None]", "response": "Return a list of modified records. This is only applicable for attached tables."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _sync_with_file(self):\n        self._records = []\n        i = -1\n        for i, line in self._enum_lines():\n            self._records.append(None)\n        self._last_synced_index = i", "response": "Clear in - memory structures so table is synced with the file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _enum_lines(self):\n        with _open_table(self.path, self.encoding) as lines:\n            for i, line in enumerate(lines):\n                yield i, line", "response": "Enumerate lines from the attached file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _enum_attached_rows(self, indices):\n        records = self._records\n        i = 0\n        # first rows covered by the file\n        for i, line in self._enum_lines():\n            if i in indices:\n                row = records[i]\n                if row is None:\n                    row = decode_row(line)\n                yield (i, row)\n        # then any uncommitted rows\n        for j in range(i, len(records)):\n            if j in indices:\n                if records[j] is not None:\n                    yield (j, records[j])", "response": "Enumerate the on - disk and in - memory records."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding records from a slice index.", "response": "def _iterslice(self, slice):\n        \"\"\"Yield records from a slice index.\"\"\"\n        indices = range(*slice.indices(len(self._records)))\n        if self.is_attached():\n            rows = self._enum_attached_rows(indices)\n            if slice.step is not None and slice.step < 0:\n                rows = reversed(list(rows))\n        else:\n            rows = zip(indices, self._records[slice])\n\n        fields = self.fields\n        for i, row in rows:\n            yield Record._make(fields, row, self, i)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a single non - slice index.", "response": "def _getitem(self, index):\n        \"\"\"Get a single non-slice index.\"\"\"\n        row = self._records[index]\n        if row is not None:\n            pass\n        elif self.is_attached():\n            # need to handle negative indices manually\n            if index < 0:\n                index = len(self._records) + index\n            row = next((decode_row(line)\n                        for i, line in self._enum_lines()\n                        if i == index),\n                       None)\n            if row is None:\n                raise ItsdbError('could not retrieve row in attached table')\n        else:\n            raise ItsdbError('invalid row in detached table: {}'.format(index))\n\n        return Record._make(self.fields, row, self, index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding each record in records to the end of the table.", "response": "def extend(self, records):\n        \"\"\"\n        Add each record in *records* to the end of the table.\n\n        Args:\n            record: an iterable of :class:`Record` or other iterables\n                containing column values\n        \"\"\"\n        fields = self.fields\n        for record in records:\n            record = _cast_record_to_str_tuple(record, fields)\n            self._records.append(record)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nselecting columns from each row in the table.", "response": "def select(self, cols, mode='list'):\n        \"\"\"\n        Select columns from each row in the table.\n\n        See :func:`select_rows` for a description of how to use the\n        *mode* parameter.\n\n        Args:\n            cols: an iterable of Field (column) names\n            mode: how to return the data\n        \"\"\"\n        if isinstance(cols, stringtypes):\n            cols = _split_cols(cols)\n        if not cols:\n            cols = [f.name for f in self.fields]\n        return select_rows(cols, self, mode=mode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_filter(self, table, cols, condition):\n        if table is not None and table not in self.relations:\n            raise ItsdbError('Cannot add filter; table \"{}\" is not defined '\n                             'by the relations file.'\n                             .format(table))\n        # this is a hack, though perhaps well-motivated\n        if cols is None:\n            cols = [None]\n        self.filters[table].append((cols, condition))", "response": "Add a filter to the list of filters for the given table and columns."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an applicator to the internal list of related tables.", "response": "def add_applicator(self, table, cols, function):\n        \"\"\"\n        Add an applicator. When reading *table*, rows in *table* will be\n        modified by apply_rows().\n\n        Args:\n            table: The table to apply the function to.\n            cols: The columns in *table* to apply the function on.\n            function: The applicator function.\n        \"\"\"\n\n        if table not in self.relations:\n            raise ItsdbError('Cannot add applicator; table \"{}\" is not '\n                             'defined by the relations file.'\n                             .format(table))\n        if cols is None:\n            raise ItsdbError('Cannot add applicator; columns not specified.')\n        fields = set(f.name for f in self.relations[table])\n        for col in cols:\n            if col not in fields:\n                raise ItsdbError('Cannot add applicator; column \"{}\" not '\n                                 'defined by the relations file.'\n                                 .format(col))\n        self.applicators[table].append((cols, function))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nyielding the rows in the [ incr tsdb() *table. A row is a dictionary mapping column names to values.", "response": "def read_raw_table(self, table):\n        \"\"\"\n        Yield rows in the [incr tsdb()] *table*. A row is a dictionary\n        mapping column names to values. Data from a profile is decoded\n        by decode_row(). No filters or applicators are used.\n        \"\"\"\n        fields = self.table_relations(table) if self.cast else None\n        field_names = [f.name for f in self.table_relations(table)]\n        field_len = len(field_names)\n        table_path = os.path.join(self.root, table)\n        with _open_table(table_path, self.encoding) as tbl:\n            for line in tbl:\n                cols = decode_row(line, fields=fields)\n                if len(cols) != field_len:\n                    # should this throw an exception instead?\n                    logging.error('Number of stored fields ({}) '\n                                  'differ from the expected number({}); '\n                                  'fields may be misaligned!'\n                                  .format(len(cols), field_len))\n                row = OrderedDict(zip(field_names, cols))\n                yield row"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding rows in the [ incr tsdb () * table * that pass any defined filters and apply_rows to each row.", "response": "def read_table(self, table, key_filter=True):\n        \"\"\"\n        Yield rows in the [incr tsdb()] *table* that pass any defined\n        filters, and with values changed by any applicators. If no\n        filters or applicators are defined, the result is the same as\n        from ItsdbProfile.read_raw_table().\n        \"\"\"\n        filters = self.filters[None] + self.filters[table]\n        if key_filter:\n            for f in self.relations[table]:\n                key = f.name\n                if f.key and (self._index.get(key) is not None):\n                    ids = self._index[key]\n                    # Can't keep local variables (like ids) in the scope of\n                    # the lambda expression, so make it a default argument.\n                    # Source: http://stackoverflow.com/a/938493/1441112\n                    function = lambda r, x, ids=ids: x in ids\n                    filters.append(([key], function))\n        applicators = self.applicators[table]\n        rows = self.read_raw_table(table)\n        return filter_rows(filters, apply_rows(applicators, rows))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nyield rows from table.", "response": "def select(self, table, cols, mode='list', key_filter=True):\n        \"\"\"\n        Yield selected rows from *table*. This method just calls\n        select_rows() on the rows read from *table*.\n        \"\"\"\n        if cols is None:\n            cols = [c.name for c in self.relations[table]]\n        rows = self.read_table(table, key_filter=key_filter)\n        for row in select_rows(cols, rows, mode=mode):\n            yield row"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef join(self, table1, table2, key_filter=True):\n        get_keys = lambda t: (f.name for f in self.relations[t] if f.key)\n        keys = set(get_keys(table1)).intersection(get_keys(table2))\n        if not keys:\n            raise ItsdbError(\n                'Cannot join tables \"{}\" and \"{}\"; no shared key exists.'\n                .format(table1, table2)\n            )\n        key = keys.pop()\n        # this join method stores the whole of table2 in memory, but it is\n        # MUCH faster than a nested loop method. Most profiles will fit in\n        # memory anyway, so it's a decent tradeoff\n        table2_data = defaultdict(list)\n        for row in self.read_table(table2, key_filter=key_filter):\n            table2_data[row[key]].append(row)\n        for row1 in self.read_table(table1, key_filter=key_filter):\n            for row2 in table2_data.get(row1[key], []):\n                joinedrow = OrderedDict(\n                    [('{}:{}'.format(table1, k), v)\n                     for k, v in row1.items()] +\n                    [('{}:{}'.format(table2, k), v)\n                     for k, v in row2.items()]\n                )\n                yield joinedrow", "response": "Yields rows from a table built by joining tables table1 and table2."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_table(self, table, rows, append=False, gzip=False):\n        _write_table(self.root,\n                     table,\n                     rows,\n                     self.table_relations(table),\n                     append=append,\n                     gzip=gzip,\n                     encoding=self.encoding)", "response": "Encode and write out a table to the profile directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_profile(self, profile_directory, relations_filename=None,\n                      key_filter=True,\n                      append=False, gzip=None):\n        \"\"\"\n        Write all tables (as specified by the relations) to a profile.\n\n        Args:\n            profile_directory: The directory of the output profile\n            relations_filename: If given, read and use the relations\n                at this path instead of the current profile's\n                relations\n            key_filter: If True, filter the rows by keys in the index\n            append: If `True`, append profile data to existing tables\n                in the output profile directory\n            gzip: If `True`, compress tables using `gzip`. Table\n                filenames will have `.gz` appended. If `False`, only\n                write out text files. If `None`, use whatever the\n                original file was.\n        \"\"\"\n        if relations_filename:\n            src_rels = os.path.abspath(relations_filename)\n            relations = get_relations(relations_filename)\n        else:\n            src_rels = os.path.abspath(os.path.join(self.root,\n                                                    _relations_filename))\n            relations = self.relations\n\n        tgt_rels = os.path.abspath(os.path.join(profile_directory,\n                                                _relations_filename))\n        if not (os.path.isfile(tgt_rels) and src_rels == tgt_rels):\n            with open(tgt_rels, 'w') as rel_fh:\n                print(open(src_rels).read(), file=rel_fh)\n\n        tables = self._tables\n        if tables is not None:\n            tables = set(tables)\n        for table, fields in relations.items():\n            if tables is not None and table not in tables:\n                continue\n            try:\n                fn = _table_filename(os.path.join(self.root, table))\n                _gzip = gzip if gzip is not None else fn.endswith('.gz')\n                rows = list(self.read_table(table, key_filter=key_filter))\n                _write_table(\n                    profile_directory, table, rows, fields,\n                    append=append, gzip=_gzip, encoding=self.encoding\n                )\n            except ItsdbError:\n                logging.warning(\n                    'Could not write \"{}\"; table doesn\\'t exist.'.format(table)\n                )\n                continue\n\n        self._cleanup(gzip=gzip)", "response": "Write all tables in the current profile to a profile."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef exists(self, table=None):\n        if not os.path.isdir(self.root):\n            return False\n        if not os.path.isfile(os.path.join(self.root, _relations_filename)):\n            return False\n        if table is not None:\n            try:\n                _table_filename(os.path.join(self.root, table))\n            except ItsdbError:\n                return False\n        return True", "response": "Returns True if the profile or a table exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the size in bytes of the profile or table.", "response": "def size(self, table=None):\n        \"\"\"\n        Return the size, in bytes, of the profile or *table*.\n\n        If *table* is `None`, this function returns the size of the\n        whole profile (i.e. the sum of the table sizes). Otherwise, it\n        returns the size of *table*.\n\n        Note: if the file is gzipped, it returns the compressed size.\n        \"\"\"\n        size = 0\n        if table is None:\n            for table in self.relations:\n                size += self.size(table)\n        else:\n            try:\n                fn = _table_filename(os.path.join(self.root, table))\n                size += os.stat(fn).st_size\n            except ItsdbError:\n                pass\n        return size"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrequesting a parse of input on server and return the response.", "response": "def parse(input, server=default_erg_server, params=None, headers=None):\n    \"\"\"\n    Request a parse of *input* on *server* and return the response.\n\n    Args:\n        input (str): sentence to be parsed\n        server (str): the url for the server (the default LOGON server\n            is used by default)\n        params (dict): a dictionary of request parameters\n        headers (dict): a dictionary of additional request headers\n    Returns:\n        A ParseResponse containing the results, if the request was\n        successful.\n    Raises:\n        requests.HTTPError: if the status code was not 200\n    \"\"\"\n    return next(parse_from_iterable([input], server, params, headers), None)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_from_iterable(\n        inputs,\n        server=default_erg_server,\n        params=None,\n        headers=None):\n    \"\"\"\n    Request parses for all *inputs*.\n\n    Args:\n        inputs (iterable): sentences to parse\n        server (str): the url for the server (the default LOGON server\n            is used by default)\n        params (dict): a dictionary of request parameters\n        headers (dict): a dictionary of additional request headers\n    Yields:\n        ParseResponse objects for each successful response.\n    Raises:\n        requests.HTTPError: for the first response with a status code\n            that is not 200\n    \"\"\"\n    client = DelphinRestClient(server)\n    for input in inputs:\n        yield client.parse(input, params=params, headers=headers)", "response": "This function parses the input sentences into a list of ParseResponse objects."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(self, sentence, params=None, headers=None):\n        if params is None:\n            params = {}\n        params['input'] = sentence\n\n        hdrs = {'Accept': 'application/json'}\n        if headers is not None:\n            hdrs.update(headers)\n\n        url = urljoin(self.server, 'parse')\n        r = requests.get(url, params=params, headers=hdrs)\n        if r.status_code == 200:\n            return _RestResponse(r.json())\n        else:\n            r.raise_for_status()", "response": "Request a parse of a sentence and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _calculate_crc_ccitt(data):\n    global CRC_CCITT_TABLE\n    if not CRC_CCITT_TABLE:\n        crc_ccitt_table = []\n        for i in range(0, 256):\n            crc = 0\n            c = i << 8\n\n            for j in range(0, 8):\n                if (crc ^ c) & 0x8000:\n                    crc = c_ushort(crc << 1).value ^ 0x1021\n                else:\n                    crc = c_ushort(crc << 1).value\n\n                c = c_ushort(c << 1).value\n\n            crc_ccitt_table.append(crc)\n            CRC_CCITT_TABLE = crc_ccitt_table\n\n    is_string = _is_string(data)\n    crc_value = 0x0000  # XModem version\n\n    for c in data:\n        d = ord(c) if is_string else c\n        tmp = ((crc_value >> 8) & 0xff) ^ d\n        crc_value = ((crc_value << 8) & 0xff00) ^ CRC_CCITT_TABLE[tmp]\n\n    return crc_value", "response": "Calculate the CRC value of a single object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_zpl_line(self, compression=3, **kwargs):\n        if compression == 3:\n            data = base64.b64encode(zlib.compress(self.data.bytes))\n            data = ':Z64:%s:%s' % (data.decode('ascii'), self._calc_crc(data))\n        elif compression == 1:\n            data = base64.b64encode(self.data.bytes)\n            data = ':B64:%s:%s' % (data.decode('ascii'), self._calc_crc(data))\n        else:\n            lines = []\n            last_unique_line = None\n\n            for line in self.data.hex_rows:\n                if line.endswith('00'):\n                    line = line.rstrip('0')\n                    if len(line) % 2:\n                        line += '0'\n                    line += ','\n                if line == last_unique_line:\n                    line = ':'\n                else:\n                    last_unique_line = line\n                lines.append(line)\n\n            data = '\\n'.join(lines)\n            to_compress = set(RE_UNCOMPRESSED.findall(data))\n            to_compress = sorted(to_compress, reverse=True)\n            for uncompressed in to_compress:\n                uncompressed = uncompressed[0]\n                repeat = len(uncompressed)\n                compressed = ''\n                while repeat >= 400:\n                    compressed += 'z'\n                    repeat -= 400\n                if repeat >= 20:\n                    value = repeat // 20\n                    repeat -= value * 20\n                    compressed += chr(value + 70).lower()\n                if repeat > 0:\n                    compressed += chr(repeat + 70)\n                data = data.replace(uncompressed, compressed + uncompressed[0])\n\n            data = data.replace('\\n', '')\n\n        zpl = '~DGR:%s.GRF,%s,%s,%s' % (\n            self.filename,\n            self.data.filesize,\n            self.data.width // 8,\n            data\n        )\n\n        return zpl", "response": "Convert the data to a ZPL line."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the ZPL representation of the current stateful version of the image.", "response": "def to_zpl(\n        self, quantity=1, pause_and_cut=0, override_pause=False,\n        print_mode='C', print_orientation='N', media_tracking='Y', **kwargs\n    ):\n        \"\"\"\n        The most basic ZPL to print the GRF. Since ZPL printers are stateful\n        this may not work and you may need to build your own.\n        \"\"\"\n        zpl = [\n            self.to_zpl_line(**kwargs),  # Download image to printer\n            '^XA',  # Start Label Format\n            '^MM%s,Y' % print_mode,\n            '^PO%s' % print_orientation,\n            '^MN%s' % media_tracking,\n            '^FO0,0',  # Field Origin to 0,0\n            '^XGR:%s.GRF,1,1' % self.filename,  # Draw image\n            '^FS',  # Field Separator\n            '^PQ%s,%s,0,%s' % (\n                int(quantity),  # Print Quantity\n                int(pause_and_cut),  # Pause and cut every N labels\n                'Y' if override_pause else 'N'  # Don't pause between cuts\n            ),\n            '^XZ',  # End Label Format\n            '^IDR:%s.GRF' % self.filename  # Delete image from printer\n        ]\n        return ''.join(zpl)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_image(cls, image, filename):\n\n        source = Image.open(BytesIO(image))\n        source = source.convert('1')\n        width = int(math.ceil(source.size[0] / 8.0))\n\n        data = []\n        for line in _chunked(list(source.getdata()), source.size[0]):\n            row = ''.join(['0' if p else '1' for p in line])\n            row = row.ljust(width * 8, '0')\n            data.append(row)\n        data = GRFData(width, bin=''.join(data))\n\n        return cls(filename, data)", "response": "Create a GRF from an image."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_pdf(\n        cls, pdf, filename, width=288, height=432, dpi=203, font_path=None,\n        center_of_pixel=False, use_bindings=False\n    ):\n        \"\"\"\n        Filename is 1-8 alphanumeric characters to identify the GRF in ZPL.\n\n        Dimensions and DPI are for a typical 4\"x6\" shipping label.\n        E.g. 432 points / 72 points in an inch / 203 dpi = 6 inches\n\n        Using center of pixel will improve barcode quality but may decrease\n        the quality of some text.\n\n        use_bindings=False:\n            - Uses subprocess.Popen\n            - Forks so there is a memory spike\n            - Easier to setup - only needs the gs binary\n\n        use_bindings=True:\n            - Uses python-ghostscript\n            - Doesn't fork so should use less memory\n            - python-ghostscript is a bit buggy\n            - May be harder to setup - even if you have updated the gs binary\n              there may stil be old libgs* files on your system\n        \"\"\"\n\n        # Most arguments below are based on what CUPS uses\n        setpagedevice = [\n            '/.HWMargins[0.000000 0.000000 0.000000 0.000000]',\n            '/Margins[0 0]'\n        ]\n\n        cmd = [\n            'gs',\n            '-dQUIET',\n            '-dPARANOIDSAFER',\n            '-dNOPAUSE',\n            '-dBATCH',\n            '-dNOINTERPOLATE',\n            '-sDEVICE=pngmono',\n            '-dAdvanceDistance=1000',\n            '-r%s' % int(dpi),\n            '-dDEVICEWIDTHPOINTS=%s' % int(width),\n            '-dDEVICEHEIGHTPOINTS=%s' % int(height),\n            '-dFIXEDMEDIA',\n            '-dPDFFitPage',\n            '-c',\n            '<<%s>>setpagedevice' % ' '.join(setpagedevice)\n        ]\n\n        if center_of_pixel:\n            cmd += ['0 .setfilladjust']\n\n        if font_path and os.path.exists(font_path):\n            cmd += ['-I' + font_path]\n\n        if use_bindings:\n            import ghostscript\n            # python-ghostscript doesn't like reading/writing from\n            # stdin/stdout so we need to use temp files\n            with tempfile.NamedTemporaryFile() as in_file, \\\n                 tempfile.NamedTemporaryFile() as out_file:\n\n                in_file.write(pdf)\n                in_file.flush()\n\n                # Ghostscript seems to be sensitive to argument order\n                cmd[13:13] += [\n                    '-sOutputFile=%s' % out_file.name\n                ]\n                cmd += [\n                    '-f', in_file.name\n                ]\n\n                try:\n                    ghostscript.Ghostscript(*[c.encode('ascii') for c in cmd])\n                except Exception as e:\n                    raise GRFException(e)\n\n                pngs = out_file.read()\n        else:\n            from subprocess import PIPE, Popen\n            # Ghostscript seems to be sensitive to argument order\n            cmd[13:13] += [\n                '-sstdout=%stderr',\n                '-sOutputFile=%stdout',\n            ]\n            cmd += [\n                '-f', '-'\n            ]\n            p = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)\n            pngs, stderr = p.communicate(pdf)\n            if stderr:\n                raise GRFException(stderr)\n\n        # This is what PIL uses to identify PNGs\n        png_start = b'\\211PNG\\r\\n\\032\\n'\n\n        grfs = []\n        for png in pngs.split(png_start)[1:]:\n            grfs.append(cls.from_image(png_start + png, filename))\n        return grfs", "response": "Create a new instance of the base class from a PDF file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _optimise_barcodes(\n        self, data, min_bar_height=20, min_bar_count=100, max_gap_size=30,\n        min_percent_white=0.2, max_percent_white=0.8, **kwargs\n    ):\n        \"\"\"\n        min_bar_height    = Minimum height of black bars in px. Set this too\n                            low and it might pick up text and data matrices,\n                            too high and it might pick up borders, tables, etc.\n        min_bar_count     = Minimum number of parallel black bars before a\n                            pattern is considered a potential barcode.\n        max_gap_size      = Biggest white gap in px allowed between black bars.\n                            This is only important if you have multiple\n                            barcodes next to each other.\n        min_percent_white = Minimum percentage of white bars between black\n                            bars. This helps to ignore solid rectangles.\n        max_percent_white = Maximum percentage of white bars between black\n                            bars. This helps to ignore solid rectangles.\n        \"\"\"\n\n        re_bars = re.compile(r'1{%s,}' % min_bar_height)\n\n        bars = {}\n        for i, line in enumerate(data):\n            for match in re_bars.finditer(line):\n                try:\n                    bars[match.span()].append(i)\n                except KeyError:\n                    bars[match.span()] = [i]\n\n        grouped_bars = []\n        for span, seen_at in bars.items():\n            group = []\n            for coords in seen_at:\n                if group and coords - group[-1] > max_gap_size:\n                    grouped_bars.append((span, group))\n                    group = []\n                group.append(coords)\n            grouped_bars.append((span, group))\n\n        suspected_barcodes = []\n        for span, seen_at in grouped_bars:\n            if len(seen_at) < min_bar_count:\n                continue\n            pc_white = len(seen_at) / float(seen_at[-1] - seen_at[0])\n            if pc_white >= min_percent_white and pc_white <= max_percent_white:\n                suspected_barcodes.append((span, seen_at))\n\n        for span, seen_at in suspected_barcodes:\n            barcode = []\n            for line in data[seen_at[0]:seen_at[-1]+1]:\n                barcode.append(line[span[0]])\n            barcode = ''.join(barcode)\n\n            # Do the actual optimisation\n            barcode = self._optimise_barcode(barcode)\n\n            barcode = list(barcode)\n            barcode.reverse()\n            width = span[1] - span[0]\n            for i in range(seen_at[0], seen_at[-1]+1):\n                line = data[i]\n                line = (\n                    line[:span[0]] + (barcode.pop() * width) + line[span[1]:]\n                )\n                data[i] = line\n\n        return data", "response": "Optimise barcodes in the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n\n        data = {}\n        data['id'] = u(array.get('id'))\n        data['title'] = u(array.get('title'))\n        data['prices'] = LabeledPrice.from_array_list(array.get('prices'), list_level=1)\n\n        instance = ShippingOption(**data)\n        instance._raw = array\n        return instance", "response": "Deserialize a new ShippingOption from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a string from camel case to underscore.", "response": "def convert_to_underscore(name):\n    \"\"\" \"someFunctionWhatever\" -> \"some_function_whatever\" \"\"\"\n    s1 = _first_cap_re.sub(r'\\1_\\2', name)\n    return _all_cap_re.sub(r'\\1_\\2', s1).lower()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef func(command, description, link, params_string, returns=\"On success, the sent Message is returned.\", return_type=\"Message\"):\n    description_with_tabs = \"\\t\\t\" + description.strip().replace(\"\\n\", \"\\n\\t\\t\")\n    param_list_args = []\n    param_list_kwargs = []\n    args = []\n    args2 = []\n    kwargs = []\n    kwargs2 = []\n    asserts = []\n    str_args = \"\"\n    str_kwargs = \"\"\n    param_strings = params_string.split(\"\\n\")\n    for param in param_strings:\n        assert_commands, assert_comments, param_name, param_type, table, non_buildin_type, param_name_input = parse_param_types(param)\n        param_required = table[2].strip()\n        param_needed = None\n        if param_required == \"Yes\":\n            param_needed = True\n        elif param_required == \"Optional\":\n            param_needed = False\n        param_description = table[3].strip()\n        if param_needed:\n            param_list_args.append(Param(param_name, param_type,param_needed, param_description))\n            args.append(param_name)\n            args2.append(\"{param_name}={param_name}\".format(param_name=param_name))\n            str_args += '\\t\\t:param {key}: {descr}\\n\\t\\t:type  {key}: {type}\\n\\n'.format(key=param_name, descr=param_description, type=param_type)\n            if assert_commands:\n                asserts.append(\"assert({var} is not None)\".format(var=param_name))\n                asserts.append(\"assert({ass})\".format(ass=\" or \".join(assert_commands)) + ((\"  # {comment}\".format(comment=\", \".join(assert_comments))) if assert_comments else \"\"))\n        else:\n            param_list_kwargs.append(Param(param_name, param_type,param_needed, param_description))\n            kwargs.append(\"{param_name}=None\".format(param_name=param_name))\n            kwargs2.append(\"{param_name}={param_name}\".format(param_name=param_name))\n            str_kwargs += '\\t\\t:keyword {key}: {descr}\\n\\t\\t:type    {key}: {type}\\n\\n'.format(key=param_name, descr=param_description, type=param_type)\n            if assert_commands:\n                asserts.append(\"assert({var} is None or {ass})\".format(var=param_name, ass=\" or \".join(assert_commands)) + ((\"  # {comment}\".format(comment=\", \".join(assert_comments))) if assert_comments else \"\"))\n    args.extend(kwargs)\n    args2.extend(kwargs2)\n    asserts_string = \"\\n\\t\\t\" + \"\\n\\t\\t\".join(asserts)\n    text = \"\"\n    if len(str_args)>0:\n        text += '\\n\\t\\tParameters:\\n\\n'\n        text += str_args\n    if len(str_kwargs)>0:\n        text += '\\n\\t\\tOptional keyword parameters:\\n\\n'\n        text += str_kwargs\n    do_args = ['\"%s\"' % command]\n    do_args.extend(args2)\n    result = '\\tdef {funcname}(self, {params}):\\n\\t\\t\"\"\"\\n{description_with_tabs}\\n\\n\\t\\t{link}\\n\\n' \\\n           '{paramshit}\\n' \\\n           '\\t\\tReturns:\\n\\n\\t\\t:return: {returns}\\n\\t\\t:rtype:  {return_type}\\n\\t\\t\"\"\"{asserts_with_tabs}\\n\\t\\treturn self.do({do_args})\\n\\t# end def {funcname}'.format(\n        funcname=convert_to_underscore(command),\n        params=\", \".join(args), description_with_tabs=description_with_tabs, link=link,\n        returns=returns, return_type=return_type, command=command, do_args=\", \".join(do_args),\n        asserts_with_tabs=asserts_string,\n        paramshit = text\n    )\n    result = result.replace(\"\\t\", \"    \")\n    return result", "response": "A function that returns a single message."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlives template for pycharm: y = clazz(clazz=\"$clazz$\", parent_clazz=\"%parent$\", description=\"$desc$\", link=\"$lnk$\", params_string=\"$first_param$\")", "response": "def clazz(clazz, parent_clazz, description, link, params_string, init_super_args=None):\n    \"\"\"\n    Live template for pycharm:\n\n    y = clazz(clazz=\"$clazz$\", parent_clazz=\"%parent$\", description=\"$desc$\", link=\"$lnk$\", params_string=\"$first_param$\")\n    \"\"\"\n    init_description_w_tabs  = description.strip().replace(\"\\n\", \"\\n\\t\\t\")\n    clazz_description_w_tabs = description.strip().replace(\"\\n\", \"\\n\\t\")\n    imports = [[], []]\n    args = []\n    args2 = []\n    kwargs = []\n    kwargs2 = []\n    asserts = []\n    str_args = \"\"\n    str_kwargs = \"\"\n    to_array1 = []\n    to_array2 = []\n    from_array1 = []\n    from_array2 = []\n    param_strings = params_string.split(\"\\n\")\n    for param in param_strings:\n        assert_commands, assert_comments, param_name, param_type, table, non_buildin_type, param_name_input = parse_param_types(param)\n        param_description = table[2].strip()\n        param_needed = not param_description.startswith(\"Optional.\")\n        asserts.append(\"\")\n        if param_needed:\n            args.append(param_name)\n            str_args += '\\n\\n\\t\\t:param {key}: {descr}\\n\\t\\t:type  {key}: {type}'.format(key=param_name, descr=param_description, type=get_type_path(param_type))\n            if assert_commands:\n                asserts.append(\"assert({var} is not None)\".format(var=param_name))\n                asserts.append(\"assert({ass})\".format(ass=\" or \".join(assert_commands)) + ((\"  # {comment}\".format(comment=\", \".join(assert_comments))) if assert_comments else \"\"))\n            if non_buildin_type:\n                to_array1.append('array[\"{var}\"] = self.{var}.to_array()'.format(var=param_name))\n                from_array1.append(\"data['{var}'] = {type}.from_array(array.get('{array_key}'))\".format(var=param_name, array_key=param_name_input, type=non_buildin_type))\n            else:\n                to_array1.append('array[\"{var}\"] = self.{var}'.format(var=param_name))\n                from_array2.append(\"data['{var}'] = array.get('{array_key}')  # type {type}\".format(var=param_name, array_key=param_name_input, type=non_buildin_type))\n            # end if non_buildin_type\n        else:\n            kwargs.append(\"{param_name}=None\".format(param_name=param_name))\n            str_kwargs += '\\n\\n\\t\\t:keyword {key}: {descr}\\n\\t\\t:type    {key}: {type}'.format(key=param_name, descr=param_description, type=param_type)\n            if assert_commands:\n                asserts.append(\"assert({var} is None or {ass})\".format(var=param_name, ass=\" or \".join(assert_commands)) + ((\"  # {comment}\".format(comment=\", \".join(assert_comments))) if assert_comments else \"\"))\n            to_array2.append('if self.{var} is not None:'.format(var=param_name))\n            if non_buildin_type:\n                to_array2.append('\\tarray[\"{var}\"] = self.{var}.to_array()'.format(var=param_name))\n                from_array2.append(\"data['{var}'] = {type}.from_array(array.get('{array_key}'))\".format(var=param_name, array_key=param_name_input, type=non_buildin_type))\n            else:\n                to_array2.append('\\tarray[\"{var}\"] = self.{var}'.format(var=param_name))\n                from_array2.append(\"data['{var}'] = array.get('{array_key}')  # type {type}\".format(var=param_name, array_key=param_name_input, type=non_buildin_type))\n        # end if non_buildin_type\n        asserts.append(\"self.{param_name} = {param_name}\".format(param_name=param_name))\n    param_description = \"\"\n    if len(str_args)>0:\n        param_description += '\\n\\t\\tParameters:'\n        param_description += str_args\n    if len(str_kwargs)>0:\n        param_description += '\\n\\n\\n\\t\\tOptional keyword parameters:'\n        param_description += str_kwargs\n    args.extend(kwargs)\n    to_array = [\"array = super({clazz}, self).to_array()\".format(clazz=clazz)]\n    to_array.extend(to_array1)\n    to_array.extend(to_array2)\n    from_array = [\"data = super({clazz}).from_array(array)\".format(clazz=clazz)]\n    from_array.extend(from_array1)\n    from_array.extend(from_array2)\n    from_array.append(\"return {clazz}(**data)\".format(clazz=clazz))\n    result = 'class {clazz}({parent_clazz}):\\n' \\\n             '\\t\"\"\"\\n' \\\n             '\\t{clazz_description_w_tabs}\\n' \\\n             '\\n' \\\n             '\\t{link}\\n' \\\n             '\\t\"\"\"\\n' \\\n             '\\tdef __init__(self, {params}):\\n' \\\n             '\\t\\t\"\"\"\\n' \\\n             '\\t\\t{init_description_w_tabs}\\n' \\\n             '\\n' \\\n             '\\t\\t{link}\\n' \\\n             '\\n' \\\n             '{param_description}\\n' \\\n             '\\t\\t\"\"\"\\n' \\\n             '\\t\\tsuper({clazz}, self).__init__({init_super_args})\\n' \\\n             '\\t\\t{asserts_with_tabs}\\n' \\\n             '\\t# end def __init__\\n' \\\n             '\\n' \\\n             '\\tdef to_array(self):\\n' \\\n             '\\t\\t{to_array_with_tabs}\\n' \\\n             '\\t\\treturn array\\n' \\\n             '\\t# end def to_array\\n' \\\n             '\\n' \\\n             '\\t@staticmethod\\n' \\\n             '\\tdef from_array(array):\\n' \\\n             '\\t\\tif array is None:\\n' \\\n             '\\t\\t\\treturn None\\n' \\\n             '\\t\\t# end if\\n' \\\n             '\\t\\t{from_array_with_tabs}\\n' \\\n             '\\t# end def from_array\\n' \\\n             '# end class {clazz}\\n'.format(\n        clazz=clazz, parent_clazz=parent_clazz, params=\", \".join(args), param_description = param_description,\n        clazz_description_w_tabs=clazz_description_w_tabs, init_description_w_tabs=init_description_w_tabs, link=link,\n        asserts_with_tabs=\"\\n\\t\\t\".join(asserts), to_array_with_tabs=\"\\n\\t\\t\".join(to_array),\n        from_array_with_tabs=\"\\n\\t\\t\".join(from_array),\n        init_super_args=(\", \".join(init_super_args) if init_super_args else \"\")\n    )\n    result = result.replace(\"\\t\", \"    \")\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nserializing this User to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this User to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(User, self).to_array()\n        array['id'] = int(self.id)  # type int\n        array['is_bot'] = bool(self.is_bot)  # type bool\n        array['first_name'] = u(self.first_name)  # py2: type unicode, py3: type str\n\n        if self.last_name is not None:\n            array['last_name'] = u(self.last_name)  # py2: type unicode, py3: type str\n\n        if self.username is not None:\n            array['username'] = u(self.username)  # py2: type unicode, py3: type str\n\n        if self.language_code is not None:\n            array['language_code'] = u(self.language_code)  # py2: type unicode, py3: type str\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['id'] = int(array.get('id'))\n        data['is_bot'] = bool(array.get('is_bot'))\n        data['first_name'] = u(array.get('first_name'))\n        data['last_name'] = u(array.get('last_name')) if array.get('last_name') is not None else None\n        data['username'] = u(array.get('username')) if array.get('username') is not None else None\n        data['language_code'] = u(array.get('language_code')) if array.get('language_code') is not None else None\n        data['_raw'] = array\n        return User(**data)", "response": "Deserialize a new User from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserialize this Chat to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this Chat to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(Chat, self).to_array()\n        array['id'] = int(self.id)  # type int\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        if self.title is not None:\n            array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        if self.username is not None:\n            array['username'] = u(self.username)  # py2: type unicode, py3: type str\n\n        if self.first_name is not None:\n            array['first_name'] = u(self.first_name)  # py2: type unicode, py3: type str\n\n        if self.last_name is not None:\n            array['last_name'] = u(self.last_name)  # py2: type unicode, py3: type str\n\n        if self.all_members_are_administrators is not None:\n            array['all_members_are_administrators'] = bool(self.all_members_are_administrators)  # type bool\n        if self.photo is not None:\n            array['photo'] = self.photo.to_array()  # type ChatPhoto\n\n        if self.description is not None:\n            array['description'] = u(self.description)  # py2: type unicode, py3: type str\n\n        if self.invite_link is not None:\n            array['invite_link'] = u(self.invite_link)  # py2: type unicode, py3: type str\n\n        if self.pinned_message is not None:\n            array['pinned_message'] = self.pinned_message.to_array()  # type Message\n\n        if self.sticker_set_name is not None:\n            array['sticker_set_name'] = u(self.sticker_set_name)  # py2: type unicode, py3: type str\n\n        if self.can_set_sticker_set is not None:\n            array['can_set_sticker_set'] = bool(self.can_set_sticker_set)  # type bool\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.media import ChatPhoto\n        from pytgbot.api_types.receivable.updates import Message\n        \n\n        data = {}\n        data['id'] = int(array.get('id'))\n        data['type'] = u(array.get('type'))\n        data['title'] = u(array.get('title')) if array.get('title') is not None else None\n        data['username'] = u(array.get('username')) if array.get('username') is not None else None\n        data['first_name'] = u(array.get('first_name')) if array.get('first_name') is not None else None\n        data['last_name'] = u(array.get('last_name')) if array.get('last_name') is not None else None\n        data['all_members_are_administrators'] = bool(array.get('all_members_are_administrators')) if array.get('all_members_are_administrators') is not None else None\n        data['photo'] = ChatPhoto.from_array(array.get('photo')) if array.get('photo') is not None else None\n        data['description'] = u(array.get('description')) if array.get('description') is not None else None\n        data['invite_link'] = u(array.get('invite_link')) if array.get('invite_link') is not None else None\n        data['pinned_message'] = Message.from_array(array.get('pinned_message')) if array.get('pinned_message') is not None else None\n        data['sticker_set_name'] = u(array.get('sticker_set_name')) if array.get('sticker_set_name') is not None else None\n        data['can_set_sticker_set'] = bool(array.get('can_set_sticker_set')) if array.get('can_set_sticker_set') is not None else None\n        data['_raw'] = array\n        return Chat(**data)", "response": "Deserialize a new Chat from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_array(self):\n        array = super(ChatMember, self).to_array()\n        array['user'] = self.user.to_array()  # type User\n\n        array['status'] = u(self.status)  # py2: type unicode, py3: type str\n\n        if self.until_date is not None:\n            array['until_date'] = int(self.until_date)  # type int\n        if self.can_be_edited is not None:\n            array['can_be_edited'] = bool(self.can_be_edited)  # type bool\n        if self.can_change_info is not None:\n            array['can_change_info'] = bool(self.can_change_info)  # type bool\n        if self.can_post_messages is not None:\n            array['can_post_messages'] = bool(self.can_post_messages)  # type bool\n        if self.can_edit_messages is not None:\n            array['can_edit_messages'] = bool(self.can_edit_messages)  # type bool\n        if self.can_delete_messages is not None:\n            array['can_delete_messages'] = bool(self.can_delete_messages)  # type bool\n        if self.can_invite_users is not None:\n            array['can_invite_users'] = bool(self.can_invite_users)  # type bool\n        if self.can_restrict_members is not None:\n            array['can_restrict_members'] = bool(self.can_restrict_members)  # type bool\n        if self.can_pin_messages is not None:\n            array['can_pin_messages'] = bool(self.can_pin_messages)  # type bool\n        if self.can_promote_members is not None:\n            array['can_promote_members'] = bool(self.can_promote_members)  # type bool\n        if self.can_send_messages is not None:\n            array['can_send_messages'] = bool(self.can_send_messages)  # type bool\n        if self.can_send_media_messages is not None:\n            array['can_send_media_messages'] = bool(self.can_send_media_messages)  # type bool\n        if self.can_send_other_messages is not None:\n            array['can_send_other_messages'] = bool(self.can_send_other_messages)  # type bool\n        if self.can_add_web_page_previews is not None:\n            array['can_add_web_page_previews'] = bool(self.can_add_web_page_previews)  # type bool\n        return array", "response": "Serializes this ChatMember to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loads(s, single=False):\n    corpus = etree.fromstring(s)\n    if single:\n        ds = _deserialize_mrs(next(corpus))\n    else:\n        ds = (_deserialize_mrs(mrs_elem) for mrs_elem in corpus)\n    return ds", "response": "Deserialize MRX string representations\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(InlineQueryResultArticle, self).to_array()\n        # 'type' and 'id' given by superclass\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n        array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n        if self.url is not None:\n            array['url'] = u(self.url)  # py2: type unicode, py3: type str\n        if self.hide_url is not None:\n            array['hide_url'] = bool(self.hide_url)  # type bool\n        if self.description is not None:\n            array['description'] = u(self.description)  # py2: type unicode, py3: type str\n        if self.thumb_url is not None:\n            array['thumb_url'] = u(self.thumb_url)  # py2: type unicode, py3: type str\n        if self.thumb_width is not None:\n            array['thumb_width'] = int(self.thumb_width)  # type int\n        if self.thumb_height is not None:\n            array['thumb_height'] = int(self.thumb_height)  # type int\n        return array", "response": "Serializes this InlineQueryResultArticle to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_array(self):\n        array = super(InlineQueryResultGif, self).to_array()\n        # 'type' and 'id' given by superclass\n        array['gif_url'] = u(self.gif_url)  # py2: type unicode, py3: type str\n        array['thumb_url'] = u(self.thumb_url)  # py2: type unicode, py3: type str\n        if self.gif_width is not None:\n            array['gif_width'] = int(self.gif_width)  # type int\n        if self.gif_height is not None:\n            array['gif_height'] = int(self.gif_height)  # type int\n        if self.gif_duration is not None:\n            array['gif_duration'] = int(self.gif_duration)  # type int\n        if self.title is not None:\n            array['title'] = u(self.title)  # py2: type unicode, py3: type str\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n        return array", "response": "Serializes this InlineQueryResultGif to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_array(self):\n        array = super(InlineQueryResultAudio, self).to_array()\n        # 'type' and 'id' given by superclass\n        array['audio_url'] = u(self.audio_url)  # py2: type unicode, py3: type str\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n        if self.performer is not None:\n            array['performer'] = u(self.performer)  # py2: type unicode, py3: type str\n        if self.audio_duration is not None:\n            array['audio_duration'] = int(self.audio_duration)  # type int\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n        return array", "response": "Serializes this InlineQueryResultAudio to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nserializes this InlineQueryResultLocation to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineQueryResultLocation to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineQueryResultLocation, self).to_array()\n        # 'type' and 'id' given by superclass\n        array['latitude'] = float(self.latitude)  # type float\n        array['longitude'] = float(self.longitude)  # type float\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n        if self.live_period is not None:\n            array['live_period'] = int(self.live_period)  # type int\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n        if self.thumb_url is not None:\n            array['thumb_url'] = u(self.thumb_url)  # py2: type unicode, py3: type str\n        if self.thumb_width is not None:\n            array['thumb_width'] = int(self.thumb_width)  # type int\n        if self.thumb_height is not None:\n            array['thumb_height'] = int(self.thumb_height)  # type int\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nserializing this InlineQueryResultContact to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineQueryResultContact to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineQueryResultContact, self).to_array()\n        # 'type' and 'id' given by superclass\n        array['phone_number'] = u(self.phone_number)  # py2: type unicode, py3: type str\n        array['first_name'] = u(self.first_name)  # py2: type unicode, py3: type str\n        if self.last_name is not None:\n            array['last_name'] = u(self.last_name)  # py2: type unicode, py3: type str\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n        if self.thumb_url is not None:\n            array['thumb_url'] = u(self.thumb_url)  # py2: type unicode, py3: type str\n        if self.thumb_width is not None:\n            array['thumb_width'] = int(self.thumb_width)  # type int\n        if self.thumb_height is not None:\n            array['thumb_height'] = int(self.thumb_height)  # type int\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nserialize this InlineQueryResultGame to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineQueryResultGame to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineQueryResultGame, self).to_array()\n        # 'type' and 'id' given by superclass\n        array['game_short_name'] = u(self.game_short_name)  # py2: type unicode, py3: type str\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_array(self):\n        array = super(InlineQueryResultCachedGif, self).to_array()\n        # 'type' and 'id' given by superclass\n        array['gif_file_id'] = u(self.gif_file_id)  # py2: type unicode, py3: type str\n        if self.title is not None:\n            array['title'] = u(self.title)  # py2: type unicode, py3: type str\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n        return array", "response": "Serializes this InlineQueryResultCachedGif to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(InlineQueryResultCachedDocument, self).to_array()\n        # 'type' and 'id' given by superclass\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n        array['document_file_id'] = u(self.document_file_id)  # py2: type unicode, py3: type str\n        if self.description is not None:\n            array['description'] = u(self.description)  # py2: type unicode, py3: type str\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n        return array", "response": "Serializes this InlineQueryResultCachedDocument to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_array(self):\n        array = super(InlineQueryResultCachedVoice, self).to_array()\n        # 'type' and 'id' given by superclass\n        array['voice_file_id'] = u(self.voice_file_id)  # py2: type unicode, py3: type str\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n        return array", "response": "Serializes this InlineQueryResultCachedVoice to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nserializing this InputTextMessageContent to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InputTextMessageContent to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InputTextMessageContent, self).to_array()\n        array['message_text'] = u(self.message_text)  # py2: type unicode, py3: type str\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n        if self.disable_web_page_preview is not None:\n            array['disable_web_page_preview'] = bool(self.disable_web_page_preview)  # type bool\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nserializes this InputLocationMessageContent to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InputLocationMessageContent to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InputLocationMessageContent, self).to_array()\n        array['latitude'] = float(self.latitude)  # type float\n        array['longitude'] = float(self.longitude)  # type float\n        if self.live_period is not None:\n            array['live_period'] = int(self.live_period)  # type int\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['latitude'] = float(array.get('latitude'))\n        data['longitude'] = float(array.get('longitude'))\n        data['live_period'] = int(array.get('live_period')) if array.get('live_period') is not None else None\n\n        instance = InputLocationMessageContent(**data)\n        instance._raw = array\n        return instance", "response": "Deserialize a new InputLocationMessageContent from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserializes this InputVenueMessageContent to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InputVenueMessageContent to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InputVenueMessageContent, self).to_array()\n        array['latitude'] = float(self.latitude)  # type float\n        array['longitude'] = float(self.longitude)  # type float\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n        array['address'] = u(self.address)  # py2: type unicode, py3: type str\n        if self.foursquare_id is not None:\n            array['foursquare_id'] = u(self.foursquare_id)  # py2: type unicode, py3: type str\n        if self.foursquare_type is not None:\n            array['foursquare_type'] = u(self.foursquare_type)  # py2: type unicode, py3: type str\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_array(self):\n        array = super(InputContactMessageContent, self).to_array()\n        array['phone_number'] = u(self.phone_number)  # py2: type unicode, py3: type str\n        array['first_name'] = u(self.first_name)  # py2: type unicode, py3: type str\n        if self.last_name is not None:\n            array['last_name'] = u(self.last_name)  # py2: type unicode, py3: type str\n        if self.vcard is not None:\n            array['vcard'] = u(self.vcard)  # py2: type unicode, py3: type str\n        return array", "response": "Serializes this InputContactMessageContent to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a new object of the specified class.", "response": "def clazz(clazz, parent_clazz, description, link, params_string, init_super_args=None):\n    \"\"\"\n    Live template for pycharm:\n\n    y = clazz(clazz=\"$clazz$\", parent_clazz=\"%parent$\", description=\"$description$\", link=\"$lnk$\", params_string=\"$first_param$\")\n    \"\"\"\n    variables_needed = []\n    variables_optional = []\n    imports = set()\n    for param in params_string.split(\"\\n\"):\n        variable = parse_param_types(param)\n        # any variable.types has always_is_value => lenght must be 1.\n        assert(not any([type_.always_is_value is not None for type_ in variable.types]) or len(variable.types) == 1)\n        if variable.optional:\n            variables_optional.append(variable)\n        else:\n            variables_needed.append(variable)\n        # end if\n        imports.update(variable.all_imports)\n    # end for\n    imports = list(imports)\n    imports.sort()\n    if isinstance(parent_clazz, str):\n        parent_clazz = to_type(parent_clazz, \"parent class\")\n    assert isinstance(parent_clazz, Type)\n\n    clazz_object = Clazz(imports=imports,\n        clazz=clazz, parent_clazz=parent_clazz, link=link, description=description,\n        parameters=variables_needed, keywords=variables_optional\n    )\n    return clazz_object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef func(command, description, link, params_string, returns=\"On success, the sent Message is returned.\", return_type=\"Message\"):\n    variables_needed = []\n    variables_optional = []\n    imports = set()\n    if params_string:  # WHITELISTED_FUNCS have no params\n        for param in params_string.split(\"\\n\"):\n            variable = parse_param_types(param)\n            # any variable.types has always_is_value => lenght must be 1.\n            assert (not any([type_.always_is_value is not None for type_ in variable.types]) or len(variable.types) == 1)\n            if variable.optional:\n                variables_optional.append(variable)\n            else:\n                variables_needed.append(variable)\n            # end if\n            imports.update(variable.all_imports)\n        # end for\n    # end if\n    imports = list(imports)\n    imports.sort()\n    returns = Variable(types=as_types(return_type, variable_name=\"return type\"), description=returns)\n    func_object = Function(\n        imports=imports, api_name=command, link=link, description=description, returns=returns,\n        parameters=variables_needed, keywords=variables_optional\n    )\n    return func_object", "response": "Function to create a function object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_type(type_string, variable_name) -> Type:\n    # type_string = type_string.strip()\n    # remove \"list of \" and set .is_list accordingly.\n    # is_list, type_string = can_strip_prefix(type_string, \"list of \")\n    # var_type = Type(string=type_string, is_list=is_list)\n\n    var_type = Type(type_string)\n    # remove \"list of \" and set .is_list accordingly.\n    is_list = True\n    while is_list:\n        is_list, var_type.string = can_strip_prefix(var_type.string, \"list of \")\n        if is_list:\n            var_type.is_list += 1\n        # end if\n    # end for\n    if var_type.string == \"True\":\n        var_type.string = \"bool\"\n        var_type.always_is_value = \"True\"\n    # end if\n    if var_type.string in [\"int\", \"bool\", \"float\", \"object\", \"None\", \"str\"]:\n        var_type.is_builtin = True\n    elif var_type.string == \"unicode_type\":\n        var_type.string = \"unicode_type\"\n        var_type.is_builtin = False\n        var_type.import_path = \"luckydonaldUtils.encoding\"\n        var_type.description = \"py2: unicode, py3: str\"\n    elif var_type.string in CLASS_TYPE_PATHS:\n        var_type.import_path = CLASS_TYPE_PATHS[var_type.string][CLASS_TYPE_PATHS__IMPORT].rstrip(\".\")\n        var_type.is_builtin = False\n    else:\n        logger.warn(\n            \"Added unrecognized type in param <{var}>: {type!r}\".format(var=variable_name, type=var_type.string))\n    # end if\n    return var_type", "response": "Converts a type string to a new type object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if the given text starts with the given prefix False otherwise.", "response": "def can_strip_prefix(text:str, prefix:str) -> (bool, str):\n    \"\"\"\n    If the given text starts with the given prefix, True and the text without that prefix is returned.\n    Else False and the original text is returned.\n\n    Note: the text always is stripped, before returning.\n\n    :param text:\n    :param prefix:\n    :return: (bool, str)  :class:`bool` whether he text started with given prefix, :class:`str` the text without prefix\n    \"\"\"\n    if text.startswith(prefix):\n        return True, text[len(prefix):].strip()\n    return False, text.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the class name of the class.", "response": "def class_name(self) -> str:\n        \"\"\"\n        Makes the fist letter big, keep the rest of the camelCaseApiName.\n        \"\"\"\n        if not self.api_name:  # empty string\n            return self.api_name\n        # end if\n        return self.api_name[0].upper() + self.api_name[1:]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the class name of the TeleFlask message.", "response": "def class_name_teleflask_message(self) -> str:\n        \"\"\"\n        If it starts with `Send` remove that.\n        \"\"\"\n        # strip leading \"Send\"\n        name = self.class_name  # \"sendPhoto\" -> \"SendPhoto\"\n        name = name[4:] if name.startswith('Send') else name  # \"SendPhoto\" -> \"Photo\"\n        name = name + \"Message\"  # \"Photo\" -> \"PhotoMessage\"\n\n        # e.g. \"MessageMessage\" will be replaced as \"TextMessage\"\n        # b/c \"sendMessage\" -> \"SendMessage\" -> \"Message\" -> \"MessageMessage\"  ==> \"TextMessage\"\n        if name in MESSAGE_CLASS_OVERRIDES:\n            return MESSAGE_CLASS_OVERRIDES[name]\n        # end if\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef full(self):\n        if self.path:\n            if self.name:\n                return self.path + \".\" + self.name\n            else:\n                return self.path\n            # end if\n        else:\n            if self.name:\n                return self.name\n            else:\n                return \"\"", "response": "Returns the full path of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_array_list(required_type, result, list_level, is_builtin):\n    logger.debug(\"Trying parsing as {type}, list_level={list_level}, is_builtin={is_builtin}\".format(\n        type=required_type.__name__, list_level=list_level, is_builtin=is_builtin\n    ))\n    if list_level > 0:\n        assert isinstance(result, (list, tuple))\n        return [from_array_list(required_type, obj, list_level-1, is_builtin) for obj in result]\n    # end if\n    if is_builtin:\n        if isinstance(result, required_type):\n            logger.debug(\"Already is correct type.\")\n            return required_type(result)\n        elif isinstance(required_type, unicode_type):  # handle str, so emojis work for py2.\n            return u(result)\n        else:\n            import ast\n            logger.warn(\"Trying parsing with ast.literal_eval()...\")\n            return ast.literal_eval(str(result))  # raises ValueError if it could not parse\n        # end if\n    else:\n        return required_type.from_array(result)", "response": "Parses the result of a list of objects into a new object of type required_type."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a dict or list of objects to a json - like representation of a variable supporting types with a. to_array function.", "response": "def as_array(obj):\n    \"\"\"\n    Creates an json-like representation of a variable, supporting types with a `.to_array()` function.\n\n    :rtype: dict|list|str|int|float|bool|None\n    \"\"\"\n    if hasattr(obj, \"to_array\"):\n        return obj.to_array()\n    elif isinstance(obj, (list, tuple)):\n        return [as_array(x) for x in obj]\n    elif isinstance(obj, dict):\n        return {key:as_array(obj[key]) for key in obj.keys()}\n    else:\n        _json_dumps(obj)  # raises error if is wrong json\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_array_list(cls, result, list_level):\n        return from_array_list(cls, result, list_level, is_builtin=False)", "response": "Tries to parse the result as type given in required_type while traversing into lists as often as specified in list_level."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do(self, command, files=None, use_long_polling=False, request_timeout=None, **query):\n        url, params = self._prepare_request(command, query)\n        return {\n            \"url\": url, \"params\": params, \"files\": files, \"stream\": use_long_polling,\n            \"verify\": True,  # No self signed certificates. Telegram should be trustworthy anyway...\n            \"timeout\": request_timeout\n        }", "response": "Send a request to the API."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_array(self):\n        array = super(Update, self).to_array()\n        array['update_id'] = int(self.update_id)  # type int\n        if self.message is not None:\n            array['message'] = self.message.to_array()  # type Message\n        if self.edited_message is not None:\n            array['edited_message'] = self.edited_message.to_array()  # type Message\n        if self.channel_post is not None:\n            array['channel_post'] = self.channel_post.to_array()  # type Message\n        if self.edited_channel_post is not None:\n            array['edited_channel_post'] = self.edited_channel_post.to_array()  # type Message\n        if self.inline_query is not None:\n            array['inline_query'] = self.inline_query.to_array()  # type InlineQuery\n        if self.chosen_inline_result is not None:\n            array['chosen_inline_result'] = self.chosen_inline_result.to_array()  # type ChosenInlineResult\n        if self.callback_query is not None:\n            array['callback_query'] = self.callback_query.to_array()  # type CallbackQuery\n        if self.shipping_query is not None:\n            array['shipping_query'] = self.shipping_query.to_array()  # type ShippingQuery\n        if self.pre_checkout_query is not None:\n            array['pre_checkout_query'] = self.pre_checkout_query.to_array()  # type PreCheckoutQuery\n        return array", "response": "Serializes this Update to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nserializes this WebhookInfo to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this WebhookInfo to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(WebhookInfo, self).to_array()\n        array['url'] = u(self.url)  # py2: type unicode, py3: type str\n        array['has_custom_certificate'] = bool(self.has_custom_certificate)  # type bool\n        array['pending_update_count'] = int(self.pending_update_count)  # type int\n        if self.last_error_date is not None:\n            array['last_error_date'] = int(self.last_error_date)  # type int\n        if self.last_error_message is not None:\n            array['last_error_message'] = u(self.last_error_message)  # py2: type unicode, py3: type str\n        if self.max_connections is not None:\n            array['max_connections'] = int(self.max_connections)  # type int\n        if self.allowed_updates is not None:\n            array['allowed_updates'] = self._as_array(self.allowed_updates)  # type list of str\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_array(self):\n        array = super(Message, self).to_array()\n        array['message_id'] = int(self.message_id)  # type int\n        array['date'] = int(self.date)  # type int\n        array['chat'] = self.chat.to_array()  # type Chat\n        if self.from_peer is not None:\n            array['from'] = self.from_peer.to_array()  # type User\n        if self.forward_from is not None:\n            array['forward_from'] = self.forward_from.to_array()  # type User\n        if self.forward_from_chat is not None:\n            array['forward_from_chat'] = self.forward_from_chat.to_array()  # type Chat\n        if self.forward_from_message_id is not None:\n            array['forward_from_message_id'] = int(self.forward_from_message_id)  # type int\n        if self.forward_signature is not None:\n            array['forward_signature'] = u(self.forward_signature)  # py2: type unicode, py3: type str\n        if self.forward_date is not None:\n            array['forward_date'] = int(self.forward_date)  # type int\n        if self.reply_to_message is not None:\n            array['reply_to_message'] = self.reply_to_message.to_array()  # type Message\n        if self.edit_date is not None:\n            array['edit_date'] = int(self.edit_date)  # type int\n        if self.media_group_id is not None:\n            array['media_group_id'] = u(self.media_group_id)  # py2: type unicode, py3: type str\n        if self.author_signature is not None:\n            array['author_signature'] = u(self.author_signature)  # py2: type unicode, py3: type str\n        if self.text is not None:\n            array['text'] = u(self.text)  # py2: type unicode, py3: type str\n        if self.entities is not None:\n            array['entities'] = self._as_array(self.entities)  # type list of MessageEntity\n        if self.caption_entities is not None:\n            array['caption_entities'] = self._as_array(self.caption_entities)  # type list of MessageEntity\n        if self.audio is not None:\n            array['audio'] = self.audio.to_array()  # type Audio\n        if self.document is not None:\n            array['document'] = self.document.to_array()  # type Document\n        if self.animation is not None:\n            array['animation'] = self.animation.to_array()  # type Animation\n        if self.game is not None:\n            array['game'] = self.game.to_array()  # type Game\n        if self.photo is not None:\n            array['photo'] = self._as_array(self.photo)  # type list of PhotoSize\n        if self.sticker is not None:\n            array['sticker'] = self.sticker.to_array()  # type Sticker\n        if self.video is not None:\n            array['video'] = self.video.to_array()  # type Video\n        if self.voice is not None:\n            array['voice'] = self.voice.to_array()  # type Voice\n        if self.video_note is not None:\n            array['video_note'] = self.video_note.to_array()  # type VideoNote\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n        if self.contact is not None:\n            array['contact'] = self.contact.to_array()  # type Contact\n        if self.location is not None:\n            array['location'] = self.location.to_array()  # type Location\n        if self.venue is not None:\n            array['venue'] = self.venue.to_array()  # type Venue\n        if self.new_chat_members is not None:\n            array['new_chat_members'] = self._as_array(self.new_chat_members)  # type list of User\n        if self.left_chat_member is not None:\n            array['left_chat_member'] = self.left_chat_member.to_array()  # type User\n        if self.new_chat_title is not None:\n            array['new_chat_title'] = u(self.new_chat_title)  # py2: type unicode, py3: type str\n        if self.new_chat_photo is not None:\n            array['new_chat_photo'] = self._as_array(self.new_chat_photo)  # type list of PhotoSize\n        if self.delete_chat_photo is not None:\n            array['delete_chat_photo'] = bool(self.delete_chat_photo)  # type bool\n        if self.group_chat_created is not None:\n            array['group_chat_created'] = bool(self.group_chat_created)  # type bool\n        if self.supergroup_chat_created is not None:\n            array['supergroup_chat_created'] = bool(self.supergroup_chat_created)  # type bool\n        if self.channel_chat_created is not None:\n            array['channel_chat_created'] = bool(self.channel_chat_created)  # type bool\n        if self.migrate_to_chat_id is not None:\n            array['migrate_to_chat_id'] = int(self.migrate_to_chat_id)  # type int\n        if self.migrate_from_chat_id is not None:\n            array['migrate_from_chat_id'] = int(self.migrate_from_chat_id)  # type int\n        if self.pinned_message is not None:\n            array['pinned_message'] = self.pinned_message.to_array()  # type Message\n        if self.invoice is not None:\n            array['invoice'] = self.invoice.to_array()  # type Invoice\n        if self.successful_payment is not None:\n            array['successful_payment'] = self.successful_payment.to_array()  # type SuccessfulPayment\n        if self.connected_website is not None:\n            array['connected_website'] = u(self.connected_website)  # py2: type unicode, py3: type str\n        if self.passport_data is not None:\n            array['passport_data'] = self.passport_data.to_array()  # type PassportData\n        return array", "response": "Serializes this Message to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        from ..receivable.peer import User, Chat\n        from ..receivable.media import Animation, Audio, Contact, Document, Game, Location, MessageEntity, PhotoSize\n        from ..receivable.media import Sticker, Venue, Video, VideoNote, Voice\n        from ..receivable.payments import Invoice, SuccessfulPayment\n        from ..receivable.passport import PassportData\n\n        data = {}\n        data['message_id'] = int(array.get('message_id'))\n        data['date'] = int(array.get('date'))\n        data['chat'] = Chat.from_array(array.get('chat'))\n        data['from_peer'] = User.from_array(array.get('from')) if array.get('from') is not None else None\n        data['forward_from'] = User.from_array(array.get('forward_from')) if array.get('forward_from') is not None else None\n        data['forward_from_chat'] = Chat.from_array(array.get('forward_from_chat')) if array.get('forward_from_chat') is not None else None\n        data['forward_from_message_id'] = int(array.get('forward_from_message_id')) if array.get('forward_from_message_id') is not None else None\n        data['forward_signature'] = u(array.get('forward_signature')) if array.get('forward_signature') is not None else None\n        data['forward_date'] = int(array.get('forward_date')) if array.get('forward_date') is not None else None\n        data['reply_to_message'] = Message.from_array(array.get('reply_to_message')) if array.get('reply_to_message') is not None else None\n        data['edit_date'] = int(array.get('edit_date')) if array.get('edit_date') is not None else None\n        data['media_group_id'] = u(array.get('media_group_id')) if array.get('media_group_id') is not None else None\n        data['author_signature'] = u(array.get('author_signature')) if array.get('author_signature') is not None else None\n        data['text'] = u(array.get('text')) if array.get('text') is not None else None\n        data['entities'] = MessageEntity.from_array_list(array.get('entities'), list_level=1) if array.get('entities') is not None else None\n        data['caption_entities'] = MessageEntity.from_array_list(array.get('caption_entities'), list_level=1) if array.get('caption_entities') is not None else None\n        data['audio'] = Audio.from_array(array.get('audio')) if array.get('audio') is not None else None\n        data['document'] = Document.from_array(array.get('document')) if array.get('document') is not None else None\n        data['animation'] = Animation.from_array(array.get('animation')) if array.get('animation') is not None else None\n        data['game'] = Game.from_array(array.get('game')) if array.get('game') is not None else None\n        data['photo'] = PhotoSize.from_array_list(array.get('photo'), list_level=1) if array.get('photo') is not None else None\n        data['sticker'] = Sticker.from_array(array.get('sticker')) if array.get('sticker') is not None else None\n        data['video'] = Video.from_array(array.get('video')) if array.get('video') is not None else None\n        data['voice'] = Voice.from_array(array.get('voice')) if array.get('voice') is not None else None\n        data['video_note'] = VideoNote.from_array(array.get('video_note')) if array.get('video_note') is not None else None\n        data['caption'] = u(array.get('caption')) if array.get('caption') is not None else None\n        data['contact'] = Contact.from_array(array.get('contact')) if array.get('contact') is not None else None\n        data['location'] = Location.from_array(array.get('location')) if array.get('location') is not None else None\n        data['venue'] = Venue.from_array(array.get('venue')) if array.get('venue') is not None else None\n        data['new_chat_members'] = User.from_array_list(array.get('new_chat_members'), list_level=1) if array.get('new_chat_members') is not None else None\n        data['left_chat_member'] = User.from_array(array.get('left_chat_member')) if array.get('left_chat_member') is not None else None\n        data['new_chat_title'] = u(array.get('new_chat_title')) if array.get('new_chat_title') is not None else None\n        data['new_chat_photo'] = PhotoSize.from_array_list(array.get('new_chat_photo'), list_level=1) if array.get('new_chat_photo') is not None else None\n        data['delete_chat_photo'] = bool(array.get('delete_chat_photo')) if array.get('delete_chat_photo') is not None else None\n        data['group_chat_created'] = bool(array.get('group_chat_created')) if array.get('group_chat_created') is not None else None\n        data['supergroup_chat_created'] = bool(array.get('supergroup_chat_created')) if array.get('supergroup_chat_created') is not None else None\n        data['channel_chat_created'] = bool(array.get('channel_chat_created')) if array.get('channel_chat_created') is not None else None\n        data['migrate_to_chat_id'] = int(array.get('migrate_to_chat_id')) if array.get('migrate_to_chat_id') is not None else None\n        data['migrate_from_chat_id'] = int(array.get('migrate_from_chat_id')) if array.get('migrate_from_chat_id') is not None else None\n        data['pinned_message'] = Message.from_array(array.get('pinned_message')) if array.get('pinned_message') is not None else None\n        data['invoice'] = Invoice.from_array(array.get('invoice')) if array.get('invoice') is not None else None\n        data['successful_payment'] = SuccessfulPayment.from_array(array.get('successful_payment')) if array.get('successful_payment') is not None else None\n        data['connected_website'] = u(array.get('connected_website')) if array.get('connected_website') is not None else None\n        data['passport_data'] = PassportData.from_array(array.get('passport_data')) if array.get('passport_data') is not None else None\n        data['_raw'] = array\n        return Message(**data)", "response": "Deserialize a new Message from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nserialize this CallbackQuery to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this CallbackQuery to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(CallbackQuery, self).to_array()\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n        array['from'] = self.from_peer.to_array()  # type User\n        array['chat_instance'] = u(self.chat_instance)  # py2: type unicode, py3: type str\n        if self.message is not None:\n            array['message'] = self.message.to_array()  # type Message\n        if self.inline_message_id is not None:\n            array['inline_message_id'] = u(self.inline_message_id)  # py2: type unicode, py3: type str\n        if self.data is not None:\n            array['data'] = u(self.data)  # py2: type unicode, py3: type str\n        if self.game_short_name is not None:\n            array['game_short_name'] = u(self.game_short_name)  # py2: type unicode, py3: type str\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        from ..receivable.peer import User\n\n        data = {}\n        data['id'] = u(array.get('id'))\n        data['from_peer'] = User.from_array(array.get('from'))\n        data['chat_instance'] = u(array.get('chat_instance'))\n        data['message'] = Message.from_array(array.get('message')) if array.get('message') is not None else None\n        data['inline_message_id'] = u(array.get('inline_message_id')) if array.get('inline_message_id') is not None else None\n        data['data'] = u(array.get('data')) if array.get('data') is not None else None\n        data['game_short_name'] = u(array.get('game_short_name')) if array.get('game_short_name') is not None else None\n        data['_raw'] = array\n        return CallbackQuery(**data)", "response": "Deserialize a new CallbackQuery from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nserializes this ResponseParameters to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this ResponseParameters to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(ResponseParameters, self).to_array()\n        if self.migrate_to_chat_id is not None:\n            array['migrate_to_chat_id'] = int(self.migrate_to_chat_id)  # type int\n        if self.retry_after is not None:\n            array['retry_after'] = int(self.retry_after)  # type int\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an Xmrs object for all the RMRS components.", "response": "def Rmrs(top=None, index=None, xarg=None,\n         eps=None, args=None, hcons=None, icons=None,\n         lnk=None, surface=None, identifier=None, vars=None):\n    \"\"\"\n    Construct an :class:`Xmrs` from RMRS components.\n\n    Robust Minimal Recursion Semantics (RMRS) are like MRS, but all\n    predications have a nodeid (\"anchor\"), and arguments are not\n    contained by the source predications, but instead reference the\n    nodeid of their predication.\n\n    Args:\n        top: the TOP (or maybe LTOP) variable\n        index: the INDEX variable\n        xarg: the XARG variable\n        eps: an iterable of EPs\n        args: a nested mapping of `{nodeid: {rargname: value}}`\n        hcons: an iterable of HandleConstraint objects\n        icons: an iterable of IndividualConstraint objects\n        lnk: the Lnk object associating the MRS to the surface form\n        surface: the surface string\n        identifier: a discourse-utterance id\n        vars: a mapping of variables to a list of `(property, value)`\n            pairs\n\n    Example:\n\n    >>> m = Rmrs(\n    >>>     top='h0',\n    >>>     index='e2',\n    >>>     eps=[ElementaryPredication(\n    >>>         10000,\n    >>>         Pred.surface('_rain_v_1_rel'),\n    >>>         'h1'\n    >>>     )],\n    >>>     args={10000: {'ARG0': 'e2'}},\n    >>>     hcons=[HandleConstraint('h0', 'qeq', 'h1'),\n    >>>     vars={'e2': {'SF': 'prop-or-ques', 'TENSE': 'present'}}\n    >>> )\n    \"\"\"\n    eps = list(eps or [])\n    args = list(args or [])\n    if vars is None: vars = {}\n    for arg in args:\n        if arg.nodeid is None:\n            raise XmrsStructureError(\"RMRS args must have a nodeid.\")\n    # make the EPs more MRS-like (with arguments)\n    for ep in eps:\n        if ep.nodeid is None:\n            raise XmrsStructureError(\"RMRS EPs must have a nodeid.\")\n        epargs = ep.args\n        for rargname, value in args.get(ep.nodeid, {}).items():\n            epargs[rargname] = value\n    hcons = list(hcons or [])\n    icons = list(icons or [])\n    return Xmrs(top=top, index=index, xarg=xarg,\n                eps=eps, hcons=hcons, icons=icons, vars=vars,\n                lnk=lnk, surface=surface, identifier=identifier)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new instance of the class cls from xmrs.", "response": "def from_xmrs(cls, xmrs, **kwargs):\n        \"\"\"\n        Facilitate conversion among subclasses.\n\n        Args:\n            xmrs (:class:`Xmrs`): instance to convert from; possibly\n                an instance of a subclass, such as :class:`Mrs` or\n                :class:`Dmrs`\n            **kwargs: additional keyword arguments that may be used\n                by a subclass's redefinition of :meth:`from_xmrs`.\n        \"\"\"\n        x = cls()\n        x.__dict__.update(xmrs.__dict__)\n        return x"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nincorporate the list of EPs given by eps*.", "response": "def add_eps(self, eps):\n        \"\"\"\n        Incorporate the list of EPs given by *eps*.\n        \"\"\"\n        # (nodeid, pred, label, args, lnk, surface, base)\n        _nodeids, _eps, _vars = self._nodeids, self._eps, self._vars\n        for ep in eps:\n            try:\n                if not isinstance(ep, ElementaryPredication):\n                    ep = ElementaryPredication(*ep)\n            except TypeError:\n                raise XmrsError('Invalid EP data: {}'.format(repr(ep)))\n            # eplen = len(ep)\n            # if eplen < 3:\n            #     raise XmrsError(\n            #         'EPs must have length >= 3: (nodeid, pred, label, ...)'\n            #     )\n            nodeid, lbl = ep.nodeid, ep.label\n            if nodeid in _eps:\n                raise XmrsError(\n                    'EP already exists in Xmrs: {} ({})'\n                    .format(nodeid, ep[1])\n                )\n            _nodeids.append(nodeid)\n            _eps[nodeid] = ep\n            if lbl is not None:\n                _vars[lbl]['refs']['LBL'].append(nodeid)\n            for role, val in ep.args.items():\n                # if the val is not in _vars, it might still be a\n                # variable; check with var_re\n                if val in _vars or var_re.match(val):\n                    vardict = _vars[val]\n                    vardict['refs'][role].append(nodeid)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_hcons(self, hcons):\n        # (hi, relation, lo)\n        _vars = self._vars\n        _hcons = self._hcons\n        for hc in hcons:\n            try:\n                if not isinstance(hc, HandleConstraint):\n                    hc = HandleConstraint(*hc)\n            except TypeError:\n                raise XmrsError('Invalid HCONS data: {}'.format(repr(hc)))\n\n            hi = hc.hi\n            lo = hc.lo\n            if hi in _hcons:\n                raise XmrsError(\n                    'Handle constraint already exists for hole %s.' % hi\n                )\n            _hcons[hi] = hc\n            # the following should also ensure lo and hi are in _vars\n            if 'hcrefs' not in _vars[lo]:\n                _vars[lo]['hcrefs'] = []\n            for role, refs in _vars[hi]['refs'].items():\n                for nodeid in refs:\n                    _vars[lo]['hcrefs'].append((nodeid, role, hi))", "response": "Add HandleConstraints to the internal list of HandleConstraints."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_icons(self, icons):\n        _vars, _icons = self._vars, self._icons\n        for ic in icons:\n            try:\n                if not isinstance(ic, IndividualConstraint):\n                    ic = IndividualConstraint(*ic)\n            except TypeError:\n                raise XmrsError('Invalid ICONS data: {}'.format(repr(ic)))\n            left = ic.left\n            right = ic.right\n            if left not in _icons:\n                _icons[left] = []\n            _icons[left].append(ic)\n            # the following should also ensure left and right are in _vars\n            if 'icrefs' not in _vars[right]:\n                _vars[right]['icrefs'] = []\n            _vars[right]['icrefs'].append(ic)\n            _vars[left]", "response": "Add the given ICONS to the internal list of the internal list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef nodeid(self, iv, quantifier=False):\n        return next(iter(self.nodeids(ivs=[iv], quantifier=quantifier)), None)", "response": "Returns the nodeid of the predication selected by iv."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nodeids(self, ivs=None, quantifier=None):\n        if ivs is None:\n            nids = list(self._nodeids)\n        else:\n            _vars = self._vars\n            nids = []\n            for iv in ivs:\n                if iv in _vars and IVARG_ROLE in _vars[iv]['refs']:\n                    nids.extend(_vars[iv]['refs'][IVARG_ROLE])\n                else:\n                    raise KeyError(iv)\n        if quantifier is not None:\n            nids = [n for n in nids if self.ep(n).is_quantifier()==quantifier]\n        return nids", "response": "Return the list of nodeids given by ivs or all nodeids."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef eps(self, nodeids=None):\n        if nodeids is None: nodeids = self._nodeids\n        _eps = self._eps\n        return [_eps[nodeid] for nodeid in nodeids]", "response": "Return the EPs with the given nodeid or all EPs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef icons(self, left=None):\n        if left is not None:\n            return self._icons[left]\n        else:\n            return list(chain.from_iterable(self._icons.values()))", "response": "Returns the ICONS with left variable left or all ICONS."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef properties(self, var_or_nodeid, as_list=False):\n        props = []\n        if var_or_nodeid in self._vars:\n            props = self._vars[var_or_nodeid]['props']\n        elif var_or_nodeid in self._eps:\n            var = self._eps[var_or_nodeid][3].get(IVARG_ROLE)\n            props = self._vars.get(var, {}).get('props', [])\n        else:\n            raise KeyError(var_or_nodeid)\n        if not as_list:\n            props = dict(props)\n        return props", "response": "Returns a dictionary of variable properties for a given variable or nodeid."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the Pred objects for the given nodeids or all Pred objects if nodeids is None.", "response": "def preds(self, nodeids=None):\n        \"\"\"\n        Return the Pred objects for *nodeids*, or all Preds.\n\n        Args:\n            nodeids: an iterable of nodeids of predications to return\n                Preds from; if `None`, return all Preds\n        \"\"\"\n        if nodeids is None: nodeids = self._nodeids\n        _eps = self._eps\n        return [_eps[nid][1] for nid in nodeids]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef labels(self, nodeids=None):\n        if nodeids is None: nodeids = self._nodeids\n        _eps = self._eps\n        return [_eps[nid][2] for nid in nodeids]", "response": "Returns the list of labels for the given nodeids or all labels if nodeids is None."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the arguments going from *nodeid* to other predications.", "response": "def outgoing_args(self, nodeid):\n        \"\"\"\n        Return the arguments going from *nodeid* to other predications.\n\n        Valid arguments include regular variable arguments and scopal\n        (label-selecting or HCONS) arguments. MOD/EQ\n        links, intrinsic arguments, and constant arguments are not\n        included.\n\n        Args:\n            nodeid: the nodeid of the EP that is the arguments' source\n        Returns:\n            dict: `{role: tgt}`\n        \"\"\"\n        _vars = self._vars\n        _hcons = self._hcons\n        args = self.args(nodeid)  # args is a copy; we can edit it\n        for arg, val in list(args.items()):\n            # don't include constant args or intrinsic args\n            if arg == IVARG_ROLE or val not in _vars:\n                del args[arg]\n            else:\n                refs = _vars[val]['refs']\n                # don't include if not HCONS or pointing to other IV or LBL\n                if not (val in _hcons or IVARG_ROLE in refs or 'LBL' in refs):\n                    del args[arg]\n        return args"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the arguments that target *nodeid*.", "response": "def incoming_args(self, nodeid):\n        \"\"\"\n        Return the arguments that target *nodeid*.\n\n        Valid arguments include regular variable arguments and scopal\n        (label-selecting or HCONS) arguments. MOD/EQ\n        links and intrinsic arguments are not included.\n\n        Args:\n            nodeid: the nodeid of the EP that is the arguments' target\n        Returns:\n            dict: `{source_nodeid: {rargname: value}}`\n        \"\"\"\n        _vars = self._vars\n        ep = self._eps[nodeid]\n        lbl = ep[2]\n        iv = ep[3].get(IVARG_ROLE)\n        in_args_list = []\n        # variable args\n        if iv in _vars:\n            for role, nids in _vars[iv]['refs'].items():\n                # ignore intrinsic args, even if shared\n                if role != IVARG_ROLE:\n                    in_args_list.append((nids, role, iv))\n        if lbl in _vars:\n            for role, nids in _vars[lbl]['refs'].items():\n                # basic label equality isn't \"incoming\"; ignore\n                if role != 'LBL':\n                    in_args_list.append((nids, role, lbl))\n            for nid, role, hi in _vars[lbl].get('hcrefs', []):\n                in_args_list.append(([nid], role, hi))\n        in_args = {}\n        for nids, role, tgt in in_args_list:\n            for nid in nids:\n                if nid not in in_args:\n                    in_args[nid] = {}\n                in_args[nid][role] = tgt\n        return in_args"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the heads of the labelset selected by label.", "response": "def labelset_heads(self, label):\n        \"\"\"\n        Return the heads of the labelset selected by *label*.\n\n        Args:\n            label: the label from which to find head nodes/EPs.\n        Returns:\n            An iterable of nodeids.\n        \"\"\"\n        _eps = self._eps\n        _vars = self._vars\n        _hcons = self._hcons\n        nodeids = {nodeid: _eps[nodeid][3].get(IVARG_ROLE, None)\n                for nodeid in _vars[label]['refs']['LBL']}\n        if len(nodeids) <= 1:\n            return list(nodeids)\n\n        scope_sets = {}\n        for nid in nodeids:\n            scope_sets[nid] = _ivs_in_scope(nid, _eps, _vars, _hcons)\n\n        out = {}\n        for n in nodeids:\n            out[n] = 0\n            for role, val in _eps[n][3].items():\n                if role == IVARG_ROLE or role == CONSTARG_ROLE:\n                    continue\n                elif any(val in s for n2, s in scope_sets.items() if n2 != n):\n                    out[n] += 1\n\n        candidates = [n for n, out_deg in out.items() if out_deg == 0]\n        rank = {}\n        for n in candidates:\n            iv = nodeids[n]\n            pred = _eps[n][1]\n            if iv in _vars and self.nodeid(iv, quantifier=True) is not None:\n                rank[n] = 0\n            elif pred.is_quantifier():\n                rank[n] = 0\n            elif pred.type == Pred.ABSTRACT:\n                rank[n] = 2\n            else:\n                rank[n] = 1\n\n        return sorted(candidates, key=lambda n: rank[n])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef subgraph(self, nodeids):\n        _eps, _vars = self._eps, self._vars\n        _hcons, _icons = self._hcons, self._icons\n        top = index = xarg = None\n        eps = [_eps[nid] for nid in nodeids]\n        lbls = set(ep[2] for ep in eps)\n        hcons = []\n        icons = []\n        subvars = {}\n        if self.top:\n            top = self.top\n            tophc = _hcons.get(top, None)\n            if tophc is not None and tophc[2] in lbls:\n                subvars[top] = {}\n            elif top not in lbls:\n                top = None  # nevermind, set it back to None\n        # do index after we know if it is an EPs intrinsic variable.\n        # what about xarg? I'm not really sure.. just put it in\n        if self.xarg:\n            xarg = self.xarg\n            subvars[self.xarg] = _vars[self.xarg]['props']\n        subvars.update((lbl, {}) for lbl in lbls)\n        subvars.update(\n            (var, _vars[var]['props'])\n            for ep in eps for var in ep[3].values()\n            if var in _vars\n        )\n        if self.index in subvars:\n            index = self.index\n        # hcons and icons; only if the targets exist in the new subgraph\n        for var in subvars:\n            hc = _hcons.get(var, None)\n            if hc is not None and hc[2] in lbls:\n                hcons.append(hc)\n            for ic in _icons.get(var, []):\n                if ic[0] in subvars and ic[2] in subvars:\n                    icons.append(ic)\n        return Xmrs(\n            top=top, index=index, xarg=xarg,\n            eps=eps, hcons=hcons, icons=icons, vars=subvars,\n            lnk=self.lnk, surface=self.surface, identifier=self.identifier\n        )", "response": "Returns an Xmrs object with only the specified nodeids."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_connected(self):\n        nids = set(self._nodeids)  # the nids left to find\n        if len(nids) == 0:\n            raise XmrsError('Cannot compute connectedness of an empty Xmrs.')\n        # build a basic dict graph of relations\n        edges = []\n        # label connections\n        for lbl in self.labels():\n            lblset = self.labelset(lbl)\n            edges.extend((x, y) for x in lblset for y in lblset if x != y)\n        # argument connections\n        _vars = self._vars\n        for nid in nids:\n            for rarg, tgt in self.args(nid).items():\n                if tgt not in _vars:\n                    continue\n                if IVARG_ROLE in _vars[tgt]['refs']:\n                    tgtnids = list(_vars[tgt]['refs'][IVARG_ROLE])\n                elif tgt in self._hcons:\n                    tgtnids = list(self.labelset(self.hcon(tgt)[2]))\n                elif 'LBL' in _vars[tgt]['refs']:\n                    tgtnids = list(_vars[tgt]['refs']['LBL'])\n                else:\n                    tgtnids = []\n                # connections are bidirectional\n                edges.extend((nid, t) for t in tgtnids if nid != t)\n                edges.extend((t, nid) for t in tgtnids if nid != t)\n        g = {nid: set() for nid in nids}\n        for x, y in edges:\n            g[x].add(y)\n        connected_nids = _bfs(g)\n        if connected_nids == nids:\n            return True\n        elif connected_nids.difference(nids):\n            raise XmrsError(\n                'Possibly bogus nodeids: {}'\n                .format(', '.join(connected_nids.difference(nids)))\n            )\n        return False", "response": "Return True if the Xmrs represents a connected graph."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks that the Xmrs is well - formed and that all of the EPs in the Xmrs are well - formed.", "response": "def validate(self):\n        \"\"\"\n        Check that the Xmrs is well-formed.\n\n        The Xmrs is analyzed and a list of problems is compiled. If\n        any problems exist, an :exc:`XmrsError` is raised with the list\n        joined as the error message. A well-formed Xmrs has the\n        following properties:\n\n        * All predications have an intrinsic variable\n        * Every intrinsic variable belongs one predication and maybe\n          one quantifier\n        * Every predication has no more than one quantifier\n        * All predications have a label\n        * The graph of predications form a net (i.e. are connected).\n          Connectivity can be established with variable arguments,\n          QEQs, or label-equality.\n        * The lo-handle for each QEQ must exist as the label of a\n          predication\n        \"\"\"\n        errors = []\n        ivs, bvs = {}, {}\n        _vars = self._vars\n        _hcons = self._hcons\n        labels = defaultdict(set)\n        # ep_args = {}\n        for ep in self.eps():\n            nid, lbl, args, is_q = (\n                ep.nodeid, ep.label, ep.args, ep.is_quantifier()\n            )\n            if lbl is None:\n                errors.append('EP ({}) is missing a label.'.format(nid))\n            labels[lbl].add(nid)\n            iv = args.get(IVARG_ROLE)\n            if iv is None:\n                errors.append('EP {nid} is missing an intrinsic variable.'\n                              .format(nid))\n            if is_q:\n                if iv in bvs:\n                    errors.append('{} is the bound variable for more than '\n                                  'one quantifier.'.format(iv))\n                bvs[iv] = nid\n            else:\n                if iv in ivs:\n                    errors.append('{} is the intrinsic variable for more '\n                                  'than one EP.'.format(iv))\n                ivs[iv] = nid\n            # ep_args[nid] = args\n        for hc in _hcons.values():\n            if hc[2] not in labels:\n                errors.append('Lo variable of HCONS ({} {} {}) is not the '\n                              'label of any EP.'.format(*hc))\n        if not self.is_connected():\n            errors.append('Xmrs structure is not connected.')\n        if errors:\n            raise XmrsError('\\n'.join(errors))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nencoding the Mrs as a dictionary suitable for JSON serialization.", "response": "def to_dict(self, short_pred=True, properties=True):\n        \"\"\"\n        Encode the Mrs as a dictionary suitable for JSON serialization.\n        \"\"\"\n        def _lnk(obj): return {'from': obj.cfrom, 'to': obj.cto}\n        def _ep(ep, short_pred=True):\n            p = ep.pred.short_form() if short_pred else ep.pred.string\n            d = dict(label=ep.label, predicate=p, arguments=ep.args)\n            if ep.lnk is not None: d['lnk'] = _lnk(ep)\n            return d\n        def _hcons(hc): return {'relation':hc[1], 'high':hc[0], 'low':hc[2]}\n        def _icons(ic): return {'relation':ic[1], 'left':ic[0], 'right':ic[2]}\n        def _var(v):\n            d = {'type': var_sort(v)}\n            if properties and self.properties(v):\n                d['properties'] = self.properties(v)\n            return d\n\n        d = dict(\n            relations=[_ep(ep, short_pred=short_pred) for ep in self.eps()],\n            constraints=([_hcons(hc) for hc in self.hcons()] +\n                         [_icons(ic) for ic in self.icons()]),\n            variables={v: _var(v) for v in self.variables()}\n        )\n        if self.top is not None: d['top'] = self.top\n        if self.index is not None: d['index'] = self.index\n        # if self.xarg is not None: d['xarg'] = self.xarg\n        # if self.lnk is not None: d['lnk'] = self.lnk\n        # if self.surface is not None: d['surface'] = self.surface\n        # if self.identifier is not None: d['identifier'] = self.identifier\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndecode a dictionary into an Mrs object.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Decode a dictionary, as from :meth:`to_dict`, into an Mrs object.\n        \"\"\"\n        def _lnk(o):\n            return None if o is None else Lnk.charspan(o['from'], o['to'])\n        def _ep(ep):\n            return ElementaryPredication(\n                nodeid=None,\n                pred=Pred.surface_or_abstract(ep['predicate']),\n                label=ep['label'],\n                args=ep.get('arguments', {}),\n                lnk=_lnk(ep.get('lnk')),\n                surface=ep.get('surface'),\n                base=ep.get('base')\n            )\n        eps = [_ep(rel) for rel in d.get('relations', [])]\n        hcons = [(c['high'], c['relation'], c['low'])\n                 for c in d.get('constraints', []) if 'high' in c]\n        icons = [(c['high'], c['relation'], c['low'])\n                 for c in d.get('constraints', []) if 'left' in c]\n        variables = {var: list(data.get('properties', {}).items())\n                     for var, data in d.get('variables', {}).items()}\n        return cls(\n            top=d.get('top'),\n            index=d.get('index'),\n            xarg=d.get('xarg'),\n            rels=eps,\n            hcons=hcons,\n            icons=icons,\n            lnk=_lnk(d.get('lnk')),\n            surface=d.get('surface'),\n            identifier=d.get('identifier'),\n            vars=variables\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nencode the Dmrs as a dictionary suitable for JSON serialization.", "response": "def to_dict(self, short_pred=True, properties=True):\n        \"\"\"\n        Encode the Dmrs as a dictionary suitable for JSON serialization.\n        \"\"\"\n        qs = set(self.nodeids(quantifier=True))\n        def _lnk(obj): return {'from': obj.cfrom, 'to': obj.cto}\n        def _node(node, short_pred=True):\n            p = node.pred.short_form() if short_pred else node.pred.string\n            d = dict(nodeid=node.nodeid, predicate=p)\n            if node.lnk is not None: d['lnk'] = _lnk(node)\n            if properties and node.sortinfo:\n                if node.nodeid not in qs:\n                    d['sortinfo'] = node.sortinfo\n            if node.surface is not None: d['surface'] = node.surface\n            if node.base is not None: d['base'] = node.base\n            if node.carg is not None: d['carg'] = node.carg\n            return d\n        def _link(link): return {\n            'from': link.start, 'to': link.end,\n            'rargname': link.rargname, 'post': link.post\n        }\n\n        d = dict(\n            nodes=[_node(n) for n in nodes(self)],\n            links=[_link(l) for l in links(self)]\n        )\n        # if self.top is not None: ... currently handled by links\n        if self.index is not None:\n            idx = self.nodeid(self.index)\n            if idx is not None:\n                d['index'] = idx\n        if self.xarg is not None:\n            xarg = self.nodeid(self.index)\n            if xarg is not None:\n                d['index'] = xarg\n        if self.lnk is not None: d['lnk'] = _lnk(self)\n        if self.surface is not None: d['surface'] = self.surface\n        if self.identifier is not None: d['identifier'] = self.identifier\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_dict(cls, d):\n        def _node(obj):\n            return Node(\n                obj.get('nodeid'),\n                Pred.surface_or_abstract(obj.get('predicate')),\n                sortinfo=obj.get('sortinfo'),\n                lnk=_lnk(obj.get('lnk')),\n                surface=obj.get('surface'),\n                base=obj.get('base'),\n                carg=obj.get('carg')\n            )\n        def _link(obj):\n            return Link(obj.get('from'), obj.get('to'),\n                        obj.get('rargname'), obj.get('post'))\n        def _lnk(o):\n            return None if o is None else Lnk.charspan(o['from'], o['to'])\n        return cls(\n            nodes=[_node(n) for n in d.get('nodes', [])],\n            links=[_link(l) for l in d.get('links', [])],\n            lnk=_lnk(d.get('lnk')),\n            surface=d.get('surface'),\n            identifier=d.get('identifier')\n        )", "response": "Decode a dictionary into a Dmrs object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nencodes the Dmrs as triples suitable for PENMAN serialization.", "response": "def to_triples(self, short_pred=True, properties=True):\n        \"\"\"\n        Encode the Dmrs as triples suitable for PENMAN serialization.\n        \"\"\"\n        ts = []\n        qs = set(self.nodeids(quantifier=True))\n        for n in nodes(self):\n            pred = n.pred.short_form() if short_pred else n.pred.string\n            ts.append((n.nodeid, 'predicate', pred))\n            if n.lnk is not None:\n                ts.append((n.nodeid, 'lnk', '\"{}\"'.format(str(n.lnk))))\n            if n.carg is not None:\n                ts.append((n.nodeid, 'carg', '\"{}\"'.format(n.carg)))\n            if properties and n.nodeid not in qs:\n                for key, value in n.sortinfo.items():\n                    ts.append((n.nodeid, key.lower(), value))\n\n        for l in links(self):\n            if safe_int(l.start) == LTOP_NODEID:\n                ts.append((l.start, 'top', l.end))\n            else:\n                relation = '{}-{}'.format(l.rargname.upper(), l.post)\n                ts.append((l.start, relation, l.end))\n        return ts"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_triples(cls, triples, remap_nodeids=True):\n        top_nid = str(LTOP_NODEID)\n        top = lnk = surface = identifier = None\n        nids, nd, edges = [], {}, []\n        for src, rel, tgt in triples:\n            src, tgt = str(src), str(tgt)  # hack for int-converted src/tgt\n            if src == top_nid and rel == 'top':\n                top = tgt\n                continue\n            elif src not in nd:\n                if top is None:\n                    top=src\n                nids.append(src)\n                nd[src] = {'pred': None, 'lnk': None, 'carg': None, 'si': []}\n            if rel == 'predicate':\n                nd[src]['pred'] = Pred.surface_or_abstract(tgt)\n            elif rel == 'lnk':\n                cfrom, cto = tgt.strip('\"<>').split(':')\n                nd[src]['lnk'] = Lnk.charspan(int(cfrom), int(cto))\n            elif rel == 'carg':\n                if (tgt[0], tgt[-1]) == ('\"', '\"'):\n                    tgt = tgt[1:-1]\n                nd[src]['carg'] = tgt\n            elif rel.islower():\n                nd[src]['si'].append((rel, tgt))\n            else:\n                rargname, post = rel.rsplit('-', 1)\n                edges.append((src, tgt, rargname, post))\n        if remap_nodeids:\n            nidmap = dict((nid, FIRST_NODEID+i) for i, nid in enumerate(nids))\n        else:\n            nidmap = dict((nid, nid) for nid in nids)\n        nodes = [\n            Node(\n                nodeid=nidmap[nid],\n                pred=nd[nid]['pred'],\n                sortinfo=nd[nid]['si'],\n                lnk=nd[nid]['lnk'],\n                carg=nd[nid]['carg']\n            ) for i, nid in enumerate(nids)\n        ]\n        links = [Link(nidmap[s], nidmap[t], r, p) for s, t, r, p in edges]\n        if top:\n            links.append(Link(LTOP_NODEID, nidmap[top], None, H_POST))\n        return cls(\n            nodes=nodes,\n            links=links,\n            lnk=lnk,\n            surface=surface,\n            identifier=identifier\n        )", "response": "Decode triples as from _to_triples_ into a Dmrs object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(Invoice, self).to_array()\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n        array['description'] = u(self.description)  # py2: type unicode, py3: type str\n        array['start_parameter'] = u(self.start_parameter)  # py2: type unicode, py3: type str\n        array['currency'] = u(self.currency)  # py2: type unicode, py3: type str\n        array['total_amount'] = int(self.total_amount)  # type int\n        return array", "response": "Serializes this Invoice to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserialize this ShippingAddress to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this ShippingAddress to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(ShippingAddress, self).to_array()\n        array['country_code'] = u(self.country_code)  # py2: type unicode, py3: type str\n        array['state'] = u(self.state)  # py2: type unicode, py3: type str\n        array['city'] = u(self.city)  # py2: type unicode, py3: type str\n        array['street_line1'] = u(self.street_line1)  # py2: type unicode, py3: type str\n        array['street_line2'] = u(self.street_line2)  # py2: type unicode, py3: type str\n        array['post_code'] = u(self.post_code)  # py2: type unicode, py3: type str\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nserializes this OrderInfo to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this OrderInfo to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(OrderInfo, self).to_array()\n        if self.name is not None:\n            array['name'] = u(self.name)  # py2: type unicode, py3: type str\n        if self.phone_number is not None:\n            array['phone_number'] = u(self.phone_number)  # py2: type unicode, py3: type str\n        if self.email is not None:\n            array['email'] = u(self.email)  # py2: type unicode, py3: type str\n        if self.shipping_address is not None:\n            array['shipping_address'] = self.shipping_address.to_array()  # type ShippingAddress\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['name'] = u(array.get('name')) if array.get('name') is not None else None\n        data['phone_number'] = u(array.get('phone_number')) if array.get('phone_number') is not None else None\n        data['email'] = u(array.get('email')) if array.get('email') is not None else None\n        data['shipping_address'] = ShippingAddress.from_array(array.get('shipping_address')) if array.get('shipping_address') is not None else None\n        data['_raw'] = array\n        return OrderInfo(**data)", "response": "Deserialize a new OrderInfo from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_array(self):\n        array = super(SuccessfulPayment, self).to_array()\n        array['currency'] = u(self.currency)  # py2: type unicode, py3: type str\n        array['total_amount'] = int(self.total_amount)  # type int\n        array['invoice_payload'] = u(self.invoice_payload)  # py2: type unicode, py3: type str\n        array['telegram_payment_charge_id'] = u(self.telegram_payment_charge_id)  # py2: type unicode, py3: type str\n        array['provider_payment_charge_id'] = u(self.provider_payment_charge_id)  # py2: type unicode, py3: type str\n        if self.shipping_option_id is not None:\n            array['shipping_option_id'] = u(self.shipping_option_id)  # py2: type unicode, py3: type str\n        if self.order_info is not None:\n            array['order_info'] = self.order_info.to_array()  # type OrderInfo\n        return array", "response": "Serializes this SuccessfulPayment to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['currency'] = u(array.get('currency'))\n        data['total_amount'] = int(array.get('total_amount'))\n        data['invoice_payload'] = u(array.get('invoice_payload'))\n        data['telegram_payment_charge_id'] = u(array.get('telegram_payment_charge_id'))\n        data['provider_payment_charge_id'] = u(array.get('provider_payment_charge_id'))\n        data['shipping_option_id'] = u(array.get('shipping_option_id')) if array.get('shipping_option_id') is not None else None\n        data['order_info'] = OrderInfo.from_array(array.get('order_info')) if array.get('order_info') is not None else None\n        data['_raw'] = array\n        return SuccessfulPayment(**data)", "response": "Deserialize a new SuccessfulPayment from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_array(self):\n        array = super(ShippingQuery, self).to_array()\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n        array['from'] = self.from_peer.to_array()  # type User\n        array['invoice_payload'] = u(self.invoice_payload)  # py2: type unicode, py3: type str\n        array['shipping_address'] = self.shipping_address.to_array()  # type ShippingAddress\n        return array", "response": "Serializes this ShippingQuery to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.peer import User\n\n        data = {}\n        data['id'] = u(array.get('id'))\n        data['from_peer'] = User.from_array(array.get('from'))\n        data['invoice_payload'] = u(array.get('invoice_payload'))\n        data['shipping_address'] = ShippingAddress.from_array(array.get('shipping_address'))\n        data['_raw'] = array\n        return ShippingQuery(**data)", "response": "Deserialize a new ShippingQuery instance from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserializes this PreCheckoutQuery to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this PreCheckoutQuery to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(PreCheckoutQuery, self).to_array()\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n        array['from'] = self.from_peer.to_array()  # type User\n        array['currency'] = u(self.currency)  # py2: type unicode, py3: type str\n        array['total_amount'] = int(self.total_amount)  # type int\n        array['invoice_payload'] = u(self.invoice_payload)  # py2: type unicode, py3: type str\n        if self.shipping_option_id is not None:\n            array['shipping_option_id'] = u(self.shipping_option_id)  # py2: type unicode, py3: type str\n        if self.order_info is not None:\n            array['order_info'] = self.order_info.to_array()  # type OrderInfo\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.peer import User\n\n        data = {}\n        data['id'] = u(array.get('id'))\n        data['from_peer'] = User.from_array(array.get('from'))\n        data['currency'] = u(array.get('currency'))\n        data['total_amount'] = int(array.get('total_amount'))\n        data['invoice_payload'] = u(array.get('invoice_payload'))\n        data['shipping_option_id'] = u(array.get('shipping_option_id')) if array.get('shipping_option_id') is not None else None\n        data['order_info'] = OrderInfo.from_array(array.get('order_info')) if array.get('order_info') is not None else None\n        data['_raw'] = array\n        return PreCheckoutQuery(**data)", "response": "Deserialize a new PreCheckoutQuery instance from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_array(self):\n        array = super(InputMediaPhoto, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['media'] = u(self.media)  # py2: type unicode, py3: type str\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        return array", "response": "Serializes this InputMediaPhoto to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_array(self):\n        array = super(InputMediaAnimation, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['media'] = u(self.media)  # py2: type unicode, py3: type str\n\n        if self.thumb is not None:\n            if isinstance(self.thumb, InputFile):\n                array['thumb'] = self.thumb.to_array()  # type InputFile\n            elif isinstance(self.thumb, str):\n                array['thumb'] = u(self.thumb)  # py2: type unicode, py3: type str\n            else:\n                raise TypeError('Unknown type, must be one of InputFile, str.')\n            # end if\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.width is not None:\n            array['width'] = int(self.width)  # type int\n        if self.height is not None:\n            array['height'] = int(self.height)  # type int\n        if self.duration is not None:\n            array['duration'] = int(self.duration)  # type int\n        return array", "response": "Serializes this InputMediaAnimation to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_array(self):\n        array = super(InputMediaAudio, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['media'] = u(self.media)  # py2: type unicode, py3: type str\n\n        if self.thumb is not None:\n            if isinstance(self.thumb, InputFile):\n                array['thumb'] = self.thumb.to_array()  # type InputFile\n            elif isinstance(self.thumb, str):\n                array['thumb'] = u(self.thumb)  # py2: type unicode, py3: type str\n            else:\n                raise TypeError('Unknown type, must be one of InputFile, str.')\n            # end if\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.duration is not None:\n            array['duration'] = int(self.duration)  # type int\n        if self.performer is not None:\n            array['performer'] = u(self.performer)  # py2: type unicode, py3: type str\n\n        if self.title is not None:\n            array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        return array", "response": "Serializes this InputMediaAudio to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_array(self):\n        array = super(InputMediaDocument, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['media'] = u(self.media)  # py2: type unicode, py3: type str\n\n        if self.thumb is not None:\n            if isinstance(self.thumb, InputFile):\n                array['thumb'] = self.thumb.to_array()  # type InputFile\n            elif isinstance(self.thumb, str):\n                array['thumb'] = u(self.thumb)  # py2: type unicode, py3: type str\n            else:\n                raise TypeError('Unknown type, must be one of InputFile, str.')\n            # end if\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        return array", "response": "Serializes this InputMediaDocument to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nserializes Xmrs objects to the Prolog representation and write to a file.", "response": "def dump(destination, ms, single=False, pretty_print=False, **kwargs):\n    \"\"\"\n    Serialize Xmrs objects to the Prolog representation and write to a file.\n\n    Args:\n        destination: filename or file object where data will be written\n        ms: an iterator of Xmrs objects to serialize (unless the\n            *single* option is `True`)\n        single: if `True`, treat *ms* as a single Xmrs object\n            instead of as an iterator\n        pretty_print: if `True`, add newlines and indentation\n    \"\"\"\n    text = dumps(ms,\n                 single=single,\n                 pretty_print=pretty_print,\n                 **kwargs)\n\n    if hasattr(destination, 'write'):\n        print(text, file=destination)\n    else:\n        with open(destination, 'w') as fh:\n            print(text, file=fh)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nserialize an Xmrs object to the Prolog representation", "response": "def dumps(ms, single=False, pretty_print=False, **kwargs):\n    \"\"\"\n    Serialize an Xmrs object to the Prolog representation\n\n    Args:\n        ms: an iterator of Xmrs objects to serialize (unless the\n            *single* option is `True`)\n        single: if `True`, treat *ms* as a single Xmrs object instead\n            of as an iterator\n        pretty_print: if `True`, add newlines and indentation\n    Returns:\n        the Prolog string representation of a corpus of Xmrs\n    \"\"\"\n    if single:\n        ms = [ms]\n    return serialize(ms, pretty_print=pretty_print, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread a variable - property mapping from source and return the VPM instance.", "response": "def load(source, semi=None):\n    \"\"\"\n    Read a variable-property mapping from *source* and return the VPM.\n\n    Args:\n        source: a filename or file-like object containing the VPM\n            definitions\n        semi (:class:`~delphin.mrs.semi.SemI`, optional): if provided,\n            it is passed to the VPM constructor\n    Returns:\n        a :class:`VPM` instance\n    \"\"\"\n    if hasattr(source, 'read'):\n        return _load(source, semi)\n    else:\n        with open(source, 'r') as fh:\n            return _load(fh, semi)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _valmatch(vs, ss, op, varsort, semi, section):\n    if op in _EQUAL_OPS or semi is None:\n        return all(\n            s == v or  # value equality\n            (s == '*' and v is not None) or  # non-null wildcard\n            (\n                v is None and (  # value is null (any or with matching varsort)\n                    s == '!' or\n                    (s[0], s[-1], s[1:-1]) == ('[', ']', varsort)\n                )\n            )\n            for v, s in zip(vs, ss)\n        )\n    else:\n        pass", "response": "Return True if every value in vs and ss matches the given condition."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply(self, var, props, reverse=False):\n        vs, vid = sort_vid_split(var)\n        if reverse:\n            # variable type mapping is disabled in reverse\n            # tms = [(b, op, a) for a, op, b in self._typemap if op in _RL_OPS]\n            tms = []\n        else:\n            tms = [(a, op, b) for a, op, b in self._typemap if op in _LR_OPS]\n        for src, op, tgt in tms:\n            if _valmatch([vs], src, op, None, self._semi, 'variables'):\n                vs = vs if tgt == ['*'] else tgt[0]\n                break\n        newvar = '{}{}'.format(vs, vid)\n\n        newprops = {}\n        for featsets, valmap in self._propmap:\n            if reverse:\n                tgtfeats, srcfeats = featsets\n                pms = [(b, op, a) for a, op, b in valmap if op in _RL_OPS]\n            else:\n                srcfeats, tgtfeats = featsets\n                pms = [(a, op, b) for a, op, b in valmap if op in _LR_OPS]\n            vals = [props.get(f) for f in srcfeats]\n            for srcvals, op, tgtvals in pms:\n                if _valmatch(vals, srcvals, op, vs, self._semi, 'properties'):\n                    for i, featval in enumerate(zip(tgtfeats, tgtvals)):\n                        k, v = featval\n                        if v == '*':\n                            print(i, len(vals), vals, k, v)\n                            if i < len(vals) and vals[i] is not None:\n                                newprops[k] = vals[i]\n                        elif v != '!':\n                            newprops[k] = v\n                    break\n\n        return newvar, newprops", "response": "Applies the VPM to a variable and properties."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert(path, source_fmt, target_fmt, select='result:mrs',\n            properties=True, show_status=False, predicate_modifiers=False,\n            color=False, pretty_print=False, indent=None):\n    \"\"\"\n    Convert between various DELPH-IN Semantics representations.\n\n    Args:\n        path (str, file): filename, testsuite directory, open file, or\n            stream of input representations\n        source_fmt (str): convert from this format\n        target_fmt (str): convert to this format\n        select (str): TSQL query for selecting data (ignored if *path*\n            is not a testsuite directory; default: `\"result:mrs\"`)\n        properties (bool): include morphosemantic properties if `True`\n            (default: `True`)\n        show_status (bool): show disconnected EDS nodes (ignored if\n            *target_fmt* is not `\"eds\"`; default: `False`)\n        predicate_modifiers (bool): apply EDS predicate modification\n            for certain kinds of patterns (ignored if *target_fmt* is\n            not an EDS format; default: `False`)\n        color (bool): apply syntax highlighting if `True` and\n            *target_fmt* is `\"simplemrs\"` (default: `False`)\n        pretty_print (bool): if `True`, format the output with\n            newlines and default indentation (default: `False`)\n        indent (int, optional): specifies an explicit number of spaces\n            for indentation (implies *pretty_print*)\n    Returns:\n        str: the converted representation\n    \"\"\"\n    if source_fmt.startswith('eds') and not target_fmt.startswith('eds'):\n        raise ValueError(\n            'Conversion from EDS to non-EDS currently not supported.')\n\n    if indent:\n        pretty_print = True\n        indent = 4 if indent is True else safe_int(indent)\n\n    if len(tsql.inspect_query('select ' + select)['projection']) != 1:\n        raise ValueError('Exactly 1 column must be given in selection query: '\n                         '(e.g., result:mrs)')\n\n    # read\n    loads = _get_codec(source_fmt)\n    if path is None:\n        xs = loads(sys.stdin.read())\n    elif hasattr(path, 'read'):\n        xs = loads(path.read())\n    elif os.path.isdir(path):\n        ts = itsdb.TestSuite(path)\n        xs = [\n            next(iter(loads(r[0])), None)\n            for r in tsql.select(select, ts)\n        ]\n    else:\n        xs = loads(open(path, 'r').read())\n\n    # write\n    dumps = _get_codec(target_fmt, load=False)\n    kwargs = {}\n    if color: kwargs['color'] = color\n    if pretty_print: kwargs['pretty_print'] = pretty_print\n    if indent: kwargs['indent'] = indent\n    if target_fmt == 'eds':\n        kwargs['pretty_print'] = pretty_print\n        kwargs['show_status'] = show_status\n    if target_fmt.startswith('eds'):\n        kwargs['predicate_modifiers'] = predicate_modifiers\n    kwargs['properties'] = properties\n\n    # this is not a great way to improve robustness when converting\n    # many representations, but it'll do until v1.0.0. Also, it only\n    # improves robustness on the output, not the input.\n    # Note that all the code below is to replace the following:\n    #     return dumps(xs, **kwargs)\n    head, joiner, tail = _get_output_details(target_fmt)\n    parts = []\n    if pretty_print:\n        joiner = joiner.strip() + '\\n'\n    def _trim(s):\n        if head and s.startswith(head):\n            s = s[len(head):].lstrip('\\n')\n        if tail and s.endswith(tail):\n            s = s[:-len(tail)].rstrip('\\n')\n        return s\n    for x in xs:\n        try:\n            s = dumps([x], **kwargs)\n        except (PyDelphinException, KeyError, IndexError):\n            logging.exception('could not convert representation')\n        else:\n            s = _trim(s)\n            parts.append(s)\n    # set these after so head and tail are used correctly in _trim\n    if pretty_print:\n        if head:\n            head += '\\n'\n        if tail:\n            tail = '\\n' + tail\n    return head + joiner.join(parts) + tail", "response": "Convert from one format to another."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nselect data from [ incr tsdb () ] profiles.", "response": "def select(dataspec, testsuite, mode='list', cast=True):\n    \"\"\"\n    Select data from [incr tsdb()] profiles.\n\n    Args:\n        query (str): TSQL select query (e.g., `'i-id i-input mrs'` or\n            `'* from item where readings > 0'`)\n        testsuite (str, TestSuite): testsuite or path to testsuite\n            containing data to select\n        mode (str): see :func:`delphin.itsdb.select_rows` for a\n            description of the *mode* parameter (default: `list`)\n        cast (bool): if `True`, cast column values to their datatype\n            according to the relations file (default: `True`)\n    Returns:\n        a generator that yields selected data\n    \"\"\"\n    if isinstance(testsuite, itsdb.ItsdbProfile):\n        testsuite = itsdb.TestSuite(testsuite.root)\n    elif not isinstance(testsuite, itsdb.TestSuite):\n        testsuite = itsdb.TestSuite(testsuite)\n    return tsql.select(dataspec, testsuite, mode=mode, cast=cast)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new TSDB profile file for the specified source and relations files.", "response": "def mkprof(destination, source=None, relations=None, where=None,\n           in_place=False, skeleton=False, full=False, gzip=False):\n    \"\"\"\n    Create [incr tsdb()] profiles or skeletons.\n\n    Data for the testsuite may come from an existing testsuite or from\n    a list of sentences. There are four main usage patterns:\n\n        - `source=\"testsuite/\"` -- read data from `testsuite/`\n        - `source=None, in_place=True` -- read data from *destination*\n        - `source=None, in_place=False` -- read sentences from stdin\n        - `source=\"sents.txt\"` -- read sentences from `sents.txt`\n\n    For the latter two, the *relations* parameter must be specified.\n\n    Args:\n        destination (str): path of the new testsuite\n        source (str): path to a source testsuite or a file containing\n            sentences; if not given and *in_place* is `False`,\n            sentences are read from stdin\n        relations (str): path to a relations file to use for the\n            created testsuite; if `None` and *source* is given, the\n            relations file of the source testsuite is used\n        where (str): TSQL condition to filter records by; ignored if\n            *source* is not a testsuite\n        in_place (bool): if `True` and *source* is not given, use\n            *destination* as the source for data (default: `False`)\n        skeleton (bool): if `True`, only write tsdb-core files\n            (default: `False`)\n        full (bool): if `True`, copy all data from the source\n            testsuite (requires *source* to be a testsuite path;\n            default: `False`)\n        gzip (bool): if `True`, non-empty tables will be compressed\n            with gzip\n    \"\"\"\n    # basic validation\n    if skeleton and full:\n        raise ValueError(\"'skeleton' is incompatible with 'full'\")\n    elif skeleton and in_place:\n        raise ValueError(\"'skeleton' is incompatible with 'in_place'\")\n    elif in_place and source is not None:\n        raise ValueError(\"'in_place' is incompatible with 'source'\")\n    if in_place:\n        source = destination\n    if full and (source is None or not os.path.isdir(source)):\n        raise ValueError(\"'full' must be used with a source testsuite\")\n    if relations is None and source is not None and os.path.isdir(source):\n        relations = os.path.join(source, 'relations')\n    elif relations is None or not os.path.isfile(relations):\n        raise ValueError('invalid or missing relations file: {}'\n                         .format(relations))\n    # setup destination testsuite\n    _prepare_output_directory(destination)\n    dts = itsdb.TestSuite(path=destination, relations=relations)\n    # input is sentences on stdin\n    if source is None:\n        dts.write({'item': _lines_to_rows(sys.stdin, dts.relations)},\n                  gzip=gzip)\n    # input is sentence file\n    elif os.path.isfile(source):\n        with open(source) as fh:\n            dts.write({'item': _lines_to_rows(fh, dts.relations)},\n                      gzip=gzip)\n    # input is source testsuite\n    elif os.path.isdir(source):\n        sts = itsdb.TestSuite(source)\n        tables = dts.relations.tables if full else itsdb.tsdb_core_files\n        where = '' if where is None else 'where ' + where\n        for table in tables:\n            if sts.size(table) > 0:\n                # filter the data, but use all if the query fails\n                # (e.g., if the filter and table cannot be joined)\n                try:\n                    rows = tsql.select(\n                        '* from {} {}'.format(table, where), sts, cast=False)\n                except itsdb.ItsdbError:\n                    rows = sts[table]\n                dts.write({table: rows}, gzip=gzip)\n    dts.reload()\n    # unless a skeleton was requested, make empty files for other tables\n    if not skeleton:\n        for table in dts.relations:\n            if len(dts[table]) == 0:\n                dts.write({table: []})\n\n    # summarize what was done\n    if sys.stdout.isatty():\n        _red = lambda s: '\\x1b[1;31m{}\\x1b[0m'.format(s)\n    else:\n        _red = lambda s: s\n    fmt = '{:>8} bytes\\t{}'\n    for filename in ['relations'] + list(dts.relations.tables):\n        path = os.path.join(destination, filename)\n        if os.path.isfile(path):\n            stat = os.stat(path)\n            print(fmt.format(stat.st_size, filename))\n        elif os.path.isfile(path + '.gz'):\n            stat = os.stat(path + '.gz')\n            print(fmt.format(stat.st_size, _red(filename + '.gz')))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef repp(file, config=None, module=None, active=None,\n         format=None, trace_level=0):\n    \"\"\"\n    Tokenize with a Regular Expression PreProcessor (REPP).\n\n    Results are printed directly to stdout. If more programmatic\n    access is desired, the :mod:`delphin.repp` module provides a\n    similar interface.\n\n    Args:\n        file (str, file): filename, open file, or stream of sentence\n            inputs\n        config (str): path to a PET REPP configuration (.set) file\n        module (str): path to a top-level REPP module; other modules\n            are found by external group calls\n        active (list): select which modules are active; if `None`, all\n            are used; incompatible with *config* (default: `None`)\n        format (str): the output format (`\"yy\"`, `\"string\"`, `\"line\"`,\n            or `\"triple\"`; default: `\"yy\"`)\n        trace_level (int): if `0` no trace info is printed; if `1`,\n            applied rules are printed, if greather than `1`, both\n            applied and unapplied rules (in order) are printed\n            (default: `0`)\n    \"\"\"\n    from delphin.repp import REPP\n\n    if config is not None and module is not None:\n        raise ValueError(\"cannot specify both 'config' and 'module'\")\n    if config is not None and active:\n        raise ValueError(\"'active' cannot be used with 'config'\")\n    if config:\n        r = REPP.from_config(config)\n    elif module:\n        r = REPP.from_file(module, active=active)\n    else:\n        r = REPP()  # just tokenize\n\n    if hasattr(file, 'read'):\n        for line in file:\n            _repp(r, line, format, trace_level)\n    else:\n        with io.open(file, encoding='utf-8') as fh:\n            for line in fh:\n                _repp(r, line, format, trace_level)", "response": "Tokenize with a Regular Expression PreProcessor."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compare(testsuite, gold, select='i-id i-input mrs'):\n    from delphin.mrs import simplemrs, compare as mrs_compare\n\n    if not isinstance(testsuite, itsdb.TestSuite):\n        if isinstance(testsuite, itsdb.ItsdbProfile):\n            testsuite = testsuite.root\n        testsuite = itsdb.TestSuite(testsuite)\n    if not isinstance(gold, itsdb.TestSuite):\n        if isinstance(gold, itsdb.ItsdbProfile):\n            gold = gold.root\n        gold = itsdb.TestSuite(gold)\n\n    queryobj = tsql.inspect_query('select ' + select)\n    if len(queryobj['projection']) != 3:\n        raise ValueError('select does not return 3 fields: ' + select)\n\n    input_select = '{} {}'.format(queryobj['projection'][0],\n                                  queryobj['projection'][1])\n    i_inputs = dict(tsql.select(input_select, testsuite))\n\n    matched_rows = itsdb.match_rows(\n        tsql.select(select, testsuite),\n        tsql.select(select, gold),\n        0)\n\n    for (key, testrows, goldrows) in matched_rows:\n        (test_unique, shared, gold_unique) = mrs_compare.compare_bags(\n            [simplemrs.loads_one(row[2]) for row in testrows],\n            [simplemrs.loads_one(row[2]) for row in goldrows])\n        yield {'id': key,\n               'input': i_inputs[key],\n               'test': test_unique,\n               'shared': shared,\n               'gold': gold_unique}", "response": "Compare two sets of items in a set of items."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef non_argument_modifiers(role='ARG1', only_connecting=True):\n    def func(xmrs, deps):\n        edges = []\n        for src in deps:\n            for _, tgt in deps[src]:\n                edges.append((src, tgt))\n        components = _connected_components(xmrs.nodeids(), edges)\n\n        ccmap = {}\n        for i, component in enumerate(components):\n            for n in component:\n                ccmap[n] = i\n\n        addl = {}\n        if not only_connecting or len(components) > 1:\n            lsh = xmrs.labelset_heads\n            lblheads = {v: lsh(v) for v, vd in xmrs._vars.items()\n                        if 'LBL' in vd['refs']}\n            for heads in lblheads.values():\n                if len(heads) > 1:\n                    first = heads[0]\n                    joined = set([ccmap[first]])\n                    for other in heads[1:]:\n                        occ = ccmap[other]\n                        srt = var_sort(xmrs.args(other).get(role, 'u0'))\n                        needs_edge = not only_connecting or occ not in joined\n                        edge_available = srt == 'u'\n                        if needs_edge and edge_available:\n                            addl.setdefault(other, []).append((role, first))\n                            joined.add(occ)\n        return addl\n\n    return func", "response": "Returns a function that returns a mapping of non - argument modifier dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dumps(ms, single=False,\n          properties=False, pretty_print=True,\n          show_status=False, predicate_modifiers=False, **kwargs):\n    \"\"\"\n    Serialize an Xmrs object to a Eds representation\n\n    Args:\n        ms: an iterator of :class:`~delphin.mrs.xmrs.Xmrs` objects to\n            serialize (unless the *single* option is `True`)\n        single (bool): if `True`, treat *ms* as a single\n            :class:`~delphin.mrs.xmrs.Xmrs` object instead of as an\n            iterator\n        properties (bool): if `False`, suppress variable properties\n        pretty_print (bool): if `True`, add newlines and indentation\n        show_status (bool): if `True`, annotate disconnected graphs and\n            nodes\n    Returns:\n        an :class:`Eds` string representation of a corpus of Xmrs\n    \"\"\"\n    if not pretty_print and kwargs.get('indent'):\n        pretty_print = True\n    if single:\n        ms = [ms]\n    return serialize(\n        ms,\n        properties=properties,\n        pretty_print=pretty_print,\n        show_status=show_status,\n        predicate_modifiers=predicate_modifiers,\n        **kwargs\n    )", "response": "Serialize an Xmrs object to an Eds representation of a corpus of Xmrs objects."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nodes(self):\n        getnode = self._nodes.__getitem__\n        return [getnode(nid) for nid in self._nodeids]", "response": "Return the list of nodes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nencode the Eds as a dictionary suitable for JSON serialization.", "response": "def to_dict(self, properties=True):\n        \"\"\"\n        Encode the Eds as a dictionary suitable for JSON serialization.\n        \"\"\"\n        nodes = {}\n        for node in self.nodes():\n            nd = {\n                'label': node.pred.short_form(),\n                'edges': self.edges(node.nodeid)\n            }\n            if node.lnk is not None:\n                nd['lnk'] = {'from': node.cfrom, 'to': node.cto}\n            if properties:\n                if node.cvarsort is not None:\n                    nd['type'] = node.cvarsort\n                props = node.properties\n                if props:\n                    nd['properties'] = props\n            if node.carg is not None:\n                nd['carg'] = node.carg\n            nodes[node.nodeid] = nd\n        return {'top': self.top, 'nodes': nodes}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_dict(cls, d):\n        makepred, charspan = Pred.surface_or_abstract, Lnk.charspan\n        top = d.get('top')\n        nodes, edges = [], []\n        for nid, node in d.get('nodes', {}).items():\n            props = node.get('properties', {})\n            if 'type' in node:\n                props[CVARSORT] = node['type']\n            if not props:\n                props = None\n            lnk = None\n            if 'lnk' in node:\n                lnk = charspan(node['lnk']['from'], node['lnk']['to'])\n            nodes.append(\n                Node(\n                    nodeid=nid,\n                    pred=makepred(node['label']),\n                    sortinfo=props,\n                    lnk=lnk,\n                    carg=node.get('carg')\n                )\n            )\n            edges.extend(\n                (nid, rargname, tgtnid)\n                for rargname, tgtnid in node.get('edges', {}).items()\n            )\n        nodes.sort(key=lambda n: (n.cfrom, -n.cto))\n        return cls(top, nodes=nodes, edges=edges)", "response": "Decode a dictionary into an Eds object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nencoding the Eds as triples suitable for PENMAN serialization.", "response": "def to_triples(self, short_pred=True, properties=True):\n        \"\"\"\n        Encode the Eds as triples suitable for PENMAN serialization.\n        \"\"\"\n        node_triples, edge_triples = [], []\n        # sort nodeids just so top var is first\n        nodes = sorted(self.nodes(), key=lambda n: n.nodeid != self.top)\n        for node in nodes:\n            nid = node.nodeid\n            pred = node.pred.short_form() if short_pred else node.pred.string\n            node_triples.append((nid, 'predicate', pred))\n            if node.lnk:\n                node_triples.append((nid, 'lnk', '\"{}\"'.format(str(node.lnk))))\n            if node.carg:\n                node_triples.append((nid, 'carg', '\"{}\"'.format(node.carg)))\n            if properties:\n                if node.cvarsort is not None:\n                    node_triples.append((nid, 'type', node.cvarsort))\n                props = node.properties\n                node_triples.extend((nid, p, v) for p, v in props.items())\n            edge_triples.extend(\n                (nid, rargname, tgt)\n                for rargname, tgt in sorted(\n                    self.edges(nid).items(),\n                    key=lambda x: rargname_sortkey(x[0])\n                )\n            )\n        return node_triples + edge_triples"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_triples(cls, triples):\n        nids, nd, edges = [], {}, []\n        for src, rel, tgt in triples:\n            if src not in nd:\n                nids.append(src)\n                nd[src] = {'pred': None, 'lnk': None, 'carg': None, 'si': []}\n            if rel == 'predicate':\n                nd[src]['pred'] = Pred.surface_or_abstract(tgt)\n            elif rel == 'lnk':\n                cfrom, cto = tgt.strip('\"<>').split(':')\n                nd[src]['lnk'] = Lnk.charspan(int(cfrom), int(cto))\n            elif rel == 'carg':\n                if (tgt[0], tgt[-1]) == ('\"', '\"'):\n                    tgt = tgt[1:-1]\n                nd[src]['carg'] = tgt\n            elif rel == 'type':\n                nd[src]['si'].append((CVARSORT, tgt))\n            elif rel.islower():\n                nd[src]['si'].append((rel, tgt))\n            else:\n                edges.append((src, rel, tgt))\n        nodes = [\n            Node(\n                nodeid=nid,\n                pred=nd[nid]['pred'],\n                sortinfo=nd[nid]['si'],\n                lnk=nd[nid]['lnk'],\n                carg=nd[nid]['carg']\n            ) for nid in nids\n        ]\n        top = nids[0] if nids else None\n        return cls(top=top, nodes=nodes, edges=edges)", "response": "Decode triples as from _to_triples_ into an Eds object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef next(self, skip=None):\n        buffer = self._buffer\n        popleft = buffer.popleft\n        if skip is not None:\n            while True:\n                try:\n                    if not skip(buffer[0]):\n                        break\n                    popleft()\n                except IndexError:\n                    self._buffer_fill()\n        try:\n            datum = popleft()\n        except IndexError:\n            self._buffer_fill()\n            datum = popleft()\n        return datum", "response": "Returns the next datum in the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef peek(self, n=0, skip=None, drop=False):\n        buffer = self._buffer\n        popleft = buffer.popleft\n        datum = None\n        if skip is not None:\n            stack = []\n            stackpush = stack.append\n            while n >= 0:\n                try:\n                    datum = popleft()\n                except IndexError:\n                    self._buffer_fill()\n                    datum = popleft()\n                if not skip(datum):\n                    n -= 1\n                    stackpush(datum)\n                elif not drop:\n                    stackpush(datum)\n            buffer.extendleft(reversed(stack))\n        else:\n            self._buffer_fill(n + 1)\n            datum = buffer[n]\n        return datum", "response": "Return the n th datum from the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nserialize this InlineQueryResultPhoto to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineQueryResultPhoto to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineQueryResultPhoto, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['photo_url'] = u(self.photo_url)  # py2: type unicode, py3: type str\n\n        array['thumb_url'] = u(self.thumb_url)  # py2: type unicode, py3: type str\n\n        if self.photo_width is not None:\n            array['photo_width'] = int(self.photo_width)  # type int\n        if self.photo_height is not None:\n            array['photo_height'] = int(self.photo_height)  # type int\n        if self.title is not None:\n            array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        if self.description is not None:\n            array['description'] = u(self.description)  # py2: type unicode, py3: type str\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserializes this InlineQueryResultMpeg4Gif to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineQueryResultMpeg4Gif to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineQueryResultMpeg4Gif, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['mpeg4_url'] = u(self.mpeg4_url)  # py2: type unicode, py3: type str\n\n        array['thumb_url'] = u(self.thumb_url)  # py2: type unicode, py3: type str\n\n        if self.mpeg4_width is not None:\n            array['mpeg4_width'] = int(self.mpeg4_width)  # type int\n        if self.mpeg4_height is not None:\n            array['mpeg4_height'] = int(self.mpeg4_height)  # type int\n        if self.mpeg4_duration is not None:\n            array['mpeg4_duration'] = int(self.mpeg4_duration)  # type int\n        if self.title is not None:\n            array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nserialize this InlineQueryResultVideo to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineQueryResultVideo to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineQueryResultVideo, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['video_url'] = u(self.video_url)  # py2: type unicode, py3: type str\n\n        array['mime_type'] = u(self.mime_type)  # py2: type unicode, py3: type str\n\n        array['thumb_url'] = u(self.thumb_url)  # py2: type unicode, py3: type str\n\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.video_width is not None:\n            array['video_width'] = int(self.video_width)  # type int\n        if self.video_height is not None:\n            array['video_height'] = int(self.video_height)  # type int\n        if self.video_duration is not None:\n            array['video_duration'] = int(self.video_duration)  # type int\n        if self.description is not None:\n            array['description'] = u(self.description)  # py2: type unicode, py3: type str\n\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nserializes this InlineQueryResultVoice to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineQueryResultVoice to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineQueryResultVoice, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['voice_url'] = u(self.voice_url)  # py2: type unicode, py3: type str\n\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.voice_duration is not None:\n            array['voice_duration'] = int(self.voice_duration)  # type int\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_array(self):\n        array = super(InlineQueryResultDocument, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        array['document_url'] = u(self.document_url)  # py2: type unicode, py3: type str\n\n        array['mime_type'] = u(self.mime_type)  # py2: type unicode, py3: type str\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.description is not None:\n            array['description'] = u(self.description)  # py2: type unicode, py3: type str\n\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n\n        if self.thumb_url is not None:\n            array['thumb_url'] = u(self.thumb_url)  # py2: type unicode, py3: type str\n\n        if self.thumb_width is not None:\n            array['thumb_width'] = int(self.thumb_width)  # type int\n        if self.thumb_height is not None:\n            array['thumb_height'] = int(self.thumb_height)  # type int\n        return array", "response": "Serializes this InlineQueryResultDocument to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(InlineQueryResultVenue, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['latitude'] = float(self.latitude)  # type float\n        array['longitude'] = float(self.longitude)  # type float\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        array['address'] = u(self.address)  # py2: type unicode, py3: type str\n\n        if self.foursquare_id is not None:\n            array['foursquare_id'] = u(self.foursquare_id)  # py2: type unicode, py3: type str\n\n        if self.foursquare_type is not None:\n            array['foursquare_type'] = u(self.foursquare_type)  # py2: type unicode, py3: type str\n\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n\n        if self.thumb_url is not None:\n            array['thumb_url'] = u(self.thumb_url)  # py2: type unicode, py3: type str\n\n        if self.thumb_width is not None:\n            array['thumb_width'] = int(self.thumb_width)  # type int\n        if self.thumb_height is not None:\n            array['thumb_height'] = int(self.thumb_height)  # type int\n        return array", "response": "Serializes this InlineQueryResultVenue to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nserializing this InlineQueryResultGame to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineQueryResultGame to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineQueryResultGame, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['game_short_name'] = u(self.game_short_name)  # py2: type unicode, py3: type str\n\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nserialize this InlineQueryResultCachedPhoto to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineQueryResultCachedPhoto to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineQueryResultCachedPhoto, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['photo_file_id'] = u(self.photo_file_id)  # py2: type unicode, py3: type str\n\n        if self.title is not None:\n            array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        if self.description is not None:\n            array['description'] = u(self.description)  # py2: type unicode, py3: type str\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nserializes this InlineQueryResultCachedMpeg4Gif to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineQueryResultCachedMpeg4Gif to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineQueryResultCachedMpeg4Gif, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['mpeg4_file_id'] = u(self.mpeg4_file_id)  # py2: type unicode, py3: type str\n\n        if self.title is not None:\n            array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_array(self):\n        array = super(InlineQueryResultCachedSticker, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['sticker_file_id'] = u(self.sticker_file_id)  # py2: type unicode, py3: type str\n\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n\n        return array", "response": "Serializes this InlineQueryResultCachedSticker to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nserializes this InlineQueryResultCachedVideo to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineQueryResultCachedVideo to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineQueryResultCachedVideo, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['video_file_id'] = u(self.video_file_id)  # py2: type unicode, py3: type str\n\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        if self.description is not None:\n            array['description'] = u(self.description)  # py2: type unicode, py3: type str\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_array(self):\n        array = super(InlineQueryResultCachedAudio, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n\n        array['audio_file_id'] = u(self.audio_file_id)  # py2: type unicode, py3: type str\n\n        if self.caption is not None:\n            array['caption'] = u(self.caption)  # py2: type unicode, py3: type str\n\n        if self.parse_mode is not None:\n            array['parse_mode'] = u(self.parse_mode)  # py2: type unicode, py3: type str\n\n        if self.reply_markup is not None:\n            array['reply_markup'] = self.reply_markup.to_array()  # type InlineKeyboardMarkup\n\n        if self.input_message_content is not None:\n            array['input_message_content'] = self.input_message_content.to_array()  # type InputMessageContent\n\n        return array", "response": "Serializes this InlineQueryResultCachedAudio to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_array(self):\n        array = super(MessageEntity, self).to_array()\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['offset'] = int(self.offset)  # type int\n        array['length'] = int(self.length)  # type int\n        if self.url is not None:\n            array['url'] = u(self.url)  # py2: type unicode, py3: type str\n\n        if self.user is not None:\n            array['user'] = self.user.to_array()  # type User\n\n        return array", "response": "Serializes this MessageEntity to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_array(self):\n        array = super(PhotoSize, self).to_array()\n        array['file_id'] = u(self.file_id)  # py2: type unicode, py3: type str\n\n        array['width'] = int(self.width)  # type int\n        array['height'] = int(self.height)  # type int\n        if self.file_size is not None:\n            array['file_size'] = int(self.file_size)  # type int\n        return array", "response": "Serializes this PhotoSize to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserializes this Audio to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this Audio to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(Audio, self).to_array()\n        array['file_id'] = u(self.file_id)  # py2: type unicode, py3: type str\n\n        array['duration'] = int(self.duration)  # type int\n        if self.performer is not None:\n            array['performer'] = u(self.performer)  # py2: type unicode, py3: type str\n\n        if self.title is not None:\n            array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        if self.mime_type is not None:\n            array['mime_type'] = u(self.mime_type)  # py2: type unicode, py3: type str\n\n        if self.file_size is not None:\n            array['file_size'] = int(self.file_size)  # type int\n        if self.thumb is not None:\n            array['thumb'] = self.thumb.to_array()  # type PhotoSize\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.media import PhotoSize\n        \n\n        data = {}\n        data['file_id'] = u(array.get('file_id'))\n        data['duration'] = int(array.get('duration'))\n        data['performer'] = u(array.get('performer')) if array.get('performer') is not None else None\n        data['title'] = u(array.get('title')) if array.get('title') is not None else None\n        data['mime_type'] = u(array.get('mime_type')) if array.get('mime_type') is not None else None\n        data['file_size'] = int(array.get('file_size')) if array.get('file_size') is not None else None\n        data['thumb'] = PhotoSize.from_array(array.get('thumb')) if array.get('thumb') is not None else None\n        data['_raw'] = array\n        return Audio(**data)", "response": "Deserialize a new Audio from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_array(self):\n        array = super(Document, self).to_array()\n        array['file_id'] = u(self.file_id)  # py2: type unicode, py3: type str\n\n        if self.thumb is not None:\n            array['thumb'] = self.thumb.to_array()  # type PhotoSize\n\n        if self.file_name is not None:\n            array['file_name'] = u(self.file_name)  # py2: type unicode, py3: type str\n\n        if self.mime_type is not None:\n            array['mime_type'] = u(self.mime_type)  # py2: type unicode, py3: type str\n\n        if self.file_size is not None:\n            array['file_size'] = int(self.file_size)  # type int\n        return array", "response": "Serializes this Document to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(Animation, self).to_array()\n        array['file_id'] = u(self.file_id)  # py2: type unicode, py3: type str\n\n        array['width'] = int(self.width)  # type int\n        array['height'] = int(self.height)  # type int\n        array['duration'] = int(self.duration)  # type int\n        if self.thumb is not None:\n            array['thumb'] = self.thumb.to_array()  # type PhotoSize\n\n        if self.file_name is not None:\n            array['file_name'] = u(self.file_name)  # py2: type unicode, py3: type str\n\n        if self.mime_type is not None:\n            array['mime_type'] = u(self.mime_type)  # py2: type unicode, py3: type str\n\n        if self.file_size is not None:\n            array['file_size'] = int(self.file_size)  # type int\n        return array", "response": "Serializes this Animation to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nserializing this Voice to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this Voice to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(Voice, self).to_array()\n        array['file_id'] = u(self.file_id)  # py2: type unicode, py3: type str\n\n        array['duration'] = int(self.duration)  # type int\n        if self.mime_type is not None:\n            array['mime_type'] = u(self.mime_type)  # py2: type unicode, py3: type str\n\n        if self.file_size is not None:\n            array['file_size'] = int(self.file_size)  # type int\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_array(self):\n        array = super(VideoNote, self).to_array()\n        array['file_id'] = u(self.file_id)  # py2: type unicode, py3: type str\n\n        array['length'] = int(self.length)  # type int\n        array['duration'] = int(self.duration)  # type int\n        if self.thumb is not None:\n            array['thumb'] = self.thumb.to_array()  # type PhotoSize\n\n        if self.file_size is not None:\n            array['file_size'] = int(self.file_size)  # type int\n        return array", "response": "Serializes this VideoNote to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nserialize this Contact to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this Contact to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(Contact, self).to_array()\n        array['phone_number'] = u(self.phone_number)  # py2: type unicode, py3: type str\n\n        array['first_name'] = u(self.first_name)  # py2: type unicode, py3: type str\n\n        if self.last_name is not None:\n            array['last_name'] = u(self.last_name)  # py2: type unicode, py3: type str\n\n        if self.user_id is not None:\n            array['user_id'] = int(self.user_id)  # type int\n        if self.vcard is not None:\n            array['vcard'] = u(self.vcard)  # py2: type unicode, py3: type str\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_array(self):\n        array = super(Location, self).to_array()\n        array['longitude'] = float(self.longitude)  # type float\n        array['latitude'] = float(self.latitude)  # type float\n        return array", "response": "Serializes this Location to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['longitude'] = float(array.get('longitude'))\n        data['latitude'] = float(array.get('latitude'))\n        data['_raw'] = array\n        return Location(**data)", "response": "Deserialize a new Location instance from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_array(self):\n        array = super(Venue, self).to_array()\n        array['location'] = self.location.to_array()  # type Location\n\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        array['address'] = u(self.address)  # py2: type unicode, py3: type str\n\n        if self.foursquare_id is not None:\n            array['foursquare_id'] = u(self.foursquare_id)  # py2: type unicode, py3: type str\n\n        if self.foursquare_type is not None:\n            array['foursquare_type'] = u(self.foursquare_type)  # py2: type unicode, py3: type str\n\n        return array", "response": "Serializes this Venue to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.media import Location\n        \n\n        data = {}\n        data['location'] = Location.from_array(array.get('location'))\n        data['title'] = u(array.get('title'))\n        data['address'] = u(array.get('address'))\n        data['foursquare_id'] = u(array.get('foursquare_id')) if array.get('foursquare_id') is not None else None\n        data['foursquare_type'] = u(array.get('foursquare_type')) if array.get('foursquare_type') is not None else None\n        data['_raw'] = array\n        return Venue(**data)", "response": "Deserialize a new Venue from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_array(self):\n        array = super(UserProfilePhotos, self).to_array()\n        array['total_count'] = int(self.total_count)  # type int\n        array['photos'] = self._as_array(self.photos)  # type list of list of PhotoSize\n\n        return array", "response": "Serializes this UserProfilePhotos to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.media import PhotoSize\n        \n\n        data = {}\n        data['total_count'] = int(array.get('total_count'))\n        data['photos'] = PhotoSize.from_array_list(array.get('photos'), list_level=2)\n        data['_raw'] = array\n        return UserProfilePhotos(**data)", "response": "Deserialize a new UserProfilePhotos instance from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_array(self):\n        array = super(File, self).to_array()\n        array['file_id'] = u(self.file_id)  # py2: type unicode, py3: type str\n\n        if self.file_size is not None:\n            array['file_size'] = int(self.file_size)  # type int\n        if self.file_path is not None:\n            array['file_path'] = u(self.file_path)  # py2: type unicode, py3: type str\n\n        return array", "response": "Serializes this File to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_array(self):\n        array = super(ChatPhoto, self).to_array()\n        array['small_file_id'] = u(self.small_file_id)  # py2: type unicode, py3: type str\n\n        array['big_file_id'] = u(self.big_file_id)  # py2: type unicode, py3: type str\n\n        return array", "response": "Serializes this ChatPhoto to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nserialize this Sticker to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this Sticker to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(Sticker, self).to_array()\n        array['file_id'] = u(self.file_id)  # py2: type unicode, py3: type str\n\n        array['width'] = int(self.width)  # type int\n        array['height'] = int(self.height)  # type int\n        if self.thumb is not None:\n            array['thumb'] = self.thumb.to_array()  # type PhotoSize\n\n        if self.emoji is not None:\n            array['emoji'] = u(self.emoji)  # py2: type unicode, py3: type str\n\n        if self.set_name is not None:\n            array['set_name'] = u(self.set_name)  # py2: type unicode, py3: type str\n\n        if self.mask_position is not None:\n            array['mask_position'] = self.mask_position.to_array()  # type MaskPosition\n\n        if self.file_size is not None:\n            array['file_size'] = int(self.file_size)  # type int\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.media import PhotoSize\n        from pytgbot.api_types.receivable.stickers import MaskPosition\n        \n\n        data = {}\n        data['file_id'] = u(array.get('file_id'))\n        data['width'] = int(array.get('width'))\n        data['height'] = int(array.get('height'))\n        data['thumb'] = PhotoSize.from_array(array.get('thumb')) if array.get('thumb') is not None else None\n        data['emoji'] = u(array.get('emoji')) if array.get('emoji') is not None else None\n        data['set_name'] = u(array.get('set_name')) if array.get('set_name') is not None else None\n        data['mask_position'] = MaskPosition.from_array(array.get('mask_position')) if array.get('mask_position') is not None else None\n        data['file_size'] = int(array.get('file_size')) if array.get('file_size') is not None else None\n        data['_raw'] = array\n        return Sticker(**data)", "response": "Deserialize a new Sticker from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(Game, self).to_array()\n        array['title'] = u(self.title)  # py2: type unicode, py3: type str\n\n        array['description'] = u(self.description)  # py2: type unicode, py3: type str\n\n        array['photo'] = self._as_array(self.photo)  # type list of PhotoSize\n\n        if self.text is not None:\n            array['text'] = u(self.text)  # py2: type unicode, py3: type str\n\n        if self.text_entities is not None:\n            array['text_entities'] = self._as_array(self.text_entities)  # type list of MessageEntity\n\n        if self.animation is not None:\n            array['animation'] = self.animation.to_array()  # type Animation\n\n        return array", "response": "Serializes this Game to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.media import Animation\n        from pytgbot.api_types.receivable.media import MessageEntity\n        from pytgbot.api_types.receivable.media import PhotoSize\n        \n\n        data = {}\n        data['title'] = u(array.get('title'))\n        data['description'] = u(array.get('description'))\n        data['photo'] = PhotoSize.from_array_list(array.get('photo'), list_level=1)\n        data['text'] = u(array.get('text')) if array.get('text') is not None else None\n        data['text_entities'] = MessageEntity.from_array_list(array.get('text_entities'), list_level=1) if array.get('text_entities') is not None else None\n        data['animation'] = Animation.from_array(array.get('animation')) if array.get('animation') is not None else None\n        data['_raw'] = array\n        return Game(**data)", "response": "Deserialize a new Game from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_array(array):\n        data = super(DownloadableMedia).from_array(array)\n        data[\"file_id\"] = array.get(\"file_id\")\n        data[\"file_size\"] = array.get(\"file_size\")  # can be None\n        return data", "response": "Subclass for all : class:`Media which has a file_id and file_size attribute extracted from the array."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from .stickers import MaskPosition\n\n        data = {}\n        data['file_id'] = u(array.get('file_id'))\n        data['width'] = int(array.get('width'))\n        data['height'] = int(array.get('height'))\n        data['thumb'] = PhotoSize.from_array(array.get('thumb')) if array.get('thumb') is not None else None\n        data['emoji'] = u(array.get('emoji')) if array.get('emoji') is not None else None\n        data['set_name'] = u(array.get('set_name')) if array.get('set_name') is not None else None\n        data['mask_position'] = MaskPosition.from_array(array.get('mask_position')) if array.get(\n            'mask_position') is not None else None\n        data['file_size'] = int(array.get('file_size')) if array.get('file_size') is not None else None\n        data['_raw'] = array\n        return Sticker(**data)", "response": "Deserialize a new Sticker from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['file_id'] = u(array.get('file_id'))\n        data['length'] = int(array.get('length'))\n        data['duration'] = int(array.get('duration'))\n        data['thumb'] = PhotoSize.from_array(array.get('thumb')) if array.get('thumb') is not None else None\n        data['file_size'] = int(array.get('file_size')) if array.get('file_size') is not None else None\n        data['_raw'] = array\n        return VideoNote(**data)", "response": "Deserialize a new VideoNote from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['total_count'] = int(array.get('total_count'))\n        data['photos'] = PhotoSize.from_array_list(array.get('photos'), list_level=2)\n        data['_raw'] = array\n        return UserProfilePhotos(**data)", "response": "Deserialize a new UserProfilePhotos instance from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(ReplyKeyboardMarkup, self).to_array()\n        array['keyboard'] = self._as_array(self.keyboard)  # type list of list of KeyboardButton\n\n        if self.resize_keyboard is not None:\n            array['resize_keyboard'] = bool(self.resize_keyboard)  # type bool\n        if self.one_time_keyboard is not None:\n            array['one_time_keyboard'] = bool(self.one_time_keyboard)  # type bool\n        if self.selective is not None:\n            array['selective'] = bool(self.selective)  # type bool\n        return array", "response": "Serializes this ReplyKeyboardMarkup to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_array(self):\n        array = super(KeyboardButton, self).to_array()\n        array['text'] = u(self.text)  # py2: type unicode, py3: type str\n\n        if self.request_contact is not None:\n            array['request_contact'] = bool(self.request_contact)  # type bool\n        if self.request_location is not None:\n            array['request_location'] = bool(self.request_location)  # type bool\n        return array", "response": "Serializes this KeyboardButton to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['text'] = u(array.get('text'))\n        data['request_contact'] = bool(array.get('request_contact')) if array.get('request_contact') is not None else None\n        data['request_location'] = bool(array.get('request_location')) if array.get('request_location') is not None else None\n        \n        instance = KeyboardButton(**data)\n        instance._raw = array\n        return instance", "response": "Deserialize a new KeyboardButton from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nserialize this ReplyKeyboardRemove to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this ReplyKeyboardRemove to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(ReplyKeyboardRemove, self).to_array()\n        array['remove_keyboard'] = bool(self.remove_keyboard)  # type bool\n        if self.selective is not None:\n            array['selective'] = bool(self.selective)  # type bool\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserializes this InlineKeyboardMarkup to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this InlineKeyboardMarkup to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(InlineKeyboardMarkup, self).to_array()\n        array['inline_keyboard'] = self._as_array(self.inline_keyboard)  # type list of list of InlineKeyboardButton\n\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_array(self):\n        array = super(InlineKeyboardButton, self).to_array()\n        array['text'] = u(self.text)  # py2: type unicode, py3: type str\n\n        if self.url is not None:\n            array['url'] = u(self.url)  # py2: type unicode, py3: type str\n\n        if self.callback_data is not None:\n            array['callback_data'] = u(self.callback_data)  # py2: type unicode, py3: type str\n\n        if self.switch_inline_query is not None:\n            array['switch_inline_query'] = u(self.switch_inline_query)  # py2: type unicode, py3: type str\n\n        if self.switch_inline_query_current_chat is not None:\n            array['switch_inline_query_current_chat'] = u(self.switch_inline_query_current_chat)  # py2: type unicode, py3: type str\n\n        if self.callback_game is not None:\n            array['callback_game'] = self.callback_game.to_array()  # type CallbackGame\n\n        if self.pay is not None:\n            array['pay'] = bool(self.pay)  # type bool\n        return array", "response": "Serializes this InlineKeyboardButton to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.updates import CallbackGame\n        \n\n        data = {}\n        data['text'] = u(array.get('text'))\n        data['url'] = u(array.get('url')) if array.get('url') is not None else None\n        data['callback_data'] = u(array.get('callback_data')) if array.get('callback_data') is not None else None\n        data['switch_inline_query'] = u(array.get('switch_inline_query')) if array.get('switch_inline_query') is not None else None\n        data['switch_inline_query_current_chat'] = u(array.get('switch_inline_query_current_chat')) if array.get('switch_inline_query_current_chat') is not None else None\n        data['callback_game'] = CallbackGame.from_array(array.get('callback_game')) if array.get('callback_game') is not None else None\n        data['pay'] = bool(array.get('pay')) if array.get('pay') is not None else None\n        \n        instance = InlineKeyboardButton(**data)\n        instance._raw = array\n        return instance", "response": "Deserialize a new InlineKeyboardButton from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_array(self):\n        array = super(ForceReply, self).to_array()\n        array['force_reply'] = bool(self.force_reply)  # type bool\n        if self.selective is not None:\n            array['selective'] = bool(self.selective)  # type bool\n        return array", "response": "Serializes this ForceReply to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['force_reply'] = bool(array.get('force_reply'))\n        data['selective'] = bool(array.get('selective')) if array.get('selective') is not None else None\n        \n        instance = ForceReply(**data)\n        instance._raw = array\n        return instance", "response": "Deserialize a new ForceReply from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nserializing this PassportElementErrorDataField to a dictionary.", "response": "def to_array(self):\n        \"\"\"\n        Serializes this PassportElementErrorDataField to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n        array = super(PassportElementErrorDataField, self).to_array()\n        array['source'] = u(self.source)  # py2: type unicode, py3: type str\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n        array['field_name'] = u(self.field_name)  # py2: type unicode, py3: type str\n        array['data_hash'] = u(self.data_hash)  # py2: type unicode, py3: type str\n        array['message'] = u(self.message)  # py2: type unicode, py3: type str\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_array(self):\n        array = super(PassportElementErrorReverseSide, self).to_array()\n        array['source'] = u(self.source)  # py2: type unicode, py3: type str\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n        array['file_hash'] = u(self.file_hash)  # py2: type unicode, py3: type str\n        array['message'] = u(self.message)  # py2: type unicode, py3: type str\n        return array", "response": "Serializes this PassportElementErrorReverseSide to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_array(self):\n        array = super(PassportElementErrorFiles, self).to_array()\n        array['source'] = u(self.source)  # py2: type unicode, py3: type str\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n        array['file_hashes'] = self._as_array(self.file_hashes)  # type list of str\n        array['message'] = u(self.message)  # py2: type unicode, py3: type str\n        return array", "response": "Serializes this PassportElementErrorFiles to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['source'] = u(array.get('source'))\n        data['type'] = u(array.get('type'))\n        data['file_hashes'] = PassportElementErrorFiles._builtin_from_array_list(required_type=unicode_type, value=array.get('file_hashes'), list_level=1)\n        data['message'] = u(array.get('message'))\n\n        instance = PassportElementErrorFiles(**data)\n        instance._raw = array\n        return instance", "response": "Deserialize a new PassportElementErrorFiles instance from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_array(self):\n        array = super(PassportElementErrorUnspecified, self).to_array()\n        array['source'] = u(self.source)  # py2: type unicode, py3: type str\n\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n\n        array['element_hash'] = u(self.element_hash)  # py2: type unicode, py3: type str\n\n        array['message'] = u(self.message)  # py2: type unicode, py3: type str\n\n        return array", "response": "Serializes this PassportElementErrorUnspecified to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_array(self):\n        array = super(InlineQuery, self).to_array()\n        array['id'] = u(self.id)  # py2: type unicode, py3: type str\n        array['from'] = self.from_peer.to_array()  # type User\n        array['query'] = u(self.query)  # py2: type unicode, py3: type str\n        array['offset'] = u(self.offset)  # py2: type unicode, py3: type str\n        if self.location is not None:\n            array['location'] = self.location.to_array()  # type Location\n        return array", "response": "Serializes this InlineQuery to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.media import Location\n        from pytgbot.api_types.receivable.peer import User\n\n        data = {}\n        data['id'] = u(array.get('id'))\n        data['from_peer'] = User.from_array(array.get('from'))\n        data['query'] = u(array.get('query'))\n        data['offset'] = u(array.get('offset'))\n        data['location'] = Location.from_array(array.get('location')) if array.get('location') is not None else None\n        data['_raw'] = array\n        return InlineQuery(**data)", "response": "Deserialize a new InlineQuery instance from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_array(self):\n        array = super(ChosenInlineResult, self).to_array()\n        array['result_id'] = u(self.result_id)  # py2: type unicode, py3: type str\n        array['from'] = self.from_peer.to_array()  # type User\n        array['query'] = u(self.query)  # py2: type unicode, py3: type str\n        if self.location is not None:\n            array['location'] = self.location.to_array()  # type Location\n        if self.inline_message_id is not None:\n            array['inline_message_id'] = u(self.inline_message_id)  # py2: type unicode, py3: type str\n        return array", "response": "Serializes this ChosenInlineResult to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n        from pytgbot.api_types.receivable.inline import ChosenInlineResult\n        from pytgbot.api_types.receivable.inline import InlineQuery\n        from pytgbot.api_types.receivable.payments import PreCheckoutQuery\n        from pytgbot.api_types.receivable.payments import ShippingQuery\n        from pytgbot.api_types.receivable.updates import CallbackQuery\n        from pytgbot.api_types.receivable.updates import Message\n        \n\n        data = {}\n        data['update_id'] = int(array.get('update_id'))\n        data['message'] = Message.from_array(array.get('message')) if array.get('message') is not None else None\n        data['edited_message'] = Message.from_array(array.get('edited_message')) if array.get('edited_message') is not None else None\n        data['channel_post'] = Message.from_array(array.get('channel_post')) if array.get('channel_post') is not None else None\n        data['edited_channel_post'] = Message.from_array(array.get('edited_channel_post')) if array.get('edited_channel_post') is not None else None\n        data['inline_query'] = InlineQuery.from_array(array.get('inline_query')) if array.get('inline_query') is not None else None\n        data['chosen_inline_result'] = ChosenInlineResult.from_array(array.get('chosen_inline_result')) if array.get('chosen_inline_result') is not None else None\n        data['callback_query'] = CallbackQuery.from_array(array.get('callback_query')) if array.get('callback_query') is not None else None\n        data['shipping_query'] = ShippingQuery.from_array(array.get('shipping_query')) if array.get('shipping_query') is not None else None\n        data['pre_checkout_query'] = PreCheckoutQuery.from_array(array.get('pre_checkout_query')) if array.get('pre_checkout_query') is not None else None\n        data['_raw'] = array\n        return Update(**data)", "response": "Deserialize a new Update from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_dict(cls, d):\n        return cls(\n            d['id'],\n            d['start'],\n            d['end'],\n            Lnk.charspan(d['from'], d['to']) if 'from' in d else None,\n            # d.get('paths', [1]),\n            form=d['form'],\n            surface=d.get('surface'),\n            # ipos=\n            # lrules=\n            pos=zip(d.get('tags', []), d.get('probabilities', []))\n        )", "response": "Decode from a dictionary as from : meth : to_dict."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_dict(self):\n        d = {\n            'id': self.id,\n            'start': self.start,\n            'end': self.end,\n            'form': self.form\n        }\n        if self.lnk is not None:\n            cfrom, cto = self.lnk.data\n            d['from'] = cfrom\n            d['to'] = cto\n        # d['paths'] = self.paths\n        if self.surface is not None:\n            d['surface'] = self.surface\n        # d['ipos'] = self.ipos\n        # d['lrules'] = self.lrules\n        if self.pos:\n            d['tags'] = [ps[0] for ps in self.pos]\n            d['probabilities'] = [ps[1] for ps in self.pos]\n        return d", "response": "Encode the token as a dictionary suitable for JSON serialization."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndecodes from the YY token lattice format.", "response": "def from_string(cls, s):\n        \"\"\"\n        Decode from the YY token lattice format.\n        \"\"\"\n        def _qstrip(s):\n            return s[1:-1]  # remove assumed quote characters\n        tokens = []\n        for match in _yy_re.finditer(s):\n            d = match.groupdict()\n            lnk, pos = None, []\n            if d['lnkfrom'] is not None:\n                lnk = Lnk.charspan(d['lnkfrom'], d['lnkto'])\n            if d['pos'] is not None:\n                ps = d['pos'].strip().split()\n                pos = list(zip(map(_qstrip, ps[::2]), map(float, ps[1::2])))\n            tokens.append(\n                YyToken(\n                    int(d['id']),\n                    int(d['start']),\n                    int(d['end']),\n                    lnk,\n                    list(map(int, d['paths'].strip().split())),\n                    _qstrip(d['form']),\n                    None if d['surface'] is None else _qstrip(d['surface']),\n                    int(d['ipos']),\n                    list(map(_qstrip, d['lrules'].strip().split())),\n                    pos\n                )\n            )\n        return cls(tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(fh, single=False, version=_default_version,\n         strict=False, errors='warn'):\n    \"\"\"\n    Deserialize SimpleMRSs from a file (handle or filename)\n\n    Args:\n        fh (str, file): input filename or file object\n        single: if `True`, only return the first read Xmrs object\n        strict: deprecated; a `True` value is the same as\n            `errors='strict'`, and a `False` value is the same as\n            `errors='warn'`\n        errors: if `'strict'`, ill-formed MRSs raise an error; if\n            `'warn'`, raise a warning instead; if `'ignore'`, do not\n            warn or raise errors for ill-formed MRSs\n    Returns:\n        a generator of Xmrs objects (unless the *single* option is\n        `True`)\n    \"\"\"\n    if isinstance(fh, stringtypes):\n        s = open(fh, 'r').read()\n    else:\n        s = fh.read()\n    return loads(s, single=single, version=version,\n                 strict=strict, errors=errors)", "response": "Deserialize SimpleMRSs from a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dumps(ms, single=False, version=_default_version, properties=True,\n          pretty_print=False, color=False, **kwargs):\n    \"\"\"\n    Serialize an Xmrs object to a SimpleMRS representation\n\n    Args:\n        ms: an iterator of Xmrs objects to serialize (unless the\n            *single* option is `True`)\n        single: if `True`, treat *ms* as a single Xmrs object instead\n            of as an iterator\n        properties: if `False`, suppress variable properties\n        pretty_print: if `True`, add newlines and indentation\n        color: if `True`, colorize the output with ANSI color codes\n    Returns:\n        a SimpleMrs string representation of a corpus of Xmrs\n    \"\"\"\n    if not pretty_print and kwargs.get('indent'):\n        pretty_print = True\n    if single:\n        ms = [ms]\n    return serialize(ms, version=version, properties=properties,\n                     pretty_print=pretty_print, color=color)", "response": "Serialize an Xmrs object to a SimpleMrs string representation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading and return a tuple of the pred s lnk type and lnk value if a pred lnk is specified.", "response": "def _read_lnk(tokens):\n    \"\"\"Read and return a tuple of the pred's lnk type and lnk value,\n       if a pred lnk is specified.\"\"\"\n    # < FROM : TO > or < FROM # TO > or < TOK... > or < @ EDGE >\n    lnk = None\n    if tokens[0] == '<':\n        tokens.popleft()  # we just checked this is a left angle\n        if tokens[0] == '>':\n            pass  # empty <> brackets the same as no lnk specified\n        # edge lnk: ['@', EDGE, ...]\n        elif tokens[0] == '@':\n            tokens.popleft()  # remove the @\n            lnk = Lnk.edge(tokens.popleft())  # edge lnks only have one number\n        # character span lnk: [FROM, ':', TO, ...]\n        elif tokens[1] == ':':\n            lnk = Lnk.charspan(tokens.popleft(), tokens[1])\n            tokens.popleft()  # this should be the colon\n            tokens.popleft()  # and this is the cto\n        # chart vertex range lnk: [FROM, '#', TO, ...]\n        elif tokens[1] == '#':\n            lnk = Lnk.chartspan(tokens.popleft(), tokens[1])\n            tokens.popleft()  # this should be the hash\n            tokens.popleft()  # and this is the to vertex\n        # tokens lnk: [(TOK,)+ ...]\n        else:\n            lnkdata = []\n            while tokens[0] != '>':\n                lnkdata.append(int(tokens.popleft()))\n            lnk = Lnk.tokens(lnkdata)\n        _read_literals(tokens, '>')\n    return lnk"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serialize(ms, version=_default_version, properties=True,\n              pretty_print=False, color=False):\n    \"\"\"Serialize an MRS structure into a SimpleMRS string.\"\"\"\n    delim = '\\n' if pretty_print else _default_mrs_delim\n    output = delim.join(\n        _serialize_mrs(m, properties=properties,\n                       version=version, pretty_print=pretty_print)\n        for m in ms\n    )\n    if color:\n        output = highlight(output)\n    return output", "response": "Serialize an MRS structure into a SimpleMRS string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nserialize an MRS argument into the SimpleMRS format.", "response": "def _serialize_argument(rargname, value, varprops):\n    \"\"\"Serialize an MRS argument into the SimpleMRS format.\"\"\"\n    _argument = '{rargname}: {value}{props}'\n    if rargname == CONSTARG_ROLE:\n        value = '\"{}\"'.format(value)\n    props = ''\n    if value in varprops:\n        props = ' [ {} ]'.format(\n            ' '.join(\n                [var_sort(value)] +\n                list(map('{0[0]}: {0[1]}'.format,\n                         [(k.upper(), v) for k, v in varprops[value]]))\n            )\n        )\n        del varprops[value]  # only print props once\n    return _argument.format(\n        rargname=rargname,\n        value=str(value),\n        props=props\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nserializes an Elementary Predication into the SimpleMRS encoding.", "response": "def _serialize_ep(ep, varprops, version=_default_version):\n    \"\"\"Serialize an Elementary Predication into the SimpleMRS encoding.\"\"\"\n    # ('nodeid', 'pred', 'label', 'args', 'lnk', 'surface', 'base')\n    args = ep[3]\n    arglist = ' '.join([_serialize_argument(rarg, args[rarg], varprops)\n                        for rarg in sorted(args, key=rargname_sortkey)])\n    if version < 1.1 or len(ep) < 6 or ep[5] is None:\n        surface = ''\n    else:\n        surface = ' \"%s\"' % ep[5]\n    lnk = None if len(ep) < 5 else ep[4]\n    pred = ep[1]\n    predstr = pred.string\n    return '[ {pred}{lnk}{surface} LBL: {label}{s}{args} ]'.format(\n        pred=predstr,\n        lnk=_serialize_lnk(lnk),\n        surface=surface,\n        label=str(ep[2]),\n        s=' ' if arglist else '',\n        args=arglist\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _serialize_lnk(lnk):\n    s = \"\"\n    if lnk is not None:\n        s = '<'\n        if lnk.type == Lnk.CHARSPAN:\n            cfrom, cto = lnk.data\n            s += ''.join([str(cfrom), ':', str(cto)])\n        elif lnk.type == Lnk.CHARTSPAN:\n            cfrom, cto = lnk.data\n            s += ''.join([str(cfrom), '#', str(cto)])\n        elif lnk.type == Lnk.TOKENS:\n            s += ' '.join([str(t) for t in lnk.data])\n        elif lnk.type == Lnk.EDGE:\n            s += ''.join(['@', str(lnk.data)])\n        s += '>'\n    return s", "response": "Serialize a predication lnk to surface form into the SimpleMRS\n       encoding."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _serialize_hcons(hcons):\n    toks = ['HCONS:', '<']\n    for hc in hcons:\n        toks.extend(hc)\n        # reln = hcon[1]\n        # toks += [hcon[0], rel, str(hcon.lo)]\n    toks += ['>']\n    return ' '.join(toks)", "response": "Serialize HandleConstraints into the SimpleMRS encoding."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _serialize_icons(icons):\n    toks = ['ICONS:', '<']\n    for ic in icons:\n        toks.extend(ic)\n        # toks += [str(icon.left),\n        #          icon.relation,\n        #          str(icon.right)]\n    toks += ['>']\n    return ' '.join(toks)", "response": "Serialize [IndividualConstraints into the SimpleMRS encoding."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nencoding the node as a dictionary suitable for JSON serialization.", "response": "def to_dict(self, fields=_all_fields, labels=None):\n        \"\"\"\n        Encode the node as a dictionary suitable for JSON serialization.\n\n        Args:\n            fields: if given, this is a whitelist of fields to include\n                on nodes (`daughters` and `form` are always shown)\n            labels: optional label annotations to embed in the\n                derivation dict; the value is a list of lists matching\n                the structure of the derivation (e.g.,\n                `[\"S\" [\"NP\" [\"NNS\" [\"Dogs\"]]] [\"VP\" [\"VBZ\" [\"bark\"]]]]`)\n        Returns:\n            dict: the dictionary representation of the structure\n        \"\"\"\n        fields = set(fields)\n        diff = fields.difference(_all_fields)\n        if isinstance(labels, Sequence):\n            labels = _map_labels(self, labels)\n        elif labels is None:\n            labels = {}\n        if diff:\n            raise ValueError(\n                'Invalid field(s): {}'.format(', '.join(diff))\n            )\n        return _to_dict(self, fields, labels)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_head(self):\n        if (self._head or self.is_root() or\n                len(getattr(self._parent, 'daughters', [None])) == 1):\n            return True\n        elif any(dtr._head for dtr in self._parent.daughters):\n            return False\n        return None", "response": "Return True if the node is a head."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef preterminals(self):\n        nodes = []\n        for dtr in self.daughters:\n            if isinstance(dtr, UdfTerminal):\n                nodes.append(self)\n            else:\n                nodes.extend(dtr.preterminals())\n        return nodes", "response": "Return the list of preterminals of this instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(fh, model):\n    graphs = penman.load(fh, cls=XMRSCodec)\n    xs = [model.from_triples(g.triples()) for g in graphs]\n    return xs", "response": "Deserialize PENMAN graphs from a file handle or filename."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef loads(s, model):\n    graphs = penman.loads(s, cls=XMRSCodec)\n    xs = [model.from_triples(g.triples()) for g in graphs]\n    return xs", "response": "Deserialize PENMAN graphs from a string containing triples"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dump(destination, xs, model=None, properties=False, indent=True, **kwargs):\n    text = dumps(\n        xs, model=model, properties=properties, indent=indent, **kwargs\n    )\n    if hasattr(destination, 'write'):\n        print(text, file=destination)\n    else:\n        with open(destination, 'w') as fh:\n            print(text, file=fh)", "response": "Serialize Xmrs objects to PENMAN and write to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dumps(xs, model=None, properties=False, indent=True, **kwargs):\n    xs = list(xs)\n\n    if not xs:\n        return ''\n\n    given_class = xs[0].__class__  # assume they are all the same\n    if model is None:\n        model = xs[0].__class__\n\n    if not hasattr(model, 'to_triples'):\n        raise TypeError(\n            '{} class does not implement to_triples()'.format(model.__name__)\n        )\n\n    # convert MRS to DMRS if necessary; EDS cannot convert\n    if given_class.__name__ in ('Mrs', 'Xmrs'):\n        xs = [model.from_xmrs(x, **kwargs) for x in xs]\n    elif given_class.__name__ == 'Eds' and model.__name__ != 'Eds':\n        raise ValueError('Cannot convert EDS to non-EDS')\n\n    codec = XMRSCodec()\n    graphs = [\n        codec.triples_to_graph(model.to_triples(x, properties=properties))\n        for x in xs\n    ]\n\n    if 'pretty_print' in kwargs:\n        indent = kwargs['pretty_print']\n\n    return penman.dumps(graphs, cls=XMRSCodec, indent=indent)", "response": "Serialize Xmrs objects to PENMAN notation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_array(array):\n        if array is None or not array:\n            return None\n        # end if\n        assert_type_or_raise(array, dict, parameter_name=\"array\")\n\n        data = {}\n        data['keyboard'] = KeyboardButton.from_array_list(array.get('keyboard'), list_level=2)\n        data['resize_keyboard'] = bool(array.get('resize_keyboard')) if array.get('resize_keyboard') is not None else None\n        data['one_time_keyboard'] = bool(array.get('one_time_keyboard')) if array.get('one_time_keyboard') is not None else None\n        data['selective'] = bool(array.get('selective')) if array.get('selective') is not None else None\n\n        instance = ReplyKeyboardMarkup(**data)\n        instance._raw = array\n        return instance", "response": "Deserialize a new ReplyKeyboardMarkup from a given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npreparing the request for the next request.", "response": "def _prepare_request(self, command, query):\n        \"\"\"\n        :param command: The Url command parameter\n        :type  command: str\n\n        :param query: will get json encoded.\n        :type  query: dict\n\n        :return:\n        \"\"\"\n        from luckydonaldUtils.encoding import to_native as n\n        from pytgbot.api_types.sendable import Sendable\n        from pytgbot.api_types import as_array\n        from DictObject import DictObject\n        import json\n\n        params = {}\n        for key in query.keys():\n            element = query[key]\n            if element is not None:\n                if isinstance(element, Sendable):\n                    params[key] = json.dumps(as_array(element))\n                else:\n                    params[key] = element\n        url = self._base_url.format(api_key=n(self.api_key), command=n(command))\n        return DictObject(url=url, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a request to the API and return the response.", "response": "def do(self, command, files=None, use_long_polling=False, request_timeout=None, **query):\n        \"\"\"\n        Send a request to the api.\n\n        If the bot is set to return the json objects, it will look like this:\n\n        ```json\n        {\n            \"ok\": bool,\n            \"result\": {...},\n            # optionally present:\n            \"description\": \"human-readable description of the result\",\n            \"error_code\": int\n        }\n        ```\n\n        :param command: The Url command parameter\n        :type  command: str\n\n        :keyword request_timeout: When the request should time out.\n        :type    request_timeout: int\n\n        :keyword files: if it needs to send files.\n\n        :keyword use_long_polling: if it should use long polling.\n                                (see http://docs.python-requests.org/en/latest/api/#requests.Response.iter_content)\n        :type    use_long_polling: bool\n\n        :param query: will get json encoded.\n\n        :return: The json response from the server, or, if `self.return_python_objects` is `True`, a parsed return type.\n        :rtype: DictObject.DictObject | pytgbot.api_types.receivable.Receivable\n        \"\"\"\n        params = self._prepare_request(command, query)\n        r = self._do_request(\n            params.url, params=params.params,\n            files=files, stream=use_long_polling,  timeout=request_timeout\n        )\n        return self._process_response(r)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_table(tag):\n    first = True\n    table_header = None\n    table_type = 'unknown'\n    param_strings = []\n\n    thead = tag.find('thead', recursive=False)\n    theads = None  # list (items in <tr> row) of <th>/<tr> elements.\n    if thead:\n        theads = thead.find_all([\"th\", \"td\"])\n    # end if\n    tbody = tag.find('tbody', recursive=False)\n    if tbody:\n        tbody_rows = tbody.find_all(\"tr\")\n    else:\n        tbody_rows = tag.find_all(\"tr\")\n    # end if\n    tbodys = [  # list (rows) of list (items in <tr> row) of <tr> elements.\n        row.find_all([\"td\" ,\"th\"]) for row in tbody_rows\n    ]\n    if not thead:  # so first row = header\n        theads = tbody_rows[0]\n        tbodys = tbody_rows[1:]\n    # end if\n\n    # TABLE HEADER\n\n    found_columns = []\n    for column in theads:\n        # Either (a) `<td><strong> ... </strong></td>`\n        # or new (b) `<th> ... </th>`\n        col = column.find(\"strong\")\n        if col:\n            # (a) `<td><strong> ... </strong></td>`\n            col_text = col.text\n        else:\n            # (b) `<th> ... </th>`\n            col_text = column.text\n        # end if\n        found_columns.append(col_text)\n    # end def\n\n    # if TABLE is func\n    for test_columns in func_fields:\n        if found_columns == test_columns:\n            table_header = test_columns\n            table_type = 'func'\n            break\n        # end if\n    # end for\n\n    # if TABLE is class\n    if not table_header:  # only check if we don't have a result yet\n        # search class now\n        for test_columns in class_fields:\n            if found_columns == test_columns:\n                if table_header is not None:\n                    raise AssertionError(\"Table detected as func and class: {!r}\".format(found_columns))\n                table_header = test_columns\n                table_type = 'class'\n                break\n            # end if\n        # end for\n    # end if\n\n    # TABLE is none of the above\n    if not table_header:  # we don't have a result yet\n        raise AssertionError(\"Unknown table, {!r}\".format(found_columns))\n    # end if\n\n    # TABLE BODY\n\n    for tds in tbodys:\n        string = \"\\t\".join([col.text for col in tds])\n        logger.debug(\"t: \" + string)\n        param_strings.append(string)\n        pass\n    # end for row\n    return table_type, param_strings", "response": "Parses the table and returns tuple of type class or func and list of param strings."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreceive a list of results (type :class:`Clazz` or :class:`Function`), and put them into the right files in :var:`folder` :param folder: Where the files should be in. :type folder: str :param results: A list of :class:`Clazz` or :class:`Function` objects, which will be used to calculate the source code. :type results: Union(Clazz, Function)", "response": "def safe_to_file(folder, results):\n    \"\"\"\n    Receives a list of results (type :class:`Clazz` or :class:`Function`), and put them into the right files in :var:`folder`\n\n    :param folder: Where the files should be in.\n    :type  folder: str\n\n    :param results: A list of :class:`Clazz` or :class:`Function` objects, which will be used to calculate the source code.\n    :type  results: Union(Clazz, Function)\n\n    \"\"\"\n    functions = []\n    message_send_functions = []\n    clazzes = {} # \"filepath\": [Class, Class, ...]\n\n    # split results into functions and classes\n    for result in results:\n        assert isinstance(result, (Clazz, Function))\n        if isinstance(result, Clazz):\n            import_path = get_type_path(result.clazz)\n            import_path = import_path.rstrip(\".\")\n            file_path = calc_path_and_create_folders(folder, import_path)\n            result.filepath = file_path\n            if file_path not in clazzes:\n                clazzes[file_path] = []\n            clazzes[file_path].append(result)\n        else:\n            assert isinstance(result, Function)\n            import_path = \"pytgbot.bot.\"\n            file_path = calc_path_and_create_folders(folder, import_path)\n            result.filepath = file_path\n            functions.append(result)\n\n            if result.name.startswith('send_'):\n                import_path = \"teleflask_messages.\"\n                file_path = calc_path_and_create_folders(folder, import_path)\n                result2 = safe_eval(repr(result), SAVE_VALUES)  # serialize + unserialize = deepcopy\n                result2.filepath = file_path\n                message_send_functions.append(result2)\n            # end if\n        # end if\n    # end for\n\n    bot_template = get_template(\"bot.template\")\n    clazzfile_template = get_template(\"classfile.template\")\n    teleflask_messages_template = get_template(\"teleflask_messages_file.template\")\n    for path, clazz_list in clazzes.items():\n        clazz_imports = set()\n        for clazz_ in clazz_list:\n            assert isinstance(clazz_, Clazz)\n            assert isinstance(clazz_.parent_clazz, Type)\n            clazz_imports.add(clazz_.parent_clazz.as_import)\n        # end for\n        clazz_imports = list(clazz_imports)\n        clazz_imports.sort()\n        is_sendable = (\"sendable\" in path)\n        try:\n            with open(path, \"w\") as f:\n                result = clazzfile_template.render(clazzes=clazz_list, imports=clazz_imports, is_sendable=is_sendable)\n                result = result.replace(\"\\t\", \"    \")\n                f.write(result)\n                # end with\n        except IOError:\n            raise  # lol\n            # end try\n    # end for classes\n    if functions:\n        txt = bot_template.render(functions=functions)\n        with open(functions[0].filepath, \"w\") as f:\n            f.write(txt)\n        # end with\n    # end if\n    if message_send_functions:\n        txt = teleflask_messages_template.render(functions=message_send_functions)\n        with open(message_send_functions[0].filepath, \"w\") as f:\n            f.write(txt)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calc_path_and_create_folders(folder, import_path):\n    file_path = abspath(path_join(folder, import_path[:import_path.rfind(\".\")].replace(\".\", folder_seperator) + \".py\"))\n    mkdir_p(dirname(file_path))\n    return file_path", "response": "calculate the path and create the needed folders"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads a file to string buffer", "response": "def read_file_to_buffer(filename):\n    \"\"\"\n    Reads a file to string buffer\n    :param filename: \n    :return: \n    \"\"\"\n    f = open(filename, \"r\")\n    buf = BytesIO(f.read())\n    f.close()\n    return buf"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the arguments of a nova tree structure.", "response": "def parse_args(string):\n    \"\"\"\n    `\"yada hoa\" yupi yeah 12 \"\" None \"None\"` -> `[\"yada hoa\", \"yupi\", \"yeah\", 12, \"\", None, \"None\"]`\n    :param str:\n    :return:\n    \"\"\"\n    import ast\n    is_quoted = False\n    result_parts = []\n    current_str = \"\"\n    while len(string) > 0:\n        if string[0] == \"\\\"\":\n            is_quoted = not is_quoted\n            current_str += string[0]\n        elif string[0].isspace():\n            if is_quoted:\n                current_str += string[0]\n            else:\n                result_parts.append(current_str)\n                current_str = \"\"\n            # end if\n        else:\n            current_str += string[0]\n        # end if\n        string = string[1:]\n    # end while\n    if current_str:  # last part of the array\n        result_parts.append(current_str)\n    # end if\n    for i in range(len(result_parts)):\n        # Will try for each element if it is something pythonic. Parsed type will replace original list element.\n        try:\n            part = ast.literal_eval(result_parts[i])\n            result_parts[i] = part  # write it back.\n        except ValueError:\n            # could not parse -> is string\n            pass  # because already is str.\n        # end try\n    # end for\n    return result_parts"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef overwrite_color(self, string, color, prefix=False, reset=False):\n        if isinstance(color, int):\n            color = self.prepare_color(color)\n        # end if\n        prefix = color if prefix else \"\"\n        if isinstance(reset, int):\n            reset = self.prepare_color(reset)\n        elif isinstance(reset, bool):\n            reset = self.formatter.color_off if reset else \"\"\n        # end if\n        return (\n            prefix +\n            string.replace(self.formatter.color_off, self.formatter.color_off+color).replace(self.formatter.all_off, self.formatter.all_off + color) +\n            reset\n        )", "response": "Overwrites the color of the input string with the new color."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint the peer to the terminal.", "response": "def print_peer(self, peer, show_id=True, id_prefix=\"\", reply=True):\n        \"\"\"\n        :param id_prefix: Prefix of the #id thing. Set a string, or true to have it generated.\n        :type  id_prefix: str|bool\n        \"\"\"\n        if isinstance(id_prefix, bool):\n            if id_prefix:  # True\n                if isinstance(peer, User):\n                    id_prefix = \"user\"\n                elif isinstance(peer, Chat):\n                    id_prefix = peer.type\n                else:\n                    id_prefix = \"unknown\"\n                # end if\n            else:  # False\n                id_prefix = \"\"\n            # end if\n        # end if\n        peer_string = self.peer_to_string(peer)\n        if show_id and \"id\" in peer:\n            peer_string += \" ({color_lightblue}{id_prefix}#{id}{color_off})\".format(id_prefix=id_prefix, id=peer.id, **self.color.formatter)\n        return peer_string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a textual representation of MRS from one source format to another.", "response": "def convert(txt, src_fmt, tgt_fmt, single=True, **kwargs):\n    \"\"\"\n    Convert a textual representation of \\*MRS from one the src_fmt\n    representation to the tgt_fmt representation. By default, only\n    read and convert a single \\*MRS object (e.g. for `mrx` this\n    starts at <mrs> and not <mrs-list>), but changing the `mode`\n    argument to `corpus` (alternatively: `list`) reads and converts\n    multiple \\*MRSs.\n\n    Args:\n        txt: A string of semantic data.\n        src_fmt: The original representation format of txt.\n        tgt_fmt: The representation format to convert to.\n        single: If True, assume txt represents a single \\*MRS, otherwise\n            read it as a corpus (or list) of \\*MRSs.\n        kwargs: Any other keyword arguments to pass to the serializer\n            of the target format. See Notes.\n    Returns:\n        A string in the target format.\n    Notes:\n        src_fmt and tgt_fmt may be one of the following:\n\n        | format    | description                  |\n        | --------- | ---------------------------- |\n        | simplemrs | The popular SimpleMRS format |\n        | mrx       | The XML format of MRS        |\n        | dmrx      | The XML format of DMRS       |\n\n        Additional keyword arguments for the serializer may include:\n\n        | option       | description                         |\n        | ------------ | ----------------------------------- |\n        | pretty_print | print with newlines and indentation |\n        | color        | print with syntax highlighting      |\n    \"\"\"\n    from importlib import import_module\n    reader = import_module('{}.{}'.format('delphin.mrs', src_fmt.lower()))\n    writer = import_module('{}.{}'.format('delphin.mrs', tgt_fmt.lower()))\n    return writer.dumps(\n        reader.loads(txt, single=single),\n        single=single,\n        **kwargs\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _peek(tokens, n=0):\n    return tokens.peek(n=n, skip=_is_comment, drop=True)", "response": "Peek and drop comments from a sequence of tokens."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _shift(tokens):\n    after = tokens.peek(n=1, skip=_is_comment, drop=True)\n    tok = tokens._buffer.popleft()\n    return tok[0], tok[1], tok[2], after[0]", "response": "pop the next token then peek the gid of the following"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _accumulate(lexitems):\n    data = []\n    stack = []\n    break_on = 10\n    in_def = False\n    for item in lexitems:\n        gid = item[0]\n        # only yield comments outside of definitions\n        if gid in (2, 3):\n            if len(data) == 0:\n                yield [item]\n            else:\n                continue\n        elif gid == 20:\n            assert len(data) == 0\n            yield [item]\n        # the following just checks if the previous definition was not\n        # terminated when the next one is read in\n        elif gid in (7, 8):\n            if in_def:\n                yield data[:-1]\n                data = data[-1:] + [item]\n                stack = []\n                break_on = 10\n            else:\n                data.append(item)\n                in_def = True\n        else:\n            data.append(item)\n            if gid == break_on:\n                if len(stack) == 0:\n                    yield data\n                    data = []\n                    in_def = False\n                else:\n                    break_on = stack.pop()\n            elif gid in (13, 14, 15):\n                stack.append(break_on)\n                break_on = gid + 3\n    if data:\n        yield data", "response": "Yields lists of tokens based on very simple parsing that checks the level of nesting within a structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncollects the contents of a bounded multiline string", "response": "def _bounded(p1, p2, line, pos, line_no, lines):\n    \"\"\"Collect the contents of a bounded multiline string\"\"\"\n    substrings = []\n    start_line_no = line_no\n    end = pos\n    while not line.startswith(p2, end):\n        if line[end] == '\\\\':\n            end += 2\n        else:\n            end += 1\n        if end >= len(line):\n            substrings.append(line[pos:])\n            try:\n                line_no, line = next(lines)\n            except StopIteration:\n                pattern = 'docstring' if p1 == '\"\"\"' else 'block comment'\n                raise TdlParsingError('Unterminated {}'.format(pattern),\n                                      line_number=start_line_no)\n            pos = end = 0\n    substrings.append(line[pos:end])\n    end += len(p2)\n    return ''.join(substrings), start_line_no, line_no, line, end"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iterparse(source, encoding='utf-8'):\n    if hasattr(source, 'read'):\n        for event in _parse2(source):\n            yield event\n    else:\n        with io.open(source, encoding=encoding) as fh:\n            for event in _parse2(fh):\n                yield event", "response": "Parse the TDL file source and iteratively yield parse events."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tokenize(s):\n    return [m.group(m.lastindex) for m in _tdl_re.finditer(s)]", "response": "Tokenize a string s of TDL code."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(f, encoding='utf-8'):\n    if hasattr(f, 'read'):\n        for event in _parse(f):\n            yield event\n    else:\n        with io.open(f, encoding=encoding) as fh:\n            for event in _parse(fh):\n                yield event", "response": "Parse the TDL file f and yield the interpreted contents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format(obj, indent=0):\n    if isinstance(obj, TypeDefinition):\n        return _format_typedef(obj, indent)\n    elif isinstance(obj, Conjunction):\n        return _format_conjunction(obj, indent)\n    elif isinstance(obj, Term):\n        return _format_term(obj, indent)\n    elif isinstance(obj, _MorphSet):\n        return _format_morphset(obj, indent)\n    elif isinstance(obj, _Environment):\n        return _format_environment(obj, indent)\n    elif isinstance(obj, FileInclude):\n        return _format_include(obj, indent)\n    else:\n        raise ValueError('cannot format object as TDL: {!r}'.format(obj))", "response": "Serialize a Term Conjunction or TypeDefinition object to string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalize(self):\n        for attr in self._avm:\n            val = self._avm[attr]\n            if isinstance(val, Conjunction):\n                val.normalize()\n                if len(val.terms) == 1 and isinstance(val.terms[0], AVM):\n                    self._avm[attr] = val.terms[0]\n            elif isinstance(val, AVM):\n                val.normalize()", "response": "Normalizes the AVM conjunctions to just the AVM."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef features(self, expand=False):\n        fs = []\n        for featpath, val in super(AVM, self).features(expand=expand):\n            # don't juse Conjunction.features() here because we want to\n            # include the non-AVM terms, too\n            if expand and isinstance(val, Conjunction):\n                for term in val.terms:\n                    if isinstance(term, AVM):\n                        for fp, v in term.features(True):\n                            fs.append(('{}.{}'.format(featpath, fp), v))\n                    else:\n                        fs.append((featpath, term))\n            else:\n                fs.append((featpath, val))\n        return fs", "response": "Return the list of tuples of feature paths and feature values."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the list of values in the ConsList feature structure.", "response": "def values(self):\n        \"\"\"\n        Return the list of values in the ConsList feature structure.\n        \"\"\"\n        if self._avm is None:\n            return []\n        else:\n            vals = [val for _, val in _collect_list_items(self)]\n            # the < a . b > notation puts b on the last REST path,\n            # which is not returned by _collect_list_items()\n            if self.terminated and self[self._last_path] is not None:\n                vals.append(self[self._last_path])\n            return vals"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nappending an item to the end of an open ConsList.", "response": "def append(self, value):\n        \"\"\"\n        Append an item to the end of an open ConsList.\n\n        Args:\n            value (:class:`Conjunction`, :class:`Term`): item to add\n        Raises:\n            :class:`TdlError`: when appending to a closed list\n        \"\"\"\n        if self._avm is not None and not self.terminated:\n            path = self._last_path\n            if path:\n                path += '.'\n            self[path + LIST_HEAD] = value\n            self._last_path = path + LIST_TAIL\n            self[self._last_path] = AVM()\n        else:\n            raise TdlError('Cannot append to a closed list.')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nterminate the tail of the list.", "response": "def terminate(self, end):\n        \"\"\"\n        Set the value of the tail of the list.\n\n        Adding values via :meth:`append` places them on the `FIRST`\n        feature of some level of the feature structure (e.g.,\n        `REST.FIRST`), while :meth:`terminate` places them on the\n        final `REST` feature (e.g., `REST.REST`). If *end* is a\n        :class:`Conjunction` or :class:`Term`, it is typically a\n        :class:`Coreference`, otherwise *end* is set to\n        `tdl.EMPTY_LIST_TYPE` or `tdl.LIST_TYPE`. This method does\n        not necessarily close the list; if *end* is `tdl.LIST_TYPE`,\n        the list is left open, otherwise it is closed.\n\n        Args:\n            end (str, :class:`Conjunction`, :class:`Term`): value to\n            use as the end of the list.\n        \"\"\"\n        if self.terminated:\n            raise TdlError('Cannot terminate a closed list.')\n        if end == LIST_TYPE:\n            self.terminated = False\n        elif end == EMPTY_LIST_TYPE:\n            if self._last_path:\n                self[self._last_path] = None\n            else:\n                self._avm = None\n            self.terminated = True\n        elif self._last_path:\n            self[self._last_path] = end\n            self.terminated = True\n        else:\n            raise TdlError('Empty list must be {} or {}'.format(\n                LIST_TYPE, EMPTY_LIST_TYPE))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrearrange the conjunction to a conventional form.", "response": "def normalize(self):\n        \"\"\"\n        Rearrange the conjunction to a conventional form.\n\n        This puts any coreference(s) first, followed by type terms,\n        then followed by AVM(s) (including lists). AVMs are\n        normalized via :meth:`AVM.normalize`.\n        \"\"\"\n        corefs = []\n        types = []\n        avms = []\n        for term in self._terms:\n            if isinstance(term, TypeTerm):\n                types.append(term)\n            elif isinstance(term, AVM):\n                term.normalize()\n                avms.append(term)\n            elif isinstance(term, Coreference):\n                corefs.append(term)\n            else:\n                raise TdlError('unexpected term {}'.format(term))\n        self._terms = corefs + types + avms"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a term to the current conjunction.", "response": "def add(self, term):\n        \"\"\"\n        Add a term to the conjunction.\n\n        Args:\n            term (:class:`Term`, :class:`Conjunction`): term to add;\n                if a :class:`Conjunction`, all of its terms are added\n                to the current conjunction.\n        Raises:\n            :class:`TypeError`: when *term* is an invalid type\n        \"\"\"\n        if isinstance(term, Conjunction):\n            for term_ in term.terms:\n                self.add(term_)\n        elif isinstance(term, Term):\n            self._terms.append(term)\n        else:\n            raise TypeError('Not a Term or Conjunction')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef types(self):\n        return [term for term in self._terms\n                if isinstance(term, (TypeIdentifier, String, Regex))]", "response": "Return the list of type terms in the conjunction."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef features(self, expand=False):\n        featvals = []\n        for term in self._terms:\n            if isinstance(term, AVM):\n                featvals.extend(term.features(expand=expand))\n        return featvals", "response": "Return the list of feature - value pairs in the conjunction."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the first string term in the conjunction or None.", "response": "def string(self):\n        \"\"\"\n        Return the first string term in the conjunction, or `None`.\n        \"\"\"\n        for term in self._terms:\n            if isinstance(term, String):\n                return str(term)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the documentation of the type.", "response": "def documentation(self, level='first'):\n        \"\"\"\n        Return the documentation of the type.\n\n        By default, this is the first docstring on a top-level term.\n        By setting *level* to `\"top\"`, the list of all docstrings on\n        top-level terms is returned, including the type's `docstring`\n        value, if not `None`, as the last item. The docstring for the\n        type itself is available via :attr:`TypeDefinition.docstring`.\n\n        Args:\n            level (str): `\"first\"` or `\"top\"`\n        Returns:\n            a single docstring or a list of docstrings\n\n        \"\"\"\n        docs = (t.docstring for t in list(self.conjunction.terms) + [self]\n                if t.docstring is not None)\n        if level.lower() == 'first':\n            doc = next(docs, None)\n        elif level.lower() == 'top':\n            doc = list(docs)\n        return doc"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef local_constraints(self):\n        cs = []\n        for feat, val in self._avm.items():\n            try:\n                if val.supertypes and not val._avm:\n                    cs.append((feat, val))\n                else:\n                    for subfeat, subval in val.features():\n                        cs.append(('{}.{}'.format(feat, subfeat), subval))\n            except AttributeError:\n                cs.append((feat, val))\n        return cs", "response": "Return the constraints defined in the local AVM."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef values(self):\n        def collect(d):\n            if d is None or d.get('FIRST') is None:\n                return []\n            vals = [d['FIRST']]\n            vals.extend(collect(d.get('REST')))\n            return vals\n        return collect(self)", "response": "Return the list of values in the current locale."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_dict(self):\n        d = {'rargname': self.rargname, 'value': self.value}\n        if self.properties:\n            d['properties'] = self.properties\n        if self.optional:\n            d['optional'] = self.optional\n        return d", "response": "Return a dictionary representation of the Role."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary representation of the Predicate.", "response": "def to_dict(self):\n        \"\"\"Return a dictionary representation of the Predicate.\"\"\"\n        return {\n            'predicate': self.predicate,\n            'parents': list(self.supertypes),\n            'synopses': [[role.to_dict() for role in synopsis]\n                         for synopsis in self.synopses]\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dictionary representation of the SemI.", "response": "def to_dict(self):\n        \"\"\"Return a dictionary representation of the SemI.\"\"\"\n        make = lambda pair: (pair[0], pair[1].to_dict())\n        return dict(\n            variables=dict(make(v) for v in self.variables.items()),\n            properties=dict(make(p) for p in self.properties.items()),\n            roles=dict(make(r) for r in self.roles.items()),\n            predicates=dict(make(p) for p in self.predicates.items())\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sort_vid_split(vs):\n    match = var_re.match(vs)\n    if match is None:\n        raise ValueError('Invalid variable string: {}'.format(str(vs)))\n    else:\n        return match.groups()", "response": "Split a valid variable string into its variable sort and id."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef links(xmrs):\n\n    # Links exist for every non-intrinsic argument that has a variable\n    # that is the intrinsic variable of some other predicate, as well\n    # as for label equalities when no argument link exists (even\n    # considering transitivity).\n    links = []\n    prelinks = []\n\n    _eps = xmrs._eps\n    _hcons = xmrs._hcons\n    _vars = xmrs._vars\n\n    lsh = xmrs.labelset_heads\n    lblheads = {v: lsh(v) for v, vd in _vars.items() if 'LBL' in vd['refs']}\n\n    top = xmrs.top\n    if top is not None:\n        prelinks.append((0, top, None, top, _vars[top]))\n\n    for nid, ep in _eps.items():\n        for role, val in ep[3].items():\n            if role == IVARG_ROLE or val not in _vars:\n                continue\n            prelinks.append((nid, ep[2], role, val, _vars[val]))\n\n    for src, srclbl, role, val, vd in prelinks:\n        if IVARG_ROLE in vd['refs']:\n            tgtnids = [n for n in vd['refs'][IVARG_ROLE]\n                       if not _eps[n].is_quantifier()]\n            if len(tgtnids) == 0:\n                continue  # maybe some bad MRS with a lonely quantifier\n            tgt = tgtnids[0]  # what do we do if len > 1?\n            tgtlbl = _eps[tgt][2]\n            post = EQ_POST if srclbl == tgtlbl else NEQ_POST\n        elif val in _hcons:\n            lbl = _hcons[val][2]\n            if lbl not in lblheads or len(lblheads[lbl]) == 0:\n                continue  # broken MRS; log this?\n            tgt = lblheads[lbl][0]  # sorted list; first item is most \"heady\"\n            post = H_POST\n        elif 'LBL' in vd['refs']:\n            if val not in lblheads or len(lblheads[val]) == 0:\n                continue  # broken MRS; log this?\n            tgt = lblheads[val][0]  # again, should be sorted already\n            post = HEQ_POST\n        else:\n            continue  # CARGs, maybe?\n        links.append(Link(src, tgt, role, post))\n\n    # now EQ links unattested by arg links\n    for lbl, heads in lblheads.items():\n        # I'm pretty sure this does what we want\n        if len(heads) > 1:\n            first = heads[0]\n            for other in heads[1:]:\n                links.append(Link(other, first, BARE_EQ_ROLE, EQ_POST))\n        # If not, something like this is more explicit\n        # lblset = self.labelset(lbl)\n        # sg = g.subgraph(lblset)\n        # ns = [nid for nid, deg in sg.degree(lblset).items() if deg == 0]\n        # head = self.labelset_head(lbl)\n        # for n in ns:\n        #     links.append(Link(head, n, post=EQ_POST))\n    def _int(x):\n        try:\n            return int(x)\n        except ValueError:\n            return 0\n    return sorted(\n        links,\n        key=lambda link: (_int(link.start), _int(link.end), link.rargname)\n    )", "response": "Return the list of Links for the MRS."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list of all HandleConstraints in * xmrs*.", "response": "def hcons(xmrs):\n    \"\"\"Return the list of all HandleConstraints in *xmrs*.\"\"\"\n    return [\n        HandleConstraint(hi, reln, lo)\n        for hi, reln, lo in sorted(xmrs.hcons(), key=lambda hc: var_id(hc[0]))\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the list of all IndividualConstraints in * xmrs*.", "response": "def icons(xmrs):\n    \"\"\"Return the list of all IndividualConstraints in *xmrs*.\"\"\"\n    return [\n        IndividualConstraint(left, reln, right)\n        for left, reln, right in sorted(xmrs.icons(),\n                                        key=lambda ic: var_id(ic[0]))\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef split_pred_string(predstr):\n    predstr = predstr.strip('\"\\'')  # surrounding quotes don't matter\n    rel_added = False\n    if not predstr.lower().endswith('_rel'):\n        logging.debug('Predicate does not end in \"_rel\": {}'\n                      .format(predstr))\n        rel_added = True\n        predstr += '_rel'\n    match = Pred.pred_re.search(predstr)\n    if match is None:\n        logging.debug('Unexpected predicate string: {}'.format(predstr))\n        return (predstr, None, None, None)\n    # _lemma_pos(_sense)?_end\n    return (match.group('lemma'), match.group('pos'),\n            match.group('sense'), None if rel_added else match.group('end'))", "response": "Split a predicate string into a set of words and their components."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_valid_pred_string(predstr):\n    predstr = predstr.strip('\"').lstrip(\"'\")\n    # this is a stricter regex than in Pred, but doesn't check POS\n    return re.match(\n        r'_([^ _\\\\]|\\\\.)+_[a-z](_([^ _\\\\]|\\\\.)+)?(_rel)?$'\n        r'|[^_]([^ \\\\]|\\\\.)+(_rel)?$',\n        predstr\n    ) is not None", "response": "Return True if predstr is a valid predicate string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef normalize_pred_string(predstr):\n    tokens = [t for t in split_pred_string(predstr)[:3] if t is not None]\n    if predstr.lstrip('\\'\"')[:1] == '_':\n        tokens = [''] + tokens\n    return '_'.join(tokens).lower()", "response": "Normalizes the predicate string to a conventional form."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nodes(xmrs):\n    nodes = []\n    _props = xmrs.properties\n    varsplit = sort_vid_split\n    for p in xmrs.eps():\n        sortinfo = None\n        iv = p.intrinsic_variable\n        if iv is not None:\n            sort, _ = varsplit(iv)\n            sortinfo = _props(iv)\n            sortinfo[CVARSORT] = sort\n        nodes.append(\n            Node(p.nodeid, p.pred, sortinfo, p.lnk, p.surface, p.base, p.carg)\n        )\n    return nodes", "response": "Return the list of Nodes for xmrs *."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef new(self, sort, properties=None):\n        if sort is None:\n            sort = UNKNOWNSORT\n        # find next available vid\n        vid, index = self.vid, self.index\n        while vid in index:\n            vid += 1\n        varstring = '{}{}'.format(sort, vid)\n        index[vid] = varstring\n        if properties is None:\n            properties = []\n        self.store[varstring] = properties\n        self.vid = vid + 1\n        return (varstring, properties)", "response": "Create a new variable for the given sort."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef charspan(cls, start, end):\n        return cls(Lnk.CHARSPAN, (int(start), int(end)))", "response": "Create a Lnk object for a character span."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a Lnk object for a chart span.", "response": "def chartspan(cls, start, end):\n        \"\"\"\n        Create a Lnk object for a chart span.\n\n        Args:\n            start: the initial chart vertex\n            end: the final chart vertex\n        \"\"\"\n        return cls(Lnk.CHARTSPAN, (int(start), int(end)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tokens(cls, tokens):\n        return cls(Lnk.TOKENS, tuple(map(int, tokens)))", "response": "Returns a Lnk object for a list of token identifiers."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cfrom(self):\n        cfrom = -1\n        try:\n            if self.lnk.type == Lnk.CHARSPAN:\n                cfrom = self.lnk.data[0]\n        except AttributeError:\n            pass  # use default cfrom of -1\n        return cfrom", "response": "Returns the initial character position in the surface string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the final character position in the surface string.", "response": "def cto(self):\n        \"\"\"\n        The final character position in the surface string.\n\n        Defaults to -1 if there is no valid cto value.\n        \"\"\"\n        cto = -1\n        try:\n            if self.lnk.type == Lnk.CHARSPAN:\n                cto = self.lnk.data[1]\n        except AttributeError:\n            pass  # use default cto of -1\n        return cto"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef realpred(cls, lemma, pos, sense=None):\n        string_tokens = [lemma]\n        if pos is not None:\n            string_tokens.append(pos)\n        if sense is not None:\n            sense = str(sense)\n            string_tokens.append(sense)\n        predstr = '_'.join([''] + string_tokens + ['rel'])\n        return cls(Pred.REALPRED, lemma, pos, sense, predstr)", "response": "Instantiate a Pred from its components."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a dict mapping from the locale to the local locale.", "response": "def properties(self):\n        \"\"\"\n        Morphosemantic property mapping.\n\n        Unlike :attr:`sortinfo`, this does not include `cvarsort`.\n        \"\"\"\n        d = dict(self.sortinfo)\n        if CVARSORT in d:\n            del d[CVARSORT]\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate HTTP GET params with the given fields that user wants to fetch.", "response": "def update_get_params(self):\n        \"\"\"Update HTTP GET params with the given fields that user wants to fetch.\"\"\"\n        if isinstance(self._fields, (tuple, list)):  # tuples & lists > x,y,z\n            self.get_params[\"fields\"] = \",\".join([str(_) for _ in self._fields])\n        elif isinstance(self._fields, str):\n            self.get_params[\"fields\"] = self._fields"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking an API call to fetch the raw data for the given probe and stores the raw data.", "response": "def _fetch_meta_data(self):\n        \"\"\"Makes an API call to fetch meta data for the given probe and stores the raw data.\"\"\"\n        is_success, meta_data = AtlasRequest(\n            url_path=self.API_META_URL.format(self.id),\n            key=self.api_key,\n            server=self.server,\n            verify=self.verify,\n            user_agent=self._user_agent\n        ).get(**self.get_params)\n\n        self.meta_data = meta_data\n        if not is_success:\n            return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npopulates the instance properties of the class properties based on the meta data from the API response.", "response": "def _populate_data(self):\n        \"\"\"Assing some probe's raw meta data from API response to instance properties\"\"\"\n        if self.id is None:\n            self.id = self.meta_data.get(\"id\")\n        self.is_anchor = self.meta_data.get(\"is_anchor\")\n        self.country_code = self.meta_data.get(\"country_code\")\n        self.description = self.meta_data.get(\"description\")\n        self.is_public = self.meta_data.get(\"is_public\")\n        self.asn_v4 = self.meta_data.get(\"asn_v4\")\n        self.asn_v6 = self.meta_data.get(\"asn_v6\")\n        self.address_v4 = self.meta_data.get(\"address_v4\")\n        self.address_v6 = self.meta_data.get(\"address_v6\")\n        self.prefix_v4 = self.meta_data.get(\"prefix_v4\")\n        self.prefix_v6 = self.meta_data.get(\"prefix_v6\")\n        self.geometry = self.meta_data.get(\"geometry\")\n        self.tags = self.meta_data.get(\"tags\")\n        self.status = self.meta_data.get(\"status\", {}).get(\"name\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _populate_data(self):\n        if self.id is None:\n            self.id = self.meta_data.get(\"id\")\n\n        self.stop_time = None\n        self.creation_time = None\n        self.start_time = None\n        self.populate_times()\n        self.protocol = self.meta_data.get(\"af\")\n        self.target_ip = self.meta_data.get(\"target_ip\")\n        self.target_asn = self.meta_data.get(\"target_asn\")\n        self.target = self.meta_data.get(\"target\")\n        self.description = self.meta_data.get(\"description\")\n        self.is_oneoff = self.meta_data.get(\"is_oneoff\")\n        self.is_public = self.meta_data.get(\"is_public\")\n        self.interval = self.meta_data.get(\"interval\")\n        self.resolve_on_probe = self.meta_data.get(\"resolve_on_probe\")\n        self.status_id = self.meta_data.get(\"status\", {}).get(\"id\")\n        self.status = self.meta_data.get(\"status\", {}).get(\"name\")\n        self.type = self.get_type()\n        self.result_url = self.meta_data.get(\"result\")", "response": "Populates the instance properties of the object with the raw meta data from the API response to the instance properties."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the type of the object.", "response": "def get_type(self):\n        \"\"\"\n        Getting type of measurement keeping backwards compatibility for\n        v2 API output changes.\n        \"\"\"\n        mtype = None\n        if \"type\" not in self.meta_data:\n            return mtype\n\n        mtype = self.meta_data[\"type\"]\n        if isinstance(mtype, dict):\n            mtype = self.meta_data.get(\"type\", {}).get(\"name\", \"\").upper()\n        elif isinstance(mtype, str):\n            mtype = mtype\n\n        return mtype"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npopulates the internal times of the object with the meta data times that comes with measurement if they are present.", "response": "def populate_times(self):\n        \"\"\"\n        Populates all different meta data times that comes with measurement if\n        they are present.\n        \"\"\"\n        stop_time = self.meta_data.get(\"stop_time\")\n        if stop_time:\n            stop_naive = datetime.utcfromtimestamp(stop_time)\n            self.stop_time = stop_naive.replace(tzinfo=tzutc())\n\n        creation_time = self.meta_data.get(\"creation_time\")\n        if creation_time:\n            creation_naive = datetime.utcfromtimestamp(creation_time)\n            self.creation_time = creation_naive.replace(tzinfo=tzutc())\n\n        start_time = self.meta_data.get(\"start_time\")\n        if start_time:\n            start_naive = datetime.utcfromtimestamp(start_time)\n            self.start_time = start_naive.replace(tzinfo=tzutc())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_tags(self, value):\n        log = (\n            'Sources fields \"tags\" should be a dict in the format '\n            '{\"include\": [ \"tag1\", \"tag2\", \"tagN\" ],'\n            '\"exclude\": [ \"tag1\", \"tag2\", \"tagN\" ] }'\n        )\n\n        if not isinstance(value, dict):\n            raise MalFormattedSource(log)\n\n        if not set(value.keys()).issubset(set([\"include\", \"exclude\"])):\n            raise MalFormattedSource(log)\n\n        for tag_list in value.values():\n            if not isinstance(tag_list, list):\n                raise MalFormattedSource(log)\n            if [tag for tag in tag_list if not isinstance(tag, str)]:\n                raise MalFormattedSource(log)\n\n        self._tags = value", "response": "Setter for tags attribute"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild the API structure for the resource.", "response": "def build_api_struct(self):\n        \"\"\"\n        Calls the clean method of the class and returns the info in a structure\n        that Atlas API is accepting.\n        \"\"\"\n        self.clean()\n        r = {\n            \"type\": self._type,\n            \"requested\": self._requested,\n            \"value\": self._value\n        }\n        if self._tags:\n            r[\"tags\"] = self._tags\n\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_type(self, value):\n        if self.action == \"remove\" and value != \"probes\":\n            log = \"Sources field 'type' when action is remove should always be 'probes'.\"\n            raise MalFormattedSource(log)\n        self._type = value", "response": "Setter for type attribute"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clean(self):\n        if not all([self._type, self._requested, self._value, self._action]):\n            raise MalFormattedSource(\n                \"<type, requested, value, action> fields are required.\"\n            )", "response": "Checks that the user has entered all required attributes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_api_struct(self):\n        data = super(AtlasChangeSource, self).build_api_struct()\n        data.update({\"action\": self._action})\n        return data", "response": "Builds the API structure for this atlas change source."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding an option and its value to the class as an attribute and stores it in the used options set.", "response": "def add_option(self, **options):\n        \"\"\"\n        Adds an option and its value to the class as an attribute and stores it\n        to the used options set.\n        \"\"\"\n        for option, value in options.items():\n            setattr(self, option, value)\n            self._store_option(option)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes the required options as class members.", "response": "def _init_required_options(self, **kwargs):\n        \"\"\"\n        Initialize the required option as class members. The value will be\n        either None or the specified value in the kwargs or __init__. The logic\n        here is to make the required options accesible to edit after a class\n        instance has been created.\n        \"\"\"\n        for field in self.required_options:\n            setattr(self, field, kwargs.get(field))\n            self._store_option(field)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean(self):\n\n        # make sure the correct measurement type is set.\n        if not self.measurement_type:\n            log = \"Please define a valid measurement type.\"\n            raise MalFormattedMeasurement(log)\n\n        # make sure the required fields are set.\n        for roption in self.required_options:\n            if getattr(self, roption, None) is None:\n                log = \"%s Measurement field: <%s> is required\" % (\n                    self.__class__.__name__, roption\n                )\n                raise MalFormattedMeasurement(log)", "response": "Clean the user entered data making sure required fields are set."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_api_struct(self):\n        self.clean()\n        data = {\"type\": self.measurement_type}\n\n        # add all options\n        for option in self.used_options:\n            option_key, option_value = self.v2_translator(option)\n            data.update({option_key: option_value})\n\n        return data", "response": "Builds the API struct that contains the info in the API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitiate the channel we want to start streams from.", "response": "def connect(self):\n        \"\"\"Initiate the channel we want to start streams from.\"\"\"\n        self.socketIO = SocketIO(\n            host=self.iosocket_server,\n            port=80,\n            resource=self.iosocket_resource,\n            proxies=self.proxies,\n            headers=self.headers,\n            transports=[\"websocket\"],\n            Namespace=AtlasNamespace,\n        )\n\n        self.socketIO.on(self.EVENT_NAME_ERROR, self.handle_error)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bind_channel(self, channel, callback):\n\n        # Remove the following list when deprecation time expires\n        if channel in self.CHANNELS:\n            warning = (\n                \"The event name '{}' will soon be deprecated. Use \"\n                \"the real event name '{}' instead.\"\n            ).format(channel, self.CHANNELS[channel])\n\n            self.handle_error(warning)\n            channel = self.CHANNELS[channel]\n        # -------------------------------------------------------\n\n        if channel == self.EVENT_NAME_ERROR:\n            self.error_callback = callback\n        elif channel == self.EVENT_NAME_RESULTS:\n            self.socketIO.on(channel, partial(self.unpack_results, callback))\n        else:\n            self.socketIO.on(channel, callback)", "response": "Bind given channel with given callback"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start_stream(self, stream_type, **stream_parameters):\n        if stream_type:\n            self.subscribe(stream_type, **stream_parameters)\n        else:\n            self.handle_error(\"You need to set a stream type\")", "response": "Starts a new stream for given type with given parameters"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsubscribe to stream with give parameters.", "response": "def subscribe(self, stream_type, **parameters):\n        \"\"\"Subscribe to stream with give parameters.\"\"\"\n        parameters[\"stream_type\"] = stream_type\n\n        if (stream_type == \"result\") and (\"buffering\" not in parameters):\n            parameters[\"buffering\"] = True\n\n        self.socketIO.emit(self.EVENT_NAME_SUBSCRIBE, parameters)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef timeout(self, seconds=None):\n        if seconds is None:\n            self.socketIO.wait()\n        else:\n            self.socketIO.wait(seconds=seconds)", "response": "Times out all streams after n seconds or wait forever"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_url(self):\n\n        if not self.api_filters:\n            return self.url\n\n        # Reduce complex objects to simpler strings\n        for k, v in self.api_filters.items():\n            if isinstance(v, datetime):  # datetime > UNIX timestamp\n                self.api_filters[k] = int(calendar.timegm(v.timetuple()))\n            if isinstance(v, (tuple, list)):  # tuples & lists > x,y,z\n                self.api_filters[k] = \",\".join([str(_) for _ in v])\n\n        if (\n            self.id_filter in self.api_filters and\n            len(str(self.api_filters[self.id_filter])) > self.URL_LENGTH_LIMIT\n        ):\n            self.build_url_chunks()\n            return self.split_urls.pop(0)\n\n        filters = '&'.join(\"%s=%s\" % (k, v) for (k, v) in self.api_filters.items())\n\n        return \"%s?%s\" % (self.url, filters)", "response": "Build the url path based on the filter options."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_url_chunks(self):\n        CHUNK_SIZE = 500\n\n        id_filter = str(self.api_filters.pop(self.id_filter)).split(',')\n        chuncks = list(self.chunks(id_filter, CHUNK_SIZE))\n        filters = '&'.join(\"%s=%s\" % (k, v) for (k, v) in self.api_filters.items())\n\n        for chunk in chuncks:\n            if filters:\n                url = \"{0}?{1}&{2}={3}\".format(self.url, filters, self.id_filter, ','.join(chunk))\n            else:\n                url = \"{0}?{1}={2}\".format(self.url, self.id_filter, ','.join(chunk))\n            self.split_urls.append(url)", "response": "Build url for all the url chunks"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying API for the next batch of objects and store next url and current batch of objects.", "response": "def next_batch(self):\n        \"\"\"\n        Querying API for the next batch of objects and store next url and\n        batch of objects.\n        \"\"\"\n        is_success, results = AtlasRequest(\n            url_path=self.atlas_url,\n            user_agent=self._user_agent,\n            server=self.server,\n            verify=self.verify,\n        ).get()\n\n        if not is_success:\n            raise APIResponseError(results)\n\n        self.total_count = results.get(\"count\")\n        self.atlas_url = self.build_next_url(results.get(\"next\"))\n        self.current_batch = results.get(\"results\", [])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding next url in a format compatible with cousteau. Path + query", "response": "def build_next_url(self, url):\n        \"\"\"Builds next url in a format compatible with cousteau. Path + query\"\"\"\n        if not url:\n            if self.split_urls:  # If we had a long request give the next part\n                self.total_count_flag = False  # Reset flag for count\n                return self.split_urls.pop(0)\n            else:\n                return None\n\n        parsed_url = urlparse(url)\n        return \"{0}?{1}\".format(parsed_url.path, parsed_url.query)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn header for the HTTP request.", "response": "def get_headers(self):\n        \"\"\"Return header for the HTTP request.\"\"\"\n        headers = {\n            \"User-Agent\": self.http_agent,\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\"\n        }\n        if self.headers:\n            headers.update(self.headers)\n\n        return headers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute the given HTTP method and returns if it s success or not the response as a string if it s success and the response as a python object after unjson if it s not success.", "response": "def http_method(self, method):\n        \"\"\"\n        Execute the given HTTP method and returns if it's success or not\n        and the response as a string if not success and as python object after\n        unjson if it's success.\n        \"\"\"\n        self.build_url()\n\n        try:\n            response = self.get_http_method(method)\n            is_success = response.ok\n\n            try:\n                response_message = response.json()\n            except ValueError:\n                response_message = response.text\n\n        except requests.exceptions.RequestException as exc:\n            is_success = False\n            response_message = exc.args\n\n        return is_success, response_message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the http method that will be called from the requests library", "response": "def get_http_method(self, method):\n        \"\"\"Gets the http method that will be called from the requests library\"\"\"\n        return self.http_methods[method](self.url, **self.http_method_args)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, **url_params):\n        if url_params:\n            self.http_method_args[\"params\"].update(url_params)\n        return self.http_method(\"GET\")", "response": "Makes the HTTP GET to the url."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking the HTTP POST to the url sending post_data.", "response": "def post(self):\n        \"\"\"\n        Makes the HTTP POST to the url sending post_data.\n        \"\"\"\n        self._construct_post_data()\n\n        post_args = {\"json\": self.post_data}\n        self.http_method_args.update(post_args)\n\n        return self.http_method(\"POST\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntransforming time field to datetime object if there is any.", "response": "def clean_time(self, time):\n        \"\"\"\n        Transform time field to datetime object if there is any.\n        \"\"\"\n        if isinstance(time, int):\n            time = datetime.utcfromtimestamp(time)\n        elif isinstance(time, str):\n            time = parser.parse(time)\n\n        return time"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _construct_post_data(self):\n        definitions = [msm.build_api_struct() for msm in self.measurements]\n        probes = [source.build_api_struct() for source in self.sources]\n        self.post_data = {\n            \"definitions\": definitions,\n            \"probes\": probes,\n            \"is_oneoff\": self.is_oneoff\n        }\n\n        if self.is_oneoff:\n            self.post_data.update({\"is_oneoff\": self.is_oneoff})\n\n        if self.start_time:\n            self.post_data.update(\n                {\"start_time\": int(calendar.timegm(self.start_time.timetuple()))}\n            )\n        if self.stop_time:\n            self.post_data.update(\n                {\"stop_time\": int(calendar.timegm(self.stop_time.timetuple()))}\n            )\n\n        if self.bill_to:\n            self.post_data.update({\"bill_to\": self.bill_to})", "response": "Constructs the data structure that is required from the atlas API based\n            on measurements sources and times user has specified."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking format of probe ids and transform it to something API understands.", "response": "def clean_probes(self, probe_ids):\n        \"\"\"\n        Checks format of probe ids and transform it to something API\n        understands.\n        \"\"\"\n        if isinstance(probe_ids, (tuple, list)):  # tuples & lists > x,y,z\n            probe_ids = \",\".join([str(_) for _ in probe_ids])\n\n        return probe_ids"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_http_method_params(self):\n        url_params = {}\n\n        if self.start:\n            url_params.update(\n                {\"start\": int(calendar.timegm(self.start.timetuple()))}\n            )\n\n        if self.stop:\n            url_params.update(\n                {\"stop\": int(calendar.timegm(self.stop.timetuple()))}\n            )\n\n        if self.probe_ids:\n            url_params.update({\"probe_ids\": self.probe_ids})\n\n        self.http_method_args[\"params\"].update(url_params)", "response": "Update the HTTP method parameters based on msm_id and query filters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query(self, query, media=None, year=None, fields=None, extended=None, **kwargs):\n        # Validate parameters\n        if not media:\n            warnings.warn(\n                \"\\\"media\\\" parameter is now required on the Trakt['search'].query() method\",\n                DeprecationWarning, stacklevel=2\n            )\n\n        if fields and not media:\n            raise ValueError('\"fields\" can only be used when the \"media\" parameter is defined')\n\n        # Build query\n        query = {\n            'query': query\n        }\n\n        if year:\n            query['year'] = year\n\n        if fields:\n            query['fields'] = fields\n\n        if extended:\n            query['extended'] = extended\n\n        # Serialize media items\n        if isinstance(media, list):\n            media = ','.join(media)\n\n        # Send request\n        response = self.http.get(\n            params=[media],\n            query=query\n        )\n\n        # Parse response\n        items = self.get_data(response, **kwargs)\n\n        if isinstance(items, requests.Response):\n            return items\n\n        if items is not None:\n            return SearchMapper.process_many(self.client, items)\n\n        return None", "response": "Search by title description media year and fields."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the season identifier which is compatible with requests that require season definitions.", "response": "def to_identifier(self):\n        \"\"\"Return the season identifier which is compatible with requests that require season definitions.\n\n        :return: Season identifier/definition\n        :rtype: :class:`~python:dict`\n        \"\"\"\n\n        return {\n            'number': self.pk,\n            'episodes': [\n                episode.to_dict()\n                for episode in self.episodes.values()\n            ]\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_dict(self):\n\n        result = self.to_identifier()\n\n        result.update({\n            'ids': dict([\n                (key, value) for (key, value) in self.keys[1:]  # NOTE: keys[0] is the season identifier\n            ])\n        })\n\n        if self.rating:\n            result['rating'] = self.rating.value\n            result['rated_at'] = to_iso8601_datetime(self.rating.timestamp)\n\n        result['in_watchlist'] = self.in_watchlist if self.in_watchlist is not None else 0\n\n        # Extended Info\n        if self.first_aired:\n            result['first_aired'] = to_iso8601_datetime(self.first_aired)\n\n        if self.episode_count:\n            result['episode_count'] = self.episode_count\n\n        if self.aired_episodes:\n            result['aired_episodes'] = self.aired_episodes\n\n        return result", "response": "Dump Season object to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_dict(self):\n\n        result = self.to_identifier()\n\n        result.update({\n            'title': self.title,\n\n            'watched': 1 if self.is_watched else 0,\n            'collected': 1 if self.is_collected else 0,\n\n            'plays': self.plays if self.plays is not None else 0,\n            'in_watchlist': self.in_watchlist if self.in_watchlist is not None else 0,\n            'progress': self.progress,\n\n            'last_watched_at': to_iso8601_datetime(self.last_watched_at),\n            'collected_at': to_iso8601_datetime(self.collected_at),\n            'paused_at': to_iso8601_datetime(self.paused_at),\n\n            'ids': dict([\n                (key, value) for (key, value) in self.keys[1:]  # NOTE: keys[0] is the (<season>, <episode>) identifier\n            ])\n        })\n\n        if self.rating:\n            result['rating'] = self.rating.value\n            result['rated_at'] = to_iso8601_datetime(self.rating.timestamp)\n\n        # Extended Info\n        if self.first_aired:\n            result['first_aired'] = to_iso8601_datetime(self.first_aired)\n\n        if self.updated_at:\n            result['updated_at'] = to_iso8601_datetime(self.updated_at)\n\n        if self.overview:\n            result['overview'] = self.overview\n\n        if self.available_translations:\n            result['available_translations'] = self.available_translations\n\n        return result", "response": "Dump the episode to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_aborted(self):\n\n        print('Authentication aborted')\n\n        # Authentication aborted\n        self.is_authenticating.acquire()\n        self.is_authenticating.notify_all()\n        self.is_authenticating.release()", "response": "Called when device authentication was aborted."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct the device authentication poller.", "response": "def poll(self, device_code, expires_in, interval, **kwargs):\n        \"\"\"Construct the device authentication poller.\n\n        :param device_code: Device authentication code\n        :type device_code: str\n\n        :param expires_in: Device authentication code expiry (in seconds)\n        :type         in: int\n\n        :param interval: Device authentication poll interval\n        :type interval: int\n\n        :rtype: DeviceOAuthPoller\n        \"\"\"\n        return DeviceOAuthPoller(self.client, device_code, expires_in, interval)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndumps this movie to a dictionary.", "response": "def to_dict(self):\n        \"\"\"Dump movie to a dictionary.\n\n        :return: Movie dictionary\n        :rtype: :class:`~python:dict`\n        \"\"\"\n\n        result = self.to_identifier()\n\n        result.update({\n            'watched': 1 if self.is_watched else 0,\n            'collected': 1 if self.is_collected else 0,\n\n            'plays': self.plays if self.plays is not None else 0,\n            'in_watchlist': self.in_watchlist if self.in_watchlist is not None else 0,\n            'progress': self.progress,\n\n            'last_watched_at': to_iso8601_datetime(self.last_watched_at),\n            'collected_at': to_iso8601_datetime(self.collected_at),\n            'paused_at': to_iso8601_datetime(self.paused_at)\n        })\n\n        if self.rating:\n            result['rating'] = self.rating.value\n            result['rated_at'] = to_iso8601_datetime(self.rating.timestamp)\n\n        # Extended Info\n        if self.released:\n            result['released'] = to_iso8601_date(self.released)\n\n        if self.updated_at:\n            result['updated_at'] = to_iso8601_datetime(self.updated_at)\n\n        if self.overview:\n            result['overview'] = self.overview\n\n        if self.tagline:\n            result['tagline'] = self.tagline\n\n        if self.runtime:\n            result['runtime'] = self.runtime\n\n        if self.certification:\n            result['certification'] = self.certification\n\n        if self.homepage:\n            result['homepage'] = self.homepage\n\n        if self.trailer:\n            result['trailer'] = self.trailer\n\n        if self.language:\n            result['language'] = self.language\n\n        if self.available_translations:\n            result['available_translations'] = self.available_translations\n\n        if self.genres:\n            result['genres'] = self.genres\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_dict(self):\n\n        result = super(Progress, self).to_dict()\n\n        label = LABELS['last_progress_change'][self.progress_type]\n        result[label] = to_iso8601_datetime(self.last_progress_change)\n\n        if self.progress_type == 'watched':\n            result['reset_at'] = self.reset_at\n\n        result['seasons'] = [\n            season.to_dict()\n            for season in self.seasons.values()\n        ]\n\n        if self.hidden_seasons:\n            result['hidden_seasons'] = [\n                popitems(season.to_dict(), ['number', 'ids'])\n                for season in self.hidden_seasons.values()\n            ]\n\n        if self.next_episode:\n            result['next_episode'] = popitems(self.next_episode.to_dict(), ['season', 'number', 'title', 'ids'])\n            result['next_episode']['season'] = self.next_episode.keys[0][0]\n\n        if self.last_episode:\n            result['last_episode'] = popitems(self.last_episode.to_dict(), ['season', 'number', 'title', 'ids'])\n            result['last_episode']['season'] = self.last_episode.keys[0][0]\n\n        return result", "response": "Dump this Progress object to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms scrobble action. :param action: Action to perform (either :code:`start`, :code:`pause` or :code:`stop`) :type action: :class:`~python:str` :param movie: Movie definition (or `None`) **Example:** .. code-block:: python { 'title': 'Guardians of the Galaxy', 'year': 2014, 'ids': { 'tmdb': 118340 } } :type movie: :class:`~python:dict` :param show: Show definition (or `None`) **Example:** .. code-block:: python { 'title': 'Breaking Bad', 'year': 2008, 'ids': { 'tvdb': 81189 } } :type show: :class:`~python:dict` :param episode: Episode definition (or `None`) **Example:** .. code-block:: python { \"season\": 3, \"number\": 11 } :type episode: :class:`~python:dict` :param progress: Current movie/episode progress percentage :type progress: :class:`~python:float` :param kwargs: Extra request options :type kwargs: :class:`~python:dict` :return: Response (or `None`) **Example:** .. code-block:: python { 'action': 'start', 'progress': 1.25, 'sharing': { 'facebook': true, 'twitter': true, 'tumblr': false }, 'movie': { 'title': 'Guardians of the Galaxy', 'year': 2014, 'ids': { 'trakt': 28, 'slug': 'guardians-of-the-galaxy-2014', 'imdb': 'tt2015381', 'tmdb': 118340 } } } :rtype: :class:`~python:dict`", "response": "def action(self, action, movie=None, show=None, episode=None, progress=0.0, **kwargs):\n        \"\"\"Perform scrobble action.\n\n        :param action: Action to perform (either :code:`start`, :code:`pause` or :code:`stop`)\n        :type action: :class:`~python:str`\n\n        :param movie: Movie definition (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    'title': 'Guardians of the Galaxy',\n                    'year': 2014,\n\n                    'ids': {\n                        'tmdb': 118340\n                    }\n                }\n\n        :type movie: :class:`~python:dict`\n\n        :param show: Show definition (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    'title': 'Breaking Bad',\n                    'year': 2008,\n\n                    'ids': {\n                        'tvdb': 81189\n                    }\n                }\n\n\n        :type show: :class:`~python:dict`\n\n        :param episode: Episode definition (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    \"season\": 3,\n                    \"number\": 11\n                }\n\n        :type episode: :class:`~python:dict`\n\n        :param progress: Current movie/episode progress percentage\n        :type progress: :class:`~python:float`\n\n        :param kwargs: Extra request options\n        :type kwargs: :class:`~python:dict`\n\n        :return: Response (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    'action': 'start',\n                    'progress': 1.25,\n\n                    'sharing': {\n                        'facebook': true,\n                        'twitter': true,\n                        'tumblr': false\n                    },\n\n                    'movie': {\n                        'title': 'Guardians of the Galaxy',\n                        'year': 2014,\n\n                        'ids': {\n                            'trakt': 28,\n                            'slug': 'guardians-of-the-galaxy-2014',\n                            'imdb': 'tt2015381',\n                            'tmdb': 118340\n                        }\n                    }\n                }\n\n        :rtype: :class:`~python:dict`\n        \"\"\"\n        if movie and (show or episode):\n            raise ValueError('Only one media type should be provided')\n\n        if not movie and not episode:\n            raise ValueError('Missing media item')\n\n        data = {\n            'progress': progress,\n            'app_version': kwargs.pop('app_version', self.client.version),\n            'app_date': kwargs.pop('app_date', None)\n        }\n\n        if movie:\n            # TODO validate\n            data['movie'] = movie\n        elif episode:\n            if show:\n                data['show'] = show\n\n            # TODO validate\n            data['episode'] = episode\n\n        response = self.http.post(\n            action,\n            data=data,\n            **popitems(kwargs, [\n                'authenticated',\n                'validate_token'\n            ])\n        )\n\n        return self.get_data(response, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(self, movie=None, show=None, episode=None, progress=0.0, **kwargs):\n        return self.action(\n            'start',\n            movie, show, episode,\n            progress,\n\n            **kwargs\n        )", "response": "Send the scrobble start action."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending the scrobble pause action.", "response": "def pause(self, movie=None, show=None, episode=None, progress=0.0, **kwargs):\n        \"\"\"Send the scrobble \"pause' action.\n\n        Use this method when the video is paused. The playback progress will be saved and\n        :code:`Trakt['sync/playback'].get()` can be used to resume the video from this exact\n        position. Un-pause a video by calling the :code:`Trakt['scrobble'].start()` method again.\n\n        :param movie: Movie definition (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    'title': 'Guardians of the Galaxy',\n                    'year': 2014,\n\n                    'ids': {\n                        'tmdb': 118340\n                    }\n                }\n\n        :type movie: :class:`~python:dict`\n\n        :param show: Show definition (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    'title': 'Breaking Bad',\n                    'year': 2008,\n\n                    'ids': {\n                        'tvdb': 81189\n                    }\n                }\n\n\n        :type show: :class:`~python:dict`\n\n        :param episode: Episode definition (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    \"season\": 3,\n                    \"number\": 11\n                }\n\n        :type episode: :class:`~python:dict`\n\n        :param progress: Current movie/episode progress percentage\n        :type progress: :class:`~python:float`\n\n        :param kwargs: Extra request options\n        :type kwargs: :class:`~python:dict`\n\n        :return: Response (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    'action': 'pause',\n                    'progress': 75,\n\n                    'sharing': {\n                        'facebook': true,\n                        'twitter': true,\n                        'tumblr': false\n                    },\n\n                    'movie': {\n                        'title': 'Guardians of the Galaxy',\n                        'year': 2014,\n\n                        'ids': {\n                            'trakt': 28,\n                            'slug': 'guardians-of-the-galaxy-2014',\n                            'imdb': 'tt2015381',\n                            'tmdb': 118340\n                        }\n                    }\n                }\n\n        :rtype: :class:`~python:dict`\n        \"\"\"\n        return self.action(\n            'pause',\n            movie, show, episode,\n            progress,\n\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending the scrobble stop action.", "response": "def stop(self, movie=None, show=None, episode=None, progress=0.0, **kwargs):\n        \"\"\"Send the scrobble \"stop\" action.\n\n        Use this method when the video is stopped or finishes playing on its own. If the\n        progress is above 80%, the video will be scrobbled and the :code:`action` will be set\n        to **scrobble**.\n\n        If the progress is less than 80%, it will be treated as a *pause* and the :code:`action`\n        will be set to **pause**. The playback progress will be saved and :code:`Trakt['sync/playback'].get()`\n        can be used to resume the video from this exact position.\n\n        **Note:** If you prefer to use a threshold higher than 80%, you should use :code:`Trakt['scrobble'].pause()`\n        yourself so it doesn't create duplicate scrobbles.\n\n        :param movie: Movie definition (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    'title': 'Guardians of the Galaxy',\n                    'year': 2014,\n\n                    'ids': {\n                        'tmdb': 118340\n                    }\n                }\n\n        :type movie: :class:`~python:dict`\n\n        :param show: Show definition (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    'title': 'Breaking Bad',\n                    'year': 2008,\n\n                    'ids': {\n                        'tvdb': 81189\n                    }\n                }\n\n\n        :type show: :class:`~python:dict`\n\n        :param episode: Episode definition (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    \"season\": 3,\n                    \"number\": 11\n                }\n\n        :type episode: :class:`~python:dict`\n\n        :param progress: Current movie/episode progress percentage\n        :type progress: :class:`~python:float`\n\n        :param kwargs: Extra request options\n        :type kwargs: :class:`~python:dict`\n\n        :return: Response (or `None`)\n\n            **Example:**\n\n            .. code-block:: python\n\n                {\n                    'action': 'scrobble',\n                    'progress': 99.9,\n\n                    'sharing': {\n                        'facebook': true,\n                        'twitter': true,\n                        'tumblr': false\n                    },\n\n                    'movie': {\n                        'title': 'Guardians of the Galaxy',\n                        'year': 2014,\n\n                        'ids': {\n                            'trakt': 28,\n                            'slug': 'guardians-of-the-galaxy-2014',\n                            'imdb': 'tt2015381',\n                            'tmdb': 118340\n                        }\n                    }\n                }\n\n        :rtype: :class:`~python:dict`\n        \"\"\"\n        return self.action(\n            'stop',\n            movie, show, episode,\n            progress,\n\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self, **kwargs):\n\n        return self._client['users/*/lists/*'].delete(self.username, self.id, **kwargs)", "response": "Delete the list.\n\n        :param kwargs: Extra request options\n        :type kwargs: :class:`~python:dict`\n\n        :return: Boolean to indicate if the request was successful\n        :rtype: :class:`~python:bool`"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the list with the current object attributes.", "response": "def update(self, **kwargs):\n        \"\"\"Update the list with the current object attributes.\n\n        :param kwargs: Extra request options\n        :type kwargs: :class:`~python:dict`\n\n        :return: Boolean to indicate if the request was successful\n        :rtype: :class:`~python:bool`\n        \"\"\"\n\n        item = self._client['users/*/lists/*'].update(self.username, self.id, return_type='data', **kwargs)\n\n        if not item:\n            return False\n\n        self._update(item)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves specified items from the list.", "response": "def remove(self, items, **kwargs):\n        \"\"\"Remove specified items from the list.\n\n        :param items: Items that should be removed from the list\n        :type items: :class:`~python:list`\n\n        :param kwargs: Extra request options\n        :type kwargs: :class:`~python:dict`\n\n        :return: Response\n        :rtype: :class:`~python:dict`\n        \"\"\"\n\n        return self._client['users/*/lists/*'].remove(self.username, self.id, items, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef like(self, **kwargs):\n\n        return self._client['users/*/lists/*'].like(self.username, self.id, **kwargs)", "response": "Like the list.\n\n        :param kwargs: Extra request options\n        :type kwargs: :class:`~python:dict`\n\n        :return: Boolean to indicate if the request was successful\n        :rtype: :class:`~python:bool`"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, source, media, collection=None, start_date=None, days=None, query=None, years=None, genres=None,\n            languages=None, countries=None, runtimes=None, ratings=None, certifications=None, networks=None,\n            status=None, **kwargs):\n        \"\"\"Retrieve calendar items.\n\n        The `all` calendar displays info for all shows airing during the specified period. The `my` calendar displays\n        episodes for all shows that have been watched, collected, or watchlisted.\n\n        :param source: Calendar source (`all` or `my`)\n        :type source: str\n\n        :param media: Media type (`dvd`, `movies` or `shows`)\n        :type media: str\n\n        :param collection: Collection type (`new`, `premieres`)\n        :type collection: str or None\n\n        :param start_date: Start date (defaults to today)\n        :type start_date: datetime or None\n\n        :param days: Number of days to display (defaults to `7`)\n        :type days: int or None\n\n        :param query: Search title or description.\n        :type query: str or None\n\n        :param years: Year or range of years (e.g. `2014`, or `2014-2016`)\n        :type years: int or str or tuple or None\n\n        :param genres: Genre slugs (e.g. `action`)\n        :type genres: str or list of str or None\n\n        :param languages: Language codes (e.g. `en`)\n        :type languages: str or list of str or None\n\n        :param countries: Country codes (e.g. `us`)\n        :type countries: str or list of str or None\n\n        :param runtimes: Runtime range in minutes (e.g. `30-90`)\n        :type runtimes: str or tuple or None\n\n        :param ratings: Rating range between `0` and `100` (e.g. `75-100`)\n        :type ratings: str or tuple or None\n\n        :param certifications: US Content Certification (e.g. `pg-13`, `tv-pg`)\n        :type certifications: str or list of str or None\n\n        :param networks: (TV) Network name (e.g. `HBO`)\n        :type networks: str or list of str or None\n\n        :param status: (TV) Show status (e.g. `returning series`, `in production`, ended`)\n        :type status: str or list of str or None\n\n        :return: Items\n        :rtype: list of trakt.objects.video.Video\n        \"\"\"\n        if source not in ['all', 'my']:\n            raise ValueError('Unknown collection type: %s' % (source,))\n\n        if media not in ['dvd', 'movies', 'shows']:\n            raise ValueError('Unknown media type: %s' % (media,))\n\n        # Default `start_date` to today when only `days` is provided\n        if start_date is None and days:\n            start_date = datetime.utcnow()\n\n        # Request calendar collection\n        response = self.http.get(\n            '/calendars/%s/%s%s' % (\n                source, media,\n                ('/' + collection) if collection else ''\n            ),\n            params=[\n                start_date.strftime('%Y-%m-%d') if start_date else None,\n                days\n            ],\n            query={\n                'query': query,\n                'years': years,\n                'genres': genres,\n\n                'languages': languages,\n                'countries': countries,\n                'runtimes': runtimes,\n\n                'ratings': ratings,\n                'certifications': certifications,\n\n                # TV\n                'networks': networks,\n                'status': status\n            },\n            **popitems(kwargs, [\n                'authenticated',\n                'validate_token'\n            ])\n        )\n\n        # Parse response\n        items = self.get_data(response, **kwargs)\n\n        if isinstance(items, requests.Response):\n            return items\n\n        # Map items\n        if media == 'shows':\n            return SummaryMapper.episodes(\n                self.client, items,\n                parse_show=True\n            )\n\n        return SummaryMapper.movies(self.client, items)", "response": "Retrieve all items from the specified calendar."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a flat episode iterator.", "response": "def episodes(self):\n        \"\"\"Return a flat episode iterator.\n\n        :returns: Iterator :code:`((season_num, episode_num), Episode)`\n        :rtype: iterator\n        \"\"\"\n\n        for sk, season in iteritems(self.seasons):\n            # Yield each episode in season\n            for ek, episode in iteritems(season.episodes):\n                yield (sk, ek), episode"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_dict(self):\n\n        result = self.to_identifier()\n\n        result['seasons'] = [\n            season.to_dict()\n            for season in self.seasons.values()\n        ]\n\n        result['in_watchlist'] = self.in_watchlist if self.in_watchlist is not None else 0\n\n        if self.rating:\n            result['rating'] = self.rating.value\n            result['rated_at'] = to_iso8601_datetime(self.rating.timestamp)\n\n        # Extended Info\n        if self.first_aired:\n            result['first_aired'] = to_iso8601_datetime(self.first_aired)\n\n        if self.updated_at:\n            result['updated_at'] = to_iso8601_datetime(self.updated_at)\n\n        if self.overview:\n            result['overview'] = self.overview\n\n        if self.airs:\n            result['airs'] = self.airs\n\n        if self.runtime:\n            result['runtime'] = self.runtime\n\n        if self.certification:\n            result['certification'] = self.certification\n\n        if self.network:\n            result['network'] = self.network\n\n        if self.country:\n            result['country'] = self.country\n\n        if self.status:\n            result['status'] = self.status\n\n        if self.homepage:\n            result['homepage'] = self.homepage\n\n        if self.language:\n            result['language'] = self.language\n\n        if self.available_translations:\n            result['available_translations'] = self.available_translations\n\n        if self.genres:\n            result['genres'] = self.genres\n\n        if self.aired_episodes:\n            result['aired_episodes'] = self.aired_episodes\n\n        return result", "response": "Dump show to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef construct_url(self):\n        path = [self.path]\n        path.extend(self.params)\n\n        # Build URL\n        url = self.client.base_url + '/'.join(\n            str(value) for value in path\n            if value\n        )\n\n        # Append query parameters (if defined)\n        query = self.encode_query(self.query)\n\n        if query:\n            url += '?' + query\n\n        return url", "response": "Construct a full trakt request URI with params and query parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch for officers by name.", "response": "def search_officers(self, term, disqualified=False, **kwargs):\n        \"\"\"Search for officers by name.\n\n        Args:\n          term (str): Officer name to search on.\n          disqualified (Optional[bool]): True to search for disqualified\n            officers\n          kwargs (dict): additional keywords passed into\n            requests.session.get params keyword.\n        \"\"\"\n        search_type = ('officers' if not disqualified else\n                       'disqualified-officers')\n        params = kwargs\n        params['q'] = term\n        baseuri = self._BASE_URI + 'search/{}'.format(search_type)\n        res = self.session.get(baseuri, params=params)\n        self.handle_http_error(res)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches for company addresses by company number.", "response": "def address(self, num):\n        \"\"\"Search for company addresses by company number.\n\n        Args:\n          num (str): Company number to search on.\n        \"\"\"\n        url_root = \"company/{}/registered-office-address\"\n        baseuri = self._BASE_URI + url_root.format(num)\n        res = self.session.get(baseuri)\n        self.handle_http_error(res)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef profile(self, num):\n        baseuri = self._BASE_URI + \"company/{}\".format(num)\n        res = self.session.get(baseuri)\n        self.handle_http_error(res)\n        return res", "response": "Search for company profile by company number."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch for a company s filling history by company number.", "response": "def filing_history(self, num, transaction=None, **kwargs):\n        \"\"\"Search for a company's filling history by company number.\n\n        Args:\n          num (str): Company number to search on.\n\n          transaction (Optional[str]): Filing record number.\n          kwargs (dict): additional keywords passed into\n            requests.session.get params keyword.\n        \"\"\"\n        baseuri = self._BASE_URI + \"company/{}/filing-history\".format(num)\n        if transaction is not None:\n            baseuri += \"/{}\".format(transaction)\n        res = self.session.get(baseuri, params=kwargs)\n        self.handle_http_error(res)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef charges(self, num, charge_id=None, **kwargs):\n        baseuri = self._BASE_URI + \"company/{}/charges\".format(num)\n        if charge_id is not None:\n            baseuri += \"/{}\".format(charge_id)\n            res = self.session.get(baseuri, params=kwargs)\n        else:\n            res = self.session.get(baseuri, params=kwargs)\n        self.handle_http_error(res)\n        return res", "response": "Search for charges against a company by company number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch for a company s registered officers by company number.", "response": "def officers(self, num, **kwargs):\n        \"\"\"Search for a company's registered officers by company number.\n\n        Args:\n          num (str): Company number to search on.\n          kwargs (dict): additional keywords passed into\n            requests.session.get *params* keyword.\n        \"\"\"\n        baseuri = self._BASE_URI + \"company/{}/officers\".format(num)\n        res = self.session.get(baseuri, params=kwargs)\n        self.handle_http_error(res)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef disqualified(self, num, natural=True, **kwargs):\n        search_type = 'natural' if natural else 'corporate'\n        baseuri = (self._BASE_URI +\n                   'disqualified-officers/{}/{}'.format(search_type, num))\n        res = self.session.get(baseuri, params=kwargs)\n        self.handle_http_error(res)\n        return res", "response": "Search for disqualified officers by officer ID."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsearch for a list of persons with significant control based on company number num.", "response": "def persons_significant_control(self, num, statements=False, **kwargs):\n        \"\"\"Search for a list of persons with significant control.\n\n        Searches for persons of significant control based on company number for\n        a specified company. Specify statements=True to only search for\n        officers with statements.\n\n        Args:\n            num (str, int): Company number to search on.\n            statements (Optional[bool]): Search only for persons with\n                statements. Default is False.\n            kwargs (dict): additional keywords passed into requests.session.get\n            *params* keyword.\n        \"\"\"\n        baseuri = (self._BASE_URI +\n                   'company/{}/persons-with-significant-control'.format(num))\n\n        # Only append statements to the URL if statements is True\n        if statements is True:\n            baseuri += '-statements'\n\n        res = self.session.get(baseuri, params=kwargs)\n        self.handle_http_error(res)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef significant_control(self,\n                            num,\n                            entity_id,\n                            entity_type='individual',\n                            **kwargs):\n        \"\"\"Get details of a specific entity with significant control.\n\n        Args:\n            num (str, int): Company number to search on.\n            entity_id (str, int): Entity id to request details for\n            entity_type (str, int): What type of entity to search for. Defaults\n                to 'individual'. Other possible opetions are\n                'corporate' (for corporate entitys), 'legal' (for legal\n                persons), 'statements' (for a person with significant control\n                statement) and 'secure' (for a super secure person).\n            kwargs (dict): additional keywords passed into requests.session.get\n            *params* keyword.\n        \"\"\"\n        # Dict mapping entity_type strings to url strings\n        entities = {'individual': 'individual',\n                    'corporate': 'corporate-entity',\n                    'legal': 'legal-person',\n                    'statements': 'persons-with-significant-control-statements',\n                    'secure': 'super-secure'}\n\n        # Make sure correct entity_type supplied\n        try:\n            entity = entities[entity_type]\n        except KeyError as e:\n            msg = (\"Wrong entity_type supplied. Please choose from \" +\n                   \"individual, corporate, legal, statements or secure\")\n            raise Exception(msg) from e\n\n        # Construct the request and return the result\n        baseuri = (self._BASE_URI +\n                   'company/{}/persons-with-significant-control/'.format(num) +\n                   '{}/{}'.format(entity, entity_id))\n        res = self.session.get(baseuri, params=kwargs)\n        self.handle_http_error(res)\n        return res", "response": "Get details of a specific entity with significant control."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrequesting for a document by the document id. Normally the response. content can be saved as a pdf file.", "response": "def document(self, document_id, **kwargs):\n        \"\"\"Requests for a document by the document id.\n           Normally the response.content can be saved as a pdf file\n\n        Args:\n           document_id (str): The id of the document retrieved.\n           kwargs (dict): additional keywords passed into\n            requests.session.get *params* keyword.\n        \"\"\"\n        baseuri = '{}document/{}/content'.format(self._DOCUMENT_URI,\n                                                 document_id)\n        res = self.session.get(baseuri, params=kwargs)\n        self.handle_http_error(res)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd file to webhook", "response": "def add_file(self, file, filename):\n        \"\"\"\n        add file to webhook\n        :param file: file content\n        :param filename: filename\n        :return:\n        \"\"\"\n        self.files['_{}'.format(filename)] = (filename, file)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_embed(self, embed):\n        self.embeds.append(embed.__dict__ if isinstance(embed, DiscordEmbed) else embed)", "response": "add embedded rich content\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef json(self):\n        data = dict()\n        embeds = self.embeds\n        self.embeds = list()\n        # convert DiscordEmbed to dict\n        for embed in embeds:\n            self.add_embed(embed)\n        for key, value in self.__dict__.items():\n            if value and key not in ['url', 'files', 'filename']:\n                data[key] = value\n        embeds_empty = all(not embed for embed in data[\"embeds\"]) if 'embeds' in data else True\n        if embeds_empty and 'content' not in data and bool(self.files) is False:\n            logger.error('webhook message is empty! set content or embed data')\n        return data", "response": "convert webhook data to json"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset timestamp of embed content", "response": "def set_timestamp(self, timestamp=str(datetime.datetime.utcfromtimestamp(time.time()))):\n        \"\"\"\n        set timestamp of embed content\n        :param timestamp: (optional) timestamp of embed content\n        \"\"\"\n        self.timestamp = timestamp"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_footer(self, **kwargs):\n        self.footer = {\n            'text': kwargs.get('text'),\n            'icon_url': kwargs.get('icon_url'),\n            'proxy_icon_url': kwargs.get('proxy_icon_url')\n        }", "response": "set footer information of embed\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_image(self, **kwargs):\n        self.image = {\n            'url': kwargs.get('url'),\n            'proxy_url': kwargs.get('proxy_url'),\n            'height': kwargs.get('height'),\n            'width': kwargs.get('width'),\n        }", "response": "set image of embed\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting thumbnail of embed", "response": "def set_thumbnail(self, **kwargs):\n        \"\"\"\n        set thumbnail of embed\n        :keyword url: source url of thumbnail (only supports http(s) and attachments)\n        :keyword proxy_url: a proxied thumbnail of the image\n        :keyword height: height of thumbnail\n        :keyword width: width of thumbnail\n        \"\"\"\n        self.thumbnail = {\n            'url': kwargs.get('url'),\n            'proxy_url': kwargs.get('proxy_url'),\n            'height': kwargs.get('height'),\n            'width': kwargs.get('width'),\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_video(self, **kwargs):\n        self.video = {\n            'url': kwargs.get('url'),\n            'height': kwargs.get('height'),\n            'width': kwargs.get('width'),\n        }", "response": "set video of embed\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset author of embed", "response": "def set_author(self, **kwargs):\n        \"\"\"\n        set author of embed\n        :keyword name: name of author\n        :keyword url: url of author\n        :keyword icon_url: url of author icon (only supports http(s) and attachments)\n        :keyword proxy_icon_url: a proxied url of author icon\n        \"\"\"\n        self.author = {\n            'name': kwargs.get('name'),\n            'url': kwargs.get('url'),\n            'icon_url': kwargs.get('icon_url'),\n            'proxy_icon_url': kwargs.get('proxy_icon_url'),\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_embed_field(self, **kwargs):\n        self.fields.append({\n            'name': kwargs.get('name'),\n            'value': kwargs.get('value'),\n            'inline': kwargs.get('inline', True)\n        })", "response": "add a field to embed\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nserves up a delicious plate with your models", "response": "def plate(self):\n        \"\"\"\n        Serves up a delicious plate with your models\n        \"\"\"\n        request = self.request\n        if self.settings is None:\n            graph_settings = deepcopy(getattr(settings, 'SPAGHETTI_SAUCE', {}))\n            graph_settings.update(self.override_settings)\n        else:\n            graph_settings = self.settings\n\n        apps = graph_settings.get('apps', [])\n\n        excludes = [\n            \"%s__%s\" % (app, model)\n            for app, models in graph_settings.get('exclude', {}).items()\n            for model in models\n        ]\n        models = ContentType.objects.filter(app_label__in=apps)\n        nodes = []\n        edges = []\n        for model in models:\n            if (model.model_class() is None):\n                continue\n            model.is_proxy = model.model_class()._meta.proxy\n            if (model.is_proxy and not graph_settings.get('show_proxy', False)):\n                continue\n\n            model.doc = model.model_class().__doc__\n            _id = \"%s__%s\" % (model.app_label, model.model)\n            if _id in excludes:\n                continue\n\n            label = self.get_node_label(model)\n\n            fields = [f for f in model.model_class()._meta.fields]\n            many = [f for f in model.model_class()._meta.many_to_many]\n            if graph_settings.get('show_fields', True):\n                label += \"\\n%s\\n\" % (\"-\" * len(model.model))\n                label += \"\\n\".join([str(f.name) for f in fields])\n            edge_color = {'inherit': 'from'}\n\n            for f in fields + many:\n                if f.remote_field is not None:\n                    m = f.remote_field.model._meta\n                    to_id = \"%s__%s\" % (m.app_label, m.model_name)\n                    if to_id in excludes:\n                        pass\n                    elif _id == to_id and graph_settings.get('ignore_self_referential', False):\n                        pass\n                    else:\n                        if m.app_label != model.app_label:\n                            edge_color = {'inherit': 'both'}\n\n                        edge = {'from': _id, 'to': to_id, 'color': edge_color}\n\n                        if str(f.name).endswith('_ptr'):\n                            # fields that end in _ptr are pointing to a parent object\n                            edge.update({\n                                'arrows': {'to': {'scaleFactor': 0.75}},  # needed to draw from-to\n                                'font': {'align': 'middle'},\n                                'label': 'is a',\n                                'dashes': True\n                            })\n                        elif type(f) == related.ForeignKey:\n                            edge.update({\n                                'arrows': {'to': {'scaleFactor': 0.75}}\n                            })\n                        elif type(f) == related.OneToOneField:\n                            edge.update({\n                                'font': {'align': 'middle'},\n                                'label': '|'\n                            })\n                        elif type(f) == related.ManyToManyField:\n                            edge.update({\n                                'color': {'color': 'gray'},\n                                'arrows': {'to': {'scaleFactor': 1}, 'from': {'scaleFactor': 1}},\n                            })\n\n                        edges.append(edge)\n            if model.is_proxy:\n                proxy = model.model_class()._meta.proxy_for_model._meta\n                model.proxy = proxy\n                edge = {\n                    'to': _id,\n                    'from': \"%s__%s\" % (proxy.app_label, proxy.model_name),\n                    'color': edge_color,\n                }\n                edges.append(edge)\n\n            all_node_fields = fields\n            if graph_settings.get('show_m2m_field_detail', False):\n                all_node_fields = fields + many\n            nodes.append(\n                {\n                    'id': _id,\n                    'label': label,\n                    'shape': 'box',\n                    'group': model.app_label,\n                    'title': get_template(self.meatball_template_name).render(\n                        {'model': model, 'fields': all_node_fields}\n                        )\n                }\n            )\n\n        data = {\n            'meatballs': json.dumps(nodes),\n            'spaghetti': json.dumps(edges)\n        }\n        return render(request, self.plate_template_name, data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_node_label(self, model):\n        if model.is_proxy:\n            label = \"(P) %s\" % (model.name.title())\n        else:\n            label = \"%s\" % (model.name.title())\n\n        line = \"\"\n        new_label = []\n        for w in label.split(\" \"):\n            if len(line + w) > 15:\n                new_label.append(line)\n                line = w\n            else:\n                line += \" \"\n                line += w\n        new_label.append(line)\n\n        return \"\\n\".join(new_label)", "response": "Returns a string that can be used to create a node label for a given model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall by _sslpsk. c to return the tuple for the socket with the specified ssl socket.", "response": "def _python_psk_client_callback(ssl_id, hint):\n    \"\"\"Called by _sslpsk.c to return the (psk, identity) tuple for the socket with\n    the specified ssl socket.\n\n    \"\"\"\n    if ssl_id not in _callbacks:\n        return (\"\", \"\")\n    else:\n        res = _callbacks[ssl_id](hint)\n        return res if isinstance(res, tuple) else (res, \"\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _sslobj(sock):\n    pass\n    if isinstance(sock._sslobj, _ssl._SSLSocket):\n        return sock._sslobj\n    else:\n        return sock._sslobj._sslobj", "response": "Returns the underlying PySLLSocket object with which the C extension\n    functions interface is used."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _colorize(val, color):\n    if termcolor is not None:\n        val = termcolor.colored(val, color)\n    elif colorama is not None:\n        val = TERMCOLOR2COLORAMA[color] + val + colorama.Style.RESET_ALL\n\n    return val", "response": "Colorize a string using termcolor or colorama."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_time(self, value):\n        try:\n            # Default time unit is a second, we should convert it to milliseconds.\n            return int(value) * 1000\n        except ValueError:\n            # Try to parse if we are unlucky to cast value into int.\n            m = self.time_format.match(value)\n            if not m:\n                raise ValueError(\"Could not parse time represented by '{t}'\".format(t=value))\n            time = int(m.group('time'))\n            if m.group('units') != 'ms':\n                time *= 1000\n            return time", "response": "Parse string time representation to get number of milliseconds."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconfigures the test timer plugin.", "response": "def configure(self, options, config):\n        \"\"\"Configures the test timer plugin.\"\"\"\n        super(TimerPlugin, self).configure(options, config)\n        self.config = config\n        if self.enabled:\n            self.timer_top_n = int(options.timer_top_n)\n            self.timer_ok = self._parse_time(options.timer_ok)\n            self.timer_warning = self._parse_time(options.timer_warning)\n            self.timer_filter = self._parse_filter(options.timer_filter)\n            self.timer_fail = options.timer_fail\n            self.timer_no_color = True\n            self.json_file = options.json_file\n\n            # Windows + nosetests does not support colors (even with colorama).\n            if not IS_NT:\n                self.timer_no_color = options.timer_no_color\n\n            # determine if multiprocessing plugin enabled\n            self.multiprocessing_enabled = bool(getattr(options, 'multiprocess_workers', False))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef report(self, stream):\n        if not self.enabled:\n            return\n\n        # if multiprocessing plugin enabled - get items from results queue\n        if self.multiprocessing_enabled:\n            for i in range(_results_queue.qsize()):\n                try:\n                    k, v, s = _results_queue.get(False)\n                    self._timed_tests[k] = {\n                        'time': v,\n                        'status': s,\n                    }\n                except Queue.Empty:\n                    pass\n\n        d = sorted(self._timed_tests.items(), key=lambda item: item[1]['time'], reverse=True)\n\n        if self.json_file:\n            dict_type = OrderedDict if self.timer_top_n else dict\n            with open(self.json_file, 'w') as f:\n                json.dump({'tests': dict_type((k, v) for k, v in d)}, f)\n\n        total_time = sum([vv['time'] for kk, vv in d])\n\n        for i, (test, time_and_status) in enumerate(d):\n            time_taken = time_and_status['time']\n            status = time_and_status['status']\n            if i < self.timer_top_n or self.timer_top_n == -1:\n                color = self._get_result_color(time_taken)\n                percent = 0 if total_time == 0 else time_taken / total_time * 100\n                line = self._format_report_line(\n                    test=test,\n                    time_taken=time_taken,\n                    color=color,\n                    status=status,\n                    percent=percent,\n                )\n                _filter = self._COLOR_TO_FILTER.get(color)\n                if self.timer_filter is None or _filter is None or _filter in self.timer_filter:\n                    stream.writeln(line)", "response": "Report the test times."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_result_color(self, time_taken):\n        time_taken_ms = time_taken * 1000\n        if time_taken_ms <= self.timer_ok:\n            color = 'green'\n        elif time_taken_ms <= self.timer_warning:\n            color = 'yellow'\n        else:\n            color = 'red'\n\n        return color", "response": "Get time taken result color."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef threshold(self):\n        if self._threshold is None:\n            self._threshold = {\n                'error': self.timer_warning,\n                'warning': self.timer_ok,\n            }[self.timer_fail]\n        return self._threshold", "response": "Get maximum test time allowed when -- timer - fail option is used."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _colored_time(self, time_taken, color=None):\n        if self.timer_no_color:\n            return \"{0:0.4f}s\".format(time_taken)\n\n        return _colorize(\"{0:0.4f}s\".format(time_taken), color)", "response": "Get formatted and colored string for a given time taken."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats a single report line.", "response": "def _format_report_line(self, test, time_taken, color, status, percent):\n        \"\"\"Format a single report line.\"\"\"\n        return \"[{0}] {3:04.2f}% {1}: {2}\".format(\n            status, test, self._colored_time(time_taken, color), percent\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addSuccess(self, test, capt=None):\n        time_taken = self._register_time(test, 'success')\n        if self.timer_fail is not None and time_taken * 1000.0 > self.threshold:\n            test.fail('Test was too slow (took {0:0.4f}s, threshold was '\n                      '{1:0.4f}s)'.format(time_taken, self.threshold / 1000.0))", "response": "Called when a test passes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef summarize(self, text, length=5, weighting='frequency', norm=None):\n\n        text = self._parse_input(text)\n\n        sentences, unprocessed_sentences = self._tokenizer.tokenize_sentences(text)\n\n        length = self._parse_summary_length(length, len(sentences))\n        if length == len(sentences):\n            return unprocessed_sentences\n\n        # Compute the word frequency matrix. If norm is set to 'l1' or 'l2' then words are normalized\n        # by the length of their associated sentences (such that each vector of sentence terms sums to 1).\n        word_matrix = self._compute_matrix(sentences, weighting=weighting, norm=norm)\n\n        # Build the similarity graph by calculating the number of overlapping words between all\n        # combinations of sentences.\n        similarity_matrix = (word_matrix * word_matrix.T)\n\n        similarity_graph = networkx.from_scipy_sparse_matrix(similarity_matrix)\n        scores = networkx.pagerank(similarity_graph)\n\n        ranked_sentences = sorted(\n            ((score, ndx) for ndx, score in scores.items()), reverse=True\n        )\n\n        top_sentences = [ranked_sentences[i][1] for i in range(length)]\n        top_sentences.sort()\n\n        return [unprocessed_sentences[i] for i in top_sentences]", "response": "Implements the TextRank summarization algorithm for ranking\n        web pages."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_stopwords(self, tokens):\n        if isinstance(tokens, (list, tuple)):\n            return [word for word in tokens if word.lower() not in self._stopwords]\n        else:\n            return ' '.join(\n                [word for word in tokens.split(' ') if word.lower() not in self._stopwords]\n            )", "response": "Remove all stopwords from a list of word tokens or a string of text."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nperforming stemming on an input word.", "response": "def stem(self, word):\n        \"\"\"Perform stemming on an input word.\"\"\"\n        if self.stemmer:\n            return unicode_to_ascii(self._stemmer.stem(word))\n        else:\n            return word"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstripping leading and trailing punctuation from an input string.", "response": "def strip_punctuation(text, exclude='', include=''):\n        \"\"\"Strip leading and trailing punctuation from an input string.\"\"\"\n        chars_to_strip = ''.join(\n            set(list(punctuation)).union(set(list(include))) - set(list(exclude))\n        )\n        return text.strip(chars_to_strip)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves excess whitespace from the ends of a given string.", "response": "def _remove_whitespace(text):\n        \"\"\"Remove excess whitespace from the ends of a given input string.\"\"\"\n        # while True:\n        #     old_text = text\n        #     text = text.replace('  ', ' ')\n        #     if text == old_text:\n        #         return text\n        non_spaces = re.finditer(r'[^ ]', text)\n\n        if not non_spaces:\n            return text\n\n        first_non_space = non_spaces.next()\n        first_non_space = first_non_space.start()\n\n        last_non_space = None\n        for item in non_spaces:\n            last_non_space = item\n\n        if not last_non_space:\n            return text[first_non_space:]\n        else:\n            last_non_space = last_non_space.end()\n            return text[first_non_space:last_non_space]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of sentences given an input string of text. :param text: input string :param word_threshold: number of significant words that a sentence must contain to be counted (to count all sentences set equal to 1; 5 by default) :return: list of sentences", "response": "def tokenize_sentences(self, text, word_threshold=5):\n        \"\"\"\n        Returns a list of sentences given an input string of text.\n\n        :param text: input string\n        :param word_threshold: number of significant words that a sentence must contain to be counted\n        (to count all sentences set equal to 1; 5 by default)\n        :return: list of sentences\n        \"\"\"\n        punkt_params = PunktParameters()\n        # Not using set literal to allow compatibility with Python 2.6\n        punkt_params.abbrev_types = set([\n            'dr', 'vs', 'mr', 'mrs', 'ms', 'prof', 'mt', 'inc', 'i.e', 'e.g'\n        ])\n        sentence_splitter = PunktSentenceTokenizer(punkt_params)\n\n        # 1. TOKENIZE \"UNPROCESSED\" SENTENCES FOR DISPLAY\n        # Need to adjust quotations for correct sentence splitting\n        text_unprocessed = text.replace('?\"', '? \"').replace('!\"', '! \"').replace('.\"', '. \"')\n\n        # Treat line breaks as end of sentence (needed in cases where titles don't have a full stop)\n        text_unprocessed = text_unprocessed.replace('\\n', ' . ')\n\n        # Perform sentence splitting\n        unprocessed_sentences = sentence_splitter.tokenize(text_unprocessed)\n\n        # Now that sentences have been split we can return them back to their normal formatting\n        for ndx, sentence in enumerate(unprocessed_sentences):\n            sentence = unicode_to_ascii(sentence)  # Sentence splitter returns unicode strings\n            sentence = sentence.replace('? \" ', '?\" ').replace('! \" ', '!\" ').replace('. \" ', '.\" ')\n            sentence = self._remove_whitespace(sentence)  # Remove excess whitespace\n            sentence = sentence[:-2] if (sentence.endswith(' .') or sentence.endswith(' . ')) else sentence\n            unprocessed_sentences[ndx] = sentence\n\n        # 2. PROCESS THE SENTENCES TO PERFORM STEMMING, STOPWORDS REMOVAL ETC. FOR MATRIX COMPUTATION\n        processed_sentences = [self.sanitize_text(sen) for sen in unprocessed_sentences]\n\n        # Sentences should contain at least 'word_threshold' significant terms\n        filter_sentences = [i for i in range(len(processed_sentences))\n                            if len(processed_sentences[i].replace('.', '').split(' ')) > word_threshold]\n\n        processed_sentences = [processed_sentences[i] for i in filter_sentences]\n        unprocessed_sentences = [unprocessed_sentences[i] for i in filter_sentences]\n\n        return processed_sentences, unprocessed_sentences"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tokenize_paragraphs(cls, text):\n        paragraphs = []\n        paragraphs_first_pass = text.split('\\n')\n        for p in paragraphs_first_pass:\n            paragraphs_second_pass = re.split('\\s{4,}', p)\n            paragraphs += paragraphs_second_pass\n\n        # Remove empty strings from list\n        paragraphs = [p for p in paragraphs if p]\n        return paragraphs", "response": "Convert an input string into a list of paragraphs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nperforming singular value decomposition for dimensionality reduction of the input matrix.", "response": "def _svd(cls, matrix, num_concepts=5):\n        \"\"\"\n        Perform singular value decomposition for dimensionality reduction of the input matrix.\n        \"\"\"\n        u, s, v = svds(matrix, k=num_concepts)\n        return u, s, v"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef summarize(self, text, topics=4, length=5, binary_matrix=True, topic_sigma_threshold=0.5):\n\n        text = self._parse_input(text)\n\n        sentences, unprocessed_sentences = self._tokenizer.tokenize_sentences(text)\n\n        length = self._parse_summary_length(length, len(sentences))\n        if length == len(sentences):\n            return unprocessed_sentences\n\n        topics = self._validate_num_topics(topics, sentences)\n\n        # Generate a matrix of terms that appear in each sentence\n        weighting = 'binary' if binary_matrix else 'frequency'\n        sentence_matrix = self._compute_matrix(sentences, weighting=weighting)\n        sentence_matrix = sentence_matrix.transpose()\n\n        # Filter out negatives in the sparse matrix (need to do this on Vt for LSA method):\n        sentence_matrix = sentence_matrix.multiply(sentence_matrix > 0)\n\n        s, u, v = self._svd(sentence_matrix, num_concepts=topics)\n\n        # Only consider topics/concepts whose singular values are half of the largest singular value\n        if 1 <= topic_sigma_threshold < 0:\n            raise ValueError('Parameter topic_sigma_threshold must take a value between 0 and 1')\n\n        sigma_threshold = max(u) * topic_sigma_threshold\n        u[u < sigma_threshold] = 0  # Set all other singular values to zero\n\n        # Build a \"length vector\" containing the length (i.e. saliency) of each sentence\n        saliency_vec = np.dot(np.square(u), np.square(v))\n\n        top_sentences = saliency_vec.argsort()[-length:][::-1]\n        # Return the sentences in the order in which they appear in the document\n        top_sentences.sort()\n\n        return [unprocessed_sentences[i] for i in top_sentences]", "response": "This method is used to summarize the text of a specific language."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_payment(self, payment):\n        validation = \"\"\n\n        if not isinstance(payment['amount'], int):\n            validation += \"AMOUNT_NOT_INTEGER \"\n\n        if not isinstance(payment['mandate_date'], datetime.date):\n            validation += \"MANDATE_DATE_INVALID_OR_NOT_DATETIME_INSTANCE\"\n        payment['mandate_date'] = str(payment['mandate_date'])\n\n        if not isinstance(payment['collection_date'], datetime.date):\n            validation += \"COLLECTION_DATE_INVALID_OR_NOT_DATETIME_INSTANCE\"\n        payment['collection_date'] = str(payment['collection_date'])\n\n        if validation == \"\":\n            return True\n        else:\n            raise Exception('Payment did not validate: ' + validation)", "response": "Check the payment for required fields and validity."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions to add payments", "response": "def add_payment(self, payment):\n        \"\"\"\n        Function to add payments\n        @param payment: The payment dict\n        @raise exception: when payment is invalid\n        \"\"\"\n        if self.clean:\n            from text_unidecode import unidecode\n\n            payment['name'] = unidecode(payment['name'])[:70]\n            payment['description'] = unidecode(payment['description'])[:140]\n\n        # Validate the payment\n        self.check_payment(payment)\n\n        # Get the CstmrDrctDbtInitnNode\n        if not self._config['batch']:\n            # Start building the non batch payment\n            PmtInf_nodes = self._create_PmtInf_node()\n            PmtInf_nodes['PmtInfIdNode'].text = make_id(self._config['name'])\n            PmtInf_nodes['PmtMtdNode'].text = \"DD\"\n            PmtInf_nodes['BtchBookgNode'].text = \"false\"\n            PmtInf_nodes['NbOfTxsNode'].text = \"1\"\n            PmtInf_nodes['CtrlSumNode'].text = int_to_decimal_str(\n                payment['amount'])\n            PmtInf_nodes['Cd_SvcLvl_Node'].text = \"SEPA\"\n            PmtInf_nodes['Cd_LclInstrm_Node'].text = self._config['instrument']\n            PmtInf_nodes['SeqTpNode'].text = payment['type']\n            PmtInf_nodes['ReqdColltnDtNode'].text = payment['collection_date']\n            PmtInf_nodes['Nm_Cdtr_Node'].text = self._config['name']\n            PmtInf_nodes['IBAN_CdtrAcct_Node'].text = self._config['IBAN']\n\n            if 'BIC' in self._config:\n                PmtInf_nodes['BIC_CdtrAgt_Node'].text = self._config['BIC']\n\n            PmtInf_nodes['ChrgBrNode'].text = \"SLEV\"\n            PmtInf_nodes['Nm_CdtrSchmeId_Node'].text = self._config['name']\n            PmtInf_nodes['Id_Othr_Node'].text = self._config['creditor_id']\n            PmtInf_nodes['PrtryNode'].text = \"SEPA\"\n\n        if 'BIC' in payment:\n            bic = True\n        else:\n            bic = False\n\n        TX_nodes = self._create_TX_node(bic)\n        TX_nodes['InstdAmtNode'].set(\"Ccy\", self._config['currency'])\n        TX_nodes['InstdAmtNode'].text = int_to_decimal_str(payment['amount'])\n\n        TX_nodes['MndtIdNode'].text = payment['mandate_id']\n        TX_nodes['DtOfSgntrNode'].text = payment['mandate_date']\n        if bic:\n            TX_nodes['BIC_DbtrAgt_Node'].text = payment['BIC']\n\n        TX_nodes['Nm_Dbtr_Node'].text = payment['name']\n        TX_nodes['IBAN_DbtrAcct_Node'].text = payment['IBAN']\n        TX_nodes['UstrdNode'].text = payment['description']\n        if not payment.get('endtoend_id', ''):\n            payment['endtoend_id'] = make_id(self._config['name'])\n        TX_nodes['EndToEndIdNode'].text = payment['endtoend_id']\n\n        if self._config['batch']:\n            self._add_batch(TX_nodes, payment)\n        else:\n            self._add_non_batch(TX_nodes, PmtInf_nodes)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfunctioning to create the GroupHeader in the current log record.", "response": "def _create_header(self):\n        \"\"\"\n        Function to create the GroupHeader (GrpHdr) in the\n        CstmrDrctDbtInit Node\n        \"\"\"\n        # Retrieve the node to which we will append the group header.\n        CstmrDrctDbtInitn_node = self._xml.find('CstmrDrctDbtInitn')\n\n        # Create the header nodes.\n        GrpHdr_node = ET.Element(\"GrpHdr\")\n        MsgId_node = ET.Element(\"MsgId\")\n        CreDtTm_node = ET.Element(\"CreDtTm\")\n        NbOfTxs_node = ET.Element(\"NbOfTxs\")\n        CtrlSum_node = ET.Element(\"CtrlSum\")\n        InitgPty_node = ET.Element(\"InitgPty\")\n        Nm_node = ET.Element(\"Nm\")\n        SupId_node = ET.Element(\"Id\")\n        OrgId_node = ET.Element(\"OrgId\")\n        Othr_node = ET.Element(\"Othr\")\n        Id_node = ET.Element(\"Id\")\n\n        # Add data to some header nodes.\n        MsgId_node.text = self.msg_id\n        CreDtTm_node.text = datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')\n        Nm_node.text = self._config['name']\n        Id_node.text = self._config['creditor_id']\n\n        # Append the nodes\n        Othr_node.append(Id_node)\n        OrgId_node.append(Othr_node)\n        SupId_node.append(OrgId_node)\n        InitgPty_node.append(Nm_node)\n        InitgPty_node.append(SupId_node)\n        GrpHdr_node.append(MsgId_node)\n        GrpHdr_node.append(CreDtTm_node)\n        GrpHdr_node.append(NbOfTxs_node)\n        GrpHdr_node.append(CtrlSum_node)\n        GrpHdr_node.append(InitgPty_node)\n\n        # Append the header to its parent\n        CstmrDrctDbtInitn_node.append(GrpHdr_node)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _create_PmtInf_node(self):\n        ED = dict()  # ED is element dict\n        ED['PmtInfNode'] = ET.Element(\"PmtInf\")\n        ED['PmtInfIdNode'] = ET.Element(\"PmtInfId\")\n        ED['PmtMtdNode'] = ET.Element(\"PmtMtd\")\n        ED['BtchBookgNode'] = ET.Element(\"BtchBookg\")\n        ED['NbOfTxsNode'] = ET.Element(\"NbOfTxs\")\n        ED['CtrlSumNode'] = ET.Element(\"CtrlSum\")\n        ED['PmtTpInfNode'] = ET.Element(\"PmtTpInf\")\n        ED['SvcLvlNode'] = ET.Element(\"SvcLvl\")\n        ED['Cd_SvcLvl_Node'] = ET.Element(\"Cd\")\n        ED['LclInstrmNode'] = ET.Element(\"LclInstrm\")\n        ED['Cd_LclInstrm_Node'] = ET.Element(\"Cd\")\n        ED['SeqTpNode'] = ET.Element(\"SeqTp\")\n        ED['ReqdColltnDtNode'] = ET.Element(\"ReqdColltnDt\")\n        ED['CdtrNode'] = ET.Element(\"Cdtr\")\n        ED['Nm_Cdtr_Node'] = ET.Element(\"Nm\")\n        ED['CdtrAcctNode'] = ET.Element(\"CdtrAcct\")\n        ED['Id_CdtrAcct_Node'] = ET.Element(\"Id\")\n        ED['IBAN_CdtrAcct_Node'] = ET.Element(\"IBAN\")\n        ED['CdtrAgtNode'] = ET.Element(\"CdtrAgt\")\n        ED['FinInstnId_CdtrAgt_Node'] = ET.Element(\"FinInstnId\")\n        if 'BIC' in self._config:\n            ED['BIC_CdtrAgt_Node'] = ET.Element(\"BIC\")\n        ED['ChrgBrNode'] = ET.Element(\"ChrgBr\")\n        ED['CdtrSchmeIdNode'] = ET.Element(\"CdtrSchmeId\")\n        ED['Nm_CdtrSchmeId_Node'] = ET.Element(\"Nm\")\n        ED['Id_CdtrSchmeId_Node'] = ET.Element(\"Id\")\n        ED['PrvtIdNode'] = ET.Element(\"PrvtId\")\n        ED['OthrNode'] = ET.Element(\"Othr\")\n        ED['Id_Othr_Node'] = ET.Element(\"Id\")\n        ED['SchmeNmNode'] = ET.Element(\"SchmeNm\")\n        ED['PrtryNode'] = ET.Element(\"Prtry\")\n        return ED", "response": "Method to create the blank payment information nodes as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a non - batch transaction to the main xml.", "response": "def _add_non_batch(self, TX_nodes, PmtInf_nodes):\n        \"\"\"\n        Method to add a transaction as non batch, will fold the transaction\n        together with the payment info node and append to the main xml.\n        \"\"\"\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['PmtInfIdNode'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['PmtMtdNode'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['BtchBookgNode'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['NbOfTxsNode'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['CtrlSumNode'])\n\n        PmtInf_nodes['SvcLvlNode'].append(PmtInf_nodes['Cd_SvcLvl_Node'])\n        PmtInf_nodes['LclInstrmNode'].append(PmtInf_nodes['Cd_LclInstrm_Node'])\n        PmtInf_nodes['PmtTpInfNode'].append(PmtInf_nodes['SvcLvlNode'])\n        PmtInf_nodes['PmtTpInfNode'].append(PmtInf_nodes['LclInstrmNode'])\n        PmtInf_nodes['PmtTpInfNode'].append(PmtInf_nodes['SeqTpNode'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['PmtTpInfNode'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['ReqdColltnDtNode'])\n\n        PmtInf_nodes['CdtrNode'].append(PmtInf_nodes['Nm_Cdtr_Node'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['CdtrNode'])\n\n        PmtInf_nodes['Id_CdtrAcct_Node'].append(\n            PmtInf_nodes['IBAN_CdtrAcct_Node'])\n        PmtInf_nodes['CdtrAcctNode'].append(PmtInf_nodes['Id_CdtrAcct_Node'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['CdtrAcctNode'])\n\n        if 'BIC' in self._config:\n            PmtInf_nodes['FinInstnId_CdtrAgt_Node'].append(\n                PmtInf_nodes['BIC_CdtrAgt_Node'])\n        PmtInf_nodes['CdtrAgtNode'].append(\n            PmtInf_nodes['FinInstnId_CdtrAgt_Node'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['CdtrAgtNode'])\n\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['ChrgBrNode'])\n\n        if self.schema == 'pain.008.001.02':\n            PmtInf_nodes['CdtrSchmeIdNode'].append(PmtInf_nodes['Nm_CdtrSchmeId_Node'])\n        PmtInf_nodes['OthrNode'].append(PmtInf_nodes['Id_Othr_Node'])\n        PmtInf_nodes['SchmeNmNode'].append(PmtInf_nodes['PrtryNode'])\n        PmtInf_nodes['OthrNode'].append(PmtInf_nodes['SchmeNmNode'])\n        PmtInf_nodes['PrvtIdNode'].append(PmtInf_nodes['OthrNode'])\n        PmtInf_nodes['Id_CdtrSchmeId_Node'].append(PmtInf_nodes['PrvtIdNode'])\n        PmtInf_nodes['CdtrSchmeIdNode'].append(\n            PmtInf_nodes['Id_CdtrSchmeId_Node'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['CdtrSchmeIdNode'])\n\n        TX_nodes['PmtIdNode'].append(TX_nodes['EndToEndIdNode'])\n        TX_nodes['DrctDbtTxInfNode'].append(TX_nodes['PmtIdNode'])\n        TX_nodes['DrctDbtTxInfNode'].append(TX_nodes['InstdAmtNode'])\n\n        TX_nodes['MndtRltdInfNode'].append(TX_nodes['MndtIdNode'])\n        TX_nodes['MndtRltdInfNode'].append(TX_nodes['DtOfSgntrNode'])\n        TX_nodes['DrctDbtTxNode'].append(TX_nodes['MndtRltdInfNode'])\n        TX_nodes['DrctDbtTxInfNode'].append(TX_nodes['DrctDbtTxNode'])\n\n        if 'BIC_DbtrAgt_Node' in TX_nodes and TX_nodes['BIC_DbtrAgt_Node'].text is not None:\n            TX_nodes['FinInstnId_DbtrAgt_Node'].append(\n                TX_nodes['BIC_DbtrAgt_Node'])\n        TX_nodes['DbtrAgtNode'].append(TX_nodes['FinInstnId_DbtrAgt_Node'])\n        TX_nodes['DrctDbtTxInfNode'].append(TX_nodes['DbtrAgtNode'])\n\n        TX_nodes['DbtrNode'].append(TX_nodes['Nm_Dbtr_Node'])\n        TX_nodes['DrctDbtTxInfNode'].append(TX_nodes['DbtrNode'])\n\n        TX_nodes['Id_DbtrAcct_Node'].append(TX_nodes['IBAN_DbtrAcct_Node'])\n        TX_nodes['DbtrAcctNode'].append(TX_nodes['Id_DbtrAcct_Node'])\n        TX_nodes['DrctDbtTxInfNode'].append(TX_nodes['DbtrAcctNode'])\n\n        TX_nodes['RmtInfNode'].append(TX_nodes['UstrdNode'])\n        TX_nodes['DrctDbtTxInfNode'].append(TX_nodes['RmtInfNode'])\n        PmtInf_nodes['PmtInfNode'].append(TX_nodes['DrctDbtTxInfNode'])\n        CstmrDrctDbtInitn_node = self._xml.find('CstmrDrctDbtInitn')\n        CstmrDrctDbtInitn_node.append(PmtInf_nodes['PmtInfNode'])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the config file for required fields and validity.", "response": "def check_config(self, config):\n        \"\"\"\n        Check the config file for required fields and validity.\n        @param config: The config dict.\n        @return: True if valid, error string if invalid paramaters where\n        encountered.\n        \"\"\"\n        validation = \"\"\n        required = [\"name\", \"currency\", \"IBAN\", \"BIC\"]\n\n        for config_item in required:\n            if config_item not in config:\n                validation += config_item.upper() + \"_MISSING \"\n\n        if not validation:\n            return True\n        else:\n            raise Exception(\"Config file did not validate. \" + validation)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck the payment for required fields and validity.", "response": "def check_payment(self, payment):\n        \"\"\"\n        Check the payment for required fields and validity.\n        @param payment: The payment dict\n        @return: True if valid, error string if invalid paramaters where\n        encountered.\n        \"\"\"\n        validation = \"\"\n        required = [\"name\", \"IBAN\", \"BIC\", \"amount\", \"description\"]\n\n        for config_item in required:\n            if config_item not in payment:\n                validation += config_item.upper() + \"_MISSING \"\n\n        if not isinstance(payment['amount'], int):\n            validation += \"AMOUNT_NOT_INTEGER \"\n\n        if 'execution_date' in payment:\n            if not isinstance(payment['execution_date'], datetime.date):\n                validation += \"EXECUTION_DATE_INVALID_OR_NOT_DATETIME_INSTANCE\"\n            payment['execution_date'] = payment['execution_date'].isoformat()\n\n        if validation == \"\":\n            return True\n        else:\n            raise Exception('Payment did not validate: ' + validation)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions to create the GroupHeader in the current locale", "response": "def _create_header(self):\n        \"\"\"\n        Function to create the GroupHeader (GrpHdr) in the\n        CstmrCdtTrfInitn Node\n        \"\"\"\n        # Retrieve the node to which we will append the group header.\n        CstmrCdtTrfInitn_node = self._xml.find('CstmrCdtTrfInitn')\n\n        # Create the header nodes.\n        GrpHdr_node = ET.Element(\"GrpHdr\")\n        MsgId_node = ET.Element(\"MsgId\")\n        CreDtTm_node = ET.Element(\"CreDtTm\")\n        NbOfTxs_node = ET.Element(\"NbOfTxs\")\n        CtrlSum_node = ET.Element(\"CtrlSum\")\n        InitgPty_node = ET.Element(\"InitgPty\")\n        Nm_node = ET.Element(\"Nm\")\n\n        # Add data to some header nodes.\n        MsgId_node.text = self.msg_id\n        CreDtTm_node.text = datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')\n        Nm_node.text = self._config['name']\n\n        # Append the nodes\n        InitgPty_node.append(Nm_node)\n        GrpHdr_node.append(MsgId_node)\n        GrpHdr_node.append(CreDtTm_node)\n        GrpHdr_node.append(NbOfTxs_node)\n        GrpHdr_node.append(CtrlSum_node)\n        GrpHdr_node.append(InitgPty_node)\n\n        # Append the header to its parent\n        CstmrCdtTrfInitn_node.append(GrpHdr_node)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _create_PmtInf_node(self):\n        ED = dict()  # ED is element dict\n        ED['PmtInfNode'] = ET.Element(\"PmtInf\")\n        ED['PmtInfIdNode'] = ET.Element(\"PmtInfId\")\n        ED['PmtMtdNode'] = ET.Element(\"PmtMtd\")\n        ED['BtchBookgNode'] = ET.Element(\"BtchBookg\")\n        ED['NbOfTxsNode'] = ET.Element(\"NbOfTxs\")\n        ED['CtrlSumNode'] = ET.Element(\"CtrlSum\")\n        ED['PmtTpInfNode'] = ET.Element(\"PmtTpInf\")\n        ED['SvcLvlNode'] = ET.Element(\"SvcLvl\")\n        ED['Cd_SvcLvl_Node'] = ET.Element(\"Cd\")\n        ED['ReqdExctnDtNode'] = ET.Element(\"ReqdExctnDt\")\n\n        ED['DbtrNode'] = ET.Element(\"Dbtr\")\n        ED['Nm_Dbtr_Node'] = ET.Element(\"Nm\")\n        ED['DbtrAcctNode'] = ET.Element(\"DbtrAcct\")\n        ED['Id_DbtrAcct_Node'] = ET.Element(\"Id\")\n        ED['IBAN_DbtrAcct_Node'] = ET.Element(\"IBAN\")\n        ED['DbtrAgtNode'] = ET.Element(\"DbtrAgt\")\n        ED['FinInstnId_DbtrAgt_Node'] = ET.Element(\"FinInstnId\")\n        if 'BIC' in self._config:\n            ED['BIC_DbtrAgt_Node'] = ET.Element(\"BIC\")\n        ED['ChrgBrNode'] = ET.Element(\"ChrgBr\")\n        return ED", "response": "Method to create the blank payment information nodes as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _add_non_batch(self, TX_nodes, PmtInf_nodes):\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['PmtInfIdNode'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['PmtMtdNode'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['BtchBookgNode'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['NbOfTxsNode'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['CtrlSumNode'])\n\n        PmtInf_nodes['SvcLvlNode'].append(PmtInf_nodes['Cd_SvcLvl_Node'])\n        PmtInf_nodes['PmtTpInfNode'].append(PmtInf_nodes['SvcLvlNode'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['PmtTpInfNode'])\n        if 'ReqdExctnDtNode' in PmtInf_nodes:\n            PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['ReqdExctnDtNode'])\n\n        PmtInf_nodes['DbtrNode'].append(PmtInf_nodes['Nm_Dbtr_Node'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['DbtrNode'])\n\n        PmtInf_nodes['Id_DbtrAcct_Node'].append(PmtInf_nodes['IBAN_DbtrAcct_Node'])\n        PmtInf_nodes['DbtrAcctNode'].append(PmtInf_nodes['Id_DbtrAcct_Node'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['DbtrAcctNode'])\n\n        if 'BIC' in self._config:\n            PmtInf_nodes['FinInstnId_DbtrAgt_Node'].append(PmtInf_nodes['BIC_DbtrAgt_Node'])\n        PmtInf_nodes['DbtrAgtNode'].append(PmtInf_nodes['FinInstnId_DbtrAgt_Node'])\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['DbtrAgtNode'])\n\n        PmtInf_nodes['PmtInfNode'].append(PmtInf_nodes['ChrgBrNode'])\n\n        TX_nodes['PmtIdNode'].append(TX_nodes['EndToEnd_PmtId_Node'])\n        TX_nodes['AmtNode'].append(TX_nodes['InstdAmtNode'])\n        TX_nodes['CdtTrfTxInfNode'].append(TX_nodes['PmtIdNode'])\n        TX_nodes['CdtTrfTxInfNode'].append(TX_nodes['AmtNode'])\n\n        if TX_nodes['BIC_CdtrAgt_Node'].text is not None:\n            TX_nodes['FinInstnId_CdtrAgt_Node'].append(\n                TX_nodes['BIC_CdtrAgt_Node'])\n        TX_nodes['CdtrAgtNode'].append(TX_nodes['FinInstnId_CdtrAgt_Node'])\n        TX_nodes['CdtTrfTxInfNode'].append(TX_nodes['CdtrAgtNode'])\n\n        TX_nodes['CdtrNode'].append(TX_nodes['Nm_Cdtr_Node'])\n        TX_nodes['CdtTrfTxInfNode'].append(TX_nodes['CdtrNode'])\n\n        TX_nodes['Id_CdtrAcct_Node'].append(TX_nodes['IBAN_CdtrAcct_Node'])\n        TX_nodes['CdtrAcctNode'].append(TX_nodes['Id_CdtrAcct_Node'])\n        TX_nodes['CdtTrfTxInfNode'].append(TX_nodes['CdtrAcctNode'])\n\n        TX_nodes['RmtInfNode'].append(TX_nodes['UstrdNode'])\n        TX_nodes['CdtTrfTxInfNode'].append(TX_nodes['RmtInfNode'])\n        PmtInf_nodes['PmtInfNode'].append(TX_nodes['CdtTrfTxInfNode'])\n        CstmrCdtTrfInitn_node = self._xml.find('CstmrCdtTrfInitn')\n        CstmrCdtTrfInitn_node.append(PmtInf_nodes['PmtInfNode'])", "response": "Add a non - batch transaction to the main xml."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the matrix of term frequencies given a list of sentences.", "response": "def _compute_matrix(cls, sentences, weighting='frequency', norm=None):\n        \"\"\"\n        Compute the matrix of term frequencies given a list of sentences\n        \"\"\"\n\n        if norm not in ('l1', 'l2', None):\n            raise ValueError('Parameter \"norm\" can only take values \"l1\", \"l2\" or None')\n\n        # Initialise vectorizer to convert text documents into matrix of token counts\n        if weighting.lower() == 'binary':\n            vectorizer = CountVectorizer(min_df=1, ngram_range=(1, 1), binary=True, stop_words=None)\n        elif weighting.lower() == 'frequency':\n            vectorizer = CountVectorizer(min_df=1, ngram_range=(1, 1), binary=False, stop_words=None)\n        elif weighting.lower() == 'tfidf':\n            vectorizer = TfidfVectorizer(min_df=1, ngram_range=(1, 1), stop_words=None)\n        else:\n            raise ValueError('Parameter \"method\" must take one of the values \"binary\", \"frequency\" or \"tfidf\".')\n\n        # Extract word features from sentences using sparse vectorizer\n        frequency_matrix = vectorizer.fit_transform(sentences).astype(float)\n\n        # Normalize the term vectors (i.e. each row adds to 1)\n        if norm in ('l1', 'l2'):\n            frequency_matrix = normalize(frequency_matrix, norm=norm, axis=1)\n        elif norm is not None:\n            raise ValueError('Parameter \"norm\" can only take values \"l1\", \"l2\" or None')\n\n        return frequency_matrix"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef summarize(self, text, length=5, binary_matrix=True):\n\n        text = self._parse_input(text)\n\n        sentences, unprocessed_sentences = self._tokenizer.tokenize_sentences(text)\n\n        length = self._parse_summary_length(length, len(sentences))\n        if length == len(sentences):\n            return unprocessed_sentences\n\n        matrix = self._compute_matrix(sentences, weighting='frequency')\n\n        # Sum occurrences of terms over all sentences to obtain document frequency\n        doc_frequency = matrix.sum(axis=0)\n\n        if binary_matrix:\n            matrix = (matrix != 0).astype(int)\n\n        summary_sentences = []\n        for _ in range(length):\n            # Take the inner product of each sentence vector with the document vector\n            sentence_scores = matrix.dot(doc_frequency.transpose())\n            sentence_scores = np.array(sentence_scores.T)[0]\n\n            # Grab the top sentence and add it to the summary\n            top_sentence = sentence_scores.argsort()[-1]\n            summary_sentences.append(top_sentence)\n\n            # Remove all terms that appear in the top sentence from the document\n            terms_in_top_sentence = (matrix[top_sentence, :] != 0).toarray()\n            doc_frequency[terms_in_top_sentence] = 0\n\n            # Remove the top sentence from consideration by setting all its elements to zero\n            # This does the same as matrix[top_sentence, :] = 0, but is much faster for sparse matrices\n            matrix.data[matrix.indptr[top_sentence]:matrix.indptr[top_sentence+1]] = 0\n            matrix.eliminate_zeros()\n\n        # Return the sentences in the order in which they appear in the document\n        summary_sentences.sort()\n        return [unprocessed_sentences[i] for i in summary_sentences]", "response": "This method computes the summarization of the text and returns a list of sentences for the summary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _prepare_document(self):\n        self._xml = ET.Element(\"Document\")\n        self._xml.set(\"xmlns\",\n                      \"urn:iso:std:iso:20022:tech:xsd:\" + self.schema)\n        self._xml.set(\"xmlns:xsi\",\n                      \"http://www.w3.org/2001/XMLSchema-instance\")\n        ET.register_namespace(\"\",\n                              \"urn:iso:std:iso:20022:tech:xsd:\" + self.schema)\n        ET.register_namespace(\"xsi\",\n                              \"http://www.w3.org/2001/XMLSchema-instance\")\n        n = ET.Element(self.root_el)\n        self._xml.append(n)", "response": "Build the main document node and set xml namespaces."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_rand_string(length=12, allowed_chars='0123456789abcdef'):\n    if not using_sysrandom:\n        # This is ugly, and a hack, but it makes things better than\n        # the alternative of predictability. This re-seeds the PRNG\n        # using a value that is hard for an attacker to predict, every\n        # time a random string is required. This may change the\n        # properties of the chosen random sequence slightly, but this\n        # is better than absolute predictability.\n        random.seed(\n            hashlib.sha256(\n                (\"%s%s\" % (\n                    random.getstate(),\n                    time.time())).encode('utf-8')\n            ).digest())\n    return ''.join([random.choice(allowed_chars) for i in range(length)])", "response": "Returns a securely generated random string. Taken from the Django project\n            Returns a securely generated random string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a semi random message id by using 12 char random hex string and a timestamp.", "response": "def make_msg_id():\n    \"\"\"\n    Create a semi random message id, by using 12 char random hex string and\n    a timestamp.\n    @return: string consisting of timestamp, -, random value\n    \"\"\"\n    random_string = get_rand_string(12)\n    timestamp = time.strftime(\"%Y%m%d%I%M%S\")\n    msg_id = timestamp + \"-\" + random_string\n    return msg_id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a random id combined with the creditor name.", "response": "def make_id(name):\n    \"\"\"\n    Create a random id combined with the creditor name.\n    @return string consisting of name (truncated at 22 chars), -,\n    12 char rand hex string.\n    \"\"\"\n    name = re.sub(r'[^a-zA-Z0-9]', '', name)\n    r = get_rand_string(12)\n    if len(name) > 22:\n        name = name[:22]\n    return name + \"-\" + r"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decimal_str_to_int(decimal_string):\n    int_string = decimal_string.replace('.', '')\n    int_string = int_string.lstrip('0')\n    return int(int_string)", "response": "Helper to decimal currency string into integers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread a list of RDF files and or RDF graphs. May raise an Exception.", "response": "def read_rdf(sources, infmt):\n    \"\"\"Read a list of RDF files and/or RDF graphs. May raise an Exception.\"\"\"\n    rdf = Graph()\n\n    for source in sources:\n        if isinstance(source, Graph):\n            for triple in source:\n                rdf.add(triple)\n            continue\n\n        if source == '-':\n            f = sys.stdin\n        else:\n            f = open(source, 'r')\n\n        if infmt:\n            fmt = infmt\n        else:\n            # determine format based on file extension\n            fmt = 'xml'  # default\n            if source.endswith('n3'):\n                fmt = 'n3'\n            if source.endswith('ttl'):\n                fmt = 'n3'\n            if source.endswith('nt'):\n                fmt = 'nt'\n\n        logging.debug(\"Parsing input file %s (format: %s)\", source, fmt)\n        rdf.parse(f, format=fmt)\n\n    return rdf"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mapping_get(uri, mapping):\n    ln = localname(uri)\n    # 1. try to match URI keys\n    for k, v in mapping.items():\n        if k == uri:\n            return v\n    # 2. try to match local names\n    for k, v in mapping.items():\n        if k == ln:\n            return v\n    # 3. try to match local names with * prefix\n    # try to match longest first, so sort the mapping by key length\n    l = list(mapping.items())\n    l.sort(key=lambda i: len(i[0]), reverse=True)\n    for k, v in l:\n        if k[0] == '*' and ln.endswith(k[1:]):\n            return v\n    raise KeyError(uri)", "response": "Look up the URI in the given mapping and return the result. Raises KeyError if no matching mapping was found."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mapping_match(uri, mapping):\n    try:\n        val = mapping_get(uri, mapping)\n        return True\n    except KeyError:\n        return False", "response": "Determine whether the given URI matches one of the given mappings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef in_general_ns(uri):\n    RDFuri = RDF.uri\n    RDFSuri = RDFS.uri\n\n    for ns in (RDFuri, RDFSuri, OWL, SKOS, DC):\n        if uri.startswith(ns):\n            return True\n    return False", "response": "Return True iff the URI is in a well - known general RDF namespace."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_concept_scheme(rdf):\n    # add explicit type\n    for s, o in rdf.subject_objects(SKOS.inScheme):\n        if not isinstance(o, Literal):\n            rdf.add((o, RDF.type, SKOS.ConceptScheme))\n        else:\n            logging.warning(\n                \"Literal value %s for skos:inScheme detected, ignoring.\", o)\n    css = list(rdf.subjects(RDF.type, SKOS.ConceptScheme))\n    if len(css) > 1:\n        css.sort()\n        cs = css[0]\n        logging.warning(\n            \"Multiple concept schemes found. \"\n            \"Selecting %s as default concept scheme.\", cs)\n    elif len(css) == 1:\n        cs = css[0]\n    else:\n        cs = None\n\n    return cs", "response": "Return a skos. ConceptScheme contained in the model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntrying to automatically detect the URI namespace of the vocabulary.", "response": "def detect_namespace(rdf):\n    \"\"\"Try to automatically detect the URI namespace of the vocabulary.\n\n    Return namespace as URIRef.\n\n    \"\"\"\n\n    # pick a concept\n    conc = rdf.value(None, RDF.type, SKOS.Concept, any=True)\n    if conc is None:\n        logging.critical(\n            \"Namespace auto-detection failed. \"\n            \"Set namespace using the --namespace option.\")\n        sys.exit(1)\n\n    ln = localname(conc)\n    ns = URIRef(conc.replace(ln, ''))\n    if ns.strip() == '':\n        logging.critical(\n            \"Namespace auto-detection failed. \"\n            \"Set namespace using the --namespace option.\")\n        sys.exit(1)\n\n    logging.info(\n        \"Namespace auto-detected to '%s' \"\n        \"- you can override this with the --namespace option.\", ns)\n    return ns"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_concept_scheme(rdf, ns, lname=''):\n\n    ont = None\n    if not ns:\n        # see if there's an owl:Ontology and use that to determine namespace\n        onts = list(rdf.subjects(RDF.type, OWL.Ontology))\n        if len(onts) > 1:\n            onts.sort()\n            ont = onts[0]\n            logging.warning(\n                \"Multiple owl:Ontology instances found. \"\n                \"Creating concept scheme from %s.\", ont)\n        elif len(onts) == 1:\n            ont = onts[0]\n        else:\n            ont = None\n\n        if not ont:\n            logging.info(\n                \"No skos:ConceptScheme or owl:Ontology found. \"\n                \"Using namespace auto-detection for creating concept scheme.\")\n            ns = detect_namespace(rdf)\n        elif ont.endswith('/') or ont.endswith('#') or ont.endswith(':'):\n            ns = ont\n        else:\n            ns = ont + '/'\n\n    NS = Namespace(ns)\n    cs = NS[lname]\n\n    rdf.add((cs, RDF.type, SKOS.ConceptScheme))\n\n    if ont is not None:\n        rdf.remove((ont, RDF.type, OWL.Ontology))\n        # remove owl:imports declarations\n        for o in rdf.objects(ont, OWL.imports):\n            rdf.remove((ont, OWL.imports, o))\n        # remove protege specific properties\n        for p, o in rdf.predicate_objects(ont):\n            prot = URIRef(\n                'http://protege.stanford.edu/plugins/owl/protege#')\n            if p.startswith(prot):\n                rdf.remove((ont, p, o))\n        # move remaining properties (dc:title etc.) of the owl:Ontology into\n        # the skos:ConceptScheme\n        replace_uri(rdf, ont, cs)\n\n    return cs", "response": "Create a skos concept scheme in the model and return it."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef initialize_concept_scheme(rdf, cs, label, language, set_modified):\n\n    # check whether the concept scheme is unlabeled, and label it if possible\n    labels = list(rdf.objects(cs, RDFS.label)) + \\\n        list(rdf.objects(cs, SKOS.prefLabel))\n    if len(labels) == 0:\n        if not label:\n            logging.warning(\n                \"Concept scheme has no label(s). \"\n                \"Use --label option to set the concept scheme label.\")\n        else:\n            logging.info(\n                \"Unlabeled concept scheme detected. Setting label to '%s'\" %\n                label)\n            rdf.add((cs, RDFS.label, Literal(label, language)))\n\n    if set_modified:\n        curdate = datetime.datetime.utcnow().replace(microsecond=0).isoformat() + 'Z'\n        rdf.remove((cs, DCTERMS.modified, None))\n        rdf.add((cs, DCTERMS.modified, Literal(curdate, datatype=XSD.dateTime)))", "response": "Initialize a concept scheme."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transform_sparql_update(rdf, update_query):\n\n    logging.debug(\"performing SPARQL Update transformation\")\n\n    if update_query[0] == '@':  # actual query should be read from file\n        update_query = file(update_query[1:]).read()\n\n    logging.debug(\"update query: %s\", update_query)\n    rdf.update(update_query)", "response": "Perform a SPARQL Update transformation on the RDF data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transform_sparql_construct(rdf, construct_query):\n\n    logging.debug(\"performing SPARQL CONSTRUCT transformation\")\n\n    if construct_query[0] == '@':  # actual query should be read from file\n        construct_query = file(construct_query[1:]).read()\n\n    logging.debug(\"CONSTRUCT query: %s\", construct_query)\n\n    newgraph = Graph()\n    for triple in rdf.query(construct_query):\n        newgraph.add(triple)\n\n    return newgraph", "response": "Perform a SPARQL CONSTRUCT query on the RDF data and return a new graph."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntransform Concepts into new types as defined by the config file.", "response": "def transform_concepts(rdf, typemap):\n    \"\"\"Transform Concepts into new types, as defined by the config file.\"\"\"\n\n    # find out all the types used in the model\n    types = set()\n    for s, o in rdf.subject_objects(RDF.type):\n        if o not in typemap and in_general_ns(o):\n            continue\n        types.add(o)\n\n    for t in types:\n        if mapping_match(t, typemap):\n            newval = mapping_get(t, typemap)\n            newuris = [v[0] for v in newval]\n            logging.debug(\"transform class %s -> %s\", t, str(newuris))\n            if newuris[0] is None:  # delete all instances\n                for inst in rdf.subjects(RDF.type, t):\n                    delete_uri(rdf, inst)\n                delete_uri(rdf, t)\n            else:\n                replace_object(rdf, t, newuris, predicate=RDF.type)\n        else:\n            logging.info(\"Don't know what to do with type %s\", t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transform_literals(rdf, literalmap):\n\n    affected_types = (SKOS.Concept, SKOS.Collection,\n                      SKOSEXT.DeprecatedConcept)\n\n    props = set()\n    for t in affected_types:\n        for conc in rdf.subjects(RDF.type, t):\n            for p, o in rdf.predicate_objects(conc):\n                if isinstance(o, Literal) \\\n                   and (p in literalmap or not in_general_ns(p)):\n                    props.add(p)\n\n    for p in props:\n        if mapping_match(p, literalmap):\n            newval = mapping_get(p, literalmap)\n            newuris = [v[0] for v in newval]\n            logging.debug(\"transform literal %s -> %s\", p, str(newuris))\n            replace_predicate(\n                rdf, p, newuris, subjecttypes=affected_types)\n        else:\n            logging.info(\"Don't know what to do with literal %s\", p)", "response": "Transform literal properties of Concepts as defined by config file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transform_relations(rdf, relationmap):\n\n    affected_types = (SKOS.Concept, SKOS.Collection,\n                      SKOSEXT.DeprecatedConcept)\n\n    props = set()\n    for t in affected_types:\n        for conc in rdf.subjects(RDF.type, t):\n            for p, o in rdf.predicate_objects(conc):\n                if isinstance(o, (URIRef, BNode)) \\\n                   and (p in relationmap or not in_general_ns(p)):\n                    props.add(p)\n\n    for p in props:\n        if mapping_match(p, relationmap):\n            newval = mapping_get(p, relationmap)\n            logging.debug(\"transform relation %s -> %s\", p, str(newval))\n            replace_predicate(\n                rdf, p, newval, subjecttypes=affected_types)\n        else:\n            logging.info(\"Don't know what to do with relation %s\", p)", "response": "Transform YSO - style concept relations into SKOS equivalents."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntransforms YSO - style AggregateConcepts into their ATTRIBS own skos : ConceptScheme.", "response": "def transform_aggregate_concepts(rdf, cs, relationmap, aggregates):\n    \"\"\"Transform YSO-style AggregateConcepts into skos:Concepts within their\n       own skos:ConceptScheme, linked to the regular concepts with\n       SKOS.narrowMatch relationships. If aggregates is False, remove\n       all aggregate concepts instead.\"\"\"\n\n    if not aggregates:\n        logging.debug(\"removing aggregate concepts\")\n\n    aggregate_concepts = []\n\n    relation = relationmap.get(\n        OWL.equivalentClass, [(OWL.equivalentClass, False)])[0][0]\n    for conc, eq in rdf.subject_objects(relation):\n        eql = rdf.value(eq, OWL.unionOf, None)\n        if eql is None:\n            continue\n        if aggregates:\n            aggregate_concepts.append(conc)\n            for item in rdf.items(eql):\n                rdf.add((conc, SKOS.narrowMatch, item))\n        # remove the old equivalentClass-unionOf-rdf:List structure\n        rdf.remove((conc, relation, eq))\n        rdf.remove((eq, RDF.type, OWL.Class))\n        rdf.remove((eq, OWL.unionOf, eql))\n        # remove the rdf:List structure\n        delete_uri(rdf, eql)\n        if not aggregates:\n            delete_uri(rdf, conc)\n\n    if len(aggregate_concepts) > 0:\n        ns = cs.replace(localname(cs), '')\n        acs = create_concept_scheme(rdf, ns, 'aggregateconceptscheme')\n        logging.debug(\"creating aggregate concept scheme %s\", acs)\n        for conc in aggregate_concepts:\n            rdf.add((conc, SKOS.inScheme, acs))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntransforming deprecated concepts so they are in their own concept scheme.", "response": "def transform_deprecated_concepts(rdf, cs):\n    \"\"\"Transform deprecated concepts so they are in their own concept\n    scheme.\"\"\"\n\n    deprecated_concepts = []\n\n    for conc in rdf.subjects(RDF.type, SKOSEXT.DeprecatedConcept):\n        rdf.add((conc, RDF.type, SKOS.Concept))\n        rdf.add((conc, OWL.deprecated, Literal(\"true\", datatype=XSD.boolean)))\n        deprecated_concepts.append(conc)\n\n    if len(deprecated_concepts) > 0:\n        ns = cs.replace(localname(cs), '')\n        dcs = create_concept_scheme(\n            rdf, ns, 'deprecatedconceptscheme')\n        logging.debug(\"creating deprecated concept scheme %s\", dcs)\n        for conc in deprecated_concepts:\n            rdf.add((conc, SKOS.inScheme, dcs))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nenrich the SKOS relations according to SKOS semantics.", "response": "def enrich_relations(rdf, enrich_mappings, use_narrower, use_transitive):\n    \"\"\"Enrich the SKOS relations according to SKOS semantics, including\n    subproperties of broader and symmetric related properties. If use_narrower\n    is True, include inverse narrower relations for all broader relations. If\n    use_narrower is False, instead remove all narrower relations, replacing\n    them with inverse broader relations. If use_transitive is True, calculate\n    transitive hierarchical relationships.\n\n    (broaderTransitive, and also narrowerTransitive if use_narrower is\n    True) and include them in the model.\n\n    \"\"\"\n\n    # 1. first enrich mapping relationships (because they affect regular ones)\n\n    if enrich_mappings:\n        infer.skos_symmetric_mappings(rdf)\n        infer.skos_hierarchical_mappings(rdf, use_narrower)\n\n    # 2. then enrich regular relationships\n\n    # related <-> related\n    infer.skos_related(rdf)\n\n    # broaderGeneric -> broader + inverse narrowerGeneric\n    for s, o in rdf.subject_objects(SKOSEXT.broaderGeneric):\n        rdf.add((s, SKOS.broader, o))\n\n    # broaderPartitive -> broader + inverse narrowerPartitive\n    for s, o in rdf.subject_objects(SKOSEXT.broaderPartitive):\n        rdf.add((s, SKOS.broader, o))\n\n    infer.skos_hierarchical(rdf, use_narrower)\n\n    # transitive closure: broaderTransitive and narrowerTransitive\n    if use_transitive:\n        infer.skos_transitive(rdf, use_narrower)\n    else:\n        # transitive relationships are not wanted, so remove them\n        for s, o in rdf.subject_objects(SKOS.broaderTransitive):\n            rdf.remove((s, SKOS.broaderTransitive, o))\n        for s, o in rdf.subject_objects(SKOS.narrowerTransitive):\n            rdf.remove((s, SKOS.narrowerTransitive, o))\n\n    infer.skos_topConcept(rdf)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_top_concepts(rdf, mark_top_concepts):\n\n    for cs in sorted(rdf.subjects(RDF.type, SKOS.ConceptScheme)):\n        for conc in sorted(rdf.subjects(SKOS.inScheme, cs)):\n            if (conc, RDF.type, SKOS.Concept) not in rdf:\n                continue  # not a Concept, so can't be a top concept\n            # check whether it's a top concept\n            broader = rdf.value(conc, SKOS.broader, None, any=True)\n            if broader is None:  # yes it is a top concept!\n                if (cs, SKOS.hasTopConcept, conc) not in rdf and \\\n                   (conc, SKOS.topConceptOf, cs) not in rdf:\n                    if mark_top_concepts:\n                        logging.info(\n                            \"Marking loose concept %s \"\n                            \"as top concept of scheme %s\", conc, cs)\n                        rdf.add((cs, SKOS.hasTopConcept, conc))\n                        rdf.add((conc, SKOS.topConceptOf, cs))\n                    else:\n                        logging.debug(\n                            \"Not marking loose concept %s as top concept \"\n                            \"of scheme %s, as mark_top_concepts is disabled\",\n                            conc, cs)", "response": "Determine the top concepts of each concept scheme and mark them using\n    hasTopConcept and topConceptOf."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes sure all concepts have an inScheme property using the given concept scheme if necessary.", "response": "def setup_concept_scheme(rdf, defaultcs):\n    \"\"\"Make sure all concepts have an inScheme property, using the given\n    default concept scheme if necessary.\"\"\"\n    for conc in rdf.subjects(RDF.type, SKOS.Concept):\n        # check concept scheme\n        cs = rdf.value(conc, SKOS.inScheme, None, any=True)\n        if cs is None:  # need to set inScheme\n            rdf.add((conc, SKOS.inScheme, defaultcs))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cleanup_classes(rdf):\n    for t in (OWL.Class, RDFS.Class):\n        for cl in rdf.subjects(RDF.type, t):\n            # SKOS classes may be safely removed\n            if cl.startswith(SKOS):\n                logging.debug(\"removing SKOS class definition: %s\", cl)\n                replace_subject(rdf, cl, None)\n                continue\n            # if there are instances of the class, keep the class def\n            if rdf.value(None, RDF.type, cl, any=True) is not None:\n                continue\n            # if the class is used in a domain/range/equivalentClass\n            # definition, keep the class def\n            if rdf.value(None, RDFS.domain, cl, any=True) is not None:\n                continue\n            if rdf.value(None, RDFS.range, cl, any=True) is not None:\n                continue\n            if rdf.value(None, OWL.equivalentClass, cl, any=True) is not None:\n                continue\n\n            # if the class is also a skos:Concept or skos:Collection, only\n            # remove its rdf:type\n            if (cl, RDF.type, SKOS.Concept) in rdf \\\n               or (cl, RDF.type, SKOS.Collection) in rdf:\n                logging.debug(\"removing classiness of %s\", cl)\n                rdf.remove((cl, RDF.type, t))\n            else:  # remove it completely\n                logging.debug(\"removing unused class definition: %s\", cl)\n                replace_subject(rdf, cl, None)", "response": "Remove unnecessary class definitions of SKOS classes or skos. Collection or skos. Concept or skos. Collection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove unnecessary property definitions.", "response": "def cleanup_properties(rdf):\n    \"\"\"Remove unnecessary property definitions.\n\n    Reemoves SKOS and DC property definitions and definitions of unused\n    properties.\"\"\"\n    for t in (RDF.Property, OWL.DatatypeProperty, OWL.ObjectProperty,\n              OWL.SymmetricProperty, OWL.TransitiveProperty,\n              OWL.InverseFunctionalProperty, OWL.FunctionalProperty):\n        for prop in rdf.subjects(RDF.type, t):\n            if prop.startswith(SKOS):\n                logging.debug(\n                    \"removing SKOS property definition: %s\", prop)\n                replace_subject(rdf, prop, None)\n                continue\n            if prop.startswith(DC):\n                logging.debug(\"removing DC property definition: %s\", prop)\n                replace_subject(rdf, prop, None)\n                continue\n\n            # if there are triples using the property, keep the property def\n            if len(list(rdf.subject_objects(prop))) > 0:\n                continue\n\n            logging.debug(\"removing unused property definition: %s\", prop)\n            replace_subject(rdf, prop, None)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind the set of reachable resources starting from the given resource excluding the seen set of resources.", "response": "def find_reachable(rdf, res):\n    \"\"\"Return the set of reachable resources starting from the given resource,\n    excluding the seen set of resources.\n\n    Note that the seen set is modified\n    in-place to reflect the ongoing traversal.\n\n    \"\"\"\n\n    starttime = time.time()\n\n    # This is almost a non-recursive breadth-first search algorithm, but a set\n    # is used as the \"open\" set instead of a FIFO, and an arbitrary element of\n    # the set is searched. This is slightly faster than DFS (using a stack)\n    # and much faster than BFS (using a FIFO).\n    seen = set()\t\t\t# used as the \"closed\" set\n    to_search = set([res])  # used as the \"open\" set\n\n    while len(to_search) > 0:\n        res = to_search.pop()\n        if res in seen:\n            continue\n        seen.add(res)\n        # res as subject\n        for p, o in rdf.predicate_objects(res):\n            if isinstance(p, URIRef) and p not in seen:\n                to_search.add(p)\n            if isinstance(o, URIRef) and o not in seen:\n                to_search.add(o)\n        # res as predicate\n        for s, o in rdf.subject_objects(res):\n            if isinstance(s, URIRef) and s not in seen:\n                to_search.add(s)\n            if isinstance(o, URIRef) and o not in seen:\n                to_search.add(o)\n        # res as object\n        for s, p in rdf.subject_predicates(res):\n            if isinstance(s, URIRef) and s not in seen:\n                to_search.add(s)\n            if isinstance(p, URIRef) and p not in seen:\n                to_search.add(p)\n\n    endtime = time.time()\n    logging.debug(\"find_reachable took %f seconds\", (endtime - starttime))\n\n    return seen"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving triples which cannot be reached from the concepts by graph traversal.", "response": "def cleanup_unreachable(rdf):\n    \"\"\"Remove triples which cannot be reached from the concepts by graph\n    traversal.\"\"\"\n\n    all_subjects = set(rdf.subjects())\n\n    logging.debug(\"total subject resources: %d\", len(all_subjects))\n\n    reachable = find_reachable(rdf, SKOS.Concept)\n    nonreachable = all_subjects - reachable\n\n    logging.debug(\"deleting %s non-reachable resources\", len(nonreachable))\n\n    for subj in nonreachable:\n        delete_uri(rdf, subj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if a given graph is a hierarchical skos hierarchy.", "response": "def check_hierarchy(rdf, break_cycles, keep_related, mark_top_concepts,\n                    eliminate_redundancy):\n    \"\"\"Check for, and optionally fix, problems in the skos:broader hierarchy\n    using a recursive depth first search algorithm.\n\n    :param Graph rdf: An rdflib.graph.Graph object.\n    :param bool fix_cycles: Break cycles.\n    :param bool fix_disjoint_relations: Remoe skos:related overlapping with\n        skos:broaderTransitive.\n    :param bool fix_redundancy: Remove skos:broader between two concepts otherwise\n        connected by skos:broaderTransitive.\n    \"\"\"\n    starttime = time.time()\n\n    if check.hierarchy_cycles(rdf, break_cycles):\n        logging.info(\n            \"Some concepts not reached in initial cycle detection. \"\n            \"Re-checking for loose concepts.\")\n        setup_top_concepts(rdf, mark_top_concepts)\n\n    check.disjoint_relations(rdf, not keep_related)\n    check.hierarchical_redundancy(rdf, eliminate_redundancy)\n\n    endtime = time.time()\n    logging.debug(\"check_hierarchy took %f seconds\", (endtime - starttime))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef skosify(*sources, **config):\n\n    cfg = Config()\n    for key in config:\n        if hasattr(cfg, key):\n            setattr(cfg, key, config[key])\n    config = cfg\n\n    namespaces = config.namespaces\n    typemap = config.types\n    literalmap = config.literals\n    relationmap = config.relations\n\n    logging.debug(\"Skosify starting. $Revision$\")\n    starttime = time.time()\n\n    logging.debug(\"Phase 1: Parsing input files\")\n    try:\n        voc = read_rdf(sources, config.from_format)\n    except:\n        logging.critical(\"Parsing failed. Exception: %s\",\n                         str(sys.exc_info()[1]))\n        sys.exit(1)\n\n    inputtime = time.time()\n\n    logging.debug(\"Phase 2: Performing inferences\")\n    if config.update_query is not None:\n        transform_sparql_update(voc, config.update_query)\n    if config.construct_query is not None:\n        voc = transform_sparql_construct(voc, config.construct_query)\n    if config.infer:\n        logging.debug(\"doing RDFS subclass and properties inference\")\n        infer.rdfs_classes(voc)\n        infer.rdfs_properties(voc)\n\n    logging.debug(\"Phase 3: Setting up namespaces\")\n    for prefix, uri in namespaces.items():\n        voc.namespace_manager.bind(prefix, uri)\n\n    logging.debug(\"Phase 4: Transforming concepts, literals and relations\")\n    # transform concepts, literals and concept relations\n    transform_concepts(voc, typemap)\n    transform_literals(voc, literalmap)\n    transform_relations(voc, relationmap)\n\n    # special transforms for labels: whitespace, prefLabel vs altLabel\n    transform_labels(voc, config.default_language)\n\n    # special transforms for collections + aggregate and deprecated concepts\n    transform_collections(voc)\n\n    # find/create concept scheme\n    cs = get_concept_scheme(voc)\n    if not cs:\n        cs = create_concept_scheme(voc, config.namespace)\n    initialize_concept_scheme(voc, cs, label=config.label,\n                              language=config.default_language,\n                              set_modified=config.set_modified)\n\n    transform_aggregate_concepts(\n        voc, cs, relationmap, config.aggregates)\n    transform_deprecated_concepts(voc, cs)\n\n    logging.debug(\"Phase 5: Performing SKOS enrichments\")\n    # enrichments: broader <-> narrower, related <-> related\n    enrich_relations(voc, config.enrich_mappings,\n                     config.narrower, config.transitive)\n\n    logging.debug(\"Phase 6: Cleaning up\")\n    # clean up unused/unnecessary class/property definitions and unreachable\n    # triples\n    if config.cleanup_properties:\n        cleanup_properties(voc)\n    if config.cleanup_classes:\n        cleanup_classes(voc)\n    if config.cleanup_unreachable:\n        cleanup_unreachable(voc)\n\n    logging.debug(\"Phase 7: Setting up concept schemes and top concepts\")\n    # setup inScheme and hasTopConcept\n    setup_concept_scheme(voc, cs)\n    setup_top_concepts(voc, config.mark_top_concepts)\n\n    logging.debug(\"Phase 8: Checking concept hierarchy\")\n    # check hierarchy for cycles\n    check_hierarchy(voc, config.break_cycles,\n                    config.keep_related, config.mark_top_concepts,\n                    config.eliminate_redundancy)\n\n    logging.debug(\"Phase 9: Checking labels\")\n    # check for duplicate labels\n    check_labels(voc, config.preflabel_policy)\n\n    processtime = time.time()\n\n    logging.debug(\"reading input file took  %d seconds\",\n                  (inputtime - starttime))\n    logging.debug(\"processing took          %d seconds\",\n                  (processtime - inputtime))\n\n    logging.debug(\"Phase 10: Writing output\")\n\n    return voc", "response": "Convert extend and check SKOS vocabulary."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexpands a CURIE - like string with a period instead of colon as separator into a URIRef.", "response": "def expand_curielike(namespaces, curie):\n    \"\"\"Expand a CURIE (or a CURIE-like string with a period instead of colon\n    as separator) into URIRef. If the provided curie is not a CURIE, return it\n    unchanged.\"\"\"\n\n    if curie == '':\n        return None\n    if sys.version < '3' and not isinstance(curie, type(u'')):\n        # Python 2 ConfigParser gives raw byte strings\n        curie = curie.decode('UTF-8')  # ...make those into Unicode objects\n\n    if curie.startswith('[') and curie.endswith(']'):\n        # decode SafeCURIE\n        curie = curie[1:-1]\n\n    if ':' in curie:\n        ns, localpart = curie.split(':', 1)\n    elif '.' in curie:\n        ns, localpart = curie.split('.', 1)\n    else:\n        return curie\n\n    if ns in namespaces:\n        return URIRef(namespaces[ns].term(localpart))\n    else:\n        logging.warning(\"Unknown namespace prefix %s\", ns)\n        return URIRef(curie)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef expand_mapping_target(namespaces, val):\n\n    vals = [v.strip() for v in val.split(',')]\n    ret = []\n    for v in vals:\n        inverse = False\n        if v.startswith('^'):\n            inverse = True\n            v = v[1:]\n        ret.append((expand_curielike(namespaces, v), inverse))\n    return ret", "response": "Expand a mapping target expressed as a comma - separated list of\n    CURIE - like strings potentially prefixed with ^ to express inverse\n    properties into a list of tuples where uri is a URIRef\n    where inverse is a boolean."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread configuration from file.", "response": "def read_file(self, cfgparser, file):\n        \"\"\"Read configuration from file.\"\"\"\n\n        if hasattr(file, 'readline'):\n            # we have a file object\n            if sys.version_info >= (3, 2):\n                cfgparser.read_file(file)  # Added in Python 3.2\n            else:\n                cfgparser.readfp(file)  # Deprecated since Python 3.2\n\n        else:\n            # we have a file name\n            cfgparser.read(file)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef replace_subject(rdf, fromuri, touri):\n    if fromuri == touri:\n        return\n    for p, o in rdf.predicate_objects(fromuri):\n        rdf.remove((fromuri, p, o))\n        if touri is not None:\n            if not isinstance(touri, (list, tuple)):\n                touri = [touri]\n            for uri in touri:\n                rdf.add((uri, p, o))", "response": "Replace occurrences of fromuri as subject with touri in given model."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreplacing occurrences of fromuri with touri in given model.", "response": "def replace_predicate(rdf, fromuri, touri, subjecttypes=None, inverse=False):\n    \"\"\"Replace occurrences of fromuri as predicate with touri in given model.\n\n    If touri=None, will delete all occurrences of fromuri instead.\n    If touri is a list or tuple of URIRef, all values will be inserted. If\n    touri is a list of (URIRef, boolean) tuples, the boolean value will be\n    used to determine whether an inverse property is created (if True) or\n    not (if False). If a subjecttypes sequence is given, modify only those\n    triples where the subject is one of the provided types.\n\n    \"\"\"\n\n    if fromuri == touri:\n        return\n    for s, o in rdf.subject_objects(fromuri):\n        if subjecttypes is not None:\n            typeok = False\n            for t in subjecttypes:\n                if (s, RDF.type, t) in rdf:\n                    typeok = True\n            if not typeok:\n                continue\n        rdf.remove((s, fromuri, o))\n        if touri is not None:\n            if not isinstance(touri, (list, tuple)):\n                touri = [touri]\n            for val in touri:\n                if not isinstance(val, tuple):\n                    val = (val, False)\n                uri, inverse = val\n                if uri is None:\n                    continue\n                if inverse:\n                    rdf.add((o, uri, s))\n                else:\n                    rdf.add((s, uri, o))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreplaces all occurrences of fromuri as object with touri in the given rdf model.", "response": "def replace_object(rdf, fromuri, touri, predicate=None):\n    \"\"\"Replace all occurrences of fromuri as object with touri in the given\n    model.\n\n    If touri=None, will delete all occurrences of fromuri instead.\n    If touri is a list or tuple of URIRef, all values will be inserted.\n    If predicate is given, modify only triples with the given predicate.\n\n    \"\"\"\n    if fromuri == touri:\n        return\n    for s, p in rdf.subject_predicates(fromuri):\n        if predicate is not None and p != predicate:\n            continue\n        rdf.remove((s, p, fromuri))\n        if touri is not None:\n            if not isinstance(touri, (list, tuple)):\n                touri = [touri]\n            for uri in touri:\n                rdf.add((s, p, uri))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreplace all occurrences of fromuri with touri in the given model.", "response": "def replace_uri(rdf, fromuri, touri):\n    \"\"\"Replace all occurrences of fromuri with touri in the given model.\n\n    If touri is a list or tuple of URIRef, all values will be inserted.\n    If touri=None, will delete all occurrences of fromuri instead.\n\n    \"\"\"\n    replace_subject(rdf, fromuri, touri)\n    replace_predicate(rdf, fromuri, touri)\n    replace_object(rdf, fromuri, touri)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hierarchy_cycles(rdf, fix=False):\n    top_concepts = sorted(rdf.subject_objects(SKOS.hasTopConcept))\n    status = {}\n    for cs, root in top_concepts:\n        _hierarchy_cycles_visit(\n            rdf, root, None, fix, status=status)\n\n    # double check that all concepts were actually visited in the search,\n    # and visit remaining ones if necessary\n    recheck_top_concepts = False\n    for conc in sorted(rdf.subjects(RDF.type, SKOS.Concept)):\n        if conc not in status:\n            recheck_top_concepts = True\n            _hierarchy_cycles_visit(\n                rdf, conc, None, fix, status=status)\n    return recheck_top_concepts", "response": "Check if the graph contains skos : broader cycles and optionally break these."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if the graph contains disjoint skos related relations.", "response": "def disjoint_relations(rdf, fix=False):\n    \"\"\"Check if the graph contains concepts connected by both of the semantically\n    disjoint semantic skos:related and skos:broaderTransitive (S27),\n    and optionally remove the involved skos:related relations.\n\n    :param Graph rdf: An rdflib.graph.Graph object.\n    :param bool fix: Fix the problem by removing skos:related relations that\n        overlap with skos:broaderTransitive.\n    \"\"\"\n    for conc1, conc2 in sorted(rdf.subject_objects(SKOS.related)):\n        if conc2 in sorted(rdf.transitive_objects(conc1, SKOS.broader)):\n            if fix:\n                logging.warning(\n                    \"Concepts %s and %s connected by both \"\n                    \"skos:broaderTransitive and skos:related, \"\n                    \"removing skos:related\",\n                    conc1, conc2)\n                rdf.remove((conc1, SKOS.related, conc2))\n                rdf.remove((conc2, SKOS.related, conc1))\n            else:\n                logging.warning(\n                    \"Concepts %s and %s connected by both \"\n                    \"skos:broaderTransitive and skos:related, \"\n                    \"but keeping it because keep_related is enabled\",\n                    conc1, conc2)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking for and optionally remove extraneous skos : broader relations between SKOS concepts.", "response": "def hierarchical_redundancy(rdf, fix=False):\n    \"\"\"Check for and optionally remove extraneous skos:broader relations.\n\n    :param Graph rdf: An rdflib.graph.Graph object.\n    :param bool fix: Fix the problem by removing skos:broader relations between\n        concepts that are otherwise connected by skos:broaderTransitive.\n    \"\"\"\n    for conc, parent1 in rdf.subject_objects(SKOS.broader):\n        for parent2 in rdf.objects(conc, SKOS.broader):\n            if parent1 == parent2:\n                continue  # must be different\n            if parent2 in rdf.transitive_objects(parent1, SKOS.broader):\n                if fix:\n                    logging.warning(\n                        \"Eliminating redundant hierarchical relationship: \"\n                        \"%s skos:broader %s\",\n                        conc, parent2)\n                    rdf.remove((conc, SKOS.broader, parent2))\n                    rdf.remove((conc, SKOS.broaderTransitive, parent2))\n                    rdf.remove((parent2, SKOS.narrower, conc))\n                    rdf.remove((parent2, SKOS.narrowerTransitive, conc))\n                else:\n                    logging.warning(\n                        \"Redundant hierarchical relationship \"\n                        \"%s skos:broader %s found, but not eliminated \"\n                        \"because eliminate_redundancy is not set\",\n                        conc, parent2)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_prop_overlap(rdf, prop1, prop2):\n    for s, o in sorted(rdf.subject_objects(prop1)):\n        if (s, prop2, o) in rdf:\n            yield (s, o)", "response": "Generate ( subject object ) pairs connected by two properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes sure that skos. related is stated in both directions ( S23 ).", "response": "def skos_related(rdf):\n    \"\"\"Make sure that skos:related is stated in both directions (S23).\"\"\"\n    for s, o in rdf.subject_objects(SKOS.related):\n        rdf.add((o, SKOS.related, s))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninferring skos. topConceptOf and skos. inScheme.", "response": "def skos_topConcept(rdf):\n    \"\"\"Infer skos:topConceptOf/skos:hasTopConcept (S8) and skos:inScheme (S7).\"\"\"\n    for s, o in rdf.subject_objects(SKOS.hasTopConcept):\n        rdf.add((o, SKOS.topConceptOf, s))\n    for s, o in rdf.subject_objects(SKOS.topConceptOf):\n        rdf.add((o, SKOS.hasTopConcept, s))\n    for s, o in rdf.subject_objects(SKOS.topConceptOf):\n        rdf.add((s, SKOS.inScheme, o))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef skos_hierarchical(rdf, narrower=True):\n    if narrower:\n        for s, o in rdf.subject_objects(SKOS.broader):\n            rdf.add((o, SKOS.narrower, s))\n    for s, o in rdf.subject_objects(SKOS.narrower):\n        rdf.add((o, SKOS.broader, s))\n        if not narrower:\n            rdf.remove((s, SKOS.narrower, o))", "response": "Infer skos. broader and skos. narrower."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nperforming transitive closure inference ( S22 S24 and S24.", "response": "def skos_transitive(rdf, narrower=True):\n    \"\"\"Perform transitive closure inference (S22, S24).\"\"\"\n    for conc in rdf.subjects(RDF.type, SKOS.Concept):\n        for bt in rdf.transitive_objects(conc, SKOS.broader):\n            if bt == conc:\n                continue\n            rdf.add((conc, SKOS.broaderTransitive, bt))\n            if narrower:\n                rdf.add((bt, SKOS.narrowerTransitive, conc))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef skos_symmetric_mappings(rdf, related=True):\n    for s, o in rdf.subject_objects(SKOS.relatedMatch):\n        rdf.add((o, SKOS.relatedMatch, s))\n        if related:\n            rdf.add((s, SKOS.related, o))\n            rdf.add((o, SKOS.related, s))\n\n    for s, o in rdf.subject_objects(SKOS.closeMatch):\n        rdf.add((o, SKOS.closeMatch, s))\n\n    for s, o in rdf.subject_objects(SKOS.exactMatch):\n        rdf.add((o, SKOS.exactMatch, s))", "response": "Ensure that the symmetric mappings are made for SKOS."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninfers skos. broadMatch and skos. narrower and skos. narrower.", "response": "def skos_hierarchical_mappings(rdf, narrower=True):\n    \"\"\"Infer skos:broadMatch/skos:narrowMatch (S43) and add the super-properties\n    skos:broader/skos:narrower (S41).\n\n    :param bool narrower: If set to False, skos:narrowMatch will not be added,\n        but rather removed.\n    \"\"\"\n    for s, o in rdf.subject_objects(SKOS.broadMatch):\n        rdf.add((s, SKOS.broader, o))\n        if narrower:\n            rdf.add((o, SKOS.narrowMatch, s))\n            rdf.add((o, SKOS.narrower, s))\n\n    for s, o in rdf.subject_objects(SKOS.narrowMatch):\n        rdf.add((o, SKOS.broadMatch, s))\n        rdf.add((o, SKOS.broader, s))\n        if narrower:\n            rdf.add((s, SKOS.narrower, o))\n        else:\n            rdf.remove((s, SKOS.narrowMatch, o))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rdfs_classes(rdf):\n\n    # find out the subclass mappings\n    upperclasses = {}  # key: class val: set([superclass1, superclass2..])\n    for s, o in rdf.subject_objects(RDFS.subClassOf):\n        upperclasses.setdefault(s, set())\n        for uc in rdf.transitive_objects(s, RDFS.subClassOf):\n            if uc != s:\n                upperclasses[s].add(uc)\n\n    # set the superclass type information for subclass instances\n    for s, ucs in upperclasses.items():\n        logging.debug(\"setting superclass types: %s -> %s\", s, str(ucs))\n        for res in rdf.subjects(RDF.type, s):\n            for uc in ucs:\n                rdf.add((res, RDF.type, uc))", "response": "Perform RDFS subclass inference."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rdfs_properties(rdf):\n\n    # find out the subproperty mappings\n    superprops = {}  # key: property val: set([superprop1, superprop2..])\n    for s, o in rdf.subject_objects(RDFS.subPropertyOf):\n        superprops.setdefault(s, set())\n        for sp in rdf.transitive_objects(s, RDFS.subPropertyOf):\n            if sp != s:\n                superprops[s].add(sp)\n\n    # add the superproperty relationships\n    for p, sps in superprops.items():\n        logging.debug(\"setting superproperties: %s -> %s\", p, str(sps))\n        for s, o in rdf.subject_objects(p):\n            for sp in sps:\n                rdf.add((s, sp, o))", "response": "Perform RDFS subproperty inference."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef overextends(parser, token):\n    bits = token.split_contents()\n    if len(bits) != 2:\n        raise TemplateSyntaxError(\"'%s' takes one argument\" % bits[0])\n    parent_name = parser.compile_filter(bits[1])\n    nodelist = parser.parse()\n    if nodelist.get_nodes_by_type(ExtendsNode):\n        raise TemplateSyntaxError(\"'%s' cannot appear more than once \"\n                                  \"in the same template\" % bits[0])\n    return OverExtendsNode(nodelist, parent_name, None)", "response": "A template tag that allows circular extends inheritance to occur."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_template(self, name, context, peeking=False):\n\n        # These imports want settings, which aren't available when this\n        # module is imported to ``add_to_builtins``, so do them here.\n        from django.conf import settings\n\n        # Find the app_template_dirs (moved in Django 1.8)\n        import django.template.loaders.app_directories as app_directories\n        try:\n            # Django >= 1.8\n            get_app_template_dirs = app_directories.get_app_template_dirs\n            app_template_dirs = get_app_template_dirs('templates')\n        except AttributeError:\n            # Django <= 1.7\n            app_template_dirs = app_directories.app_template_dirs\n        \n        # Find the find_template_loader function, and appropriate template\n        # settings (changed in Django 1.8)\n        try:\n            # Django >= 1.8\n            find_template_loader = context.template.engine.find_template_loader\n            template_dirs = context.template.engine.dirs\n            template_loaders = context.template.engine.loaders\n        except AttributeError:\n            # Django <= 1.7\n            from django.template.loader import find_template_loader\n            template_dirs = list(settings.TEMPLATE_DIRS)\n            template_loaders = settings.TEMPLATE_LOADERS\n        \n        # Store a dictionary in the template context mapping template\n        # names to the lists of template directories available to\n        # search for that template. Each time a template is loaded, its\n        # origin directory is removed from its directories list.\n        context_name = \"OVEREXTENDS_DIRS\"\n        if context_name not in context:\n            context[context_name] = {}\n        if name not in context[context_name]:\n            all_dirs = template_dirs + list(app_template_dirs)\n            # os.path.abspath is needed under uWSGI, and also ensures we\n            # have consistent path separators across different OSes.\n            context[context_name][name] = list(map(os.path.abspath, all_dirs))\n\n        # Build a list of template loaders to use. For loaders that wrap\n        # other loaders like the ``cached`` template loader, unwind its\n        # internal loaders and add those instead.\n        loaders = []\n        for loader_name in template_loaders:\n            loader = find_template_loader(loader_name)\n            loaders.extend(getattr(loader, \"loaders\", [loader]))\n\n        # Go through the loaders and try to find the template. When\n        # found, removed its absolute path from the context dict so\n        # that it won't be used again when the same relative name/path\n        # is requested.\n        for loader in loaders:\n            dirs = context[context_name][name]\n            if not dirs:\n                break\n            try:\n                source, path = loader.load_template_source(name, dirs)\n            except TemplateDoesNotExist:\n                pass\n            else:\n                # Only remove the absolute path for the initial call in\n                # get_parent, and not when we're peeking during the\n                # second call.\n                if not peeking:\n                    remove_path = os.path.abspath(path[:-len(name) - 1])\n                    context[context_name][name].remove(remove_path)\n                return Template(source)\n        raise TemplateDoesNotExist(name)", "response": "Find a template in the current template context."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_parent(self, context):\n        parent = self.parent_name.resolve(context)\n        # If parent is a template object, just return it.\n        if hasattr(parent, \"render\"):\n            return parent\n        template = self.find_template(parent, context)\n        for node in template.nodelist:\n            if (isinstance(node, ExtendsNode) and\n                    node.parent_name.resolve(context) == parent):\n                return self.find_template(parent, context, peeking=True)\n        return template", "response": "Load the parent template using our own find_template method."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates and return an OptionParser with the given defaults.", "response": "def get_option_parser(defaults):\n    \"\"\"Create and return an OptionParser with the given defaults.\"\"\"\n    # based on recipe from:\n    # http://stackoverflow.com/questions/1880404/using-a-file-to-store-optparse-arguments\n\n    # process command line parameters\n    # e.g. skosify yso.owl -o yso-skos.rdf\n    usage = \"Usage: %prog [options] voc1 [voc2 ...]\"\n    parser = optparse.OptionParser(usage=usage)\n    parser.set_defaults(**defaults)\n    parser.add_option('-c', '--config', type='string',\n                      help='Read default options '\n                           'and transformation definitions '\n                           'from the given configuration file.')\n    parser.add_option('-o', '--output', type='string',\n                      help='Output file name. Default is \"-\" (stdout).')\n    parser.add_option('-D', '--debug', action=\"store_true\",\n                      help='Show debug output.')\n    parser.add_option('-d', '--no-debug', dest=\"debug\",\n                      action=\"store_false\", help='Hide debug output.')\n    parser.add_option('-O', '--log', type='string',\n                      help='Log file name. Default is to use standard error.')\n\n    group = optparse.OptionGroup(parser, \"Input and Output Options\")\n    group.add_option('-f', '--from-format', type='string',\n                     help='Input format. '\n                           'Default is to detect format '\n                           'based on file extension. '\n                           'Possible values: xml, n3, turtle, nt...')\n    group.add_option('-F', '--to-format', type='string',\n                     help='Output format. '\n                           'Default is to detect format '\n                           'based on file extension. '\n                           'Possible values: xml, n3, turtle, nt...')\n    group.add_option('--update-query', type='string',\n                     help='SPARQL update query. '\n                     'This query is executed against the input '\n                     'data before processing it. '\n                     'The value can be either the actual query, '\n                     'or \"@filename\".')\n    group.add_option('--construct-query', type='string',\n                     help='SPARQL CONSTRUCT query. '\n                     'This query is executed against the input '\n                     'data and the result graph is used as the '\n                     'actual input. '\n                     'The value can be either the actual query, '\n                     'or \"@filename\".')\n    group.add_option('-I', '--infer', action=\"store_true\",\n                     help='Perform RDFS subclass/subproperty inference '\n                          'before transforming input.')\n    group.add_option('-i', '--no-infer', dest=\"infer\", action=\"store_false\",\n                     help=\"Don't perform RDFS subclass/subproperty inference \"\n                          \"before transforming input.\")\n    parser.add_option_group(group)\n\n    group = optparse.OptionGroup(\n        parser, \"Concept Scheme and Labelling Options\")\n    group.add_option('-s', '--namespace', type='string',\n                     help='Namespace of vocabulary '\n                          '(usually optional; used to create a ConceptScheme)')\n    group.add_option('-L', '--label', type='string',\n                     help='Label/title for the vocabulary '\n                          '(usually optional; used to label a ConceptScheme)')\n    group.add_option('-l', '--default-language', type='string',\n                     help='Language tag to set for labels '\n                          'with no defined language.')\n    group.add_option('-p', '--preflabel-policy', type='string',\n                     help='Policy for handling multiple prefLabels '\n                          'with the same language tag. '\n                          'Possible values: shortest, longest, all.')\n    group.add_option('--set-modified', dest=\"set_modified\",\n                     action=\"store_true\",\n                     help='Set modification date on the ConceptScheme')\n    group.add_option('--no-set-modified', dest=\"set_modified\",\n                     action=\"store_false\",\n                     help=\"Don't set modification date on the ConceptScheme\")\n    parser.add_option_group(group)\n\n    group = optparse.OptionGroup(parser, \"Vocabulary Structure Options\")\n    group.add_option('-E', '--mark-top-concepts', action=\"store_true\",\n                     help='Mark top-level concepts in the hierarchy '\n                          'as top concepts (entry points).')\n    group.add_option('-e', '--no-mark-top-concepts',\n                     dest=\"mark_top_concepts\", action=\"store_false\",\n                     help=\"Don't mark top-level concepts in the hierarchy \"\n                          \"as top concepts.\")\n    group.add_option('-N', '--narrower', action=\"store_true\",\n                     help='Include narrower/narrowerGeneric/narrowerPartitive '\n                          'relationships in the output vocabulary.')\n    group.add_option('-n', '--no-narrower',\n                     dest=\"narrower\", action=\"store_false\",\n                     help=\"Don't include \"\n                          \"narrower/narrowerGeneric/narrowerPartitive \"\n                          \"relationships in the output vocabulary.\")\n    group.add_option('-T', '--transitive', action=\"store_true\",\n                     help='Include transitive hierarchy relationships '\n                          'in the output vocabulary.')\n    group.add_option('-t', '--no-transitive',\n                     dest=\"transitive\", action=\"store_false\",\n                     help=\"Don't include transitive hierarchy relationships \"\n                          \"in the output vocabulary.\")\n    group.add_option('-M', '--enrich-mappings', action=\"store_true\",\n                     help='Perform SKOS enrichments on mapping relationships.')\n    group.add_option('-m', '--no-enrich-mappings', dest=\"enrich_mappings\",\n                     action=\"store_false\",\n                     help=\"Don't perform SKOS enrichments \"\n                          \"on mapping relationships.\")\n    group.add_option('-A', '--aggregates', action=\"store_true\",\n                     help='Keep AggregateConcepts completely '\n                          'in the output vocabulary.')\n    group.add_option('-a', '--no-aggregates',\n                     dest=\"aggregates\", action=\"store_false\",\n                     help='Remove AggregateConcepts completely '\n                          'from the output vocabulary.')\n    group.add_option('-R', '--keep-related', action=\"store_true\",\n                     help=\"Keep skos:related relationships \"\n                          \"within the same hierarchy.\")\n    group.add_option('-r', '--no-keep-related',\n                     dest=\"keep_related\", action=\"store_false\",\n                     help=\"Remove skos:related relationships \"\n                          \"within the same hierarchy.\")\n    group.add_option('-B', '--break-cycles', action=\"store_true\",\n                     help=\"Break any cycles in the skos:broader hierarchy.\")\n    group.add_option('-b', '--no-break-cycles', dest=\"break_cycles\",\n                     action=\"store_false\",\n                     help=\"Don't break cycles in the skos:broader hierarchy.\")\n    group.add_option('--eliminate-redundancy', action=\"store_true\",\n                     help=\"Eliminate hierarchical redundancy in the \"\n                          \"skos:broader hierarchy.\")\n    group.add_option('--no-eliminate-redundancy', dest=\"eliminate_redundancy\",\n                     action=\"store_false\",\n                     help=\"Don't eliminate hierarchical redundancy in the \"\n                          \"skos:broader hierarchy.\")\n    parser.add_option_group(group)\n\n    group = optparse.OptionGroup(parser, \"Cleanup Options\")\n    group.add_option('--cleanup-classes', action=\"store_true\",\n                     help=\"Remove definitions of classes with no instances.\")\n    group.add_option('--no-cleanup-classes', dest='cleanup_classes',\n                     action=\"store_false\",\n                     help=\"Don't remove definitions \"\n                          \"of classes with no instances.\")\n    group.add_option('--cleanup-properties', action=\"store_true\",\n                     help=\"Remove definitions of properties \"\n                          \"which have not been used.\")\n    group.add_option('--no-cleanup-properties', action=\"store_false\",\n                     dest='cleanup_properties',\n                     help=\"Don't remove definitions of properties \"\n                          \"which have not been used.\")\n    group.add_option('--cleanup-unreachable', action=\"store_true\",\n                     help=\"Remove triples which can not be reached \"\n                          \"by a traversal from the main vocabulary graph.\")\n    group.add_option('--no-cleanup-unreachable', action=\"store_false\",\n                     dest='cleanup_unreachable',\n                     help=\"Don't remove triples which can not be reached \"\n                          \"by a traversal from the main vocabulary graph.\")\n    parser.add_option_group(group)\n\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading command line parameters and make a transform based on them.", "response": "def main():\n    \"\"\"Read command line parameters and make a transform based on them.\"\"\"\n\n    config = Config()\n\n    # additional options for command line client only\n    defaults = vars(config)\n    defaults['to_format'] = None\n    defaults['output'] = '-'\n    defaults['log'] = None\n    defaults['debug'] = False\n\n    options, remainingArgs = get_option_parser(defaults).parse_args()\n    for key in vars(options):\n        if hasattr(config, key):\n            setattr(config, key, getattr(options, key))\n\n    # configure logging, messages to stderr by default\n    logformat = '%(levelname)s: %(message)s'\n    loglevel = logging.INFO\n    if options.debug:\n        loglevel = logging.DEBUG\n    if options.log:\n        logging.basicConfig(filename=options.log,\n                            format=logformat, level=loglevel)\n    else:\n        logging.basicConfig(format=logformat, level=loglevel)\n\n    output = options.output\n    to_format = options.to_format\n\n    # read config file as defaults and override from command line arguments\n    if options.config is not None:\n        config.read_and_parse_config_file(options.config)\n        options, remainingArgs = get_option_parser(vars(config)).parse_args()\n        for key in vars(options):\n            if hasattr(config, key):\n                setattr(config, key, getattr(options, key))\n\n    if remainingArgs:\n        inputfiles = remainingArgs\n    else:\n        inputfiles = ['-']\n\n    voc = skosify(*inputfiles, **vars(config))\n    write_rdf(voc, output, to_format)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_handler(self, handler):\n        if self._handler:\n            raise Exception('Handler was already set')\n        if handler:\n            self._handler = async_task(handler, loop=self._loop)", "response": "Connect with a coroutine which will be scheduled when connection is made."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting a new request by sending given headers on a new stream.", "response": "def start_request(self, headers, *, end_stream=False):\n        \"\"\"\n        Start a request by sending given headers on a new stream, and return\n        the ID of the new stream.\n\n        This may block until the underlying transport becomes writable, and\n        the number of concurrent outbound requests (open outbound streams) is\n        less than the value of peer config MAX_CONCURRENT_STREAMS.\n\n        The completion of the call to this method does not mean the request is\n        successfully delivered - data is only correctly stored in a buffer to\n        be sent. There's no guarantee it is truly delivered.\n\n        :param headers: A list of key-value tuples as headers.\n        :param end_stream: To send a request without body, set `end_stream` to\n                           `True` (default `False`).\n        :return: Stream ID as a integer, used for further communication.\n        \"\"\"\n        yield from _wait_for_events(self._resumed, self._stream_creatable)\n        stream_id = self._conn.get_next_available_stream_id()\n        self._priority.insert_stream(stream_id)\n        self._priority.block(stream_id)\n        self._conn.send_headers(stream_id, headers, end_stream=end_stream)\n        self._flush()\n        return stream_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start_response(self, stream_id, headers, *, end_stream=False):\n        yield from self._resumed.wait()\n        self._conn.send_headers(stream_id, headers, end_stream=end_stream)\n        self._flush()", "response": "Start a response by sending given headers on the given stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_data(self, stream_id, data, *, end_stream=False):\n        try:\n            with (yield from self._get_stream(stream_id).wlock):\n                while True:\n                    yield from _wait_for_events(\n                        self._resumed, self._get_stream(stream_id).window_open)\n                    self._priority.unblock(stream_id)\n                    waiter = asyncio.Future()\n                    if not self._priority_events:\n                        self._loop.call_soon(self._priority_step)\n                    self._priority_events[stream_id] = waiter\n                    try:\n                        yield from waiter\n                        data_size = len(data)\n                        size = min(\n                            data_size,\n                            self._conn.local_flow_control_window(stream_id),\n                            self._conn.max_outbound_frame_size)\n                        if data_size == 0 or size == data_size:\n                            self._conn.send_data(stream_id, data,\n                                                 end_stream=end_stream)\n                            self._flush()\n                            break\n                        elif size > 0:\n                            self._conn.send_data(stream_id, data[:size])\n                            data = data[size:]\n                            self._flush()\n                    finally:\n                        self._priority_events.pop(stream_id, None)\n                        self._priority.block(stream_id)\n                        if self._priority_events:\n                            self._loop.call_soon(self._priority_step)\n        except ProtocolError:\n            raise exceptions.SendException(data)", "response": "Send data to a given stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending trailers on the given stream.", "response": "def send_trailers(self, stream_id, headers):\n        \"\"\"\n        Send trailers on the given stream, closing the stream locally.\n\n        This may block until the underlying transport becomes writable, or\n        other coroutines release the wlock on this stream.\n\n        :param stream_id: Which stream to send trailers on.\n        :param headers: A list of key-value tuples as trailers.\n        \"\"\"\n        with (yield from self._get_stream(stream_id).wlock):\n            yield from self._resumed.wait()\n            self._conn.send_headers(stream_id, headers, end_stream=True)\n            self._flush()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclosing the given stream locally.", "response": "def end_stream(self, stream_id):\n        \"\"\"\n        Close the given stream locally.\n\n        This may block until the underlying transport becomes writable, or\n        other coroutines release the wlock on this stream.\n\n        :param stream_id: Which stream to close.\n        \"\"\"\n        with (yield from self._get_stream(stream_id).wlock):\n            yield from self._resumed.wait()\n            self._conn.end_stream(stream_id)\n            self._flush()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading data from the given stream.", "response": "def read_stream(self, stream_id, size=None):\n        \"\"\"\n        Read data from the given stream.\n\n        By default (`size=None`), this returns all data left in current HTTP/2\n        frame. In other words, default behavior is to receive frame by frame.\n\n        If size is given a number above zero, method will try to return as much\n        bytes as possible up to the given size, block until enough bytes are\n        ready or stream is remotely closed.\n\n        If below zero, it will read until the stream is remotely closed and\n        return everything at hand.\n\n        `size=0` is a special case that does nothing but returns `b''`. The\n        same result `b''` is also returned under other conditions if there is\n        no more data on the stream to receive, even under `size=None` and peer\n        sends an empty frame - you can use `b''` to safely identify the end of\n        the given stream.\n\n        Flow control frames will be automatically sent while reading clears the\n        buffer, allowing more data to come in.\n\n        :param stream_id: Stream to read\n        :param size: Expected size to read, `-1` for all, default frame.\n        :return: Bytes read or empty if there is no more to expect.\n        \"\"\"\n        rv = []\n        try:\n            with (yield from self._get_stream(stream_id).rlock):\n                if size is None:\n                    rv.append((\n                        yield from self._get_stream(stream_id).read_frame()))\n                    self._flow_control(stream_id)\n                elif size < 0:\n                    while True:\n                        rv.extend((\n                            yield from self._get_stream(stream_id).read_all()))\n                        self._flow_control(stream_id)\n                else:\n                    while size > 0:\n                        bufs, count = yield from self._get_stream(\n                            stream_id).read(size)\n                        rv.extend(bufs)\n                        size -= count\n                        self._flow_control(stream_id)\n        except StreamClosedError:\n            pass\n        except _StreamEndedException as e:\n            try:\n                self._flow_control(stream_id)\n            except StreamClosedError:\n                pass\n            rv.extend(e.bufs)\n        return b''.join(rv)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwaits until the connection becomes functional.", "response": "def wait_functional(self):\n        \"\"\"\n        Wait until the connection becomes functional.\n\n        The connection is count functional if it was active within last few\n        seconds (defined by `functional_timeout`), where a newly-made\n        connection and received data indicate activeness.\n\n        :return: Most recently calculated round-trip time if any.\n        \"\"\"\n        while not self._is_functional():\n            self._rtt = None\n            self._ping_index += 1\n            self._ping_time = self._loop.time()\n            self._conn.ping(struct.pack('Q', self._ping_index))\n            self._flush()\n            try:\n                yield from asyncio.wait_for(self._functional.wait(),\n                                            self._functional_timeout)\n            except asyncio.TimeoutError:\n                pass\n        return self._rtt"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the priority status of an existing stream. :param stream_id: The stream ID of the stream being updated. :param depends_on: (optional) The ID of the stream that the stream now depends on. If ``None``, will be moved to depend on stream 0. :param weight: (optional) The new weight to give the stream. Defaults to 16. :param exclusive: (optional) Whether this stream should now be an exclusive dependency of the new parent.", "response": "def reprioritize(self, stream_id,\n                     depends_on=None, weight=16, exclusive=False):\n        \"\"\"\n        Update the priority status of an existing stream.\n\n        :param stream_id: The stream ID of the stream being updated.\n        :param depends_on: (optional) The ID of the stream that the stream now\n            depends on. If ``None``, will be moved to depend on stream 0.\n        :param weight: (optional) The new weight to give the stream. Defaults\n            to 16.\n        :param exclusive: (optional) Whether this stream should now be an\n            exclusive dependency of the new parent.\n        \"\"\"\n        self._priority.reprioritize(stream_id, depends_on, weight, exclusive)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef superuser_required(view_func=None, redirect_field_name=REDIRECT_FIELD_NAME,\n                       login_url='admin:login'):\n    \"\"\"\n    Decorator for views that checks that the user is logged in and is a superuser\n    member, redirecting to the login page if necessary.\n    \"\"\"\n    actual_decorator = user_passes_test(\n        lambda u: u.is_active and u.is_superuser,\n        login_url=login_url,\n        redirect_field_name=redirect_field_name\n    )\n    if view_func:\n        return actual_decorator(view_func)\n    return actual_decorator", "response": "Decorator for views that checks that the user is logged in and is a superuser member."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _condition_as_sql(self, qn, connection):\n        '''\n        Return sql for condition.\n        '''\n        def escape(value):\n            if isinstance(value, bool):\n                value = str(int(value))\n            if isinstance(value, six.string_types):\n                # Escape params used with LIKE\n                if '%' in value:\n                    value = value.replace('%', '%%')\n                # Escape single quotes\n                if \"'\" in value:\n                    value = value.replace(\"'\", \"''\")\n                # Add single quote to text values\n                value = \"'\" + value + \"'\"\n            return value\n\n        sql, param = self.condition.query.where.as_sql(qn, connection)\n        param = map(escape, param)\n\n        return sql % tuple(param)", "response": "Return sql for condition.\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef computeVoronoiDiagram(points):\n    siteList = SiteList(points)\n    context  = Context()\n    voronoi(siteList,context)\n    return (context.vertices, context.edges, context.polygons)", "response": "Computes the Voronoi diagram of a list of points."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the Delaunay triangulation of a list of points.", "response": "def computeDelaunayTriangulation(points):\n    \"\"\" Takes a list of point objects (which must have x and y fields).\n        Returns a list of 3-tuples: the indices of the points that form a\n        Delaunay triangle.\n    \"\"\"\n    siteList = SiteList(points)\n    context  = Context()\n    context.triangulate = True\n    voronoi(siteList,context)\n    return context.triangles"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_messages_metrics(messages):\n    count_types = collections.Counter(\n        line.get('type') or None\n        for line in messages)\n    count_modules = collections.Counter(\n        line.get('module') or None\n        for line in messages)\n    count_symbols = collections.Counter(\n        line.get('symbol') or None\n        for line in messages)\n    count_paths = collections.Counter(\n        line.get('path') or None\n        for line in messages)\n\n    return {\n        'types': count_types,\n        'modules': count_modules,\n        'symbols': count_symbols,\n        'paths': count_paths,\n    }", "response": "Build reports s metrics"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_messages_modules(messages):\n    data = collections.defaultdict(list)\n    for line in messages:\n        module_name = line.get('module')\n        module_path = line.get('path')\n        module_info = ModuleInfo(\n            module_name,\n            module_path,\n        )\n        data[module_info].append(line)\n\n    for module, module_messages in data.items():\n        yield (\n            module,\n            sorted(module_messages, key=lambda x: x.get('line')))", "response": "Build and yield sorted list of messages per module."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stats_evaluation(stats):\n    statement = stats.get('statement')\n    error = stats.get('error', 0)\n    warning = stats.get('warning', 0)\n    refactor = stats.get('refactor', 0)\n    convention = stats.get('convention', 0)\n\n    if not statement or statement <= 0:\n        return None\n\n    malus = float(5 * error + warning + refactor + convention)\n    malus_ratio = malus / statement\n    return 10.0 - (malus_ratio * 10)", "response": "Generate an evaluation for the given pylint stats."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_command_parser():\n    parser = argparse.ArgumentParser(\n        description='Transform Pylint JSON report to HTML')\n    parser.add_argument(\n        'filename',\n        metavar='FILENAME',\n        type=argparse.FileType('r'),\n        nargs='?',\n        default=sys.stdin,\n        help='Pylint JSON report input file (or stdin)')\n    parser.add_argument(\n        '-o', '--output',\n        metavar='FILENAME',\n        type=argparse.FileType('w'),\n        default=sys.stdout,\n        help='Pylint HTML report output file (or stdout)')\n    parser.add_argument(\n        '-f', '--input-format',\n        metavar='FORMAT',\n        choices=[SIMPLE_JSON, EXTENDED_JSON],\n        action='store',\n        dest='input_format',\n        default='json',\n        help='Pylint JSON Report input type (json or jsonextended)')\n\n    return parser", "response": "Build command parser using argparse module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrender the report to HTML", "response": "def render(self):\n        \"\"\"Render report to HTML\"\"\"\n        template = self.get_template()\n        return template.render(\n            messages=self._messages,\n            metrics=self.metrics,\n            report=self)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstoring new message for later use.", "response": "def handle_message(self, msg):\n        \"\"\"Store new message for later use.\n\n        .. seealso:: :meth:`~JsonExtendedReporter.on_close`\n        \"\"\"\n        self._messages.append({\n            'type': msg.category,\n            'module': msg.module,\n            'obj': msg.obj,\n            'line': msg.line,\n            'column': msg.column,\n            'path': msg.path,\n            'symbol': msg.symbol,\n            'message': str(msg.msg) or '',\n            'message-id': msg.msg_id,\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint the extended JSON report to the reporter s output.", "response": "def on_close(self, stats, previous_stats):\n        \"\"\"Print the extended JSON report to reporter's output.\n\n        :param dict stats: Metrics for the current pylint run\n        :param dict previous_stats: Metrics for the previous pylint run\n        \"\"\"\n        reports = {\n            'messages': self._messages,\n            'stats': stats,\n            'previous': previous_stats,\n        }\n        print(json.dumps(reports, cls=JSONSetEncoder, indent=4), file=self.out)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef triangulate(points):  \n    # Remove duplicate xy points bc that would make delauney fail, and must remember z (if any) for retrieving originals from index results\n    seen = set() \n    uniqpoints = [ p for p in points if str( p[:2] ) not in seen and not seen.add( str( p[:2] ) )]\n    classpoints = [_Point(*point[:2]) for point in uniqpoints]\n\n    # Compute Delauney\n    triangle_ids = tesselator.computeDelaunayTriangulation(classpoints)\n\n    # Get vertices from result indexes\n    triangles = [[uniqpoints[i] for i in triangle] for triangle in triangle_ids]\n    \n    return triangles", "response": "Computes the smallest possible Delauney triangles between the input list of xy points."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of 2 - tuples with the first item being the original point and the second item being the corressponding Voronoi polygon.", "response": "def voronoi(points, buffer_percent=100):\n    \"\"\"\n    Surrounds each point in an input list of xy tuples with a\n    unique Voronoi polygon.\n\n    Arguments:\n    \n    - **points**: A list of xy or xyz point tuples to triangulate. \n    - **buffer_percent** (optional): Controls how much bigger than\n        the original bbox of the input points to set the bbox of fake points,\n        used to account for lacking values around the edges (default is 100 percent).\n\n    Returns:\n    \n    - Returns a list of 2-tuples, with the first item in each tuple being the\n        original input point (or None for each corner of the bounding box buffer),\n        and the second item being the point's corressponding Voronoi polygon. \n\n    \"\"\"\n    # Remove duplicate xy points bc that would make delauney fail, and must remember z (if any) for retrieving originals from index results\n    seen = set() \n    uniqpoints = [ p for p in points if str( p[:2] ) not in seen and not seen.add( str( p[:2] ) )]\n    classpoints = [_Point(*point[:2]) for point in uniqpoints]\n\n    # Create fake sitepoints around the point extent to correct for infinite polygons\n    # For a similar approach and problem see: http://gis.stackexchange.com/questions/11866/voronoi-polygons-that-run-out-to-infinity\n    xs,ys = list(zip(*uniqpoints))[:2]\n    pointswidth = max(xs) - min(xs)\n    pointsheight = max(ys) - min(ys)\n    xbuff,ybuff = ( pointswidth / 100.0 * buffer_percent , pointsheight / 100.0 * buffer_percent )\n    midx,midy = ( sum(xs) / float(len(xs)) , sum(ys) / float(len(ys)) )\n    #bufferbox = [(midx-xbuff,midy-ybuff),(midx+xbuff,midy-ybuff),(midx+xbuff,midy+ybuff),(midx-xbuff,midy+ybuff)] # corner buffer\n    bufferbox = [(midx-xbuff,midy),(midx+xbuff,midy),(midx,midy+ybuff),(midx,midy-ybuff)] # mid sides buffer\n    classpoints.extend([_Point(*corner) for corner in bufferbox])\n\n    # Compute Voronoi\n    vertices,edges,poly_dict = tesselator.computeVoronoiDiagram(classpoints)\n\n    # Turn unordered result edges into ordered polygons\n    polygons = list()\n    for sitepoint,polyedges in list(poly_dict.items()):\n        polyedges = [edge[1:] for edge in polyedges]\n        poly = list()\n        firststart,firstend = polyedges.pop(0)\n        poly.append(firstend)\n        while polyedges:\n            curend = poly[-1]\n            for i,other in enumerate(polyedges):\n                otherstart,otherend = other\n                if otherstart == curend:\n                    poly.append(otherend)\n                    ##print otherstart,otherend\n                    polyedges.pop(i)\n                    break\n                elif otherend == curend:\n                    ##print otherend,otherstart\n                    poly.append(otherstart)\n                    polyedges.pop(i)\n                    break\n        # Get vertices from indexes\n        try: sitepoint = uniqpoints[sitepoint]\n        except IndexError:\n            sitepoint = None # fake bbox sitepoints shouldnt be in the results\n        poly = [vertices[vi] for vi in poly if vi != -1]\n        polygons.append((sitepoint, poly))\n\n    # Maybe clip parts of polygons that stick outside screen?\n    # ...\n\n    return polygons"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef equals(val1, val2):\n    if len(val1) != len(val2):\n        return False\n    result = 0\n    for x, y in zip(val1, val2):\n        result |= ord(x) ^ ord(y)\n    return result == 0", "response": "Returns True if the two strings are equal False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nencodes integer into variable - length format into data.", "response": "def _encode_uvarint(data, n):\n    ''' Encodes integer into variable-length format into data.'''\n    if n < 0:\n        raise ValueError('only support positive integer')\n    while True:\n        this_byte = n & 0x7f\n        n >>= 7\n        if n == 0:\n            data.append(this_byte)\n            break\n        data.append(this_byte | 0x80)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_section_v2(self, data):\n        ''' Parses a sequence of packets in data.\n\n        The sequence is terminated by a packet with a field type of EOS\n        :param data bytes to be deserialized.\n        :return: the rest of data and an array of packet V2\n        '''\n\n        from pymacaroons.exceptions import MacaroonDeserializationException\n\n        prev_field_type = -1\n        packets = []\n        while True:\n            if len(data) == 0:\n                raise MacaroonDeserializationException(\n                    'section extends past end of buffer')\n            rest, packet = self._parse_packet_v2(data)\n            if packet.field_type == self._EOS:\n                return rest, packets\n            if packet.field_type <= prev_field_type:\n                raise MacaroonDeserializationException('fields out of order')\n            packets.append(packet)\n            prev_field_type = packet.field_type\n            data = rest", "response": "Parses a sequence of packets in data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_packet_v2(self, data):\n        ''' Parses a V2 data packet at the start of the given data.\n\n        The format of a packet is as follows:\n\n        field_type(varint) payload_len(varint) data[payload_len bytes]\n\n        apart from EOS which has no payload_en or data (it's a single zero\n        byte).\n\n        :param data:\n        :return: rest of data, PacketV2\n        '''\n        from pymacaroons.exceptions import MacaroonDeserializationException\n\n        ft, n = _decode_uvarint(data)\n        data = data[n:]\n        if ft == self._EOS:\n            return data, PacketV2(ft, None)\n        payload_len, n = _decode_uvarint(data)\n        data = data[n:]\n        if payload_len > len(data):\n            raise MacaroonDeserializationException(\n                'field data extends past end of buffer')\n        return data[payload_len:], PacketV2(ft, data[0:payload_len])", "response": "Parses a V2 data packet at the start of the given data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prepare_for_request(self, discharge_macaroon):\n        ''' Return a new discharge macaroon bound to the receiving macaroon's\n        current signature so that it can be used in a request.\n\n        This must be done before a discharge macaroon is sent to a server.\n\n        :param discharge_macaroon:\n        :return: bound discharge macaroon\n        '''\n        protected = discharge_macaroon.copy()\n        return HashSignaturesBinder(self).bind(protected)", "response": "Returns a new discharge macaroon bound to the receiving macaroon s\n        current signature so that it can be used in a request."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a caveat as a dictionary for export as the JSON macaroon v1 format.", "response": "def _caveat_v1_to_dict(c):\n    ''' Return a caveat as a dictionary for export as the JSON\n    macaroon v1 format.\n    '''\n    serialized = {}\n    if len(c.caveat_id) > 0:\n        serialized['cid'] = c.caveat_id\n    if c.verification_key_id:\n        serialized['vid'] = utils.raw_urlsafe_b64encode(\n            c.verification_key_id).decode('utf-8')\n    if c.location:\n        serialized['cl'] = c.location\n    return serialized"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _caveat_v2_to_dict(c):\n    ''' Return a caveat as a dictionary for export as the JSON\n    macaroon v2 format.\n    '''\n    serialized = {}\n    if len(c.caveat_id_bytes) > 0:\n        _add_json_binary_field(c.caveat_id_bytes, serialized, 'i')\n    if c.verification_key_id:\n        _add_json_binary_field(c.verification_key_id, serialized, 'v')\n    if c.location:\n        serialized['l'] = c.location\n    return serialized", "response": "Return a caveat as a dictionary for export as the JSON\n    macaroon v2 format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _add_json_binary_field(b, serialized, field):\n    ''' Set the given field to the given val (a bytearray) in the serialized\n    dictionary.\n\n    If the value isn't valid utf-8, we base64 encode it and use field+\"64\"\n    as the field name.\n    '''\n    try:\n        val = b.decode(\"utf-8\")\n        serialized[field] = val\n    except UnicodeDecodeError:\n        val = utils.raw_urlsafe_b64encode(b).decode('utf-8')\n        serialized[field + '64'] = val", "response": "Add a field to the given val in the given serialized dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _read_json_binary_field(deserialized, field):\n    ''' Read the value of a JSON field that may be string or base64-encoded.\n    '''\n    val = deserialized.get(field)\n    if val is not None:\n        return utils.convert_to_bytes(val)\n    val = deserialized.get(field + '64')\n    if val is None:\n        return None\n    return utils.raw_urlsafe_b64decode(val)", "response": "Read the value of a JSON field that may be string or base64 - encoded."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef serialize(self, m):\n        '''Serialize the macaroon in JSON format indicated by the version field.\n\n        @param macaroon the macaroon to serialize.\n        @return JSON macaroon.\n        '''\n        from pymacaroons import macaroon\n        if m.version == macaroon.MACAROON_V1:\n            return self._serialize_v1(m)\n        return self._serialize_v2(m)", "response": "Serialize the macaroon in JSON format indicated by the version field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nserializing the macaroon in JSON format v1. @param macaroon the macaroon to serialize. @return JSON macaroon.", "response": "def _serialize_v1(self, macaroon):\n        '''Serialize the macaroon in JSON format v1.\n\n        @param macaroon the macaroon to serialize.\n        @return JSON macaroon.\n        '''\n        serialized = {\n            'identifier': utils.convert_to_string(macaroon.identifier),\n            'signature': macaroon.signature,\n        }\n        if macaroon.location:\n            serialized['location'] = macaroon.location\n        if macaroon.caveats:\n            serialized['caveats'] = [\n                _caveat_v1_to_dict(caveat) for caveat in macaroon.caveats\n            ]\n        return json.dumps(serialized)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _serialize_v2(self, macaroon):\n        '''Serialize the macaroon in JSON format v2.\n\n        @param macaroon the macaroon to serialize.\n        @return JSON macaroon in v2 format.\n        '''\n        serialized = {}\n        _add_json_binary_field(macaroon.identifier_bytes, serialized, 'i')\n        _add_json_binary_field(binascii.unhexlify(macaroon.signature_bytes),\n                               serialized, 's')\n\n        if macaroon.location:\n            serialized['l'] = macaroon.location\n        if macaroon.caveats:\n            serialized['c'] = [\n                _caveat_v2_to_dict(caveat) for caveat in macaroon.caveats\n            ]\n        return json.dumps(serialized)", "response": "Serialize the macaroon in JSON format v2."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _deserialize_v1(self, deserialized):\n        '''Deserialize a JSON macaroon in v1 format.\n\n        @param serialized the macaroon in v1 JSON format.\n        @return the macaroon object.\n        '''\n        from pymacaroons.macaroon import Macaroon, MACAROON_V1\n        from pymacaroons.caveat import Caveat\n\n        caveats = []\n        for c in deserialized.get('caveats', []):\n            caveat = Caveat(\n                caveat_id=c['cid'],\n                verification_key_id=(\n                    utils.raw_b64decode(c['vid']) if c.get('vid')\n                    else None\n                ),\n                location=(\n                    c['cl'] if c.get('cl') else None\n                ),\n                version=MACAROON_V1\n            )\n            caveats.append(caveat)\n\n        return Macaroon(\n            location=deserialized.get('location'),\n            identifier=deserialized['identifier'],\n            caveats=caveats,\n            signature=deserialized['signature'],\n            version=MACAROON_V1\n        )", "response": "Deserialize a JSON macaroon in v1 format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _deserialize_v2(self, deserialized):\n        '''Deserialize a JSON macaroon v2.\n\n        @param serialized the macaroon in JSON format v2.\n        @return the macaroon object.\n        '''\n        from pymacaroons.macaroon import Macaroon, MACAROON_V2\n        from pymacaroons.caveat import Caveat\n        caveats = []\n        for c in deserialized.get('c', []):\n            caveat = Caveat(\n                caveat_id=_read_json_binary_field(c, 'i'),\n                verification_key_id=_read_json_binary_field(c, 'v'),\n                location=_read_json_binary_field(c, 'l'),\n                version=MACAROON_V2\n            )\n            caveats.append(caveat)\n        return Macaroon(\n            location=_read_json_binary_field(deserialized, 'l'),\n            identifier=_read_json_binary_field(deserialized, 'i'),\n            caveats=caveats,\n            signature=binascii.hexlify(\n                _read_json_binary_field(deserialized, 's')),\n            version=MACAROON_V2\n        )", "response": "Deserialize a JSON macaroon in JSON format v2.\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find(cls, id='', user=None, project=None):\n\n        if not id:\n            if not (user and project):\n                raise ValueError('Both user and project required')\n            if (\n                isinstance(user, User)\n                and isinstance(project, Project)\n            ):\n                _user_id = user.id\n                _project_id = project.id\n            elif (\n                isinstance(user, (int, str,))\n                and isinstance(project, (int, str,))\n            ):\n                _user_id = user\n                _project_id = project\n            else:\n                raise TypeError\n            id = cls.where(user_id=_user_id, project_id=_project_id).next().id\n        return super(ProjectPreferences, cls).find(id)", "response": "Like PaloptesObject. find but can also query by user and project."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving settings for a user and project.", "response": "def save_settings(cls, project=None, user=None, settings=None):\n        \"\"\"\n        Save settings for a user without first fetching their preferences.\n\n        - **user** and **project** can be either a :py:class:`.User` and\n          :py:class:`.Project` instance respectively, or they can be given as\n          IDs. If either argument is given, the other is also required.\n        - **settings** is a :py:class:`dict` containing the settings to be\n          saved.\n        \"\"\"\n\n        if (isinstance(settings, dict)):\n            _to_update = settings\n            if (\n                isinstance(user, User)\n                and isinstance(project, Project)\n            ):\n                _user_id = user.id\n                _project_id = project.id\n            elif (\n                isinstance(user, (int, str,))\n                and isinstance(project, (int, str,))\n            ):\n                _user_id = user\n                _project_id = project\n            else:\n                raise TypeError\n            cls.http_post(\n                'update_settings',\n                json={\n                    'project_preferences': {\n                        'user_id': _user_id,\n                        'project_id': _project_id,\n                        'settings': _to_update,\n                    }\n                }\n            )\n        else:\n            raise TypeError"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a context manager that allows asynchronously creating subjects.", "response": "def async_saves(cls):\n        \"\"\"\n        Returns a context manager to allow asynchronously creating subjects.\n        Using this context manager will create a pool of threads which will\n        create multiple subjects at once and upload any local files\n        simultaneously.\n\n        The recommended way to use this is with the `with` statement::\n\n            with Subject.async_saves():\n                local_files = [...]\n                for filename in local_files:\n                    s = Subject()\n                    s.links.project = 1234\n                    s.add_location(filename)\n                    s.save()\n\n        Alternatively, you can manually shut down the thread pool::\n\n            pool = Subject.async_saves()\n            local_files = [...]\n            try:\n                for filename in local_files:\n                    s = Subject()\n                    s.links.project = 1234\n                    s.add_location(filename)\n                    s.save()\n            finally:\n                pool.shutdown()\n        \"\"\"\n        cls._local.save_exec = ThreadPoolExecutor(\n            max_workers=ASYNC_SAVE_THREADS\n        )\n        return cls._local.save_exec"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save(self, client=None):\n        if not client:\n            client = Panoptes.client()\n\n        async_save = hasattr(self._local, 'save_exec')\n\n        with client:\n            if async_save:\n                try:\n                    # The recursive call will exec in a new thread, so\n                    # self._local.save_exec will be undefined above\n                    self._async_future = self._local.save_exec.submit(\n                        self.save,\n                        client=client,\n                    )\n                    return\n                except RuntimeError:\n                    del self._local.save_exec\n                    async_save = False\n\n            if not self.metadata == self._original_metadata:\n                self.modified_attributes.add('metadata')\n\n            response = retry(\n                super(Subject, self).save,\n                attempts=UPLOAD_RETRY_LIMIT,\n                sleeptime=RETRY_BACKOFF_INTERVAL,\n                retry_exceptions=(PanoptesAPIException,),\n                log_args=False,\n            )\n\n            if not response:\n                return\n\n            try:\n                if async_save:\n                    upload_exec = self._local.save_exec\n                else:\n                    upload_exec = ThreadPoolExecutor(\n                        max_workers=ASYNC_SAVE_THREADS,\n                    )\n\n                for location, media_data in zip(\n                    response['subjects'][0]['locations'],\n                    self._media_files\n                ):\n                    if not media_data:\n                        continue\n\n                    for media_type, url in location.items():\n                        upload_exec.submit(\n                            retry,\n                            self._upload_media,\n                            args=(url, media_data, media_type),\n                            attempts=UPLOAD_RETRY_LIMIT,\n                            sleeptime=RETRY_BACKOFF_INTERVAL,\n                            retry_exceptions=(\n                                requests.exceptions.RequestException,\n                            ),\n                            log_args=False,\n                        )\n            finally:\n                if not async_save:\n                    upload_exec.shutdown()", "response": "Save the object to the server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the result of this subject s asynchronous save.", "response": "def async_save_result(self):\n        \"\"\"\n        Retrieves the result of this subject's asynchronous save.\n\n        - Returns `True` if the subject was saved successfully.\n        - Raises `concurrent.futures.CancelledError` if the save was cancelled.\n        - If the save failed, raises the relevant exception.\n        - Returns `False` if the subject hasn't finished saving or if the\n          subject has not been queued for asynchronous save.\n        \"\"\"\n        if hasattr(self, \"_async_future\") and self._async_future.done():\n            self._async_future.result()\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_location(self, location):\n        if type(location) is dict:\n            self.locations.append(location)\n            self._media_files.append(None)\n            return\n        elif type(location) in (str,) + _OLD_STR_TYPES:\n            f = open(location, 'rb')\n        else:\n            f = location\n\n        try:\n            media_data = f.read()\n            if MEDIA_TYPE_DETECTION == 'magic':\n                media_type = magic.from_buffer(media_data, mime=True)\n            else:\n                media_type = imghdr.what(None, media_data)\n                if not media_type:\n                    raise UnknownMediaException(\n                        'Could not detect file type. Please try installing '\n                        'libmagic: https://panoptes-python-client.readthedocs.'\n                        'io/en/latest/user_guide.html#uploading-non-image-'\n                        'media-types'\n                    )\n                media_type = 'image/{}'.format(media_type)\n            self.locations.append(media_type)\n            self._media_files.append(media_data)\n        finally:\n            f.close()", "response": "Add a location to this subject."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndownload a data export over HTTP and returns a Requests Response_object containing the content of the export.", "response": "def get_export(\n        self,\n        export_type,\n        generate=False,\n        wait=False,\n        wait_timeout=None,\n    ):\n        \"\"\"\n        Downloads a data export over HTTP. Returns a `Requests Response\n        <http://docs.python-requests.org/en/master/api/#requests.Response>`_\n        object containing the content of the export.\n\n        - **export_type** is a string specifying which type of export should be\n          downloaded.\n        - **generate** is a boolean specifying whether to generate a new export\n          and wait for it to be ready, or to just download the latest export.\n        - **wait** is a boolean specifying whether to wait for an in-progress\n          export to finish, if there is one. Has no effect if ``generate`` is\n          ``True``.\n        - **wait_timeout** is the number of seconds to wait if ``wait`` is\n          ``True``. Has no effect if ``wait`` is ``False`` or if ``generate``\n          is ``True``.\n\n        The returned :py:class:`.Response` object has two additional attributes\n        as a convenience for working with the CSV content; **csv_reader** and\n        **csv_dictreader**, which are wrappers for :py:meth:`.csv.reader`\n        and :py:class:`csv.DictReader` respectively. These wrappers take care\n        of correctly decoding the export content for the CSV parser.\n\n        Example::\n\n            classification_export = Project(1234).get_export('classifications')\n            for row in classification_export.csv_reader():\n                print(row)\n\n            classification_export = Project(1234).get_export('classifications')\n            for row in classification_export.csv_dictreader():\n                print(row)\n        \"\"\"\n\n        if generate:\n            self.generate_export(export_type)\n\n        if generate or wait:\n            export = self.wait_export(export_type, wait_timeout)\n        else:\n            export = self.describe_export(export_type)\n\n        if export_type in TALK_EXPORT_TYPES:\n            media_url = export['data_requests'][0]['url']\n        else:\n            media_url = export['media'][0]['src']\n\n        response = requests.get(media_url, stream=True)\n        response.csv_reader = functools.partial(\n            csv.reader,\n            response.iter_lines(decode_unicode=True),\n        )\n        response.csv_dictreader = functools.partial(\n            csv.DictReader,\n            response.iter_lines(decode_unicode=True),\n        )\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wait_export(\n        self,\n        export_type,\n        timeout=None,\n    ):\n        \"\"\"\n        Blocks until an in-progress export is ready.\n\n        - **export_type** is a string specifying which type of export to wait\n          for.\n        - **timeout** is the maximum number of seconds to wait.\n\n        If ``timeout`` is given and the export is not ready by the time limit,\n        :py:class:`.PanoptesAPIException` is raised.\n        \"\"\"\n\n        success = False\n        if timeout:\n            end_time = datetime.datetime.now() + datetime.timedelta(\n                seconds=timeout\n            )\n\n        while (not timeout) or (datetime.datetime.now() < end_time):\n            export_description = self.describe_export(\n                export_type,\n            )\n\n            if export_type in TALK_EXPORT_TYPES:\n                export_metadata = export_description['data_requests'][0]\n            else:\n                export_metadata = export_description['media'][0]['metadata']\n\n            if export_metadata.get('state', '') in ('ready', 'finished'):\n                success = True\n                break\n\n            time.sleep(2)\n\n        if not success:\n            raise PanoptesAPIException(\n                '{}_export not ready within {} seconds'.format(\n                    export_type,\n                    timeout\n                )\n            )\n\n        return export_description", "response": "Waits until an export is ready."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_export(self, export_type):\n\n        if export_type in TALK_EXPORT_TYPES:\n            return talk.post_data_request(\n                'project-{}'.format(self.id),\n                export_type.replace('talk_', '')\n            )\n\n        return self.http_post(\n            self._export_path(export_type),\n            json={\"media\": {\"content_type\": \"text/csv\"}},\n        )[0]", "response": "Generate a new export."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef describe_export(self, export_type):\n        if export_type in TALK_EXPORT_TYPES:\n            return talk.get_data_request(\n                'project-{}'.format(self.id),\n                export_type.replace('talk_', '')\n            )[0]\n\n        return self.http_get(\n            self._export_path(export_type),\n        )[0]", "response": "Get metadata for an export."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find(cls, id='', slug=None):\n\n        if not id and not slug:\n            return None\n        try:\n            return cls.where(id=id, slug=slug).next()\n        except StopIteration:\n            raise PanoptesAPIException(\n                \"Could not find collection with slug='{}'\".format(slug)\n            )", "response": "Similar to : py : meth :. PanoptesObject. find but allows lookup by slug\n            as well as ID."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_default_subject(self, subject):\n        if not (\n            isinstance(subject, Subject)\n            or isinstance(subject, (int, str,))\n        ):\n            raise TypeError\n        if isinstance(subject, Subject):\n            _subject_id = subject.id\n        else:\n            _subject_id = str(subject)\n\n        self.http_post(\n            '{}/links/default_subject'.format(self.id),\n            json={'default_subject': _subject_id},\n        )", "response": "Sets the subject s location media URL as a link."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef subjects(self):\n\n        for sms in SetMemberSubject.where(subject_set_id=self.id):\n            yield sms.links.subject", "response": "A generator which yields all subjects in this set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretire the given subjects in this workflow.", "response": "def retire_subjects(self, subjects, reason='other'):\n        \"\"\"\n        Retires subjects in this workflow.\n\n        - **subjects** can be a list of :py:class:`Subject` instances, a list\n          of subject IDs, a single :py:class:`Subject` instance, or a single\n          subject ID.\n        - **reason** gives the reason the :py:class:`Subject` has been retired.\n          Defaults to **other**.\n\n        Examples::\n\n            workflow.retire_subjects(1234)\n            workflow.retire_subjects([1,2,3,4])\n            workflow.retire_subjects(Subject(1234))\n            workflow.retire_subjects([Subject(12), Subject(34)])\n        \"\"\"\n\n        subjects = [ s.id if isinstance(s, Subject) else s for s in subjects ]\n\n        return Workflow.http_post(\n            '{}/retired_subjects'.format(self.id),\n            json={\n                'subject_ids': subjects,\n                'retirement_reason': reason\n            }\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collaborators(self, *roles):\n\n        return [\n            r.links.owner for r in ProjectRole.where(project_id=self.id)\n            if len(roles) == 0 or len(set(roles) & set(r.roles)) > 0\n        ]", "response": "Returns a list of users who are collaborators on this project."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(cls, *args, **kwargs):\n        cls._local.panoptes_client = cls(*args, **kwargs)\n        cls._local.panoptes_client.login()\n        return cls._local.panoptes_client", "response": "Connect to the PANOPTES API."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef where(cls, **kwargs):\n\n        _id = kwargs.pop('id', '')\n        return cls.paginated_results(*cls.http_get(_id, params=kwargs))", "response": "Returns a generator which yields instances matching the given query\n            arguments."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the individual instance with the given ID if it exists. Raises a PanoptesAPIException if the object with the given ID is not found.", "response": "def find(cls, _id):\n        \"\"\"\n        Returns the individual instance with the given ID, if it exists. Raises\n        :py:class:`PanoptesAPIException` if the object with that ID is not\n        found.\n        \"\"\"\n\n        if not _id:\n            return None\n        try:\n            return next(cls.where(id=_id))\n        except StopIteration:\n            raise PanoptesAPIException(\n                \"Could not find {} with id='{}'\".format(cls.__name__, _id)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self):\n\n        if not self.id:\n            save_method = Panoptes.client().post\n            force_reload = False\n        else:\n            if not self.modified_attributes:\n                return\n            if not self._loaded:\n                self.reload()\n            save_method = Panoptes.client().put\n            force_reload = True\n\n        response, response_etag = save_method(\n            self.url(self.id),\n            json={self._api_slug: self._savable_dict(\n                modified_attributes=self.modified_attributes\n            )},\n            etag=self.etag\n        )\n\n        raw_resource_response = response[self._api_slug][0]\n        self.set_raw(raw_resource_response, response_etag)\n\n        if force_reload:\n            self._loaded = False\n\n        return response", "response": "Saves the object to the API."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreloads the object from the API discarding any local changes.", "response": "def reload(self):\n        \"\"\"\n        Re-fetches the object from the API, discarding any local changes.\n        Returns without doing anything if the object is new.\n        \"\"\"\n\n        if not self.id:\n            return\n        reloaded_object = self.__class__.find(self.id)\n        self.set_raw(\n            reloaded_object.raw,\n            reloaded_object.etag\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete(self):\n\n        if not self.id:\n            return\n        if not self._loaded:\n            self.reload()\n        return self.http_delete(self.id, etag=self.etag)", "response": "Deletes the object. Returns without doing anything if the object is new."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, objs):\n\n        if self.readonly:\n            raise NotImplementedError(\n                '{} links can\\'t be modified'.format(self._slug)\n            )\n\n        if not self._parent.id:\n            raise ObjectNotSavedException(\n                \"Links can not be modified before the object has been saved.\"\n            )\n\n        _objs = [obj for obj in self._build_obj_list(objs) if obj not in self]\n        if not _objs:\n            return\n\n        self._parent.http_post(\n            '{}/links/{}'.format(self._parent.id, self._slug),\n            json={self._slug: _objs},\n            retry=True,\n        )\n        self._linked_object_ids.extend(_objs)", "response": "Adds the given objects to the LinkCollection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove(self, objs):\n\n        if self.readonly:\n            raise NotImplementedError(\n                '{} links can\\'t be modified'.format(self._slug)\n            )\n\n        if not self._parent.id:\n            raise ObjectNotSavedException(\n                \"Links can not be modified before the object has been saved.\"\n            )\n\n        _objs = [obj for obj in self._build_obj_list(objs) if obj in self]\n        if not _objs:\n            return\n\n        _obj_ids = \",\".join(_objs)\n        self._parent.http_delete(\n            '{}/links/{}/{}'.format(self._parent.id, self._slug, _obj_ids),\n            retry=True,\n        )\n        self._linked_object_ids = [\n            obj for obj in self._linked_object_ids if obj not in _objs\n        ]", "response": "Removes the given objects from this LinkCollection."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the command line input arguments.", "response": "def parse():\n    \"\"\"Parse the command line input arguments.\"\"\"\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument('--version', action='version',\n                        version='f90nml {0}'.format(f90nml.__version__))\n\n    parser.add_argument('--group', '-g', action='store',\n                        help=\"specify namelist group to modify. \"\n                        \"When absent, the first group is used\")\n    parser.add_argument('--variable', '-v', action='append',\n                        help=\"specify the namelist variable to add or modify, \"\n                        \"followed by the new value. Expressions are of the \"\n                        \"form `VARIABLE=VALUE`\")\n    parser.add_argument('--patch', '-p', action='store_true',\n                        help=\"modify the existing namelist as a patch\")\n    parser.add_argument('--format', '-f', action='store',\n                        help=\"specify the output format (json, yaml, or nml)\")\n    parser.add_argument('--output', '-o', action='store',\n                        help=\"specify namelist group to modify. \"\n                        \"When absent, the first group is used\")\n\n    parser.add_argument('input', nargs='?')\n    parser.add_argument('output', nargs='?')\n\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit()\n\n    args = parser.parse_args()\n\n    input_fname = args.input\n    output_fname = args.output\n\n    # Get input format\n    # TODO: Combine with output format\n    if input_fname:\n        _, input_ext = os.path.splitext(input_fname)\n        if input_ext == '.json':\n            input_fmt = 'json'\n        elif input_ext == '.yaml':\n            input_fmt = 'yaml'\n        else:\n            input_fmt = 'nml'\n    else:\n        input_fmt = 'nml'\n\n    # Output format flag validation\n    valid_formats = ('json', 'yaml', 'nml')\n    if args.format and args.format not in valid_formats:\n        print('f90nml: error: format must be one of the following: {0}'\n              ''.format(valid_formats), file=sys.stderr)\n        sys.exit(-1)\n\n    # Get output format\n    # TODO: Combine with input format\n    if not args.format:\n        if output_fname:\n            _, output_ext = os.path.splitext(output_fname)\n            if output_ext == '.json':\n                output_fmt = 'json'\n            elif output_ext in ('.yaml', '.yml'):\n                output_fmt = 'yaml'\n            else:\n                output_fmt = 'nml'\n        else:\n            output_fmt = 'nml'\n    else:\n        output_fmt = args.format\n\n    # Confirm that YAML module is available\n    if (input_fmt == 'yaml' or output_fmt == 'yaml') and not has_yaml:\n        print('f90nml: error: YAML module could not be found.',\n              file=sys.stderr)\n        sys.exit(-1)\n\n    # Do not patch non-namelist output\n    if any(fmt != 'nml' for fmt in (input_fmt, output_fmt)) and args.patch:\n        print('f90nml: error: Only namelist files can be patched.',\n              file=sys.stderr)\n        sys.exit(-1)\n\n    # Read the input file\n    if input_fname:\n        if input_fmt in ('json', 'yaml'):\n            if input_fmt == 'json':\n                with open(input_fname) as input_file:\n                    input_data = json.load(input_file)\n            elif input_ext == '.yaml':\n                with open(input_fname) as input_file:\n                    input_data = yaml.safe_load(input_file)\n        else:\n            input_data = f90nml.read(input_fname)\n    else:\n        input_data = {}\n\n    input_data = f90nml.Namelist(input_data)\n\n    # Construct the update namelist\n    update_nml = {}\n    if args.variable:\n        if not args.group:\n            # Use the first available group\n            grp = list(input_data.keys())[0]\n            warnings.warn('f90nml: warning: Assuming variables are in group \\'{0}\\'.'.format(grp))\n        else:\n            grp = args.group\n\n        update_nml_str = '&{0} {1} /\\n'.format(grp, ', '.join(args.variable))\n        update_io = StringIO(update_nml_str)\n        update_nml = f90nml.read(update_io)\n        update_io.close()\n\n    # Target output\n    output_file = open(output_fname, 'w') if output_fname else sys.stdout\n\n    if args.patch:\n        # We have to read the file twice for a patch.  The main reason is\n        # to identify the default group, in case this is not provided.\n        # It could be avoided if a group is provided, but logically that could\n        # a mess that I do not want to sort out right now.\n        f90nml.patch(input_fname, update_nml, output_file)\n\n    else:\n        # Update the input namelist directly\n        if update_nml:\n            try:\n                input_data[grp].update(update_nml[grp])\n            except KeyError:\n                input_data[grp] = update_nml[grp]\n\n        # Write to output\n        if not args.patch:\n            if output_fmt in ('json', 'yaml'):\n                if output_fmt == 'json':\n                    input_data = input_data.todict(complex_tuple=True)\n                    json.dump(input_data, output_file,\n                              indent=4, separators=(',', ': '))\n                    output_file.write('\\n')\n\n                elif output_fmt == 'yaml':\n                    input_data = input_data.todict(complex_tuple=True)\n                    yaml.dump(input_data, output_file,\n                              default_flow_style=False)\n            else:\n                # Default to namelist output\n                f90nml.write(input_data, output_file)\n\n    # Cleanup\n    if output_file != sys.stdout:\n        output_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write(nml, nml_path, force=False, sort=False):\n    # Promote dicts to Namelists\n    if not isinstance(nml, Namelist) and isinstance(nml, dict):\n        nml_in = Namelist(nml)\n    else:\n        nml_in = nml\n\n    nml_in.write(nml_path, force=force, sort=sort)", "response": "Save a namelist to disk using either a file object or its file path."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef patch(nml_path, nml_patch, out_path=None):\n    parser = Parser()\n\n    return parser.read(nml_path, nml_patch, out_path)", "response": "Create a new namelist based on an input namelist and a reference dict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset coordinates of the window to run from x1 y1 x2 y2.", "response": "def setCoords(self, x1, y1, x2, y2):\n        \"\"\"Set coordinates of window to run from (x1,y1) in the\n        lower-left corner to (x2,y2) in the upper-right corner.\"\"\"\n        self.trans = Transform(self.size[0], self.size[1], x1, y1, x2, y2)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef convert(self, format=\"png\", **kwargs):\n        if format.upper() in cairosvg.SURFACES:\n            surface = cairosvg.SURFACES[format.upper()]\n        else:\n            raise Exception(\"'%s' image format unavailable: use one of %s\" %\n                            (format.upper(), list(cairosvg.SURFACES.keys())))\n        return surface.convert(bytestring=str(self), **kwargs)", "response": "Convert image to specified format"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert canvas to PIL image", "response": "def toPIL(self, **attribs):\n        \"\"\"\n        Convert canvas to a PIL image\n        \"\"\"\n        import PIL.Image\n        bytes = self.convert(\"png\")\n        sfile = io.BytesIO(bytes)\n        pil = PIL.Image.open(sfile)\n        return pil"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef toGIF(self, **attribs):\n        im = self.toPIL(**attribs)\n        sfile = io.BytesIO()\n        im.save(sfile, format=\"gif\")\n        return sfile.getvalue()", "response": "Convert canvas to GIF bytes\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getPixels(self):\n        array = self.toArray()\n        (width, height, depth) = array.size\n        for x in range(width):\n            for y in range(height):\n                yield Pixel(array, x, y)", "response": "Return a generator of Pixels from the current Canvas."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getP1(self):\n        return Point(self.center[0] - self.radius,\n                     self.center[1] - self.radius)", "response": "getP1 - Returns the first point in the region"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getP2(self):\n        return Point(self.center[0] + self.radius,\n                     self.center[1] + self.radius)", "response": "getP2 - Returns the right lower point of the center of the region"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts the simulation in the background showing the GUI by default.", "response": "def start_sim(self, gui=True, set_values={}, error=None):\n        \"\"\"\n        Run the simulation in the background, showing the GUI by default.\n        \"\"\"\n        self.error = error\n        if not self.is_running.is_set():\n            def loop():\n                self.need_to_stop.clear()\n                self.is_running.set()\n                for robot in self.robots:\n                    if robot.brain:\n                        self.runBrain(robot.brain)\n                count = 0\n                while not self.need_to_stop.isSet():\n                    if not self.paused.is_set():\n                        self.clock += self.sim_time\n                        for robot in self.robots:\n                            try:\n                                robot.update()\n                            except Exception as exc:\n                                self.need_to_stop.set()\n                                if error:\n                                    error.value = \"Error: %s. Now stopping simulation.\" % str(exc)\n                                else:\n                                    raise\n                    if gui:\n                        self.draw()\n                    if count % self.gui_update == 0:\n                        if \"canvas\" in set_values:\n                            set_values[\"canvas\"].value = str(self.render())\n                        if \"energy\" in set_values:\n                            if len(self.robots) > 0:\n                                set_values[\"energy\"].value = str(self.robots[0].energy)\n                    count += 1\n                    self.realsleep(self.sim_time)\n                    if self.robots[0].energy <= 0:\n                        self.need_to_stop.set()\n                self.is_running.clear()\n                for robot in self.robots:\n                    robot.stop()\n            threading.Thread(target=loop).start()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef draw(self):\n        from calysto.display import display, clear_output\n        canvas = self.render()\n        clear_output(wait=True)\n        display(canvas)", "response": "Render and draw the world and robots."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsleeps in simulated time.", "response": "def sleep(self, seconds):\n        \"\"\"\n        Sleep in simulated time.\n        \"\"\"\n        start = self.time()\n        while (self.time() - start < seconds and\n               not self.need_to_stop.is_set()):\n            self.need_to_stop.wait(self.sim_time)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef runBrain(self, f):\n        if self.error:\n            self.error.value = \"\"\n        def wrapper():\n            self.brain_running.set()\n            try:\n                f()\n            except KeyboardInterrupt:\n                # Just stop\n                pass\n            except Exception as e:\n                if self.error:\n                    self.error.value = \"<pre style='background: #fdd'>\" + traceback.format_exc() + \"</pre>\"\n                else:\n                    raise\n            finally:\n                self.brain_running.clear()\n            # Otherwise, will show error\n        threading.Thread(target=wrapper).start()", "response": "Run a brain program in the background."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addCluster(self, cx, cy, item, count, lam_percent=.25):\n        dx, dy = map(lambda v: v * lam_percent, self.psize)\n        total = 0\n        while total < count:\n            points = np.random.poisson(lam=(dx, dy), size=(count, 2))\n            for x, y in points:\n                px, py = (int(x - dx + cx), int(y - dy + cy))\n                if self.getPatch(px, py) is None:\n                    self.setPatch(px, py, item)\n                    total += 1\n                    if total == count:\n                        break", "response": "Add a Poisson cluster of count items around x y."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef forward(self, seconds, vx=5):\n        self.vx = vx\n        self.sleep(seconds)\n        self.vx = 0", "response": "Move continuously in simulator for seconds and velocity vx."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nturns a codon of 000 to 999 to a number between - 5. 0 and 5. 0.", "response": "def codon2weight(self, codon):\n        \"\"\"\n        Turn a codon of \"000\" to \"999\" to a number between\n        -5.0 and 5.0.\n        \"\"\"\n        length = len(codon)\n        retval = int(codon)\n        return retval/(10 ** (length - 1)) - 5.0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a weight between - 5 and 5 turn it into a codon eg 000 to 999", "response": "def weight2codon(self, weight, length=None):\n        \"\"\"\n        Given a weight between -5 and 5, turn it into\n        a codon, eg \"000\" to \"999\"\n        \"\"\"\n        if length is None:\n            length = self.clen\n        retval = 0\n        weight = min(max(weight + 5.0, 0), 10.0) * (10 ** (length - 1))\n        for i in range(length):\n            if i == length - 1: # last one\n                d = int(round(weight / (10 ** (length - i - 1))))\n            else:\n                d = int(weight / (10 ** (length - i - 1)))\n            weight = weight % (10 ** (length - i - 1))\n            retval += d * (10 ** (length - i - 1))\n        return (\"%0\" + str(length) + \"d\") % retval"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if list contains either values of type vtype or None.", "response": "def is_nullable_list(val, vtype):\n    \"\"\"Return True if list contains either values of type `vtype` or None.\"\"\"\n    return (isinstance(val, list) and\n            any(isinstance(v, vtype) for v in val) and\n            all((isinstance(v, vtype) or v is None) for v in val))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates and set the column width.", "response": "def column_width(self, width):\n        \"\"\"Validate and set the column width.\"\"\"\n        if isinstance(width, int):\n            if width >= 0:\n                self._column_width = width\n            else:\n                raise ValueError('Column width must be nonnegative.')\n        else:\n            raise TypeError('Column width must be a nonnegative integer.')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef indent(self, value):\n        # Explicit indent setting\n        if isinstance(value, str):\n            if value.isspace() or len(value) == 0:\n                self._indent = value\n            else:\n                raise ValueError('String indentation can only contain '\n                                 'whitespace.')\n\n        # Set indent width\n        elif isinstance(value, int):\n            if value >= 0:\n                self._indent = value * ' '\n            else:\n                raise ValueError('Indentation spacing must be nonnegative.')\n\n        else:\n            raise TypeError('Indentation must be specified by string or space '\n                            'width.')", "response": "Validate and set the indent width."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate and set the comma termination flag.", "response": "def end_comma(self, value):\n        \"\"\"Validate and set the comma termination flag.\"\"\"\n        if not isinstance(value, bool):\n            raise TypeError('end_comma attribute must be a logical type.')\n        self._end_comma = value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef index_spacing(self, value):\n        if not isinstance(value, bool):\n            raise TypeError('index_spacing attribute must be a logical type.')\n        self._index_spacing = value", "response": "Validate and set the index_spacing flag."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate and set the uppercase flag.", "response": "def uppercase(self, value):\n        \"\"\"Validate and set the uppercase flag.\"\"\"\n        if not isinstance(value, bool):\n            raise TypeError('uppercase attribute must be a logical type.')\n        self._uppercase = value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef float_format(self, value):\n        if isinstance(value, str):\n            # Duck-test the format string; raise ValueError on fail\n            '{0:{1}}'.format(1.23, value)\n\n            self._float_format = value\n        else:\n            raise TypeError('Floating point format code must be a string.')", "response": "Validate and set the upper case flag."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef logical_repr(self, value):\n        if not any(isinstance(value, t) for t in (list, tuple)):\n            raise TypeError(\"Logical representation must be a tuple with \"\n                            \"a valid true and false value.\")\n        if not len(value) == 2:\n            raise ValueError(\"List must contain two values.\")\n\n        self.false_repr = value[0]\n        self.true_repr = value[1]", "response": "Set the string representation of logical values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef false_repr(self, value):\n        if isinstance(value, str):\n            if not (value.lower().startswith('f') or\n                    value.lower().startswith('.f')):\n                raise ValueError(\"Logical false representation must start \"\n                                 \"with 'F' or '.F'.\")\n            else:\n                self._logical_repr[0] = value\n        else:\n            raise TypeError('Logical false representation must be a string.')", "response": "Validate and set the logical false representation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start_index(self, value):\n        # TODO: Validate contents?  (May want to set before adding the data.)\n        if not isinstance(value, dict):\n            raise TypeError('start_index attribute must be a dict.')\n        self._start_index = value", "response": "Validate and set the vector start index."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write(self, nml_path, force=False, sort=False):\n        nml_is_file = hasattr(nml_path, 'read')\n        if not force and not nml_is_file and os.path.isfile(nml_path):\n            raise IOError('File {0} already exists.'.format(nml_path))\n\n        nml_file = nml_path if nml_is_file else open(nml_path, 'w')\n        try:\n            self._writestream(nml_file, sort)\n        finally:\n            if not nml_is_file:\n                nml_file.close()", "response": "Write a Fortran 90 namelist file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the namelist from another partial or full namelist.", "response": "def patch(self, nml_patch):\n        \"\"\"Update the namelist from another partial or full namelist.\n\n        This is different from the intrinsic `update()` method, which replaces\n        a namelist section.  Rather, it updates the values within a section.\n        \"\"\"\n        for sec in nml_patch:\n            if sec not in self:\n                self[sec] = Namelist()\n            self[sec].update(nml_patch[sec])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an iterator that spans values with group and variable names.", "response": "def groups(self):\n        \"\"\"Return an iterator that spans values with group and variable names.\n\n        Elements of the iterator consist of a tuple containing two values.  The\n        first is internal tuple containing the current namelist group and its\n        variable name.  The second element of the returned tuple is the value\n        associated with the current group and variable.\n        \"\"\"\n        for key, value in self.items():\n            for inner_key, inner_value in value.items():\n                yield (key, inner_key), inner_value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _write_nmlgrp(self, grp_name, grp_vars, nml_file, sort=False):\n        if self._newline:\n            print(file=nml_file)\n        self._newline = True\n\n        if self.uppercase:\n            grp_name = grp_name.upper()\n\n        if sort:\n            grp_vars = Namelist(sorted(grp_vars.items(), key=lambda t: t[0]))\n\n        print('&{0}'.format(grp_name), file=nml_file)\n\n        for v_name, v_val in grp_vars.items():\n\n            v_start = grp_vars.start_index.get(v_name, None)\n\n            for v_str in self._var_strings(v_name, v_val, v_start=v_start):\n                nml_line = self.indent + '{0}'.format(v_str)\n                print(nml_line, file=nml_file)\n\n        print('/', file=nml_file)", "response": "Write namelist group to target file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _var_strings(self, v_name, v_values, v_idx=None, v_start=None):\n        if self.uppercase:\n            v_name = v_name.upper()\n\n        var_strs = []\n\n        # Parse a multidimensional array\n        if is_nullable_list(v_values, list):\n            if not v_idx:\n                v_idx = []\n\n            i_s = v_start[::-1][len(v_idx)] if v_start else None\n\n            # FIXME: We incorrectly assume 1-based indexing if it is\n            # unspecified.  This is necessary because our output method always\n            # separates the outer axes to one per line.  But we cannot do this\n            # if we don't know the first index (which we are no longer assuming\n            # to be 1-based elsewhere).  Unfortunately, the solution needs a\n            # rethink of multidimensional output.\n\n            # NOTE: Fixing this would also clean up the output of todict(),\n            # which is now incorrectly documenting unspecified indices as 1.\n\n            # For now, we will assume 1-based indexing here, just to keep\n            # things working smoothly.\n            if i_s is None:\n                i_s = 1\n\n            for idx, val in enumerate(v_values, start=i_s):\n                v_idx_new = v_idx + [idx]\n                v_strs = self._var_strings(v_name, val, v_idx=v_idx_new,\n                                           v_start=v_start)\n                var_strs.extend(v_strs)\n\n        # Parse derived type contents\n        elif isinstance(v_values, Namelist):\n            for f_name, f_vals in v_values.items():\n                v_title = '%'.join([v_name, f_name])\n\n                v_start_new = v_values.start_index.get(f_name, None)\n\n                v_strs = self._var_strings(v_title, f_vals,\n                                           v_start=v_start_new)\n                var_strs.extend(v_strs)\n\n        # Parse an array of derived types\n        elif is_nullable_list(v_values, Namelist):\n            if not v_idx:\n                v_idx = []\n\n            i_s = v_start[::-1][len(v_idx)] if v_start else 1\n\n            for idx, val in enumerate(v_values, start=i_s):\n\n                # Skip any empty elements in a list of derived types\n                if val is None:\n                    continue\n\n                v_title = v_name + '({0})'.format(idx)\n\n                v_strs = self._var_strings(v_title, val)\n                var_strs.extend(v_strs)\n\n        else:\n            use_default_start_index = False\n            if not isinstance(v_values, list):\n                v_values = [v_values]\n                use_default_start_index = False\n            else:\n                use_default_start_index = self.default_start_index is not None\n\n            # Print the index range\n\n            # TODO: Include a check for len(v_values) to determine if vector\n            if v_idx or v_start or use_default_start_index:\n                v_idx_repr = '('\n\n                if v_start or use_default_start_index:\n                    if v_start:\n                        i_s = v_start[0]\n                    else:\n                        i_s = self.default_start_index\n\n                    if i_s is None:\n                        v_idx_repr += ':'\n\n                    else:\n                        i_e = i_s + len(v_values) - 1\n\n                        if i_s == i_e:\n                            v_idx_repr += '{0}'.format(i_s)\n                        else:\n                            v_idx_repr += '{0}:{1}'.format(i_s, i_e)\n                else:\n                    v_idx_repr += ':'\n\n                if v_idx:\n                    idx_delim = ', ' if self._index_spacing else ','\n                    v_idx_repr += idx_delim\n                    v_idx_repr += idx_delim.join(str(i) for i in v_idx[::-1])\n\n                v_idx_repr += ')'\n\n            else:\n                v_idx_repr = ''\n\n            # Split output across multiple lines (if necessary)\n\n            val_strs = []\n\n            val_line = ''\n            for v_val in v_values:\n\n                v_header = v_name + v_idx_repr + ' = '\n                # Increase column width if the header exceeds this value\n                if len(self.indent + v_header) >= self.column_width:\n                    column_width = len(self.indent + v_header) + 1\n                else:\n                    column_width = self.column_width\n\n                v_width = column_width - len(self.indent + v_header)\n\n                if len(val_line) < v_width:\n                    val_line += self._f90repr(v_val) + ', '\n\n                if len(val_line) >= v_width:\n                    val_strs.append(val_line.rstrip())\n                    val_line = ''\n\n            # Append any remaining values\n            if val_line:\n                val_strs.append(val_line.rstrip())\n\n            if val_strs:\n                if self.end_comma or v_values[-1] is None:\n                    pass\n                else:\n                    val_strs[-1] = val_strs[-1][:-1]\n\n            # Complete the set of values\n            if val_strs:\n                var_strs.append('{0}{1} = {2}'\n                                ''.format(v_name, v_idx_repr,\n                                          val_strs[0]).strip())\n\n                for v_str in val_strs[1:]:\n                    var_strs.append(' ' * len(v_header) + v_str)\n\n        return var_strs", "response": "Convert namelist variable to list of fixed - width strings."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef todict(self, complex_tuple=False):\n        # TODO: Preserve ordering\n        nmldict = OrderedDict(self)\n\n        # Search for namelists within the namelist\n        # TODO: Move repeated stuff to new functions\n        for key, value in self.items():\n            if isinstance(value, Namelist):\n                nmldict[key] = value.todict(complex_tuple)\n\n            elif isinstance(value, complex) and complex_tuple:\n                nmldict[key] = [value.real, value.imag]\n                try:\n                    nmldict['_complex'].append(key)\n                except KeyError:\n                    nmldict['_complex'] = [key]\n\n            elif isinstance(value, list):\n                complex_list = False\n                for idx, entry in enumerate(value):\n                    if isinstance(entry, Namelist):\n                        nmldict[key][idx] = entry.todict(complex_tuple)\n\n                    elif isinstance(entry, complex) and complex_tuple:\n                        nmldict[key][idx] = [entry.real, entry.imag]\n                        complex_list = True\n\n                if complex_list:\n                    try:\n                        nmldict['_complex'].append(key)\n                    except KeyError:\n                        nmldict['_complex'] = [key]\n\n        # Append the start index if present\n        if self.start_index:\n            nmldict['_start_index'] = self.start_index\n\n        return nmldict", "response": "Return a dict equivalent to the namelist."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting primitive Python types to equivalent Fortran strings.", "response": "def _f90repr(self, value):\n        \"\"\"Convert primitive Python types to equivalent Fortran strings.\"\"\"\n        if isinstance(value, bool):\n            return self._f90bool(value)\n        elif isinstance(value, numbers.Integral):\n            return self._f90int(value)\n        elif isinstance(value, numbers.Real):\n            return self._f90float(value)\n        elif isinstance(value, numbers.Complex):\n            return self._f90complex(value)\n        elif isinstance(value, basestring):\n            return self._f90str(value)\n        elif value is None:\n            return ''\n        else:\n            raise ValueError('Type {0} of {1} cannot be converted to a Fortran'\n                             ' type.'.format(type(value), value))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _f90complex(self, value):\n        return '({0:{fmt}}, {1:{fmt}})'.format(value.real, value.imag,\n                                               fmt=self.float_format)", "response": "Return a Fortran 90 representation of a complex number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a Fortran 90 representation of a string.", "response": "def _f90str(self, value):\n        \"\"\"Return a Fortran 90 representation of a string.\"\"\"\n        # Replace Python quote escape sequence with Fortran\n        result = repr(str(value)).replace(\"\\\\'\", \"''\").replace('\\\\\"', '\"\"')\n\n        # Un-escape the Python backslash escape sequence\n        result = result.replace('\\\\\\\\', '\\\\')\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract the AppNexus object or list of objects from the response", "response": "def extract_data(self, page):\n        \"\"\"Extract the AppNexus object or list of objects from the response\"\"\"\n        response_keys = set(page.keys())\n        uncommon_keys = response_keys - self.common_keys\n\n        for possible_data_key in uncommon_keys:\n            element = page[possible_data_key]\n            if isinstance(element, dict):\n                return [self.representation(self.client, self.service_name,\n                                            element)]\n            if isinstance(element, list):\n                return [self.representation(self.client, self.service_name, x)\n                        for x in element]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef first(self):\n        page = self.get_page(num_elements=1)\n        data = self.extract_data(page)\n        if data:\n            return data[0]", "response": "Extract the first AppNexus object present in the response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_page(self, start_element=0, num_elements=None):\n        if num_elements is None:\n            num_elements = self.batch_size\n        specs = self.specs.copy()\n        specs.update(start_element=start_element, num_elements=num_elements)\n        return self.client.get(self.service_name, **specs)", "response": "Get a page of entries from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef size(self):\n        initial_count = self.count()\n        count_with_skip = max(0, initial_count - self._skip)\n        size = min(count_with_skip, self._limit)\n        return size", "response": "Return the number of elements of the cursor with skip and limit"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pad(s, n, p = \" \", sep = \"|\", align = \"left\"):\n    if align == \"left\":\n        return (s + (p * n))[:n] + sep\n    elif align == \"center\":\n        pos = n + len(s)/2 - n/2\n        return ((p * n) + s + (p * n))[pos:pos + n] + sep\n    elif align == \"right\":\n        return ((p * n) + s)[-n:] + sep", "response": "Returns a padded string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding two dictionaries together and merges into the first dict. Returns first dict.", "response": "def sumMerge(dict1, dict2):\n    \"\"\"\n    Adds two dictionaries together, and merges into the first, dict1.\n    Returns first dict.\n    \"\"\"\n    for key in dict2:\n        dict1[key] = list(map(lambda a,b: a + b, dict1.get(key, [0,0,0,0]), dict2[key]))\n    return dict1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef loadNetworkFromFile(filename, mode = 'pickle'):\n    if mode == 'pickle':\n        import pickle\n        fp = open(filename)\n        network = pickle.load(fp)\n        fp.close()\n        return network\n    elif mode in ['plain', 'conx']:\n        fp = open(filename, \"r\")\n        line = fp.readline()\n        network = None\n        while line:\n            if line.startswith(\"layer,\"):\n                # layer, name, size\n                temp, name, sizeStr = line.split(\",\")\n                name = name.strip()\n                size = int(sizeStr)\n                network.addLayer(name, size)\n                line = fp.readline()\n                weights = [float(f) for f in line.split()]\n                for i in range(network[name].size):\n                    network[name].weight[i] = weights[i]\n            elif line.startswith(\"connection,\"):\n                # connection, fromLayer, toLayer\n                temp, nameFrom, nameTo = line.split(\",\")\n                nameFrom, nameTo = nameFrom.strip(), nameTo.strip()\n                network.connect(nameFrom, nameTo)\n                for i in range(network[nameFrom].size):\n                    line = fp.readline()\n                    weights = [float(f) for f in line.split()]\n                    for j in range(network[nameTo].size):\n                        network[nameFrom, nameTo].weight[i][j] = weights[j]\n            elif line.startswith(\"parameter,\"):\n                temp, exp = line.split(\",\")\n                exec(exp) # network is the neural network object\n            elif line.startswith(\"network,\"):\n                temp, netType = line.split(\",\")\n                netType = netType.strip().lower()\n                if netType == \"cascornetwork\":\n                    from pyrobot.brain.cascor import CascorNetwork\n                    network = CascorNetwork()\n                elif netType == \"network\":\n                    network = Network()\n                elif netType == \"srn\":\n                    network = SRN()\n                else:\n                    raise AttributeError(\"unknown network type: '%s'\" % netType)\n            line = fp.readline()\n        return network", "response": "Load neural network from file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes a multi - dimensional array of random floats.", "response": "def ndim(n, *args, **kwargs):\n    \"\"\"\n    Makes a multi-dimensional array of random floats. (Replaces RandomArray).\n    \"\"\"\n    thunk = kwargs.get(\"thunk\", lambda: random.random())\n    if not args: \n        return [thunk() for i in range(n)]\n    A = [] \n    for i in range(n):\n        A.append( ndim(*args, thunk=thunk) ) \n    return A"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef randomArray2(size, bound):\n    if type(size) == type(1):\n        size = (size,)\n    temp = Numeric.array( ndim(*size), thunk=lambda: random.gauss(0, 1)) * (2.0 * bound)\n    return temp - bound", "response": "Returns an array initialized to random values between - bound and bound distributed in a gaussian probability distribution more\n    appropriate for a Tanh activation function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an array initialized to random values between - max and max.", "response": "def randomArray(size, bound):\n    \"\"\"\n    Returns an array initialized to random values between -max and max.\n    \"\"\"\n    if type(size) == type(1):\n        size = (size,)\n    temp = Numeric.array( ndim(*size) ) * (2.0 * bound)\n    return temp - bound"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting an array to the screen.", "response": "def displayArray(name, a, width = 0):\n    \"\"\"\n    Prints an array (any sequence of floats, really) to the screen.\n    \"\"\"\n    print(name + \": \", end=\" \")\n    cnt = 0\n    for i in a:\n        print(\"%4.2f\" % i, end=\" \")\n        if width > 0 and (cnt + 1) % width == 0:\n            print('')\n        cnt += 1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef toStringArray(name, a, width = 0):\n    string = name + \": \"\n    cnt = 0\n    for i in a:\n        string += \"%4.2f  \" % i \n        if width > 0 and (cnt + 1) % width == 0:\n            string += '\\n'\n        cnt += 1\n    return string", "response": "Returns an array as a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite an array to file pointed to by file pointer.", "response": "def writeArray(fp, a, delim = \" \", nl = 1):\n    \"\"\"\n    Writes a sequence a of floats to file pointed to by file pointer.\n    \"\"\"\n    for i in a:\n        fp.write(\"%f%s\" % (i, delim))\n    if nl:\n        fp.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef initialize(self):\n        self.randomize()\n        self.dweight = Numeric.zeros(self.size, 'f')\n        self.delta = Numeric.zeros(self.size, 'f')\n        self.wed = Numeric.zeros(self.size, 'f')\n        self.wedLast = Numeric.zeros(self.size, 'f')\n        self.target = Numeric.zeros(self.size, 'f')\n        self.error = Numeric.zeros(self.size, 'f')\n        self.activation = Numeric.zeros(self.size, 'f')\n        self.netinput = Numeric.zeros(self.size, 'f')\n        self.targetSet = 0\n        self.activationSet = 0\n        self.verify = 1\n        # layer report of stats:\n        self.pcorrect = 0\n        self.ptotal = 0\n        self.correct = 0\n        # misc:\n        self.minTarget = 0.0\n        self.maxTarget = 1.0\n        self.minActivation = 0.0\n        self.maxActivation = 1.0", "response": "Initializes the internal state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes node biases to random values in the range [ - max maxRandom )", "response": "def randomize(self, force = 0):\n        \"\"\"\n        Initialize node biases to random values in the range [-max, max].\n        \"\"\"\n        if force or not self.frozen:\n            self.weight = randomArray(self.size, self._maxRandom)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nchange the size of the layer.", "response": "def changeSize(self, newsize):\n        \"\"\"\n        Changes the size of the layer. Should only be called through\n        Network.changeLayerSize().\n        \"\"\"\n        # overwrites current data\n        if newsize <= 0:\n            raise LayerError('Layer size changed to zero.', newsize)\n        minSize = min(self.size, newsize)\n        bias = randomArray(newsize, self._maxRandom)\n        Numeric.put(bias, Numeric.arange(minSize), self.weight)\n        self.weight = bias\n        self.size = newsize\n        self.displayWidth = newsize\n        self.targetSet = 0\n        self.activationSet = 0\n        self.target = Numeric.zeros(self.size, 'f')\n        self.error = Numeric.zeros(self.size, 'f')\n        self.activation = Numeric.zeros(self.size, 'f')\n        self.dweight = Numeric.zeros(self.size, 'f')\n        self.delta = Numeric.zeros(self.size, 'f')\n        self.netinput = Numeric.zeros(self.size, 'f')\n        self.wed = Numeric.zeros(self.size, 'f')\n        self.wedLast = Numeric.zeros(self.size, 'f')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef RMSError(self):\n        tss = self.TSSError()\n        return math.sqrt(tss / self.size)", "response": "Returns Root Mean Squared Error for this layer s pattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the number of nodes within tolerance of the target.", "response": "def getCorrect(self, tolerance):\n        \"\"\"\n        Returns the number of nodes within tolerance of the target.\n        \"\"\"\n        return Numeric.add.reduce(Numeric.fabs(self.target - self.activation) < tolerance)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the winner of the specified type.", "response": "def getWinner(self, type = 'activation'):\n        \"\"\"\n        Returns the winner of the type specified {'activation' or\n        'target'}.\n        \"\"\"\n        maxvalue = -10000\n        maxpos = -1\n        ttlvalue = 0\n        if type == 'activation':\n            ttlvalue = Numeric.add.reduce(self.activation)\n            maxpos = Numeric.argmax(self.activation)\n            maxvalue = self.activation[maxpos]\n        elif type == 'target':\n            # note that backprop() resets self.targetSet flag\n            if self.verify and self.targetSet == 0:\n                raise LayerError('getWinner() called with \\'target\\' but target has not been set.', \\\n                       self.targetSet)\n            ttlvalue = Numeric.add.reduce(self.target)\n            maxpos = Numeric.argmax(self.target)\n            maxvalue = self.target[maxpos]\n        else:\n            raise LayerError('getWinner() called with unknown layer attribute.', \\\n                               type)\n        if self.size > 0:\n            avgvalue = ttlvalue / float(self.size)\n        else:\n            raise LayerError('getWinner() called for layer of size zero.', \\\n                               self.size)\n        return maxpos, maxvalue, avgvalue"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the log file with the given name.", "response": "def setLog(self, fileName, writeName=False):\n        \"\"\"\n        Opens a log file with name fileName.\n        \"\"\"\n        self.log = 1\n        self.logFile = fileName\n        self._logPtr = open(fileName, \"w\")\n        if writeName:\n            self._namePtr = open(fileName + \".name\", \"w\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclosing the log file.", "response": "def closeLog(self):\n        \"\"\"\n        Closes the log file.\n        \"\"\"\n        self._logPtr.close()\n        if self._namePtr:\n            self._namePtr.close()\n        self.log = 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite to the log file.", "response": "def writeLog(self, network):\n        \"\"\"\n        Writes to the log file.\n        \"\"\"\n        if self.log:\n            writeArray(self._logPtr, self.activation)\n            if self._namePtr:\n                self._namePtr.write(network.getWord(self.activation))\n                self._namePtr.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string representation of the object.", "response": "def toString(self):\n        \"\"\"\n        Returns a string representation of Layer instance.\n        \"\"\"\n        string = \"Layer '%s': (Kind: %s, Size: %d, Active: %d, Frozen: %d)\\n\" % (\n            self.name, self.kind, self.size, self.active, self.frozen) \n        if (self.type == 'Output'):\n            string += toStringArray('Target    ', self.target, self.displayWidth)\n        string += toStringArray('Activation', self.activation, self.displayWidth) \n        if (self.type != 'Input' and self._verbosity > 1):\n            string += toStringArray('Error     ', self.error, self.displayWidth)\n        if (self._verbosity > 4 and self.type != 'Input'):\n            string +=  toStringArray('weight    ', self.weight, self.displayWidth)\n            string +=  toStringArray('dweight   ', self.dweight, self.displayWidth)\n            string +=  toStringArray('delta     ', self.delta, self.displayWidth)\n            string +=  toStringArray('netinput  ', self.netinput, self.displayWidth)\n            string +=  toStringArray('wed       ', self.wed, self.displayWidth)\n        return string"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef display(self):\n        if self.displayWidth == 0: return\n        print(\"=============================\")\n        print(\"Layer '%s': (Kind: %s, Size: %d, Active: %d, Frozen: %d)\" % (\n            self.name, self.kind, self.size, self.active, self.frozen))\n        if (self.type == 'Output'):\n            displayArray('Target    ', self.target, self.displayWidth)\n        displayArray('Activation', self.activation, self.displayWidth)\n        if (self.type != 'Input' and self._verbosity > 1):\n            displayArray('Error     ', self.error, self.displayWidth)\n        if (self._verbosity > 4 and self.type != 'Input'):\n            print(\"    \", end=\" \"); displayArray('weight', self.weight)\n            print(\"    \", end=\" \"); displayArray('dweight', self.dweight)\n            print(\"    \", end=\" \"); displayArray('delta', self.delta)\n            print(\"    \", end=\" \"); displayArray('netinput', self.netinput)\n            print(\"    \", end=\" \"); displayArray('wed', self.wed)", "response": "Displays the Layer instance to the screen."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setActivations(self, value):\n        #if self.verify and not self.activationSet == 0:\n        #    raise LayerError, \\\n        #          ('Activation flag not reset. Activations may have been set multiple times without any intervening call to propagate().', self.activationSet)\n        Numeric.put(self.activation, Numeric.arange(len(self.activation)), value)\n        self.activationSet = 1", "response": "Sets all activations to the value of the argument."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncopying activations from the argument array into the current layer activations.", "response": "def copyActivations(self, arr, reckless = 0):\n        \"\"\"\n        Copies activations from the argument array into\n        layer activations.\n        \"\"\"\n        array = Numeric.array(arr)\n        if not len(array) == self.size:\n            raise LayerError('Mismatched activation size and layer size in call to copyActivations()', \\\n                   (len(array), self.size))\n        if self.verify and not self.activationSet == 0:\n            if not reckless:\n                raise LayerError('Activation flag not reset before call to copyActivations()', \\\n                       self.activationSet) \n        self.activation = array\n        self.activationSet = 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the value of the target attribute of the layer.", "response": "def setTargets(self, value):\n        \"\"\"\n        Sets all targets the the value of the argument. This value must be in the range [min,max].\n        \"\"\"\n        # Removed this because both propagate and backprop (via compute_error) set targets\n        #if self.verify and not self.targetSet == 0:\n        #    if not self.warningIssued:\n        #        print 'Warning! Targets have already been set and no intervening backprop() was called.', \\\n        #              (self.name, self.targetSet)\n        #        print \"(Warning will not be issued again)\"\n        #        self.warningIssued = 1\n        if value > self.maxActivation or value < self.minActivation:\n            raise LayerError('Targets for this layer are out of the proper interval.', (self.name, value))\n        Numeric.put(self.target, Numeric.arange(len(self.target)), value)\n        self.targetSet = 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copyTargets(self, arr):\n        array = Numeric.array(arr)\n        if not len(array) == self.size:\n            raise LayerError('Mismatched target size and layer size in call to copyTargets()', \\\n                   (len(array), self.size))\n        # Removed this because both propagate and backprop (via compute_error) set targets\n        #if self.verify and not self.targetSet == 0:\n        #    if not self.warningIssued:\n        #        print 'Warning! Targets have already been set and no intervening backprop() was called.', \\\n        #              (self.name, self.targetSet)\n        #        print \"(Warning will not be issued again)\"\n        #        self.warningIssued = 1\n        if Numeric.add.reduce(array < self.minTarget) or Numeric.add.reduce(array > self.maxTarget):\n            print(self.name, self.minTarget, self.maxTarget)\n            raise LayerError('Targets for this layer are out of range.', (self.name, array))\n        self.target = array\n        self.targetSet = 1", "response": "Copies the targets of the array into the self. target attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef initialize(self):\n        self.randomize()\n        self.dweight = Numeric.zeros((self.fromLayer.size, \\\n                                      self.toLayer.size), 'f')\n        self.wed = Numeric.zeros((self.fromLayer.size, \\\n                                  self.toLayer.size), 'f')\n        self.wedLast = Numeric.zeros((self.fromLayer.size, \\\n                                      self.toLayer.size), 'f')", "response": "Initializes the dweight and wed matrices."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchanges the size of the connection depending on the size of the source or destination layer.", "response": "def changeSize(self, fromLayerSize, toLayerSize):\n        \"\"\"\n        Changes the size of the connection depending on the size\n        change of either source or destination layer. Should only be\n        called through Network.changeLayerSize().\n        \"\"\"\n        if toLayerSize <= 0 or fromLayerSize <= 0:\n            raise LayerError('changeSize() called with invalid layer size.', \\\n                               (fromLayerSize, toLayerSize))\n        dweight = Numeric.zeros((fromLayerSize, toLayerSize), 'f')\n        wed = Numeric.zeros((fromLayerSize, toLayerSize), 'f')\n        wedLast = Numeric.zeros((fromLayerSize, toLayerSize), 'f')\n        weight = randomArray((fromLayerSize, toLayerSize),\n                             self.toLayer._maxRandom)\n        # copy from old to new, considering one is smaller\n        minFromLayerSize = min( fromLayerSize, self.fromLayer.size)\n        minToLayerSize = min( toLayerSize, self.toLayer.size)\n        for i in range(minFromLayerSize):\n            for j in range(minToLayerSize):\n                wed[i][j] = self.wed[i][j]\n                wedLast[i][j] = self.wedLast[i][j]\n                dweight[i][j] = self.dweight[i][j]\n                weight[i][j] = self.weight[i][j]\n        self.dweight = dweight\n        self.wed = wed\n        self.wedLast = wedLast\n        self.weight = weight"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndisplays connection information to the screen.", "response": "def display(self):\n        \"\"\"\n        Displays connection information to the screen.\n        \"\"\"\n        if self.toLayer._verbosity > 4:\n            print(\"wed: from '\" + self.fromLayer.name + \"' to '\" + self.toLayer.name +\"'\")\n            for j in range(self.toLayer.size):\n                print(self.toLayer.name, \"[\", j, \"]\", end=\" \")\n            print('')\n            for i in range(self.fromLayer.size):\n                print(self.fromLayer.name, \"[\", i, \"]\", \": \", end=\" \")\n                for j in range(self.toLayer.size):\n                    print(self.wed[i][j], end=\" \")\n                print('')\n            print('')\n            print(\"dweight: from '\" + self.fromLayer.name + \"' to '\" + self.toLayer.name +\"'\")\n            for j in range(self.toLayer.size):\n                print(self.toLayer.name, \"[\", j, \"]\", end=\" \")\n            print('')\n            for i in range(self.fromLayer.size):\n                print(self.fromLayer.name, \"[\", i, \"]\", \": \", end=\" \")\n                for j in range(self.toLayer.size):\n                    print(self.dweight[i][j], end=\" \")\n                print('')\n            print('')\n        if self.toLayer._verbosity > 2:\n            print(\"Weights: from '\" + self.fromLayer.name + \"' to '\" + self.toLayer.name +\"'\")\n            print(\"             \", end=\" \")\n            for j in range(self.toLayer.size):\n                print(self.toLayer.name, \"[\", j, \"]\", end=\" \")\n            print('')\n            for i in range(self.fromLayer.size):\n                print(self.fromLayer.name, \"[\", i, \"]\", \": \", end=\" \")\n                for j in range(self.toLayer.size):\n                    print(self.weight[i][j], end=\" \")\n                print('')\n            print('')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a string representation of the current entry.", "response": "def toString(self):\n        \"\"\"\n        Connection information as a string.\n        \"\"\"\n        string = \"\"\n        if self.toLayer._verbosity > 4:\n            string += \"wed: from '\" + self.fromLayer.name + \"' to '\" + self.toLayer.name +\"'\\n\" \n            string += \"            \"\n            for j in range(self.toLayer.size):\n                string += \"        \" + self.toLayer.name + \"[\" + str(j) + \"]\"\n            string += '\\n'\n            for i in range(self.fromLayer.size):\n                string += self.fromLayer.name+ \"[\"+ str(i)+ \"]\"+ \": \"\n                for j in range(self.toLayer.size):\n                    string += \"              \" + str(self.wed[i][j])\n                string += '\\n'\n            string += '\\n'\n            string += \"dweight: from '\" + self.fromLayer.name + \"' to '\" + self.toLayer.name +\"'\\n\"\n            string += \"            \"\n            for j in range(self.toLayer.size):\n                string += \"        \" + self.toLayer.name+ \"[\"+ str(j)+ \"]\"\n            string += '\\n'\n            for i in range(self.fromLayer.size):\n                string += self.fromLayer.name+ \"[\"+ str(i)+ \"]\"+ \": \"\n                for j in range(self.toLayer.size):\n                    string +=  \"              \" + str(self.dweight[i][j])\n                string += '\\n'\n            string += '\\n'\n        if self.toLayer._verbosity > 2:\n            string += \"Weights: from '\" + self.fromLayer.name + \"' to '\" + self.toLayer.name +\"'\\n\"\n            string += \"            \"\n            for j in range(self.toLayer.size):\n                string += \"        \"  + self.toLayer.name+ \"[\"+ str(j)+ \"]\"\n            string += '\\n'\n            for i in range(self.fromLayer.size):\n                string += self.fromLayer.name+ \"[\"+ str(i)+ \"]\"+ \": \"\n                for j in range(self.toLayer.size):\n                    string +=  \"    \" + str(self.weight[i][j])\n                string += '\\n'\n            string += '\\n'\n        return string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the cache on or updates or turns off.", "response": "def setCache(self, val = 1):\n        \"\"\" Sets cache on (or updates), or turns off \"\"\"\n        # first clear the old cached values\n        self.cacheConnections = []\n        self.cacheLayers = []\n        if val:\n            for layer in self.layers:\n                if layer.active and not layer.frozen:\n                    self.cacheLayers.append( layer )\n            for connection in self.connections:\n                if connection.active and not connection.frozen:\n                    self.cacheConnections.append( connection )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn 1 if the path is found in the given endLayer.", "response": "def path(self, startLayer, endLayer):\n        \"\"\"\n        Used in error checking with verifyArchitecture() and in prop_from().\n        \"\"\"\n        next = {startLayer.name : startLayer}\n        visited = {}\n        while next != {}:\n            for item in list(next.items()):\n                # item[0] : name, item[1] : layer reference\n                # add layer to visited dict and del from next \n                visited[item[0]] = item[1]\n                del next[item[0]]\n                for connection in self.connections:\n                    if connection.fromLayer.name == item[0]:\n                        if connection.toLayer.name == endLayer.name:\n                            return 1 # a path!\n                        elif connection.toLayer.name in next:\n                            pass # already in the list to be traversed\n                        elif connection.toLayer.name in visited:\n                            pass # already been there\n                        else:\n                            # add to next\n                            next[connection.toLayer.name] = connection.toLayer\n        return 0 # didn't find it and ran out of places to go"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the index of a reference to a layer in the list of available layers.", "response": "def getLayerIndex(self, layer):\n        \"\"\"\n        Given a reference to a layer, returns the index of that layer in\n        self.layers.\n        \"\"\"              \n        for i in range(len(self.layers)):\n            if layer == self.layers[i]: # shallow cmp\n                return i\n        return -1 # not in list"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a layer to the set.", "response": "def add(self, layer, verbosity = 0, position = None):\n        \"\"\"\n        Adds a layer. Layer verbosity is optional (default 0).\n        \"\"\"\n        layer._verbosity = verbosity\n        layer._maxRandom = self._maxRandom\n        layer.minTarget = 0.0\n        layer.maxTarget = 1.0\n        layer.minActivation = 0.0\n        layer.maxActivation = 1.0\n        if position == None:\n            self.layers.append(layer)\n        else:\n            self.layers.insert(position, layer)\n        self.layersByName[layer.name] = layer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef isConnected(self, fromName, toName):\n        for c in self.connections:\n            if (c.fromLayer.name == fromName and\n                c.toLayer.name == toName):\n                return 1\n        return 0", "response": "Is this one layer connected to another?"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connect(self, *names):\n        fromName, toName, rest = names[0], names[1], names[2:]\n        self.connectAt(fromName, toName)\n        if len(rest) != 0:\n            self.connect(toName, *rest)", "response": "Connects a list of names one to the next."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconnect two layers by instantiating an instance of Connection class. Allows a position number indicating the ordering of the connection.", "response": "def connectAt(self, fromName, toName, position = None):\n        \"\"\"\n        Connects two layers by instantiating an instance of Connection\n        class. Allows a position number, indicating the ordering of\n        the connection.\n        \"\"\"\n        fromLayer = self.getLayer(fromName)\n        toLayer   = self.getLayer(toName)\n        if self.getLayerIndex(fromLayer) >= self.getLayerIndex(toLayer):\n            raise NetworkError('Layers out of order.', (fromLayer.name, toLayer.name))\n        if (fromLayer.type == 'Output'):\n            fromLayer.type = 'Hidden'\n            fromLayer.patternReport = 0 # automatically turned off for hidden layers\n            if fromLayer.kind == 'Output':\n                fromLayer.kind = 'Hidden'\n        elif (fromLayer.type == 'Undefined'):\n            fromLayer.type = 'Input'\n            fromLayer.patternReport = 0 # automatically turned off for input layers\n            if fromLayer.kind == 'Undefined':\n                fromLayer.kind = 'Input'\n        if (toLayer.type == 'Input'):\n            raise NetworkError('Connections out of order', (fromLayer.name, toLayer.name))\n        elif (toLayer.type == 'Undefined'):\n            toLayer.type = 'Output'\n            toLayer.patternReport = 1 # automatically turned on for output layers\n            if toLayer.kind == 'Undefined':\n                toLayer.kind = 'Output'\n        if position == None:\n            self.connections.append(Connection(fromLayer, toLayer))\n        else:\n            self.connections.insert(position, Connection(fromLayer, toLayer))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addLayers(self, *arg, **kw):\n        netType = \"serial\"\n        if \"type\" in kw:\n            netType = kw[\"type\"]\n        self.addLayer('input', arg[0])\n        hiddens = []\n        if len(arg) > 3:\n            hcount = 0\n            for hidc in arg[1:-1]:\n                name = 'hidden%d' % hcount\n                self.addLayer(name, hidc)\n                hiddens.append(name)\n                hcount += 1\n        elif len(arg) == 3:\n                name = 'hidden'\n                self.addLayer(name, arg[1])\n                hiddens.append(name)\n        elif len(arg) == 2:\n            pass\n        else:\n            raise AttributeError(\"not enough layers! need >= 2\")\n        self.addLayer('output', arg[-1])\n        lastName = \"input\"\n        for name in hiddens:\n            if netType == \"parallel\":\n                self.connect('input', name)\n                self.connect(name, 'output')\n            else: # serial\n                self.connect(lastName, name)\n                lastName = name\n        if netType == \"serial\" or lastName == \"input\":\n            self.connect(lastName, \"output\")", "response": "Adds a set of layers to the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove a particular unit from a layer.", "response": "def deleteLayerNode(self, layername, nodeNum):\n        \"\"\"\n        Removes a particular unit/node from a layer.\n        \"\"\"\n        # first, construct an array of all of the weights\n        # that won't be deleted:\n        gene = []\n        for layer in self.layers:\n            if layer.type != 'Input':\n                for i in range(layer.size):\n                    if layer.name == layername and i == nodeNum:\n                        pass # skip it\n                    else:\n                        gene.append(layer.weight[i])\n        for connection in self.connections:\n            for i in range(connection.fromLayer.size):\n                for j in range(connection.toLayer.size):\n                    if ((connection.fromLayer.name == layername and i == nodeNum) or\n                        (connection.toLayer.name == layername and j == nodeNum)):\n                        pass # skip weights from/to nodeNum\n                    else:\n                        gene.append(connection.weight[i][j])\n        # now, change the size (removes rightmost node):\n        self.changeLayerSize(layername, self[layername].size - 1)\n        # and put the good weights where they go:\n        self.unArrayify(gene)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a new node to a layer and puts in new weights.", "response": "def addLayerNode(self, layerName, bias = None, weights = {}):\n        \"\"\"\n        Adds a new node to a layer, and puts in new weights. Adds node on the end.\n        Weights will be random, unless specified.\n\n        bias    = the new node's bias weight\n        weights = dict of {connectedLayerName: [weights], ...}\n\n        Example:\n        >>> net = Network() # doctest: +ELLIPSIS\n        Conx using seed: ...\n        >>> net.addLayers(2, 5, 1)\n        >>> net.addLayerNode(\"hidden\", bias = -0.12, weights = {\"input\": [1, 0], \"output\": [0]})\n        \"\"\"\n        self.changeLayerSize(layerName, self[layerName].size + 1)\n        if bias != None:\n            self[layerName].weight[-1] = bias\n        for name in list(weights.keys()):\n            for c in self.connections:\n                if c.fromLayer.name == name and c.toLayer.name == layerName:\n                    for i in range(self[name].size):\n                        self[name, layerName].weight[i][-1] = weights[name][i]\n                elif c.toLayer.name == name and c.fromLayer.name == layerName:\n                    for j in range(self[name].size):\n                        self[layerName, name].weight[-1][j] = weights[name][j]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef changeLayerSize(self, layername, newsize):\n        # for all connection from to this layer, change matrix:\n        if self.sharedWeights:\n            raise AttributeError(\"shared weights broken\")\n        for connection in self.connections:\n            if connection.fromLayer.name == layername:\n                connection.changeSize(  newsize, connection.toLayer.size )\n            if connection.toLayer.name == layername:\n                connection.changeSize( connection.fromLayer.size, newsize )\n        # then, change the actual layer size:\n        self.getLayer(layername).changeSize(newsize)", "response": "Changes the size of the specified layer. Newsize must be greater than zero."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef initialize(self):\n        print(\"Initializing '%s' weights...\" % self.name, end=\" \", file=sys.stderr)\n        if self.sharedWeights:\n            raise AttributeError(\"shared weights broken\")\n        self.count = 0\n        for connection in self.connections:\n            connection.initialize()\n        for layer in self.layers:\n            layer.initialize()", "response": "Initializes the internal state of the internal state of the internal state of the internal state."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef putActivations(self, dict):\n        for name in dict:\n            self.layersByName[name].copyActivations( dict[name] )", "response": "Put activations into their respective layers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a dictionary of layer names that map to a list of activations.", "response": "def getActivationsDict(self, nameList):\n        \"\"\"\n        Returns a dictionary of layer names that map to a list of activations.\n        \"\"\"\n        retval = {}\n        for name in nameList:\n            retval[name] = self.layersByName[name].getActivationsList()\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the seed to value.", "response": "def setSeed(self, value):\n        \"\"\"\n        Sets the seed to value.\n        \"\"\"\n        self.seed = value\n        random.seed(self.seed)\n        if self.verbosity >= 0:\n            print(\"Conx using seed:\", self.seed)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the connection instance connecting the specified ( string ) layer names.", "response": "def getConnection(self, lfrom, lto):\n        \"\"\"\n        Returns the connection instance connecting the specified (string)\n        layer names.\n        \"\"\"\n        for connection in self.connections:\n            if connection.fromLayer.name == lfrom and \\\n               connection.toLayer.name == lto:\n                return connection\n        raise NetworkError('Connection was not found.', (lfrom, lto))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setVerbosity(self, value):\n        self._verbosity = value\n        for layer in self.layers:\n            layer._verbosity = value", "response": "Sets the verbosity of the current object and all layers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the maxRandom Layer attribute for each layer to value.", "response": "def setMaxRandom(self, value):\n        \"\"\"\n        Sets the maxRandom Layer attribute for each layer to value.Specifies\n        the global range for randomly initialized values, [-max, max].\n        \"\"\"\n        self._maxRandom = value\n        for layer in self.layers:\n            layer._maxRandom = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the weights of a connection between two layers.", "response": "def getWeights(self, fromName, toName):\n        \"\"\"\n        Gets the weights of the connection between two layers (argument strings).\n        \"\"\"\n        for connection in self.connections:\n            if connection.fromLayer.name == fromName and \\\n               connection.toLayer.name == toName:\n                return connection.weight\n        raise NetworkError('Connection was not found.', (fromName, toName))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the weight of the connection between two layers.", "response": "def setWeight(self, fromName, fromPos, toName, toPos, value):\n        \"\"\"\n        Sets the weight of the connection between two layers (argument strings).\n        \"\"\"\n        for connection in self.connections:\n            if connection.fromLayer.name == fromName and \\\n               connection.toLayer.name == toName:\n                connection.weight[fromPos][toPos] = value\n                return value\n        raise NetworkError('Connection was not found.', (fromName, toName))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset self. orderedInputs to value. Specifies if inputs should be ordered and orders the inputs.", "response": "def setOrderedInputs(self, value):\n        \"\"\"\n        Sets self.orderedInputs to value. Specifies if inputs\n        should be ordered and if so orders the inputs.\n        \"\"\"\n        self.orderedInputs = value\n        if self.orderedInputs:\n            self.loadOrder = [0] * len(self.inputs)\n            for i in range(len(self.inputs)):\n                self.loadOrder[i] = i"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nverify that the arguments to setInputs and setTargets are appropriately formatted.", "response": "def verifyArguments(self, arg):\n        \"\"\"\n        Verifies that arguments to setInputs and setTargets are appropriately formatted.\n        \"\"\"\n        for l in arg:\n            if not type(l) == list and \\\n               not type(l) == type(Numeric.array([0.0])) and \\\n               not type(l) == tuple and \\\n               not type(l) == dict:\n                return 0\n            if type(l) == dict:\n                for i in l:\n                    if not type(i) == str and i not in list(self.layers.keys()):\n                        return 0\n            else:\n                for i in l:\n                    if not type(i) == float and not type(i) == int:\n                        return 0\n        return 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setInputs(self, inputs):\n        if not self.verifyArguments(inputs) and not self.patterned:\n            raise NetworkError('setInputs() requires [[...],[...],...] or [{\"layerName\": [...]}, ...].', inputs)\n        self.inputs = inputs\n        self.loadOrder = [0] * len(self.inputs)\n        for i in range(len(self.inputs)):\n            self.loadOrder[i] = i", "response": "Sets self. input to inputs."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef randomizeOrder(self):\n        flag = [0] * len(self.inputs)\n        self.loadOrder = [0] * len(self.inputs)\n        for i in range(len(self.inputs)):\n            pos = int(random.random() * len(self.inputs))\n            while (flag[pos] == 1):\n                pos = int(random.random() * len(self.inputs))\n            flag[pos] = 1\n            self.loadOrder[pos] = i", "response": "Randomizes self. loadOrder the order in which inputs set with\n        self. setInputs is presented."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncopies vector2 into vector1 being sure to replace patterns if necessary. Use self. copyActivations or self. copyTargets if necessary. Use self. copyActivations or self. copyTargets instead.", "response": "def copyVector(self, vector1, vec2, start):\n        \"\"\"\n        Copies vec2 into vector1 being sure to replace patterns if\n        necessary. Use self.copyActivations() or self.copyTargets()\n        instead.\n        \"\"\"\n        vector2 = self.replacePatterns(vec2)\n        length = min(len(vector1), len(vector2))\n        if self.verbosity > 4:\n            print(\"Copying Vector: \", vector2[start:start+length])\n        p = 0\n        for i in range(start, start + length):\n            vector1[p] = vector2[i]\n            p += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copyActivations(self, layer, vec, start = 0):\n        vector = self.replacePatterns(vec, layer.name)\n        if self.verbosity > 4:\n            print(\"Copying Activations: \", vector[start:start+layer.size])\n        layer.copyActivations(vector[start:start+layer.size])", "response": "Copies activations in vec to the specified layer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the inputs and targets for a pattern pos or returns the inputs and targets for that pattern pos or returns the inputs and targets for that pattern pos or returns the outputs and targets for that pattern pos.", "response": "def getDataCrossValidation(self, pos):\n        \"\"\"\n        Returns the inputs/targets for a pattern pos, or assumes that\n        the layers are called input and output and uses the lists\n        in self.inputs and self.targets.\n        \"\"\"\n        set = {}\n        if type(self.inputs[pos]) == dict:\n            set.update(self.inputs[pos])\n        else:\n            set[\"input\"] = self.inputs[pos]\n        if self.targets:\n            if type(self.targets[pos]) == dict:\n                set.update(self.targets[pos])\n            else:\n                set[\"output\"] = self.targets[pos]\n        return set"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a data map from a vector.", "response": "def getDataMap(self, intype, pos, name, offset = 0):\n        \"\"\"\n        Hook defined to lookup a name, and get it from a vector.\n        Can be overloaded to get it from somewhere else.\n        \"\"\"\n        if intype == \"input\":\n            vector = self.inputs\n        elif intype == \"target\":\n            vector = self.targets\n        else:\n            raise AttributeError(\"invalid map type '%s'\" % intype)\n        return vector[pos][offset:offset+self[name].size]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn dictionary with input and target given pos.", "response": "def getData(self, pos):\n        \"\"\"\n        Returns dictionary with input and target given pos. \n        \"\"\"\n        retval = {}\n        if pos >= len(self.inputs):\n            raise IndexError('getData() pattern beyond range.', pos)\n        if self.verbosity >= 1: print(\"Getting input\", pos, \"...\")\n        if len(self.inputMap) == 0:\n            if type(self.inputs[pos]) == dict: # allow inputs to be a dict\n                retval.update(self.inputs[pos])\n            else:\n                retval[self.layers[0].name] = self.inputs[pos]\n        else: # mapInput set manually\n            for vals in self.inputMap:\n                (name, offset) = vals\n                retval[name] = self.getDataMap(\"input\", pos, name, offset)\n        if self.verbosity > 1: print(\"Loading target\", pos, \"...\")\n        if len(self.targets) == 0:\n            pass # ok, no targets\n        elif len(self.targetMap) == 0:\n            if type(self.targets[pos]) == dict: # allow targets to be a dict\n                retval.update(self.targets[pos])\n            else:\n                retval[self.layers[len(self.layers)-1].name] = self.targets[pos]\n        else: # set manually\n            for vals in self.targetMap:\n                (name, offset) = vals\n                retval[name] = self.getDataMap(\"target\", pos, name, offset)\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef verifyArchitecture(self):\n        if len(self.cacheLayers) != 0 or len(self.cacheConnections) != 0: return\n        # flags for layer type tests\n        hiddenInput = 1\n        hiddenOutput = 1       \n        outputLayerFlag = 1  \n        inputLayerFlag = 1\n        # must have layers and connections\n        if len(self.layers) == 0:\n            raise NetworkError('No network layers.', \\\n                                 self.layers)\n        if len(self.connections) == 0:\n            raise NetworkError('No network connections.', \\\n                                 self.connections)\n        # layers should not have the same name\n        for x, y in [(x, y) for x in range(len(self.layers)) for y in range(len(self.layers))]:\n            if x == y:\n                pass # same layer so same name\n            else:\n                # different layers same name\n                if self.layers[x].name == self.layers[y].name:\n                    raise NetworkError('Two layers have the same name.', (x,y))\n        # no multiple connections between layers\n        for x, y in [(x,y) for x in range(len(self.connections)) for y in range(len(self.connections))]:\n            if x == y:\n                pass # same connection\n            else:\n                # multiple connections between fromLayer and toLayer\n                if self.connections[x].fromLayer.name == self.connections[y].fromLayer.name and \\\n                   self.connections[x].toLayer.name == self.connections[y].toLayer.name:\n                    raise NetworkError('Multiple connections between two layers.', \\\n                                         (self.connections[x].fromLayer.name, \\\n                                          self.connections[x].toLayer.name))\n        # layer type tests\n        for layer in self.layers:\n            # no undefined layers\n            if layer.type == 'Undefined':\n                raise NetworkError('There is an unconnected layer.', layer.name)\n            elif layer.type == 'Input':\n                for connection in self.connections:\n                    # input layers must have outgoing connections \n                    if connection.fromLayer.name == layer.name:\n                        inputLayerFlag = 0\n                    # input layers must have no incoming connections\n                    if connection.toLayer.name == layer.name:\n                        raise NetworkError('Layer has type \\'Input\\' and an incoming connection.', layer.name)\n                if inputLayerFlag:\n                    raise NetworkError('Layer has type \\'Input\\' but no outgoing connections', layer.name)\n            elif layer.type == 'Output':\n                for connection in self.connections:\n                    # output layers must have no outgoing connections`\n                    if connection.fromLayer.name == layer.name:\n                        raise NetworkError('Layer has type \\'Output\\' and an outgoing connections.',layer.name)\n                    # output layers must have an incoming connection\n                    if connection.toLayer.name == layer.name:\n                        outputLayerFlag = 0\n                if outputLayerFlag:\n                    raise NetworkError('Layer has type \\'Output\\' and no incoming connections.', layer.name)           \n            elif layer.type == 'Hidden':\n                for connection in self.connections:\n                    # hidden layers must have incoming and outgoing connections.\n                    if connection.toLayer.name == layer.name:\n                        hiddenInput = 0\n                    if connection.fromLayer.name == layer.name:\n                        hiddenOutput = 0\n                if hiddenInput or hiddenOutput:\n                    raise NetworkError('Layer has type \\'Hidden\\' but does not have both input and output connections.',\\\n                           layer.name)\n            else:\n                raise LayerError('Unknown layer encountered in verifyArchitecture().', layer.name)\n        # network should not have unconnected sub networks\n        # every input layer should have a path to every output layer\n        for inLayer in self.layers:\n            if inLayer.type == 'Input':\n                for outLayer in self.layers:\n                    if outLayer.type == 'Output':\n                        if not self.path(inLayer, outLayer):\n                            raise NetworkError('Network contains disconnected sub networks.', \\\n                                                 (inLayer.name, outLayer.name))\n        # network should not have directed cycles\n        for layer in self.layers:\n            if self.path(layer, layer):\n                raise NetworkError('Network contains a cycle.', layer.name)", "response": "Verify architecture of the current network."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef verifyInputs(self):\n        for layer in self.layers:\n            if (layer.verify and\n                layer.type == 'Input' and\n                layer.kind != 'Context' and\n                layer.active and\n                not layer.activationSet):\n                raise LayerError(\"Inputs are not set and verifyInputs() was called on layer '%s'.\" % layer.name)\n            else:\n                layer.resetActivationFlag()", "response": "Verify that all inputs have been set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nverifying that the network targets have been set.", "response": "def verifyTargets(self):\n        \"\"\"\n        Used in backprop() to verify that the network targets have\n        been set.\n        \"\"\"\n        for layer in self.layers:\n            if layer.verify and layer.type == 'Output' and layer.active and not layer.targetSet:\n                raise LayerError('Targets are not set and verifyTargets() was called.',\\\n                                   (layer.name, layer.type))\n            else:\n                layer.resetTargetFlag()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef RMSError(self):\n        tss = 0.0\n        size = 0\n        for layer in self.layers:\n            if layer.type == 'Output':\n                tss += layer.TSSError()\n                size += layer.size\n        return math.sqrt( tss / size )", "response": "Returns Root Mean Squared Error for all output layers in this network."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntraining the network on the dataset till a stopping condition is met.", "response": "def train(self, sweeps=None, cont=0):\n        \"\"\"\n        Trains the network on the dataset till a stopping condition is\n        met. This stopping condition can be a limiting epoch or a percentage correct requirement.\n        \"\"\"\n        # check architecture\n        self.complete = 0\n        self.verifyArchitecture()\n        tssErr = 0.0; rmsErr = 0.0; totalCorrect = 0; totalCount = 1; totalPCorrect = {}\n        if not cont: # starting afresh\n            self.resetFlags()\n            self.epoch = 0\n            self.reportStart()\n            self.resetCount = 1\n            self.epoch = 1\n            self.lastLowestTSSError = sys.maxsize # some maximum value (not all pythons have Infinity)\n            if sweeps != None:\n                self.resetEpoch = sweeps\n        else:\n            if sweeps != None:\n                self.resetEpoch = self.epoch + sweeps - 1\n        while self.doWhile(totalCount, totalCorrect):\n            (tssErr, totalCorrect, totalCount, totalPCorrect) = self.sweep()\n            self.complete = 1\n            if totalCount != 0:\n                rmsErr = math.sqrt(tssErr / totalCount)\n            else:\n                self.Print(\"Warning: sweep didn't do anything!\")\n            if self.epoch % self.reportRate == 0:\n                self.reportEpoch(self.epoch, tssErr, totalCorrect, totalCount, rmsErr, totalPCorrect)\n                if len(self.crossValidationCorpus) > 0 or self.autoCrossValidation:\n                    (tssCVErr, totalCVCorrect, totalCVCount, totalCVPCorrect) = self.sweepCrossValidation()\n                    rmsCVErr = math.sqrt(tssCVErr / totalCVCount)\n                    self.Print(\"CV    #%6d | TSS Error: %.4f | Correct: %.4f | RMS Error: %.4f\" % \\\n                               (self.epoch, tssCVErr, totalCVCorrect * 1.0 / totalCVCount, rmsCVErr))\n                    if self.autoSaveWeightsFile != None and tssCVErr < self.lastLowestTSSError:\n                        self.lastLowestTSSError = tssCVErr\n                        self.saveWeights(self.autoSaveWeightsFile, mode = self.autoSaveWeightsFileFormat)\n                        self.Print(\"auto saving weights to '%s'...\" % self.lastAutoSaveWeightsFilename)\n                    if self.autoSaveNetworkFile != None:\n                        self.saveNetwork(self.autoSaveNetworkFile, mode = self.autoSaveNetworkFileFormat)\n                        self.Print(\"auto saving network to '%s'...\" % self.lastAutoSaveNetworkFilename)\n                    if totalCVCorrect * 1.0 / totalCVCount >= self.stopPercent and self.useCrossValidationToStop:\n                        self.epoch += 1\n                        break\n            if self.resetEpoch == self.epoch:\n                if self.resetCount == self.resetLimit:\n                    self.Print(\"Reset limit reached; ending without reaching goal\")\n                    self.epoch += 1\n                    self.complete = 0\n                    break\n                self.resetCount += 1\n                self.Print(\"RESET! resetEpoch reached; starting over...\")\n                self.initialize()\n                tssErr = 0.0; rmsErr = 0.0; self.epoch = 1; totalCorrect = 0; totalPCorrect = {}\n                continue\n            self.epoch += 1\n        if totalCount > 0:\n            self.reportFinal(self.epoch, tssErr, totalCorrect, totalCount, rmsErr, totalPCorrect)\n            if len(self.crossValidationCorpus) > 0 or self.autoCrossValidation:\n                (tssCVErr, totalCVCorrect, totalCVCount, totalCVPCorrect) = self.sweepCrossValidation()\n                rmsCVErr = math.sqrt(tssCVErr / totalCVCount)\n                self.Print(\"CV    #%6d | TSS Error: %.4f | Correct: %.4f | RMS Error: %.4f\" % \\\n                           (self.epoch-1, tssCVErr, totalCVCorrect * 1.0 / totalCVCount, rmsCVErr))\n                if self.autoSaveWeightsFile != None and tssCVErr < self.lastLowestTSSError:\n                    self.lastLowestTSSError = tssCVErr\n                    self.saveWeights(self.autoSaveWeightsFile, mode = self.autoSaveWeightsFileFormat)\n                    self.Print(\"auto saving weights to '%s'...\" % self.lastAutoSaveWeightsFilename)\n                if self.autoSaveNetworkFile != None:\n                    self.saveNetwork(self.autoSaveNetworkFile, mode = self.autoSaveNetworkFileFormat)\n                    self.Print(\"auto saving network to '%s'...\" % self.lastAutoSaveNetworkFilename)\n        else:\n            print(\"Final: nothing done\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef step(self, **args):\n        if self.verbosity > 0:\n            print(\"Network.step() called with:\", args)\n        # First, copy the values into either activations or targets:\n        retargs = self.preStep(**args)\n        if retargs: args = retargs # replace the args\n        # Propagate activation through network:\n        self.propagate(**args)\n        retargs = self.postPropagate(**args)\n        if retargs: args = retargs # replace the args\n        # Next, take care of any Auto-association, and copy\n        # activations to targets\n        for aa in self.association:\n            (inName, outName) = aa\n            inLayer = self.getLayer(inName)\n            if inLayer.type not in ['Input', \"Hidden\"]:\n                raise LayerError('Associated input layer not type \\'Input\\' or \\'Hidden\\'.', \\\n                                   inLayer.type)\n            outLayer = self.getLayer(outName)\n            if not outLayer.type == 'Output':\n                raise LayerError('Associated output layer not type \\'Output\\'.', \\\n                                   outLayer.type)\n            outLayer.copyTargets(inLayer.activation)\n        # Compute error, and back prop it:\n        retargs = self.preBackprop(**args)\n        if retargs: args = retargs # replace the args\n        (error, correct, total, pcorrect) = self.backprop(**args) # compute_error()\n        if self.verbosity > 2 or self.interactive:\n            self.display()\n            if self.interactive:\n                self.prompt()\n        retargs = self.postBackprop(**args)\n        if retargs: args = retargs # replace the args\n        # if learning is true, and need to update weights here:\n        if self.learning and not self.batch:\n            self.change_weights() # else change weights in sweep\n        retargs = self.postStep(**args)\n        if retargs: args = retargs # replace the args\n        self.reportPattern()\n        return (error, correct, total, pcorrect)", "response": "Performs a single step of the network."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sweepCrossValidation(self):\n        # get learning value and then turn it off\n        oldLearning = self.learning\n        self.learning = 0\n        tssError = 0.0; totalCorrect = 0; totalCount = 0; totalPCorrect = {}\n        self._cv = True # in cross validation\n        if self.autoCrossValidation:\n            for i in range(len(self.inputs)):\n                set = self.getDataCrossValidation(i)\n                self._sweeping = 1\n                (error, correct, total, pcorrect) = self.step( **set )\n                self._sweeping = 0\n                if self.crossValidationReportLayers != []:\n                    (error, correct, total, pcorrect) = self.getError( *self.crossValidationReportLayers )\n                tssError += error\n                totalCorrect += correct\n                totalCount += total\n                sumMerge(totalPCorrect, pcorrect)\n        else:\n            for set in self.crossValidationCorpus:\n                self._sweeping = 1\n                (error, correct, total, pcorrect) = self.step( **set )\n                self._sweeping = 0\n                if self.crossValidationReportLayers != []:\n                    (error, correct, total, pcorrect) = self.getError( *self.crossValidationReportLayers )\n                tssError += error\n                totalCorrect += correct\n                totalCount += total\n                sumMerge(totalPCorrect, pcorrect)\n        self.learning = oldLearning\n        self._cv = False\n        return (tssError, totalCorrect, totalCount, totalPCorrect)", "response": "This method will sweep through each of the crossvalidation input and target dictionaries and return the error total correct total totalPCorrect total."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the number of incoming weights including bias. Assumes fully connected.", "response": "def numConnects(self, layerName):\n        \"\"\" Number of incoming weights, including bias. Assumes fully connected. \"\"\"\n        count = 0\n        if self[layerName].active: \n            count += 1 # 1 = bias\n            for connection in self.connections:\n                if connection.active and connection.fromLayer.active and connection.toLayer.name == layerName:\n                    count += connection.fromLayer.size\n        return count"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prop_from(self, startLayers):\n        if self.verbosity > 2: print(\"Partially propagating network:\")\n        # find all the layers involved in the propagation\n        propagateLayers = []\n        # propagateLayers should not include startLayers (no loops)\n        for startLayer in startLayers:\n            for layer in self.layers:\n                if self.path(startLayer, layer):\n                    propagateLayers.append(layer)\n        for layer in propagateLayers:\n            if layer.active: \n                layer.netinput = (layer.weight).copy() \n        for layer in propagateLayers:\n            if layer.active:\n                for connection in self.connections:\n                    if connection.active and connection.toLayer.name == layer.name:\n                        connection.toLayer.netinput = connection.toLayer.netinput + \\\n                                                      Numeric.matrixmultiply(connection.fromLayer.activation,\\\n                                                                             connection.weight) # propagate!\n                if layer.type != 'Input':\n                    layer.activation = self.activationFunction(layer.netinput)\n        for layer in propagateLayers:\n            if layer.log and layer.active:\n                layer.writeLog(self)", "response": "Propagate the network from the startLayers."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npropagating activation through the network. Optionally takes input layer names as keywords and their associated activations and then returns the output layer s activation. Optionally takes input layer names as keywords and their associated activations and then returns the output layer s activation.", "response": "def propagate(self, **args):\n        \"\"\"\n        Propagates activation through the network. Optionally, takes input layer names\n        as keywords, and their associated activations. If input layer(s) are given, then\n        propagate() will return the output layer's activation. If there is more than\n        one output layer, then a dictionary is returned.\n\n        Examples:\n\n        >>> net = Network() # doctest: +ELLIPSIS\n        Conx using seed: ...\n        >>> net.addLayers(2, 5, 1)\n        >>> len(net.propagate(input = [0, .5]))\n        1\n        \"\"\"\n        self.prePropagate(**args)\n        for key in args:\n            layer = self.getLayer(key)\n            if layer.kind == 'Input':\n                if self[key].verify and not self[key].activationSet == 0: \n                    raise AttributeError(\"attempt to set activations on input layer '%s' without reset\" % key)\n                self.copyActivations(layer, args[key])\n            elif layer.kind == 'Context':\n                self.copyActivations(layer, args[key])\n            elif layer.kind == 'Output' and len(args[key]) == layer.size: # in case you expect propagate to handle the outputs\n                self.copyTargets(layer, args[key])\n        self.verifyInputs() # better have inputs set\n        if self.verbosity > 2: print(\"Propagate Network '\" + self.name + \"':\")\n        # initialize netinput:\n        for layer in self.layers:\n            if layer.type != 'Input' and layer.active:\n                layer.netinput = (layer.weight).copy() \n        # for each connection, in order:\n        for layer in self.layers:\n            if layer.active:\n                for connection in self.connections:\n                    if (connection.toLayer.name == layer.name\n                        and connection.fromLayer.active\n                        and connection.active):\n\n                        a = connection.fromLayer.activation\n                        w = connection.weight\n                        m = Numeric.matrixmultiply(a, w)\n                        ni = m + connection.toLayer.netinput\n\n                        connection.toLayer.netinput = ni\n\n                        #connection.toLayer.netinput = \\\n                        #    (connection.toLayer.netinput + \n                        #     Numeric.matrixmultiply(connection.fromLayer.activation,\n                        #                            connection.weight)) # propagate!\n\n                if layer.type != 'Input':\n                    layer.activation = self.activationFunction(layer.netinput)\n        for layer in self.layers:\n            if layer.log and layer.active:\n                layer.writeLog(self)\n        self.count += 1 # counts number of times propagate() is called\n        if len(args) != 0:\n            dict = {}\n            for layer in self.layers:\n                if layer.type == \"Output\":\n                    dict[layer.name] = layer.activation.copy()\n            if len(dict) == 1:\n                return dict[list(dict.keys())[0]]\n            else:\n                return dict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef propagateTo(self, toLayer, **args):\n        for layerName in args:\n            self[layerName].activationSet = 0 # force it to be ok\n            self[layerName].copyActivations(args[layerName])\n        # init toLayer:\n        self[toLayer].netinput = (self[toLayer].weight).copy() \n        # for each connection, in order:\n        for connection in self.connections:\n            if connection.active and connection.toLayer.name == toLayer and connection.fromLayer.active:\n                connection.toLayer.netinput = connection.toLayer.netinput + \\\n                                              Numeric.matrixmultiply(connection.fromLayer.activation,\\\n                                                                     connection.weight) # propagate!\n                if self[toLayer].type != 'Input':\n                    self[toLayer].activation = self.activationFunction(self[toLayer].netinput)\n        return self[toLayer].activation.copy()", "response": "Propagates activation to a layer. Optionally takes input layer names\n        as keywords and their associated activations. Returns the toLayer s activation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetermining the activation function for a given net input.", "response": "def activationFunctionASIG(self, x):\n        \"\"\"\n        Determine the activation of a node based on that nodes net input.\n        \"\"\"\n        def act(v):\n            if   v < -15.0: return 0.0\n            elif v >  15.0: return 1.0\n            else: return 1.0 / (1.0 + Numeric.exp(-v))\n        return Numeric.array(list(map(act, x)), 'f')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef useTanhActivationFunction(self):\n        self.activationFunction = self.activationFunctionTANH\n        self.ACTPRIME = self.ACTPRIMETANH\n        self.actDeriv = self.actDerivTANH\n        for layer in self:\n            layer.minTarget, layer.minActivation = -1.7159, -1.7159 \n            layer.maxTarget, layer.maxActivation = 1.7159, 1.7159", "response": "Change the network to use the hyperbolic tangent activation function for all layers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef useFahlmanActivationFunction(self):\n        self.activationFunction = self.activationFunctionFahlman\n        self.ACTPRIME = self.ACTPRIME_Fahlman\n        self.actDeriv = self.actDerivFahlman\n        for layer in self:\n            layer.minTarget, layer.minActivation = -0.5, -0.5 \n            layer.maxTarget, layer.maxActivation = 0.5, 0.5", "response": "Change the network to use Fahlman s default activation function for all layers."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef backprop(self, **args):\n        retval = self.compute_error(**args)\n        if self.learning:\n            self.compute_wed()\n        return retval", "response": "Compute error and wed for back propagation of error."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nchange the weights according to the error values calculated during backprop.", "response": "def change_weights(self):\n        \"\"\"\n        Changes the weights according to the error values calculated\n        during backprop(). Learning must be set.\n        \"\"\"\n        dw_count, dw_sum = 0, 0.0\n        if len(self.cacheLayers) != 0:\n            changeLayers = self.cacheLayers\n        else:\n            changeLayers = self.layers\n        for layer in changeLayers:\n            if layer.active and layer.type != 'Input':\n                if not layer.frozen:\n                    if self._quickprop or self.splitEpsilon:\n                        layer.dweight = self.deltaWeight(self.epsilon,\n                                                         layer.wed,\n                                                         self.momentum,\n                                                         layer.dweight,\n                                                         layer.wedLast,\n                                                         layer.weight,\n                                                         self.numConnects(layer.name))\n                    else:\n                        layer.dweight = self.epsilon * layer.wed + self.momentum * layer.dweight\n                    layer.weight += layer.dweight\n                    #print \"layer.wed = \",layer.wed\n                    #print \"layer.weight = \",layer.weight,\" layer.dweight = \",layer.dweight\n                    layer.wedLast = Numeric.array(layer.wed) # make copy\n                    if self._quickprop:\n                        layer.wed = layer.weight * self.decay # reset to last weight, with decay\n                    else:\n                        layer.wed = layer.wed * 0.0 # keep same numeric type, just zero it\n                    dw_count += len(layer.dweight)\n                    dw_sum += Numeric.add.reduce(abs(layer.dweight))\n        if len(self.cacheConnections) != 0:\n            changeConnections = self.cacheConnections\n        else:\n            changeConnections = self.connections\n        for connection in changeConnections:\n            if (connection.active\n                and connection.fromLayer.active\n                and connection.toLayer.active\n                and not connection.frozen):\n                toLayer = connection.toLayer\n                if self._quickprop or self.splitEpsilon:\n                    # doing it one vector at a time, to match layer bias training (a quickprop abstraction)\n                    for i in range(len(connection.dweight)):\n                        Numeric.put(connection.dweight[i],\n                                    Numeric.arange(len(connection.dweight[i])),\n                                    self.deltaWeight(self.epsilon,\n                                                     connection.wed[i],\n                                                     self.momentum,\n                                                     connection.dweight[i],\n                                                     connection.wedLast[i],\n                                                     connection.weight[i],\n                                                     self.numConnects(connection.toLayer.name)))\n                else:\n                    connection.dweight = self.epsilon * connection.wed + self.momentum * connection.dweight\n                connection.weight += connection.dweight\n                #print \"connection.wed = \",connection.wed\n                #print \"connection.weight = \",connection.weight,\" connection.dweight = \",connection.dweight\n                # reset values:\n                connection.wedLast = Numeric.array(connection.wed) # make copy\n                if self._quickprop:\n                    connection.wed = connection.weight * self.decay \n                else:\n                    connection.wed = connection.wed * 0.0 # keeps the same Numeric type, but makes it zero\n                # get some stats\n                dw_count += Numeric.multiply.reduce(connection.dweight.shape)\n                dw_sum += Numeric.add.reduce(Numeric.add.reduce(abs(connection.dweight)))\n        if self.verbosity >= 1:\n            print(\"WEIGHTS CHANGED\")\n            if self.verbosity > 2:\n                self.display()\n        return (dw_count, dw_sum)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nuse a hyperbolic arctan on the error slightly exaggerates the actual error non-linearly. Return t - a to just use the difference. t - target vector a - activation vector", "response": "def errorFunction(self, t, a):\n        \"\"\"\n        Using a hyperbolic arctan on the error slightly exaggerates\n        the actual error non-linearly. Return t - a to just use the difference.\n        t - target vector\n        a - activation vector\n        \"\"\"\n        def difference(v):\n            if not self.hyperbolicError:\n                #if -0.1 < v < 0.1: return 0.0\n                #else:\n                return v\n            else:\n                if   v < -0.9999999: return -17.0\n                elif v >  0.9999999: return  17.0\n                else: return math.log( (1.0 + v) / (1.0 - v) )\n                #else: return Numeric.arctanh(v) # half that above\n        return list(map(difference, t - a))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes error computation. Calculates error for output and hidden layers and initializes hidden layer error to zero.", "response": "def ce_init(self):\n        \"\"\"\n        Initializes error computation. Calculates error for output\n        layers and initializes hidden layer error to zero.\n        \"\"\"\n        retval = 0.0; correct = 0; totalCount = 0\n        for layer in self.layers:\n            if layer.active:\n                if layer.type == 'Output':\n                    layer.error = self.errorFunction(layer.target, layer.activation) \n                    totalCount += layer.size\n                    retval += Numeric.add.reduce((layer.target - layer.activation) ** 2)\n                    correct += Numeric.add.reduce(Numeric.fabs(layer.target - layer.activation) < self.tolerance)\n                elif (layer.type == 'Hidden'):\n                    for i in range(layer.size): # do it this way so you don't break reference links\n                        layer.error[i] = 0.0\n        return (retval, correct, totalCount)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compute_error(self, **args):\n        for key in args:\n            layer = self.getLayer(key)\n            if layer.kind == 'Output':\n                self.copyTargets(layer, args[key])\n        self.verifyTargets() # better have targets set\n        error, correct, total = self.ce_init()\n        pcorrect = {}\n        # go backwards through each proj but don't redo output errors!\n        if len(self.cacheConnections) != 0:\n            changeConnections = self.cacheConnections\n        else:\n            changeConnections = self.connections\n        for connect in reverse(changeConnections):\n            if connect.active and connect.toLayer.active and connect.fromLayer.active:\n                connect.toLayer.delta = (connect.toLayer.error *\n                                         (self.ACTPRIME(connect.toLayer.activation)))\n                connect.fromLayer.error = connect.fromLayer.error + \\\n                                          Numeric.matrixmultiply(connect.weight, connect.toLayer.delta)\n        # now all errors are set on all layers!\n        pcorrect = self.getLayerErrors()\n        return (error, correct, total, pcorrect)", "response": "Compute error for all non - output layers backwards through all non - output layers and all non - output layers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the weight error derivative for all connections in self. connections starting with the last connection.", "response": "def compute_wed(self):\n        \"\"\"\n        Computes weight error derivative for all connections in\n        self.connections starting with the last connection.\n        \"\"\"\n        if len(self.cacheConnections) != 0:\n            changeConnections = self.cacheConnections\n        else:\n            changeConnections = self.connections            \n        for connect in reverse(changeConnections):\n            if connect.active and connect.fromLayer.active and connect.toLayer.active:\n                connect.wed = connect.wed + Numeric.outerproduct(connect.fromLayer.activation,\n                                                                 connect.toLayer.delta)\n        if len(self.cacheLayers) != 0:\n            changeLayers = self.cacheLayers\n        else:\n            changeLayers = self.layers\n        for layer in changeLayers:\n            if layer.active:\n                layer.wed = layer.wed + layer.delta"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the network layers as a string.", "response": "def toString(self):\n        \"\"\"\n        Returns the network layers as a string.\n        \"\"\"\n        output = \"\"\n        for layer in reverse(self.layers):\n            output += layer.toString()\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndisplaying the network to the screen.", "response": "def display(self):\n        \"\"\"\n        Displays the network to the screen.\n        \"\"\"\n        print(\"Display network '\" + self.name + \"':\")\n        size = list(range(len(self.layers)))\n        size.reverse()\n        for i in size:\n            if self.layers[i].active:\n                self.layers[i].display()\n                if self.patterned and self.layers[i].type != 'Hidden':\n                    targetWord, diff = self.getWord( self.layers[i].target, returnDiff = 1)\n                    if self.layers[i].kind == 'Output':\n                        if targetWord == None:\n                            print(\"Target Pattern   = %s\" % \"No match\")\n                        else:\n                            if diff == 0.0:\n                                print(\"Target Pattern   = '%s'; (exact)\" % targetWord)\n                            else:\n                                print(\"Target Pattern   = '%s'; Match difference = %f)\" % (targetWord, diff))\n                    actWord, diff = self.getWord( self.layers[i].activation, returnDiff = 1 )\n                    if (self.layers[i].kind == 'Input' or self.layers[i].kind == 'Output'):\n                        if actWord == None:\n                            print(\"Matching Pattern = %s\" % \"No match\")\n                        else:\n                            if diff == 0.0:\n                                print(\"Matching Pattern = '%s'; (exact)\" % actWord)\n                            else:\n                                print(\"Matching Pattern = '%s'; Match difference = %f\" % (actWord, diff))\n                if self.verbosity >= 1:\n                    weights = list(range(len(self.connections)))\n                    weights.reverse()\n                    for j in weights:\n                        if self.connections[j].toLayer.name == self.layers[i].name:\n                            self.connections[j].display()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an array of node bias values and connection weights for use in a GA.", "response": "def arrayify(self):\n        \"\"\"\n        Returns an array of node bias values and connection weights\n        for use in a GA.\n        \"\"\"\n        gene = []\n        for layer in self.layers:\n            if layer.type != 'Input':\n                for i in range(layer.size):\n                    gene.append( layer.weight[i] )\n        for connection in self.connections:\n            for i in range(connection.fromLayer.size):\n                for j in range(connection.toLayer.size):\n                    gene.append( connection.weight[i][j] )\n        return gene"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncopying the gene bias values and weights to network bias values and weights.", "response": "def unArrayify(self, gene):\n        \"\"\"\n        Copies gene bias values and weights to network bias values and\n        weights.\n        \"\"\"\n        g = 0\n        # if gene is too small an IndexError will be thrown\n        for layer in self.layers:\n            if layer.type != 'Input':\n                for i in range(layer.size):\n                    layer.weight[i] = float( gene[g])\n                    g += 1\n        for connection in self.connections:\n            for i in range(connection.fromLayer.size):\n                for j in range(connection.toLayer.size):\n                    connection.weight[i][j] = gene[g]\n                    g += 1\n        # if gene is too long we may have a problem\n        if len(gene) > g:\n            raise IndexError('Argument to unArrayify is too long.', len(gene))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave weighted values to a file.", "response": "def saveWeightsToFile(self, filename, mode='pickle', counter=None):\n        \"\"\"\n        Deprecated. Use saveWeights instead.\n        \"\"\"\n        self.saveWeights(filename, mode, counter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef saveWeights(self, filename, mode='pickle', counter=None):\n        # modes: pickle/conx, plain, tlearn\n        if \"?\" in filename: # replace ? pattern in filename with epoch number\n            import re\n            char = \"?\"\n            match = re.search(re.escape(char) + \"+\", filename)\n            if match:\n                num = self.epoch\n                if counter != None:\n                    num = counter\n                elif self.totalEpoch != 0: # use a total epoch, if one:\n                    num = self.totalEpoch\n                fstring = \"%%0%dd\" % len(match.group())\n                filename = filename[:match.start()] + \\\n                           fstring % self.epoch + \\\n                           filename[match.end():]\n                self.lastAutoSaveWeightsFilename = filename\n        if mode == 'pickle':\n            mylist = self.arrayify()\n            import pickle\n            fp = open(filename, \"w\")\n            pickle.dump(mylist, fp)\n            fp.close()\n        elif mode in ['plain', 'conx']:\n            fp = open(filename, \"w\")\n            fp.write(\"# Biases\\n\")\n            for layer in self.layers:\n                if layer.type != 'Input':\n                    fp.write(\"# Layer: \" + layer.name + \"\\n\")\n                    for i in range(layer.size):\n                        fp.write(\"%f \" % layer.weight[i] )\n                    fp.write(\"\\n\")\n            fp.write(\"# Weights\\n\")\n            for connection in self.connections:\n                fp.write(\"# from \" + connection.fromLayer.name + \" to \" +\n                         connection.toLayer.name + \"\\n\")\n                for i in range(connection.fromLayer.size):\n                    for j in range(connection.toLayer.size):\n                        fp.write(\"%f \" % connection.weight[i][j] )\n                    fp.write(\"\\n\")\n            fp.close()\n        elif mode == 'tlearn':\n            fp = open(filename, \"w\")\n            fp.write(\"NETWORK CONFIGURED BY TLEARN\\n\")\n            fp.write(\"# weights after %d sweeps\\n\" % self.epoch)\n            fp.write(\"# WEIGHTS\\n\")\n            cnt = 1\n            for lto in self.layers:\n                if lto.type != 'Input':\n                    for j in range(lto.size):\n                        fp.write(\"# TO NODE %d\\n\" % cnt)\n                        fp.write(\"%f\\n\" % lto.weight[j] )\n                        for lfrom in self.layers:\n                            try:\n                                connection = self.getConnection(lfrom.name,lto.name)\n                                for i in range(connection.fromLayer.size):\n                                    fp.write(\"%f\\n\" % connection.weight[i][j])\n                            except NetworkError: # should return an exception here\n                                for i in range(lfrom.size):\n                                    fp.write(\"%f\\n\" % 0.0)\n                        cnt += 1\n            fp.close()            \n        else:\n            raise ValueError('Unknown mode in saveWeights().', mode)", "response": "Saves weights to file in pickle or tlearn mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loadWeights(self, filename, mode='pickle'):\n        # modes: pickle, plain/conx, tlearn\n        if mode == 'pickle':\n            import pickle\n            fp = open(filename, \"r\")\n            mylist = pickle.load(fp)\n            fp.close()\n            self.unArrayify(mylist)\n        elif mode in ['plain', 'conx']:\n            arr = []\n            fp = open(filename, \"r\")\n            lines = fp.readlines()\n            for line in lines:\n                line = line.strip()\n                if line == '' or line[0] == '#':\n                    pass\n                else:\n                    data = list(map( float, line.split()))\n                    arr.extend( data )\n            self.unArrayify( arr )\n            fp.close()\n        elif mode == 'tlearn':\n            fp = open(filename, \"r\")\n            fp.readline() # NETWORK CONFIGURED BY\n            fp.readline() # # weights after %d sweeps\n            fp.readline() # # WEIGHTS\n            cnt = 1\n            for lto in self.layers:\n                if lto.type != 'Input':\n                    for j in range(lto.size):\n                        fp.readline() # TO NODE %d\n                        lto.weight[j] = float(fp.readline())\n                        for lfrom in self.layers:\n                            try:\n                                connection = self.getConnection(lfrom.name, lto.name)\n                                for i in range(connection.fromLayer.size):\n                                    connection.weight[i][j] = float( fp.readline() )\n                            except NetworkError:\n                                for i in range(lfrom.size):\n                                    # 0.0\n                                    fp.readline()\n                        cnt += 1\n            fp.close()            \n        elif mode == 'nbench':\n            # reads weights and constructs network\n            fp = open(filename, \"r\")\n            line = fp.readline()\n            while line[:8] != \"Ninputs:\":\n                line = fp.readline()\n            itxt, inputs, ttxt, total, otxt, outputs = line.split()\n            inputs, total, outputs = int(inputs), int(total), int(outputs)\n            # cascor's total value is the bias + inputs + hiddens\n            hiddens = total - inputs - 1\n            # create the layers:\n            self.addLayer(\"input\", inputs)\n            for i in range(hiddens):\n                self.addLayer(\"hidden%d\" % i, 1)\n            self.addLayer(\"output\", outputs)\n            # connect input to all hiddens, output:\n            for i in range(hiddens):\n                self.connect(\"input\", \"hidden%d\" % i)\n            self.connect(\"input\", \"output\")\n            # connect all hiddens to all later hiddens:\n            for i in range(hiddens - 1):\n                for j in range(i + 1, hiddens):\n                    if j != i:\n                        self.connect(\"hidden%d\" % i, \"hidden%d\" % j )\n            # connect all hiddens to outputs:\n            for i in range(hiddens):\n                self.connect(\"hidden%d\" % i, \"output\")\n            # now, let's set the weights:\n            for outcount in range(outputs):\n                while line[:9] != \"# Output:\":\n                    line = fp.readline()\n                line = fp.readline() # $\n                line = fp.readline() # bias, input to output, hidden to output?\n                data = \"\"\n                while line and line[0] != \"#\":\n                    data += \" \" + line.strip()\n                    line = fp.readline()\n                weights = list(map(float, data.split()))\n                self[\"output\"].weight[outcount] = weights[0] # bias\n                next = 1\n                for i in range(self[\"input\"].size):\n                    self[\"input\", \"output\"].weight[i][outcount] = weights[next]\n                    next += 1\n                for h in range(hiddens):\n                    for i in range(self[\"hidden%d\" % h].size): # normally just 1\n                        self[\"hidden%d\" % h, \"output\"].weight[i][outcount] = weights[next]\n                        next += 1\n            # now, for each hidden \"layer\":\n            while line and line[0] != \"$\":\n                line = fp.readline()\n            line = fp.readline()\n            for hidcount in range(hiddens):\n                weights = []\n                while line and line[0] != \"$\" and line[0] != \"#\": # next line is a weight line\n                    weights.extend( list(map(float, line.split()))) # bias, input to hidden, hidden to hidden?\n                    line = fp.readline() \n                self[(\"hidden%d\" % hidcount)].weight[0] = weights[0] # bias first\n                next = 1\n                for i in range(self[\"input\"].size):\n                    for j in range(self[\"hidden%d\" % hidcount].size): # normally just 1\n                        self[\"input\", (\"hidden%d\" % hidcount)].weight[i][j] = weights[next]\n                        next += 1\n                for h in range(hidcount): # all those hids leading up to this one\n                    for i in range(self[\"hidden%d\" % h].size): # normally just 1\n                        for j in range(self[\"hidden%d\" % hidcount].size): # normally just 1\n                            self[(\"hidden%d\" % h), (\"hidden%d\" % hidcount)].weight[i][j] = weights[next]\n                            next += 1\n                line = fp.readline() # $\n                line = fp.readline() # beginning of weights\n        else:\n            raise ValueError('Unknown mode in loadWeights()', mode)", "response": "Loads weights from a file in pickle or nbench mode."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef saveNetwork(self, filename, makeWrapper = 1, mode = \"pickle\", counter = None):\n        self.saveNetworkToFile(filename, makeWrapper, mode, counter)", "response": "Saves the current object to a file using pickle."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave the current network to a file.", "response": "def saveNetworkToFile(self, filename, makeWrapper = 1, mode = \"pickle\", counter = None):\n        \"\"\"\n        Deprecated.\n        \"\"\"\n        if \"?\" in filename: # replace ? pattern in filename with epoch number\n            import re\n            char = \"?\"\n            match = re.search(re.escape(char) + \"+\", filename)\n            if match:\n                num = self.epoch\n                if counter != None:\n                    num = counter\n                elif self.totalEpoch != 0: # use a total epoch, if one:\n                    num = self.totalEpoch\n                fstring = \"%%0%dd\" % len(match.group())\n                filename = filename[:match.start()] + \\\n                           fstring % num + \\\n                           filename[match.end():]\n                self.lastAutoSaveNetworkFilename = filename\n        if mode == \"pickle\":\n            # dump network via pickle:\n            import pickle\n            basename = filename.split('.')[0]\n            filename += \".pickle\"\n            fp = open(filename, 'w')\n            pickle.dump(self, fp)\n            fp.close()\n            # make wrapper python file:\n            if makeWrapper:\n                fp = open(basename + \".py\", \"w\")\n                fp.write(\"from pyrobot.brain.conx import *\\n\")\n                fp.write(\"import pickle\\n\")\n                fp.write(\"fp = open('%s', 'r')\\n\" % filename)\n                fp.write(\"network = pickle.load(fp)\")\n                fp.close()\n            # give some help:\n            print(\"To load network:\")\n            print(\"   %% python -i %s \" % (basename + \".py\"))\n            print(\"   >>> network.train() # for example\")\n            print(\"--- OR ---\")\n            print(\"   % python\")\n            print(\"   >>> from pyrobot.brain.conx import *\")\n            print(\"   >>> network = loadNetwork(%s)\" % filename)\n            print(\"   >>> network.train() # for example\")\n        elif mode in [\"plain\", \"conx\"]:\n            fp = open(filename, \"w\")\n            fp.write(\"network, %s\\n\" % (self.__class__.__name__))\n            for layer in self.layers:\n                fp.write(\"layer, %s, %s\\n\" % (layer.name, layer.size))\n                # biases:\n                for i in range(layer.size):\n                    fp.write(\"%f \" % layer.weight[i])\n                fp.write(\"\\n\")\n            for connection in self.connections:\n                fp.write(\"connection, %s, %s\\n\" %(connection.fromLayer.name, connection.toLayer.name))\n                # weights:\n                for i in range(connection.fromLayer.size):\n                    for j in range(connection.toLayer.size):\n                        fp.write(\"%f \" % connection.weight[i][j])\n                    fp.write(\"\\n\")\n            fp.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef loadVectors(self, filename, cols = None, everyNrows = 1,\n                    delim = ' ', checkEven = 1, patterned = 0):\n        \"\"\"\n        Load a set of vectors from a file. Takes a filename, list of cols\n        you want (or None for all), get every everyNrows (or 1 for no\n        skipping), and a delimeter.\n        \"\"\"\n        return self.loadVectorsFromFile(filename, cols, everyNrows,\n                                        delim, checkEven, patterned)", "response": "Load a set of vectors from a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading vectors from a file.", "response": "def loadVectorsFromFile(self, filename, cols = None, everyNrows = 1,\n                            delim = ' ', checkEven = 1, patterned = 0):\n        \"\"\"\n        Deprecated.\n        \"\"\"\n        fp = open(filename, \"r\")\n        line = fp.readline()\n        lineno = 0\n        lastLength = None\n        data = []\n        while line:\n            if lineno % everyNrows == 0:\n                if patterned:\n                    linedata1 = [x for x in line.strip().split(delim)]\n                else:\n                    linedata1 = [float(x) for x in line.strip().split(delim)]\n            else:\n                lineno += 1\n                line = fp.readline()\n                continue\n            if cols == None: # get em all\n                newdata = linedata1\n            else: # just get some cols\n                newdata = []\n                for i in cols:\n                    newdata.append( linedata1[i] )\n            if lastLength == None or (not checkEven) or (checkEven and len(newdata) == lastLength):\n                data.append( newdata )\n            else:\n                raise ValueError(\"Data Format Error: line = %d, data = %s\" % (lineno, newdata))\n            lastLength = len(newdata)\n            lineno += 1\n            line = fp.readline()    \n        fp.close()\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload input patterns from file.", "response": "def loadInputPatterns(self, filename, cols = None, everyNrows = 1,\n                          delim = ' ', checkEven = 1):\n        \"\"\"\n        Loads inputs as patterns from file.\n        \"\"\"\n        self.loadInputPatternsFromFile(filename, cols, everyNrows,\n                                       delim, checkEven)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef loadInputPatternsFromFile(self, filename, cols = None, everyNrows = 1,\n                                  delim = ' ', checkEven = 1):\n        \"\"\"\n        Deprecated.\n        \"\"\"\n        self.inputs = self.loadVectors(filename, cols, everyNrows, delim, checkEven, patterned = 1)\n        self.loadOrder = [0] * len(self.inputs)\n        for i in range(len(self.inputs)):\n            self.loadOrder[i] = i", "response": "Load input patterns from a file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the inputs from a file.", "response": "def loadInputs(self, filename, cols = None, everyNrows = 1,\n                   delim = ' ', checkEven = 1):\n        \"\"\"\n        Loads inputs from file. Patterning is lost.\n        \"\"\"\n        self.loadInputsFromFile(filename, cols, everyNrows,\n                                delim, checkEven)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves the inputs to a file.", "response": "def saveInputsToFile(self, filename):\n        \"\"\"\n        Deprecated.\n        \"\"\"\n        fp = open(filename, 'w')\n        for input in self.inputs:\n            vec = self.replacePatterns(input)\n            for item in vec:\n                fp.write(\"%f \" % item)\n            fp.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the set of target tables from a file.", "response": "def loadTargets(self, filename, cols = None, everyNrows = 1,\n                            delim = ' ', checkEven = 1):\n        \"\"\"\n        Loads targets from file.\n        \"\"\"\n        self.loadTargetsFromFile(filename, cols, everyNrows,\n                                 delim, checkEven)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload the set of target tables from a file.", "response": "def loadTargetsFromFile(self, filename, cols = None, everyNrows = 1,\n                            delim = ' ', checkEven = 1):\n        \"\"\"\n        Loads targets from file.\n        \"\"\"\n        self.targets = self.loadVectors(filename, cols, everyNrows,\n                                        delim, checkEven)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading target patterns from a file.", "response": "def loadTargetPatterns(self, filename, cols = None, everyNrows = 1,\n                            delim = ' ', checkEven = 1):\n        \"\"\"\n        Loads targets as patterns from file.\n        \"\"\"\n        self.loadTargetPatternssFromFile(filename, cols, everyNrows,\n                                         delim, checkEven)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload target patterns from a file.", "response": "def loadTargetPatternsFromFile(self, filename, cols = None, everyNrows = 1,\n                                   delim = ' ', checkEven = 1):\n        \"\"\"\n        Deprecated.\n        \"\"\"\n        self.targets = self.loadVectors(filename, cols, everyNrows,\n                                        delim, checkEven, patterned=1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef saveTargetsToFile(self, filename):\n        fp = open(filename, 'w')\n        for target in self.targets:\n            vec = self.replacePatterns(target)\n            for item in vec:\n                fp.write(\"%f \" % item)\n            fp.write(\"\\n\")", "response": "Save the set of targets to a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave the data to a file.", "response": "def saveDataToFile(self, filename):\n        \"\"\"\n        Deprecated.\n        \"\"\"\n        fp = open(filename, 'w')\n        for i in range(len(self.inputs)):\n            try:\n                vec = self.replacePatterns(self.inputs[i])\n                for item in vec:\n                    fp.write(\"%f \" % item)\n            except:\n                pass\n            try:\n                vec = self.replacePatterns(self.targets[i])\n                for item in vec:\n                    fp.write(\"%f \" % item)\n            except:\n                pass\n            fp.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload the data from a file.", "response": "def loadDataFromFile(self, filename, ocnt = -1):\n        \"\"\"\n        Deprecated.\n        \"\"\"\n        if ocnt == -1:\n            ocnt = int(self.layers[len(self.layers) - 1].size)\n        fp = open(filename, 'r')\n        line = fp.readline()\n        self.targets = []\n        self.inputs = []\n        while line:\n            data = list(map(float, line.split()))\n            cnt = len(data)\n            icnt = cnt - ocnt\n            self.inputs.append(self.patternVector(data[0:icnt]))\n            self.targets.append(self.patternVector(data[icnt:]))\n            line = fp.readline()\n        self.loadOrder = [0] * len(self.inputs)\n        for i in range(len(self.inputs)):\n            self.loadOrder[i] = i"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsees if there is a name/layer pattern combo, else return the name pattern.", "response": "def lookupPattern(self, name, layer):\n        \"\"\" See if there is a name/layer pattern combo, else return the name pattern. \"\"\"\n        if (name, layer) in self.patterns:\n            return self.patterns[(name, layer)]\n        else:\n            return self.patterns[name]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef replacePatterns(self, vector, layer = None):\n        if not self.patterned: return vector\n        if type(vector) == str:\n            return self.replacePatterns(self.lookupPattern(vector, layer), layer)\n        elif type(vector) != list:\n            return vector\n        # should be a vector if we made it here\n        vec = []\n        for v in vector:\n            if type(v) == str:\n                retval = self.replacePatterns(self.lookupPattern(v, layer), layer)\n                if type(retval) == list:\n                    vec.extend( retval )\n                else:\n                    vec.append( retval )\n            else:\n                vec.append( v )\n        return vec", "response": "Replaces patterned inputs or targets with activation vectors."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef patternVector(self, vector):\n        if not self.patterned: return vector\n        if type(vector) == int:\n            if self.getWord(vector) != '':\n                return self.getWord(vector)\n            else:\n                return vector\n        elif type(vector) == float:\n            if self.getWord(vector) != '':\n                return self.getWord(vector)\n            else:\n                return vector\n        elif type(vector) == str:\n            return vector\n        elif type(vector) == list:\n            if self.getWord(vector) != '':\n                return self.getWord(vector)\n        # should be a list\n        vec = []\n        for v in vector:\n            if self.getWord(v) != '':\n                retval = self.getWord(v)\n                vec.append( retval )\n            else:\n                retval = self.patternVector(v)\n                vec.append( retval )                \n        return vec", "response": "Replaces vector with patterns. Used for loading inputs or targets from a file and still preserving patterns."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the pattern with key word.", "response": "def getPattern(self, word):\n        \"\"\"\n        Returns the pattern with key word.\n\n        Example: net.getPattern(\"tom\") => [0, 0, 0, 1]\n        \n        \"\"\"\n        if word in self.patterns:\n            return self.patterns[word]\n        else:\n            raise ValueError('Unknown pattern in getPattern().', word)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the word associated with pattern.", "response": "def getWord(self, pattern, returnDiff = 0):\n        \"\"\"\n        Returns the word associated with pattern.\n\n        Example: net.getWord([0, 0, 0, 1]) => \"tom\"\n\n        This method now returns the closest pattern based on distance.\n        \"\"\"\n        minDist = 10000\n        closest = None\n        for w in self.patterns:\n            # There may be some patterns that are scalars; we don't search\n            # those in this function:\n            if type(self.patterns[w]) in [int, float, int]: continue\n            if len(self.patterns[w]) == len(pattern):\n                dist = reduce(operator.add, [(a - b) ** 2 for (a,b) in zip(self.patterns[w], pattern )])\n                if dist == 0.0:\n                    if returnDiff:\n                        return w, dist\n                    else:\n                        return w\n                if dist < minDist:\n                    minDist = dist\n                    closest = w\n        if returnDiff:\n            return closest, minDist\n        else:\n            return closest"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a pattern with key word.", "response": "def addPattern(self, word, vector):\n        \"\"\"\n        Adds a pattern with key word.\n\n        Example: net.addPattern(\"tom\", [0, 0, 0, 1])\n        \n        \"\"\"\n        if word in self.patterns:\n            raise NetworkError('Pattern key already in use. Call delPattern to free key.', word)\n        else:\n            self.patterns[word] = vector"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef shareWeights(self, network, listOfLayerNamePairs = None):\n        if listOfLayerNamePairs == None:\n            listOfLayerNamePairs = []\n            for c in self.connections:\n                listOfLayerNamePairs.append( [c.fromLayer.name, c.toLayer.name] )\n        if self.verbosity > 1:\n            print(\"sharing weights:\", self.name, listOfLayerNamePairs)\n        # first, check to see if this will work:\n        count = 0\n        for (fromLayerName, toLayerName) in listOfLayerNamePairs:\n            for c1 in range(len(self.connections)):\n                if self.connections[c1].fromLayer.name == fromLayerName and \\\n                       self.connections[c1].toLayer.name == toLayerName:\n                    for c2 in range(len(network.connections)):\n                        if network.connections[c2].fromLayer.name == fromLayerName and \\\n                               network.connections[c2].toLayer.name == toLayerName:\n                            if (self.connections[c1].fromLayer.size != network.connections[c2].fromLayer.size) or \\\n                               (self.connections[c1].toLayer.size != network.connections[c2].toLayer.size):\n                                raise AttributeError(\"shareSomeWeights: layer sizes did not match\")\n                            count += 1\n        if count != len(listOfLayerNamePairs):\n            raise AttributeError(\"shareSomeWeights: layer names did not match\")\n        # ok, now let's share!\n        self.sharedWeights = 1\n        network.sharedWeights = 1\n        for (fromLayerName, toLayerName) in listOfLayerNamePairs:\n            for c1 in range(len(self.connections)):\n                if self.connections[c1].fromLayer.name == fromLayerName and \\\n                       self.connections[c1].toLayer.name == toLayerName:\n                    for c2 in range(len(network.connections)):\n                        if network.connections[c2].fromLayer.name == fromLayerName and \\\n                               network.connections[c2].toLayer.name == toLayerName:\n                            self.connections[c1].weight = network.connections[c2].weight\n        for (fromLayerName, toLayerName) in listOfLayerNamePairs:\n            for l1 in range(len(self.layers)):\n                if self.layers[l1].name == toLayerName:\n                    for l2 in range(len(network.layers)):\n                        if network.layers[l2].name == toLayerName:\n                            self.layers[l1].weight = network.layers[l2].weight", "response": "Share weights with another network."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef propagate(self, *arg, **kw):\n        output = Network.propagate(self, *arg, **kw)\n        if self.interactive:\n            self.updateGraphics()\n        # IMPORTANT: convert results from numpy.floats to conventional floats \n        if type(output) == dict:\n            for layerName in output:\n                output[layerName] = [float(x) for x in output[layerName]]\n            return output\n        else:\n            return [float(x) for x in output]", "response": "Propagates activation through the network."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef loadWeightsFromFile(self, filename, mode='pickle'):\n        Network.loadWeights(self, filename, mode)\n        self.updateGraphics()", "response": "Load weights from a file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef display(self):\n        size = list(range(len(self.layers)))\n        size.reverse()\n        for i in size:\n            layer = self.layers[i]\n            if layer.active:\n                print('%s layer (size %d)' % (layer.name, layer.size))\n                tlabel, olabel = '', ''\n                if (layer.type == 'Output'):\n                    if self.countWrong:\n                        tlabel = ' (%s)' % self.classify(layer.target.tolist())\n                        olabel = ' (%s)' % self.classify(layer.activation.tolist())\n                        if olabel == tlabel:\n                            self.numRight += 1\n                        else:\n                            olabel += '  *** WRONG ***'\n                            self.numWrong += 1\n                            if self.actDisplay is not None:\n                                self.actDisplay.showWrong()\n                    print('Target    : %s%s' % (pretty(layer.target, max=15), tlabel))\n                print('Activation: %s%s' % (pretty(layer.activation, max=15), olabel))\n                if self.patterned and layer.type != 'Hidden':\n                    targetWord, diff = self.getWord( layer.target, returnDiff = 1)\n                    if layer.kind == 'Output':\n                        if targetWord == None:\n                            print(\"Target Pattern   = %s\" % \"No match\")\n                        else:\n                            if diff == 0.0:\n                                print(\"Target Pattern   = '%s'\" % targetWord)\n                            else:\n                                print(\"Target Pattern   = '%s'; difference = %f)\" % (targetWord, diff))\n                    actWord, diff = self.getWord( layer.activation, returnDiff = 1 )\n                    if (layer.kind == 'Input' or layer.kind == 'Output'):\n                        if actWord == None:\n                            print(\"Matching Pattern = %s\" % \"No match\")\n                        else:\n                            if diff == 0.0:\n                                print(\"Matching Pattern = '%s'\" % actWord)\n                            else:\n                                print(\"Matching Pattern = '%s'; difference = %f\" % (actWord, diff))\n                print(\"------------------------------------\")", "response": "Displays the network to the screen."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the sequence type of the current object.", "response": "def setSequenceType(self, value):\n        \"\"\"\n        You must set this!\n        \"\"\"\n        if value == \"ordered-continuous\":\n            self.orderedInputs = 1           \n            self.initContext = 0             \n        elif value == \"random-segmented\":\n            self.orderedInputs = 0\n            self.initContext = 1\n        elif value == \"random-continuous\":\n            self.orderedInputs = 0\n            self.initContext = 0\n        elif value == \"ordered-segmented\":\n            self.orderedInputs = 1\n            self.initContext = 1\n        else:\n            raise AttributeError(\"invalid sequence type: '%s'\" % value)\n        self.sequenceType = value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addLayers(self, *arg, **kw):\n        netType = \"serial\"\n        if \"type\" in kw:\n            netType = kw[\"type\"]\n        self.addLayer('input', arg[0])\n        hiddens = []\n        contexts = []\n        if len(arg) > 3: # FIXME: add context for each\n            hcount = 0\n            for hidc in arg[1:-1]:\n                name = 'hidden%d' % hcount\n                cname = 'context%d' % hcount\n                self.addLayer(name, hidc)\n                hiddens.append(name)\n                self.addContextLayer(cname, hidc, name)\n                hiddens.append((cname, name))\n                hcount += 1\n        elif len(arg) == 3:\n                name = 'hidden'\n                self.addContextLayer('context', arg[1], name)\n                self.addLayer(name, arg[1])\n                hiddens.append(name)\n                contexts.append(('context', name))\n        elif len(arg) == 2:\n            pass\n        else:\n            raise AttributeError(\"not enough layers! need >= 2\")\n        self.addLayer('output', arg[-1])\n        # Connect contexts\n        for (fromName, toName) in contexts:\n            self.connect(fromName, toName)\n        lastName = \"input\"\n        for name in hiddens:\n            if netType == \"parallel\":\n                self.connect('input', name)\n                self.connect(name, 'output')\n            else: # serial\n                self.connect(lastName, name)\n                lastName = name\n        if netType == \"serial\" or lastName == \"input\":\n            self.connect(lastName, \"output\")", "response": "Adds a set of layers to the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addThreeLayers(self, inc, hidc, outc):\n        self.addLayer('input', inc)\n        self.addContextLayer('context', hidc, 'hidden')\n        self.addLayer('hidden', hidc)\n        self.addLayer('output', outc)\n        self.connect('input', 'hidden')\n        self.connect('context', 'hidden')\n        self.connect('hidden', 'output')", "response": "Adds a three level network with a context layer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addSRNLayers(self, inc, hidc, outc):\n        self.addThreeLayers(inc, hidc, outc)", "response": "Adds three layers to the set of SRN records for the given include and outc."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a context layer.", "response": "def addContext(self, layer, hiddenLayerName = 'hidden', verbosity = 0):\n        \"\"\"\n        Adds a context layer. Necessary to keep self.contextLayers dictionary up to date. \n        \"\"\"\n        # better not add context layer first if using sweep() without mapInput\n        SRN.add(self, layer, verbosity)\n        if hiddenLayerName in self.contextLayers:\n            raise KeyError('There is already a context layer associated with this hidden layer.', \\\n                             hiddenLayerName)\n        else:\n            self.contextLayers[hiddenLayerName] = layer\n            layer.kind = 'Context'"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copyHiddenToContext(self):\n        for item in list(self.contextLayers.items()):\n            if self.verbosity > 2: print('Hidden layer: ', self.getLayer(item[0]).activation)\n            if self.verbosity > 2: print('Context layer before copy: ', item[1].activation)\n            item[1].copyActivations(self.getLayer(item[0]).activation)\n            if self.verbosity > 2: print('Context layer after copy: ', item[1].activation)", "response": "Copies hidden layer to context layer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the context layer to value.", "response": "def setContext(self, value = .5):\n        \"\"\"\n        Clears the context layer by setting context layer to (default) value 0.5. \n        \"\"\"\n        for context in list(self.contextLayers.values()):\n            context.resetFlags() # hidden activations have already been copied in\n            context.setActivations(value)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef showPerformance(self):\n        if len(self.inputs) == 0:\n            print('no patterns to test')\n            return\n        self.setContext()\n        while True:\n            BackpropNetwork.showPerformance(self)\n            if self.quitFromSweep:\n                return", "response": "Show the performance of the current training patterns."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(self, line):\n        tokens = []\n\n        self.idx = -1   # Bogus value to ensure idx = 0 after first iteration\n        self.characters = iter(line)\n        self.update_chars()\n\n        while self.char != '\\n':\n            # Update namelist group status\n            if self.char in ('&', '$'):\n                self.group_token = self.char\n\n            if self.group_token and (\n                    (self.group_token, self.char) in (('&', '/'), ('$', '$'))):\n                self.group_token = False\n\n            word = ''\n            if self.char in self.whitespace:\n                while self.char in self.whitespace:\n                    word += self.char\n                    self.update_chars()\n\n            elif self.char in ('!', '#') or self.group_token is None:\n                # Abort the iteration and build the comment token\n                word = line[self.idx:-1]\n                self.char = '\\n'\n\n            elif self.char in '\"\\'' or self.prior_delim:\n                word = self.parse_string()\n\n            elif self.char.isalpha():\n                word = self.parse_name(line)\n\n            elif self.char in ('+', '-'):\n                # Lookahead to check for IEEE value\n                self.characters, lookahead = itertools.tee(self.characters)\n                ieee_val = ''.join(itertools.takewhile(str.isalpha, lookahead))\n                if ieee_val.lower() in ('inf', 'infinity', 'nan'):\n                    word = self.char + ieee_val\n                    self.characters = lookahead\n                    self.prior_char = ieee_val[-1]\n                    self.char = next(lookahead, '\\n')\n                else:\n                    word = self.parse_numeric()\n\n            elif self.char.isdigit():\n                word = self.parse_numeric()\n\n            elif self.char == '.':\n                self.update_chars()\n                if self.char.isdigit():\n                    frac = self.parse_numeric()\n                    word = '.' + frac\n                else:\n                    word = '.'\n                    while self.char.isalpha():\n                        word += self.char\n                        self.update_chars()\n                    if self.char == '.':\n                        word += self.char\n                        self.update_chars()\n\n            elif self.char in Tokenizer.punctuation:\n                word = self.char\n                self.update_chars()\n\n            else:\n                # This should never happen\n                raise ValueError\n\n            tokens.append(word)\n\n        return tokens", "response": "Tokenize a line of Fortran source."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_numeric(self):\n        word = ''\n        frac = False\n\n        if self.char == '-':\n            word += self.char\n            self.update_chars()\n\n        while self.char.isdigit() or (self.char == '.' and not frac):\n            # Only allow one decimal point\n            if self.char == '.':\n                frac = True\n            word += self.char\n            self.update_chars()\n\n        # Check for float exponent\n        if self.char in 'eEdD':\n            word += self.char\n            self.update_chars()\n\n        if self.char in '+-':\n            word += self.char\n            self.update_chars()\n        while self.char.isdigit():\n            word += self.char\n            self.update_chars()\n\n        return word", "response": "Tokenize a Fortran numerical value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_chars(self):\n        # NOTE: We spoof non-Unix files by returning '\\n' on StopIteration\n        self.prior_char, self.char = self.char, next(self.characters, '\\n')\n        self.idx += 1", "response": "Update the current charters in the tokenizer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef outerproduct(a, b):\n    result = zeros((len(a), len(b)))\n    for i in range(len(a)):\n        for j in range(len(b)):\n            result[i][j] = a[i] * b[j]\n    return result", "response": "A simple innerproduct function that returns a vector that is the product of two numbers."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reduce(vector):\n        if type(vector) is list: # matrix\n            return array(list(map(add.reduce, vector)))\n        else:\n            return sum(vector)", "response": "Reduce the set of keys in a list or matrix."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reduce(vector):\n        if type(vector) is list: # matrix\n            return array(list(map(multiply.reduce, vector)))\n        else:\n            return reduce(operator.mul, vector)", "response": "Reduce the set of items in the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pycomplex(v_str):\n    assert isinstance(v_str, str)\n\n    if v_str[0] == '(' and v_str[-1] == ')' and len(v_str.split(',')) == 2:\n        v_re, v_im = v_str[1:-1].split(',', 1)\n\n        # NOTE: Failed float(str) will raise ValueError\n        return complex(pyfloat(v_re), pyfloat(v_im))\n    else:\n        raise ValueError('{0} must be in complex number form (x, y).'\n                         ''.format(v_str))", "response": "Convert string repr of Fortran complex to Python complex."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pybool(v_str, strict_logical=True):\n    assert isinstance(v_str, str)\n    assert isinstance(strict_logical, bool)\n\n    if strict_logical:\n        v_bool = v_str.lower()\n    else:\n        try:\n            if v_str.startswith('.'):\n                v_bool = v_str[1].lower()\n            else:\n                v_bool = v_str[0].lower()\n        except IndexError:\n            raise ValueError('{0} is not a valid logical constant.'\n                             ''.format(v_str))\n\n    if v_bool in ('.true.', '.t.', 'true', 't'):\n        return True\n    elif v_bool in ('.false.', '.f.', 'false', 'f'):\n        return False\n    else:\n        raise ValueError('{0} is not a valid logical constant.'.format(v_str))", "response": "Convert string repr of Fortran logical to Python logical."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pystr(v_str):\n    assert isinstance(v_str, str)\n\n    if v_str[0] in (\"'\", '\"') and v_str[0] == v_str[-1]:\n        quote = v_str[0]\n        out = v_str[1:-1]\n    else:\n        # NOTE: This is non-standard Fortran.\n        #       For example, gfortran rejects non-delimited strings.\n        quote = None\n        out = v_str\n\n    # Replace escaped strings\n    if quote:\n        out = out.replace(2 * quote, quote)\n\n    return out", "response": "Convert string repr of Fortran string to Python string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pad_array(v, idx):\n    i_v, i_s = idx[0]\n\n    if len(idx) > 1:\n        # Append missing subarrays\n        v.extend([[] for _ in range(len(v), i_v - i_s + 1)])\n\n        # Pad elements\n        for e in v:\n            pad_array(e, idx[1:])\n    else:\n        v.extend([None for _ in range(len(v), i_v - i_s + 1)])", "response": "Expand lists in multidimensional arrays to pad unset values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef merge_values(src, new):\n    if isinstance(src, dict) and isinstance(new, dict):\n        return merge_dicts(src, new)\n    else:\n        if not isinstance(src, list):\n            src = [src]\n        if not isinstance(new, list):\n            new = [new]\n\n        return merge_lists(src, new)", "response": "Merge two lists or dicts into a single element."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates a value list with a list of new or updated values.", "response": "def merge_lists(src, new):\n    \"\"\"Update a value list with a list of new or updated values.\"\"\"\n    l_min, l_max = (src, new) if len(src) < len(new) else (new, src)\n\n    l_min.extend(None for i in range(len(l_min), len(l_max)))\n\n    for i, val in enumerate(new):\n        if isinstance(val, dict) and isinstance(src[i], dict):\n            new[i] = merge_dicts(src[i], val)\n        elif isinstance(val, list) and isinstance(src[i], list):\n            new[i] = merge_lists(src[i], val)\n        elif val is not None:\n            new[i] = val\n        else:\n            new[i] = src[i]\n\n    return new"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef merge_dicts(src, patch):\n    for key in patch:\n        if key in src:\n            if isinstance(src[key], dict) and isinstance(patch[key], dict):\n                merge_dicts(src[key], patch[key])\n            else:\n                src[key] = merge_values(src[key], patch[key])\n        else:\n            src[key] = patch[key]\n\n    return src", "response": "Merge contents of dict patch into src."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreduces lists of zero or one elements to individual values.", "response": "def delist(values):\n    \"\"\"Reduce lists of zero or one elements to individual values.\"\"\"\n    assert isinstance(values, list)\n\n    if not values:\n        return None\n    elif len(values) == 1:\n        return values[0]\n\n    return values"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nidentify the number of values ahead of the current token.", "response": "def count_values(tokens):\n    \"\"\"Identify the number of values ahead of the current token.\"\"\"\n    ntoks = 0\n    for tok in tokens:\n        if tok in ('=', '/', '$', '&'):\n            if ntoks > 0 and tok == '=':\n                ntoks -= 1\n            break\n        elif tok in whitespace + ',':\n            continue\n        else:\n            ntoks += 1\n\n    return ntoks"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate and set the comment token string.", "response": "def comment_tokens(self, value):\n        \"\"\"Validate and set the comment token string.\"\"\"\n        if not isinstance(value, str):\n            raise TypeError('comment_tokens attribute must be a string.')\n        self._comment_tokens = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating and set the default start index.", "response": "def default_start_index(self, value):\n        \"\"\"Validate and set the default start index.\"\"\"\n        if not isinstance(value, int):\n            raise TypeError('default_start_index attribute must be of int '\n                            'type.')\n        self._default_start_index = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating and enable spare arrays.", "response": "def sparse_arrays(self, value):\n        \"\"\"Validate and enable spare arrays.\"\"\"\n        if not isinstance(value, bool):\n            raise TypeError('sparse_arrays attribute must be a logical type.')\n        self._sparse_arrays = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the global start index.", "response": "def global_start_index(self, value):\n        \"\"\"Set the global start index.\"\"\"\n        if not isinstance(value, int) and value is not None:\n            raise TypeError('global_start_index attribute must be of int '\n                            'type.')\n        self._global_start_index = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef row_major(self, value):\n        if value is not None:\n            if not isinstance(value, bool):\n                raise TypeError(\n                    'f90nml: error: row_major must be a logical value.')\n            else:\n                self._row_major = value", "response": "Validate and set row - major format for multidimensional arrays."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef strict_logical(self, value):\n        if value is not None:\n            if not isinstance(value, bool):\n                raise TypeError(\n                    'f90nml: error: strict_logical must be a logical value.')\n            else:\n                self._strict_logical = value", "response": "Validate and set the strict logical flag."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a Fortran namelist file and store the contents.", "response": "def read(self, nml_fname, nml_patch_in=None, patch_fname=None):\n        \"\"\"Parse a Fortran namelist file and store the contents.\n\n        >>> parser = f90nml.Parser()\n        >>> data_nml = parser.read('data.nml')\n        \"\"\"\n        # For switching based on files versus paths\n        nml_is_path = not hasattr(nml_fname, 'read')\n        patch_is_path = not hasattr(patch_fname, 'read')\n\n        # Convert patch data to a Namelist object\n        if nml_patch_in is not None:\n            if not isinstance(nml_patch_in, dict):\n                raise TypeError('Input patch must be a dict or a Namelist.')\n\n            nml_patch = copy.deepcopy(Namelist(nml_patch_in))\n\n            if not patch_fname and nml_is_path:\n                patch_fname = nml_fname + '~'\n            elif not patch_fname:\n                raise ValueError('f90nml: error: No output file for patch.')\n            elif nml_fname == patch_fname:\n                raise ValueError('f90nml: error: Patch filepath cannot be the '\n                                 'same as the original filepath.')\n            if patch_is_path:\n                self.pfile = open(patch_fname, 'w')\n            else:\n                self.pfile = patch_fname\n        else:\n            nml_patch = Namelist()\n\n        try:\n            nml_file = open(nml_fname, 'r') if nml_is_path else nml_fname\n            try:\n                return self._readstream(nml_file, nml_patch)\n\n            # Close the files we opened on any exceptions within readstream\n            finally:\n                if nml_is_path:\n                    nml_file.close()\n        finally:\n            if self.pfile and patch_is_path:\n                self.pfile.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _readstream(self, nml_file, nml_patch_in=None):\n        nml_patch = nml_patch_in if nml_patch_in is not None else Namelist()\n\n        tokenizer = Tokenizer()\n        f90lex = []\n        for line in nml_file:\n            toks = tokenizer.parse(line)\n            while tokenizer.prior_delim:\n                new_toks = tokenizer.parse(next(nml_file))\n\n                # Skip empty lines\n                if not new_toks:\n                    continue\n\n                # The tokenizer always pre-tokenizes the whitespace (leftover\n                # behaviour from Fortran source parsing) so this must be added\n                # manually.\n                if new_toks[0].isspace():\n                    toks[-1] += new_toks.pop(0)\n\n                # Append the rest of the string (if present)\n                if new_toks:\n                    toks[-1] += new_toks[0]\n\n                    # Attach the rest of the tokens\n                    toks.extend(new_toks[1:])\n\n            toks.append('\\n')\n            f90lex.extend(toks)\n\n        self.tokens = iter(f90lex)\n\n        nmls = Namelist()\n\n        # Attempt to get first token; abort on empty file\n        try:\n            self._update_tokens(write_token=False)\n        except StopIteration:\n            return nmls\n\n        # TODO: Replace \"while True\" with an update_token() iterator\n        while True:\n            try:\n                # Check for classic group terminator\n                if self.token == 'end':\n                    self._update_tokens()\n\n                # Ignore tokens outside of namelist groups\n                while self.token not in ('&', '$'):\n                    self._update_tokens()\n\n            except StopIteration:\n                break\n\n            # Create the next namelist\n            self._update_tokens()\n            g_name = self.token\n\n            g_vars = Namelist()\n            v_name = None\n\n            # TODO: Edit `Namelist` to support case-insensitive `get` calls\n            grp_patch = nml_patch.get(g_name.lower(), Namelist())\n\n            # Populate the namelist group\n            while g_name:\n\n                if self.token not in ('=', '%', '('):\n                    self._update_tokens()\n\n                # Set the next active variable\n                if self.token in ('=', '(', '%'):\n\n                    v_name, v_values = self._parse_variable(\n                        g_vars,\n                        patch_nml=grp_patch\n                    )\n\n                    if v_name in g_vars:\n                        v_prior_values = g_vars[v_name]\n                        v_values = merge_values(v_prior_values, v_values)\n\n                    g_vars[v_name] = v_values\n\n                    # Deselect variable\n                    v_name = None\n                    v_values = []\n\n                # Finalise namelist group\n                if self.token in ('/', '&', '$'):\n\n                    # Append any remaining patched variables\n                    for v_name, v_val in grp_patch.items():\n                        g_vars[v_name] = v_val\n                        v_strs = nmls._var_strings(v_name, v_val)\n                        for v_str in v_strs:\n                            self.pfile.write(\n                                '{0}{1}\\n'.format(nml_patch.indent, v_str)\n                            )\n\n                    # Append the grouplist to the namelist\n                    if g_name in nmls:\n                        g_update = nmls[g_name]\n\n                        # Update to list of groups\n                        if not isinstance(g_update, list):\n                            g_update = [g_update]\n\n                        g_update.append(g_vars)\n\n                    else:\n                        g_update = g_vars\n\n                    nmls[g_name] = g_update\n\n                    # Reset state\n                    g_name, g_vars = None, None\n\n            try:\n                self._update_tokens()\n            except StopIteration:\n                break\n\n        return nmls", "response": "Parse an input stream containing a Fortran namelist."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_variable(self, parent, patch_nml=None):\n        if not patch_nml:\n            patch_nml = Namelist()\n\n        v_name = self.prior_token\n        v_values = []\n\n        # Patch state\n        patch_values = None\n\n        # Derived type parent index (see notes below)\n        dt_idx = None\n\n        if self.token == '(':\n\n            v_idx_bounds = self._parse_indices()\n            v_idx = FIndex(v_idx_bounds, self.global_start_index)\n\n            # Update starting index against namelist record\n            if v_name.lower() in parent.start_index:\n                p_idx = parent.start_index[v_name.lower()]\n\n                for idx, pv in enumerate(zip(p_idx, v_idx.first)):\n                    if all(i is None for i in pv):\n                        i_first = None\n                    else:\n                        i_first = min(i for i in pv if i is not None)\n\n                    v_idx.first[idx] = i_first\n\n                # Resize vector based on starting index\n                for i_p, i_v in zip(p_idx, v_idx.first):\n                    if i_p is not None and i_v is not None and i_v < i_p:\n                        pad = [None for _ in range(i_p - i_v)]\n                        parent[v_name] = pad + parent[v_name]\n\n            else:\n                # If variable already existed without an index, then assume a\n                #   1-based index\n                # FIXME: Need to respect undefined `None` starting indexes?\n                if v_name in parent:\n                    v_idx.first = [self.default_start_index\n                                   for _ in v_idx.first]\n\n            parent.start_index[v_name.lower()] = v_idx.first\n\n            self._update_tokens()\n\n            # Derived type parent check\n            # NOTE: This assumes single-dimension derived type vectors\n            #       (which I think is the only case supported in Fortran)\n            if self.token == '%':\n                assert v_idx_bounds[0][1] - v_idx_bounds[0][0] == 1\n                dt_idx = v_idx_bounds[0][0] - v_idx.first[0]\n\n                # NOTE: This is the sensible play to call `parse_variable`\n                # but not yet sure how to implement it, so we currently pass\n                # along `dt_idx` to the `%` handler.\n\n        else:\n            v_idx = None\n\n            # If indexed variable already exists, then re-index this new\n            #   non-indexed variable using the global start index\n\n            if v_name in parent.start_index:\n                p_start = parent.start_index[v_name.lower()]\n                v_start = [self.default_start_index for _ in p_start]\n\n                # Resize vector based on new starting index\n                for i_p, i_v in zip(p_start, v_start):\n                    if i_v < i_p:\n                        pad = [None for _ in range(i_p - i_v)]\n                        parent[v_name] = pad + parent[v_name]\n\n                parent.start_index[v_name.lower()] = v_start\n\n        if self.token == '%':\n\n            # Resolve the derived type\n\n            # Check for value in patch\n            v_patch_nml = None\n            if v_name in patch_nml:\n                v_patch_nml = patch_nml.pop(v_name.lower())\n\n            if parent:\n                vpar = parent.get(v_name.lower())\n                if vpar and isinstance(vpar, list):\n                    # If new element is not a list, then assume it's the first\n                    # element of the list.\n                    if dt_idx is None:\n                        dt_idx = self.default_start_index\n\n                    try:\n                        v_parent = vpar[dt_idx]\n                    except IndexError:\n                        v_parent = Namelist()\n                elif vpar:\n                    v_parent = vpar\n                else:\n                    v_parent = Namelist()\n            else:\n                v_parent = Namelist()\n                parent[v_name] = v_parent\n\n            self._update_tokens()\n            self._update_tokens()\n\n            v_att, v_att_vals = self._parse_variable(\n                v_parent,\n                patch_nml=v_patch_nml\n            )\n\n            next_value = Namelist()\n            next_value[v_att] = v_att_vals\n            self._append_value(v_values, next_value, v_idx)\n\n        else:\n            # Construct the variable array\n\n            assert self.token == '='\n            n_vals = None\n\n            self._update_tokens()\n\n            # Check if value is in the namelist patch\n            # TODO: Edit `Namelist` to support case-insensitive `pop` calls\n            #       (Currently only a problem in PyPy2)\n            if v_name in patch_nml:\n                patch_values = patch_nml.pop(v_name.lower())\n\n                if not isinstance(patch_values, list):\n                    patch_values = [patch_values]\n\n                p_idx = 0\n\n            # Add variables until next variable trigger\n            while (self.token not in ('=', '(', '%') or\n                   (self.prior_token, self.token) in (('=', '('), (',', '('))):\n\n                # Check for repeated values\n                if self.token == '*':\n                    n_vals = self._parse_value()\n                    assert isinstance(n_vals, int)\n                    self._update_tokens()\n                elif not n_vals:\n                    n_vals = 1\n\n                # First check for implicit null values\n                if self.prior_token in ('=', '%', ','):\n                    if (self.token in (',', '/', '&', '$') and\n                            not (self.prior_token == ',' and\n                                 self.token in ('/', '&', '$'))):\n                        self._append_value(v_values, None, v_idx, n_vals)\n\n                elif self.prior_token == '*':\n\n                    if self.token not in ('/', '&', '$'):\n                        self._update_tokens()\n\n                    if (self.token == '=' or (self.token in ('/', '&', '$') and\n                                              self.prior_token == '*')):\n                        next_value = None\n                    else:\n                        next_value = self._parse_value()\n\n                    self._append_value(v_values, next_value, v_idx, n_vals)\n\n                else:\n                    next_value = self._parse_value()\n                    self._append_value(v_values, next_value, v_idx, n_vals)\n\n                # Reset default repeat factor for subsequent values\n                n_vals = 1\n\n                # Exit for end of nml group (/, &, $) or null broadcast (=)\n                if self.token in ('/', '&', '$', '='):\n                    break\n                else:\n                    # Get the remaining length of the unpatched vector?\n\n                    # NOTE: it is probably very inefficient to keep re-creating\n                    # iterators upon every element; this solution reflects the\n                    # absence of mature lookahead in the script.\n                    #\n                    # This is a temporary fix to address errors caused by\n                    # patches of different length from the original value, and\n                    # represents a direction to fully rewrite the parser using\n                    # `tee`.\n\n                    self.tokens, lookahead = itertools.tee(self.tokens)\n                    n_vals_remain = count_values(lookahead)\n\n                    if patch_values:\n                        # XXX: The (p_idx - 1) <= n_vals_remain test is dodgy\n                        # and does not really make sense to me, but it appears\n                        # to work.\n\n                        # TODO: Patch indices that are not set in the namelist\n\n                        if (p_idx < len(patch_values) and\n                                (p_idx - 1) <= n_vals_remain and\n                                len(patch_values) > 0 and self.token != ','):\n                            p_val = patch_values[p_idx]\n                            p_repr = patch_nml._f90repr(patch_values[p_idx])\n                            p_idx += 1\n                            self._update_tokens(override=p_repr)\n                            if isinstance(p_val, complex):\n                                # Skip over the complex content\n                                # NOTE: Assumes input and patch are complex\n                                self._update_tokens(write_token=False)\n                                self._update_tokens(write_token=False)\n                                self._update_tokens(write_token=False)\n                                self._update_tokens(write_token=False)\n                        else:\n                            # Skip any values beyond the patch size\n                            skip = (p_idx >= len(patch_values))\n                            self._update_tokens(patch_skip=skip)\n                    else:\n                        self._update_tokens()\n\n        if patch_values:\n            v_values = patch_values\n\n        if not v_idx:\n            v_values = delist(v_values)\n\n        return v_name, v_values", "response": "Parse a variable and return its name and values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a sequence of Fortran vector indices as a list of tuples.", "response": "def _parse_indices(self):\n        \"\"\"Parse a sequence of Fortran vector indices as a list of tuples.\"\"\"\n        v_name = self.prior_token\n        v_indices = []\n\n        while self.token in (',', '('):\n            v_indices.append(self._parse_index(v_name))\n\n        return v_indices"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing Fortran vector indices into a tuple of Python indices.", "response": "def _parse_index(self, v_name):\n        \"\"\"Parse Fortran vector indices into a tuple of Python indices.\"\"\"\n        i_start = i_end = i_stride = None\n\n        # Start index\n        self._update_tokens()\n        try:\n            i_start = int(self.token)\n            self._update_tokens()\n        except ValueError:\n            if self.token in (',', ')'):\n                raise ValueError('{0} index cannot be empty.'.format(v_name))\n            elif not self.token == ':':\n                raise\n\n        # End index\n        if self.token == ':':\n            self._update_tokens()\n            try:\n                i_end = 1 + int(self.token)\n                self._update_tokens()\n            except ValueError:\n                if self.token == ':':\n                    raise ValueError('{0} end index cannot be implicit '\n                                     'when using stride.'.format(v_name))\n                elif self.token not in (',', ')'):\n                    raise\n        elif self.token in (',', ')'):\n            # Replace index with single-index range\n            if i_start:\n                i_end = 1 + i_start\n\n        # Stride index\n        if self.token == ':':\n            self._update_tokens()\n            try:\n                i_stride = int(self.token)\n            except ValueError:\n                if self.token == ')':\n                    raise ValueError('{0} stride index cannot be '\n                                     'implicit.'.format(v_name))\n                else:\n                    raise\n\n            if i_stride == 0:\n                raise ValueError('{0} stride index cannot be zero.'\n                                 ''.format(v_name))\n\n            self._update_tokens()\n\n        if self.token not in (',', ')'):\n            raise ValueError('{0} index did not terminate '\n                             'correctly.'.format(v_name))\n\n        idx_triplet = (i_start, i_end, i_stride)\n        return idx_triplet"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_value(self, write_token=True, override=None):\n        v_str = self.prior_token\n\n        # Construct the complex string\n        if v_str == '(':\n            v_re = self.token\n\n            self._update_tokens(write_token)\n            assert self.token == ','\n\n            self._update_tokens(write_token)\n            v_im = self.token\n\n            self._update_tokens(write_token)\n            assert self.token == ')'\n\n            self._update_tokens(write_token, override)\n            v_str = '({0}, {1})'.format(v_re, v_im)\n\n        recast_funcs = [int, pyfloat, pycomplex, pybool, pystr]\n\n        for f90type in recast_funcs:\n            try:\n                # Unclever hack.. integrate this better\n                if f90type == pybool:\n                    value = pybool(v_str, self.strict_logical)\n                else:\n                    value = f90type(v_str)\n                return value\n            except ValueError:\n                continue", "response": "Convert string repr of Fortran type to equivalent Python type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _update_tokens(self, write_token=True, override=None,\n                       patch_skip=False):\n        \"\"\"Update tokens to the next available values.\"\"\"\n        next_token = next(self.tokens)\n\n        patch_value = ''\n        patch_tokens = ''\n\n        if self.pfile and write_token:\n            token = override if override else self.token\n            patch_value += token\n\n        while next_token[0] in self.comment_tokens + whitespace:\n            if self.pfile:\n                if next_token[0] in self.comment_tokens:\n                    while not next_token == '\\n':\n                        patch_tokens += next_token\n                        next_token = next(self.tokens)\n                patch_tokens += next_token\n\n            # Several sections rely on StopIteration to terminate token search\n            # If that occurs, dump the patched tokens immediately\n            try:\n                next_token = next(self.tokens)\n            except StopIteration:\n                if not patch_skip or next_token in ('=', '(', '%'):\n                    patch_tokens = patch_value + patch_tokens\n\n                if self.pfile:\n                    self.pfile.write(patch_tokens)\n                raise\n\n        # Write patched values and whitespace + comments to file\n        if not patch_skip or next_token in ('=', '(', '%'):\n            patch_tokens = patch_value + patch_tokens\n\n        if self.pfile:\n            self.pfile.write(patch_tokens)\n\n        # Update tokens, ignoring padding\n        self.token, self.prior_token = next_token, self.token", "response": "Update the tokens to the next available values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _append_value(self, v_values, next_value, v_idx=None, n_vals=1):\n        for _ in range(n_vals):\n            if v_idx:\n                try:\n                    v_i = next(v_idx)\n                except StopIteration:\n                    # Repeating commas are null-statements and can be ignored\n                    # Otherwise, we warn the user that this is a bad namelist\n                    if next_value is not None:\n                        warnings.warn('f90nml: warning: Value {0} is not assigned to '\n                              'any variable and has been removed.'\n                              ''.format(next_value))\n\n                    # There are more values than indices, so we stop here\n                    break\n\n                v_s = [self.default_start_index if idx is None else idx\n                       for idx in v_idx.first]\n\n                if not self.row_major:\n                    v_i = v_i[::-1]\n                    v_s = v_s[::-1]\n\n                # Multidimensional arrays\n                if not self.sparse_arrays:\n                    pad_array(v_values, list(zip(v_i, v_s)))\n\n                # We iterate inside the v_values and inspect successively\n                # deeper lists within the list tree.  If the requested index is\n                # missing, we re-size that particular entry.\n                # (NOTE: This is unnecessary when sparse_arrays is disabled.)\n\n                v_subval = v_values\n                for (i_v, i_s) in zip(v_i[:-1], v_s[:-1]):\n                    try:\n                        v_subval = v_subval[i_v - i_s]\n                    except IndexError:\n                        size = len(v_subval)\n                        v_subval.extend([] for _ in range(size, i_v - i_s + 1))\n                        v_subval = v_subval[i_v - i_s]\n\n                # On the deepest level, we explicitly assign the value\n                i_v, i_s = v_i[-1], v_s[-1]\n                try:\n                    v_subval[i_v - i_s] = next_value\n                except IndexError:\n                    size = len(v_subval)\n                    v_subval.extend(None for _ in range(size, i_v - i_s + 1))\n                    v_subval[i_v - i_s] = next_value\n            else:\n                v_values.append(next_value)", "response": "Append a value to a list of parsed values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprepare the URI for a request containing the current set of resources.", "response": "def _prepare_uri(self, service_name, **parameters):\n        \"\"\"Prepare the URI for a request\n\n        :param service_name: The target service\n        :type service_name: str\n        :param kwargs: query parameters\n        :return: The uri of the request\n        \"\"\"\n        query_parameters = []\n        for key, value in parameters.items():\n            if isinstance(value, (list, tuple)):\n                value = \",\".join([str(member) for member in value])\n            if isinstance(value, bool):\n                value = \"true\" if value else \"false\"\n            query_parameters.append(\"{}={}\".format(key, value))\n\n        if query_parameters:\n            uri = \"{}{}?{}\".format(self.base_url, service_name,\n                                   \"&\".join(query_parameters))\n        else:\n            uri = \"{}{}\".format(self.base_url, service_name)\n        return uri"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle rate exceeded errors", "response": "def _handle_rate_exceeded(self, response):  # pragma: no cover\n        \"\"\"Handles rate exceeded errors\"\"\"\n        waiting_time = int(response.headers.get(\"Retry-After\", 10))\n        time.sleep(waiting_time)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _send(self, send_method, service_name, data=None, **kwargs):\n        valid_response = False\n        raw = kwargs.pop(\"raw\", False)\n\n        while not valid_response:\n            headers = dict(Authorization=self.token)\n            uri = self._prepare_uri(service_name, **kwargs)\n            logger.debug(' '.join(map(str, (headers, uri, data))))\n\n            response = send_method(uri, headers=headers, json=data)\n            content_type = response.headers[\"Content-Type\"].split(\";\")[0]\n\n            if response.content and content_type == \"application/json\":\n                response_data = response.json()\n                if \"response\" in response_data:\n                    response_data = response_data[\"response\"]\n            elif response.content:\n                return response.content\n            else:\n                return None\n\n            try:\n                self.check_errors(response, response_data)\n            except RateExceeded:\n                self._handle_rate_exceeded(response)\n            except NoAuth:\n                self.update_token()\n            else:\n                valid_response = True\n        if raw:\n            return response.json()\n        return response_data", "response": "Send a request to the AppNexus API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrequest a new token and store it for future use", "response": "def update_token(self):\n        \"\"\"Request a new token and store it for future use\"\"\"\n        logger.info('updating token')\n        if None in self.credentials.values():\n            raise RuntimeError(\"You must provide an username and a password\")\n        credentials = dict(auth=self.credentials)\n        url = self.test_url if self.test else self.url\n        response = requests.post(url + \"auth\",\n                                 json=credentials)\n        data = response.json()[\"response\"]\n        if \"error_id\" in data and data[\"error_id\"] == \"NOAUTH\":\n            raise BadCredentials()\n        if \"error_code\" in data and data[\"error_code\"] == \"RATE_EXCEEDED\":\n            time.sleep(150)\n            return\n        if \"error_code\" in data or \"error_id\" in data:\n            raise AppNexusException(response)\n        self.token = data[\"token\"]\n        self.save_token()\n        return self.token"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck for errors and raise an appropriate error if needed", "response": "def check_errors(self, response, data):\n        \"\"\"Check for errors and raise an appropriate error if needed\"\"\"\n        if \"error_id\" in data:\n            error_id = data[\"error_id\"]\n            if error_id in self.error_ids:\n                raise self.error_ids[error_id](response)\n        if \"error_code\" in data:\n            error_code = data[\"error_code\"]\n            if error_code in self.error_codes:\n                raise self.error_codes[error_code](response)\n        if \"error_code\" in data or \"error_id\" in data:\n            raise AppNexusException(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves data from AppNexus API", "response": "def get(self, service_name, **kwargs):\n        \"\"\"Retrieve data from AppNexus API\"\"\"\n        return self._send(requests.get, service_name, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef modify(self, service_name, json, **kwargs):\n        return self._send(requests.put, service_name, json, **kwargs)", "response": "Modify an AppNexus object"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new AppNexus object", "response": "def create(self, service_name, json, **kwargs):\n        \"\"\"Create a new AppNexus object\"\"\"\n        return self._send(requests.post, service_name, json, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete(self, service_name, *ids, **kwargs):\n        return self._send(requests.delete, service_name, id=ids, **kwargs)", "response": "Delete an AppNexus object"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplot the current object at the given coordinates.", "response": "def plot(self, x, y, color=\"black\"):\n        \"\"\"\n        Uses coordinant system.\n        \"\"\"\n        p = Point(x, y)\n        p.fill(color)\n        p.draw(self)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nplotting a single pixel of the current object.", "response": "def plotPixel(self, x, y, color=\"black\"):\n        \"\"\"\n        Doesn't use coordinant system.\n        \"\"\"\n        p = Point(x, y)\n        p.fill(color)\n        p.draw(self)\n        p.t = lambda v: v\n        p.tx = lambda v: v\n        p.ty = lambda v: v"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getMouse(self):\n        # FIXME: this isn't working during an executing cell\n        self.mouse_x.value = -1\n        self.mouse_y.value = -1\n        while self.mouse_x.value == -1 and self.mouse_y.value == -1:\n            time.sleep(.1)\n        return (self.mouse_x.value, self.mouse_y.value)", "response": "Waits for a mouse click. Returns the mouse coordinates."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef event_html_page_context(app, pagename, templatename, context, doctree):\n    assert app or pagename or templatename  # Unused, for linting.\n    if 'script_files' in context and doctree and any(hasattr(n, 'disqus_shortname') for n in doctree.traverse()):\n        # Clone list to prevent leaking into other pages and add disqus.js to this page.\n        context['script_files'] = context['script_files'][:] + ['_static/disqus.js']", "response": "Called when the HTML builder has created a context dictionary to render a template with."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup(app):\n    app.add_config_value('disqus_shortname', None, True)\n    app.add_directive('disqus', DisqusDirective)\n    app.add_node(DisqusNode, html=(DisqusNode.visit, DisqusNode.depart))\n    app.config.html_static_path.append(os.path.relpath(STATIC_DIR, app.confdir))\n    app.connect('html-page-context', event_html_page_context)\n    return dict(version=__version__)", "response": "Called by Sphinx during phase 1."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef visit(spht, node):\n        html_attrs = {\n            'ids': ['disqus_thread'],\n            'data-disqus-shortname': node.disqus_shortname,\n            'data-disqus-identifier': node.disqus_identifier,\n        }\n        spht.body.append(spht.starttag(node, 'div', '', **html_attrs))", "response": "Append opening tags to document body list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_shortname(self):\n        disqus_shortname = self.state.document.settings.env.config.disqus_shortname\n        if not disqus_shortname:\n            raise ExtensionError('disqus_shortname config value must be set for the disqus extension to work.')\n        if not RE_SHORTNAME.match(disqus_shortname):\n            raise ExtensionError('disqus_shortname config value must be 3-50 letters, numbers, and hyphens only.')\n        return disqus_shortname", "response": "Validate and returns disqus_shortname config value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate and returns disqus_identifier option value.", "response": "def get_identifier(self):\n        \"\"\"Validate and returns disqus_identifier option value.\n\n        :returns: disqus_identifier config value.\n        :rtype: str\n        \"\"\"\n        if 'disqus_identifier' in self.options:\n            return self.options['disqus_identifier']\n\n        title_nodes = self.state.document.traverse(nodes.title)\n        if not title_nodes:\n            raise DisqusError('No title nodes found in document, cannot derive disqus_identifier config value.')\n        return title_nodes[0].astext()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute by Sphinx. :returns: Single DisqusNode instance with config values passed as arguments. :rtype: list", "response": "def run(self):\n        \"\"\"Executed by Sphinx.\n\n        :returns: Single DisqusNode instance with config values passed as arguments.\n        :rtype: list\n        \"\"\"\n        disqus_shortname = self.get_shortname()\n        disqus_identifier = self.get_identifier()\n        return [DisqusNode(disqus_shortname, disqus_identifier)]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef attach(func, params):\n\tsig = inspect.signature(func)\n\tparams = Projection(sig.parameters.keys(), params)\n\treturn functools.partial(func, **params)", "response": "Given a function and a namespace of possible parameters attach any params matching the signature of the function to that function."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_config(overrides):\n\tpmxbot.config = config = ConfigDict()\n\tconfig.setdefault('bot_nickname', 'pmxbot')\n\tconfig.update(overrides)\n\treturn config", "response": "Initialize the config dict with the given overrides."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing the bot with a dictionary of config items", "response": "def initialize(config):\n\t\"Initialize the bot with a dictionary of config items\"\n\tconfig = init_config(config)\n\n\t_setup_logging()\n\t_load_library_extensions()\n\tif not Handler._registry:\n\t\traise RuntimeError(\"No handlers registered\")\n\n\tclass_ = _load_bot_class()\n\n\tconfig.setdefault('log_channels', [])\n\tconfig.setdefault('other_channels', [])\n\n\tchannels = config.log_channels + config.other_channels\n\n\tlog.info('Running with config')\n\tlog.info(pprint.pformat(config))\n\n\thost = config.get('server_host', 'localhost')\n\tport = config.get('server_port', 6667)\n\n\treturn class_(\n\t\thost,\n\t\tport,\n\t\tconfig.bot_nickname,\n\t\tchannels=channels,\n\t\tpassword=config.get('password'),\n\t)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load_filters():\n\tgroup = 'pmxbot_filters'\n\teps = entrypoints.get_group_all(group=group)\n\treturn [ep.load() for ep in eps]", "response": "Load all filters from the entrypoints."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef augment_items(cls, items, **defaults):\n\t\tproperties = defaults\n\t\tfor item in items:\n\t\t\t# allow the Sentinel to be just the class itself, which is to be\n\t\t\t#  constructed with no parameters.\n\t\t\tif isinstance(item, type) and issubclass(item, Sentinel):\n\t\t\t\titem = item()\n\t\t\tif isinstance(item, Sentinel):\n\t\t\t\tproperties.update(item.properties)\n\t\t\t\tcontinue\n\t\t\tyield AugmentableMessage(item, **properties)", "response": "Iterate over the items keeping a adding properties as supplied by the Sentinel objects encountered."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_matching(cls, message, channel):\n\t\treturn (\n\t\t\thandler\n\t\t\tfor handler in cls._registry\n\t\t\tif isinstance(handler, cls)\n\t\t\tand handler.match(message, channel)\n\t\t)", "response": "Find all subclasses that match message and channel."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decorate(self, func):\n\t\tself.func = func\n\t\tself._set_implied_name()\n\t\tself.register()\n\t\treturn func", "response": "Decorate a handler function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_implied_name(self):\n\t\t\"Allow the name of this handler to default to the function name.\"\n\t\tif getattr(self, 'name', None) is None:\n\t\t\tself.name = self.func.__name__\n\t\tself.name = self.name.lower()", "response": "Allow the name of this handler to default to the function name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the docstring of the function.", "response": "def _set_doc(self, func):\n\t\t\"\"\"\n\t\tIf no doc was explicitly set, use the function's docstring, trimming\n\t\twhitespace and replacing newlines with spaces.\n\t\t\"\"\"\n\t\tif not self.doc and func.__doc__:\n\t\t\tself.doc = func.__doc__.strip().replace('\\n', ' ')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nallowing plugins to filter content.", "response": "def allow(self, channel, message):\n\t\t\"\"\"\n\t\tAllow plugins to filter content.\n\t\t\"\"\"\n\t\treturn all(\n\t\t\tfilter(channel, message)\n\t\t\tfor filter in _load_filters()\n\t\t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle output from the master.", "response": "def _handle_output(self, channel, output):\n\t\t\"\"\"\n\t\tGiven an initial channel and a sequence of messages or sentinels,\n\t\toutput the messages.\n\t\t\"\"\"\n\t\taugmented = Sentinel.augment_items(output, channel=channel, secret=False)\n\t\tfor message in augmented:\n\t\t\tself.out(message.channel, message, not message.secret)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_action(self, channel, nick, msg):\n\t\t\"Core message parser and dispatcher\"\n\n\t\tmessages = ()\n\t\tfor handler in Handler.find_matching(msg, channel):\n\t\t\texception_handler = functools.partial(\n\t\t\t\tself._handle_exception,\n\t\t\t\thandler=handler,\n\t\t\t)\n\t\t\trest = handler.process(msg)\n\t\t\tclient = connection = event = None\n\t\t\t# for regexp handlers\n\t\t\tmatch = rest\n\t\t\tf = handler.attach(locals())\n\t\t\tresults = pmxbot.itertools.generate_results(f)\n\t\t\tclean_results = pmxbot.itertools.trap_exceptions(results, exception_handler)\n\t\t\tmessages = itertools.chain(messages, clean_results)\n\t\t\tif not handler.allow_chain:\n\t\t\t\tbreak\n\t\tself._handle_output(channel, messages)", "response": "Core message parser and dispatcher"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_scheduled(self, target):\n\t\tif not isinstance(target, Handler):\n\t\t\treturn target()\n\n\t\treturn self._handle_scheduled(target)", "response": "target is a Handler or simple callable"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs a leave or part event.", "response": "def log_leave(event, nick, channel):\n\t\"\"\"\n\tLog a quit or part event.\n\t\"\"\"\n\tif channel not in pmxbot.config.log_channels:\n\t\treturn\n\tParticipantLogger.store.log(nick, channel, event.type)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef karma(nick, rest):\n\t\"Return or change the karma value for some(one|thing)\"\n\tkarmee = rest.strip('++').strip('--').strip('~~')\n\tif '++' in rest:\n\t\tKarma.store.change(karmee, 1)\n\telif '--' in rest:\n\t\tKarma.store.change(karmee, -1)\n\telif '~~' in rest:\n\t\tchange = random.choice([-1, 0, 1])\n\t\tKarma.store.change(karmee, change)\n\t\tif change == 1:\n\t\t\treturn \"%s karma++\" % karmee\n\t\telif change == 0:\n\t\t\treturn \"%s karma shall remain the same\" % karmee\n\t\telif change == -1:\n\t\t\treturn \"%s karma--\" % karmee\n\telif '==' in rest:\n\t\tt1, t2 = rest.split('==')\n\t\ttry:\n\t\t\tKarma.store.link(t1, t2)\n\t\texcept SameName:\n\t\t\tKarma.store.change(nick, -1)\n\t\t\treturn \"Don't try to link a name to itself!\"\n\t\texcept AlreadyLinked:\n\t\t\treturn \"Those names were previously linked.\"\n\t\tscore = Karma.store.lookup(t1)\n\t\treturn \"%s and %s are now linked and have a score of %s\" % (t1, t2, score)\n\telse:\n\t\tkarmee = rest or nick\n\t\tscore = Karma.store.lookup(karmee)\n\t\treturn \"%s has %s karmas\" % (karmee, score)", "response": "Return or change the karma value for some one|thing"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef top10(rest):\n\tif rest:\n\t\ttopn = int(rest)\n\telse:\n\t\ttopn = 10\n\tselection = Karma.store.list(topn)\n\tres = ' '.join('(%s: %s)' % (', '.join(n), k) for n, k in selection)\n\treturn res", "response": "Return the top n highest entities by Karmic value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef link(self, thing1, thing2):\n\t\tthing1 = thing1.strip().lower()\n\t\tthing2 = thing2.strip().lower()\n\t\tif thing1 == thing2:\n\t\t\traise SameName(\"Attempted to link two of the same name\")\n\t\tself.change(thing1, 0)\n\t\tself.change(thing2, 0)\n\t\treturn self._link(thing1, thing2)", "response": "Link thing1 and thing2."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get(self, id):\n\t\t\"Return keys and value for karma id\"\n\t\tVALUE_SQL = \"SELECT karmavalue from karma_values where karmaid = ?\"\n\t\tKEYS_SQL = \"SELECT karmakey from karma_keys where karmaid = ?\"\n\t\tvalue = self.db.execute(VALUE_SQL, [id]).fetchall()[0][0]\n\t\tkeys_cur = self.db.execute(KEYS_SQL, [id]).fetchall()\n\t\tkeys = sorted(x[0] for x in keys_cur)\n\t\treturn keys, value", "response": "Return keys and value for karma id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef repair_duplicate_names(self):\n\t\tfor name in self._all_names():\n\t\t\tcur = self.db.find({'names': name})\n\t\t\tmain_doc = next(cur)\n\t\t\tfor duplicate in cur:\n\t\t\t\tquery = {'_id': main_doc['_id']}\n\t\t\t\tupdate = {\n\t\t\t\t\t'$inc': {'value': duplicate['value']},\n\t\t\t\t\t'$push': {'names': {'$each': duplicate['names']}},\n\t\t\t\t}\n\t\t\t\tself.db.update(query, update)\n\t\t\t\tself.db.remove(duplicate)", "response": "This routine repairs duplicate names in the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlooking up a message from the database.", "response": "def lookup(self, nick):\n\t\tquery = \"\"\"\n\t\t\tSELECT fromnick, message, notifytime, notifyid\n\t\t\tFROM notify WHERE tonick = ?\n\t\t\"\"\"\n\t\t''' Ugly, but will work with sqlite3 or pysqlite2 '''\n\t\tmessages = [\n\t\t\t{\n\t\t\t\t'fromnick': x[0],\n\t\t\t\t'message': x[1],\n\t\t\t\t'notifytime': x[2],\n\t\t\t\t'notifyid': x[3],\n\t\t\t}\n\t\t\tfor x in self.db.execute(query, [nick])\n\t\t]\n\t\tids = [x['notifyid'] for x in messages]\n\t\tquery = \"\"\"\n\t\t\tDELETE FROM notify\n\t\t\tWHERE notifyid IN (%s)\n\t\t\t\"\"\" % ','.join('?' for x in ids)\n\t\tself.db.execute(query, ids)\n\n\t\treturn messages"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef google(rest):\n\t\"Look up a phrase on google\"\n\tAPI_URL = 'https://www.googleapis.com/customsearch/v1?'\n\ttry:\n\t\tkey = pmxbot.config['Google API key']\n\texcept KeyError:\n\t\treturn \"Configure 'Google API key' in config\"\n\t# Use a custom search that searches everything normally\n\t# http://stackoverflow.com/a/11206266/70170\n\tcustom_search = '004862762669074674786:hddvfu0gyg0'\n\tparams = dict(\n\t\tkey=key,\n\t\tcx=custom_search,\n\t\tq=rest.strip(),\n\t)\n\turl = API_URL + urllib.parse.urlencode(params)\n\tresp = requests.get(url)\n\tresp.raise_for_status()\n\tresults = resp.json()\n\thit1 = next(iter(results['items']))\n\treturn ' - '.join((\n\t\turllib.parse.unquote(hit1['link']),\n\t\thit1['title'],\n\t))", "response": "Look up a phrase on google"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef troutslap(rest):\n\t\"Slap some(one|thing) with a fish\"\n\tslapee = rest\n\tkarma.Karma.store.change(slapee, -1)\n\treturn \"/me slaps %s around a bit with a large trout\" % slapee", "response": "Slap some ( one|thing with a fish"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef keelhaul(rest):\n\t\"Inflict great pain and embarassment on some(one|thing)\"\n\tkeelee = rest\n\tkarma.Karma.store.change(keelee, -1)\n\treturn (\n\t\t\"/me straps %s to a dirty rope, tosses 'em overboard and pulls \"\n\t\t\"with great speed. Yarrr!\" % keelee)", "response": "Inflict great pain and embarassment on some ( one|thing )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef annoy():\n\t\"Annoy everyone with meaningless banter\"\n\tdef a1():\n\t\tyield 'OOOOOOOHHH, WHAT DO YOU DO WITH A DRUNKEN SAILOR'\n\t\tyield 'WHAT DO YOU DO WITH A DRUNKEN SAILOR'\n\t\tyield \"WHAT DO YOU DO WITH A DRUNKEN SAILOR, EARLY IN THE MORNIN'?\"\n\n\tdef a2():\n\t\tyield \"I'M HENRY THE EIGHTH I AM\"\n\t\tyield \"HENRY THE EIGHTH I AM I AM\"\n\t\tyield (\n\t\t\t\"I GOT MARRIED TO THE GIRL NEXT DOOR; SHE'S BEEN MARRIED \"\n\t\t\t\"SEVEN TIMES BEFORE\")\n\n\tdef a3():\n\t\tyield \"BOTHER!\"\n\t\tyield \"BOTHER BOTHER BOTHER!\"\n\t\tyield \"BOTHER BOTHER BOTHER BOTHER!\"\n\n\tdef a4():\n\t\tyield \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\t\tyield \"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\"\n\t\tyield \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\n\tdef a5():\n\t\tyield \"YOUR MOTHER WAS A HAMSTER!\"\n\t\tyield \"AND YOUR FATHER SMELLED OF ELDERBERRIES!\"\n\n\tdef a6():\n\t\tyield(\n\t\t\t\"My Tallest! My Tallest! Hey! Hey My Tallest! My Tallest? My \"\n\t\t\t\"Tallest! Hey! Hey! Hey! My Taaaaaaallist! My Tallest? My \"\n\t\t\t\"Tallest! Hey! Hey My Tallest! My Tallest? It's me! My Tallest? \"\n\t\t\t\"My Tallest!\")\n\treturn random.choice([a1, a2, a3, a4, a5, a6])()", "response": "A basic annoy command."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef featurecreep():\n\t\"Generate feature creep (P+C http://www.dack.com/web/bullshit.html)\"\n\tverb = random.choice(phrases.fcverbs).capitalize()\n\tadjective = random.choice(phrases.fcadjectives)\n\tnoun = random.choice(phrases.fcnouns)\n\treturn '%s %s %s!' % (verb, adjective, noun)", "response": "Generate feature creep ( P + C http://www. dack. com / web / bullshit. html )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a job title http://www. cubefigures. com / job. html", "response": "def job():\n\t\"Generate a job title, http://www.cubefigures.com/job.html\"\n\tj1 = random.choice(phrases.jobs1)\n\tj2 = random.choice(phrases.jobs2)\n\tj3 = random.choice(phrases.jobs3)\n\treturn '%s %s %s' % (j1, j2, j3)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nasking the magic 8ball a question", "response": "def eball(rest):\n\t\"Ask the magic 8ball a question\"\n\ttry:\n\t\turl = 'https://8ball.delegator.com/magic/JSON/'\n\t\turl += rest\n\t\tresult = requests.get(url).json()['magic']['answer']\n\texcept Exception:\n\t\tresult = util.wchoice(phrases.ball8_opts)\n\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrolling a die default = 100.", "response": "def roll(rest, nick):\n\t\"Roll a die, default = 100.\"\n\tif rest:\n\t\trest = rest.strip()\n\t\tdie = int(rest)\n\telse:\n\t\tdie = 100\n\tmyroll = random.randint(1, die)\n\treturn \"%s rolls %s\" % (nick, myroll)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlooking up a ticker symbol s current trading value", "response": "def ticker(rest):\n\t\"Look up a ticker symbol's current trading value\"\n\tticker = rest.upper()\n\t# let's use Yahoo's nifty csv facility, and pull last time/price both\n\tsymbol = 's'\n\tlast_trade_price = 'l1'\n\tlast_trade_time = 't1'\n\tchange_percent = 'p2'\n\tformat = ''.join((symbol, last_trade_time, last_trade_price, change_percent))\n\turl = (\n\t\t'http://finance.yahoo.com/d/quotes.csv?s=%(ticker)s&f=%(format)s'\n\t\t% locals())\n\tstock_info = csv.reader(util.open_url(url).text.splitlines())\n\tlast_trade, = stock_info\n\tticker_given, time, price, diff = last_trade\n\tif ticker_given != ticker:\n\t\treturn \"d'oh... could not find information for symbol %s\" % ticker\n\treturn '%(ticker)s at %(time)s (ET): %(price)s (%(diff)s)' % locals()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npicks between a few options", "response": "def pick(rest):\n\t\"Pick between a few options\"\n\tquestion = rest.strip()\n\tchoices = util.splitem(question)\n\tif len(choices) == 1:\n\t\treturn \"I can't pick if you give me only one choice!\"\n\telse:\n\t\tpick = random.choice(choices)\n\t\tcertainty = random.sample(phrases.certainty_opts, 1)[0]\n\t\treturn \"%s... %s %s\" % (pick, certainty, pick)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lunch(rest):\n\t\"Pick where to go to lunch\"\n\trs = rest.strip()\n\tif not rs:\n\t\treturn \"Give me an area and I'll pick a place: (%s)\" % (\n\t\t\t', '.join(list(pmxbot.config.lunch_choices)))\n\tif rs not in pmxbot.config.lunch_choices:\n\t\treturn \"I didn't recognize that area; here's what i have: (%s)\" % (\n\t\t\t', '.join(list(pmxbot.config.lunch_choices)))\n\tchoices = pmxbot.config.lunch_choices[rs]\n\treturn random.choice(choices)", "response": "Pick where to go to lunch"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef password(rest):\n\tcharsets = [\n\t\tstring.ascii_lowercase,\n\t\tstring.ascii_uppercase,\n\t\tstring.digits,\n\t\tstring.punctuation,\n\t]\n\tpasswd = []\n\n\ttry:\n\t\tlength = rest.strip() or 12\n\t\tlength = int(length)\n\texcept ValueError:\n\t\treturn 'need an integer password length!'\n\n\tfor i in range(length):\n\t\tpasswd.append(random.choice(''.join(charsets)))\n\n\tif length >= len(charsets):\n\t\t# Ensure we have at least one character from each charset\n\t\treplacement_indices = random.sample(range(length), len(charsets))\n\t\tfor i, charset in zip(replacement_indices, charsets):\n\t\t\tpasswd[i] = random.choice(charset)\n\n\treturn ''.join(passwd)", "response": "Generate a random password"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insult(rest):\n\t\"Generate a random insult from datahamster\"\n\t# not supplying any style will automatically redirect to a random\n\turl = 'http://autoinsult.datahamster.com/'\n\tins_type = random.randrange(4)\n\tins_url = url + \"?style={ins_type}\".format(**locals())\n\tinsre = re.compile('<div class=\"insult\" id=\"insult\">(.*?)</div>')\n\tresp = requests.get(ins_url)\n\tresp.raise_for_status()\n\tinsult = insre.search(resp.text).group(1)\n\tif not insult:\n\t\treturn\n\tif rest:\n\t\tinsultee = rest.strip()\n\t\tkarma.Karma.store.change(insultee, -1)\n\t\tif ins_type in (0, 2):\n\t\t\tcinsre = re.compile(r'\\b(your)\\b', re.IGNORECASE)\n\t\t\tinsult = cinsre.sub(\"%s's\" % insultee, insult)\n\t\telif ins_type in (1, 3):\n\t\t\tcinsre = re.compile(r'^([TY])')\n\t\t\tinsult = cinsre.sub(\n\t\t\t\tlambda m: \"%s, %s\" % (\n\t\t\t\t\tinsultee, m.group(1).lower()), insult)\n\treturn insult", "response": "Generate a random insult from datahamster"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compliment(rest):\n\tcompurl = 'http://www.madsci.org/cgi-bin/cgiwrap/~lynn/jardin/SCG'\n\tcomphtml = ''.join([i.decode() for i in urllib.request.urlopen(compurl)])\n\tcompmark1 = '<h2>\\n\\n'\n\tcompmark2 = '\\n</h2>'\n\tcompliment = comphtml[\n\t\tcomphtml.find(compmark1) + len(compmark1):comphtml.find(compmark2)]\n\tif compliment:\n\t\tcompliment = re.compile(r'\\n').sub('%s' % ' ', compliment)\n\t\tcompliment = re.compile(r'  ').sub('%s' % ' ', compliment)\n\t\tif rest:\n\t\t\tcomplimentee = rest.strip()\n\t\t\tkarma.Karma.store.change(complimentee, 1)\n\t\t\tcompliment = re.compile(r'\\b(your)\\b', re.IGNORECASE).sub(\n\t\t\t\t'%s\\'s' % complimentee, compliment)\n\t\t\tcompliment = re.compile(r'\\b(you are)\\b', re.IGNORECASE).sub(\n\t\t\t\t'%s is' % complimentee, compliment)\n\t\t\tcompliment = re.compile(r'\\b(you have)\\b', re.IGNORECASE).sub(\n\t\t\t\t'%s has' % complimentee, compliment)\n\t\treturn compliment", "response": "Generate a random compliment from\n\thttp://www. madsci. org"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a random compliment from http://emergencycompliment. com/\"", "response": "def emer_comp(rest):\n\t\"Return a random compliment from http://emergencycompliment.com/\"\n\tcomps = util.load_emergency_compliments()\n\tcompliment = random.choice(comps)\n\tif rest:\n\t\tcomplimentee = rest.strip()\n\t\tkarma.Karma.store.change(complimentee, 1)\n\t\treturn \"%s: %s\" % (complimentee, compliment)\n\treturn compliment"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget toorks a user.", "response": "def gettowork(channel, nick, rest):\n\t\"You really ought to, ya know...\"\n\tsuggestions = [\n\t\t\"Um, might I suggest working now\",\n\t\t\"Get to work\",\n\t\t(\n\t\t\t\"Between the coffee break, the smoking break, the lunch break, \"\n\t\t\t\"the tea break, the bagel break, and the water cooler break, \"\n\t\t\t\"may I suggest a work break.  It\u2019s when you do some work\"\n\t\t),\n\t\t\"Work faster\",\n\t\t\"I didn\u2019t realize we paid people for doing that\",\n\t\t\"You aren't being paid to believe in the power of your dreams\",\n\t]\n\tsuggestion = random.choice(suggestions)\n\trest = rest.strip()\n\tif rest:\n\t\tkarma.Karma.store.change(rest, -1)\n\t\tsuggestion = suggestion + ', %s' % rest\n\telse:\n\t\tkarma.Karma.store.change(channel, -1)\n\tkarma.Karma.store.change(nick, -1)\n\treturn suggestion"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstabbing shank or shiv some ( one|thing!", "response": "def stab(nick, rest):\n\t\"Stab, shank or shiv some(one|thing)!\"\n\tif rest:\n\t\tstabee = rest\n\telse:\n\t\tstabee = 'wildly at anything'\n\tif random.random() < 0.9:\n\t\tkarma.Karma.store.change(stabee, -1)\n\t\tweapon = random.choice(phrases.weapon_opts)\n\t\tweaponadj = random.choice(phrases.weapon_adjs)\n\t\tviolentact = random.choice(phrases.violent_acts)\n\t\treturn \"/me grabs a %s %s and %s %s!\" % (\n\t\t\tweaponadj, weapon, violentact, stabee)\n\telif random.random() < 0.6:\n\t\tkarma.Karma.store.change(stabee, -1)\n\t\treturn (\n\t\t\t\"/me is going to become rich and famous after i invent a \"\n\t\t\t\"device that allows you to stab people in the face over the \"\n\t\t\t\"internet\")\n\telse:\n\t\tkarma.Karma.store.change(nick, -1)\n\t\treturn (\n\t\t\t\"/me turns on its master and shivs %s. This is reality man, \"\n\t\t\t\"and you never know what you're going to get!\" % nick)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef disembowel(rest):\n\t\"Disembowel some(one|thing)!\"\n\tif rest:\n\t\tstabee = rest\n\t\tkarma.Karma.store.change(stabee, -1)\n\telse:\n\t\tstabee = \"someone nearby\"\n\treturn (\n\t\t\"/me takes %s, brings them down to the basement, ties them to a \"\n\t\t\"leaky pipe, and once bored of playing with them mercifully \"\n\t\t\"ritually disembowels them...\" % stabee)", "response": "Disembowel some ( one|thing!"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calc(rest):\n\t\"Perform a basic calculation\"\n\tmo = calc_exp.match(rest)\n\tif mo:\n\t\ttry:\n\t\t\treturn str(eval(rest))\n\t\texcept Exception:\n\t\t\treturn \"eval failed... check your syntax\"\n\telse:\n\t\treturn \"misformatted arithmetic!\"", "response": "Perform a basic calculation"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndefines a word with Urban Dictionary", "response": "def urbandict(rest):\n\t\"Define a word with Urban Dictionary\"\n\tword = rest.strip()\n\tdefinition = util.urban_lookup(word)\n\tif not definition:\n\t\treturn \"Arg!  I didn't find a definition for that.\"\n\treturn 'Urban Dictionary says {word}: {definition}'.format(**locals())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlooks up an acronym", "response": "def acit(rest):\n\t\"Look up an acronym\"\n\tword = rest.strip()\n\tres = util.lookup_acronym(word)\n\tif res is None:\n\t\treturn \"Arg!  I couldn't expand that...\"\n\telse:\n\t\treturn ' | '.join(res)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fight(nick, rest):\n\t\"Pit two sworn enemies against each other (separate with 'vs.')\"\n\tif rest:\n\t\tvtype = random.choice(phrases.fight_victories)\n\t\tfdesc = random.choice(phrases.fight_descriptions)\n\t\t# valid separators are vs., v., and vs\n\t\tpattern = re.compile('(.*) (?:vs[.]?|v[.]) (.*)')\n\t\tmatcher = pattern.match(rest)\n\t\tif not matcher:\n\t\t\tkarma.Karma.store.change(nick.lower(), -1)\n\t\t\targs = (vtype, nick, fdesc)\n\t\t\treturn \"/me %s %s in %s for bad protocol.\" % args\n\t\tcontenders = [c.strip() for c in matcher.groups()]\n\t\trandom.shuffle(contenders)\n\t\twinner, loser = contenders\n\t\tkarma.Karma.store.change(winner, 1)\n\t\tkarma.Karma.store.change(loser, -1)\n\t\treturn \"%s %s %s in %s.\" % (winner, vtype, loser, fdesc)", "response": "Pit two sworn enemies against each other ( separate with vs. )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef progress(rest):\n\t\"Display the progress of something: start|end|percent\"\n\tif rest:\n\t\tleft, right, amount = [piece.strip() for piece in rest.split('|')]\n\t\tticks = min(int(round(float(amount) / 10)), 10)\n\t\tbar = \"=\" * ticks\n\t\treturn \"%s [%-10s] %s\" % (left, bar, right)", "response": "Display the progress of something start | end | percent"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a random passive - agressive comment.", "response": "def nastygram(nick, rest):\n\t\"\"\"\n\tA random passive-agressive comment, optionally directed toward\n\tsome(one|thing).\n\t\"\"\"\n\trecipient = \"\"\n\tif rest:\n\t\trecipient = rest.strip()\n\t\tkarma.Karma.store.change(recipient, -1)\n\treturn util.passagg(recipient, nick.lower())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef meaculpa(nick, rest):\n\t\"Sincerely apologize\"\n\tif rest:\n\t\trest = rest.strip()\n\n\tif rest:\n\t\treturn random.choice(phrases.direct_apologies) % dict(a=nick, b=rest)\n\telse:\n\t\treturn random.choice(phrases.apologies) % dict(a=nick)", "response": "Meaculpa s sincerely apologize"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef version(rest):\n\t\"Get the version of pmxbot or one of its plugins\"\n\tpkg = rest.strip() or 'pmxbot'\n\tif pkg.lower() == 'python':\n\t\treturn sys.version.split()[0]\n\treturn importlib_metadata.version(pkg)", "response": "Get the version of pmxbot or one of its plugins"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert date between timezones.", "response": "def timezone(rest):\n\t\"\"\"Convert date between timezones.\n\n\tExample:\n\t> !tz 11:00am UTC in PDT\n\t11:00 UTC -> 4:00 PDT\n\n\tUTC is implicit\n\n\t> !tz 11:00am in PDT\n\t11:00 UTC -> 4:00 PDT\n\n\t> !tz 11:00am PDT\n\t11:00 PDT -> 18:00 UTC\n\n\t\"\"\"\n\n\tif ' in ' in rest:\n\t\tdstr, tzname = rest.split(' in ', 1)\n\telse:\n\t\tdstr, tzname = rest, 'UTC'\n\n\ttzobj = TZINFOS[tzname.strip()]\n\tdt = dateutil.parser.parse(dstr, tzinfos=TZINFOS)\n\tif dt.tzinfo is None:\n\t\tdt = pytz.UTC.localize(dt)\n\tres = dt.astimezone(tzobj)\n\treturn '{} {} -> {} {}'.format(\n\t\tdt.strftime('%H:%M'), dt.tzname() or dt.strftime('%z'),\n\t\tres.strftime('%H:%M'), tzname)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete the various persistence objects", "response": "def finalize(cls):\n\t\t\"Delete the various persistence objects\"\n\t\tfor finalizer in cls._finalizers:\n\t\t\ttry:\n\t\t\t\tfinalizer()\n\t\t\texcept Exception:\n\t\t\t\tlog.exception(\"Error in finalizer %s\", finalizer)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef help(rest):\n\trs = rest.strip()\n\tif rs:\n\t\t# give help for matching commands\n\t\tfor handler in Handler._registry:\n\t\t\tif handler.name == rs.lower():\n\t\t\t\tyield '!%s: %s' % (handler.name, handler.doc)\n\t\t\t\tbreak\n\t\telse:\n\t\t\tyield \"command not found\"\n\t\treturn\n\n\t# give help for all commands\n\tdef mk_entries():\n\t\thandlers = (\n\t\t\thandler\n\t\t\tfor handler in Handler._registry\n\t\t\tif type(handler) is pmxbot.core.CommandHandler\n\t\t)\n\t\thandlers = sorted(handlers, key=operator.attrgetter('name'))\n\t\tfor handler in handlers:\n\t\t\tres = \"!\" + handler.name\n\t\t\tif handler.aliases:\n\t\t\t\talias_names = (alias.name for alias in handler.aliases)\n\t\t\t\tres += \" (%s)\" % ', '.join(alias_names)\n\t\t\tyield res\n\to = io.StringIO(\" \".join(mk_entries()))\n\tmore = o.read(160)\n\twhile more:\n\t\tyield more\n\t\ttime.sleep(0.3)\n\t\tmore = o.read(160)", "response": "Help for this command"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the month name and year", "response": "def pmon(month):\n\t\"\"\"\n\tP the month\n\n\t>>> print(pmon('2012-08'))\n\tAugust, 2012\n\t\"\"\"\n\tyear, month = month.split('-')\n\treturn '{month_name}, {year}'.format(\n\t\tmonth_name=calendar.month_name[int(month)],\n\t\tyear=year,\n\t)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pday(dayfmt):\n\n\tyear, month, day = map(int, dayfmt.split('-'))\n\treturn '{day} the {number}'.format(\n\t\tday=calendar.day_name[calendar.weekday(year, month, day)],\n\t\tnumber=inflect.engine().ordinal(day),\n\t)", "response": "print the day of the last 24th"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npatch the config values to be compatible with older config values.", "response": "def patch_compat(config):\n\t\"\"\"\n\tSupport older config values.\n\t\"\"\"\n\tif 'web_host' in config:\n\t\tconfig['host'] = config.pop('web_host')\n\tif 'web_port' in config:\n\t\tconfig['port'] = config.pop('web_port')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nresolving a file name into a context name.", "response": "def resolve_file(mgr, filename):\n\t\"\"\"\n\tGiven a file manager (ExitStack), load the filename\n\tand set the exit stack to clean up. See\n\thttps://importlib-resources.readthedocs.io/en/latest/migration.html#pkg-resources-resource-filename\n\tfor more details.\n\t\"\"\"\n\tpath = importlib_resources.path('pmxbot.web.templates', filename)\n\treturn str(mgr.enter_context(path))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef date_key(cls, month_string):\n\t\tmonth, year = month_string.split(',')\n\t\tmonth_ord = cls.month_ordinal[month]\n\t\treturn year, month_ord", "response": "Return a key suitable for sorting by month."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nredirect to an href for UTC.", "response": "def forward(self, channel, date_s, fragment):\n\t\t\"\"\"\n\t\tGiven an HREF in the legacy timezone, redirect to an href for UTC.\n\t\t\"\"\"\n\t\ttime_s, sep, nick = fragment.rpartition('.')\n\t\ttime = datetime.datetime.strptime(time_s, '%H.%M.%S')\n\t\tdate = datetime.datetime.strptime(date_s, '%Y-%m-%d')\n\t\tdt = datetime.datetime.combine(date, time.time())\n\t\tloc_dt = self.timezone.localize(dt)\n\t\tutc_dt = loc_dt.astimezone(pytz.utc)\n\t\turl_tmpl = '/day/{channel}/{target_date}#{target_time}.{nick}'\n\t\turl = url_tmpl.format(\n\t\t\ttarget_date=utc_dt.date().isoformat(),\n\t\t\ttarget_time=utc_dt.time().strftime('%H.%M.%S'),\n\t\t\t**locals()\n\t\t)\n\t\traise cherrypy.HTTPRedirect(url, 301)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a date from sqlite. Assumes the date is in US / Pacific time zone.", "response": "def parse_date(record):\n\t\"Parse a date from sqlite. Assumes the date is in US/Pacific time zone.\"\n\tdt = record.pop('datetime')\n\tfmts = [\n\t\t'%Y-%m-%d %H:%M:%S.%f',\n\t\t'%Y-%m-%d %H:%M:%S',\n\t]\n\tfor fmt in fmts:\n\t\ttry:\n\t\t\tdt = datetime.datetime.strptime(dt, fmt)\n\t\t\tbreak\n\t\texcept ValueError:\n\t\t\tpass\n\telse:\n\t\traise\n\ttz = pytz.timezone('US/Pacific')\n\tloc_dt = tz.localize(dt)\n\trecord['datetime'] = loc_dt\n\treturn record"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstrike last <n> statements from the record", "response": "def strike(channel, nick, rest):\n\t\"Strike last <n> statements from the record\"\n\tyield NoLog\n\trest = rest.strip()\n\tif not rest:\n\t\tcount = 1\n\telse:\n\t\tif not rest.isdigit():\n\t\t\tyield \"Strike how many?  Argument must be a positive integer.\"\n\t\t\traise StopIteration\n\t\tcount = int(rest)\n\ttry:\n\t\tstruck = Logger.store.strike(channel, nick, count)\n\t\ttmpl = (\n\t\t\t\"Isn't undo great?  Last %d statement%s \"\n\t\t\t\"by %s were stricken from the record.\"\n\t\t)\n\t\tyield tmpl % (struck, 's' if struck > 1 else '', nick)\n\texcept Exception:\n\t\ttraceback.print_exc()\n\t\tyield \"Hmm.. I didn't find anything of yours to strike!\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef where(channel, nick, rest):\n\t\"When did pmxbot last see <nick> speak?\"\n\tonick = rest.strip()\n\tlast = Logger.store.last_seen(onick)\n\tif last:\n\t\ttm, chan = last\n\t\ttmpl = \"I last saw {onick} speak at {tm} in channel #{chan}\"\n\t\treturn tmpl.format(tm=tm, chan=chan, onick=onick)\n\telse:\n\t\treturn \"Sorry!  I don't have any record of %s speaking\" % onick", "response": "When did pmxbot last see <nick > speak?"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef logs(channel):\n\t\"Where can one find the logs?\"\n\tdefault_url = 'http://' + socket.getfqdn()\n\tbase = pmxbot.config.get('logs URL', default_url)\n\tlogged_channel = channel in pmxbot.config.log_channels\n\tpath = '/channel/' + channel.lstrip('#') if logged_channel else '/'\n\treturn urllib.parse.urljoin(base, path)", "response": "Where can one find the logs?"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef log(channel, rest):\n\twords = [s.lower() for s in rest.split()]\n\tif 'please' not in words:\n\t\treturn\n\tinclude = 'stop' not in rest\n\texisting = set(pmxbot.config.log_channels)\n\t# add the channel if include, otherwise remove the channel\n\top = existing.union if include else existing.difference\n\tpmxbot.config.log_channels = list(op([channel]))", "response": "Enable or disable logging for a channel ; leave it off if it is already enabled ; leave it off if it is not enabled ; leave it off if it is stop."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nkeeps a tab on the most recent message for each channel", "response": "def _add_recent(self, doc, logged_id):\n\t\t\"Keep a tab on the most recent message for each channel\"\n\t\tspec = dict(channel=doc['channel'])\n\t\tdoc['ref'] = logged_id\n\t\tdoc.pop('_id')\n\t\tself._recent.replace_one(spec, doc, upsert=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if the full text search is enabled on the messages if possible and return True.", "response": "def _has_fulltext(cls, uri):\n\t\t\"\"\"\n\t\tEnable full text search on the messages if possible and return True.\n\t\tIf the full text search cannot be enabled, then return False.\n\t\t\"\"\"\n\t\tcoll = cls._get_collection(uri)\n\t\twith ExceptionTrap(storage.pymongo.errors.OperationFailure) as trap:\n\t\t\tcoll.create_index([('message', 'text')], background=True)\n\t\treturn not trap"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _find_user_channel(self, username):\n\t\tuser_id = self.slacker.users.get_user_id(username)\n\t\tim = user_id and self.slacker.im.open(user_id).body['channel']['id']\n\t\treturn im and self.slack.server.channels.find(im)", "response": "Find the user channel by username"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends the message to Slack.", "response": "def transmit(self, channel, message):\n\t\t\"\"\"\n\t\tSend the message to Slack.\n\n\t\t:param channel: channel or user to whom the message should be sent.\n\t\t\tIf a ``thread`` attribute is present, that thread ID is used.\n\t\t:param str message: message to send.\n\t\t\"\"\"\n\t\ttarget = (\n\t\t\tself.slack.server.channels.find(channel)\n\t\t\tor self._find_user_channel(username=channel)\n\t\t)\n\t\tmessage = self._expand_references(message)\n\n\t\ttarget.send_message(message, thread=getattr(channel, 'thread', None))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a random word randomly selected from the keys weighted by proportion.", "response": "def wchoice(d):\n\t\"\"\"\n\tGiven a dictionary of word: proportion, return a word randomly selected\n\tfrom the keys weighted by proportion.\n\n\t>>> wchoice({'a': 0, 'b': 1})\n\t'b'\n\t>>> choices = [wchoice({'a': 1, 'b': 2}) for x in range(1000)]\n\n\tStatistically speaking, choices should be .5 a:b\n\t>>> ratio = choices.count('a') / choices.count('b')\n\t>>> .4 < ratio < .6\n\tTrue\n\t\"\"\"\n\ttotal = sum(d.values())\n\ttarget = random.random() * total\n\t# elect the first item which pushes the count over target\n\tcount = 0\n\tfor word, proportion in d.items():\n\t\tcount += proportion\n\t\tif count > target:\n\t\t\treturn word"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsplit a query into a list of choices.", "response": "def splitem(query):\n\t\"\"\"\n\tSplit a query into choices\n\n\t>>> splitem('dog, cat')\n\t['dog', 'cat']\n\n\tDisregards trailing punctuation.\n\n\t>>> splitem('dogs, cats???')\n\t['dogs', 'cats']\n\t>>> splitem('cats!!!')\n\t['cats']\n\n\tAllow or\n\t>>> splitem('dogs, cats or prarie dogs?')\n\t['dogs', 'cats', 'prarie dogs']\n\n\tHonors serial commas\n\t>>> splitem('dogs, cats, or prarie dogs?')\n\t['dogs', 'cats', 'prarie dogs']\n\n\tAllow choices to be prefixed by some ignored prompt.\n\t>>> splitem('stuff: a, b, c')\n\t['a', 'b', 'c']\n\t\"\"\"\n\tprompt, sep, query = query.rstrip('?.!').rpartition(':')\n\n\tchoices = query.split(',')\n\tchoices[-1:] = choices[-1].split(' or ')\n\n\treturn [choice.strip() for choice in choices if choice.strip()]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lookup(word):\n\t'''\n\tGet a definition for a word (uses Wordnik)\n\t'''\n\t_patch_wordnik()\n\t# Jason's key - do not abuse\n\tkey = 'edc4b9b94b341eeae350e087c2e05d2f5a2a9e0478cefc6dc'\n\tclient = wordnik.swagger.ApiClient(key, 'http://api.wordnik.com/v4')\n\twords = wordnik.WordApi.WordApi(client)\n\tdefinitions = words.getDefinitions(word, limit=1)\n\tif not definitions:\n\t\treturn\n\tdefinition = definitions[0]\n\treturn str(definition.text)", "response": "Get a definition for a word"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef urban_lookup(word):\n\t'''\n\tReturn a Urban Dictionary definition for a word or None if no result was\n\tfound.\n\t'''\n\turl = \"http://api.urbandictionary.com/v0/define\"\n\tparams = dict(term=word)\n\tresp = requests.get(url, params=params)\n\tresp.raise_for_status()\n\tres = resp.json()\n\tif not res['list']:\n\t\treturn\n\treturn res['list'][0]['definition']", "response": "A function to get a Urban Dictionary definition for a word or None if no result was\n\tfound."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef passagg(recipient, sender):\n\tadj = random.choice(pmxbot.phrases.adjs)\n\tif random.choice([False, True]):\n\t\t# address the recipient last\n\t\tlead = \"\"\n\t\ttrail = recipient if not recipient else \", %s\" % recipient\n\telse:\n\t\t# address the recipient first\n\t\tlead = recipient if not recipient else \"%s, \" % recipient\n\t\ttrail = \"\"\n\tbody = random.choice(pmxbot.phrases.adj_intros) % adj\n\tif not lead:\n\t\tbody = body.capitalize()\n\tmsg = \"{lead}{body}{trail}.\".format(**locals())\n\tfw = random.choice(pmxbot.phrases.farewells)\n\treturn \"{msg} {fw}, {sender}.\".format(**locals())", "response": "Generate a passive - aggressive statement to recipient from sender."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef config(client, event, channel, nick, rest):\n\t\"Change the running config, something like a=b or a+=b or a-=b\"\n\tpattern = re.compile(r'(?P<key>\\w+)\\s*(?P<op>[+-]?=)\\s*(?P<value>.*)$')\n\tmatch = pattern.match(rest)\n\tif not match:\n\t\treturn \"Command not recognized\"\n\tres = match.groupdict()\n\tkey = res['key']\n\top = res['op']\n\tvalue = yaml.safe_load(res['value'])\n\tif op in ('+=', '-='):\n\t\t# list operation\n\t\top_name = {'+=': 'append', '-=': 'remove'}[op]\n\t\top_name\n\t\tif key not in pmxbot.config:\n\t\t\tmsg = \"{key} not found in config. Can't {op_name}.\"\n\t\t\treturn msg.format(**locals())\n\t\tif not isinstance(pmxbot.config[key], (list, tuple)):\n\t\t\tmsg = \"{key} is not list or tuple. Can't {op_name}.\"\n\t\t\treturn msg.format(**locals())\n\t\top = getattr(pmxbot.config[key], op_name)\n\t\top(value)\n\telse:  # op is '='\n\t\tpmxbot.config[key] = value", "response": "Change the running config something like a = b or a = b or a - = b"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\niterating through the results, but if an exception occurs, stop processing the results and instead replace the results with the output from the exception handler.", "response": "def trap_exceptions(results, handler, exceptions=Exception):\n\t\"\"\"\n\tIterate through the results, but if an exception occurs, stop\n\tprocessing the results and instead replace\n\tthe results with the output from the exception handler.\n\t\"\"\"\n\ttry:\n\t\tfor result in results:\n\t\t\tyield result\n\texcept exceptions as exc:\n\t\tfor result in always_iterable(handler(exc)):\n\t\t\tyield result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a random quote from the quotes database.", "response": "def quote(rest):\n\t\"\"\"\n\tIf passed with nothing then get a random quote. If passed with some\n\tstring then search for that. If prepended with \"add:\" then add it to the\n\tdb, eg \"!quote add: drivers: I only work here because of pmxbot!\".\n\tDelete an individual quote by prepending \"del:\" and passing a search\n\tmatching exactly one query.\n\t\"\"\"\n\trest = rest.strip()\n\tif rest.startswith('add: ') or rest.startswith('add '):\n\t\tquote_to_add = rest.split(' ', 1)[1]\n\t\tQuotes.store.add(quote_to_add)\n\t\tqt = False\n\t\treturn 'Quote added!'\n\tif rest.startswith('del: ') or rest.startswith('del '):\n\t\tcmd, sep, lookup = rest.partition(' ')\n\t\tQuotes.store.delete(lookup)\n\t\treturn 'Deleted the sole quote that matched'\n\tqt, i, n = Quotes.store.lookup(rest)\n\tif not qt:\n\t\treturn\n\treturn '(%s/%s): %s' % (i, n, qt)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete a quote from the database.", "response": "def delete(self, lookup):\n\t\t\"\"\"\n\t\tIf exactly one quote matches, delete it. Otherwise,\n\t\traise a ValueError.\n\t\t\"\"\"\n\t\tlookup, num = self.split_num(lookup)\n\t\tif num:\n\t\t\tresult = self.find_matches(lookup)[num - 1]\n\t\telse:\n\t\t\tresult, = self.find_matches(lookup)\n\t\tself.db.delete_one(result)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_index(index, items):\n    indices = []\n    if index is None:\n        return indices\n\n    for atom in index.split(\",\"):\n        atom = atom.strip()\n        if not atom:\n            continue\n\n        if (\n            (atom.startswith(\"'\") and atom.endswith(\"'\")) or\n            (atom.startswith('\"') and atom.endswith('\"'))\n        ):\n            atom = atom[1:-1].lower()\n            for i, item in enumerate(items):\n                if atom in item.lower():\n                    indices.append(i)\n        elif atom.startswith('/') and atom.endswith('/'):\n            atom = atom[1:-1]\n            for i, item in enumerate(items):\n                if re.search(atom, item):\n                    indices.append(i)\n        elif \":\" in atom:\n            start, end = [x.strip() for x in atom.split(\":\", 1)]\n            start = int(start) if start else 1\n            if start < 0:\n                start += len(items) + 1\n            end = int(end) if end else len(items)\n            if end < 0:\n                end += len(items) + 1\n            start -= 1  # Shift to Python 0-based indices\n            end -= 1    # Shift to Python 0-based indices\n            for i in range(start, end + 1):\n                indices.append(i)\n        elif atom == \"first\":\n            indices.append(0)\n        elif atom == \"last\":\n            indices.append(len(items) - 1)\n        else:\n            index = int(atom)\n            if index < 0:\n                index += len(items) + 1\n            index -= 1  # Shift to Python 0-based indices\n            indices.append(index)\n\n    return indices", "response": "Parse a single index string into a list of 0 - based index numbers."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stack(nick, rest):\n    'Manage short lists in pmxbot. See !stack help for more info'\n    atoms = [atom.strip() for atom in rest.split(' ', 1) if atom.strip()]\n    if len(atoms) == 0:\n        subcommand = \"show\"\n        rest = \"\"\n    elif len(atoms) == 1:\n        subcommand = atoms[0]\n        rest = \"\"\n    else:\n        subcommand, rest = atoms\n\n    start = rest.find(\"[\")\n    finish = rest.rfind(\"]\")\n    sp = rest.find(\" \")\n    if (\n        start != -1 and finish != -1 and start < finish and\n        (sp == -1 or start < sp)\n    ):\n        topic, index = [atom.strip() for atom in rest[:finish].split(\"[\", 1)]\n        if not topic:\n            topic = nick\n        new_item = rest[finish + 1:].strip()\n    else:\n        topic = nick\n        index = None\n        new_item = rest.strip()\n\n    if subcommand == \"topics\" or subcommand == \"list\":\n        items = Stack.store.get_topics()\n        items.sort()\n    else:\n        items = Stack.store.get_items(topic)\n    try:\n        indices = parse_index(index, items)\n    except ValueError:\n        return helpdoc[\"index\"]\n\n    if debug:\n        print(\"SUBCOMMAND\", subcommand.ljust(8), \"TOPIC\", topic.ljust(8),\n              \"INDICES\", str(indices).ljust(12), \"ITEM\", new_item)\n\n    if subcommand == \"add\":\n        if not new_item:\n            return ('!stack add <topic[index]> item: '\n                    'You must provide an item to add.')\n\n        if not indices:\n            items.insert(0, new_item)\n        else:\n            for i in reversed(sorted(set(indices))):\n                if i >= len(items):\n                    items.append(new_item)\n                else:\n                    items.insert(i + 1, new_item)\n\n        Stack.store.save_items(topic, items)\n    elif subcommand == \"pop\":\n        if not indices:\n            indices = [0]\n\n        popped_items = [items.pop(i) for i in reversed(sorted(set(indices)))\n                        if len(items) > i >= 0]\n\n        Stack.store.save_items(topic, items)\n\n        return output([(\"-\", item) for item in reversed(popped_items)],\n                      \"(none popped)\", pop=True)\n    elif subcommand == \"show\":\n        if new_item:\n            return helpdoc[\"show\"]\n\n        if not indices:\n            indices = range(len(items))\n\n        return output(\n            [(i + 1, items[i]) for i in indices if len(items) > i >= 0]\n        )\n    elif subcommand == \"shuffle\":\n        if not indices:\n            random.shuffle(items)\n        else:\n            items = [items[i] for i in indices if len(items) > i >= 0]\n\n        Stack.store.save_items(topic, items)\n\n        return output(enumerate(items, 1))\n    elif subcommand == \"topics\" or subcommand == \"list\":\n        if new_item:\n            return helpdoc[\"topics\"]\n\n        if not indices:\n            indices = range(len(items))\n\n        return output(\n            [(i + 1, items[i]) for i in indices if len(items) > i >= 0]\n        )\n    elif subcommand == \"help\":\n        return helpdoc.get(new_item, helpdoc[\"help\"])\n    else:\n        return helpdoc[\"stack\"]", "response": "Manage short lists in pmxbot. See!stack help for more info"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_wrapper():\n\t\tif not pmxbot.config.get('use_ssl', False):\n\t\t\treturn lambda x: x\n\t\treturn importlib.import_module('ssl').wrap_socket", "response": "Get a socket wrapper based on SSL config."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transmit(self, channel, msg):\n\t\tis_action, msg = self.action_pattern.match(msg).groups()\n\t\tfunc = self._conn.action if is_action else self._conn.privmsg\n\t\ttry:\n\t\t\tfunc(channel, msg)\n\t\t\treturn msg\n\t\texcept irc.client.MessageTooLong:\n\t\t\t# some msgs will fail because they're too long\n\t\t\tlog.warning(\"Long message could not be transmitted: %s\", msg)\n\t\texcept irc.client.InvalidCharacters:\n\t\t\ttmpl = (\n\t\t\t\t\"Message contains carriage returns, \"\n\t\t\t\t\"which aren't allowed in IRC messages: %r\"\n\t\t\t)\n\t\t\tlog.warning(tmpl, msg)", "response": "Transmit a message or action."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getStatusCode(self):\n\n        if 'status' in self._response.keys():\n            if (self._response['status'] is not None) and ('code' in self._response['status'].keys()) and (self._response['status']['code'] is not None):\n                return self._response['status']['code']\n\n            else:\n                return None\n        else:\n            return None", "response": "Returns the code of the status of the response or None if it does not exist"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the status message of the response if it exists otherwise an empty string", "response": "def getStatusMsg(self):\n        \"\"\"\n        Returns the message of the status or an empty string if it does not exist\n\n        :return:\n            Status message of the response\n        \"\"\"\n\n        if 'status' in self._response.keys():\n            if (self._response['status'] is not None) and ('msg' in self._response['status'].keys()) and (self._response['status']['msg'] is not None):\n                return self._response['status']['msg']\n            else:\n                return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the number of credits consumed by the request made AttributeNames", "response": "def getConsumedCredits(self):\n        \"\"\"\n        Returns the credit consumed by the request made\n\n        :return:\n            String with the number of credits consumed\n        \"\"\"\n\n        if 'status' in self._response.keys():\n            if (self._response['status'] is not None) and ('credits' in self._response['status'].keys()):\n                if self._response['status']['credits'] is not None:\n                    return self._response['status']['credits']\n                else:\n                    return '0'\n            else:\n                print(\"Not credits field\\n\")\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the results from the API without the status of the request", "response": "def getResults(self):\n        \"\"\"\n        Returns the results from the API without the status of the request\n\n        :return:\n            Dictionary with the results\n        \"\"\"\n\n        results = self._response.copy()\n        if 'status' in self._response.keys():\n            if results['status'] is not None:\n                del results['status']\n            return results\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a list of all police force objects. Uses the forces_ API call.", "response": "def get_forces(self):\n        \"\"\"\n        Get a list of all police forces. Uses the forces_ API call.\n\n        .. _forces: https://data.police.uk/docs/method/forces/\n\n        :rtype: list\n        :return: A list of :class:`forces.Force` objects (one for each police\n                 force represented in the API)\n        \"\"\"\n\n        forces = []\n        for f in self.service.request('GET', 'forces'):\n            forces.append(Force(self, id=f['id'], name=f['name']))\n        return forces"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_neighbourhoods(self, force):\n\n        if not isinstance(force, Force):\n            force = Force(self, id=force)\n\n        neighbourhoods = []\n        for n in self.service.request('GET', '%s/neighbourhoods' % force.id):\n            neighbourhoods.append(\n                Neighbourhood(self, force=force, id=n['id'], name=n['name']))\n        return sorted(neighbourhoods, key=lambda n: n.name)", "response": "Get a list of all neighbourhoods for a given force. Uses the neighbourhoods_\n        API call."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_neighbourhood(self, force, id, **attrs):\n\n        if not isinstance(force, Force):\n            force = Force(self, id=force, **attrs)\n\n        return Neighbourhood(self, force=force, id=id, **attrs)", "response": "Get a specific neighbourhood. Uses the neighbourhood_ API call."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding a neighbourhood by location. Uses the locate - neighbourhood_ API call.", "response": "def locate_neighbourhood(self, lat, lng):\n        \"\"\"\n        Find a neighbourhood by location. Uses the locate-neighbourhood_ API\n        call.\n\n        .. _locate-neighbourhood:\n            https://data.police.uk/docs/method/neighbourhood-locate/\n\n        :param lat: The latitude of the location.\n        :type lat: float or str\n        :param lng: The longitude of the location.\n        :type lng: float or str\n        :rtype: Neighbourhood or None\n        :return: The Neighbourhood object representing the Neighbourhood\n                 Policing Team responsible for the given location.\n         \"\"\"\n\n        method = 'locate-neighbourhood'\n        q = '%s,%s' % (lat, lng)\n        try:\n            result = self.service.request('GET', method, q=q)\n            return self.get_neighbourhood(result['force'],\n                                          result['neighbourhood'])\n        except APIError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a list of crime categories valid for a particular date. Uses the clf API call.", "response": "def get_crime_categories(self, date=None):\n        \"\"\"\n        Get a list of crime categories, valid for a particular date. Uses the\n        crime-categories_ API call.\n\n        .. _crime-categories:\n            https://data.police.uk/docs/method/crime-categories/\n\n        :rtype: list\n        :param date: The date of the crime categories to get.\n        :type date: str or None\n        :return: A ``list`` of crime categories which are valid at the\n                 specified date (or at the latest date, if ``None``).\n        \"\"\"\n\n        return sorted(self._get_crime_categories(date=date).values(),\n                      key=lambda c: c.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a particular crime category by ID valid at a particular date. Uses the _get_crime_categories_ API call.", "response": "def get_crime_category(self, id, date=None):\n        \"\"\"\n        Get a particular crime category by ID, valid at a particular date. Uses\n        the crime-categories_ API call.\n\n        :rtype: CrimeCategory\n        :param str id: The ID of the crime category to get.\n        :param date: The date that the given crime category is valid for (the\n                     latest date is used if ``None``).\n        :type date: str or None\n        :return: A crime category with the given ID which is valid for the\n                 specified date (or at the latest date, if ``None``).\n        \"\"\"\n\n        try:\n            return self._get_crime_categories(date=date)[id]\n        except KeyError:\n            raise InvalidCategoryException(\n                'Category %s not found for %s' % (id, date))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_crime(self, persistent_id):\n\n        method = 'outcomes-for-crime/%s' % persistent_id\n        response = self.service.request('GET', method)\n        crime = Crime(self, data=response['crime'])\n        crime._outcomes = []\n        outcomes = response['outcomes']\n        if outcomes is not None:\n            for o in outcomes:\n                o.update({\n                    'crime': crime,\n                })\n                crime._outcomes.append(crime.Outcome(self, o))\n        return crime", "response": "Get a particular crime by persistent ID. Uses the outcomes - for - crime_COOKIE API call."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting crimes within a 1 - mile radius of a location.", "response": "def get_crimes_point(self, lat, lng, date=None, category=None):\n        \"\"\"\n        Get crimes within a 1-mile radius of a location. Uses the crime-street_\n        API call.\n\n        .. _crime-street: https//data.police.uk/docs/method/crime-street/\n\n        :rtype: list\n        :param lat: The latitude of the location.\n        :type lat: float or str\n        :param lng: The longitude of the location.\n        :type lng: float or str\n        :param date: The month in which the crimes were reported in the format\n                    ``YYYY-MM`` (the latest date is used if ``None``).\n        :type date: str or None\n        :param category: The category of the crimes to filter by (either by ID\n                         or CrimeCategory object)\n        :type category: str or CrimeCategory\n        :return: A ``list`` of crimes which were reported within 1 mile of the\n                 specified location, in the given month (optionally filtered by\n                 category).\n        \"\"\"\n\n        if isinstance(category, CrimeCategory):\n            category = category.id\n        method = 'crimes-street/%s' % (category or 'all-crime')\n        kwargs = {\n            'lat': lat,\n            'lng': lng,\n        }\n        crimes = []\n        if date is not None:\n            kwargs['date'] = date\n        for c in self.service.request('GET', method, **kwargs):\n            crimes.append(Crime(self, data=c))\n        return crimes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_crimes_area(self, points, date=None, category=None):\n\n        if isinstance(category, CrimeCategory):\n            category = category.id\n        method = 'crimes-street/%s' % (category or 'all-crime')\n        kwargs = {\n            'poly': encode_polygon(points),\n        }\n        crimes = []\n        if date is not None:\n            kwargs['date'] = date\n        for c in self.service.request('POST', method, **kwargs):\n            crimes.append(Crime(self, data=c))\n        return crimes", "response": "Get crimes within a custom area."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_crimes_location(self, location_id, date=None):\n\n        kwargs = {\n            'location_id': location_id,\n        }\n        crimes = []\n        if date is not None:\n            kwargs['date'] = date\n        for c in self.service.request('GET', 'crimes-at-location', **kwargs):\n            crimes.append(Crime(self, data=c))\n        return crimes", "response": "Get crimes at a particular location. Uses the crimes - at - location_ API call."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_crimes_no_location(self, force, date=None, category=None):\n\n        if not isinstance(force, Force):\n            force = Force(self, id=force)\n\n        if isinstance(category, CrimeCategory):\n            category = category.id\n\n        kwargs = {\n            'force': force.id,\n            'category': category or 'all-crime',\n        }\n        crimes = []\n        if date is not None:\n            kwargs['date'] = date\n        for c in self.service.request('GET', 'crimes-no-location', **kwargs):\n            crimes.append(NoLocationCrime(self, data=c))\n        return crimes", "response": "Get crimes with no location for a given force."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef scoreTagToString(self, scoreTag):\n\n        scoreTagToString = \"\"\n        if scoreTag == \"P+\":\n            scoreTagToString = 'strong positive'\n        elif scoreTag == \"P\":\n            scoreTagToString = 'positive'\n        elif scoreTag == \"NEU\":\n            scoreTagToString = 'neutral'\n        elif scoreTag == \"N\":\n            scoreTagToString = 'negative'\n        elif scoreTag == \"N+\":\n            scoreTagToString = 'strong negative'\n        elif scoreTag == \"NONE\":\n            scoreTagToString = 'no sentiment'\n\n        return scoreTagToString", "response": "returns a string representation of the scoreTag"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _retrocom(rx, tx, game, kwargs):\n    env = RetroWrapper.retro_make_func(game, **kwargs)\n\n    # Sit around on the queue, waiting for calls from RetroWrapper\n    while True:\n        attr, args, kwargs = rx.get()\n\n        # First, handle special case where the wrapper is asking if attr is callable.\n        # In this case, we actually have RetroWrapper.symbol, attr, and {}.\n        if attr == RetroWrapper.symbol:\n            result = env.__getattribute__(args)\n            tx.put(callable(result))\n        elif attr == \"close\":\n            env.close()\n            break\n        else:\n            # Otherwise, handle the request\n            result = getattr(env, attr)\n            if callable(result):\n                result = result(*args, **kwargs)\n            tx.put(result)", "response": "This function is the target for RetroWrapper s internal\n    process. It is the target for RetroWrapper s internal\n    process. It is the target for RetroWrapper s internal\n    process. It is the target for RetroWrapper s internal\n    process. It is the target for RetroWrapper s internal\n    process."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if the attribute is callable.", "response": "def _ask_if_attr_is_callable(self, attr):\n        \"\"\"\n        Returns whether or not the attribute is a callable.\n        \"\"\"\n        self._tx.put((RetroWrapper.symbol, attr, {}))\n        return self._rx.get()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a parameter to the request", "response": "def addParam(self, paramName, paramValue):\n        \"\"\"\n        Add a parameter to the request\n\n        :param paramName:\n            Name of the parameter\n        :param paramValue:\n            Value of the parameter\n        \"\"\"\n\n        if not paramName:\n            raise ValueError('paramName cannot be empty')\n        self._params[paramName] = paramValue"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setContent(self, type_, value):\n\n        if type_ in [self.CONTENT_TYPE_TXT, self.CONTENT_TYPE_URL,\n                     self.CONTENT_TYPE_FILE]:\n            if type_ == self.CONTENT_TYPE_FILE:\n                self._file = {}\n                self._file = {'doc': open(value, 'rb')}\n            else:\n                self.addParam(type_, value)", "response": "Sets the content that s going to be sent to analyze according to its type_ and value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sendRequest(self, extraHeaders=\"\"):\n\n        self.addParam('src', 'mc-python')\n\n        params = urlencode(self._params)\n\n        url = self._url\n\n        if 'doc' in self._file.keys():\n            headers = {}\n\n            if (extraHeaders is not None) and (extraHeaders is dict):\n                headers = headers.update(extraHeaders)\n\n            result = requests.post(url=url, data=self._params, files=self._file, headers=headers)\n            result.encoding = 'utf-8'\n            return result\n        else:\n            headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n            if (extraHeaders is not None) and (extraHeaders is dict):\n                headers = headers.update(extraHeaders)\n            result = requests.request(\"POST\", url=url, data=params, headers=headers)\n            result.encoding = 'utf-8'\n            return result", "response": "Sends a request to the URL specified and returns a response only if the HTTP code returned is OK"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the last node of the type specified by type_.", "response": "def getTypeLastNode(self, type_):\n        \"\"\"\n        Obtains the last node or leaf of the type specified\n\n        :param type_:\n            Type we want to analize (sementity, semtheme)\n        :return:\n            Last node of the type\n        \"\"\"\n\n        lastNode = \"\"\n        if type_ and (type(type_) is not list) and (type(type_) is not dict):\n            aType = type_.split('>')\n            lastNode = aType[len(aType) - 1]\n        return lastNode"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling by the event loop when a new connection is made.", "response": "def __conn_listener(self, state):\n        \"\"\"\n        Connection event listener\n\n        :param state: The new connection state\n        \"\"\"\n        if state == KazooState.CONNECTED:\n            self.__online = True\n            if not self.__connected:\n                self.__connected = True\n                self._logger.info(\"Connected to ZooKeeper\")\n                self._queue.enqueue(self.on_first_connection)\n            else:\n                self._logger.warning(\"Re-connected to ZooKeeper\")\n                self._queue.enqueue(self.on_client_reconnection)\n        elif state == KazooState.SUSPENDED:\n            self._logger.warning(\"Connection suspended\")\n            self.__online = False\n        elif state == KazooState.LOST:\n            self.__online = False\n            self.__connected = False\n\n            if self.__stop:\n                self._logger.info(\"Disconnected from ZooKeeper (requested)\")\n            else:\n                self._logger.warning(\"Connection lost\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __path(self, path):\n        if path.startswith(self.__prefix):\n            return path\n\n        return \"{}{}\".format(self.__prefix, path)", "response": "Adds the prefix to the given path"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a ZooKeeper node with the given data", "response": "def create(self, path, data, ephemeral=False, sequence=False):\n        \"\"\"\n        Creates a ZooKeeper node\n\n        :param path: Z-Path\n        :param data: Node Content\n        :param ephemeral: Ephemeral flag\n        :param sequence: Sequential flag\n        \"\"\"\n        return self._zk.create(\n            self.__path(path), data, ephemeral=ephemeral, sequence=sequence\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the content of a ZooKeeper node", "response": "def get(self, path, watch=None):\n        \"\"\"\n        Gets the content of a ZooKeeper node\n\n        :param path: Z-Path\n        :param watch: Watch method\n        \"\"\"\n        return self._zk.get(self.__path(path), watch=watch)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the list of children of a node", "response": "def get_children(self, path, watch=None):\n        \"\"\"\n        Gets the list of children of a node\n\n        :param path: Z-Path\n        :param watch: Watch method\n        \"\"\"\n        return self._zk.get_children(self.__path(path), watch=watch)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(self, path, data):\n        return self._zk.set(self.__path(path), data)", "response": "Sets the content of a ZooKeeper node"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve a tuple containing the service reference to the iPOPO service and the service itself", "response": "def get_ipopo_svc_ref(bundle_context):\n    # type: (BundleContext) -> Optional[Tuple[ServiceReference, Any]]\n    \"\"\"\n    Retrieves a tuple containing the service reference to iPOPO and the service\n    itself\n\n    :param bundle_context: The calling bundle context\n    :return: The reference to the iPOPO service and the service itself,\n             None if not available\n    \"\"\"\n    # Look after the service\n    ref = bundle_context.get_service_reference(SERVICE_IPOPO)\n    if ref is None:\n        return None\n\n    try:\n        # Get it\n        svc = bundle_context.get_service(ref)\n    except BundleException:\n        # Service reference has been invalidated\n        return None\n\n    # Return both the reference (to call unget_service()) and the service\n    return ref, svc"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef use_waiting_list(bundle_context):\n    # type: (BundleContext) -> Any\n    \"\"\"\n    Utility context to use the iPOPO waiting list safely in a \"with\" block.\n    It looks after the the iPOPO waiting list service and releases its\n    reference when exiting the context.\n\n    :param bundle_context: The calling bundle context\n    :return: The iPOPO waiting list service\n    :raise BundleException: Service not found\n    \"\"\"\n    # Get the service and its reference\n    ref = bundle_context.get_service_reference(SERVICE_IPOPO_WAITING_LIST)\n    if ref is None:\n        raise BundleException(\"No iPOPO waiting list service available\")\n\n    try:\n        # Give the service\n        yield bundle_context.get_service(ref)\n    finally:\n        try:\n            # Release it\n            bundle_context.unget_service(ref)\n        except BundleException:\n            # Service might have already been unregistered\n            pass", "response": "Utility context to use the iPOPO waiting list safely in a with block."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute the content of the __jsonclass__ field for the given object", "response": "def _compute_jsonclass(obj):\n    \"\"\"\n    Compute the content of the __jsonclass__ field for the given object\n\n    :param obj: An object\n    :return: The content of the __jsonclass__ field\n    \"\"\"\n    # It's not a standard type, so it needs __jsonclass__\n    module_name = inspect.getmodule(obj).__name__\n    json_class = obj.__class__.__name__\n    if module_name not in (\"\", \"__main__\"):\n        json_class = \"{0}.{1}\".format(module_name, json_class)\n\n    return [json_class, []]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _is_builtin(obj):\n    module_ = inspect.getmodule(obj)\n    if module_ in (None, builtins):\n        return True\n\n    return module_.__name__ in (\"\", \"__main__\")", "response": "Checks if the object is a built - in one or not"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the given Java class is one we might have set up", "response": "def _is_converted_class(java_class):\n    \"\"\"\n    Checks if the given Java class is one we *might* have set up\n    \"\"\"\n    if not java_class:\n        return False\n\n    return (\n        JAVA_MAPS_PATTERN.match(java_class) is not None\n        or JAVA_LISTS_PATTERN.match(java_class) is not None\n        or JAVA_SETS_PATTERN.match(java_class) is not None\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_jabsorb(value):\n    # None ?\n    if value is None:\n        return None\n\n    # Map ?\n    elif isinstance(value, dict):\n        if JAVA_CLASS in value or JSON_CLASS in value:\n            if not _is_converted_class(value.get(JAVA_CLASS)):\n                # Bean representation\n                converted_result = {}\n\n                for key, content in value.items():\n                    converted_result[key] = to_jabsorb(content)\n\n                try:\n                    # Keep the raw jsonrpclib information\n                    converted_result[JSON_CLASS] = value[JSON_CLASS]\n                except KeyError:\n                    pass\n\n            else:\n                # We already worked on this value\n                converted_result = value\n\n        else:\n            # Needs the whole transformation\n            converted_result = {JAVA_CLASS: \"java.util.HashMap\"}\n            converted_result[\"map\"] = map_pairs = {}\n            for key, content in value.items():\n                map_pairs[key] = to_jabsorb(content)\n\n            try:\n                # Keep the raw jsonrpclib information\n                map_pairs[JSON_CLASS] = value[JSON_CLASS]\n            except KeyError:\n                pass\n\n    # List ? (consider tuples as an array)\n    elif isinstance(value, list):\n        converted_result = {\n            JAVA_CLASS: \"java.util.ArrayList\",\n            \"list\": [to_jabsorb(entry) for entry in value],\n        }\n\n    # Set ?\n    elif isinstance(value, (set, frozenset)):\n        converted_result = {\n            JAVA_CLASS: \"java.util.HashSet\",\n            \"set\": [to_jabsorb(entry) for entry in value],\n        }\n\n    # Tuple ? (used as array, except if it is empty)\n    elif isinstance(value, tuple):\n        converted_result = [to_jabsorb(entry) for entry in value]\n\n    elif hasattr(value, JAVA_CLASS):\n        # Class with a Java class hint: convert into a dictionary\n        class_members = {\n            name: getattr(value, name)\n            for name in dir(value)\n            if not name.startswith(\"_\")\n        }\n\n        converted_result = HashableDict(\n            (name, to_jabsorb(content))\n            for name, content in class_members.items()\n            if not inspect.ismethod(content)\n        )\n\n        # Do not forget the Java class\n        converted_result[JAVA_CLASS] = getattr(value, JAVA_CLASS)\n\n        # Also add a __jsonclass__ entry\n        converted_result[JSON_CLASS] = _compute_jsonclass(value)\n\n    # Other ?\n    else:\n        converted_result = value\n\n    return converted_result", "response": "Converts a Python object to a Jabsorb map format."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_jabsorb(request, seems_raw=False):\n    if isinstance(request, (tuple, set, frozenset)):\n        # Special case : JSON arrays (Python lists)\n        return type(request)(from_jabsorb(element) for element in request)\n\n    elif isinstance(request, list):\n        # Check if we were a list or a tuple\n        if seems_raw:\n            return list(from_jabsorb(element) for element in request)\n\n        return tuple(from_jabsorb(element) for element in request)\n\n    elif isinstance(request, dict):\n        # Dictionary\n        java_class = request.get(JAVA_CLASS)\n        json_class = request.get(JSON_CLASS)\n        seems_raw = not java_class and not json_class\n\n        if java_class:\n            # Java Map ?\n            if JAVA_MAPS_PATTERN.match(java_class) is not None:\n                return HashableDict(\n                    (from_jabsorb(key), from_jabsorb(value))\n                    for key, value in request[\"map\"].items()\n                )\n\n            # Java List ?\n            elif JAVA_LISTS_PATTERN.match(java_class) is not None:\n                return HashableList(\n                    from_jabsorb(element) for element in request[\"list\"]\n                )\n\n            # Java Set ?\n            elif JAVA_SETS_PATTERN.match(java_class) is not None:\n                return HashableSet(\n                    from_jabsorb(element) for element in request[\"set\"]\n                )\n\n        # Any other case\n        result = AttributeMap(\n            (from_jabsorb(key), from_jabsorb(value, seems_raw))\n            for key, value in request.items()\n        )\n\n        # Keep JSON class information as is\n        if json_class:\n            result[JSON_CLASS] = json_class\n\n        return result\n\n    elif not _is_builtin(request):\n        # Bean\n        for attr in dir(request):\n            # Only convert public fields\n            if not attr[0] == \"_\":\n                # Field conversion\n                setattr(request, attr, from_jabsorb(getattr(request, attr)))\n\n        return request\n\n    else:\n        # Any other case\n        return request", "response": "Converts a Jabsorb request into a more Python data model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy(self):\n        # type: () -> Requirement\n        \"\"\"\n        Returns a copy of this instance\n\n        :return: A copy of this instance\n        \"\"\"\n        return Requirement(\n            self.specification,\n            self.aggregate,\n            self.optional,\n            self.__original_filter,\n            self.immediate_rebind,\n        )", "response": "Returns a copy of this instance of Requirement"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the filter for the given oneCOOKIE.", "response": "def set_filter(self, props_filter):\n        \"\"\"\n        Changes the current filter for the given one\n\n        :param props_filter: The new requirement filter on service properties\n        :raise TypeError: Unknown filter type\n        \"\"\"\n        if props_filter is not None and not (\n            is_string(props_filter)\n            or isinstance(\n                props_filter, (ldapfilter.LDAPFilter, ldapfilter.LDAPCriteria)\n            )\n        ):\n            # Unknown type\n            raise TypeError(\n                \"Invalid filter type {0}\".format(type(props_filter).__name__)\n            )\n\n        if props_filter is not None:\n            # Filter given, keep its string form\n            self.__original_filter = str(props_filter)\n        else:\n            # No filter\n            self.__original_filter = None\n\n        # Parse the filter\n        self.filter = ldapfilter.get_ldap_filter(props_filter)\n\n        # Prepare the full filter\n        spec_filter = \"({0}={1})\".format(OBJECTCLASS, self.specification)\n        self.__full_filter = ldapfilter.combine_filters(\n            (spec_filter, self.filter)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a deep copy of the current FactoryContext instance", "response": "def copy(self, inheritance=False):\n        # type: (bool) -> FactoryContext\n        \"\"\"\n        Returns a deep copy of the current FactoryContext instance\n\n        :param inheritance: If True, current handlers configurations are stored\n                            as inherited ones\n        \"\"\"\n        # Create a new factory context and duplicate its values\n        new_context = FactoryContext()\n        for field in self.__slots__:\n            if not field.startswith(\"_\"):\n                setattr(\n                    new_context, field, self._deepcopy(getattr(self, field))\n                )\n\n        if inheritance:\n            # Store configuration as inherited one\n            new_context.__inherited_configuration = self.__handlers.copy()\n            new_context.__handlers = {}\n\n        # Remove instances in any case\n        new_context.__instances.clear()\n        new_context.is_singleton_active = False\n        return new_context"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmerges the inherited configuration with the current ones.", "response": "def inherit_handlers(self, excluded_handlers):\n        # type: (Iterable[str]) -> None\n        \"\"\"\n        Merges the inherited configuration with the current ones\n\n        :param excluded_handlers: Excluded handlers\n        \"\"\"\n        if not excluded_handlers:\n            excluded_handlers = tuple()\n\n        for handler, configuration in self.__inherited_configuration.items():\n            if handler in excluded_handlers:\n                # Excluded handler\n                continue\n\n            elif handler not in self.__handlers:\n                # Fully inherited configuration\n                self.__handlers[handler] = configuration\n\n            # Merge configuration...\n            elif isinstance(configuration, dict):\n                # Dictionary\n                self.__handlers.setdefault(handler, {}).update(configuration)\n\n            elif isinstance(configuration, list):\n                # List\n                handler_conf = self.__handlers.setdefault(handler, [])\n                for item in configuration:\n                    if item not in handler_conf:\n                        handler_conf.append(item)\n\n        # Clear the inherited configuration dictionary\n        self.__inherited_configuration.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_instance(self, name, properties):\n        # type: (str, dict) -> None\n        \"\"\"\n        Stores the description of a component instance. The given properties\n        are stored as is.\n\n        :param name: Instance name\n        :param properties: Instance properties\n        :raise NameError: Already known instance name\n        \"\"\"\n        if name in self.__instances:\n            raise NameError(name)\n\n        # Store properties \"as-is\"\n        self.__instances[name] = properties", "response": "Stores the description of a component instance. The given properties are stored as is."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the registered method for the given event. Returns None if the event is not registered for the given event.", "response": "def get_field_callback(self, field, event):\n        # type: (str, str) -> Optional[Tuple[Callable, bool]]\n        \"\"\"\n        Retrieves the registered method for the given event. Returns None if\n        not found\n\n        :param field: Name of the dependency field\n        :param event: A component life cycle event\n        :return: A 2-tuple containing the callback associated to the given\n                 event and flag indicating if the callback must be called in\n                 valid state only\n        \"\"\"\n        try:\n            return self.factory_context.field_callbacks[field][event]\n        except KeyError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef grab_hidden_properties(self):\n        # type: () -> dict\n        \"\"\"\n        A one-shot access to hidden properties (the field is then destroyed)\n\n        :return: A copy of the hidden properties dictionary on the first call\n        :raise AttributeError: On any call after the first one\n        \"\"\"\n        # Copy properties\n        result = self.__hidden_properties.copy()\n\n        # Destroy the field\n        self.__hidden_properties.clear()\n        del self.__hidden_properties\n        return result", "response": "Returns a copy of the hidden properties dictionary on the first call."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _field_property_generator(self, public_properties):\n        # Local variable, to avoid messing with \"self\"\n        stored_instance = self._ipopo_instance\n\n        # Choose public or hidden properties\n        # and select the method to call to notify about the property update\n        if public_properties:\n            properties = stored_instance.context.properties\n            update_notifier = stored_instance.update_property\n        else:\n            # Copy Hidden properties and remove them from the context\n            properties = stored_instance.context.grab_hidden_properties()\n            update_notifier = stored_instance.update_hidden_property\n\n        def get_value(_, name):\n            \"\"\"\n            Retrieves the property value, from the iPOPO dictionaries\n\n            :param name: The property name\n            :return: The property value\n            \"\"\"\n            return properties.get(name)\n\n        def set_value(_, name, new_value):\n            \"\"\"\n            Sets the property value and trigger an update event\n\n            :param name: The property name\n            :param new_value: The new property value\n            \"\"\"\n            assert stored_instance.context is not None\n\n            # Get the previous value\n            old_value = properties.get(name)\n            if new_value != old_value:\n                # Change the property\n                properties[name] = new_value\n\n                # New value is different of the old one, trigger an event\n                update_notifier(name, old_value, new_value)\n\n            return new_value\n\n        return get_value, set_value", "response": "Generates the methods called by the injected class properties\n            and returns the values that are set to the new value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_methods_names(public_properties):\n        if public_properties:\n            prefix = ipopo_constants.IPOPO_PROPERTY_PREFIX\n        else:\n            prefix = ipopo_constants.IPOPO_HIDDEN_PROPERTY_PREFIX\n\n        return (\n            \"{0}{1}\".format(prefix, ipopo_constants.IPOPO_GETTER_SUFFIX),\n            \"{0}{1}\".format(prefix, ipopo_constants.IPOPO_SETTER_SUFFIX),\n        )", "response": "Generates the names of the methods that are used to inject the getter and setter of the class properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef manipulate(self, stored_instance, component_instance):\n        # Store the stored instance\n        self._ipopo_instance = stored_instance\n\n        # Public flags to generate (True for public accessors)\n        flags_to_generate = set()\n        if stored_instance.context.properties:\n            flags_to_generate.add(True)\n\n        # (False for hidden ones)\n        if stored_instance.context.has_hidden_properties():\n            flags_to_generate.add(False)\n\n        # Inject properties getters and setters\n        for public_flag in flags_to_generate:\n            # Prepare methods\n            getter, setter = self._field_property_generator(public_flag)\n\n            # Inject the getter and setter at the instance level\n            getter_name, setter_name = self.get_methods_names(public_flag)\n            setattr(component_instance, getter_name, getter)\n            setattr(component_instance, setter_name, setter)", "response": "This method is used to manipulate the iPOPO component instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the full name of the class of the given object", "response": "def _full_class_name(obj):\n    \"\"\"\n    Returns the full name of the class of the given object\n\n    :param obj: Any Python object\n    :return: The full name of the class of the object (if possible)\n    \"\"\"\n    module = obj.__class__.__module__\n    if module is None or module == str.__class__.__module__:\n        return obj.__class__.__name__\n    return module + \".\" + obj.__class__.__name__"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _prompt(self, prompt=None):\n        if prompt:\n            # Print the prompt\n            self.write(prompt)\n            self.output.flush()\n\n        # Read the line\n        return to_str(self.input.readline())", "response": "Reads a line written by the user and returns a string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert the given data then writes it to the output stream.", "response": "def _write_bytes(self, data):\n        \"\"\"\n        Converts the given data then writes it\n\n        :param data: Data to be written\n        :return: The result of ``self.output.write()``\n        \"\"\"\n        with self.__lock:\n            self.output.write(to_bytes(data, self.encoding))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _write_str(self, data):\n        with self.__lock:\n            self.output.write(\n                to_str(data, self.encoding)\n                .encode()\n                .decode(self.out_encoding, errors=\"replace\")\n            )", "response": "Converts the given data then writes it to the output file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_line(self, line=None, *args, **kwargs):\n        if line is None:\n            # Empty line\n            self.write(\"\\n\")\n        else:\n            # Format the line, if arguments have been given\n            if args or kwargs:\n                line = line.format(*args, **kwargs)\n\n            with self.__lock:\n                # Write it\n                self.write(line)\n                try:\n                    if line[-1] != \"\\n\":\n                        # Add the trailing new line\n                        self.write(\"\\n\")\n                except IndexError:\n                    # Got an empty string\n                    self.write(\"\\n\")\n\n        self.flush()", "response": "Formats and writes a line to the output\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats and writes a line to the output file.", "response": "def write_line_no_feed(self, line=None, *args, **kwargs):\n        \"\"\"\n        Formats and writes a line to the output\n        \"\"\"\n        if line is None:\n            # Empty line\n            line = \"\"\n        else:\n            # Format the line, if arguments have been given\n            if args or kwargs:\n                line = line.format(*args, **kwargs)\n\n            # Remove the trailing line feed\n            if line[-1] == \"\\n\":\n                line = line[:-1]\n\n        # Write it\n        self.write(line)\n        self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of handlers associated to the given component.", "response": "def get_handlers(self, component_context, instance):\n        \"\"\"\n        Sets up service providers for the given component\n\n        :param component_context: The ComponentContext bean\n        :param instance: The component instance\n        :return: The list of handlers associated to the given component\n                 (never None)\n        \"\"\"\n        # Extract information from the context\n        logger_field = component_context.get_handler(constants.HANDLER_LOGGER)\n        if not logger_field:\n            # Error: log it and either raise an exception\n            # or ignore this handler\n            _logger.warning(\"Logger iPOPO handler can't find its configuration\")\n\n            # Here, we ignore the error and do not give any handler to iPOPO\n            return []\n\n        else:\n            # Construct a handler and return it in a list\n            return [_LoggerHandler(logger_field, component_context.name)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef manipulate(self, stored_instance, component_instance):\n        # Create the logger for this component instance\n        self._logger = logging.getLogger(self._name)\n\n        # Inject it\n        setattr(component_instance, self._field, self._logger)", "response": "This method is called by iPOPO when the component is instantiated."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clear(self):\n        self._logger.debug(\"Component handlers are cleared\")\n\n        # Clean up everything to avoid stale references, ...\n        self._field = None\n        self._name = None\n        self._logger = None", "response": "Clears out the component s state."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the possible completions of the current argument in the current shell session.", "response": "def completion_hints(config, prompt, session, context, current, arguments):\n    # type: (CompletionInfo, str, ShellSession, BundleContext, str, List[str]) -> List[str]\n    \"\"\"\n    Returns the possible completions of the current argument\n\n    :param config: Configuration of the current completion\n    :param prompt: The shell prompt string\n    :param session: Current shell session\n    :param context: Context of the shell UI bundle\n    :param current: Current argument (to be completed)\n    :param arguments: List of all arguments in their current state\n    :return: A list of possible completions\n    \"\"\"\n    if not current:\n        # No word yet, so the current position is after the existing ones\n        arg_idx = len(arguments)\n    else:\n        # Find the current word position\n        arg_idx = arguments.index(current)\n\n    # Find the ID of the next completer\n    completers = config.completers\n    if arg_idx > len(completers) - 1:\n        # Argument is too far to be positional, try\n        if config.multiple:\n            # Multiple calls allowed for the last completer\n            completer_id = completers[-1]\n        else:\n            # Nothing to return\n            return []\n    else:\n        completer_id = completers[arg_idx]\n\n    if completer_id == DUMMY:\n        # Dummy completer: do nothing\n        return []\n\n    # Find the matching service\n    svc_ref = context.get_service_reference(\n        SVC_COMPLETER, \"({}={})\".format(PROP_COMPLETER_ID, completer_id)\n    )\n    if svc_ref is None:\n        # Handler not found\n        _logger.debug(\"Unknown shell completer ID: %s\", completer_id)\n        return []\n\n    # Call the completer\n    try:\n        with use_service(context, svc_ref) as completer:\n            matches = completer.complete(\n                config, prompt, session, context, arguments, current\n            )\n            if not matches:\n                return []\n\n            return matches\n    except Exception as ex:\n        _logger.exception(\"Error calling completer %s: %s\", completer_id, ex)\n        return []"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of handlers associated to the given component.", "response": "def get_handlers(self, component_context, instance):\n        \"\"\"\n        Sets up service providers for the given component\n\n        :param component_context: The ComponentContext bean\n        :param instance: The component instance\n        :return: The list of handlers associated to the given component\n                 (never None)\n        \"\"\"\n        # Extract information from the context\n        logger_field = component_context.get_handler(constants.HANDLER_LOGGER)\n        if not logger_field:\n            # Error: log it and either raise an exception\n            # or ignore this handler\n            _logger.warning(\"Logger iPOPO handler can't find its configuration\")\n\n        else:\n            # Create the logger for this component instance\n            logger = logging.getLogger(component_context.name)\n\n            # Inject it\n            setattr(instance, logger_field, logger)\n            logger.debug(\"Logger has been injected\")\n\n        # No need to have an instance handler\n        return []"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the file exists and returns its absolute path. If it does not return None.", "response": "def _resolve_file(file_name):\n    \"\"\"\n    Checks if the file exists.\n\n    If the file exists, the method returns its absolute path.\n    Else, it returns None\n\n    :param file_name: The name of the file to check\n    :return: An absolute path, or None\n    \"\"\"\n    if not file_name:\n        return None\n\n    path = os.path.realpath(file_name)\n    if os.path.isfile(path):\n        return path\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_common_parser():\n    parser = argparse.ArgumentParser(add_help=False)\n\n    # Version number\n    parser.add_argument(\n        \"--version\",\n        action=\"version\",\n        version=\"Pelix {0} from {1}\".format(pelix.__version__, pelix.__file__),\n    )\n\n    # Framework options\n    group = parser.add_argument_group(\"Framework options\")\n    group.add_argument(\n        \"-D\",\n        nargs=\"+\",\n        dest=\"properties\",\n        metavar=\"KEY=VALUE\",\n        help=\"Sets framework properties\",\n    )\n    group.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"Set loggers to DEBUG level\",\n    )\n\n    # Initial configuration\n    group = parser.add_argument_group(\"Initial configuration\")\n    group.add_argument(\n        \"-c\",\n        \"--conf\",\n        dest=\"init_conf\",\n        metavar=\"FILE\",\n        help=\"Name of an initial configuration file to use \"\n        \"(default configuration is also loaded)\",\n    )\n    group.add_argument(\n        \"-C\",\n        \"--exclusive-conf\",\n        dest=\"init_conf_exclusive\",\n        metavar=\"FILE\",\n        help=\"Name of an initial configuration file to use \"\n        \"(without the default configuration)\",\n    )\n    group.add_argument(\n        \"-e\",\n        \"--empty-conf\",\n        dest=\"init_empty\",\n        action=\"store_true\",\n        help=\"Don't load any initial configuration\",\n    )\n\n    # Initial script\n    group = parser.add_argument_group(\"Script execution arguments\")\n    group.add_argument(\n        \"--init\",\n        action=\"store\",\n        dest=\"init_script\",\n        metavar=\"SCRIPT\",\n        help=\"Runs the given shell script before starting the console\",\n    )\n    group.add_argument(\n        \"--run\",\n        action=\"store\",\n        dest=\"run_script\",\n        metavar=\"SCRIPT\",\n        help=\"Runs the given shell script then stops the framework\",\n    )\n    return parser", "response": "Creates an argument parser that can be used as a parent argument in the argument parser."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles the common arguments defined by the parser.", "response": "def handle_common_arguments(parsed_args):\n    \"\"\"\n    Handles the arguments defined by :meth:`~make_common_parser`\n\n    :param parsed_args: Argument parsed with ``argparse`` (``Namespace``)\n    :return: An :class:`~InitFileHandler` object\n    :raise IOError: Initial or run script not found\n    \"\"\"\n    # Setup the logger\n    logging.basicConfig(\n        level=logging.DEBUG if parsed_args.verbose else logging.WARNING\n    )\n\n    # Framework properties dictionary\n    props = {}\n\n    # Read the initial configuration script\n    init = InitFileHandler()\n    if not parsed_args.init_empty:\n        if not parsed_args.init_conf_exclusive:\n            # Load default configuration\n            init.load()\n\n        # Load the given configuration file\n        conf_file = parsed_args.init_conf_exclusive or parsed_args.init_conf\n        if conf_file:\n            init.load(conf_file)\n\n        # Normalize configuration\n        init.normalize()\n\n        # Set initial framework properties\n        props.update(init.properties)\n\n    # Compute framework properties\n    for prop_def in parsed_args.properties or []:\n        key, value = prop_def.split(\"=\", 1)\n        props[key] = value\n\n    # Check initial run script(s)\n    if parsed_args.init_script:\n        path = props[PROP_INIT_FILE] = _resolve_file(parsed_args.init_script)\n        if not path:\n            raise IOError(\n                \"Initial script file not found: {0}\".format(\n                    parsed_args.init_script\n                )\n            )\n\n    if parsed_args.run_script:\n        # Find the file\n        path = props[PROP_RUN_FILE] = _resolve_file(parsed_args.run_script)\n        if not path:\n            raise IOError(\n                \"Script file not found: {0}\".format(parsed_args.run_script)\n            )\n\n    # Update the stored configuration\n    init.properties.update(props)\n    return init"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _normal_prompt(self):\n        sys.stdout.write(self.__get_ps1())\n        sys.stdout.flush()\n        return safe_input()", "response": "Flushes the prompt before requesting the command line\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef loop_input(self, on_quit=None):\n        # Start the init script\n        self._run_script(\n            self.__session, self._context.get_property(PROP_INIT_FILE)\n        )\n\n        # Run the script\n        script_file = self._context.get_property(PROP_RUN_FILE)\n        if script_file:\n            self._run_script(self.__session, script_file)\n        else:\n            # No script: run the main loop (blocking)\n            self._run_loop(self.__session)\n\n        # Nothing more to do\n        self._stop_event.set()\n        sys.stdout.write(\"Bye !\\n\")\n        sys.stdout.flush()\n        if on_quit is not None:\n            # Call a handler if needed\n            on_quit()", "response": "Reads the standard input until the shell session is stopped."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the given script file_path and returns True if a file has been executed False otherwise", "response": "def _run_script(self, session, file_path):\n        \"\"\"\n        Runs the given script file\n\n        :param session: Current shell session\n        :param file_path: Path to the file to execute\n        :return: True if a file has been execute\n        \"\"\"\n        if file_path:\n            # The 'run' command returns False in case of error\n            # The 'execute' method returns False if the run command fails\n            return self._shell.execute('run \"{0}\"'.format(file_path), session)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _run_loop(self, session):\n        try:\n            first_prompt = True\n\n            # Set up the prompt\n            prompt = (\n                self._readline_prompt\n                if readline is not None\n                else self._normal_prompt\n            )\n\n            while not self._stop_event.is_set():\n                # Wait for the shell to be there\n                # Before Python 2.7, wait() doesn't return a result\n                if self._shell_event.wait(.2) or self._shell_event.is_set():\n                    # Shell present\n                    if first_prompt:\n                        # Show the banner on first prompt\n                        sys.stdout.write(self._shell.get_banner())\n                        first_prompt = False\n\n                    # Read the next line\n                    line = prompt()\n\n                    with self._lock:\n                        if self._shell_event.is_set():\n                            # Execute it\n                            self._shell.execute(line, session)\n\n                        elif not self._stop_event.is_set():\n                            # Shell service lost while not stopping\n                            sys.stdout.write(\"Shell service lost.\")\n                            sys.stdout.flush()\n        except (EOFError, KeyboardInterrupt, SystemExit):\n            # Input closed or keyboard interruption\n            pass", "response": "Runs the main input loop."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef readline_completer(self, text, state):\n        if state == 0:\n            # New completion, reset the list of matches and the display hook\n            self._readline_matches = []\n            try:\n                readline.set_completion_display_matches_hook(None)\n            except AttributeError:\n                pass\n\n            # Get the full line\n            full_line = readline.get_line_buffer()\n            begin_idx = readline.get_begidx()\n\n            # Parse arguments as best as we can\n            try:\n                arguments = shlex.split(full_line)\n            except ValueError:\n                arguments = full_line.split()\n\n            # Extract the command (maybe with its namespace)\n            command = arguments.pop(0)\n\n            if begin_idx > 0:\n                # We're completing after the command (and maybe some args)\n                try:\n                    # Find the command\n                    ns, command = self._shell.get_ns_command(command)\n                except ValueError:\n                    # Ambiguous command: ignore\n                    return None\n\n                # Use the completer associated to the command, if any\n                try:\n                    configuration = self._shell.get_command_completers(\n                        ns, command\n                    )\n                    if configuration is not None:\n                        self._readline_matches = completion_hints(\n                            configuration,\n                            self.__get_ps1(),\n                            self.__session,\n                            self._context,\n                            text,\n                            arguments,\n                        )\n                except KeyError:\n                    # Unknown command\n                    pass\n\n            elif \".\" in command:\n                # Completing the command, and a name space is given\n                namespace, prefix = text.split(\".\", 2)\n                commands = self._shell.get_commands(namespace)\n\n                # Filter methods according to the prefix\n                self._readline_matches = [\n                    \"{0}.{1}\".format(namespace, command)\n                    for command in commands\n                    if command.startswith(prefix)\n                ]\n            else:\n                # Completing a command or namespace\n                prefix = command\n\n                # Default commands goes first...\n                possibilities = [\n                    \"{0} \".format(command)\n                    for command in self._shell.get_commands(None)\n                    if command.startswith(prefix)\n                ]\n\n                # ... then name spaces\n                namespaces = self._shell.get_namespaces()\n                possibilities.extend(\n                    \"{0}.\".format(namespace)\n                    for namespace in namespaces\n                    if namespace.startswith(prefix)\n                )\n\n                # ... then commands in those name spaces\n                possibilities.extend(\n                    \"{0} \".format(command)\n                    for namespace in namespaces\n                    if namespace is not None\n                    for command in self._shell.get_commands(namespace)\n                    if command.startswith(prefix)\n                )\n\n                # Filter methods according to the prefix\n                self._readline_matches = possibilities\n\n            if not self._readline_matches:\n                return None\n\n            # Return the first possibility\n            return self._readline_matches[0]\n\n        elif state < len(self._readline_matches):\n            # Next try\n            return self._readline_matches[state]\n\n        return None", "response": "A completer for the readline library."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching for a shell in the context and sets the shell reference.", "response": "def search_shell(self):\n        \"\"\"\n        Looks for a shell service\n        \"\"\"\n        with self._lock:\n            if self._shell is not None:\n                # A shell is already there\n                return\n\n            reference = self._context.get_service_reference(SERVICE_SHELL)\n            if reference is not None:\n                self.set_shell(reference)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall by Pelix when an event changes the service attributes.", "response": "def service_changed(self, event):\n        \"\"\"\n        Called by Pelix when an events changes\n        \"\"\"\n        kind = event.get_kind()\n        reference = event.get_service_reference()\n\n        if kind in (pelix.ServiceEvent.REGISTERED, pelix.ServiceEvent.MODIFIED):\n            # A service matches our filter\n            self.set_shell(reference)\n\n        else:\n            with self._lock:\n                # Service is not matching our filter anymore\n                self.clear_shell()\n\n                # Request for a new binding\n                self.search_shell()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_shell(self, svc_ref):\n        if svc_ref is None:\n            return\n\n        with self._lock:\n            # Get the service\n            self._shell_ref = svc_ref\n            self._shell = self._context.get_service(self._shell_ref)\n\n            # Set the readline completer\n            if readline is not None:\n                readline.set_completer(self.readline_completer)\n\n            # Set the flag\n            self._shell_event.set()", "response": "Binds the given shell service."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclearing the active shell", "response": "def clear_shell(self):\n        \"\"\"\n        Unbinds the active shell service\n        \"\"\"\n        with self._lock:\n            # Clear the flag\n            self._shell_event.clear()\n\n            # Clear the readline completer\n            if readline is not None:\n                readline.set_completer(None)\n                del self._readline_matches[:]\n\n            if self._shell_ref is not None:\n                # Release the service\n                self._context.unget_service(self._shell_ref)\n\n            self._shell_ref = None\n            self._shell = None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_POST(self, request, response):\n        # pylint: disable=C0103\n        \"\"\"\n        Handles a HTTP POST request\n\n        :param request: The HTTP request bean\n        :param response: The HTTP response handler\n        \"\"\"\n        try:\n            # Get the request content\n            data = to_str(request.read_data())\n\n            # Dispatch\n            result = self._marshaled_dispatch(data, self._simple_dispatch)\n\n            # Send the result\n            response.send_content(200, result, \"application/json-rpc\")\n        except Exception as ex:\n            response.send_content(\n                500, \"Internal error:\\n{0}\\n\".format(ex), \"text/plain\"\n            )", "response": "Handles a HTTP POST request"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _prepare_requirements(requirements, requires_filters):\n        if not requires_filters or not isinstance(requires_filters, dict):\n            # No explicit filter configured\n            return requirements\n\n        # We need to change a part of the requirements\n        new_requirements = {}\n        for field, requirement in requirements.items():\n            try:\n                explicit_filter = requires_filters[field]\n\n                # Store an updated copy of the requirement\n                requirement_copy = requirement.copy()\n                requirement_copy.set_filter(explicit_filter)\n                new_requirements[field] = requirement_copy\n\n            except (KeyError, TypeError, ValueError):\n                # No information for this one, or invalid filter:\n                # keep the factory requirement\n                new_requirements[field] = requirement\n\n        return new_requirements", "response": "Prepare the requirements dictionary for the component - level modules."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the list of handlers associated to the given component.", "response": "def get_handlers(self, component_context, instance):\n        \"\"\"\n        Sets up service providers for the given component\n\n        :param component_context: The ComponentContext bean\n        :param instance: The component instance\n        :return: The list of handlers associated to the given component\n        \"\"\"\n        # Extract information from the context\n        requirements = component_context.get_handler(\n            ipopo_constants.HANDLER_REQUIRES\n        )\n        requires_filters = component_context.properties.get(\n            ipopo_constants.IPOPO_REQUIRES_FILTERS, None\n        )\n\n        # Prepare requirements\n        requirements = self._prepare_requirements(\n            requirements, requires_filters\n        )\n\n        # Set up the runtime dependency handlers\n        handlers = []\n        for field, requirement in requirements.items():\n            # Construct the handler\n            if requirement.aggregate:\n                handlers.append(AggregateDependency(field, requirement))\n            else:\n                handlers.append(SimpleDependency(field, requirement))\n\n        return handlers"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef manipulate(self, stored_instance, component_instance):\n        # Store the stored instance...\n        self._ipopo_instance = stored_instance\n\n        # ... and the bundle context\n        self._context = stored_instance.bundle_context", "response": "Stores the given StoredInstance bean and the bundle context."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear(self):\n        self._lock = None\n        self._ipopo_instance = None\n        self._context = None\n        self.requirement = None\n        self._value = None\n        self._field = None", "response": "Clears the internal state of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall by the framework when a service event occurs.", "response": "def service_changed(self, event):\n        \"\"\"\n        Called by the framework when a service event occurs\n        \"\"\"\n        if (\n            self._ipopo_instance is None\n            or not self._ipopo_instance.check_event(event)\n        ):\n            # stop() and clean() may have been called after we have been put\n            # inside a listener list copy...\n            # or we've been told to ignore this event\n            return\n\n        # Call sub-methods\n        kind = event.get_kind()\n        svc_ref = event.get_service_reference()\n\n        if kind == ServiceEvent.REGISTERED:\n            # Service coming\n            self.on_service_arrival(svc_ref)\n\n        elif kind in (\n            ServiceEvent.UNREGISTERING,\n            ServiceEvent.MODIFIED_ENDMATCH,\n        ):\n            # Service gone or not matching anymore\n            self.on_service_departure(svc_ref)\n\n        elif kind == ServiceEvent.MODIFIED:\n            # Modified properties (can be a new injection)\n            self.on_service_modify(svc_ref, event.get_previous_properties())"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts the dependency manager.", "response": "def start(self):\n        \"\"\"\n        Starts the dependency manager\n        \"\"\"\n        self._context.add_service_listener(\n            self, self.requirement.filter, self.requirement.specification\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclearing up the manager.", "response": "def clear(self):\n        \"\"\"\n        Cleans up the manager. The manager can't be used after this method has\n        been called\n        \"\"\"\n        self.reference = None\n        self._pending_ref = None\n        super(SimpleDependency, self).clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_service_arrival(self, svc_ref):\n        with self._lock:\n            if self._value is None:\n                # Inject the service\n                self.reference = svc_ref\n                self._value = self._context.get_service(svc_ref)\n\n                self._ipopo_instance.bind(self, self._value, self.reference)\n                return True\n\n        return None", "response": "Called when a service is arrived in the framework."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall when a service has been modified in the framework", "response": "def on_service_modify(self, svc_ref, old_properties):\n        \"\"\"\n        Called when a service has been modified in the framework\n\n        :param svc_ref: A service reference\n        :param old_properties: Previous properties values\n        \"\"\"\n        with self._lock:\n            if self.reference is None:\n                # A previously registered service now matches our filter\n                self.on_service_arrival(svc_ref)\n            elif svc_ref is self.reference:\n                # Notify the property modification\n                self._ipopo_instance.update(\n                    self, self._value, svc_ref, old_properties\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stop(self):\n        super(SimpleDependency, self).stop()\n        if self.reference is not None:\n            # Return a tuple of tuple\n            return ((self._value, self.reference),)\n\n        return None", "response": "Stops the dependency manager and returns the removed bindings or None if the dependency manager is not running."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_valid(self):\n        return super(SimpleDependency, self).is_valid() or (\n            self.requirement.immediate_rebind and self._pending_ref is not None\n        )", "response": "Tests if the dependency is in a valid state."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsearches for the required service and binds it to the component.", "response": "def try_binding(self):\n        \"\"\"\n        Searches for the required service if needed\n\n        :raise BundleException: Invalid ServiceReference found\n        \"\"\"\n        with self._lock:\n            if self.reference is not None:\n                # Already bound\n                return\n\n            if self._pending_ref is not None:\n                # Get the reference we chose to keep this component valid\n                ref = self._pending_ref\n                self._pending_ref = None\n            else:\n                # Get the first matching service\n                ref = self._context.get_service_reference(\n                    self.requirement.specification, self.requirement.filter\n                )\n\n            if ref is not None:\n                # Found a service\n                self.on_service_arrival(ref)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclear up the manager.", "response": "def clear(self):\n        \"\"\"\n        Cleans up the manager. The manager can't be used after this method has\n        been called\n        \"\"\"\n        self.services.clear()\n        self.services = None\n        self._future_value = None\n        super(AggregateDependency, self).clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_service_arrival(self, svc_ref):\n        with self._lock:\n            if svc_ref not in self.services:\n                # Get the new service\n                service = self._context.get_service(svc_ref)\n\n                if self._future_value is None:\n                    # First value\n                    self._future_value = []\n\n                # Store the information\n                self._future_value.append(service)\n                self.services[svc_ref] = service\n\n                self._ipopo_instance.bind(self, service, svc_ref)\n                return True\n\n            return None", "response": "Called when a service is arrived in the framework."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls when a service is deactivated from the framework", "response": "def on_service_departure(self, svc_ref):\n        \"\"\"\n        Called when a service has been unregistered from the framework\n\n        :param svc_ref: A service reference\n        :return: A tuple (service, reference) if the service has been lost,\n                 else None\n        \"\"\"\n        with self._lock:\n            try:\n                # Get the service instance\n                service = self.services.pop(svc_ref)\n            except KeyError:\n                # Not a known service reference: ignore\n                pass\n            else:\n                # Clean the instance values\n                self._future_value.remove(service)\n\n                # Nullify the value if needed\n                if not self._future_value:\n                    self._future_value = None\n\n                self._ipopo_instance.unbind(self, service, svc_ref)\n                return True\n\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling when a service has been modified in the framework", "response": "def on_service_modify(self, svc_ref, old_properties):\n        \"\"\"\n        Called when a service has been modified in the framework\n\n        :param svc_ref: A service reference\n        :param old_properties: Previous properties values\n        :return: A tuple (added, (service, reference)) if the dependency has\n                 been changed, else None\n        \"\"\"\n        with self._lock:\n            try:\n                # Look for the service\n                service = self.services[svc_ref]\n            except KeyError:\n                # A previously registered service now matches our filter\n                return self.on_service_arrival(svc_ref)\n            else:\n                # Notify the property modification\n                self._ipopo_instance.update(\n                    self, service, svc_ref, old_properties\n                )\n\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stop(self):\n        super(AggregateDependency, self).stop()\n\n        if self.services:\n            return [\n                (service, reference)\n                for reference, service in self.services.items()\n            ]\n\n        return None", "response": "Stops the dependency manager and returns a list of the removed bindings or None if no bindings are removed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstore a new log entry and notifies listeners", "response": "def _store_entry(self, entry):\n        \"\"\"\n        Stores a new log entry and notifies listeners\n\n        :param entry: A LogEntry object\n        \"\"\"\n        # Get the logger and log the message\n        self.__logs.append(entry)\n\n        # Notify listeners\n        for listener in self.__listeners.copy():\n            try:\n                listener.logged(entry)\n            except Exception as ex:\n                # Create a new log entry, without using logging nor notifying\n                # listener (to avoid a recursion)\n                err_entry = LogEntry(\n                    logging.WARNING,\n                    \"Error notifying logging listener {0}: {1}\".format(\n                        listener, ex\n                    ),\n                    sys.exc_info(),\n                    self._context.get_bundle(),\n                    None,\n                )\n\n                # Insert the new entry before the real one\n                self.__logs.pop()\n                self.__logs.append(err_entry)\n                self.__logs.append(entry)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlog a message possibly with an exception context", "response": "def log(self, level, message, exc_info=None, reference=None):\n        # pylint: disable=W0212\n        \"\"\"\n        Logs a message, possibly with an exception\n\n        :param level: Severity of the message (Python logging level)\n        :param message: Human readable message\n        :param exc_info: The exception context (sys.exc_info()), if any\n        :param reference: The ServiceReference associated to the log\n        \"\"\"\n        if not isinstance(reference, pelix.framework.ServiceReference):\n            # Ensure we have a clean Service Reference\n            reference = None\n\n        if exc_info is not None:\n            # Format the exception to avoid memory leaks\n            try:\n                exception_str = \"\\n\".join(traceback.format_exception(*exc_info))\n            except (TypeError, ValueError, AttributeError):\n                exception_str = \"<Invalid exc_info>\"\n        else:\n            exception_str = None\n\n        # Store the LogEntry\n        entry = LogEntry(\n            level, message, exception_str, self.__bundle, reference\n        )\n        self.__reader._store_entry(entry)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the bundle associated to a Python module object.", "response": "def _bundle_from_module(self, module_object):\n        \"\"\"\n        Find the bundle associated to a module\n\n        :param module_object: A Python module object\n        :return: The Bundle object associated to the module, or None\n        \"\"\"\n        try:\n            # Get the module name\n            module_object = module_object.__name__\n        except AttributeError:\n            # We got a string\n            pass\n\n        return self._framework.get_bundle_by_name(module_object)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef emit(self, record):\n        # pylint: disable=W0212\n        \"\"\"\n        Handle a message logged with the logger\n\n        :param record: A log record\n        \"\"\"\n        # Get the bundle\n        bundle = self._bundle_from_module(record.module)\n\n        # Convert to a LogEntry\n        entry = LogEntry(\n            record.levelno, record.getMessage(), None, bundle, None\n        )\n        self._reader._store_entry(entry)", "response": "Handle a log record logged with the logger\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef publish(self, topic, payload, qos=0, retain=False):\n        # TODO: check (full transmission) success\n        return self._client.publish(topic, payload, qos, retain)", "response": "Publishes a MQTT message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _prepare_requirements(configs, requires_filters):\n        if not requires_filters or not isinstance(requires_filters, dict):\n            # No explicit filter configured\n            return configs\n\n        # We need to change a part of the requirements\n        new_requirements = {}\n        for field, config in configs.items():\n            # Extract values from tuple\n            requirement, key, allow_none = config\n\n            try:\n                explicit_filter = requires_filters[field]\n\n                # Store an updated copy of the requirement\n                requirement_copy = requirement.copy()\n                requirement_copy.set_filter(explicit_filter)\n                new_requirements[field] = (requirement_copy, key, allow_none)\n\n            except (KeyError, TypeError, ValueError):\n                # No information for this one, or invalid filter:\n                # keep the factory requirement\n                new_requirements[field] = config\n\n        return new_requirements", "response": "Prepare the requirements dictionary for the component."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of handlers associated to the given component.", "response": "def get_handlers(self, component_context, instance):\n        \"\"\"\n        Sets up service providers for the given component\n\n        :param component_context: The ComponentContext bean\n        :param instance: The component instance\n        :return: The list of handlers associated to the given component\n        \"\"\"\n        # Extract information from the context\n        configs = component_context.get_handler(\n            ipopo_constants.HANDLER_REQUIRES_MAP\n        )\n        requires_filters = component_context.properties.get(\n            ipopo_constants.IPOPO_REQUIRES_FILTERS, None\n        )\n\n        # Prepare requirements\n        configs = self._prepare_requirements(configs, requires_filters)\n\n        # Set up the runtime dependency handlers\n        handlers = []\n        for field, config in configs.items():\n            # Extract values from tuple\n            requirement, key, allow_none = config\n\n            # Construct the handler\n            if requirement.aggregate:\n                handlers.append(\n                    AggregateDependency(field, requirement, key, allow_none)\n                )\n            else:\n                handlers.append(\n                    SimpleDependency(field, requirement, key, allow_none)\n                )\n\n        return handlers"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef manipulate(self, stored_instance, component_instance):\n        # Store the stored instance...\n        self._ipopo_instance = stored_instance\n\n        # ... and the bundle context\n        self._context = stored_instance.bundle_context\n\n        # Set the default value for the field: an empty dictionary\n        setattr(component_instance, self._field, {})", "response": "Manually updates the component instance with the values from the given StoredInstance bean."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clear(self):\n        self.services.clear()\n        self._future_value.clear()\n\n        self.services = None\n        self._lock = None\n        self._ipopo_instance = None\n        self._context = None\n        self.requirement = None\n        self._key = None\n        self._allow_none = None\n        self._future_value = None\n        self._field = None", "response": "Clears up the manager."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_valid(self):\n        return (\n            self.requirement is not None and self.requirement.optional\n        ) or bool(self._future_value)", "response": "Tests if the dependency is in a valid state."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstop the dependency manager and returns a list of the removed bindings or None if no services are available.", "response": "def stop(self):\n        \"\"\"\n        Stops the dependency manager (must be called before clear())\n\n        :return: The removed bindings (list) or None\n        \"\"\"\n        self._context.remove_service_listener(self)\n        if self.services:\n            return [\n                (service, reference)\n                for reference, service in self.services.items()\n            ]\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntrying to bind all services to the required service.", "response": "def try_binding(self):\n        \"\"\"\n        Searches for the required service if needed\n\n        :raise BundleException: Invalid ServiceReference found\n        \"\"\"\n        with self._lock:\n            if self.services:\n                # We already are alive (not our first call)\n                # => we are updated through service events\n                return\n\n            # Get all matching services\n            refs = self._context.get_all_service_references(\n                self.requirement.specification, self.requirement.filter\n            )\n            if not refs:\n                # No match found\n                return\n\n            results = []\n            try:\n                # Bind all new reference\n                for reference in refs:\n                    added = self.on_service_arrival(reference)\n                    if added:\n                        results.append(reference)\n            except BundleException as ex:\n                # Get the logger for this instance\n                logger = logging.getLogger(\n                    \"-\".join((self._ipopo_instance.name, \"RequiresMap-Runtime\"))\n                )\n                logger.debug(\"Error binding multiple references: %s\", ex)\n\n                # Undo what has just been done, ignoring errors\n                for reference in results:\n                    try:\n                        self.on_service_departure(reference)\n\n                    except BundleException as ex2:\n                        logger.debug(\"Error cleaning up: %s\", ex2)\n\n                del results[:]\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling when a service is arrived in the framework.", "response": "def on_service_arrival(self, svc_ref):\n        \"\"\"\n        Called when a service has been registered in the framework\n\n        :param svc_ref: A service reference\n        \"\"\"\n        with self._lock:\n            if svc_ref not in self.services:\n                # Get the key property\n                prop_value = svc_ref.get_property(self._key)\n                if (\n                    prop_value not in self._future_value\n                    and prop_value is not None\n                    or self._allow_none\n                ):\n                    # Matching new property value\n                    service = self._context.get_service(svc_ref)\n\n                    # Store the information\n                    self._future_value[prop_value] = service\n                    self.services[svc_ref] = service\n\n                    # Call back iPOPO\n                    self._ipopo_instance.bind(self, service, svc_ref)\n                    return True\n\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __store_service(self, key, service):\n        self._future_value.setdefault(key, []).append(service)", "response": "Stores the given service in the dictionary\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove the given service from the future dictionary.", "response": "def __remove_service(self, key, service):\n        \"\"\"\n        Removes the given service from the future dictionary\n\n        :param key: Dictionary key\n        :param service: Service to remove from the dictionary\n        \"\"\"\n        try:\n            # Remove the injected service\n            prop_services = self._future_value[key]\n            prop_services.remove(service)\n\n            # Clean up\n            if not prop_services:\n                del self._future_value[key]\n\n        except KeyError:\n            # Ignore: can occur when removing a service with a None property,\n            # if allow_none is False\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_value(self):\n        with self._lock:\n            # The value field must be a deep copy of our dictionary\n            if self._future_value is not None:\n                return {\n                    key: value[:] for key, value in self._future_value.items()\n                }\n\n            return None", "response": "Retrieves the value to inject in the component\n\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling when a service is deactivated from the framework", "response": "def on_service_departure(self, svc_ref):\n        \"\"\"\n        Called when a service has been unregistered from the framework\n\n        :param svc_ref: A service reference\n        :return: A tuple (service, reference) if the service has been lost,\n                 else None\n        \"\"\"\n        with self._lock:\n            if svc_ref in self.services:\n                # Get the service instance\n                service = self.services.pop(svc_ref)\n\n                # Get the key property\n                prop_value = svc_ref.get_property(self._key)\n\n                # Remove the injected service\n                self.__remove_service(prop_value, service)\n\n                self._ipopo_instance.unbind(self, service, svc_ref)\n                return True\n\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_service_modify(self, svc_ref, old_properties):\n        with self._lock:\n            if svc_ref not in self.services:\n                # A previously registered service now matches our filter\n                return self.on_service_arrival(svc_ref)\n            else:\n                # Get the property values\n                service = self.services[svc_ref]\n                old_value = old_properties.get(self._key)\n                prop_value = svc_ref.get_property(self._key)\n\n                if old_value != prop_value:\n                    # Key changed\n                    if prop_value is not None or self._allow_none:\n                        # New property accepted\n                        if old_value is not None or self._allow_none:\n                            self.__remove_service(old_value, service)\n\n                        self.__store_service(prop_value, service)\n\n                        # Notify the property modification, with a value change\n                        self._ipopo_instance.update(\n                            self, service, svc_ref, old_properties, True\n                        )\n                    else:\n                        # Consider the service as gone\n                        self.__remove_service(old_value, service)\n                        del self.services[svc_ref]\n                        self._ipopo_instance.unbind(self, service, svc_ref)\n                else:\n                    # Simple property update\n                    self._ipopo_instance.update(\n                        self, service, svc_ref, old_properties, False\n                    )\n\n            return None", "response": "Called when a service has been modified in the framework."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef match_sr(self, svc_ref, cid=None):\n        # type: (ServiceReference, Optional[Tuple[str, str]] ) -> bool\n        \"\"\"\n        Checks if this export registration matches the given service reference\n\n        :param svc_ref: A service reference\n        :param cid: A container ID\n        :return: True if the service matches this export registration\n        \"\"\"\n        with self.__lock:\n            our_sr = self.get_reference()\n            if our_sr is None:\n                return False\n\n            sr_compare = our_sr == svc_ref\n            if cid is None:\n                return sr_compare\n\n            our_cid = self.get_export_container_id()\n            if our_cid is None:\n                return False\n\n            return sr_compare and our_cid == cid", "response": "Checks if this export registration matches the given service reference and container ID."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the exception associated to the export if any otherwise returns None.", "response": "def get_exception(self):\n        # type: () -> Optional[Tuple[Any, Any, Any]]\n        \"\"\"\n        Returns the exception associated to the export\n\n        :return: An exception tuple, if any\n        \"\"\"\n        with self.__lock:\n            return (\n                self.__updateexception\n                if self.__updateexception or self.__closed\n                else self.__exportref.get_exception()\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncloses the export endpoint and all related resources.", "response": "def close(self):\n        \"\"\"\n        Cleans up the export endpoint\n        \"\"\"\n        publish = False\n        exporterid = rsid = exception = export_ref = ed = None\n        with self.__lock:\n            if not self.__closed:\n                exporterid = self.__exportref.get_export_container_id()\n                export_ref = self.__exportref\n                rsid = self.__exportref.get_remoteservice_id()\n                ed = self.__exportref.get_description()\n                exception = self.__exportref.get_exception()\n                self.__closed = True\n                publish = self.__exportref.close(self)\n                self.__exportref = None\n\n        # pylint: disable=W0212\n        if publish and export_ref and self.__rsa:\n            self.__rsa._publish_event(\n                RemoteServiceAdminEvent.fromexportunreg(\n                    self.__rsa._get_bundle(),\n                    exporterid,\n                    rsid,\n                    export_ref,\n                    exception,\n                    ed,\n                )\n            )\n            self.__rsa = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef advertise_endpoint(self, endpoint_description):\n        endpoint_id = endpoint_description.get_id()\n        with self._published_endpoints_lock:\n            if self.get_advertised_endpoint(endpoint_id) is not None:\n                return False\n\n            advertise_result = self._advertise(endpoint_description)\n            if advertise_result:\n                self._add_advertised(endpoint_description, advertise_result)\n                return True\n\n            return False", "response": "Advertise and add an endpoint_description to the cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating an existing endpoint_description.", "response": "def update_endpoint(self, updated_ed):\n        \"\"\"\n        Update a previously advertised endpoint_description.\n\n        :param endpoint_description: an instance of EndpointDescription to\n        update. Must not be None.\n        :return: True if advertised, False if not\n        (e.g. it's already been advertised)\n        \"\"\"\n        endpoint_id = updated_ed.get_id()\n        with self._published_endpoints_lock:\n            if self.get_advertised_endpoint(endpoint_id) is None:\n                return False\n\n            advertise_result = self._update(updated_ed)\n            if advertise_result:\n                self._remove_advertised(endpoint_id)\n                self._add_advertised(updated_ed, advertise_result)\n                return True\n\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_handlers(self, component_context, instance):\n        # Retrieve the handler configuration\n        provides = component_context.get_handler(\n            ipopo_constants.HANDLER_PROVIDES\n        )\n        if not provides:\n            # Nothing to do\n            return ()\n\n        # 1 handler per provided service\n        return [\n            ServiceRegistrationHandler(\n                specs, controller, is_factory, is_prototype\n            )\n            for specs, controller, is_factory, is_prototype in provides\n        ]", "response": "Returns a list of handlers associated to the given component."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating the methods called by the injected controller", "response": "def _field_controller_generator(self):\n        \"\"\"\n        Generates the methods called by the injected controller\n        \"\"\"\n        # Local variable, to avoid messing with \"self\"\n        stored_instance = self._ipopo_instance\n\n        def get_value(self, name):\n            # pylint: disable=W0613\n            \"\"\"\n            Retrieves the controller value, from the iPOPO dictionaries\n\n            :param name: The property name\n            :return: The property value\n            \"\"\"\n            return stored_instance.get_controller_state(name)\n\n        def set_value(self, name, new_value):\n            # pylint: disable=W0613\n            \"\"\"\n            Sets the property value and trigger an update event\n\n            :param name: The property name\n            :param new_value: The new property value\n            \"\"\"\n            # Get the previous value\n            old_value = stored_instance.get_controller_state(name)\n            if new_value != old_value:\n                # Update the controller state\n                stored_instance.set_controller_state(name, new_value)\n\n            return new_value\n\n        return get_value, set_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmanipulates the component instance :param stored_instance: The iPOPO component StoredInstance :param component_instance: The component instance", "response": "def manipulate(self, stored_instance, component_instance):\n        \"\"\"\n        Manipulates the component instance\n\n        :param stored_instance: The iPOPO component StoredInstance\n        :param component_instance: The component instance\n        \"\"\"\n        # Store the stored instance\n        self._ipopo_instance = stored_instance\n\n        if self.__controller is None:\n            # No controller: do nothing\n            return\n\n        # Get the current value of the member (True by default)\n        controller_value = getattr(component_instance, self.__controller, True)\n\n        # Store the controller value\n        stored_instance.set_controller_state(\n            self.__controller, controller_value\n        )\n\n        # Prepare the methods names\n        getter_name = \"{0}{1}\".format(\n            ipopo_constants.IPOPO_CONTROLLER_PREFIX,\n            ipopo_constants.IPOPO_GETTER_SUFFIX,\n        )\n        setter_name = \"{0}{1}\".format(\n            ipopo_constants.IPOPO_CONTROLLER_PREFIX,\n            ipopo_constants.IPOPO_SETTER_SUFFIX,\n        )\n\n        # Inject the getter and setter at the instance level\n        getter, setter = self._field_controller_generator()\n        setattr(component_instance, getter_name, getter)\n        setattr(component_instance, setter_name, setter)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef on_controller_change(self, name, value):\n        if self.__controller != name:\n            # Nothing to do\n            return\n\n        # Update the controller value\n        self.__controller_on = value\n        if value:\n            # Controller switched to \"ON\"\n            self._register_service()\n        else:\n            # Controller switched to \"OFF\"\n            self._unregister_service()", "response": "Called by the instance manager when a controller value has been changed"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_property_change(self, name, old_value, new_value):\n        if self._registration is not None:\n            # use the registration to trigger the service event\n            self._registration.set_properties({name: new_value})", "response": "Called by the instance manager when a component property is changed."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters the provided service with the component if possible.", "response": "def _register_service(self):\n        \"\"\"\n        Registers the provided service, if possible\n        \"\"\"\n        if (\n            self._registration is None\n            and self.specifications\n            and self.__validated\n            and self.__controller_on\n        ):\n            # Use a copy of component properties\n            properties = self._ipopo_instance.context.properties.copy()\n            bundle_context = self._ipopo_instance.bundle_context\n\n            # Register the service\n            self._registration = bundle_context.register_service(\n                self.specifications,\n                self._ipopo_instance.instance,\n                properties,\n                factory=self.__is_factory,\n                prototype=self.__is_prototype,\n            )\n            self._svc_reference = self._registration.get_reference()\n\n            # Notify the component\n            self._ipopo_instance.safe_callback(\n                ipopo_constants.IPOPO_CALLBACK_POST_REGISTRATION,\n                self._svc_reference,\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef use_service(bundle_context, svc_reference):\n    if svc_reference is None:\n        raise TypeError(\"Invalid ServiceReference\")\n\n    try:\n        # Give the service\n        yield bundle_context.get_service(svc_reference)\n    finally:\n        try:\n            # Release it\n            bundle_context.unget_service(svc_reference)\n        except pelix.constants.BundleException:\n            # Service might have already been unregistered\n            pass", "response": "Utility context to safely use a service in a with block."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef SynchronizedClassMethod(*locks_attr_names, **kwargs):\n    # pylint: disable=C1801\n    \"\"\"\n    A synchronizer decorator for class methods. An AttributeError can be raised\n    at runtime if the given lock attribute doesn't exist or if it is None.\n\n    If a parameter ``sorted`` is found in ``kwargs`` and its value is True,\n    then the list of locks names will be sorted before locking.\n\n    :param locks_attr_names: A list of the lock(s) attribute(s) name(s) to be\n                             used for synchronization\n    :return: The decorator method, surrounded with the lock\n    \"\"\"\n    # Filter the names (remove empty ones)\n    locks_attr_names = [\n        lock_name for lock_name in locks_attr_names if lock_name\n    ]\n\n    if not locks_attr_names:\n        raise ValueError(\"The lock names list can't be empty\")\n\n    if \"sorted\" not in kwargs or kwargs[\"sorted\"]:\n        # Sort the lock names if requested\n        # (locking always in the same order reduces the risk of dead lock)\n        locks_attr_names = list(locks_attr_names)\n        locks_attr_names.sort()\n\n    def wrapped(method):\n        \"\"\"\n        The wrapping method\n\n        :param method: The wrapped method\n        :return: The wrapped method\n        :raise AttributeError: The given attribute name doesn't exist\n        \"\"\"\n\n        @functools.wraps(method)\n        def synchronized(self, *args, **kwargs):\n            \"\"\"\n            Calls the wrapped method with a lock\n            \"\"\"\n            # Raises an AttributeError if needed\n            locks = [getattr(self, attr_name) for attr_name in locks_attr_names]\n            locked = collections.deque()\n            i = 0\n\n            try:\n                # Lock\n                for lock in locks:\n                    if lock is None:\n                        # No lock...\n                        raise AttributeError(\n                            \"Lock '{0}' can't be None in class {1}\".format(\n                                locks_attr_names[i], type(self).__name__\n                            )\n                        )\n\n                    # Get the lock\n                    i += 1\n                    lock.acquire()\n                    locked.appendleft(lock)\n\n                # Use the method\n                return method(self, *args, **kwargs)\n\n            finally:\n                # Unlock what has been locked in all cases\n                for lock in locked:\n                    lock.release()\n\n                locked.clear()\n                del locks[:]\n\n        return synchronized\n\n    # Return the wrapped method\n    return wrapped", "response": "A synchronizer for class methods."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_lock(lock):\n    if lock is None:\n        # Don't do useless tests\n        return False\n\n    for attr in \"acquire\", \"release\", \"__enter__\", \"__exit__\":\n        if not hasattr(lock, attr):\n            # Missing something\n            return False\n\n    # Same API as a lock\n    return True", "response": "Tests if the given lock is an instance of a lock class\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list with duplicates removed in the same order", "response": "def remove_duplicates(items):\n    \"\"\"\n    Returns a list without duplicates, keeping elements order\n\n    :param items: A list of items\n    :return: The list without duplicates, in the same order\n    \"\"\"\n    if items is None:\n        return items\n\n    new_list = []\n    for item in items:\n        if item not in new_list:\n            new_list.append(item)\n    return new_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a listener to the list of events in the order they were registered.", "response": "def add_listener(registry, listener):\n    \"\"\"\n    Adds a listener in the registry, if it is not yet in\n\n    :param registry: A registry (a list)\n    :param listener: The listener to register\n    :return: True if the listener has been added\n    \"\"\"\n    if listener is None or listener in registry:\n        return False\n\n    registry.append(listener)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_listener(registry, listener):\n    if listener is not None and listener in registry:\n        registry.remove(listener)\n        return True\n\n    return False", "response": "Removes a listener from the registry"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntries to convert the given value to an iterable if necessary.", "response": "def to_iterable(value, allow_none=True):\n    \"\"\"\n    Tries to convert the given value to an iterable, if necessary.\n    If the given value is a list, a list is returned; if it is a string, a list\n    containing one string is returned, ...\n\n    :param value: Any object\n    :param allow_none: If True, the method returns None if value is None, else\n                       it returns an empty list\n    :return: A list containing the given string, or the given value\n    \"\"\"\n    if value is None:\n        # None given\n        if allow_none:\n            return None\n\n        return []\n\n    elif isinstance(value, (list, tuple, set, frozenset)):\n        # Iterable given, return it as-is\n        return value\n\n    # Return a one-value list\n    return [value]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlog the deprecation message on first call does nothing after is logged", "response": "def __log(self, method_name):\n        \"\"\"\n        Logs the deprecation message on first call, does nothing after\n\n        :param method_name: Name of the deprecated method\n        \"\"\"\n        if not self.__already_logged:\n            # Print only if not already done\n            stack = \"\\n\\t\".join(traceback.format_stack())\n\n            logging.getLogger(self.__logger).warning(\n                \"%s: %s\\n%s\", method_name, self.__message, stack\n            )\n            self.__already_logged = True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef step(self):\n        # type: () -> bool\n        \"\"\"\n        Decreases the internal counter. Raises an error if the counter goes\n        below 0\n\n        :return: True if this step was the final one, else False\n        :raise ValueError: The counter has gone below 0\n        \"\"\"\n        with self.__lock:\n            self.__value -= 1\n            if self.__value == 0:\n                # All done\n                self.__event.set()\n                return True\n            elif self.__value < 0:\n                # Gone too far\n                raise ValueError(\"The counter has gone below 0\")\n\n        return False", "response": "Decreases the internal counter and returns True if this step was the final one. Raises an error if the counter goes below 0\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplay the available bundle matches and the bundle name.", "response": "def display_hook(prompt, session, context, matches, longest_match_len):\n        # type: (str, ShellSession, BundleContext, List[str], int) -> None\n        \"\"\"\n        Displays the available bundle matches and the bundle name\n\n        :param prompt: Shell prompt string\n        :param session: Current shell session (for display)\n        :param context: BundleContext of the shell\n        :param matches: List of words matching the substitution\n        :param longest_match_len: Length of the largest match\n        \"\"\"\n        # Prepare a line pattern for each match\n        match_pattern = \"{{0: >{}}}: {{1}}\".format(longest_match_len)\n\n        # Sort matching IDs\n        matches = sorted(int(match) for match in matches)\n\n        # Print the match and the associated name\n        session.write_line()\n        for bnd_id in matches:\n            bnd = context.get_bundle(bnd_id)\n            session.write_line(match_pattern, bnd_id, bnd.get_symbolic_name())\n\n        # Print the prompt, then current line\n        session.write(prompt)\n        session.write_line_no_feed(readline.get_line_buffer())\n        readline.redisplay()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncompletes the current word - value - list of bundle IDs matching the current word - value", "response": "def complete(\n        self, config, prompt, session, context, current_arguments, current\n    ):\n        # type: (CompletionInfo, str, ShellSession, BundleContext, List[str], str) -> List[str]\n        \"\"\"\n        Returns the list of bundle IDs matching the current state\n\n        :param config: Configuration of the current completion\n        :param prompt: Shell prompt (for re-display)\n        :param session: Shell session (to display in shell)\n        :param context: Bundle context of the Shell bundle\n        :param current_arguments: Current arguments (without the command itself)\n        :param current: Current word\n        :return: A list of matches\n        \"\"\"\n        # Register a method to display helpful completion\n        self.set_display_hook(self.display_hook, prompt, session, context)\n\n        # Return a list of bundle IDs (strings) matching the current value\n        # and not yet in arguments\n        rl_matches = []\n        for bnd in context.get_bundles():\n            bnd_id = \"{0} \".format(bnd.get_bundle_id())\n            if bnd_id.startswith(current):\n                rl_matches.append(bnd_id)\n\n        return rl_matches"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisplays the available services matches and the service details.", "response": "def display_hook(prompt, session, context, matches, longest_match_len):\n        # type: (str, ShellSession, BundleContext, List[str], int) -> None\n        \"\"\"\n        Displays the available services matches and the service details\n\n        :param prompt: Shell prompt string\n        :param session: Current shell session (for display)\n        :param context: BundleContext of the shell\n        :param matches: List of words matching the substitution\n        :param longest_match_len: Length of the largest match\n        \"\"\"\n        try:\n            # Prepare a line pattern for each match\n            match_pattern = \"{{0: >{}}}: {{1}}\".format(longest_match_len)\n\n            # Sort matching IDs\n            matches = sorted(int(match) for match in matches)\n\n            # Print the match and the associated name\n            session.write_line()\n            for svc_id in matches:\n                svc_ref = context.get_service_reference(\n                    None, \"({}={})\".format(SERVICE_ID, svc_id)\n                )\n                session.write_line(match_pattern, svc_id, str(svc_ref))\n\n            # Print the prompt, then current line\n            session.write(prompt)\n            session.write_line_no_feed(readline.get_line_buffer())\n            readline.redisplay()\n        except Exception as ex:\n            session.write_line(\"\\n{}\\n\\n\", ex)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncompletes the current value of the current key - value pair.", "response": "def complete(\n        self, config, prompt, session, context, current_arguments, current\n    ):\n        # type: (CompletionInfo, str, ShellSession, BundleContext, List[str], str) -> List[str]\n        \"\"\"\n        Returns the list of services IDs matching the current state\n\n        :param config: Configuration of the current completion\n        :param prompt: Shell prompt (for re-display)\n        :param session: Shell session (to display in shell)\n        :param context: Bundle context of the Shell bundle\n        :param current_arguments: Current arguments (without the command itself)\n        :param current: Current word\n        :return: A list of matches\n        \"\"\"\n        # Register a method to display helpful completion\n        self.set_display_hook(self.display_hook, prompt, session, context)\n\n        # Return a list of bundle IDs (strings) matching the current value\n        # and not yet in arguments\n        rl_matches = []\n        for svc_ref in context.get_all_service_references(None, None):\n            svc_id = \"{0} \".format(svc_ref.get_property(SERVICE_ID))\n            if svc_id.startswith(current):\n                rl_matches.append(svc_id)\n\n        return rl_matches"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if this distribution provider supports export for given exported_configs service_intents and export_props.", "response": "def supports_export(self, exported_configs, service_intents, export_props):\n        \"\"\"\n        Method called by rsa.export_service to ask if this\n        ExportDistributionProvider supports export for given\n        exported_configs (list), service_intents (list), and\n        export_props (dict).\n\n        If a ExportContainer instance is returned then it is used to export\n        the service.  If None is returned, then this distribution provider will\n        not be used to export the service.\n\n        The default implementation returns self._get_or_create_container.\n        \"\"\"\n        return self._get_or_create_container(\n            exported_configs, service_intents, export_props\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if this distribution provider supports import for given exported_configs service_intents and endpoint_props.", "response": "def supports_import(\n        self, exported_configs, service_intents, endpoint_props\n    ):\n        \"\"\"\n        Method called by rsa.export_service to ask if this\n        ImportDistributionProvider supports import for given\n        exported_configs (list), service_intents (list), and\n        export_props (dict).\n\n        If a ImportContainer instance is returned then it is used to import\n        the service.  If None is returned, then this distribution provider will\n        not be used to import the service.\n\n        The default implementation returns self._get_or_create_container.\n        \"\"\"\n        return self._get_or_create_container(\n            exported_configs, service_intents, endpoint_props\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if the component is valid.", "response": "def is_valid(self):\n        # type: () -> bool\n        \"\"\"\n        Checks if the component is valid\n\n        :return: Always True if it doesn't raise an exception\n        :raises AssertionError: Invalid properties\n        \"\"\"\n        assert self._bundle_context\n        assert self._container_props is not None\n        assert self._get_distribution_provider()\n        assert self.get_config_name()\n        assert self.get_namespace()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validate_component(self, bundle_context, container_props):\n        # type: (BundleContext, Dict[str, Any]) -> None\n        \"\"\"\n        Component validated\n\n        :param bundle_context: Bundle context\n        :param container_props: Instance properties\n        :raises AssertionError: Invalid properties\n        \"\"\"\n        self._bundle_context = bundle_context\n        self._container_props = container_props\n        self.is_valid()", "response": "Component validated\n\n        :param bundle_context: Bundle context\n        :param container_props: Instance properties\n        :raises AssertionError: Invalid properties"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _add_export(self, ed_id, inst):\n        # type: (str, Tuple[Any, EndpointDescription]) -> None\n        \"\"\"\n        Keeps track of an exported service\n\n        :param ed_id: ID of the endpoint description\n        :param inst: A tuple: (service instance, endpoint description)\n        \"\"\"\n        with self._exported_instances_lock:\n            self._exported_services[ed_id] = inst", "response": "Adds an exported service instance to the exported list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _find_export(self, func):\n        # type: (Callable[[Tuple[Any, EndpointDescription]], bool]) -> Optional[Tuple[Any, EndpointDescription]]\n        \"\"\"\n        Look for an export using the given lookup method\n\n        The lookup method must accept a single parameter, which is a tuple\n        containing a service instance and endpoint description.\n\n        :param func: A function to look for the excepted export\n        :return: The found tuple or None\n        \"\"\"\n        with self._exported_instances_lock:\n            for val in self._exported_services.values():\n                if func(val):\n                    return val\n\n            return None", "response": "Searches for an export using a given function"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters a service export entry into the cache.", "response": "def _export_service(self, svc, ed):\n        # type: (Any, EndpointDescription) -> None\n        \"\"\"\n        Registers a service export\n\n        :param svc: Service instance\n        :param ed: Endpoint description\n        \"\"\"\n        self._add_export(ed.get_id(), (svc, ed))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprepare the properties of an endpoint", "response": "def prepare_endpoint_props(self, intfs, svc_ref, export_props):\n        # type: (List[str], ServiceReference, Dict[str, Any]) -> Dict[str, Any]\n        \"\"\"\n        Sets up the properties of an endpoint\n\n        :param intfs: Specifications to export\n        :param svc_ref: Reference of the exported service\n        :param export_props: Export properties\n        :return: The properties of the endpoint\n        \"\"\"\n        pkg_vers = rsa.get_package_versions(intfs, export_props)\n        exported_configs = get_string_plus_property_value(\n            svc_ref.get_property(SERVICE_EXPORTED_CONFIGS)\n        )\n        if not exported_configs:\n            exported_configs = [self.get_config_name()]\n        service_intents = set()\n        svc_intents = export_props.get(SERVICE_INTENTS, None)\n        if svc_intents:\n            service_intents.update(svc_intents)\n        svc_exp_intents = export_props.get(SERVICE_EXPORTED_INTENTS, None)\n        if svc_exp_intents:\n            service_intents.update(svc_exp_intents)\n        svc_exp_intents_extra = export_props.get(\n            SERVICE_EXPORTED_INTENTS_EXTRA, None\n        )\n        if svc_exp_intents_extra:\n            service_intents.update(svc_exp_intents_extra)\n\n        rsa_props = rsa.get_rsa_props(\n            intfs,\n            exported_configs,\n            self._get_supported_intents(),\n            svc_ref.get_property(SERVICE_ID),\n            export_props.get(ENDPOINT_FRAMEWORK_UUID),\n            pkg_vers,\n            list(service_intents),\n        )\n        ecf_props = rsa.get_ecf_props(\n            self.get_id(),\n            self.get_namespace(),\n            rsa.get_next_rsid(),\n            rsa.get_current_time_millis(),\n        )\n        extra_props = rsa.get_extra_props(export_props)\n        merged = rsa.merge_dicts(rsa_props, ecf_props, extra_props)\n        # remove service.bundleid\n        merged.pop(SERVICE_BUNDLE_ID, None)\n        # remove service.scope\n        merged.pop(SERVICE_SCOPE, None)\n        return merged"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexport the given service to the given set of properties.", "response": "def export_service(self, svc_ref, export_props):\n        # type: (ServiceReference, Dict[str, Any]) -> EndpointDescription\n        \"\"\"\n        Exports the given service\n\n        :param svc_ref: Reference to the service to export\n        :param export_props: Export properties\n        :return: The endpoint description\n        \"\"\"\n        ed = EndpointDescription.fromprops(export_props)\n        self._export_service(\n            self._get_bundle_context().get_service(svc_ref), ed\n        )\n        return ed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nflushing buffered data to the target", "response": "def flush(self):\n        \"\"\"\n        Sends buffered data to the target\n        \"\"\"\n        # Flush buffer\n        content = self._buffer.getvalue()\n        self._buffer = StringIO()\n\n        if content:\n            # Send message\n            self._client.send_message(self._target, content, mtype=\"chat\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a service instance from a Prototype Service Factory and a ServiceRegistration object", "response": "def _get_from_factory(self, factory, svc_registration):\n        # type: (Any, ServiceRegistration) -> Any\n        \"\"\"\n        Returns a service instance from a Prototype Service Factory\n\n        :param factory: The prototype service factory\n        :param svc_registration: The ServiceRegistration object\n        :return: The requested service instance returned by the factory\n        \"\"\"\n        svc_ref = svc_registration.get_reference()\n        try:\n            # Use the existing service\n            service, counter = self.__factored[svc_ref]\n            counter.inc()\n        except KeyError:\n            # Create the service\n            service = factory.get_service(self.__bundle, svc_registration)\n            counter = _UsageCounter()\n            counter.inc()\n\n            # Store the counter\n            self.__factored[svc_ref] = (service, counter)\n\n        return service"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a service instance from a Prototype Service Factory", "response": "def _get_from_prototype(self, factory, svc_registration):\n        # type: (Any, ServiceRegistration) -> Any\n        \"\"\"\n        Returns a service instance from a Prototype Service Factory\n\n        :param factory: The service factory\n        :param svc_registration: The ServiceRegistration object\n        :return: The requested service instance returned by the factory\n        \"\"\"\n        svc_ref = svc_registration.get_reference()\n        service = factory.get_service(self.__bundle, svc_registration)\n\n        try:\n            # Check if the service already exists\n            services, counter = self.__factored[svc_ref]\n            services.append(service)\n            counter.inc()\n        except KeyError:\n            counter = _UsageCounter()\n            counter.inc()\n\n            # Store the counter\n            self.__factored[svc_ref] = ([service], counter)\n\n        return service"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the service required by the bundle.", "response": "def get_service(self, factory, svc_registration):\n        # type: (Any, ServiceRegistration) -> Any\n        \"\"\"\n        Returns the service required by the bundle. The Service Factory is\n        called only when necessary while the Prototype Service Factory is\n        called each time\n\n        :param factory: The service factory\n        :param svc_registration: The ServiceRegistration object\n        :return: The requested service instance (created if necessary)\n        \"\"\"\n        svc_ref = svc_registration.get_reference()\n        if svc_ref.is_prototype():\n            return self._get_from_prototype(factory, svc_registration)\n\n        return self._get_from_factory(factory, svc_registration)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreleases references to the given service reference :param factory: The service factory :param svc_registration: The ServiceRegistration object :param service: Service instance (for prototype factories) :return: True if all service references to this service factory have been released", "response": "def unget_service(self, factory, svc_registration, service=None):\n        # type: (Any, ServiceRegistration, Any) -> bool\n        \"\"\"\n        Releases references to the given service reference\n\n        :param factory: The service factory\n        :param svc_registration: The ServiceRegistration object\n        :param service: Service instance (for prototype factories)\n        :return: True if all service references to this service factory\n                 have been released\n        \"\"\"\n        svc_ref = svc_registration.get_reference()\n        try:\n            _, counter = self.__factored[svc_ref]\n        except KeyError:\n            logging.warning(\n                \"Trying to release an unknown service factory: %s\", svc_ref\n            )\n        else:\n            if svc_ref.is_prototype():\n                # Notify the factory to clean up this instance\n                factory.unget_service_instance(\n                    self.__bundle, svc_registration, service\n                )\n\n            if not counter.dec():\n                # All references have been released: clean up\n                del self.__factored[svc_ref]\n\n                # Call the factory\n                factory.unget_service(self.__bundle, svc_registration)\n\n                # No more reference to this service\n                return True\n\n        # Some references are still there\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the reference to the given service from the bundle if it was using that factory.", "response": "def cleanup_service(self, factory, svc_registration):\n        # type: (Any, ServiceRegistration) -> bool\n        \"\"\"\n        If this bundle used that factory, releases the reference; else does\n        nothing\n\n        :param factory: The service factory\n        :param svc_registration: The ServiceRegistration object\n        :return: True if the bundle was using the factory, else False\n        \"\"\"\n        svc_ref = svc_registration.get_reference()\n        try:\n            # \"service\" for factories, \"services\" for prototypes\n            services, _ = self.__factored.pop(svc_ref)\n        except KeyError:\n            return False\n        else:\n            if svc_ref.is_prototype() and services:\n                for service in services:\n                    try:\n                        factory.unget_service_instance(\n                            self.__bundle, svc_registration, service\n                        )\n                    except Exception:\n                        # Ignore instance-level exceptions, potential errors\n                        # will reappear in unget_service()\n                        pass\n\n            # Call the factory\n            factory.unget_service(self.__bundle, svc_registration)\n\n            # No more association\n            svc_ref.unused_by(self.__bundle)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nindicates that this reference is not being used anymore by the given bundle. This method should only be used by the framework. :param bundle: A bundle that used this reference", "response": "def unused_by(self, bundle):\n        \"\"\"\n        Indicates that this reference is not being used anymore by the given\n        bundle.\n        This method should only be used by the framework.\n\n        :param bundle: A bundle that used this reference\n        \"\"\"\n        if bundle is None or bundle is self.__bundle:\n            # Ignore\n            return\n\n        with self.__usage_lock:\n            try:\n                if not self.__using_bundles[bundle].dec():\n                    # This bundle has cleaner all of its usages of this\n                    # reference\n                    del self.__using_bundles[bundle]\n            except KeyError:\n                # Ignore error\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef used_by(self, bundle):\n        if bundle is None or bundle is self.__bundle:\n            # Ignore\n            return\n\n        with self.__usage_lock:\n            self.__using_bundles.setdefault(bundle, _UsageCounter()).inc()", "response": "Indicates that this reference is being used by the given bundle."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_properties(self, properties):\n        if not isinstance(properties, dict):\n            raise TypeError(\"Waiting for dictionary\")\n\n        # Keys that must not be updated\n        for forbidden_key in OBJECTCLASS, SERVICE_ID:\n            try:\n                del properties[forbidden_key]\n            except KeyError:\n                pass\n\n        to_delete = []\n        for key, value in properties.items():\n            if self.__properties.get(key) == value:\n                # No update\n                to_delete.append(key)\n\n        for key in to_delete:\n            # Remove unchanged properties\n            del properties[key]\n\n        if not properties:\n            # Nothing to do\n            return\n\n        # Ensure that the service has a valid service ranking\n        try:\n            properties[SERVICE_RANKING] = int(properties[SERVICE_RANKING])\n        except (ValueError, TypeError):\n            # Bad value: ignore update\n            del properties[SERVICE_RANKING]\n        except KeyError:\n            # Service ranking not updated: ignore\n            pass\n\n        # pylint: disable=W0212\n        with self.__reference._props_lock:\n            # Update the properties\n            previous = self.__properties.copy()\n            self.__properties.update(properties)\n\n            if self.__reference.needs_sort_update():\n                # The sort key and the registry must be updated\n                self.__update_callback(self.__reference)\n\n            # Trigger a new computation in the framework\n            event = ServiceEvent(\n                ServiceEvent.MODIFIED, self.__reference, previous\n            )\n\n            self.__framework._dispatcher.fire_service_event(event)", "response": "Updates the properties of the service with the given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear(self):\n        with self.__bnd_lock:\n            self.__bnd_listeners = []\n\n        with self.__svc_lock:\n            self.__svc_listeners.clear()\n\n        with self.__fw_lock:\n            self.__fw_listeners = []", "response": "Clears the event dispatcher and all associated listeners"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a bundle listener to the list of bundle listeners.", "response": "def add_bundle_listener(self, listener):\n        \"\"\"\n        Adds a bundle listener\n\n        :param listener: The bundle listener to register\n        :return: True if the listener has been registered, False if it was\n                 already known\n        :raise BundleException: An invalid listener has been given\n        \"\"\"\n        if listener is None or not hasattr(listener, \"bundle_changed\"):\n            raise BundleException(\"Invalid bundle listener given\")\n\n        with self.__bnd_lock:\n            if listener in self.__bnd_listeners:\n                self._logger.warning(\n                    \"Already known bundle listener '%s'\", listener\n                )\n                return False\n\n            self.__bnd_listeners.append(listener)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_framework_listener(self, listener):\n        if listener is None or not hasattr(listener, \"framework_stopping\"):\n            raise BundleException(\"Invalid framework listener given\")\n\n        with self.__fw_lock:\n            if listener in self.__fw_listeners:\n                self._logger.warning(\n                    \"Already known framework listener '%s'\", listener\n                )\n                return False\n\n            self.__fw_listeners.append(listener)\n            return True", "response": "Adds a listener that will be called back right before the framework stops."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_service_listener(\n        self, bundle_context, listener, specification=None, ldap_filter=None\n    ):\n        \"\"\"\n        Registers a service listener\n\n        :param bundle_context: The bundle_context of the service listener\n        :param listener: The service listener\n        :param specification: The specification that must provide the service\n                              (optional, None to accept all services)\n        :param ldap_filter: Filter that must match the service properties\n                            (optional, None to accept all services)\n        :return: True if the listener has been registered, False if it was\n                 already known\n        :raise BundleException: An invalid listener has been given\n        \"\"\"\n        if listener is None or not hasattr(listener, \"service_changed\"):\n            raise BundleException(\"Invalid service listener given\")\n\n        with self.__svc_lock:\n            if listener in self.__listeners_data:\n                self._logger.warning(\n                    \"Already known service listener '%s'\", listener\n                )\n                return False\n\n            try:\n                ldap_filter = ldapfilter.get_ldap_filter(ldap_filter)\n            except ValueError as ex:\n                raise BundleException(\"Invalid service filter: {0}\".format(ex))\n\n            stored = ListenerInfo(\n                bundle_context, listener, specification, ldap_filter\n            )\n            self.__listeners_data[listener] = stored\n            self.__svc_listeners.setdefault(specification, []).append(stored)\n            return True", "response": "Adds a service listener to the list of services that have been added to the service."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_bundle_listener(self, listener):\n        with self.__bnd_lock:\n            if listener not in self.__bnd_listeners:\n                return False\n\n            self.__bnd_listeners.remove(listener)\n            return True", "response": "Removes a bundle listener"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving a framework stop listener", "response": "def remove_framework_listener(self, listener):\n        \"\"\"\n        Unregisters a framework stop listener\n\n        :param listener: The framework listener to unregister\n        :return: True if the listener has been unregistered, else False\n        \"\"\"\n        with self.__fw_lock:\n            try:\n                self.__fw_listeners.remove(listener)\n                return True\n            except ValueError:\n                return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_service_listener(self, listener):\n        with self.__svc_lock:\n            try:\n                data = self.__listeners_data.pop(listener)\n                spec_listeners = self.__svc_listeners[data.specification]\n                spec_listeners.remove(data)\n                if not spec_listeners:\n                    del self.__svc_listeners[data.specification]\n                return True\n            except KeyError:\n                return False", "response": "Removes a service listener from the list of available service listeners."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fire_bundle_event(self, event):\n        with self.__bnd_lock:\n            # Copy the list of listeners\n            listeners = self.__bnd_listeners[:]\n\n        # Call'em all\n        for listener in listeners:\n            try:\n                listener.bundle_changed(event)\n            except:\n                self._logger.exception(\"Error calling a bundle listener\")", "response": "Fires a bundle event in all the listeners of the bundle"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfire the framework stopping event for the current node", "response": "def fire_framework_stopping(self):\n        \"\"\"\n        Calls all framework listeners, telling them that the framework is\n        stopping\n        \"\"\"\n        with self.__fw_lock:\n            # Copy the list of listeners\n            listeners = self.__fw_listeners[:]\n\n        for listener in listeners:\n            try:\n                listener.framework_stopping()\n            except:\n                self._logger.exception(\n                    \"An error occurred calling one of the \"\n                    \"framework stop listeners\"\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fire_service_event(self, event):\n        # Get the service properties\n        properties = event.get_service_reference().get_properties()\n        svc_specs = properties[OBJECTCLASS]\n        previous = None\n        endmatch_event = None\n        svc_modified = event.get_kind() == ServiceEvent.MODIFIED\n\n        if svc_modified:\n            # Modified service event : prepare the end match event\n            previous = event.get_previous_properties()\n            endmatch_event = ServiceEvent(\n                ServiceEvent.MODIFIED_ENDMATCH,\n                event.get_service_reference(),\n                previous,\n            )\n\n        with self.__svc_lock:\n            # Get the listeners for this specification\n            listeners = set()\n            for spec in svc_specs:\n                try:\n                    listeners.update(self.__svc_listeners[spec])\n                except KeyError:\n                    pass\n\n            # Add those which listen to any specification\n            try:\n                listeners.update(self.__svc_listeners[None])\n            except KeyError:\n                pass\n\n        # Filter listeners with EventListenerHooks\n        listeners = self._filter_with_hooks(event, listeners)\n\n        # Get the listeners for this specification\n        for data in listeners:\n            # Default event to send : the one we received\n            sent_event = event\n\n            # Test if the service properties matches the filter\n            ldap_filter = data.ldap_filter\n            if ldap_filter is not None and not ldap_filter.matches(properties):\n                # Event doesn't match listener filter...\n                if (\n                    svc_modified\n                    and previous is not None\n                    and ldap_filter.matches(previous)\n                ):\n                    # ... but previous properties did match\n                    sent_event = endmatch_event\n                else:\n                    # Didn't match before either, ignore it\n                    continue\n\n            # Call'em\n            try:\n                data.listener.service_changed(sent_event)\n            except:\n                self._logger.exception(\"Error calling a service listener\")", "response": "Fires a new event in the calling thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfilters listeners with hooks", "response": "def _filter_with_hooks(self, svc_event, listeners):\n        \"\"\"\n        Filters listeners with EventListenerHooks\n\n        :param svc_event: ServiceEvent being triggered\n        :param listeners: Listeners to filter\n        :return: A list of listeners with hook references\n        \"\"\"\n        svc_ref = svc_event.get_service_reference()\n        # Get EventListenerHooks service refs from registry\n        hook_refs = self._registry.find_service_references(\n            SERVICE_EVENT_LISTENER_HOOK\n        )\n        # only do something if there are some hook_refs\n        if hook_refs:\n            # Associate bundle context to hooks\n            ctx_listeners = {}\n            for listener in listeners:\n                context = listener.bundle_context\n                ctx_listeners.setdefault(context, []).append(listener)\n\n            # Convert the dictionary to a shrinkable one,\n            # with shrinkable lists of listeners\n            shrinkable_ctx_listeners = ShrinkableMap(\n                {\n                    context: ShrinkableList(value)\n                    for context, value in ctx_listeners.items()\n                }\n            )\n\n            for hook_ref in hook_refs:\n                if not svc_ref == hook_ref:\n                    # Get the bundle of the hook service\n                    hook_bundle = hook_ref.get_bundle()\n                    # lookup service from registry\n                    hook_svc = self._registry.get_service(hook_bundle, hook_ref)\n                    if hook_svc is not None:\n                        # call event method of the hook service,\n                        # pass in svc_event and shrinkable_ctx_listeners\n                        # (which can be modified by hook)\n                        try:\n                            hook_svc.event(svc_event, shrinkable_ctx_listeners)\n                        except:\n                            self._logger.exception(\n                                \"Error calling EventListenerHook\"\n                            )\n                        finally:\n                            # Clean up the service\n                            self._registry.unget_service(hook_bundle, hook_ref)\n\n            # Convert the shrinkable_ctx_listeners back to a list of listeners\n            # before returning\n            ret_listeners = set()\n            for bnd_listeners in shrinkable_ctx_listeners.values():\n                ret_listeners.update(bnd_listeners)\n\n            return ret_listeners\n\n        # No hook ref\n        return listeners"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing the registry and services.", "response": "def clear(self):\n        \"\"\"\n        Clears the registry\n        \"\"\"\n        with self.__svc_lock:\n            self.__svc_registry.clear()\n            self.__svc_factories.clear()\n            self.__svc_specs.clear()\n            self.__bundle_svc.clear()\n            self.__bundle_imports.clear()\n            self.__factory_usage.clear()\n            self.__pending_services.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register(\n        self, bundle, classes, properties, svc_instance, factory, prototype\n    ):\n        \"\"\"\n        Registers a service.\n\n        :param bundle: The bundle that registers the service\n        :param classes: The classes implemented by the service\n        :param properties: The properties associated to the service\n        :param svc_instance: The instance of the service\n        :param factory: If True, the given service is a service factory\n        :param prototype: If True, the given service is a prototype service\n                          factory (the factory argument is considered True)\n        :return: The ServiceRegistration object\n        \"\"\"\n        with self.__svc_lock:\n            # Prepare properties\n            service_id = self.__next_service_id\n            self.__next_service_id += 1\n            properties[OBJECTCLASS] = classes\n            properties[SERVICE_ID] = service_id\n            properties[SERVICE_BUNDLEID] = bundle.get_bundle_id()\n\n            # Compute service scope\n            if prototype:\n                properties[SERVICE_SCOPE] = SCOPE_PROTOTYPE\n            elif factory:\n                properties[SERVICE_SCOPE] = SCOPE_BUNDLE\n            else:\n                properties[SERVICE_SCOPE] = SCOPE_SINGLETON\n\n            # Force to have a valid service ranking\n            try:\n                properties[SERVICE_RANKING] = int(properties[SERVICE_RANKING])\n            except (KeyError, ValueError, TypeError):\n                properties[SERVICE_RANKING] = 0\n\n            # Make the service reference\n            svc_ref = ServiceReference(bundle, properties)\n\n            # Make the service registration\n            svc_registration = ServiceRegistration(\n                self.__framework, svc_ref, properties, self.__sort_registry\n            )\n\n            # Store service information\n            if prototype or factory:\n                self.__svc_factories[svc_ref] = (svc_instance, svc_registration)\n\n            # Also store factories, as they must appear like any other service\n            self.__svc_registry[svc_ref] = svc_instance\n\n            for spec in classes:\n                spec_refs = self.__svc_specs.setdefault(spec, [])\n                bisect.insort_left(spec_refs, svc_ref)\n\n            # Reverse map, to ease bundle/service association\n            bundle_services = self.__bundle_svc.setdefault(bundle, set())\n            bundle_services.add(svc_ref)\n            return svc_registration", "response": "Registers a new service in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __sort_registry(self, svc_ref):\n        # type: (ServiceReference) -> None\n        \"\"\"\n        Sorts the registry, after the update of the sort key of given service\n        reference\n\n        :param svc_ref: A service reference with a modified sort key\n        \"\"\"\n        with self.__svc_lock:\n            if svc_ref not in self.__svc_registry:\n                raise BundleException(\"Unknown service: {0}\".format(svc_ref))\n\n            # Remove current references\n            for spec in svc_ref.get_property(OBJECTCLASS):\n                # Use bisect to remove the reference (faster)\n                spec_refs = self.__svc_specs[spec]\n                idx = bisect.bisect_left(spec_refs, svc_ref)\n                del spec_refs[idx]\n\n            # ... use the new sort key\n            svc_ref.update_sort_key()\n\n            for spec in svc_ref.get_property(OBJECTCLASS):\n                # ... and insert it again\n                spec_refs = self.__svc_specs[spec]\n                bisect.insort_left(spec_refs, svc_ref)", "response": "Sorts the registry after the update of the sort key of the given service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhiding the services of the given bundle.", "response": "def hide_bundle_services(self, bundle):\n        \"\"\"\n        Hides the services of the given bundle (removes them from lists, but\n        lets them be unregistered)\n\n        :param bundle: The bundle providing services\n        :return: The references of the hidden services\n        \"\"\"\n        with self.__svc_lock:\n            try:\n                svc_refs = self.__bundle_svc.pop(bundle)\n            except KeyError:\n                # Nothing to do\n                return set()\n            else:\n                # Clean the registry\n                specs = set()\n                for svc_ref in svc_refs:\n                    if svc_ref.is_factory():\n                        continue\n\n                    # Remove direct references\n                    self.__pending_services[svc_ref] = self.__svc_registry.pop(\n                        svc_ref\n                    )\n                    specs.update(svc_ref.get_property(OBJECTCLASS))\n\n                    # Clean the specifications cache\n                    for spec in svc_ref.get_property(OBJECTCLASS):\n                        spec_services = self.__svc_specs[spec]\n                        # Use bisect to remove the reference (faster)\n                        idx = bisect.bisect_left(spec_services, svc_ref)\n                        del spec_services[idx]\n                        if not spec_services:\n                            del self.__svc_specs[spec]\n\n            return svc_refs"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds all services references matching the given filter.", "response": "def find_service_references(\n        self, clazz=None, ldap_filter=None, only_one=False\n    ):\n        \"\"\"\n        Finds all services references matching the given filter.\n\n        :param clazz: Class implemented by the service\n        :param ldap_filter: Service filter\n        :param only_one: Return the first matching service reference only\n        :return: A list of found references, or None\n        :raise BundleException: An error occurred looking for service\n                                references\n        \"\"\"\n        with self.__svc_lock:\n            if clazz is None and ldap_filter is None:\n                # Return a sorted copy of the keys list\n                # Do not return None, as the whole content was required\n                return sorted(self.__svc_registry.keys())\n\n            if hasattr(clazz, \"__name__\"):\n                # Escape the type name\n                clazz = ldapfilter.escape_LDAP(clazz.__name__)\n            elif is_string(clazz):\n                # Escape the class name\n                clazz = ldapfilter.escape_LDAP(clazz)\n\n            if clazz is None:\n                # Directly use the given filter\n                refs_set = sorted(self.__svc_registry.keys())\n            else:\n                try:\n                    # Only for references with the given specification\n                    refs_set = iter(self.__svc_specs[clazz])\n                except KeyError:\n                    # No matching specification\n                    return None\n\n            # Parse the filter\n            try:\n                new_filter = ldapfilter.get_ldap_filter(ldap_filter)\n            except ValueError as ex:\n                raise BundleException(ex)\n\n            if new_filter is not None:\n                # Prepare a generator, as we might not need a complete\n                # walk-through\n                refs_set = (\n                    ref\n                    for ref in refs_set\n                    if new_filter.matches(ref.get_properties())\n                )\n\n            if only_one:\n                # Return the first element in the list/generator\n                try:\n                    return [next(refs_set)]\n                except StopIteration:\n                    # No match\n                    return None\n\n            # Get all the matching references\n            return list(refs_set) or None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn this bundle s ServiceReference list for all services it is using or returns None if this bundle is not using any services.", "response": "def get_bundle_imported_services(self, bundle):\n        \"\"\"\n        Returns this bundle's ServiceReference list for all services it is\n        using or returns None if this bundle is not using any services.\n        A bundle is considered to be using a service if its use count for that\n        service is greater than zero.\n\n        The list is valid at the time of the call to this method, however, as\n        the Framework is a very dynamic environment, services can be modified\n        or unregistered at any time.\n\n        :param bundle: The bundle to look into\n        :return: The references of the services used by this bundle\n        \"\"\"\n        with self.__svc_lock:\n            return sorted(self.__bundle_imports.get(bundle, []))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list of services registered by the given bundle. Returns None if the bundle didn t register any services.", "response": "def get_bundle_registered_services(self, bundle):\n        # type: (Any) -> List[ServiceReference]\n        \"\"\"\n        Retrieves the services registered by the given bundle. Returns None\n        if the bundle didn't register any service.\n\n        :param bundle: The bundle to look into\n        :return: The references to the services registered by the bundle\n        \"\"\"\n        with self.__svc_lock:\n            return sorted(self.__bundle_svc.get(bundle, []))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_service(self, bundle, reference):\n        # type: (Any, ServiceReference) -> Any\n        \"\"\"\n        Retrieves the service corresponding to the given reference\n\n        :param bundle: The bundle requiring the service\n        :param reference: A service reference\n        :return: The requested service\n        :raise BundleException: The service could not be found\n        \"\"\"\n        with self.__svc_lock:\n            if reference.is_factory():\n                return self.__get_service_from_factory(bundle, reference)\n\n            # Be sure to have the instance\n            try:\n                service = self.__svc_registry[reference]\n\n                # Indicate the dependency\n                imports = self.__bundle_imports.setdefault(bundle, {})\n                imports.setdefault(reference, _UsageCounter()).inc()\n                reference.used_by(bundle)\n                return service\n            except KeyError:\n                # Not found\n                raise BundleException(\n                    \"Service not found (reference: {0})\".format(reference)\n                )", "response": "Returns the service corresponding to the given service."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __get_service_from_factory(self, bundle, reference):\n        # type: (Any, ServiceReference) -> Any\n        \"\"\"\n        Returns a service instance from a service factory or a prototype\n        service factory\n\n        :param bundle: The bundle requiring the service\n        :param reference: A reference pointing to a factory\n        :return: The requested service\n        :raise BundleException: The service could not be found\n        \"\"\"\n        try:\n            factory, svc_reg = self.__svc_factories[reference]\n\n            # Indicate the dependency\n            imports = self.__bundle_imports.setdefault(bundle, {})\n            if reference not in imports:\n                # New reference usage: store a single usage\n                # The Factory counter will handle the rest\n                usage_counter = _UsageCounter()\n                usage_counter.inc()\n                imports[reference] = usage_counter\n                reference.used_by(bundle)\n\n            # Check the per-bundle usage counter\n            factory_counter = self.__factory_usage.setdefault(\n                bundle, _FactoryCounter(bundle)\n            )\n            return factory_counter.get_service(factory, svc_reg)\n        except KeyError:\n            # Not found\n            raise BundleException(\n                \"Service not found (reference: {0})\".format(reference)\n            )", "response": "Returns a service instance from a service factory or a prototype service factory"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unget_used_services(self, bundle):\n        # Pop used references\n        try:\n            imported_refs = list(self.__bundle_imports.pop(bundle))\n        except KeyError:\n            # Nothing to do\n            return\n\n        for svc_ref in imported_refs:\n            # Remove usage marker\n            svc_ref.unused_by(bundle)\n\n            if svc_ref.is_prototype():\n                # Get factory information and clean up the service from the\n                # factory counter\n                factory_counter = self.__factory_usage.pop(bundle)\n                factory, svc_reg = self.__svc_factories[svc_ref]\n                factory_counter.cleanup_service(factory, svc_reg)\n            elif svc_ref.is_factory():\n                # Factory service, release it the standard way\n                self.__unget_service_from_factory(bundle, svc_ref)\n\n        # Clean up local structures\n        try:\n            del self.__factory_usage[bundle]\n        except KeyError:\n            pass\n\n        try:\n            self.__bundle_imports.pop(bundle).clear()\n        except KeyError:\n            pass", "response": "Removes all service usages of the given bundle."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the usage of a service by a bundle.", "response": "def unget_service(self, bundle, reference, service=None):\n        # type: (Any, ServiceReference, Any) -> bool\n        \"\"\"\n        Removes the usage of a service by a bundle\n\n        :param bundle: The bundle that used the service\n        :param reference: A service reference\n        :param service: Service instance (for Prototype Service Factories)\n        :return: True if the bundle usage has been removed\n        \"\"\"\n        with self.__svc_lock:\n            if reference.is_prototype():\n                return self.__unget_service_from_factory(\n                    bundle, reference, service\n                )\n            elif reference.is_factory():\n                return self.__unget_service_from_factory(bundle, reference)\n\n            try:\n                # Remove the service reference from the bundle\n                imports = self.__bundle_imports[bundle]\n                if not imports[reference].dec():\n                    # No more reference to it\n                    del imports[reference]\n            except KeyError:\n                # Unknown reference\n                return False\n            else:\n                # Clean up\n                if not imports:\n                    del self.__bundle_imports[bundle]\n\n                # Update the service reference\n                reference.unused_by(bundle)\n                return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __unget_service_from_factory(self, bundle, reference, service=None):\n        # type: (Any, ServiceReference, Any) -> bool\n        \"\"\"\n        Removes the usage of a a service factory or a prototype\n        service factory by a bundle\n\n        :param bundle: The bundle that used the service\n        :param reference: A service reference\n        :param service: Service instance (for prototype factories)\n        :return: True if the bundle usage has been removed\n        \"\"\"\n        try:\n            factory, svc_reg = self.__svc_factories[reference]\n        except KeyError:\n            # Unknown service reference\n            return False\n\n        # Check the per-bundle usage counter\n        try:\n            counter = self.__factory_usage[bundle]\n        except KeyError:\n            # Unknown reference to a factory\n            return False\n        else:\n            if counter.unget_service(factory, svc_reg, service):\n                try:\n                    # No more dependency\n                    reference.unused_by(bundle)\n\n                    # All references have been taken away: clean up\n                    if not self.__factory_usage[bundle].is_used():\n                        del self.__factory_usage[bundle]\n\n                    # Remove the service reference from the bundle\n                    imports = self.__bundle_imports[bundle]\n                    del imports[reference]\n                except KeyError:\n                    # Unknown reference\n                    return False\n                else:\n                    # Clean up\n                    if not imports:\n                        del self.__bundle_imports[bundle]\n\n        return True", "response": "Removes the usage of a service from a service factory or prototype factory by a bundle."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert the given value according to the given type of the value.", "response": "def _convert_value(vtype, value):\n        \"\"\"\n        Converts the given value string according to the given type\n\n        :param vtype: Type of the value\n        :param value: String form of the value\n        :return: The converted value\n        :raise ValueError: Conversion failed\n        \"\"\"\n        # Normalize value\n        value = value.strip()\n\n        if vtype == TYPE_STRING:\n            # Nothing to do\n            return value\n        elif vtype in TYPES_INT:\n            return int(value)\n        elif vtype in TYPES_FLOAT:\n            return float(value)\n        elif vtype in TYPES_BOOLEAN:\n            # Compare lower-case value\n            return value.lower() not in (\"false\", \"0\")\n        elif vtype in TYPES_CHAR:\n            return value[0]\n\n        # No luck\n        raise ValueError(\"Unknown value type: {0}\".format(vtype))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds the given container to the given property node.", "response": "def _add_container(props_node, tag, container):\n        \"\"\"\n        Walks through the given container and fills the node\n\n        :param props_node: A property node\n        :param tag: Name of the container tag\n        :param container: The container\n        \"\"\"\n        values_node = ElementTree.SubElement(props_node, tag)\n        for value in container:\n            value_node = ElementTree.SubElement(values_node, TAG_VALUE)\n            value_node.text = str(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the type associated to the given name or value.", "response": "def _get_type(name, value):\n        \"\"\"\n        Returns the type associated to the given name or value\n\n        :param name: Property name\n        :param value: Property value\n        :return: A value type name\n        \"\"\"\n        # Types forced for known keys\n        if name in TYPED_BOOL:\n            return TYPE_BOOLEAN\n\n        elif name in TYPED_LONG:\n            return TYPE_LONG\n\n        elif name in TYPED_STRING:\n            return TYPE_STRING\n\n        # We need to analyze the content of value\n        if isinstance(value, (tuple, list, set)):\n            # Get the type from container content\n            try:\n                # Extract value\n                value = next(iter(value))\n\n            except StopIteration:\n                # Empty list, can't check\n                return TYPE_STRING\n\n        # Single value\n        if isinstance(value, int):\n            # Integer\n            return TYPE_LONG\n\n        elif isinstance(value, float):\n            # Float\n            return TYPE_DOUBLE\n\n        elif isinstance(value, type(ElementTree.Element(None))):\n            # XML\n            return XML_VALUE\n\n        # Default: String\n        return TYPE_STRING"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connect(\n        self, host, port=5222, reattempt=False, use_tls=True, use_ssl=False\n    ):\n        # pylint: disable=W0221\n        \"\"\"\n        Connects to the server.\n\n        By default, uses an un-encrypted connection, as it won't connect to an\n        OpenFire server otherwise\n\n        :param host: Server host name\n        :param port: Server port (default: 5222)\n        :param reattempt: If True, tries to connect to the server until it\n                         succeeds\n        :param use_tls: Use STARTTLS\n        :param use_ssl: Server connection is encrypted\n        :return: True if connection succeeded\n        \"\"\"\n        if not self._expected_server_name:\n            # We seem to connect the server anonymously, so SleekXMPP\n            # couldn't find the server host name from the JID\n            # => give it the given server host name as the expected one\n            self._expected_server_name = host\n\n        # Try to connect\n        if super(BasicBot, self).connect(\n            (host, port), reattempt, use_tls, use_ssl\n        ):\n            # On success, start the processing thread\n            self.process(threaded=True)\n            return True\n\n        return False", "response": "Connect to the server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_session_start(self, data):\n        # pylint: disable=W0613\n        \"\"\"\n        XMPP session started\n        \"\"\"\n        # Send initial presence\n        self.send_presence(ppriority=self._initial_priority)\n\n        # Request roster\n        self.get_roster()", "response": "Called when the XMPP session is started."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_invite(self, data):\n        if not self._nick:\n            self._nick = self.boundjid.user\n\n        # Join the room\n        self.plugin[\"xep_0045\"].joinMUC(data[\"from\"], self._nick)", "response": "Invite from the MUC."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iter_services(self, feature=None):\n        # Get the list of root services\n        items = self[\"xep_0030\"].get_items(\n            jid=self.boundjid.domain,\n            ifrom=self.boundjid.full,\n            block=True,\n            timeout=10,\n        )\n\n        for item in items[\"disco_items\"][\"items\"]:\n            # Each item is a 3-tuple. The service JID is the first entry\n            if not feature:\n                # No filter\n                yield item[0]\n            else:\n                # Get service details\n                info = self[\"xep_0030\"].get_info(\n                    jid=item[0],\n                    ifrom=self.boundjid.full,\n                    block=True,\n                    timeout=10,\n                )\n                if feature in info[\"disco_info\"][\"features\"]:\n                    # The service provides the required feature\n                    yield item[0]", "response": "Iterate over the root - level services on the server which provides the requested feature."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _find_assignment(arg_token):\n    idx = arg_token.find(\"=\")\n    while idx != -1:\n        if idx != 0 and arg_token[idx - 1] != \"\\\\\":\n            # No escape character\n            return idx\n\n        idx = arg_token.find(\"=\", idx + 1)\n\n    # No assignment found\n    return -1", "response": "Find the first non - escaped assignment in the given argument token."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts the given list of arguments into a list of kwargs and a", "response": "def _make_args(args_list, session, fw_props):\n    \"\"\"\n    Converts the given list of arguments into a list (args) and a\n    dictionary (kwargs).\n    All arguments with an assignment are put into kwargs, others in args.\n\n    :param args_list: The list of arguments to be treated\n    :param session: The current shell session\n    :return: The (arg_token, kwargs) tuple.\n    \"\"\"\n    args = []\n    kwargs = {}\n\n    for arg_token in args_list:\n        idx = _find_assignment(arg_token)\n        if idx != -1:\n            # Assignment\n            key = arg_token[:idx]\n            value = arg_token[idx + 1 :]\n            kwargs[key] = value\n        else:\n            # Direct argument\n            args.append(arg_token)\n\n    # Prepare the dictionary of variables\n    variables = collections.defaultdict(str)\n    variables.update(fw_props)\n    variables.update(session.variables)\n\n    # Replace variables\n    args = [_ArgTemplate(arg).safe_substitute(variables) for arg in args]\n    kwargs = {\n        key: _ArgTemplate(value).safe_substitute(variables)\n        for key, value in kwargs.items()\n    }\n    return args, kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _split_ns_command(cmd_token):\n    namespace = None\n    cmd_split = cmd_token.split(\".\", 1)\n    if len(cmd_split) == 1:\n        # No name space given\n        command = cmd_split[0]\n    else:\n        # Got a name space and a command\n        namespace = cmd_split[0]\n        command = cmd_split[1]\n\n    if not namespace:\n        # No name space given: given an empty one\n        namespace = \"\"\n\n    # Use lower case values only\n    return namespace.lower(), command.lower()", "response": "Splits the command name of the given command token into a namespace and command tuple."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_command(self, namespace, command, method):\n        if method is None:\n            self._logger.error(\"No method given for %s.%s\", namespace, command)\n            return False\n\n        # Store everything in lower case\n        namespace = (namespace or \"\").strip().lower()\n        command = (command or \"\").strip().lower()\n\n        if not namespace:\n            namespace = DEFAULT_NAMESPACE\n\n        if not command:\n            self._logger.error(\"No command name given\")\n            return False\n\n        if namespace not in self._commands:\n            space = self._commands[namespace] = {}\n        else:\n            space = self._commands[namespace]\n\n        if command in space:\n            self._logger.error(\n                \"Command already registered: %s.%s\", namespace, command\n            )\n            return False\n\n        space[command] = method\n        return True", "response": "Registers the given command to the shell."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_command_completers(self, namespace, command):\n        # type: (str, str) -> CompletionInfo\n        \"\"\"\n        Returns the completer method associated to the given command, or None\n\n        :param namespace: The command name space.\n        :param command: The shell name of the command\n        :return: A CompletionConfiguration object\n        :raise KeyError: Unknown command or name space\n        \"\"\"\n        # Find the method (can raise a KeyError)\n        method = self._commands[namespace][command]\n\n        # Return the completer, if any\n        return getattr(method, ATTR_COMPLETERS, None)", "response": "Returns the completer method associated to the given command."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unregister(self, namespace, command=None):\n        if not namespace:\n            namespace = DEFAULT_NAMESPACE\n\n        namespace = namespace.strip().lower()\n        if namespace not in self._commands:\n            self._logger.warning(\"Unknown name space: %s\", namespace)\n            return False\n\n        if command is not None:\n            # Remove the command\n            command = command.strip().lower()\n            if command not in self._commands[namespace]:\n                self._logger.warning(\n                    \"Unknown command: %s.%s\", namespace, command\n                )\n                return False\n\n            del self._commands[namespace][command]\n\n            # Remove the name space if necessary\n            if not self._commands[namespace]:\n                del self._commands[namespace]\n        else:\n            # Remove the whole name space\n            del self._commands[namespace]\n\n        return True", "response": "Unregisters the given command from the given name space."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __find_command_ns(self, command):\n        # Look for the spaces where the command name appears\n        namespaces = []\n        for namespace, commands in self._commands.items():\n            if command in commands:\n                namespaces.append(namespace)\n\n        # Sort name spaces\n        namespaces.sort()\n\n        # Default name space must always come first\n        try:\n            namespaces.remove(DEFAULT_NAMESPACE)\n            namespaces.insert(0, DEFAULT_NAMESPACE)\n        except ValueError:\n            # Default name space wasn't present\n            pass\n\n        return namespaces", "response": "Returns the name spaces where the given command name appears."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_namespaces(self):\n        namespaces = list(self._commands.keys())\n        namespaces.remove(DEFAULT_NAMESPACE)\n        namespaces.sort()\n        return namespaces", "response": "Returns the list of known name spaces without the default one"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve the commands of the given name space.", "response": "def get_commands(self, namespace):\n        \"\"\"\n        Retrieves the commands of the given name space. If *namespace* is None\n        or empty, it retrieves the commands of the default name space\n\n        :param namespace: The commands name space\n        :return: A list of commands names\n        \"\"\"\n        if not namespace:\n            # Default name space:\n            namespace = DEFAULT_NAMESPACE\n\n        try:\n            namespace.strip().lower()\n            commands = list(self._commands[namespace].keys())\n            commands.sort()\n            return commands\n        except KeyError:\n            # Unknown name space\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_ns_commands(self, cmd_name):\n        namespace, command = _split_ns_command(cmd_name)\n        if not namespace:\n            # Name space not given, look for the commands\n            spaces = self.__find_command_ns(command)\n            if not spaces:\n                # Unknown command\n                raise ValueError(\"Unknown command {0}\".format(command))\n            else:\n                # Return a sorted list of tuples\n                return sorted((namespace, command) for namespace in spaces)\n\n        # Single match\n        return [(namespace, command)]", "response": "Returns the possible name spaces and commands associated to the given command name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_ns_command(self, cmd_name):\n        namespace, command = _split_ns_command(cmd_name)\n        if not namespace:\n            # Name space not given, look for the command\n            spaces = self.__find_command_ns(command)\n            if not spaces:\n                # Unknown command\n                raise ValueError(\"Unknown command {0}\".format(command))\n            elif len(spaces) > 1:\n                # Multiple possibilities\n                if spaces[0] == DEFAULT_NAMESPACE:\n                    # Default name space has priority\n                    namespace = DEFAULT_NAMESPACE\n\n                else:\n                    # Ambiguous name\n                    raise ValueError(\n                        \"Multiple name spaces for command '{0}': {1}\".format(\n                            command, \", \".join(sorted(spaces))\n                        )\n                    )\n            else:\n                # Use the found name space\n                namespace = spaces[0]\n\n        # Command found\n        return namespace, command", "response": "Returns the name space and command associated to the given command name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef execute(self, cmdline, session=None):\n        if session is None:\n            # Default session\n            session = beans.ShellSession(\n                beans.IOHandler(sys.stdin, sys.stdout), {}\n            )\n\n        assert isinstance(session, beans.ShellSession)\n\n        # Split the command line\n        if not cmdline:\n            return False\n\n        # Convert the line into a string\n        cmdline = to_str(cmdline)\n\n        try:\n            line_split = shlex.split(cmdline, True, True)\n        except ValueError as ex:\n            session.write_line(\"Error reading line: {0}\", ex)\n            return False\n\n        if not line_split:\n            return False\n\n        try:\n            # Extract command information\n            namespace, command = self.get_ns_command(line_split[0])\n        except ValueError as ex:\n            # Unknown command\n            session.write_line(str(ex))\n            return False\n\n        # Get the content of the name space\n        space = self._commands.get(namespace, None)\n        if not space:\n            session.write_line(\"Unknown name space {0}\", namespace)\n            return False\n\n        # Get the method object\n        method = space.get(command, None)\n        if method is None:\n            session.write_line(\"Unknown command: {0}.{1}\", namespace, command)\n            return False\n\n        # Make arguments and keyword arguments\n        args, kwargs = _make_args(\n            line_split[1:], session, self._framework.get_properties()\n        )\n        try:\n            # Execute it\n            result = method(session, *args, **kwargs)\n\n            # Store the result as $?\n            if result is not None:\n                session.set(beans.RESULT_VAR_NAME, result)\n\n            # 0, None are considered as success, so don't use not nor bool\n            return result is not False\n        except TypeError as ex:\n            # Invalid arguments...\n            self._logger.error(\n                \"Error calling %s.%s: %s\", namespace, command, ex\n            )\n            session.write_line(\"Invalid method call: {0}\", ex)\n            self.__print_namespace_help(session, namespace, command)\n            return False\n        except Exception as ex:\n            # Error\n            self._logger.exception(\n                \"Error calling %s.%s: %s\", namespace, command, ex\n            )\n            session.write_line(\"{0}: {1}\", type(ex).__name__, str(ex))\n            return False\n        finally:\n            # Try to flush in any case\n            try:\n                session.flush()\n            except IOError:\n                pass", "response": "Executes the given command line and stores the result in the current shell session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __extract_help(method):\n        if method is None:\n            return \"(No associated method)\"\n\n        # Get the arguments\n        arg_spec = get_method_arguments(method)\n\n        # Ignore the session argument\n        start_arg = 1\n\n        # Compute the number of arguments with default value\n        if arg_spec.defaults is not None:\n            nb_optional = len(arg_spec.defaults)\n\n            # Let the mandatory arguments as they are\n            args = [\n                \"<{0}>\".format(arg)\n                for arg in arg_spec.args[start_arg:-nb_optional]\n            ]\n\n            # Add the other arguments\n            for name, value in zip(\n                arg_spec.args[-nb_optional:], arg_spec.defaults[-nb_optional:]\n            ):\n                if value is not None:\n                    args.append(\"[<{0}>={1}]\".format(name, value))\n                else:\n                    args.append(\"[<{0}>]\".format(name))\n        else:\n            # All arguments are mandatory\n            args = [\"<{0}>\".format(arg) for arg in arg_spec.args[start_arg:]]\n\n        # Extra arguments\n        if arg_spec.keywords:\n            args.append(\"[<property=value> ...]\")\n\n        if arg_spec.varargs:\n            args.append(\"[<{0} ...>]\".format(arg_spec.varargs))\n\n        # Get the documentation string\n        doc = inspect.getdoc(method) or \"(Documentation missing)\"\n        return \" \".join(args), \" \".join(doc.split())", "response": "Extracts the help string for the given method"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __print_command_help(self, session, namespace, cmd_name):\n        # Extract documentation\n        args, doc = self.__extract_help(self._commands[namespace][cmd_name])\n\n        # Print the command name, and its arguments\n        if args:\n            session.write_line(\"- {0} {1}\", cmd_name, args)\n        else:\n            session.write_line(\"- {0}\", cmd_name)\n\n        # Print the documentation line\n        session.write_line(\"\\t\\t{0}\", doc)", "response": "Prints the documentation of the given command"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __print_namespace_help(self, session, namespace, cmd_name=None):\n        session.write_line(\"=== Name space '{0}' ===\", namespace)\n\n        # Get all commands in this name space\n        if cmd_name is None:\n            names = [command for command in self._commands[namespace]]\n            names.sort()\n        else:\n            names = [cmd_name]\n\n        first_cmd = True\n        for command in names:\n            if not first_cmd:\n                # Print an empty line\n                session.write_line(\"\\n\")\n\n            self.__print_command_help(session, namespace, command)\n            first_cmd = False", "response": "Prints the documentation of all the commands in the given name space and all the commands in the given name space."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef print_help(self, session, command=None):\n        if command:\n            # Single command mode\n            if command in self._commands:\n                # Argument is a name space\n                self.__print_namespace_help(session, command)\n                was_namespace = True\n            else:\n                was_namespace = False\n\n            # Also print the name of matching commands\n            try:\n                # Extract command name space and name\n                possibilities = self.get_ns_commands(command)\n            except ValueError as ex:\n                # Unknown command\n                if not was_namespace:\n                    # ... and no name space were matching either -> error\n                    session.write_line(str(ex))\n                    return False\n            else:\n                # Print the help of the found command\n                if was_namespace:\n                    # Give some space\n                    session.write_line(\"\\n\\n\")\n\n                for namespace, cmd_name in possibilities:\n                    self.__print_namespace_help(session, namespace, cmd_name)\n        else:\n            # Get all name spaces\n            namespaces = list(self._commands.keys())\n            namespaces.remove(DEFAULT_NAMESPACE)\n            namespaces.sort()\n            namespaces.insert(0, DEFAULT_NAMESPACE)\n\n            first_ns = True\n            for namespace in namespaces:\n                if not first_ns:\n                    # Add empty lines\n                    session.write_line(\"\\n\\n\")\n\n                # Print the help of all commands\n                self.__print_namespace_help(session, namespace)\n                first_ns = False\n\n        return None", "response": "Prints the available methods and their documentation or the documentation of the given command."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the given variables or prints the current ones.", "response": "def var_set(session, **kwargs):\n        \"\"\"\n        Sets the given variables or prints the current ones. \"set answer=42\"\n        \"\"\"\n        if not kwargs:\n            for name, value in session.variables.items():\n                session.write_line(\"{0}={1}\".format(name, value))\n        else:\n            for name, value in kwargs.items():\n                name = name.strip()\n                session.set(name, value)\n                session.write_line(\"{0}={1}\", name, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef var_unset(session, name):\n        name = name.strip()\n        try:\n            session.unset(name)\n        except KeyError:\n            session.write_line(\"Unknown variable: {0}\", name)\n            return False\n        else:\n            session.write_line(\"Variable {0} unset.\", name)\n\n        return None", "response": "Unsets the given variable in the given session."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun the given script file", "response": "def run_file(self, session, filename):\n        \"\"\"\n        Runs the given \"script\" file\n        \"\"\"\n        try:\n            with open(filename, \"r\") as filep:\n                for lineno, line in enumerate(filep):\n                    line = line.strip()\n                    if not line or line.startswith(\"#\"):\n                        # Ignore comments and empty lines\n                        continue\n\n                    # Print out the executed line\n                    session.write_line(\"[{0:02d}] >> {1}\", lineno, line)\n\n                    # Execute the line\n                    if not self.execute(line, session):\n                        session.write_line(\n                            \"Command at line {0} failed. Abandon.\", lineno + 1\n                        )\n                        return False\n\n                session.write_line(\"Script execution succeeded\")\n        except IOError as ex:\n            session.write_line(\"Error reading file {0}: {1}\", filename, ex)\n            return False\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_properties(self, properties):\n        if isinstance(properties, dict):\n            self._properties.update(properties)", "response": "Updates the framework properties dictionary with the new properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_environment(self, environ):\n        if isinstance(environ, dict):\n            self._environment.update(environ)", "response": "Updates the environment dictionary with the given one."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd new paths to the Python path.", "response": "def add_paths(self, paths):\n        \"\"\"\n        Adds entries to the Python path.\n\n        The given paths are normalized before being added to the left of the\n        list\n\n        :param paths: New paths to add\n        \"\"\"\n        if paths:\n            # Use new paths in priority\n            self._paths = list(paths) + self._paths"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a list of components to instantiate", "response": "def add_components(self, components):\n        \"\"\"\n        Adds a list of components to instantiate\n\n        :param components: The description of components\n        :raise KeyError: Missing component configuration\n        \"\"\"\n        if components:\n            for component in components:\n                self._components[component[\"name\"]] = (\n                    component[\"factory\"],\n                    component.get(\"properties\", {}),\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nnormalize the environment variables paths and filters the lists of bundles to install and start.", "response": "def normalize(self):\n        \"\"\"\n        Normalizes environment variables, paths and filters the lists of\n        bundles to install and start.\n\n        After this call, the environment variables of this process will have\n        been updated.\n        \"\"\"\n        # Add environment variables\n        os.environ.update(self._environment)\n\n        # Normalize paths and avoid duplicates\n        self._paths = remove_duplicates(\n            os.path.realpath(os.path.expanduser(os.path.expandvars(path)))\n            for path in self._paths\n            if os.path.exists(path)\n        )\n\n        # Normalize the lists of bundles\n        self._bundles = remove_duplicates(self._bundles)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_default(self, filename):\n        for path in self.DEFAULT_PATH:\n            # Normalize path\n            path = os.path.expanduser(os.path.expandvars(path))\n            fullname = os.path.realpath(os.path.join(path, filename))\n\n            if os.path.exists(fullname) and os.path.isfile(fullname):\n                yield fullname", "response": "A generator which looks in common folders for the default configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load(self, filename=None):\n        if not filename:\n            for name in self.find_default(\".pelix.conf\"):\n                self.load(name)\n        else:\n            with open(filename, \"r\") as filep:\n                self.__parse(json.load(filep))", "response": "Loads the given file and adds its content to the current state."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __parse(self, configuration):\n        for entry in (\n            \"properties\",\n            \"environment\",\n            \"paths\",\n            \"bundles\",\n            \"components\",\n        ):\n            # Check if current values must be reset\n            reset_key = \"reset_{0}\".format(entry)\n\n            # Compute the name of the method\n            call_name = \"add\" if not configuration.get(reset_key) else \"set\"\n            method = getattr(self.__state, \"{0}_{1}\".format(call_name, entry))\n\n            # Update configuration\n            method(configuration.get(entry))", "response": "Parses the given configuration dictionary into a dictionary of values."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef normalize(self):\n        # Normalize configuration\n        self.__state.normalize()\n\n        # Update sys.path, avoiding duplicates\n        whole_path = list(self.__state.paths)\n        whole_path.extend(sys.path)\n\n        # Ensure the working directory as first search path\n        sys.path = [\".\"]\n        for path in whole_path:\n            if path not in sys.path:\n                sys.path.append(path)", "response": "Normalizes the environment variables and the Python path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unescape_string_literal(literal, encoding):\n    r'''Unescape a string or unicode literal.\n\n    Examples:\n\n    >>> u = u'\\u4e16\\u754c\\u4f60\\u597d' # \u4e16\u754c\u4f60\u597d\n    >>> print unescape_string_literal(repr(u), 'utf-8')\n    u'\u4e16\u754c\u4f60\u597d'\n\n    >>> print unescape_string_literal(repr(u.encode('utf-8')), 'utf-8')\n    '\u4e16\u754c\u4f60\u597d'\n\n    >>> print unescape_string_literal(repr(u.encode('big5')), 'utf-8')\n    '\\xa5@\\xac\\xc9\\xa7A\\xa6n'\n    '''\n\n    if encoding is None:\n        encoding = getfilesystemencoding()\n\n    if literal[0] in 'uU':\n\n        return literalize_string(\n            literal[2:-1].decode('unicode-escape').encode(encoding),\n            is_unicode=True\n        )\n\n    else:\n\n        content = literal[1:-1].decode('string-escape')\n\n        # keep it escaped if the encoding doesn't work on it\n        try:\n            content.decode(encoding)\n        except UnicodeDecodeError:\n            return literal\n\n    return literalize_string(content)", "response": "r Unescape a string or unicode literal."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unescape(b, encoding):\n    '''Unescape all string and unicode literals in bytes.'''\n    return string_literal_re.sub(\n        lambda m: unescape_string_literal(m.group(), encoding),\n        b\n    )", "response": "Unescape all string and unicode literals in bytes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_unistream(stream):\n    '''Make a stream which unescapes string literals before writes out.'''\n\n    unistream = lambda: 'I am an unistream!'\n\n    # make unistream look like the stream\n    for attr_name in dir(stream):\n        if not attr_name.startswith('_'):\n            setattr(unistream, attr_name, getattr(stream, attr_name))\n\n    # modify the write method to unescape the output\n    unistream.write = lambda b: stream.write(\n        # TODO: the to_bytes makes the behavior different, should we care?\n        unescape(to_bytes(b, unistream.encoding), unistream.encoding)\n    )\n\n    return unistream", "response": "Make a stream which unescapes string literals before writes out."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting the given stack frame to show its position in the code and its context.", "response": "def format_frame_info(frame):\n    \"\"\"\n    Formats the given stack frame to show its position in the code and\n    part of its context\n\n    :param frame: A stack frame\n    \"\"\"\n    # Same as in traceback.extract_stack\n    line_no = frame.f_lineno\n    code = frame.f_code\n    filename = code.co_filename\n    method_name = code.co_name\n    linecache.checkcache(filename)\n\n    try:\n        # Try to get the type of the calling object\n        instance = frame.f_locals[\"self\"]\n        method_name = \"{0}::{1}\".format(type(instance).__name__, method_name)\n    except KeyError:\n        # Not called from a bound method\n        pass\n\n    # File & line\n    output_lines = [\n        '  File \"{0}\", line {1}, in {2}'.format(filename, line_no, method_name)\n    ]\n\n    # Arguments\n    if frame.f_locals:\n        # Pypy keeps f_locals as an empty dictionary\n        arg_info = inspect.getargvalues(frame)\n        for name in arg_info.args:\n            try:\n                output_lines.append(\n                    \"    - {0:s} = {1}\".format(name, repr(frame.f_locals[name]))\n                )\n            except TypeError:\n                # Happens in dict/list-comprehensions in Python 2.x\n                name = name[0]\n                output_lines.append(\n                    \"    - {0:s} = {1}\".format(name, repr(frame.f_locals[name]))\n                )\n\n        if arg_info.varargs:\n            output_lines.append(\n                \"    - *{0:s} = {1}\".format(\n                    arg_info.varargs, frame.f_locals[arg_info.varargs]\n                )\n            )\n\n        if arg_info.keywords:\n            output_lines.append(\n                \"    - **{0:s} = {1}\".format(\n                    arg_info.keywords, frame.f_locals[arg_info.keywords]\n                )\n            )\n\n    # Line block\n    lines = _extract_lines(filename, frame.f_globals, line_no, 3)\n    if lines:\n        output_lines.append(\"\")\n        prefix = \"      \"\n        output_lines.append(\n            \"{0}{1}\".format(prefix, \"\\n{0}\".format(prefix).join(lines))\n        )\n    return \"\\n\".join(output_lines)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _extract_lines(filename, f_globals, line_no, around):\n    current_line = linecache.getline(filename, line_no, f_globals)\n    if not current_line:\n        # No data on this line\n        return \"\"\n\n    lines = []\n    # Add some lines before\n    for pre_line_no in range(line_no - around, line_no):\n        pre_line = linecache.getline(filename, pre_line_no, f_globals)\n        lines.append(\"{0}\".format(pre_line.rstrip()))\n\n    # The line itself\n    lines.append(\"{0}\".format(current_line.rstrip()))\n\n    # Add some lines after\n    for pre_line_no in range(line_no + 1, line_no + around + 1):\n        pre_line = linecache.getline(filename, pre_line_no, f_globals)\n        lines.append(\"{0}\".format(pre_line.rstrip()))\n\n    # Smart left strip\n    minimal_tab = None\n    for line in lines:\n        if line.strip():\n            tab = len(line) - len(line.lstrip())\n            if minimal_tab is None or tab < minimal_tab:\n                minimal_tab = tab\n\n    if minimal_tab > 0:\n        lines = [line[minimal_tab:] for line in lines]\n\n    # Add some place for a marker\n    marked_line = \">> {0}\".format(lines[around])\n    lines = [\"   {0}\".format(line) for line in lines]\n    lines[around] = marked_line\n    lines.append(\"\")\n    return lines", "response": "Extracts a block of lines from the given file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the list of methods for this command handler.", "response": "def get_methods(self):\n        \"\"\"\n        Retrieves the list of tuples (command, method) for this command handler\n        \"\"\"\n        return [\n            (\"levels\", self.print_levels),\n            (\"make\", self.make_report),\n            (\"clear\", self.clear_report),\n            (\"show\", self.show_report),\n            (\"write\", self.write_report),\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_level_methods(self, level):\n        try:\n            # Real name of the level\n            return set(self.__levels[level])\n        except KeyError:\n            # Alias\n            result = set()\n            for sub_level in self.__aliases[level]:\n                result.update(self.get_level_methods(sub_level))\n            return result", "response": "Returns the set of methods to call for the given level of report\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting the available levels to the given session.", "response": "def print_levels(self, session):\n        \"\"\"\n        Lists available levels\n        \"\"\"\n        lines = []\n        for level in sorted(self.get_levels()):\n            methods = sorted(\n                method.__name__ for method in self.get_level_methods(level)\n            )\n            lines.append(\"- {0}:\".format(level))\n            lines.append(\"\\t{0}\".format(\", \".join(methods)))\n        session.write_line(\"\\n\".join(lines))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dictionary containing details about the operating system and the operating system itself.", "response": "def os_details():\n        \"\"\"\n        Returns a dictionary containing details about the operating system\n        \"\"\"\n        # Compute architecture and linkage\n        bits, linkage = platform.architecture()\n        results = {\n            # Machine details\n            \"platform.arch.bits\": bits,\n            \"platform.arch.linkage\": linkage,\n            \"platform.machine\": platform.machine(),\n            \"platform.process\": platform.processor(),\n            \"sys.byteorder\": sys.byteorder,\n            # OS details\n            \"os.name\": os.name,\n            \"host.name\": socket.gethostname(),\n            \"sys.platform\": sys.platform,\n            \"platform.system\": platform.system(),\n            \"platform.release\": platform.release(),\n            \"platform.version\": platform.version(),\n            \"encoding.filesystem\": sys.getfilesystemencoding(),\n        }\n\n        # Paths and line separators\n        for name in \"sep\", \"altsep\", \"pathsep\", \"linesep\":\n            results[\"os.{0}\".format(name)] = getattr(os, name, None)\n\n        try:\n            # Available since Python 3.4\n            results[\"os.cpu_count\"] = os.cpu_count()\n        except AttributeError:\n            results[\"os.cpu_count\"] = None\n\n        try:\n            # Only for Unix\n            # pylint: disable=E1101\n            results[\"sys.dlopenflags\"] = sys.getdlopenflags()\n        except AttributeError:\n            results[\"sys.dlopenflags\"] = None\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn details about the current process", "response": "def process_details():\n        \"\"\"\n        Returns details about the current process\n        \"\"\"\n        results = {\"argv\": sys.argv, \"working.directory\": os.getcwd()}\n\n        # Process ID and execution IDs (UID, GID, Login, ...)\n        for key, method in {\n            \"pid\": \"getpid\",\n            \"ppid\": \"getppid\",\n            \"login\": \"getlogin\",\n            \"uid\": \"getuid\",\n            \"euid\": \"geteuid\",\n            \"gid\": \"getgid\",\n            \"egid\": \"getegid\",\n            \"groups\": \"getgroups\",\n        }.items():\n            try:\n                results[key] = getattr(os, method)()\n            except (AttributeError, OSError):\n                results[key] = None\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns details about the network links in the current language.", "response": "def network_details():\n        \"\"\"\n        Returns details about the network links\n        \"\"\"\n        # Get IPv4 details\n        ipv4_addresses = [\n            info[4][0]\n            for info in socket.getaddrinfo(\n                socket.gethostname(), None, socket.AF_INET\n            )\n        ]\n\n        # Add localhost\n        ipv4_addresses.extend(\n            info[4][0]\n            for info in socket.getaddrinfo(\"localhost\", None, socket.AF_INET)\n        )\n\n        # Filter addresses\n        ipv4_addresses = sorted(set(ipv4_addresses))\n\n        try:\n            # Get IPv6 details\n            ipv6_addresses = [\n                info[4][0]\n                for info in socket.getaddrinfo(\n                    socket.gethostname(), None, socket.AF_INET6\n                )\n            ]\n\n            # Add localhost\n            ipv6_addresses.extend(\n                info[4][0]\n                for info in socket.getaddrinfo(\n                    \"localhost\", None, socket.AF_INET6\n                )\n            )\n\n            # Filter addresses\n            ipv6_addresses = sorted(set(ipv6_addresses))\n        except (socket.gaierror, AttributeError):\n            # AttributeError: AF_INET6 is missing in some versions of Python\n            ipv6_addresses = None\n\n        return {\n            \"IPv4\": ipv4_addresses,\n            \"IPv6\": ipv6_addresses,\n            \"host.name\": socket.gethostname(),\n            \"host.fqdn\": socket.getfqdn(),\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef python_details():\n        build_no, build_date = platform.python_build()\n        results = {\n            # Version of interpreter\n            \"build.number\": build_no,\n            \"build.date\": build_date,\n            \"compiler\": platform.python_compiler(),\n            \"branch\": platform.python_branch(),\n            \"revision\": platform.python_revision(),\n            \"implementation\": platform.python_implementation(),\n            \"version\": \".\".join(str(v) for v in sys.version_info),\n            # API version\n            \"api.version\": sys.api_version,\n            # Installation details\n            \"prefix\": sys.prefix,\n            \"base_prefix\": getattr(sys, \"base_prefix\", None),\n            \"exec_prefix\": sys.exec_prefix,\n            \"base_exec_prefix\": getattr(sys, \"base_exec_prefix\", None),\n            # Execution details\n            \"executable\": sys.executable,\n            \"encoding.default\": sys.getdefaultencoding(),\n            # Other details, ...\n            \"recursion_limit\": sys.getrecursionlimit(),\n        }\n\n        # Threads implementation details\n        thread_info = getattr(sys, \"thread_info\", (None, None, None))\n        results[\"thread_info.name\"] = thread_info[0]\n        results[\"thread_info.lock\"] = thread_info[1]\n        results[\"thread_info.version\"] = thread_info[2]\n\n        # ABI flags (POSIX only)\n        results[\"abiflags\"] = getattr(sys, \"abiflags\", None)\n\n        # -X options (CPython only)\n        results[\"x_options\"] = getattr(sys, \"_xoptions\", None)\n        return results", "response": "Returns a dictionary containing details about the Python interpreter and the Python interpreter itself."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef python_modules():\n        imported = {}\n        results = {\"builtins\": sys.builtin_module_names, \"imported\": imported}\n        for module_name, module_ in sys.modules.items():\n            if module_name not in sys.builtin_module_names:\n                try:\n                    imported[module_name] = inspect.getfile(module_)\n                except TypeError:\n                    imported[\n                        module_name\n                    ] = \"<no file information :: {0}>\".format(repr(module_))\n\n        return results", "response": "Returns the list of Python modules and their file information."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pelix_bundles(self):\n        framework = self.__context.get_framework()\n        return {\n            bundle.get_bundle_id(): {\n                \"name\": bundle.get_symbolic_name(),\n                \"version\": bundle.get_version(),\n                \"state\": bundle.get_state(),\n                \"location\": bundle.get_location(),\n            }\n            for bundle in framework.get_bundles()\n        }", "response": "Return a list of installed bundles"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of the services that are in the system", "response": "def pelix_services(self):\n        \"\"\"\n        List of registered services\n        \"\"\"\n        return {\n            svc_ref.get_property(pelix.constants.SERVICE_ID): {\n                \"specifications\": svc_ref.get_property(\n                    pelix.constants.OBJECTCLASS\n                ),\n                \"ranking\": svc_ref.get_property(\n                    pelix.constants.SERVICE_RANKING\n                ),\n                \"properties\": svc_ref.get_properties(),\n                \"bundle.id\": svc_ref.get_bundle().get_bundle_id(),\n                \"bundle.name\": svc_ref.get_bundle().get_symbolic_name(),\n            }\n            for svc_ref in self.__context.get_all_service_references(None)\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ipopo_factories(self):\n        try:\n            with use_ipopo(self.__context) as ipopo:\n                return {\n                    name: ipopo.get_factory_details(name)\n                    for name in ipopo.get_factories()\n                }\n        except BundleException:\n            # iPOPO is not available:\n            return None", "response": "Return a dictionary of iPOPO factory details for all the iPOPO related objects."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ipopo_instances(self):\n        try:\n            with use_ipopo(self.__context) as ipopo:\n                return {\n                    instance[0]: ipopo.get_instance_details(instance[0])\n                    for instance in ipopo.get_instances()\n                }\n        except BundleException:\n            # iPOPO is not available:\n            return None", "response": "Returns a list of iPOPO instances"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting the active threads and their current code line line.", "response": "def threads_list():\n        \"\"\"\n        Lists the active threads and their current code line\n        \"\"\"\n        results = {}\n\n        # pylint: disable=W0212\n        try:\n            # Extract frames\n            frames = sys._current_frames()\n\n            # Get the thread ID -> Thread mapping\n            names = threading._active.copy()\n        except AttributeError:\n            # Extraction not available\n            return results\n\n        # Sort by thread ID\n        thread_ids = sorted(frames.keys())\n        for thread_id in thread_ids:\n            # Get the corresponding stack\n            stack = frames[thread_id]\n\n            # Try to get the thread name\n            try:\n                name = names[thread_id].name\n            except KeyError:\n                name = \"<unknown>\"\n\n            trace_lines = []\n            frame = stack\n            while frame is not None:\n                # Store the line information\n                trace_lines.append(format_frame_info(frame))\n\n                # Previous frame...\n                frame = frame.f_back\n\n            # Construct the thread description\n            results[thread_id] = {\n                \"name\": name,\n                \"stacktrace\": \"\\n\".join(reversed(trace_lines)),\n            }\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a report for the requested levels.", "response": "def make_report(self, session, *levels):\n        \"\"\"\n        Prepares the report at the requested level(s)\n        \"\"\"\n        if not levels:\n            levels = [\"full\"]\n\n        try:\n            # List the methods to call, avoiding double-calls\n            methods = set()\n            for level in levels:\n                methods.update(self.get_level_methods(level))\n        except KeyError as ex:\n            # Unknown level\n            session.write_line(\"Unknown report level: {0}\", ex)\n            self.__report = None\n        else:\n            # Call each method\n            self.__report = {method.__name__: method() for method in methods}\n            # Describe the report\n            self.__report[\"report\"] = {\n                \"report.levels\": levels,\n                \"time.stamp\": time.time(),\n                \"time.local\": str(datetime.datetime.now()),\n                \"time.utc\": str(datetime.datetime.utcnow()),\n            }\n\n        return self.__report"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_json(self, data):\n        # Don't forget the empty line at the end of the file\n        return (\n            json.dumps(\n                data,\n                sort_keys=True,\n                indent=4,\n                separators=(\",\", \": \"),\n                default=self.json_converter,\n            )\n            + \"\\n\"\n        )", "response": "Converts the given object to a pretty - formatted JSON string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_report(self, session, *levels):\n        if levels:\n            self.make_report(session, *levels)\n\n        if self.__report:\n            session.write_line(self.to_json(self.__report))\n        else:\n            session.write_line(\"No report to show\")", "response": "Shows the report that has been generated by this instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_report(self, session, filename):\n        if not self.__report:\n            session.write_line(\"No report to write down\")\n            return\n\n        try:\n            with open(filename, \"w+\") as out_file:\n                out_file.write(self.to_json(self.__report))\n        except IOError as ex:\n            session.write_line(\"Error writing to file: {0}\", ex)", "response": "Writes the report in JSON format to the given file"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles the result of a call.", "response": "def handle_result(self, result, error):\n        \"\"\"\n        The result has been received\n\n        :param result: Call result\n        :param error: Error message\n        \"\"\"\n        if not self._error and not self._result:\n            # Store results, if not already set\n            self._error = error\n            self._result = result\n\n        # Unlock the call\n        self._event.set()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstarting a Pelix framework and waits for it to stop", "response": "def main():\n    \"\"\"\n    Starts a Pelix framework and waits for it to stop\n    \"\"\"\n    # Prepare the framework, with iPOPO and the shell console\n    # Warning: we only use the first argument of this method, a list of bundles\n    framework = pelix.framework.create_framework((\n        # iPOPO\n        \"pelix.ipopo.core\",\n        # Shell core (engine)\n        \"pelix.shell.core\",\n        # Text console\n        \"pelix.shell.console\"))\n\n    # Start the framework, and the pre-installed bundles\n    framework.start()\n\n    # Get the bundle context of the framework, i.e. the link between the\n    # framework starter and its content.\n    context = framework.get_bundle_context()\n\n    # Start the spell dictionary bundles, which provide the dictionary services\n    context.install_bundle(\"spell_dictionary_EN\").start()\n    context.install_bundle(\"spell_dictionary_FR\").start()\n\n    # Start the spell checker bundle, which provides the spell checker service.\n    context.install_bundle(\"spell_checker\").start()\n\n    # Sample usage of the spell checker service\n    # 1. get its service reference, that describes the service itself\n    ref_config = context.get_service_reference(\"spell_checker_service\")\n\n    # 2. the use_service method allows to grab a service and to use it inside a\n    # with block. It automatically releases the service when exiting the block,\n    # even if an exception was raised\n    with use_service(context, ref_config) as svc_config:\n        # Here, svc_config points to the spell checker service\n        passage = \"Welcome to our framwork iPOPO\"\n        print(\"1. Testing Spell Checker:\", passage)\n        misspelled_words = svc_config.check(passage)\n        print(\">  Misspelled_words are:\", misspelled_words)\n\n    # Start the spell client bundle, which provides a shell command\n    context.install_bundle(\"spell_client\").start()\n\n    # Wait for the framework to stop\n    framework.wait_for_stop()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wrap_socket(socket, certfile, keyfile, password=None):\n    # Log warnings when some\n    logger = logging.getLogger(\"ssl_wrap\")\n\n    def _password_support_error():\n        \"\"\"\n        Logs a warning and raises an OSError if a password has been given but\n        Python doesn't support ciphered key files.\n\n        :raise OSError: If a password has been given\n        \"\"\"\n        if password:\n            logger.error(\n                \"The ssl.wrap_socket() fallback method doesn't \"\n                \"support key files with a password.\"\n            )\n            raise OSError(\n                \"Can't decode the SSL key file: \"\n                \"this version of Python doesn't support it\"\n            )\n\n    try:\n        # Prefer the default context factory, as it will be updated to reflect\n        # security issues (Python >= 2.7.9 and >= 3.4)\n        default_context = ssl.create_default_context()\n    except AttributeError:\n        default_context = None\n\n    try:\n        # Try to equivalent to create_default_context() in Python 3.5\n        # Create an SSL context and set its options\n        context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n\n        if default_context is not None:\n            # Copy options\n            context.options = default_context.options\n        else:\n            # Set up the context as create_default_context() does in Python 3.5\n            # SSLv2 considered harmful\n            # SSLv3 has problematic security\n            context.options |= ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3\n\n        # disallow ciphers with known vulnerabilities\n        context.set_ciphers(_RESTRICTED_SERVER_CIPHERS)\n\n        try:\n            # Load the certificate, with a password\n            context.load_cert_chain(certfile, keyfile, password)\n        except TypeError:\n            # The \"password\" argument isn't supported\n            # Check support for key file password\n            _password_support_error()\n\n            # Load the certificate, without the password argument\n            context.load_cert_chain(certfile, keyfile)\n\n        # Return the wrapped socket\n        return context.wrap_socket(socket, server_side=True)\n\n    except AttributeError as ex:\n        # Log a warning to advise the user of possible security holes\n        logger.warning(\n            \"Can't create a custom SSLContext. \"\n            \"The server should be considered insecure.\"\n        )\n        logger.debug(\"Missing attribute: %s\", ex)\n\n    # Check support for key file password\n    _password_support_error()\n\n    # Fall back to the \"old\" wrap_socket method\n    return ssl.wrap_socket(\n        socket, server_side=True, certfile=certfile, keyfile=keyfile\n    )", "response": "Wrap an existing TCP socket and return an SSLSocket object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes a HTML list from the given iterable of items.", "response": "def make_html_list(items, tag=\"ul\"):\n    # type: (Iterable[Any], str) -> str\n    \"\"\"\n    Makes a HTML list from the given iterable\n\n    :param items: The items to list\n    :param tag: The tag to use (ul or ol)\n    :return: The HTML list code\n    \"\"\"\n    html_list = \"\\n\".join(\n        '<li><a href=\"{0}\">{0}</a></li>'.format(item) for item in items\n    )\n    return \"<{0}>\\n{1}\\n</{0}>\".format(tag, html_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_data(self):\n        # type: () -> ByteString\n        \"\"\"\n        Reads all the data in the input stream\n\n        :return: The read data\n        \"\"\"\n        try:\n            size = int(self.get_header(\"content-length\"))\n        except (ValueError, TypeError):\n            size = -1\n\n        return self.get_rfile().read(size)", "response": "Reads all the data in the input stream\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_content(\n        self,\n        http_code,\n        content,\n        mime_type=\"text/html\",\n        http_message=None,\n        content_length=-1,\n    ):\n        # type: (int, str, str, str, int) -> None\n        \"\"\"\n        Utility method to send the given content as an answer.\n        You can still use get_wfile or write afterwards, if you forced the\n        content length.\n\n        If content_length is negative (default), it will be computed as the\n        length of the content;\n        if it is positive, the given value will be used;\n        if it is None, the content-length header won't be sent.\n\n        :param http_code: HTTP result code\n        :param content: Data to be sent (must be a string)\n        :param mime_type: Content MIME type (content-type)\n        :param http_message: HTTP code description\n        :param content_length: Forced content length\n        \"\"\"\n        self.set_response(http_code, http_message)\n        if mime_type and not self.is_header_set(\"content-type\"):\n            self.set_header(\"content-type\", mime_type)\n\n        # Convert the content\n        raw_content = to_bytes(content)\n\n        if content_length is not None and not self.is_header_set(\n            \"content-length\"\n        ):\n            if content_length < 0:\n                # Compute the length\n                content_length = len(raw_content)\n\n            # Send the length\n            self.set_header(\"content-length\", content_length)\n\n        self.end_headers()\n\n        # Send the content\n        self.write(raw_content)", "response": "Utility method to send the given content to the related object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_mreq(family, address):\n    if not address:\n        raise ValueError(\"Empty address\")\n\n    # Convert the address to a binary form\n    group_bin = pton(family, address)\n\n    if family == socket.AF_INET:\n        # IPv4\n        # struct ip_mreq\n        # {\n        #     struct in_addr imr_multiaddr; /* IP multicast address of group */\n        #     struct in_addr imr_interface; /* local IP address of interface */\n        # };\n        # \"=I\" : Native order, standard size unsigned int\n        return group_bin + struct.pack(\"=I\", socket.INADDR_ANY)\n\n    elif family == socket.AF_INET6:\n        # IPv6\n        # struct ipv6_mreq {\n        #    struct in6_addr ipv6mr_multiaddr;\n        #    unsigned int    ipv6mr_interface;\n        # };\n        # \"@I\" : Native order, native size unsigned int\n        return group_bin + struct.pack(\"@I\", 0)\n\n    raise ValueError(\"Unknown family {0}\".format(family))", "response": "Makes a mreq structure object for the given address and socket family."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a multicast socket according to the given address and port.", "response": "def create_multicast_socket(address, port):\n    \"\"\"\n    Creates a multicast socket according to the given address and port.\n    Handles both IPv4 and IPv6 addresses.\n\n    :param address: Multicast address/group\n    :param port: Socket port\n    :return: A tuple (socket, listening address)\n    :raise ValueError: Invalid address or port\n    \"\"\"\n    # Get the information about a datagram (UDP) socket, of any family\n    try:\n        addrs_info = socket.getaddrinfo(\n            address, port, socket.AF_UNSPEC, socket.SOCK_DGRAM\n        )\n    except socket.gaierror:\n        raise ValueError(\n            \"Error retrieving address informations ({0}, {1})\".format(\n                address, port\n            )\n        )\n\n    if len(addrs_info) > 1:\n        _logger.debug(\n            \"More than one address information found. Using the first one.\"\n        )\n\n    # Get the first entry : (family, socktype, proto, canonname, sockaddr)\n    addr_info = addrs_info[0]\n\n    # Only accept IPv4/v6 addresses\n    if addr_info[0] not in (socket.AF_INET, socket.AF_INET6):\n        # Unhandled address family\n        raise ValueError(\"Unhandled socket family : %d\" % (addr_info[0]))\n\n    # Prepare the socket\n    sock = socket.socket(addr_info[0], socket.SOCK_DGRAM, socket.IPPROTO_UDP)\n\n    # Reuse address\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    if hasattr(socket, \"SO_REUSEPORT\"):\n        # Special for MacOS\n        # pylint: disable=E1101\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n\n    # Bind the socket\n    if sock.family == socket.AF_INET:\n        # IPv4 binding\n        sock.bind((\"0.0.0.0\", port))\n\n    else:\n        # IPv6 Binding\n        sock.bind((\"::\", port))\n\n    # Prepare the mreq structure to join the group\n    # addrinfo[4] = (addr,port)\n    mreq = make_mreq(sock.family, addr_info[4][0])\n\n    # Join the group\n    if sock.family == socket.AF_INET:\n        # IPv4\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)\n\n        # Allow multicast packets to get back on this host\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_LOOP, 1)\n\n    elif sock.family == socket.AF_INET6:\n        # IPv6\n        sock.setsockopt(ipproto_ipv6(), socket.IPV6_JOIN_GROUP, mreq)\n\n        # Allow multicast packets to get back on this host\n        sock.setsockopt(ipproto_ipv6(), socket.IPV6_MULTICAST_LOOP, 1)\n\n    return sock, addr_info[4][0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose the given multicast socket.", "response": "def close_multicast_socket(sock, address):\n    \"\"\"\n    Cleans up the given multicast socket.\n    Unregisters it of the multicast group.\n\n    Parameters should be the result of create_multicast_socket\n\n    :param sock: A multicast socket\n    :param address: The multicast address used by the socket\n    \"\"\"\n    if sock is None:\n        return\n\n    if address:\n        # Prepare the mreq structure to join the group\n        mreq = make_mreq(sock.family, address)\n\n        # Quit group\n        if sock.family == socket.AF_INET:\n            # IPv4\n            sock.setsockopt(socket.IPPROTO_IP, socket.IP_DROP_MEMBERSHIP, mreq)\n\n        elif sock.family == socket.AF_INET6:\n            # IPv6\n            sock.setsockopt(ipproto_ipv6(), socket.IPV6_LEAVE_GROUP, mreq)\n\n    # Close the socket\n    sock.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the factory context for the given class based on the given bundle context.", "response": "def _set_factory_context(factory_class, bundle_context):\n    # type: (type, Optional[BundleContext]) -> Optional[FactoryContext]\n    \"\"\"\n    Transforms the context data dictionary into its FactoryContext object form.\n\n    :param factory_class: A manipulated class\n    :param bundle_context: The class bundle context\n    :return: The factory context, None on error\n    \"\"\"\n    try:\n        # Try to get the factory context (built using decorators)\n        context = getattr(factory_class, constants.IPOPO_FACTORY_CONTEXT)\n    except AttributeError:\n        # The class has not been manipulated, or too badly\n        return None\n\n    if not context.completed:\n        # Partial context (class not manipulated)\n        return None\n\n    # Associate the factory to the bundle context\n    context.set_bundle_context(bundle_context)\n    return context"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_bundle_factories(bundle):\n    # type: (Bundle) -> List[Tuple[FactoryContext, type]]\n    \"\"\"\n    Retrieves a list of pairs (FactoryContext, factory class) with all\n    readable manipulated classes found in the bundle.\n\n    :param bundle: A Bundle object\n    :return: The list of factories loaded from the bundle\n    \"\"\"\n    result = []\n\n    # Get the Python module\n    module_ = bundle.get_module()\n\n    # Get the bundle context\n    bundle_context = bundle.get_bundle_context()\n\n    for name in dir(module_):\n        try:\n            # Get the module member\n            factory_class = getattr(module_, name)\n            if not inspect.isclass(factory_class):\n                continue\n\n            # Check if it is a class\n            if sys.modules[factory_class.__module__] is not module_:\n                # Only keep classes from this module\n                continue\n        except (AttributeError, KeyError):\n            # getattr() didn't work or __module__ is not a member of the class,\n            # or the module is not known by the interpreter\n            continue\n\n        context = _set_factory_context(factory_class, bundle_context)\n        if context is None:\n            # Error setting up the factory context\n            continue\n\n        result.append((context, factory_class))\n\n    return result", "response": "Loads the factories from the specified bundle."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __find_handler_factories(self):\n        # Get the references\n        svc_refs = self.__context.get_all_service_references(\n            handlers_const.SERVICE_IPOPO_HANDLER_FACTORY\n        )\n        if svc_refs:\n            for svc_ref in svc_refs:\n                # Store each handler factory\n                self.__add_handler_factory(svc_ref)", "response": "Finds all registered handler factories and stores them as objects"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new handler factory for the given service reference.", "response": "def __add_handler_factory(self, svc_ref):\n        # type: (ServiceReference) -> None\n        \"\"\"\n        Stores a new handler factory\n\n        :param svc_ref: ServiceReference of the new handler factory\n        \"\"\"\n        with self.__handlers_lock:\n            # Get the handler ID\n            handler_id = svc_ref.get_property(handlers_const.PROP_HANDLER_ID)\n            if handler_id in self._handlers:\n                # Duplicated ID\n                _logger.warning(\"Already registered handler ID: %s\", handler_id)\n            else:\n                # Store the service\n                self._handlers_refs.add(svc_ref)\n                self._handlers[handler_id] = self.__context.get_service(svc_ref)\n\n                # Try to instantiate waiting components\n                succeeded = set()\n                for (\n                    name,\n                    (context, instance),\n                ) in self.__waiting_handlers.items():\n                    if self.__try_instantiate(context, instance):\n                        succeeded.add(name)\n\n                # Remove instantiated component from the waiting list\n                for name in succeeded:\n                    del self.__waiting_handlers[name]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving an handler factory from the list of handlers and instances.", "response": "def __remove_handler_factory(self, svc_ref):\n        # type: (ServiceReference) -> None\n        \"\"\"\n        Removes an handler factory\n\n        :param svc_ref: ServiceReference of the handler factory to remove\n        \"\"\"\n        with self.__handlers_lock:\n            # Get the handler ID\n            handler_id = svc_ref.get_property(handlers_const.PROP_HANDLER_ID)\n\n            # Check if this is the handler we use\n            if svc_ref not in self._handlers_refs:\n                return\n\n            # Clean up\n            self.__context.unget_service(svc_ref)\n            self._handlers_refs.remove(svc_ref)\n            del self._handlers[handler_id]\n\n            # List the components using this handler\n            to_stop = set()  # type: Set[StoredInstance]\n            for factory_name in self.__factories:\n                _, factory_context = self.__get_factory_with_context(\n                    factory_name\n                )\n                if handler_id in factory_context.get_handlers_ids():\n                    to_stop.update(self.__get_stored_instances(factory_name))\n\n            with self.__instances_lock:\n                for stored_instance in to_stop:\n                    # Extract information\n                    context = stored_instance.context\n                    name = context.name\n                    instance = stored_instance.instance\n\n                    # Clean up the stored instance (iPOPO side)\n                    del self.__instances[name]\n                    stored_instance.kill()\n\n                    # Add the component to the waiting queue\n                    self.__waiting_handlers[name] = (context, instance)\n\n            # Try to find a new handler factory\n            new_ref = self.__context.get_service_reference(\n                handlers_const.SERVICE_IPOPO_HANDLER_FACTORY,\n                \"({0}={1})\".format(handlers_const.PROP_HANDLER_ID, handler_id),\n            )\n            if new_ref is not None:\n                self.__add_handler_factory(new_ref)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __get_factory_with_context(self, factory_name):\n        # type: (str) -> Tuple[type, FactoryContext]\n        \"\"\"\n        Retrieves the factory registered with the given and its factory context\n\n        :param factory_name: The name of the factory\n        :return: A (factory, context) tuple\n        :raise TypeError: Unknown factory, or factory not manipulated\n        \"\"\"\n        factory = self.__factories.get(factory_name)\n        if factory is None:\n            raise TypeError(\"Unknown factory '{0}'\".format(factory_name))\n\n        # Get the factory context\n        factory_context = getattr(\n            factory, constants.IPOPO_FACTORY_CONTEXT, None\n        )\n        if factory_context is None:\n            raise TypeError(\n                \"Factory context missing in '{0}'\".format(factory_name)\n            )\n\n        return factory, factory_context", "response": "Returns the factory and its context for the given factory name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list of all stored instances corresponding to the given factory name.", "response": "def __get_stored_instances(self, factory_name):\n        # type: (str) -> List[StoredInstance]\n        \"\"\"\n        Retrieves the list of all stored instances objects corresponding to\n        the given factory name\n\n        :param factory_name: A factory name\n        :return: All components instantiated from the given factory\n        \"\"\"\n        with self.__instances_lock:\n            return [\n                stored_instance\n                for stored_instance in self.__instances.values()\n                if stored_instance.factory_name == factory_name\n            ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntries to instantiate a component.", "response": "def __try_instantiate(self, component_context, instance):\n        # type: (ComponentContext, object) -> bool\n        \"\"\"\n        Instantiates a component, if all of its handlers are there. Returns\n        False if a handler is missing.\n\n        :param component_context: A ComponentContext bean\n        :param instance: The component instance\n        :return: True if the component has started,\n                 False if a handler is missing\n        \"\"\"\n        with self.__instances_lock:\n            # Extract information about the component\n            factory_context = component_context.factory_context\n            handlers_ids = factory_context.get_handlers_ids()\n            name = component_context.name\n            factory_name = factory_context.name\n\n            try:\n                # Get handlers\n                handler_factories = self.__get_handler_factories(handlers_ids)\n            except KeyError:\n                # A handler is missing, stop here\n                return False\n\n            # Instantiate the handlers\n            all_handlers = set()  # type: Set[Any]\n            for handler_factory in handler_factories:\n                handlers = handler_factory.get_handlers(\n                    component_context, instance\n                )\n                if handlers:\n                    all_handlers.update(handlers)\n\n            # Prepare the stored instance\n            stored_instance = StoredInstance(\n                self, component_context, instance, all_handlers\n            )\n\n            # Manipulate the properties\n            for handler in all_handlers:\n                handler.manipulate(stored_instance, instance)\n\n            # Store the instance\n            self.__instances[name] = stored_instance\n\n        # Start the manager\n        stored_instance.start()\n\n        # Notify listeners now that every thing is ready to run\n        self._fire_ipopo_event(\n            constants.IPopoEvent.INSTANTIATED, factory_name, name\n        )\n\n        # Try to validate it\n        stored_instance.update_bindings()\n        stored_instance.check_lifecycle()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstoring the components of the given bundle with the auto - restart property.", "response": "def _autorestart_store_components(self, bundle):\n        # type: (Bundle) -> None\n        \"\"\"\n        Stores the components of the given bundle with the auto-restart\n        property\n\n        :param bundle: A Bundle object\n        \"\"\"\n        with self.__instances_lock:\n            # Prepare the list of components\n            store = self.__auto_restart.setdefault(bundle, [])\n            for stored_instance in self.__instances.values():\n                # Get the factory name\n                factory = stored_instance.factory_name\n                if self.get_factory_bundle(factory) is bundle:\n                    # Factory from this bundle\n                    # Test component properties\n                    properties = stored_instance.context.properties\n                    if properties.get(constants.IPOPO_AUTO_RESTART):\n                        # Auto-restart property found\n                        store.append(\n                            (factory, stored_instance.name, properties)\n                        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrestarting the components of the given bundle", "response": "def _autorestart_components(self, bundle):\n        # type: (Bundle) -> None\n        \"\"\"\n        Restart the components of the given bundle\n\n        :param bundle: A Bundle object\n        \"\"\"\n        with self.__instances_lock:\n            instances = self.__auto_restart.get(bundle)\n            if not instances:\n                # Nothing to do\n                return\n\n            for factory, name, properties in instances:\n                try:\n                    # Instantiate the given component\n                    self.instantiate(factory, name, properties)\n                except Exception as ex:\n                    # Log error, but continue to work\n                    _logger.exception(\n                        \"Error restarting component '%s' ('%s') \"\n                        \"from bundle %s (%d): %s\",\n                        name,\n                        factory,\n                        bundle.get_symbolic_name(),\n                        bundle.get_bundle_id(),\n                        ex,\n                    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfires an iPOPO event for the specified iPOPO class", "response": "def _fire_ipopo_event(self, kind, factory_name, instance_name=None):\n        # type: (int, str, Optional[str]) -> None\n        \"\"\"\n        Triggers an iPOPO event\n\n        :param kind: Kind of event\n        :param factory_name: Name of the factory associated to the event\n        :param instance_name: Name of the component instance associated to the\n                              event\n        \"\"\"\n        with self.__listeners_lock:\n            # Use a copy of the list of listeners\n            listeners = self.__listeners[:]\n\n        for listener in listeners:\n            try:\n                listener.handle_ipopo_event(\n                    constants.IPopoEvent(kind, factory_name, instance_name)\n                )\n            except:\n                _logger.exception(\"Error calling an iPOPO event handler\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _prepare_instance_properties(self, properties, factory_properties):\n        # type: (dict, dict) -> dict\n        \"\"\"\n        Prepares the properties of a component instance, based on its\n        configuration, factory and framework properties\n\n        :param properties: Component instance properties\n        :param factory_properties: Component factory \"default\" properties\n        :return: The merged properties\n        \"\"\"\n        # Normalize given properties\n        if properties is None or not isinstance(properties, dict):\n            properties = {}\n\n        # Use framework properties to fill missing ones\n        framework = self.__context.get_framework()\n        for property_name in factory_properties:\n            if property_name not in properties:\n                # Missing property\n                value = framework.get_property(property_name)\n                if value is not None:\n                    # Set the property value\n                    properties[property_name] = value\n\n        return properties", "response": "Prepare the properties of a component instance based on its configuration factory and framework properties."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering all the factories found in the given bundle.", "response": "def _register_bundle_factories(self, bundle):\n        # type: (Bundle) -> None\n        \"\"\"\n        Registers all factories found in the given bundle\n\n        :param bundle: A bundle\n        \"\"\"\n        # Load the bundle factories\n        factories = _load_bundle_factories(bundle)\n\n        for context, factory_class in factories:\n            try:\n                # Register each found factory\n                self._register_factory(context.name, factory_class, False)\n            except ValueError as ex:\n                # Already known factory\n                _logger.error(\n                    \"Cannot register factory '%s' of bundle %d (%s): %s\",\n                    context.name,\n                    bundle.get_bundle_id(),\n                    bundle.get_symbolic_name(),\n                    ex,\n                )\n                _logger.error(\n                    \"class: %s -- module: %s\",\n                    factory_class,\n                    factory_class.__module__,\n                )\n            else:\n                # Instantiate components\n                for name, properties in context.get_instances().items():\n                    self.instantiate(context.name, name, properties)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters a component factory with the given name.", "response": "def _register_factory(self, factory_name, factory, override):\n        # type: (str, type, bool) -> None\n        \"\"\"\n        Registers a component factory\n\n        :param factory_name: The name of the factory\n        :param factory: The factory class object\n        :param override: If true, previous factory is overridden, else an\n                         exception is risen if a previous factory with that\n                         name already exists\n        :raise ValueError: The factory name already exists or is invalid\n        :raise TypeError: Invalid factory type\n        \"\"\"\n        if not factory_name or not is_string(factory_name):\n            raise ValueError(\"A factory name must be a non-empty string\")\n\n        if not inspect.isclass(factory):\n            raise TypeError(\n                \"Invalid factory class '{0}'\".format(type(factory).__name__)\n            )\n\n        with self.__factories_lock:\n            if factory_name in self.__factories:\n                if override:\n                    _logger.info(\"Overriding factory '%s'\", factory_name)\n                else:\n                    raise ValueError(\n                        \"'{0}' factory already exist\".format(factory_name)\n                    )\n\n            self.__factories[factory_name] = factory\n\n            # Trigger an event\n            self._fire_ipopo_event(\n                constants.IPopoEvent.REGISTERED, factory_name\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _unregister_bundle_factories(self, bundle):\n        # type: (Bundle) -> None\n        \"\"\"\n        Unregisters all factories of the given bundle\n\n        :param bundle: A bundle\n        \"\"\"\n        with self.__factories_lock:\n            # Find out which factories must be removed\n            to_remove = [\n                factory_name\n                for factory_name in self.__factories\n                if self.get_factory_bundle(factory_name) is bundle\n            ]\n\n            # Remove all of them\n            for factory_name in to_remove:\n                try:\n                    self.unregister_factory(factory_name)\n                except ValueError as ex:\n                    _logger.warning(\n                        \"Error unregistering factory '%s': %s\", factory_name, ex\n                    )", "response": "Unregisters all factories of the given bundle"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _stop(self):\n        # Running flag down\n        self.running = False\n\n        # Unregister the service listener\n        self.__context.remove_service_listener(self)\n\n        # Clean up handler factories usages\n        with self.__instances_lock:\n            for svc_ref in self._handlers_refs:\n                self.__context.unget_service(svc_ref)\n\n            self._handlers.clear()\n            self._handlers_refs.clear()", "response": "iPOPO is stopping: clean everything up"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bundle_changed(self, event):\n        # type: (BundleEvent) -> None\n        \"\"\"\n        A bundle event has been triggered\n\n        :param event: The bundle event\n        \"\"\"\n        kind = event.get_kind()\n        bundle = event.get_bundle()\n\n        if kind == BundleEvent.STOPPING_PRECLEAN:\n            # A bundle is gone, remove its factories after the deactivator has\n            # been called. That way, the deactivator can kill manually started\n            # components.\n            self._unregister_bundle_factories(bundle)\n\n        elif kind == BundleEvent.STARTED:\n            # A bundle is staring, register its factories before its activator\n            # is called. That way, the activator can use the registered\n            # factories.\n            self._register_bundle_factories(bundle)\n\n        elif kind == BundleEvent.UPDATE_BEGIN:\n            # A bundle will be updated, store its auto-restart component\n            self._autorestart_store_components(bundle)\n\n        elif kind == BundleEvent.UPDATED:\n            # Update has finished, restart stored components\n            self._autorestart_components(bundle)\n            self._autorestart_clear_components(bundle)\n\n        elif kind == BundleEvent.UPDATE_FAILED:\n            # Update failed, clean the stored components\n            self._autorestart_clear_components(bundle)", "response": "Called when a bundle event has been triggered."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef service_changed(self, event):\n        # type: (ServiceEvent) -> None\n        \"\"\"\n        Called when a handler factory service is un/registered\n        \"\"\"\n        # Call sub-methods\n        kind = event.get_kind()\n        svc_ref = event.get_service_reference()\n\n        if kind == ServiceEvent.REGISTERED:\n            # Service coming\n            with self.__instances_lock:\n                self.__add_handler_factory(svc_ref)\n\n        elif kind == ServiceEvent.UNREGISTERING:\n            # Service gone\n            with self.__instances_lock:\n                self.__remove_handler_factory(svc_ref)", "response": "Called when a handler factory service is un - registered or registered."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef retry_erroneous(self, name, properties_update=None):\n        # type: (str, dict) -> int\n        \"\"\"\n        Removes the ERRONEOUS state of the given component, and retries a\n        validation\n\n        :param name: Name of the component to retry\n        :param properties_update: A dictionary to update the initial properties\n                                  of the component\n        :return: The new state of the component\n        :raise ValueError: Invalid component name\n        \"\"\"\n        with self.__instances_lock:\n            try:\n                stored_instance = self.__instances[name]\n            except KeyError:\n                raise ValueError(\n                    \"Unknown component instance '{0}'\".format(name)\n                )\n            else:\n                return stored_instance.retry_erroneous(properties_update)", "response": "Removes the ERRONEOUS state of the given component and retries the validation if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninvalidate the given component with the given name.", "response": "def invalidate(self, name):\n        # type: (str) -> None\n        \"\"\"\n        Invalidates the given component\n\n        :param name: Name of the component to invalidate\n        :raise ValueError: Invalid component name\n        \"\"\"\n        with self.__instances_lock:\n            try:\n                stored_instance = self.__instances[name]\n            except KeyError:\n                raise ValueError(\n                    \"Unknown component instance '{0}'\".format(name)\n                )\n            else:\n                # Call back the component during the invalidation\n                stored_instance.invalidate(True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef kill(self, name):\n        # type: (str) -> None\n        \"\"\"\n        Kills the given component\n\n        :param name: Name of the component to kill\n        :raise ValueError: Invalid component name\n        \"\"\"\n        if not name:\n            raise ValueError(\"Name can't be None or empty\")\n\n        with self.__instances_lock:\n            try:\n                # Running instance\n                stored_instance = self.__instances.pop(name)\n\n                # Store the reference to the factory context\n                factory_context = stored_instance.context.factory_context\n\n                # Kill it\n                stored_instance.kill()\n\n                # Update the singleton state flag\n                factory_context.is_singleton_active = False\n            except KeyError:\n                # Queued instance\n                try:\n                    # Extract the component context\n                    context, _ = self.__waiting_handlers.pop(name)\n\n                    # Update the singleton state flag\n                    context.factory_context.is_singleton_active = False\n                except KeyError:\n                    raise ValueError(\n                        \"Unknown component instance '{0}'\".format(name)\n                    )", "response": "Kills the given component with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register_factory(self, bundle_context, factory):\n        # type: (BundleContext, type) -> bool\n        \"\"\"\n        Registers a manually created factory, using decorators programmatically\n\n        :param bundle_context: The factory bundle context\n        :param factory: A manipulated class\n        :return: True if the factory has been registered\n        :raise ValueError: Invalid parameter, or factory already registered\n        :raise TypeError: Invalid factory type (not a manipulated class)\n        \"\"\"\n        if factory is None or bundle_context is None:\n            # Invalid parameter, to nothing\n            raise ValueError(\"Invalid parameter\")\n\n        context = _set_factory_context(factory, bundle_context)\n        if not context:\n            raise TypeError(\"Not a manipulated class (no context found)\")\n\n        self._register_factory(context.name, factory, False)\n        return True", "response": "Registers a manually created factory using decorators programmatically\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unregister_factory(self, factory_name):\n        # type: (str) -> bool\n        \"\"\"\n        Unregisters the given component factory\n\n        :param factory_name: Name of the factory to unregister\n        :return: True the factory has been removed, False if the factory is\n                 unknown\n        \"\"\"\n        if not factory_name or not is_string(factory_name):\n            # Invalid name\n            return False\n\n        with self.__factories_lock:\n            try:\n                # Remove the factory from the registry\n                factory_class = self.__factories.pop(factory_name)\n            except KeyError:\n                # Unknown factory\n                return False\n\n            # Trigger an event\n            self._fire_ipopo_event(\n                constants.IPopoEvent.UNREGISTERED, factory_name\n            )\n\n            # Invalidate and delete all components of this factory\n            with self.__instances_lock:\n                # Compute the list of __instances to remove\n                to_remove = self.__get_stored_instances(factory_name)\n\n                # Remove instances from the registry: avoids dependencies \\\n                # update to link against a component from this factory again.\n                for instance in to_remove:\n                    try:\n                        # Kill the instance\n                        self.kill(instance.name)\n                    except ValueError:\n                        # Unknown instance: already killed by the invalidation\n                        # callback of a component killed in this loop\n                        # => ignore\n                        pass\n\n                # Remove waiting component\n                names = [\n                    name\n                    for name, (context, _) in self.__waiting_handlers.items()\n                    if context.factory_context.name == factory_name\n                ]\n                for name in names:\n                    del self.__waiting_handlers[name]\n\n            # Clear the bundle context of the factory\n            _set_factory_context(factory_class, None)\n\n        return True", "response": "Unregisters the given component factory from the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_instances(self):\n        # type: () -> List[Tuple[str, str, int]]\n        \"\"\"\n        Retrieves the list of the currently registered component instances\n\n        :return: A list of (name, factory name, state) tuples.\n        \"\"\"\n        with self.__instances_lock:\n            return sorted(\n                (name, stored_instance.factory_name, stored_instance.state)\n                for name, stored_instance in self.__instances.items()\n            )", "response": "Returns the list of currently registered component instances."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the list of the instances waiting for their handlers", "response": "def get_waiting_components(self):\n        # type: () -> List[Tuple[str, str, Set[str]]]\n        \"\"\"\n        Returns the list of the instances waiting for their handlers\n\n        :return: A list of (name, factory name, missing handlers) tuples\n        \"\"\"\n        with self.__instances_lock:\n            result = []\n            for name, (context, _) in self.__waiting_handlers.items():\n                # Compute missing handlers\n                missing = set(context.factory_context.get_handlers_ids())\n                missing.difference_update(self._handlers.keys())\n\n                result.append((name, context.factory_context.name, missing))\n\n            result.sort()\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dictionary containing the details of the given component instance.", "response": "def get_instance_details(self, name):\n        # type: (str) -> Dict[str, Any]\n        \"\"\"\n        Retrieves a snapshot of the given component instance.\n        The result dictionary has the following keys:\n\n        * ``name``: The component name\n        * ``factory``: The name of the component factory\n        * ``bundle_id``: The ID of the bundle providing the component factory\n        * ``state``: The current component state\n        * ``services``: A ``{Service ID \u2192 Service reference}`` dictionary, with\n          all services provided by the component\n        * ``dependencies``: A dictionary associating field names with the\n          following dictionary:\n\n          * ``handler``: The name of the type of the dependency handler\n          * ``filter`` (optional): The requirement LDAP filter\n          * ``optional``: A flag indicating whether the requirement is optional\n            or not\n          * ``aggregate``: A flag indicating whether the requirement is a set\n            of services or not\n          * ``binding``: A list of the ServiceReference the component is bound\n            to\n\n        * ``properties``: A dictionary key \u2192 value, with all properties of the\n          component. The value is converted to its string representation, to\n          avoid unexpected behaviours.\n\n        :param name: The name of a component instance\n        :return: A dictionary of details\n        :raise ValueError: Invalid component name\n        \"\"\"\n        if not is_string(name):\n            raise ValueError(\"Component name must be a string\")\n\n        with self.__instances_lock:\n            if name not in self.__instances:\n                raise ValueError(\"Unknown component: {0}\".format(name))\n\n            stored_instance = self.__instances[name]\n            assert isinstance(stored_instance, StoredInstance)\n            with stored_instance._lock:\n                result = {}  # type: Dict[str, Any]\n                result[\"name\"] = stored_instance.name\n\n                # Factory name\n                result[\"factory\"] = stored_instance.factory_name\n\n                # Factory bundle\n                result[\n                    \"bundle_id\"\n                ] = stored_instance.bundle_context.get_bundle().get_bundle_id()\n\n                # Component state\n                result[\"state\"] = stored_instance.state\n\n                # Error details\n                result[\"error_trace\"] = stored_instance.error_trace\n\n                # Provided service\n                result[\"services\"] = {}\n                for handler in stored_instance.get_handlers(\n                    handlers_const.KIND_SERVICE_PROVIDER\n                ):\n                    svc_ref = handler.get_service_reference()\n                    if svc_ref is not None:\n                        svc_id = svc_ref.get_property(SERVICE_ID)\n                        result[\"services\"][svc_id] = svc_ref\n\n                # Dependencies\n                result[\"dependencies\"] = {}\n                for dependency in stored_instance.get_handlers(\n                    handlers_const.KIND_DEPENDENCY\n                ):\n                    # Dependency\n                    info = result[\"dependencies\"][dependency.get_field()] = {}\n                    info[\"handler\"] = type(dependency).__name__\n\n                    # Requirement\n                    req = dependency.requirement\n                    info[\"specification\"] = req.specification\n                    info[\"filter\"] = str(req.filter) if req.filter else None\n                    info[\"optional\"] = req.optional\n                    info[\"aggregate\"] = req.aggregate\n\n                    # Bindings\n                    info[\"bindings\"] = dependency.get_bindings()\n\n                # Properties\n                properties = stored_instance.context.properties.items()\n                result[\"properties\"] = {\n                    str(key): str(value) for key, value in properties\n                }\n\n                # All done\n                return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_factory_bundle(self, name):\n        # type: (str) -> Bundle\n        \"\"\"\n        Retrieves the Pelix Bundle object that registered the given factory\n\n        :param name: The name of a factory\n        :return: The Bundle that registered the given factory\n        :raise ValueError: Invalid factory\n        \"\"\"\n        with self.__factories_lock:\n            try:\n                factory = self.__factories[name]\n            except KeyError:\n                raise ValueError(\"Unknown factory '{0}'\".format(name))\n            else:\n                # Bundle Context is stored in the Factory Context\n                factory_context = getattr(\n                    factory, constants.IPOPO_FACTORY_CONTEXT\n                )\n                return factory_context.bundle_context.get_bundle()", "response": "Returns the Pelix Bundle object that registered the given factory\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_factory_details(self, name):\n        # type: (str) -> Dict[str, Any]\n        \"\"\"\n        Retrieves a dictionary with details about the given factory\n\n        * ``name``: The factory name\n        * ``bundle``: The Bundle object of the bundle providing the factory\n        * ``properties``: Copy of the components properties defined by the\n          factory\n        * ``requirements``: List of the requirements defined by the factory\n\n          * ``id``: Requirement ID (field where it is injected)\n          * ``specification``: Specification of the required service\n          * ``aggregate``: If True, multiple services will be injected\n          * ``optional``: If True, the requirement is optional\n\n        * ``services``: List of the specifications of the services provided by\n          components of this factory\n        * ``handlers``: Dictionary of the non-built-in handlers required by\n          this factory.\n          The dictionary keys are handler IDs, and it contains a tuple with:\n\n          * A copy of the configuration of the handler (0)\n          * A flag indicating if the handler is present or not\n\n        :param name: The name of a factory\n        :return: A dictionary describing the factory\n        :raise ValueError: Invalid factory\n        \"\"\"\n        with self.__factories_lock:\n            try:\n                factory = self.__factories[name]\n            except KeyError:\n                raise ValueError(\"Unknown factory '{0}'\".format(name))\n\n            context = getattr(factory, constants.IPOPO_FACTORY_CONTEXT)\n            assert isinstance(context, FactoryContext)\n\n            result = {}  # type: Dict[Any, Any]\n            # Factory name & bundle\n            result[\"name\"] = context.name\n            result[\"bundle\"] = context.bundle_context.get_bundle()\n\n            # Configurable properties\n            # Name -> Default value\n            result[\"properties\"] = {\n                prop_name: context.properties.get(prop_name)\n                for prop_name in context.properties_fields.values()\n            }\n\n            # Requirements (list of dictionaries)\n            reqs = result[\"requirements\"] = []\n            handler_requires = context.get_handler(constants.HANDLER_REQUIRES)\n            if handler_requires is not None:\n                for field, requirement in handler_requires.items():\n                    reqs.append(\n                        {\n                            \"id\": field,\n                            \"specification\": requirement.specification,\n                            \"aggregate\": requirement.aggregate,\n                            \"optional\": requirement.optional,\n                            \"filter\": requirement.original_filter,\n                        }\n                    )\n\n            # Provided services (list of list of specifications)\n            handler_provides = context.get_handler(constants.HANDLER_PROVIDES)\n            if handler_provides is not None:\n                result[\"services\"] = [\n                    specs_controller[0] for specs_controller in handler_provides\n                ]\n            else:\n                result[\"services\"] = []\n\n            # Other handlers\n            handlers = set(context.get_handlers_ids())\n            handlers.difference_update(\n                (\n                    constants.HANDLER_PROPERTY,\n                    constants.HANDLER_PROVIDES,\n                    constants.HANDLER_REQUIRES,\n                )\n            )\n            result[\"handlers\"] = {\n                handler: copy.deepcopy(context.get_handler(handler))\n                for handler in handlers\n            }\n\n            return result", "response": "Returns a dictionary describing the given factory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_double_stack(socket_obj, double_stack=True):\n    # type: (socket.socket, bool) -> None\n    \"\"\"\n    Sets up the IPv6 double stack according to the operating system\n\n    :param socket_obj: A socket object\n    :param double_stack: If True, use the double stack, else only support IPv6\n    :raise AttributeError: Python or system doesn't support V6\n    :raise socket.error: Error setting up the double stack value\n    \"\"\"\n    try:\n        # Use existing value\n        opt_ipv6_only = socket.IPV6_V6ONLY\n    except AttributeError:\n        # Use \"known\" value\n        if os.name == \"nt\":\n            # Windows: see ws2ipdef.h\n            opt_ipv6_only = 27\n        elif platform.system() == \"Linux\":\n            # Linux: see linux/in6.h (in recent kernels)\n            opt_ipv6_only = 26\n        else:\n            # Unknown value: do nothing\n            raise\n\n    # Setup the socket (can raise a socket.error)\n    socket_obj.setsockopt(ipproto_ipv6(), opt_ipv6_only, int(not double_stack))", "response": "Sets up the IPv6 double stack according to the operating system."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef escape_LDAP(ldap_string):\n    # type: (str) -> str\n    # pylint: disable=C0103\n    \"\"\"\n    Escape a string to let it go in an LDAP filter\n\n    :param ldap_string: The string to escape\n    :return: The protected string\n    \"\"\"\n    if not ldap_string:\n        # No content\n        return ldap_string\n\n    # Protect escape character previously in the string\n    assert is_string(ldap_string)\n    ldap_string = ldap_string.replace(\n        ESCAPE_CHARACTER, ESCAPE_CHARACTER + ESCAPE_CHARACTER\n    )\n\n    # Leading space\n    if ldap_string.startswith(\" \"):\n        ldap_string = \"\\\\ {0}\".format(ldap_string[1:])\n\n    # Trailing space\n    if ldap_string.endswith(\" \"):\n        ldap_string = \"{0}\\\\ \".format(ldap_string[:-1])\n\n    # Escape other characters\n    for escaped in ESCAPED_CHARACTERS:\n        ldap_string = ldap_string.replace(escaped, ESCAPE_CHARACTER + escaped)\n\n    return ldap_string", "response": "Escapes a string to let it go in an LDAP filter"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntesting if the filter value is presence test", "response": "def _comparator_presence(_, tested_value):\n    \"\"\"\n    Tests a filter which simply a joker, i.e. a value presence test\n    \"\"\"\n    # The filter value is a joker : simple presence test\n    if tested_value is None:\n        return False\n    elif hasattr(tested_value, \"__len__\"):\n        # Refuse empty values\n        # pylint: disable=C1801\n        return len(tested_value) != 0\n\n    # Presence validated\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests if a filter contains a joker item and returns True if it is the same as the filter_value.", "response": "def _comparator_star(filter_value, tested_value):\n    \"\"\"\n    Tests a filter containing a joker\n    \"\"\"\n    if isinstance(tested_value, ITERABLES):\n        for value in tested_value:\n            if _star_comparison(filter_value, value):\n                return True\n        return False\n\n    return _star_comparison(filter_value, tested_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntests a filter containing a joker and returns True if the tested value matches the filter value.", "response": "def _star_comparison(filter_value, tested_value):\n    \"\"\"\n    Tests a filter containing a joker\n    \"\"\"\n    if not is_string(tested_value):\n        # Unhandled value type...\n        return False\n\n    parts = filter_value.split(\"*\")\n\n    i = 0\n    last_part = len(parts) - 1\n\n    idx = 0\n    for part in parts:\n        # Find the part in the tested value\n        idx = tested_value.find(part, idx)\n        if idx == -1:\n            # Part not found\n            return False\n\n        len_part = len(part)\n        if i == 0 and len_part != 0 and idx != 0:\n            # First part is not a star, but the tested value is not at\n            # position 0 => Doesn't match\n            return False\n\n        if (\n            i == last_part\n            and len_part != 0\n            and idx != len(tested_value) - len_part\n        ):\n            # Last tested part is not at the end of the sequence\n            return False\n\n        # Be sure to test the next part\n        idx += len_part\n        i += 1\n\n    # Whole test passed\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests if the filter value is equal to the tested value", "response": "def _comparator_eq(filter_value, tested_value):\n    \"\"\"\n    Tests if the filter value is equal to the tested value\n    \"\"\"\n    if isinstance(tested_value, ITERABLES):\n        # Convert the list items to strings\n        for value in tested_value:\n            # Try with the string conversion\n            if not is_string(value):\n                value = repr(value)\n\n            if filter_value == value:\n                # Match !\n                return True\n    # Standard comparison\n    elif not is_string(tested_value):\n        # String vs string representation\n        return filter_value == repr(tested_value)\n    else:\n        # String vs string\n        return filter_value == tested_value\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntest if the filter value is nearly equal to the tested value.", "response": "def _comparator_approximate(filter_value, tested_value):\n    \"\"\"\n    Tests if the filter value is nearly equal to the tested value.\n\n    If the tested value is a string or an array of string, it compares their\n    lower case forms\n    \"\"\"\n    lower_filter_value = filter_value.lower()\n\n    if is_string(tested_value):\n        # Lower case comparison\n        return _comparator_eq(lower_filter_value, tested_value.lower())\n\n    elif hasattr(tested_value, \"__iter__\"):\n        # Extract a list of strings\n        new_tested = [\n            value.lower() for value in tested_value if is_string(value)\n        ]\n\n        if _comparator_eq(lower_filter_value, new_tested):\n            # Value found in the strings\n            return True\n\n    # Compare the raw values\n    return _comparator_eq(filter_value, tested_value) or _comparator_eq(\n        lower_filter_value, tested_value\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests if the filter value is nearly equal to the tested value.", "response": "def _comparator_approximate_star(filter_value, tested_value):\n    \"\"\"\n    Tests if the filter value, which contains a joker, is nearly equal to the\n    tested value.\n\n    If the tested value is a string or an array of string, it compares their\n    lower case forms\n    \"\"\"\n    lower_filter_value = filter_value.lower()\n\n    if is_string(tested_value):\n        # Lower case comparison\n        return _comparator_star(lower_filter_value, tested_value.lower())\n\n    elif hasattr(tested_value, \"__iter__\"):\n        # Extract a list of strings\n        new_tested = [\n            value.lower() for value in tested_value if is_string(value)\n        ]\n\n        if _comparator_star(lower_filter_value, new_tested):\n            # Value found in the strings\n            return True\n\n    # Compare the raw values\n    return _comparator_star(filter_value, tested_value) or _comparator_star(\n        lower_filter_value, tested_value\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests if the filter value is strictly greater than the tested value.", "response": "def _comparator_lt(filter_value, tested_value):\n    \"\"\"\n    Tests if the filter value is strictly greater than the tested value\n\n    tested_value < filter_value\n    \"\"\"\n    if is_string(filter_value):\n        value_type = type(tested_value)\n        try:\n            # Try a conversion\n            filter_value = value_type(filter_value)\n\n        except (TypeError, ValueError):\n            if value_type is int:\n                # Integer/float comparison trick\n                try:\n                    filter_value = float(filter_value)\n                except (TypeError, ValueError):\n                    # None-float value\n                    return False\n            else:\n                # Incompatible type\n                return False\n    try:\n        return tested_value < filter_value\n    except TypeError:\n        # Incompatible type\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _compute_comparator(string, idx):\n    # type: (str, int) -> Optional[Callable[[Any, Any], bool]]\n    \"\"\"\n    Tries to compute the LDAP comparator at the given index\n\n    Valid operators are :\n\n    * = : equality\n    * <= : less than\n    * >= : greater than\n    * ~= : approximate\n\n    :param string: A LDAP filter string\n    :param idx: An index in the given string\n    :return: The corresponding operator, None if unknown\n    \"\"\"\n    part1 = string[idx]\n    try:\n        part2 = string[idx + 1]\n    except IndexError:\n        # String is too short (no comparison)\n        return None\n\n    if part1 == \"=\":\n        # Equality\n        return _comparator_eq\n    elif part2 != \"=\":\n        # It's a \"strict\" operator\n        if part1 == \"<\":\n            # Strictly lesser\n            return _comparator_lt\n        elif part1 == \">\":\n            # Strictly greater\n            return _comparator_gt\n    else:\n        if part1 == \"<\":\n            # Less or equal\n            return _comparator_le\n        elif part1 == \">\":\n            # Greater or equal\n            return _comparator_ge\n        elif part1 == \"~\":\n            # Approximate equality\n            return _comparator_approximate\n    return None", "response": "Compute the LDAP comparator function at the given index"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _compute_operation(string, idx):\n    # type: (str, int) -> Optional[int]\n    \"\"\"\n    Tries to compute the LDAP operation at the given index\n\n    Valid operations are :\n\n    * & : AND\n    * | : OR\n    * ! : NOT\n\n    :param string: A LDAP filter string\n    :param idx: An index in the given string\n    :return: The corresponding operator (AND, OR or NOT)\n    \"\"\"\n    operator = string[idx]\n    if operator == \"&\":\n        return AND\n    elif operator == \"|\":\n        return OR\n    elif operator == \"!\":\n        return NOT\n\n    return None", "response": "Compute the LDAP operation at the given index"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _skip_spaces(string, idx):\n    # type: (str, int) -> int\n    \"\"\"\n    Retrieves the next non-space character after idx index in the given string\n\n    :param string: The string to look into\n    :param idx: The base search index\n    :return: The next non-space character index, -1 if not found\n    \"\"\"\n    i = idx\n    for char in string[idx:]:\n        if not char.isspace():\n            return i\n        i += 1\n\n    return -1", "response": "Returns the next non - space character after idx in the given string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing an LDAP filter string and returns a LDAPCriteria object.", "response": "def _parse_ldap_criteria(ldap_filter, startidx=0, endidx=-1):\n    # type: (str, int, int) -> LDAPCriteria\n    \"\"\"\n    Parses an LDAP sub filter (criterion)\n\n    :param ldap_filter: An LDAP filter string\n    :param startidx: Sub-filter start index\n    :param endidx: Sub-filter end index\n    :return: The LDAP sub-filter\n    :raise ValueError: Invalid sub-filter\n    \"\"\"\n    comparators = \"=<>~\"\n    if startidx < 0:\n        raise ValueError(\n            \"Invalid string range start={0}, end={1}\".format(startidx, endidx)\n        )\n\n    # Get the comparator\n    escaped = False\n    idx = startidx\n    for char in ldap_filter[startidx:endidx]:\n        if not escaped:\n            if char == ESCAPE_CHARACTER:\n                # Next character escaped\n                escaped = True\n            elif char in comparators:\n                # Comparator found\n                break\n        else:\n            # Escaped character ignored\n            escaped = False\n        idx += 1\n    else:\n        # Comparator never found\n        raise ValueError(\n            \"Comparator not found in '{0}'\".format(ldap_filter[startidx:endidx])\n        )\n\n    # The attribute name can be extracted directly\n    attribute_name = ldap_filter[startidx:idx].strip()\n    if not attribute_name:\n        # Attribute name is missing\n        raise ValueError(\n            \"Attribute name is missing in '{0}'\".format(\n                ldap_filter[startidx:endidx]\n            )\n        )\n\n    comparator = _compute_comparator(ldap_filter, idx)\n    if comparator is None:\n        # Unknown comparator\n        raise ValueError(\n            \"Unknown comparator in '{0}' - {1}\\nFilter : {2}\".format(\n                ldap_filter[startidx:endidx], ldap_filter[idx], ldap_filter\n            )\n        )\n\n    # Find the end of the comparator\n    while ldap_filter[idx] in comparators:\n        idx += 1\n\n    # Skip spaces\n    idx = _skip_spaces(ldap_filter, idx)\n\n    # Extract the value\n    value = ldap_filter[idx:endidx].strip()\n\n    # Use the appropriate comparator if a joker is found in the filter value\n    if value == \"*\":\n        # Presence comparator\n        comparator = _comparator_presence\n    elif \"*\" in value:\n        # Joker\n        if comparator == _comparator_eq:\n            comparator = _comparator_star\n        elif comparator == _comparator_approximate:\n            comparator = _comparator_approximate_star\n\n    return LDAPCriteria(\n        unescape_LDAP(attribute_name), unescape_LDAP(value), comparator\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse an LDAP filter string and returns an LDAP filter object.", "response": "def _parse_ldap(ldap_filter):\n    # type: (str) -> Optional[LDAPFilter]\n    \"\"\"\n    Parses the given LDAP filter string\n\n    :param ldap_filter: An LDAP filter string\n    :return: An LDAPFilter object, None if the filter was empty\n    :raise ValueError: The LDAP filter string is invalid\n    \"\"\"\n    if ldap_filter is None:\n        # Nothing to do\n        return None\n\n    assert is_string(ldap_filter)\n\n    # Remove surrounding spaces\n    ldap_filter = ldap_filter.strip()\n    if not ldap_filter:\n        # Empty string\n        return None\n\n    escaped = False\n    filter_len = len(ldap_filter)\n    root = None\n    stack = []\n    subfilter_stack = []\n\n    idx = 0\n    while idx < filter_len:\n        if not escaped:\n            if ldap_filter[idx] == \"(\":\n                # Opening filter : get the operator\n                idx = _skip_spaces(ldap_filter, idx + 1)\n                if idx == -1:\n                    raise ValueError(\n                        \"Missing filter operator: {0}\".format(ldap_filter)\n                    )\n\n                operator = _compute_operation(ldap_filter, idx)\n                if operator is not None:\n                    # New sub-filter\n                    stack.append(LDAPFilter(operator))\n                else:\n                    # Sub-filter content\n                    subfilter_stack.append(idx)\n\n            elif ldap_filter[idx] == \")\":\n                # Ending filter : store it in its parent\n                if subfilter_stack:\n                    # criterion finished\n                    start_idx = subfilter_stack.pop()\n                    criterion = _parse_ldap_criteria(\n                        ldap_filter, start_idx, idx\n                    )\n\n                    if stack:\n                        top = stack.pop()\n                        top.append(criterion)\n                        stack.append(top)\n                    else:\n                        # No parent : filter contains only one criterion\n                        # Make a parent to stay homogeneous\n                        root = LDAPFilter(AND)\n                        root.append(criterion)\n                elif stack:\n                    # Sub filter finished\n                    ended_filter = stack.pop()\n                    if stack:\n                        top = stack.pop()\n                        top.append(ended_filter)\n                        stack.append(top)\n                    else:\n                        # End of the parse\n                        root = ended_filter\n                else:\n                    raise ValueError(\n                        \"Too many end of parenthesis:{0}: {1}\".format(\n                            idx, ldap_filter[idx:]\n                        )\n                    )\n            elif ldap_filter[idx] == \"\\\\\":\n                # Next character must be ignored\n                escaped = True\n        else:\n            # Escaped character ignored\n            escaped = False\n\n        # Don't forget to increment...\n        idx += 1\n\n    # No root : invalid content\n    if root is None:\n        raise ValueError(\"Invalid filter string: {0}\".format(ldap_filter))\n\n    # Return the root of the filter\n    return root.normalize()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_ldap_filter(ldap_filter):\n    # type: (Any) -> Optional[Union[LDAPFilter, LDAPCriteria]]\n    \"\"\"\n    Retrieves the LDAP filter object corresponding to the given filter.\n    Parses it the argument if it is an LDAPFilter instance\n\n    :param ldap_filter: An LDAP filter (LDAPFilter or string)\n    :return: The corresponding filter, can be None\n    :raise ValueError: Invalid filter string found\n    :raise TypeError: Unknown filter type\n    \"\"\"\n    if ldap_filter is None:\n        return None\n\n    if isinstance(ldap_filter, (LDAPFilter, LDAPCriteria)):\n        # No conversion needed\n        return ldap_filter\n    elif is_string(ldap_filter):\n        # Parse the filter\n        return _parse_ldap(ldap_filter)\n\n    # Unknown type\n    raise TypeError(\n        \"Unhandled filter type {0}\".format(type(ldap_filter).__name__)\n    )", "response": "Returns the LDAP filter object corresponding to the given filter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef combine_filters(filters, operator=AND):\n    # type: (Iterable[Any], int) -> Optional[Union[LDAPFilter, LDAPCriteria]]\n    \"\"\"\n    Combines two LDAP filters, which can be strings or LDAPFilter objects\n\n    :param filters: Filters to combine\n    :param operator: The operator for combination\n    :return: The combined filter, can be None if all filters are None\n    :raise ValueError: Invalid filter string found\n    :raise TypeError: Unknown filter type\n    \"\"\"\n    if not filters:\n        return None\n\n    if not hasattr(filters, \"__iter__\") or is_string(filters):\n        raise TypeError(\"Filters argument must be iterable\")\n\n    # Remove None filters and convert others\n    ldap_filters = []\n    for sub_filter in filters:\n        if sub_filter is None:\n            # Ignore None filters\n            continue\n\n        ldap_filter = get_ldap_filter(sub_filter)\n        if ldap_filter is not None:\n            # Valid filter\n            ldap_filters.append(ldap_filter)\n\n    if not ldap_filters:\n        # Do nothing\n        return None\n    elif len(ldap_filters) == 1:\n        # Only one filter, return it\n        return ldap_filters[0]\n\n    new_filter = LDAPFilter(operator)\n    for sub_filter in ldap_filters:\n        # Direct combination\n        new_filter.append(sub_filter)\n\n    return new_filter.normalize()", "response": "Combines two LDAP filters and returns the combined filter."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nappends an LDAP filter or a criterion to the filterlist.", "response": "def append(self, ldap_filter):\n        \"\"\"\n        Appends a filter or a criterion to this filter\n\n        :param ldap_filter: An LDAP filter or criterion\n        :raise TypeError: If the parameter is not of a known type\n        :raise ValueError: If the more than one filter is associated to a\n                           NOT operator\n        \"\"\"\n        if not isinstance(ldap_filter, (LDAPFilter, LDAPCriteria)):\n            raise TypeError(\n                \"Invalid filter type: {0}\".format(type(ldap_filter).__name__)\n            )\n\n        if len(self.subfilters) >= 1 and self.operator == NOT:\n            raise ValueError(\"Not operator only handles one child\")\n\n        self.subfilters.append(ldap_filter)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef matches(self, properties):\n        # Use a generator, and declare it outside of the method call\n        # => seems to be quite a speed up trick\n        generator = (\n            criterion.matches(properties) for criterion in self.subfilters\n        )\n\n        # Extract \"if\" from loops and use built-in methods\n        if self.operator == OR:\n            result = any(generator)\n        else:\n            result = all(generator)\n            if self.operator == NOT:\n                # Revert result\n                return not result\n\n        return result", "response": "Tests if the given properties matches this LDAP filter and its children."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef normalize(self):\n        if not self.subfilters:\n            # No sub-filters\n            return None\n\n        # New sub-filters list\n        new_filters = []\n        for subfilter in self.subfilters:\n            # Normalize the sub-filter before storing it\n            norm_filter = subfilter.normalize()\n            if norm_filter is not None and norm_filter not in new_filters:\n                new_filters.append(norm_filter)\n\n        # Update the instance\n        self.subfilters = new_filters\n\n        size = len(self.subfilters)\n        if size > 1 or self.operator == NOT:\n            # Normal filter or NOT\n            # NOT is the only operator to accept 1 operand\n            return self\n\n        # Return the only child as the filter object\n        return self.subfilters[0].normalize()", "response": "Normalizes the filter and returns the first meaningful object in this filter."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntesting if the given LDAP criterion matches this LDAP criterion.", "response": "def matches(self, properties):\n        \"\"\"\n        Tests if the given criterion matches this LDAP criterion\n\n        :param properties: A dictionary of properties\n        :return: True if the properties matches this criterion, else False\n        \"\"\"\n        try:\n            # Use the comparator\n            return self.comparator(self.value, properties[self.name])\n        except KeyError:\n            # Criterion key is not in the properties\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the framework :param is_server: If True, starts the provider bundle, else the consumer one :param discoveries: List of discovery protocols :param transports: List of RPC protocols :param http_port: Port of the HTTP server :param other_arguments: Other arguments", "response": "def main(is_server, discoveries, transports, http_port, other_arguments):\n    \"\"\"\n    Runs the framework\n\n    :param is_server: If True, starts the provider bundle,\n                      else the consumer one\n    :param discoveries: List of discovery protocols\n    :param transports: List of RPC protocols\n    :param http_port: Port of the HTTP server\n    :param other_arguments: Other arguments\n    \"\"\"\n    # Create the framework\n    framework = pelix.framework.create_framework(\n        (\n            \"pelix.ipopo.core\",\n            \"pelix.ipopo.waiting\",\n            # Shell\n            \"pelix.shell.core\",\n            \"pelix.shell.ipopo\",\n            \"pelix.shell.console\",\n            # HTTP Service\n            \"pelix.http.basic\",\n            # Remote Services (core)\n            \"pelix.remote.dispatcher\",\n            \"pelix.remote.registry\",\n        ),\n        # Framework properties\n        {pelix.constants.FRAMEWORK_UID: other_arguments.fw_uid},\n    )\n\n    # Start everything\n    framework.start()\n    context = framework.get_bundle_context()\n\n    # Instantiate components\n    # Get the iPOPO service\n    with use_waiting_list(context) as ipopo:\n        # Instantiate remote service components\n        # ... HTTP server\n        ipopo.add(\n            \"pelix.http.service.basic.factory\",\n            \"http-server\",\n            {\"pelix.http.address\": \"0.0.0.0\", \"pelix.http.port\": http_port},\n        )\n\n        # ... servlet giving access to the registry\n        ipopo.add(\n            rs.FACTORY_REGISTRY_SERVLET, \"pelix-remote-dispatcher-servlet\"\n        )\n\n    # Prepare the utility object\n    util = InstallUtils(context, other_arguments)\n\n    # Install the discovery bundles\n    for discovery in discoveries:\n        getattr(util, \"discovery_{0}\".format(discovery))()\n\n    # Install the transport bundles\n    for transport in transports:\n        getattr(util, \"transport_{0}\".format(transport))()\n\n    # Start the service provider or consumer\n    if is_server:\n        # ... the provider\n        context.install_bundle(\"remote.provider\").start()\n\n    else:\n        # ... or the consumer\n        context.install_bundle(\"remote.consumer\").start()\n\n    # Start the framework and wait for it to stop\n    framework.wait_for_stop()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninstalling the multicast discovery bundles and instantiates components", "response": "def discovery_multicast(self):\n        \"\"\"\n        Installs the multicast discovery bundles and instantiates components\n        \"\"\"\n        # Install the bundle\n        self.context.install_bundle(\"pelix.remote.discovery.multicast\").start()\n\n        with use_waiting_list(self.context) as ipopo:\n            # Instantiate the discovery\n            ipopo.add(\n                rs.FACTORY_DISCOVERY_MULTICAST, \"pelix-discovery-multicast\"\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninstalling the mDNS discovery bundles and instantiates components", "response": "def discovery_mdns(self):\n        \"\"\"\n        Installs the mDNS discovery bundles and instantiates components\n        \"\"\"\n        # Remove Zeroconf debug output\n        logging.getLogger(\"zeroconf\").setLevel(logging.WARNING)\n\n        # Install the bundle\n        self.context.install_bundle(\"pelix.remote.discovery.mdns\").start()\n\n        with use_waiting_list(self.context) as ipopo:\n            # Instantiate the discovery\n            ipopo.add(rs.FACTORY_DISCOVERY_ZEROCONF, \"pelix-discovery-zeroconf\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninstalls the MQTT discovery bundles and instantiates components", "response": "def discovery_mqtt(self):\n        \"\"\"\n        Installs the MQTT discovery bundles and instantiates components\n        \"\"\"\n        # Install the bundle\n        self.context.install_bundle(\"pelix.remote.discovery.mqtt\").start()\n\n        with use_waiting_list(self.context) as ipopo:\n            # Instantiate the discovery\n            ipopo.add(\n                rs.FACTORY_DISCOVERY_MQTT,\n                \"pelix-discovery-mqtt\",\n                {\n                    \"application.id\": \"sample.rs\",\n                    \"mqtt.host\": self.arguments.mqtt_host,\n                    \"mqtt.port\": self.arguments.mqtt_port,\n                },\n            )"}
