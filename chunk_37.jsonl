{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getsdm(*args, **kwargs):\n\n    try:\n        sdm = sdmpy.SDM(*args, **kwargs)\n    except XMLSyntaxError:\n        kwargs['use_xsd'] = False\n        sdm = sdmpy.SDM(*args, **kwargs)\n\n    return sdm", "response": "Wrap sdmpy. SDM to get around schema change error"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart changing light level manually. Direction should be up or down.", "response": "def start_change(self, direction):\n        \"\"\"Start changing light level manually. Direction should be 'up' or 'down'\"\"\"\n        self.logger.info(\"Dimmer %s start_change: %s\", self.device_id, direction)\n\n        if direction == 'up':\n            level = '01'\n        elif direction == 'down':\n            level = '00'\n        else:\n            self.logger.error(\"Dimmer %s start_change: %s is invalid, use up or down\",\n                              self.device_id, direction)\n            return False\n\n        self.hub.direct_command(self.device_id, '17', level)\n        success = self.hub.check_success(self.device_id, '17',\n                                         self.hub.brightness_to_hex(level))\n        if success:\n            self.logger.info(\"Dimmer %s start_change: Light started changing successfully\",\n                             self.device_id)\n            self.hub.clear_device_command_cache(self.device_id)\n        else:\n            self.logger.error(\"Dimmer %s start_change: Light did not change\",\n                              self.device_id)\n\n        return success"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstopping changing light level manually", "response": "def stop_change(self):\n        \"\"\"Stop changing light level manually\"\"\"\n        self.logger.info(\"Dimmer %s stop_change\", self.device_id)\n\n        self.hub.direct_command(self.device_id, '18', '00')\n        success = self.hub.check_success(self.device_id, '18', '00')\n        if success:\n            self.logger.info(\"Dimmer %s stop_change: Light stopped changing successfully\",\n                             self.device_id)\n            self.hub.clear_device_command_cache(self.device_id)\n        else:\n            self.logger.error(\"Dimmer %s stop_change: Light did not stop\",\n                              self.device_id)\n\n        return success"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes dimmer beep. Not all devices support this", "response": "def beep(self):\n        \"\"\"Make dimmer beep. Not all devices support this\"\"\"\n        self.logger.info(\"Dimmer %s beep\", self.device_id)\n\n        self.hub.direct_command(self.device_id, '30', '00')\n\n        success = self.hub.check_success(self.device_id, '30', '00')\n\n        return success"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the pk if we have one or raise a ValueError", "response": "def _get_pk(self):\n        \"\"\"\n        Return None if we don't have any filter on a pk, the pk if we have one,\n        or raise a ValueError if we have more than one.\n        For internal use only.\n        \"\"\"\n        pk = None\n        if self._lazy_collection['pks']:\n            if len(self._lazy_collection['pks']) > 1:\n                raise ValueError('Too much pks !')\n            pk = list(self._lazy_collection['pks'])[0]\n        return pk"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _prepare_sort_options(self, has_pk):\n        sort_options = {}\n        if self._sort is not None and not has_pk:\n            sort_options.update(self._sort)\n        if self._sort_limits is not None:\n            if 'start' in self._sort_limits and 'num' not in self._sort_limits:\n                self._sort_limits['num'] = -1\n            elif 'num' in self._sort_limits and 'start' not in self._sort_limits:\n                self._sort_limits['start'] = 0\n            sort_options.update(self._sort_limits)\n        if not sort_options and self._sort is None:\n            sort_options = None\n        return sort_options", "response": "Prepare sort options to use when calling the collection depending on _sort and _sort_limits attributes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of instances for each given pk respecting the condition about checking or not.", "response": "def _to_instances(self, pks):\n        \"\"\"\n        Returns a list of instances for each given pk, respecting the condition\n        about checking or not if a pk exists.\n        \"\"\"\n        # we want instances, so create an object for each pk, without\n        # checking for pk existence if asked\n        meth = self.cls.lazy_connect if self._instances_skip_exist_test else self.cls\n        return [meth(pk) for pk in pks]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprepares the results from redis before returning them.", "response": "def _prepare_results(self, results):\n        \"\"\"\n        Called in _collection to prepare results from redis before returning\n        them.\n        \"\"\"\n        if self._instances:\n            results = self._to_instances(results)\n        else:\n            results = list(results)\n\n        # cache the len for future use\n        self._len = len(results)\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _prepare_sets(self, sets):\n\n        final_sets = set()\n        tmp_keys = set()\n\n        for set_ in sets:\n            if isinstance(set_, str):\n                final_sets.add(set_)\n            elif isinstance(set_, ParsedFilter):\n\n                for index_key, key_type, is_tmp in set_.index.get_filtered_keys(\n                            set_.suffix,\n                            accepted_key_types=self._accepted_key_types,\n                            *(set_.extra_field_parts + [set_.value])\n                        ):\n                    if key_type not in self._accepted_key_types:\n                        raise ValueError('The index key returned by the index %s is not valid' % (\n                            set_.index.__class__.__name__\n                        ))\n                    final_sets.add(index_key)\n                    if is_tmp:\n                        tmp_keys.add(index_key)\n            else:\n                raise ValueError('Invalid filter type')\n\n        return final_sets, tmp_keys", "response": "Prepare the set of redis sets to be used for the new set."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the name of the final set to use and a list of keys to delete once the collection is really called.", "response": "def _get_final_set(self, sets, pk, sort_options):\n        \"\"\"\n        Called by _collection to get the final set to work on. Return the name\n        of the set to use, and a list of keys to delete once the collection is\n        really called (in case of a computed set based on multiple ones)\n        \"\"\"\n        conn = self.cls.get_connection()\n        all_sets = set()\n        tmp_keys = set()\n\n        if pk is not None and not sets and not (sort_options and sort_options.get('get')):\n            # no final set if only a pk without values to retrieve\n            return (None, False)\n\n        elif sets or pk:\n            if sets:\n                new_sets, new_tmp_keys = self._prepare_sets(sets)\n                all_sets.update(new_sets)\n                tmp_keys.update(new_tmp_keys)\n            if pk is not None:\n                # create a set with the pk to do intersection (and to pass it to\n                # the store command to retrieve values if needed)\n                tmp_key = self._unique_key()\n                conn.sadd(tmp_key, pk)\n                all_sets.add(tmp_key)\n                tmp_keys.add(tmp_key)\n\n        else:\n            # no sets or pk, use the whole collection instead\n            all_sets.add(self.cls.get_field('pk').collection_key)\n\n        if not all_sets:\n            delete_set_later = False\n            final_set = None\n        elif len(all_sets) == 1:\n            # if we have only one set, we  delete the set after calling\n            # collection only if it's a temporary one, and we do not delete\n            # it right now\n            final_set = all_sets.pop()\n            if final_set in tmp_keys:\n                delete_set_later = True\n                tmp_keys.remove(final_set)\n            else:\n                delete_set_later = False\n        else:\n            # more than one set, do an intersection on all of them in a new key\n            # that will must be deleted once the collection is called.\n            delete_set_later = True\n            final_set = self._combine_sets(all_sets, self._unique_key())\n\n        if tmp_keys:\n            conn.delete(*tmp_keys)\n\n        # return the final set to work on, and a flag if we later need to delete it\n        return (final_set, [final_set] if delete_set_later else None)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a list of sets combine them into a single set and return the set that will be used to make the final redis call.", "response": "def _combine_sets(self, sets, final_set):\n        \"\"\"\n        Given a list of set, combine them to create the final set that will be\n        used to make the final redis call.\n        \"\"\"\n        self.cls.get_connection().sinterstore(final_set, list(sets))\n        return final_set"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _field_is_pk(self, field_name):\n        if self.cls._field_is_pk(field_name):\n            return True\n        if field_name.endswith('__eq') and self.cls._field_is_pk(field_name[:-4]):\n            return True\n        return False", "response": "Check if the given name is the pk field."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _add_filters(self, **filters):\n        for key, value in filters.items():\n            if self._field_is_pk(key):\n                pk = self.cls.get_field('pk').normalize(value)\n                self._lazy_collection['pks'].add(pk)\n            else:\n                # store the info to call the index later, in ``_prepare_sets``\n                # (to avoid doing extra work if the collection is never called)\n                index, suffix, extra_field_parts = self._parse_filter_key(key)\n                parsed_filter = ParsedFilter(index, suffix, extra_field_parts, value)\n                self._lazy_collection['sets'].append(parsed_filter)\n\n        return self", "response": "Define self. _lazy_collection according to filters."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nasks the collection to return a list of instances.", "response": "def instances(self, skip_exist_test=False):\n        \"\"\"\n        Ask the collection to return a list of instances.\n        If skip_exist_test is set to True, the instances returned by the\n        collection won't have their primary key checked for existence.\n        \"\"\"\n        self.reset_result_type()\n        self._instances = True\n        self._instances_skip_exist_test = skip_exist_test\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_simple_fields(self):\n        fields = []\n        for field_name in self.cls._fields:\n            field = self.cls.get_field(field_name)\n            if not isinstance(field, MultiValuesField):\n                fields.append(field_name)\n        return fields", "response": "Return a list of all simple values of the class fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the sort parameter of the object.", "response": "def sort(self, **parameters):\n        \"\"\"\n        Parameters:\n        `by`: pass either a field name or a wildcard string to sort on\n              prefix with `-` to make a desc sort.\n        `alpha`: set it to True to sort lexicographically instead of numerically.\n        \"\"\"\n        parameters = self._coerce_by_parameter(parameters)\n        self._sort = parameters\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef plot_cand(candsfile, candloc=[], candnum=-1, threshold=0, savefile=True, returndata=False, outname='', newplot=True, returnstate=False, **kwargs):\n\n    # get candidate info\n    loc, prop, d0 = pc.read_candidates(candsfile, returnstate=True)\n\n    # define state dict and overload with user prefs\n    for key in kwargs:\n        logger.info('Setting %s to %s' % (key, kwargs[key]))\n        d0[key] = kwargs[key]\n    d0['logfile'] = False  # no need to save log\n\n    # feature columns\n    if 'snr2' in d0['features']:\n        snrcol = d0['features'].index('snr2')\n    elif 'snr1' in d0['features']:\n        snrcol = d0['features'].index('snr1')\n    if 'l2' in d0['features']:\n        lcol = d0['features'].index('l2')\n    elif 'l1' in d0['features']:\n        lcol = d0['features'].index('l1')\n    if 'm2' in d0['features']:\n        mcol = d0['features'].index('m2')\n    elif 'm1' in d0['features']:\n        mcol = d0['features'].index('m1')\n\n    scancol = d0['featureind'].index('scan')\n    segmentcol = d0['featureind'].index('segment')\n    intcol = d0['featureind'].index('int')\n    dtindcol = d0['featureind'].index('dtind')\n    dmindcol = d0['featureind'].index('dmind')\n\n    # sort and prep candidate list\n    snrs = prop[:, snrcol]\n    select = np.where(np.abs(snrs) > threshold)[0]\n    loc = loc[select]\n    prop = prop[select]\n\n    if candnum >= 0 or len(candloc):\n        if (candnum >= 0) and not len(candloc):\n            logger.info('Reproducing and visualizing candidate %d at %s with properties %s.' % (candnum, loc[candnum], prop[candnum]))\n            dmarrorig = d0['dmarr']\n            dtarrorig = d0['dtarr']\n            scan = loc[candnum, scancol]\n            segment = loc[candnum, segmentcol]\n            candint = loc[candnum, intcol]\n            dmind = loc[candnum, dmindcol]\n            dtind = loc[candnum, dtindcol]\n            beamnum = 0\n            candloc = (scan, segment, candint, dmind, dtind, beamnum)\n        elif len(candloc) and (candnum < 0):\n            assert len(candloc) == 6, 'candloc should be length 6 ( scan, segment, candint, dmind, dtind, beamnum ).'\n            logger.info('Reproducing and visualizing candidate %d at %s' % (candnum, candloc))\n            dmarrorig = d0['dmarr']\n            dtarrorig = d0['dtarr']\n            scan, segment, candint, dmind, dtind, beamnum = candloc\n        else:\n            raise Exception, 'Provide candnum or candloc, not both'\n\n        # if working locally, set workdir appropriately. Can also be used in queue system with full path given.\n        if not os.path.dirname(candsfile):\n            d0['workdir'] = os.getcwd()\n        else:\n            d0['workdir'] = os.path.dirname(candsfile)\n        filename = os.path.join(d0['workdir'], os.path.basename(d0['filename']))\n\n        if d0.has_key('segmenttimesdict'):  # using merged pkl\n            segmenttimes = d0['segmenttimesdict'][scan]\n        else:\n            segmenttimes = d0['segmenttimes']\n\n        # clean up d0 of superfluous keys\n        params = pp.Params()  # will be used as input to rt.set_pipeline\n        for key in d0.keys():\n            if not hasattr(params, key): # and 'memory_limit' not in key:\n                _ = d0.pop(key)\n        d0['npix'] = 0\n        d0['uvres'] = 0\n        d0['logfile'] = False\n        d0['savenoise'] = False\n        d0['savecands'] = False\n\n# this triggers redefinition of segment boundaries. memory optimization changed, so this is a problem.\n#        d0['nsegments'] = 0\n#        d0['scale_nsegments'] = 1.\n        d0['segmenttimes'] = segmenttimes\n        d0['nsegments'] = len(segmenttimes)\n\n        # get cand data\n        d = rt.set_pipeline(filename, scan, **d0)\n        (vismem, immem) = rt.calc_memory_footprint(d)\n        if 'memory_limit' in d:\n            assert vismem+immem < d['memory_limit'], 'memory_limit defined, but nsegments must (for now) be set to initial values to properly reproduce candidate'\n\n        im, data = rt.pipeline_reproduce(d, candloc, product='imdata') # removed loc[candnum]\n\n        # optionally plot\n        if savefile:\n            loclabel = scan, segment, candint, dmind, dtind, beamnum\n            if newplot:\n                make_cand_plot(d, im, data, loclabel, version=2, snrs=snrs, outname=outname) \n            else:\n                make_cand_plot(d, im, data, loclabel, version=1, outname=outname)\n\n        # optionally return data\n        if returndata:\n            return (im, data)\n        elif returnstate:\n            return d", "response": "Plot a single candidate for plotting or inspection."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_cands(candsfile, threshold=0.):\n\n    loc, prop, d0 = pc.read_candidates(candsfile, snrmin=threshold, returnstate=True)\n\n    if 'snr2' in d0['features']:\n        snrcol = d0['features'].index('snr2')\n    elif 'snr1' in d0['features']:\n        snrcol = d0['features'].index('snr1')\n    dmindcol = d0['featureind'].index('dmind')\n\n    if len(loc):\n        snrs = prop[:, snrcol]\n        times = pc.int2mjd(d0, loc)\n        times = times - times[0]\n\n        logger.info('Getting candidates...')\n        logger.info('candnum: loc, SNR, DM (pc/cm3), time (s; rel)')\n        for i in range(len(loc)):\n            logger.info(\"%d: %s, %.1f, %.1f, %.1f\" % (i, str(loc[i]), prop[i, snrcol], np.array(d0['dmarr'])[loc[i,dmindcol]], times[i]))", "response": "Prints candidate info in time order above some threshold"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun refine_cand on all positive SNR candidates above threshold. Any detected at higher SNR are highlighted.", "response": "def refine_cands(candsfile, threshold=0, scaledm=2.1, scalepix=2, scaleuv=1.0, chans=[], savepkl=True):\n    \"\"\" Runs refine_cand on all positive SNR candidates above threshold. Any detected at higher SNR are highlighted. \"\"\"\n\n    # get snrs above threshold\n    locs, props, d = pc.read_candidates(candsfile, snrmin=threshold, returnstate=True)\n\n    if 'snr2' in d['features']:\n        snrcol = d['features'].index('snr2')\n    elif 'snr1' in d['features']:\n        snrcol = d['features'].index('snr1')\n    scancol = d['featureind'].index('scan')\n    segmentcol = d['featureind'].index('segment')\n    intcol = d['featureind'].index('int')\n    dtindcol = d['featureind'].index('dtind')\n    dmindcol = d['featureind'].index('dmind')\n    snrs = props[:, snrcol]\n    \n    for (i, snr) in enumerate(snrs):\n        if snr > 0:\n            d, cands = refine_cand(candsfile, threshold=threshold, candnum=i,\n                                   scaledm=scaledm, scalepix=scalepix, scaleuv=scaleuv, chans=chans)\n            if cands:\n                candlocs = np.array(cands.keys())\n                candprops = np.array(cands.values())\n\n                scan = locs[i, scancol]\n                segment = locs[i, segmentcol]\n                candint = locs[i, intcol]\n                dmind = locs[i, dmindcol]\n                dtind = locs[i, dtindcol]\n                candfile = 'cands_{0}_sc{1}-seg{2}-i{3}-dm{4}-dt{5}.pkl'.format(d['fileroot'], scan, segment, candint, dmind, dtind)\n\n                if any([candsnr > snr for candsnr in candprops[:, snrcol]]):\n                    logger.info('Cand {0} had SNR {1} and refinement found a higher SNR in new ones: {2}.'.format(i, snr, candprops[:, snrcol]))\n                    logger.info('Saving to {0}: {1}'.format(candfile, cands))\n\n                    with open(candfile, 'w') as pkl:\n                        pickle.dump(d, pkl, protocol=2)\n                        pickle.dump((candlocs, candprops), pkl, protocol=2)\n                else:\n                    logger.info('Cand {0} had SNR {1}, but refinement found no improvement: {2}'.format(i, snr, candprops[:, snrcol]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a candidate plot from original data.", "response": "def make_cand_plot(d, im, data, loclabel, version=2, snrs=[], outname=''):\n    \"\"\" Builds a new candidate plot, distinct from the original plots produced by make_cand_plot.\n    Expects phased, dedispersed data (cut out in time, dual-pol), image, and metadata\n\n    version 2 is the new one (thanks to bridget andersen). version 1 is the initial one.\n    loclabel is used to label the plot with (scan, segment, candint, dmind, dtind, beamnum).\n    snrs is array for an (optional) SNR histogram plot.\n    d are used to label the plots with useful information.\n    \"\"\"\n\n    # given d, im, data, make plot\n    logger.info('Plotting...')\n    logger.debug('(image, data) shape: (%s, %s)' % (str(im.shape), str(data.shape)))\n\n    assert len(loclabel) == 6, 'loclabel should have (scan, segment, candint, dmind, dtind, beamnum)'\n    scan, segment, candint, dmind, dtind, beamnum = loclabel\n\n    # calc source location\n    snrmin = im.min()/im.std()\n    snrmax = im.max()/im.std()\n    if snrmax > -1*snrmin:\n        l1, m1 = rt.calc_lm(d, im, minmax='max')\n        snrobs = snrmax\n    else:\n        l1, m1 = rt.calc_lm(d, im, minmax='min')\n        snrobs = snrmin\n    pt_ra, pt_dec = d['radec']\n    src_ra, src_dec = source_location(pt_ra, pt_dec, l1, m1)\n    logger.info('Peak (RA, Dec): %s, %s' % (src_ra, src_dec))\n\n    # convert l1 and m1 from radians to arcminutes\n    l1arcm = l1*180.*60./np.pi\n    m1arcm = m1*180.*60./np.pi\n\n    if version == 1:\n        # build plot\n        fig = plt.Figure(figsize=(8.5,8))\n        ax = fig.add_subplot(221, axisbg='white')\n\n        # add annotating info\n        ax.text(0.1, 0.9, d['fileroot'], fontname='sans-serif', transform = ax.transAxes)\n        ax.text(0.1, 0.8, 'sc %d, seg %d, int %d, DM %.1f, dt %d' % (scan, segment, candint, d['dmarr'][dmind], d['dtarr'][dtind]), fontname='sans-serif', transform = ax.transAxes)\n        ax.text(0.1, 0.7, 'Peak: (' + str(np.round(l1, 3)) + ' ,' + str(np.round(m1, 3)) + '), SNR: ' + str(np.round(snrobs, 1)), fontname='sans-serif', transform = ax.transAxes)\n\n        # plot dynamic spectra\n        left, width = 0.6, 0.2\n        bottom, height = 0.2, 0.7\n        rect_dynsp = [left, bottom, width, height]\n        rect_lc = [left, bottom-0.1, width, 0.1]    \n        rect_sp = [left+width, bottom, 0.1, height]\n        ax_dynsp = fig.add_axes(rect_dynsp)\n        ax_lc = fig.add_axes(rect_lc)    \n        ax_sp = fig.add_axes(rect_sp)\n        spectra = np.swapaxes(data.real,0,1)      # seems that latest pickle actually contains complex values in spectra...\n        dd = np.concatenate( (spectra[...,0], np.zeros_like(spectra[...,0]), spectra[...,1]), axis=1)    # make array for display with white space between two pols\n        logger.debug('{0}'.format(dd.shape))\n        impl = ax_dynsp.imshow(dd, origin='lower', interpolation='nearest', aspect='auto', cmap=plt.get_cmap('Greys'))\n        ax_dynsp.text(0.5, 0.95, 'RR LL', horizontalalignment='center', verticalalignment='center', fontsize=16, color='w', transform = ax_dynsp.transAxes)\n        ax_dynsp.set_yticks(range(0,len(d['freq']),30))\n        ax_dynsp.set_yticklabels(d['freq'][::30])\n        ax_dynsp.set_ylabel('Freq (GHz)')\n        ax_dynsp.set_xlabel('Integration (rel)')\n        spectrum = spectra[:,len(spectra[0])/2].mean(axis=1)      # assume pulse in middle bin. get stokes I spectrum. **this is wrong in a minority of cases.**\n        ax_sp.plot(spectrum, range(len(spectrum)), 'k.')\n        ax_sp.plot(np.zeros(len(spectrum)), range(len(spectrum)), 'k:')\n        ax_sp.set_ylim(0, len(spectrum))\n        ax_sp.set_yticklabels([])\n        xmin,xmax = ax_sp.get_xlim()\n        ax_sp.set_xticks(np.linspace(xmin,xmax,3).round(2))\n        ax_sp.set_xlabel('Flux (Jy)')\n        lc = dd.mean(axis=0)\n        lenlc = len(data)  # old (stupid) way: lenlc = np.where(lc == 0)[0][0]\n        ax_lc.plot(range(0,lenlc)+range(2*lenlc,3*lenlc), list(lc)[:lenlc] + list(lc)[-lenlc:], 'k.')\n        ax_lc.plot(range(0,lenlc)+range(2*lenlc,3*lenlc), list(np.zeros(lenlc)) + list(np.zeros(lenlc)), 'k:')\n        ax_lc.set_xlabel('Integration')\n        ax_lc.set_ylabel('Flux (Jy)')\n        ax_lc.set_xticks([0,0.5*lenlc,lenlc,1.5*lenlc,2*lenlc,2.5*lenlc,3*lenlc])\n        ax_lc.set_xticklabels(['0',str(lenlc/2),str(lenlc),'','0',str(lenlc/2),str(lenlc)])\n        ymin,ymax = ax_lc.get_ylim()\n        ax_lc.set_yticks(np.linspace(ymin,ymax,3).round(2))\n\n        # image\n        ax = fig.add_subplot(223)\n        fov = np.degrees(1./d['uvres'])*60.\n        logger.debug('{0}'.format(im.shape))\n        impl = ax.imshow(im.transpose(), aspect='equal', origin='upper',\n                         interpolation='nearest', extent=[fov/2, -fov/2, -fov/2, fov/2],\n                         cmap=plt.get_cmap('Greys'), vmin=0, vmax=0.5*im.max())\n        ax.set_xlabel('RA Offset (arcmin)')\n        ax.set_ylabel('Dec Offset (arcmin)')\n\n    elif version == 2:\n        # build overall plot\n        fig = plt.Figure(figsize=(12.75,8))\n    \n        # add metadata in subfigure\n        ax = fig.add_subplot(2,3,1, axisbg='white')   \n    \n        # calculate the overall dispersion delay: dd\n        f1 = d['freq_orig'][0]\n        f2 = d['freq_orig'][len(d['freq_orig'])-1]\n        dd = 4.15*d['dmarr'][dmind]*(f1**(-2)-f2**(-2))\n\n        # add annotating info\n        start = 1.1 # these values determine the spacing and location of the annotating information\n        space = 0.07\n        left = 0.0\n        ax.text(left, start, d['fileroot'], fontname='sans-serif', transform = ax.transAxes, fontsize='small')\n        ax.text(left, start-space, 'Peak (arcmin): (' + str(np.round(l1arcm, 3)) + ', ' + str(np.round(m1arcm, 3)) + ')', fontname='sans-serif', transform = ax.transAxes, fontsize='small')\n        # split the RA and Dec and display in a nice format\n        ra = src_ra.split()\n        dec = src_dec.split()\n        ax.text(left, start-2*space, 'Peak (RA, Dec): (' + ra[0] + ':' + ra[1] + ':' + ra[2][0:4] + ', ' + dec[0] + ':' + dec[1] + ':' + dec[2][0:4]  + ')', \n                fontname='sans-serif', transform = ax.transAxes, fontsize='small')\n        ax.text(left, start-3*space, 'Source: ' + str(d['source']), fontname='sans-serif', transform = ax.transAxes, fontsize='small')\n        ax.text(left, start-4*space, 'scan: ' + str(scan), fontname='sans-serif', transform = ax.transAxes, fontsize='small')\n        ax.text(left, start-5*space, 'segment: ' + str(segment), fontname='sans-serif', transform = ax.transAxes, fontsize='small')\n        ax.text(left, start-6*space, 'integration: ' + str(candint), fontname='sans-serif', transform = ax.transAxes, fontsize='small')\n        ax.text(left, start-7*space, 'DM = ' + str(d['dmarr'][dmind]) + ' (index ' + str(dmind) + ')', fontname='sans-serif', transform = ax.transAxes, fontsize='small')\n        ax.text(left, start-8*space, 'dt = ' + str(np.round(d['inttime']*d['dtarr'][dtind], 3)*1e3) + ' ms' + ' (index ' + str(dtind) + ')', fontname='sans-serif', transform = ax.transAxes, fontsize='small')\n        ax.text(left, start-9*space, 'disp delay = ' + str(np.round(dd,1)) + ' ms', fontname='sans-serif', transform = ax.transAxes, fontsize='small')\n        ax.text(left, start-10*space, 'SNR: ' + str(np.round(snrobs, 1)), fontname='sans-serif', transform = ax.transAxes, fontsize='small')\n        # set the plot invisible so that it doesn't interfere with annotations\n        ax.get_xaxis().set_visible(False)\n        ax.get_yaxis().set_visible(False)\n        ax.spines['bottom'].set_color('white')\n        ax.spines['top'].set_color('white') \n        ax.spines['right'].set_color('white')\n        ax.spines['left'].set_color('white')    \n\n        # plot full dynamic spectra\n        left, width = 0.75, 0.2*2./3.\n        bottom, height = 0.2, 0.7\n        rect_dynsp1 = [left, bottom, width/3., height] # three rectangles for each panel of the spectrum (RR, RR+LL, LL)\n        rect_dynsp2 = [left+width/3., bottom, width/3., height]\n        rect_dynsp3 = [left+2.*width/3., bottom, width/3., height]\n        rect_lc1 = [left, bottom-0.1, width/3., 0.1] \n        rect_lc2 = [left+width/3., bottom-0.1, width/3., 0.1]\n        rect_lc3 = [left+2.*width/3., bottom-0.1, width/3., 0.1]\n        rect_sp = [left+width, bottom, 0.1*2./3., height]\n        ax_dynsp1 = fig.add_axes(rect_dynsp1)\n        ax_dynsp2 = fig.add_axes(rect_dynsp2, sharey=ax_dynsp1) # sharey so that axes line up\n        ax_dynsp3 = fig.add_axes(rect_dynsp3, sharey=ax_dynsp1)\n        # make RR+LL and LL dynamic spectra y labels invisible so they don't interfere with the plots\n        [label.set_visible(False) for label in ax_dynsp2.get_yticklabels()]\n        [label.set_visible(False) for label in ax_dynsp3.get_yticklabels()]\n        ax_sp = fig.add_axes(rect_sp, sharey=ax_dynsp3)\n        [label.set_visible(False) for label in ax_sp.get_yticklabels()]\n        ax_lc1 = fig.add_axes(rect_lc1)\n        ax_lc2 = fig.add_axes(rect_lc2, sharey=ax_lc1)\n        ax_lc3 = fig.add_axes(rect_lc3, sharey=ax_lc1)\n        [label.set_visible(False) for label in ax_lc2.get_yticklabels()]\n        [label.set_visible(False) for label in ax_lc3.get_yticklabels()]\n    \n        # now actually plot the data\n        spectra = np.swapaxes(data.real,0,1)     \n        dd1 = spectra[...,0]\n        dd2 = spectra[...,0] + spectra[...,1]\n        dd3 = spectra[...,1]\n        colormap = 'viridis'\n        logger.debug('{0}'.format(dd1.shape))\n        logger.debug('{0}'.format(dd2.shape))\n        logger.debug('{0}'.format(dd3.shape))\n        impl1 = ax_dynsp1.imshow(dd1, origin='lower', interpolation='nearest', aspect='auto', cmap=plt.get_cmap(colormap))\n        impl2 = ax_dynsp2.imshow(dd2, origin='lower', interpolation='nearest', aspect='auto', cmap=plt.get_cmap(colormap))\n        impl3 = ax_dynsp3.imshow(dd3, origin='lower', interpolation='nearest', aspect='auto', cmap=plt.get_cmap(colormap))\n        ax_dynsp1.set_yticks(range(0,len(d['freq']),30))\n        ax_dynsp1.set_yticklabels(d['freq'][::30])\n        ax_dynsp1.set_ylabel('Freq (GHz)')\n        ax_dynsp1.set_xlabel('RR')\n        ax_dynsp1.xaxis.set_label_position('top')\n        ax_dynsp2.set_xlabel('RR+LL')\n        ax_dynsp2.xaxis.set_label_position('top')\n        ax_dynsp3.set_xlabel('LL')\n        ax_dynsp3.xaxis.set_label_position('top')\n        [label.set_visible(False) for label in ax_dynsp1.get_xticklabels()] # set xlabels invisible so that they don't interefere with lc plots\n        ax_dynsp1.get_yticklabels()[0].set_visible(False) # This one y label was getting in the way\n    \n        # plot stokes I spectrum of the candidate pulse (assume middle bin)\n        spectrum = spectra[:,len(spectra[0])/2].mean(axis=1) # select stokes I middle bin\n        ax_sp.plot(spectrum, range(len(spectrum)), 'k.')\n        ax_sp.plot(np.zeros(len(spectrum)), range(len(spectrum)), 'r:') # plot 0 Jy dotted line\n        xmin,xmax = ax_sp.get_xlim()\n        ax_sp.set_xticks(np.linspace(xmin,xmax,3).round(2))\n        ax_sp.set_xlabel('Flux (Jy)')    \n\n        # plot mean flux values for each time bin\n        lc1 = dd1.mean(axis=0)\n        lc2 = dd2.mean(axis=0)\n        lc3 = dd3.mean(axis=0)\n        lenlc = len(data)\n        ax_lc1.plot(range(0,lenlc), list(lc1)[:lenlc], 'k.')\n        ax_lc2.plot(range(0,lenlc), list(lc2)[:lenlc], 'k.')\n        ax_lc3.plot(range(0,lenlc), list(lc3)[:lenlc], 'k.')\n        ax_lc1.plot(range(0,lenlc), list(np.zeros(lenlc)), 'r:') # plot 0 Jy dotted line for each plot\n        ax_lc2.plot(range(0,lenlc), list(np.zeros(lenlc)), 'r:')\n        ax_lc3.plot(range(0,lenlc), list(np.zeros(lenlc)), 'r:')    \n        ax_lc2.set_xlabel('Integration (rel)')\n        ax_lc1.set_ylabel('Flux (Jy)')\n        ax_lc1.set_xticks([0, 0.5*lenlc, lenlc])\n        ax_lc1.set_xticklabels(['0', str(lenlc/2), str(lenlc)]) # note I chose to only show the '0' label for one of the plots to avoid messy overlap\n        ax_lc2.set_xticks([0, 0.5*lenlc, lenlc])\n        ax_lc2.set_xticklabels(['', str(lenlc/2), str(lenlc)])\n        ax_lc3.set_xticks([0, 0.5*lenlc, lenlc])\n        ax_lc3.set_xticklabels(['', str(lenlc/2), str(lenlc)])\n        ymin,ymax = ax_lc1.get_ylim()\n        ax_lc1.set_yticks(np.linspace(ymin,ymax,3).round(2))\n\n        # readjust the x tick marks on the dynamic spectra so that they line up with the lc plots\n        ax_dynsp1.set_xticks([0, 0.5*lenlc, lenlc])\n        ax_dynsp2.set_xticks([0, 0.5*lenlc, lenlc])\n        ax_dynsp3.set_xticks([0, 0.5*lenlc, lenlc])\n\n        # plot second set of dynamic spectra (averaged across frequency bins to get SNR=2 for the detected candidate)\n        left, width = 0.45, 0.1333\n        bottom, height = 0.1, 0.4\n        rect_dynsp1 = [left, bottom, width/3., height]\n        rect_dynsp2 = [left+width/3., bottom, width/3., height]\n        rect_dynsp3 = [left+2.*width/3., bottom, width/3., height]\n        rect_sp = [left+width, bottom, 0.1*2./3., height]\n        ax_dynsp1 = fig.add_axes(rect_dynsp1)\n        ax_dynsp2 = fig.add_axes(rect_dynsp2, sharey=ax_dynsp1)\n        ax_dynsp3 = fig.add_axes(rect_dynsp3, sharey=ax_dynsp1)\n        # make RR+LL and LL dynamic spectra y labels invisible so they don't interfere with the plots\n        [label.set_visible(False) for label in ax_dynsp2.get_yticklabels()]\n        [label.set_visible(False) for label in ax_dynsp3.get_yticklabels()]\n        ax_sp = fig.add_axes(rect_sp, sharey=ax_dynsp3)\n        [label.set_visible(False) for label in ax_sp.get_yticklabels()]\n\n        # calculate the number of frequency rows to average together (make the plot have an SNR of 2)\n        n = int((2.*(len(spectra))**0.5/snrobs)**2)\n        if n == 0: # if n==0 then don't average any (avoids errors for modding and dividing by 0)\n            dd1avg = dd1\n            dd3avg = dd3\n        else:\n            # otherwise, add zeros onto the data so that it's length is cleanly divisible by n (makes it easier to average over)\n            dd1zerotemp = np.concatenate((np.zeros((n-len(spectra)%n, len(spectra[0])), dtype=dd1.dtype), dd1), axis=0)\n            dd3zerotemp = np.concatenate((np.zeros((n-len(spectra)%n, len(spectra[0])), dtype=dd3.dtype), dd3), axis=0)\n            # make them masked arrays so that the appended zeros do not affect average calculation\n            zeros = np.zeros((len(dd1), len(dd1[0])))\n            ones = np.ones((n-len(spectra)%n, len(dd1[0])))\n            masktemp = np.concatenate((ones, zeros), axis=0)\n            dd1zero = ma.masked_array(dd1zerotemp, mask=masktemp)\n            dd3zero = ma.masked_array(dd3zerotemp, mask=masktemp)\n            # average together the data\n            dd1avg = np.array([], dtype=dd1.dtype)\n            for i in range(len(spectra[0])):\n                temp = dd1zero[:,i].reshape(-1,n)\n                tempavg = np.reshape(np.mean(temp, axis=1),(len(temp),1))\n                temprep = np.repeat(tempavg, n, axis=0) # repeats the mean values to create more pixels (easier to properly crop when it is finally displayed)\n                if i == 0:\n                    dd1avg = temprep\n                else:\n                    dd1avg = np.concatenate((dd1avg, temprep), axis=1)\n            dd3avg = np.array([], dtype=dd3.dtype)\n            for i in range(len(spectra[0])):\n                temp = dd3zero[:,i].reshape(-1,n)\n                tempavg = np.reshape(np.mean(temp, axis=1),(len(temp),1))\n                temprep = np.repeat(tempavg, n, axis=0)\n                if i == 0:\n                    dd3avg = temprep\n                else:\n                    dd3avg = np.concatenate((dd3avg, temprep), axis=1)\n        dd2avg = dd1avg + dd3avg # add together to get averaged RR+LL spectrum\n        colormap = 'viridis'\n        if n == 0: # again, if n==0 then don't crop the spectra because no zeroes were appended\n            dd1avgcrop = dd1avg\n            dd2avgcrop = dd2avg\n            dd3avgcrop = dd3avg\n        else: # otherwise, crop off the appended zeroes\n            dd1avgcrop = dd1avg[len(ones):len(dd1avg),:]\n            dd2avgcrop = dd2avg[len(ones):len(dd2avg),:]\n            dd3avgcrop = dd3avg[len(ones):len(dd3avg),:]\n        logger.debug('{0}'.format(dd1avgcrop.shape))\n        logger.debug('{0}'.format(dd2avgcrop.shape))\n        logger.debug('{0}'.format(dd3avgcrop.shape))\n        impl1 = ax_dynsp1.imshow(dd1avgcrop, origin='lower', interpolation='nearest', aspect='auto', cmap=plt.get_cmap(colormap))\n        impl2 = ax_dynsp2.imshow(dd2avgcrop, origin='lower', interpolation='nearest', aspect='auto', cmap=plt.get_cmap(colormap))\n        impl3 = ax_dynsp3.imshow(dd3avgcrop, origin='lower', interpolation='nearest', aspect='auto', cmap=plt.get_cmap(colormap))\n        ax_dynsp1.set_yticks(range(0,len(d['freq']), 30))\n        ax_dynsp1.set_yticklabels(d['freq'][::30])\n        ax_dynsp1.set_ylabel('Freq (GHz)')\n        ax_dynsp1.set_xlabel('RR')\n        ax_dynsp1.xaxis.set_label_position('top')\n        ax_dynsp2.set_xlabel('Integration (rel)')\n        ax2 = ax_dynsp2.twiny()\n        ax2.set_xlabel('RR+LL')\n        [label.set_visible(False) for label in ax2.get_xticklabels()]\n        ax_dynsp3.set_xlabel('LL')\n        ax_dynsp3.xaxis.set_label_position('top')\n    \n        # plot stokes I spectrum of the candidate pulse in the averaged data (assume middle bin)\n        ax_sp.plot(dd2avgcrop[:,len(dd2avgcrop[0])/2]/2., range(len(dd2avgcrop)), 'k.')\n        ax_sp.plot(np.zeros(len(dd2avgcrop)), range(len(dd2avgcrop)), 'r:')\n        xmin,xmax = ax_sp.get_xlim()\n        ax_sp.set_xticks(np.linspace(xmin,xmax,3).round(2))\n        ax_sp.get_xticklabels()[0].set_visible(False)\n        ax_sp.set_xlabel('Flux (Jy)')    \n\n        # readjust the x tick marks on the dynamic spectra\n        ax_dynsp1.set_xticks([0, 0.5*lenlc, lenlc])\n        ax_dynsp1.set_xticklabels(['0', str(lenlc/2), str(lenlc)])\n        ax_dynsp2.set_xticks([0, 0.5*lenlc, lenlc])\n        ax_dynsp2.set_xticklabels(['', str(lenlc/2), str(lenlc)])\n        ax_dynsp3.set_xticks([0, 0.5*lenlc, lenlc])\n        ax_dynsp3.set_xticklabels(['', str(lenlc/2), str(lenlc)])\n\n        # plot the image and zoomed cutout\n        ax = fig.add_subplot(2,3,4)\n        fov = np.degrees(1./d['uvres'])*60.\n        impl = ax.imshow(im.transpose(), aspect='equal', origin='upper',\n                         interpolation='nearest', extent=[fov/2, -fov/2, -fov/2, fov/2],\n                         cmap=plt.get_cmap('viridis'), vmin=0, vmax=0.5*im.max())\n        ax.set_xlabel('RA Offset (arcmin)')\n        ax.set_ylabel('Dec Offset (arcmin)')\n        ax.autoscale(False) # to stop the plot from autoscaling when we plot the triangles that label the location\n        # add markers on the axes to indicate the measured position of the candidate\n        ax.scatter(x=[l1arcm], y=[-fov/2], c='#ffff00', s=60, marker='^', clip_on=False)\n        ax.scatter(x=[fov/2], y=[m1arcm], c='#ffff00', s=60, marker='>', clip_on=False)\n        ax.set_frame_on(False) # makes it so the axis does not intersect the location triangles (for cosmetic reasons)\n    \n        # add a zoomed cutout image of the candidate (set width at 5*synthesized beam)\n        key = d['vrange'].keys()[0]\n        umax = d['urange'][key]\n        vmax = d['vrange'][key]\n        uvdist = (umax**2+vmax**2)**0.5\n        sbeam = np.degrees(d['uvoversample']/uvdist)*60. # calculate synthesized beam in arcminutes\n        # figure out the location to center the zoomed image on\n        xratio = len(im[0])/fov # pix/arcmin\n        yratio = len(im)/fov # pix/arcmin\n        mult = 5 # sets how many times the synthesized beam the zoomed FOV is\n        xmin = max(0, int(len(im[0])/2-(m1arcm+sbeam*mult)*xratio))\n        xmax = int(len(im[0])/2-(m1arcm-sbeam*mult)*xratio)\n        ymin = max(0, int(len(im)/2-(l1arcm+sbeam*mult)*yratio))\n        ymax = int(len(im)/2-(l1arcm-sbeam*mult)*yratio)\n        left, width = 0.231, 0.15\n        bottom, height = 0.465, 0.15\n        rect_imcrop = [left, bottom, width, height]\n        ax_imcrop = fig.add_axes(rect_imcrop)\n        logger.debug('{0}'.format(im.transpose()[xmin:xmax,ymin:ymax].shape))\n        logger.debug('{0} {1} {2} {3}'.format(xmin, xmax, ymin, ymax))\n        impl = ax_imcrop.imshow(im.transpose()[xmin:xmax,ymin:ymax], aspect=1, origin='upper',\n                                interpolation='nearest', extent=[-1,1,-1,1],\n                                cmap=plt.get_cmap('viridis'), vmin=0, vmax=0.5*im.max())\n        # setup the axes\n        ax_imcrop.set_ylabel('Dec (arcmin)')\n        ax_imcrop.set_xlabel('RA (arcmin)')\n        ax_imcrop.xaxis.set_label_position('top')\n        ax_imcrop.xaxis.tick_top()\n        xlabels = [str(np.round(l1arcm+sbeam*mult/2, 1)), '', str(np.round(l1arcm, 1)), '', str(np.round(l1arcm-sbeam*mult/2, 1))]\n        ylabels = [str(np.round(m1arcm-sbeam*mult/2, 1)), '', str(np.round(m1arcm, 1)), '', str(np.round(m1arcm+sbeam*mult/2, 1))]\n        ax_imcrop.set_xticklabels(xlabels)\n        ax_imcrop.set_yticklabels(ylabels)\n        # change axis label location of inset so it doesn't interfere with the full picture\n        ax_imcrop.get_yticklabels()[0].set_verticalalignment('bottom')\n\n        # create SNR versus N histogram for the whole observation (properties for each candidate in the observation given by prop)\n        if len(snrs):\n            left, width = 0.45, 0.2\n            bottom, height = 0.6, 0.3\n            rect_snr = [left, bottom, width, height]\n            ax_snr = fig.add_axes(rect_snr)\n            pos_snrs = snrs[snrs >= 0]\n            neg_snrs = snrs[snrs < 0]\n            if not len(neg_snrs):  # if working with subset and only positive snrs\n                neg_snrs = pos_snrs\n                nonegs = True\n            else:\n                nonegs = False\n            minval = 5.5\n            maxval = 8.0\n            # determine the min and max values of the x axis\n            if min(pos_snrs) < min(np.abs(neg_snrs)):\n                minval = min(pos_snrs)\n            else:\n                minval = min(np.abs(neg_snrs))\n            if max(pos_snrs) > max(np.abs(neg_snrs)):\n                maxval = max(pos_snrs)\n            else:\n                maxval = max(np.abs(neg_snrs))\n\n            # positive SNR bins are in blue\n            # absolute values of negative SNR bins are taken and plotted as red x's on top of positive blue bins for compactness\n            n, b, patches = ax_snr.hist(pos_snrs, 50, (minval,maxval), facecolor='blue', zorder=1)\n            vals, bin_edges = np.histogram(np.abs(neg_snrs), 50, (minval,maxval))\n            bins = np.array([(bin_edges[i]+bin_edges[i+1])/2. for i in range(len(vals))])\n            vals = np.array(vals)\n            if not nonegs:\n                ax_snr.scatter(bins[vals > 0], vals[vals > 0], marker='x', c='orangered', alpha=1.0, zorder=2)\n            ax_snr.set_xlabel('SNR')\n            ax_snr.set_xlim(left=minval-0.2)\n            ax_snr.set_xlim(right=maxval+0.2)\n            ax_snr.set_ylabel('N')\n            ax_snr.set_yscale('log')\n            # draw vertical line where the candidate SNR is\n            ax_snr.axvline(x=np.abs(snrobs), linewidth=1, color='y', alpha=0.7)\n\n    else:\n        logger.warn('make_cand_plot version not recognized.')\n\n    if not outname:\n        outname = os.path.join(d['workdir'],\n                               'cands_{}_sc{}-seg{}-i{}-dm{}-dt{}.png'.format(d['fileroot'], scan,\n                                                                              segment, candint, dmind, dtind))\n\n    try:\n        canvas = FigureCanvasAgg(fig)\n        canvas.print_figure(outname)\n    except ValueError:\n        logger.warn('Could not write figure to %s' % outname)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking phase center and source l in radians to get ra dec of source. Returns string", "response": "def source_location(pt_ra, pt_dec, l1, m1):\n    \"\"\" Takes phase center and src l,m in radians to get ra,dec of source.\n    Returns string ('hh mm ss', 'dd mm ss')\n    \"\"\"\n    import math\n\n    srcra = np.degrees(pt_ra + l1/math.cos(pt_dec))\n    srcdec = np.degrees(pt_dec + m1)\n\n    return deg2HMS(srcra, srcdec)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef guess_wxr_version(self, tree):\n        for v in ('1.2', '1.1', '1.0'):\n            try:\n                tree.find('channel/{%s}wxr_version' % (WP_NS % v)).text\n                return v\n            except AttributeError:\n                pass\n        raise CommandError('Cannot resolve the wordpress namespace')", "response": "Try to guess the wxr version used by the wordpress xml namespace name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving all the authors used in posts and convert them to new or existing author and return the conversion.", "response": "def import_authors(self, tree):\n        \"\"\"\n        Retrieve all the authors used in posts\n        and convert it to new or existing author and\n        return the conversion.\n        \"\"\"\n        self.write_out(self.style.STEP('- Importing authors\\n'))\n\n        post_authors = set()\n        for item in tree.findall('channel/item'):\n            post_type = item.find('{%s}post_type' % WP_NS).text\n            if post_type == 'post':\n                post_authors.add(item.find(\n                    '{http://purl.org/dc/elements/1.1/}creator').text)\n\n        self.write_out('> %i authors found.\\n' % len(post_authors))\n\n        authors = {}\n        for post_author in post_authors:\n            if self.default_author:\n                authors[post_author] = self.default_author\n            else:\n                authors[post_author] = self.migrate_author(\n                    post_author.replace(' ', '-'))\n        return authors"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle the actions for migrating the authors.", "response": "def migrate_author(self, author_name):\n        \"\"\"\n        Handle actions for migrating the authors.\n        \"\"\"\n        action_text = \"The author '%s' needs to be migrated to an user:\\n\"\\\n                      \"1. Use an existing user ?\\n\"\\\n                      \"2. Create a new user ?\\n\"\\\n                      \"Please select a choice: \" % self.style.ITEM(author_name)\n        while 42:\n            selection = input(smart_str(action_text))\n            if selection and selection in '12':\n                break\n        if selection == '1':\n            users = Author.objects.all()\n            if users.count() == 1:\n                username = users[0].get_username()\n                preselected_user = username\n                usernames = [username]\n                usernames_display = ['[%s]' % username]\n            else:\n                usernames = []\n                usernames_display = []\n                preselected_user = None\n                for user in users:\n                    username = user.get_username()\n                    if username == author_name:\n                        usernames_display.append('[%s]' % username)\n                        preselected_user = username\n                    else:\n                        usernames_display.append(username)\n                    usernames.append(username)\n            while 42:\n                user_text = \"1. Select your user, by typing \" \\\n                            \"one of theses usernames:\\n\"\\\n                            \"%s or 'back'\\n\"\\\n                            \"Please select a choice: \" % \\\n                            ', '.join(usernames_display)\n                user_selected = input(user_text)\n                if user_selected in usernames:\n                    break\n                if user_selected == '' and preselected_user:\n                    user_selected = preselected_user\n                    break\n                if user_selected.strip() == 'back':\n                    return self.migrate_author(author_name)\n            return users.get(**{users[0].USERNAME_FIELD: user_selected})\n        else:\n            create_text = \"2. Please type the email of \" \\\n                          \"the '%s' user or 'back': \" % author_name\n            author_mail = input(create_text)\n            if author_mail.strip() == 'back':\n                return self.migrate_author(author_name)\n            try:\n                return Author.objects.create_user(author_name, author_mail)\n            except IntegrityError:\n                return Author.objects.get(\n                    **{Author.USERNAME_FIELD: author_name})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef import_categories(self, category_nodes):\n        self.write_out(self.style.STEP('- Importing categories\\n'))\n\n        categories = {}\n        for category_node in category_nodes:\n            title = category_node.find('{%s}cat_name' % WP_NS).text[:255]\n            slug = category_node.find(\n                '{%s}category_nicename' % WP_NS).text[:255]\n            try:\n                parent = category_node.find(\n                    '{%s}category_parent' % WP_NS).text[:255]\n            except TypeError:\n                parent = None\n            self.write_out('> %s... ' % title)\n            category, created = Category.objects.get_or_create(\n                slug=slug, defaults={'title': title,\n                                     'parent': categories.get(parent)})\n            categories[title] = category\n            self.write_out(self.style.ITEM('OK\\n'))\n        return categories", "response": "Imports all the categories from the given category nodes and returns a dict for the database optimizations."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nimports all the tags in item nodes into a Tag object.", "response": "def import_tags(self, tag_nodes):\n        \"\"\"\n        Import all the tags form 'wp:tag' nodes,\n        because tags in 'item' nodes are not necessarily\n        all the tags, then use only the nicename, because it's like\n        a slug and the true tag name may be not valid for url usage.\n        \"\"\"\n        self.write_out(self.style.STEP('- Importing tags\\n'))\n        for tag_node in tag_nodes:\n            tag_name = tag_node.find(\n                '{%s}tag_slug' % WP_NS).text[:50]\n            self.write_out('> %s... ' % tag_name)\n            Tag.objects.get_or_create(name=tag_name)\n            self.write_out(self.style.ITEM('OK\\n'))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of entry s tags by using the nicename for url compatibility.", "response": "def get_entry_tags(self, categories):\n        \"\"\"\n        Return a list of entry's tags,\n        by using the nicename for url compatibility.\n        \"\"\"\n        tags = []\n        for category in categories:\n            domain = category.attrib.get('domain', 'category')\n            if 'tag' in domain and category.attrib.get('nicename'):\n                tags.append(category.attrib.get('nicename'))\n        return tags"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_entry_categories(self, category_nodes):\n        categories = []\n        for category_node in category_nodes:\n            domain = category_node.attrib.get('domain')\n            if domain == 'category':\n                categories.append(self.categories[category_node.text])\n        return categories", "response": "Return a list of entry s categories based on imported categories."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nimport an entry from the item node.", "response": "def import_entry(self, title, content, item_node):\n        \"\"\"\n        Importing an entry but some data are missing like\n        related entries, start_publication and end_publication.\n        start_publication and creation_date will use the same value,\n        wich is always in Wordpress $post->post_date.\n        \"\"\"\n        try:\n            creation_date = datetime.strptime(\n                item_node.find('{%s}post_date_gmt' % WP_NS).text,\n                '%Y-%m-%d %H:%M:%S')\n        except ValueError as error:\n            print 'Import entry error: {}'.format(error)\n\n            creation_date = datetime.now()\n\n        if settings.USE_TZ:\n            creation_date = timezone.make_aware(\n                creation_date, pytz.timezone('GMT'))\n\n        excerpt = strip_tags(item_node.find(\n            '{%sexcerpt/}encoded' % WP_NS).text or '')\n        if not excerpt:\n            if self.auto_excerpt:\n                excerpt = Truncator(strip_tags(content)).words(50)\n            else:\n                excerpt = ''\n\n        # Prefer use this function than\n        # item_node.find('{%s}post_name' % WP_NS).text\n        # Because slug can be not well formated\n        slug = slugify(title)[:255] or 'post-%s' % item_node.find(\n            '{%s}post_id' % WP_NS).text\n\n        entry_dict = {\n            'title': title,\n            'content': content,\n            'excerpt': excerpt,\n            'tags': ', '.join(self.get_entry_tags(item_node.findall(\n                'category'))),\n            'status': self.REVERSE_STATUS[item_node.find(\n                '{%s}status' % WP_NS).text],\n            'comment_enabled': item_node.find(\n                '{%s}comment_status' % WP_NS).text == 'open',\n            'pingback_enabled': item_node.find(\n                '{%s}ping_status' % WP_NS).text == 'open',\n            'featured': item_node.find('{%s}is_sticky' % WP_NS).text == '1',\n            'password': item_node.find('{%s}post_password' % WP_NS).text or '',\n            'login_required': item_node.find(\n                '{%s}status' % WP_NS).text == 'private',\n            'last_update': timezone.now()}\n        entry_dict['trackback_enabled'] = entry_dict['pingback_enabled']\n\n        entry, created = Entry.objects.get_or_create(\n            slug=slug, creation_date=creation_date,\n            defaults=entry_dict)\n        if created:\n            try:\n                entry.categories.add(*self.get_entry_categories(\n                    item_node.findall('category')))\n                entry.authors.add(self.authors[item_node.find(\n                    '{http://purl.org/dc/elements/1.1/}creator').text])\n                entry.sites.add(self.SITE)\n            except KeyError as error:\n                print 'Import entry error: {}'.format(error)\n\n        return entry, created"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nimporting the items and images of the items.", "response": "def import_entries(self, items):\n        \"\"\"\n        Loops over items and find entry to import,\n        an entry need to have 'post_type' set to 'post' and\n        have content.\n        \"\"\"\n        self.write_out(self.style.STEP('- Importing entries\\n'))\n\n        for item_node in items:\n            title = (item_node.find('title').text or '')[:255]\n            post_type = item_node.find('{%s}post_type' % WP_NS).text\n            content = item_node.find(\n                '{http://purl.org/rss/1.0/modules/content/}encoded').text\n\n            if post_type == 'post' and content and title:\n                self.write_out('> %s... ' % title)\n                entry, created = self.import_entry(title, content, item_node)\n                if created:\n                    self.write_out(self.style.ITEM('OK\\n'))\n                    image_id = self.find_image_id(\n                        item_node.findall('{%s}postmeta' % WP_NS))\n                    if image_id:\n                        self.import_image(entry, items, image_id)\n                    self.import_comments(entry, item_node.findall(\n                        '{%s}comment' % WP_NS))\n                else:\n                    self.write_out(self.style.NOTICE(\n                        'SKIPPED (already imported)\\n'))\n            else:\n                self.write_out('> %s... ' % title, 2)\n                self.write_out(self.style.NOTICE('SKIPPED (not a post)\\n'), 2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nimport the comments from the given comments nodes and writes the comments to the appropriate django_comments file.", "response": "def import_comments(self, entry, comment_nodes):\n        \"\"\"\n        Loops over comments nodes and import then\n        in django_comments.\n        \"\"\"\n        for comment_node in comment_nodes:\n            is_pingback = comment_node.find(\n                '{%s}comment_type' % WP_NS).text == PINGBACK\n            is_trackback = comment_node.find(\n                '{%s}comment_type' % WP_NS).text == TRACKBACK\n\n            title = 'Comment #%s' % (comment_node.find(\n                '{%s}comment_id' % WP_NS).text)\n            self.write_out(' > %s... ' % title)\n\n            content = comment_node.find(\n                '{%s}comment_content' % WP_NS).text\n            if not content:\n                self.write_out(self.style.NOTICE('SKIPPED (unfilled)\\n'))\n                return\n\n            submit_date = datetime.strptime(\n                comment_node.find('{%s}comment_date_gmt' % WP_NS).text,\n                '%Y-%m-%d %H:%M:%S')\n            if settings.USE_TZ:\n                submit_date = timezone.make_aware(submit_date,\n                                                  pytz.timezone('GMT'))\n\n            approvation = comment_node.find(\n                '{%s}comment_approved' % WP_NS).text\n            is_public = True\n            is_removed = False\n            if approvation != '1':\n                is_removed = True\n            if approvation == 'spam':\n                is_public = False\n\n            comment_dict = {\n                'content_object': entry,\n                'site': self.SITE,\n                'user_name': comment_node.find(\n                    '{%s}comment_author' % WP_NS).text[:50],\n                'user_email': comment_node.find(\n                    '{%s}comment_author_email' % WP_NS).text or '',\n                'user_url': comment_node.find(\n                    '{%s}comment_author_url' % WP_NS).text or '',\n                'comment': content,\n                'submit_date': submit_date,\n                'ip_address': comment_node.find(\n                    '{%s}comment_author_IP' % WP_NS).text or None,\n                'is_public': is_public,\n                'is_removed': is_removed, }\n            comment = comments.get_model()(**comment_dict)\n            comment.save()\n            if is_pingback:\n                comment.flags.create(\n                    user=get_user_flagger(), flag=PINGBACK)\n            if is_trackback:\n                comment.flags.create(\n                    user=get_user_flagger(), flag=TRACKBACK)\n\n            self.write_out(self.style.ITEM('OK\\n'))\n        entry.comment_count = entry.comments.count()\n        entry.pingback_count = entry.pingbacks.count()\n        entry.trackback_count = entry.trackbacks.count()\n        entry.save(force_update=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, k, default=None):\n        '''\n        >>> dd = DiskDict(DATA_FILE)\n        >>> print(dd.get('deepcompute'))\n        1\n        '''\n\n        k = self._enckey(k)\n        v = self._f.get(k, None)\n        if v is None: return default\n        return pickle.loads(v)", "response": "Get a key from the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\niterate over all the items in the cache.", "response": "def items(self):\n        '''\n        >>> dd = DiskDict(DATA_FILE)\n        >>> print(next(dd.items()))\n        ('deepcompute', 1)\n        '''\n\n        for k, v in self._f:\n            yield self._deckey(k), pickle.loads(v)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the gradient of the model for the current parameters.", "response": "def compute_gradient(self, *args, **kwargs):\n        \"\"\"\n        Compute the \"gradient\" of the model for the current parameters\n\n        The default implementation computes the gradients numerically using\n        a first order forward scheme. For better performance, this method\n        should be overloaded by subclasses. The output of this function\n        should be an array where the first dimension is ``full_size``.\n\n        \"\"\"\n        _EPS = 1.254e-5\n        vector = self.get_parameter_vector()\n        value0 = self.get_value(*args, **kwargs)\n        grad = np.empty([len(vector)] + list(value0.shape), dtype=np.float64)\n        for i, v in enumerate(vector):\n            vector[i] = v + _EPS\n            self.set_parameter_vector(vector)\n            value = self.get_value(*args, **kwargs)\n            vector[i] = v\n            self.set_parameter_vector(vector)\n            grad[i] = (value - value0) / _EPS\n        return grad"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrefreshing the instance data from the API.", "response": "def refresh(self):\n      '''Refetch instance data from the API.\n      '''\n      response = requests.get('%s/guides/%s' % (API_BASE_URL, self.id))\n      attributes = response.json()\n      \n      self.category = Category(attributes['category'])\n      self.url = attributes['url']\n      \n      self.title = attributes['title']\n      if attributes['image']:\n         self.image = Image(attributes['image']['id'])\n      else:\n         self.image = None\n      self.locale = attributes['locale']\n      self.introduction = WikiText(attributes['introduction_raw'],\n                                   attributes['introduction_rendered'])\n      self.conclusion = WikiText(attributes['conclusion_raw'],\n                                 attributes['conclusion_rendered'])\n      #self.tools = attributes['tools']\n      #self.parts = attributes['parts']\n      self.subject = attributes['subject']\n      self.modifiedDate = datetime.utcfromtimestamp(attributes['modified_date'])\n      self.createdDate = datetime.utcfromtimestamp(attributes['created_date'])\n      self.publishedDate = datetime.utcfromtimestamp(attributes['published_date'])\n      #self.documents = attributes['documents']\n      author = attributes['author']\n      #self.author = User(author['userid'], name=author['text'])\n      #self.timeRequired = attributes['timeRequired']\n      self.steps = [Step(step['guideid'], step['stepid'], data=step) for step in attributes['steps']]\n      self.type = attributes['type']\n      self.public = attributes['public']\n      self.revision = attributes['revisionid']\n      self.difficulty = attributes['difficulty']\n      self.prerequisites = [Guide(guide['guideid']) for guide in attributes['prerequisites']]\n      #                     attributes['prereq_modified_date']\n      #self.summary = attributes['summary']\n      self.flags = [Flag.from_id(flag['flagid']) for flag in attributes['flags']]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all(guideids=None, filter=None, order=None):\n      '''\n      Fetch all guides.\n      \n      :param iterable guideids: Only return Guides corresponding to these ids.\n      :param string filter: Only return guides of this type.  Choices:\n                            installation, repair, disassembly, teardown,\n                            technique, maintenance.\n      :param string order: Instead of ordering by guideid, order alphabetically.\n                           Choices: ASC, DESC.\n      :rtype: generator of :class:`pyfixit.guide.Guide` objects.\n      '''\n      parameters = []\n      if guideids:\n         parameters.append('guideids=%s' % ','.join(map(str, guideids)))\n      if filter:\n         parameters.append('filter=%s' % filter)\n      if order:\n         parameters.append('order=%s' % order)\n      parameters = '&'.join(parameters)\n      \n      offset = 0\n      limit = 5 # Tune this to balance memory vs. frequent network trips.\n      guideJSONs = []\n      while True:\n         if not guideJSONs:\n            url = '%s/guides?offset=%s&limit=%s&%s' \\\n                  % (API_BASE_URL, offset, limit, parameters)\n            response = requests.get(url)\n            guideJSONs = response.json()\n            # Are we at the end of pagination?\n            if not guideJSONs:\n               return\n            offset += limit\n         yield Guide(guideJSONs.pop(0)['guideid'])", "response": "Returns a generator of all guides corresponding to the given ids."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconnect the instance to redis by checking if the instance exists and if it does not connect to redis.", "response": "def connect(self):\n        \"\"\"\n        Connect the instance to redis by checking the existence of its primary\n        key. Do nothing if already connected.\n        \"\"\"\n        if self.connected:\n            return\n        pk = self._pk\n        if self.exists(pk=pk):\n            self._connected = True\n        else:\n            self._pk = None\n            self._connected = False\n            raise DoesNotExist(\"No %s found with pk %s\" % (self.__class__.__name__, pk))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate an object with a primary key without testing it.", "response": "def lazy_connect(cls, pk):\n        \"\"\"\n        Create an object, setting its primary key without testing it. So the\n        instance is not connected\n        \"\"\"\n        instance = cls()\n        instance._pk = instance.pk.normalize(pk)\n        instance._connected = False\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_class_field(cls, field_name):\n        if not cls.has_field(field_name):\n            raise AttributeError('\"%s\" is not a field for the model \"%s\"' %\n                                 (field_name, cls.__name__))\n\n        field = getattr(cls, '_redis_attr_%s' % field_name)\n\n        return field", "response": "Returns the field object with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_instance_field(self, field_name):\n        if not self.has_field(field_name):\n            raise AttributeError('\"%s\" is not a field for the model \"%s\"' %\n                                 (field_name, self.__class__.__name__))\n\n        field = getattr(self, field_name)\n\n        return field", "response": "Returns the field object with the given name"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the primary key of the instance.", "response": "def _set_pk(self, value):\n        \"\"\"\n        Use the given value as the instance's primary key, if it doesn't have\n        one yet (it must be used only for new instances). Then save default values.\n        \"\"\"\n        if self._pk:\n            raise ImplementationError('Something wrong happened, the PK was already set !')\n        self._pk = value\n        self._connected = True\n        # Default must be set only at first initialization\n        self._set_defaults()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _set_defaults(self):\n        for field_name in self._fields:\n            if field_name in self._init_fields:\n                continue\n            field = self.get_field(field_name)\n            if hasattr(field, \"default\"):\n                field.proxy_set(field.default)", "response": "Set default values to fields."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef exists(cls, **kwargs):\n        if not kwargs:\n            raise ValueError(u\"`Exists` method requires at least one kwarg.\")\n\n        # special case to check for a simple pk\n        if len(kwargs) == 1 and cls._field_is_pk(list(kwargs.keys())[0]):\n            return cls.get_field('pk').exists(list(kwargs.values())[0])\n\n        # get only the first element of the unsorted collection (the fastest)\n        try:\n            cls.collection(**kwargs).sort(by='nosort')[0]\n        except IndexError:\n            return False\n        else:\n            return True", "response": "Check if a record with the values defined by kwargs exists in db?"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(cls, *args, **kwargs):\n        if len(args) == 1:  # Guess it's a pk\n            pk = args[0]\n        elif kwargs:\n            # special case to check for a simple pk\n            if len(kwargs) == 1 and cls._field_is_pk(list(kwargs.keys())[0]):\n                pk = list(kwargs.values())[0]\n            else:  # case with many filters\n                result = cls.collection(**kwargs).sort(by='nosort')\n                if len(result) == 0:\n                    raise DoesNotExist(u\"No object matching filter: %s\" % kwargs)\n                elif len(result) > 1:\n                    raise ValueError(u\"More than one object matching filter: %s\" % kwargs)\n                else:\n                    try:\n                        pk = result[0]\n                    except IndexError:\n                        # object was deleted between the `len` check and now\n                        raise DoesNotExist(u\"No object matching filter: %s\" % kwargs)\n\n        else:\n            raise ValueError(\"Invalid `get` usage with args %s and kwargs %s\" % (args, kwargs))\n        return cls(pk)", "response": "Retrieve one instance from db according to given kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntrying to retrieve an object in db and create it if it doesn t exist.", "response": "def get_or_connect(cls, **kwargs):\n        \"\"\"\n        Try to retrieve an object in db, and create it if it does not exist.\n        \"\"\"\n        try:\n            inst = cls.get(**kwargs)\n            created = False\n        except DoesNotExist:\n            inst = cls(**kwargs)\n            created = True\n        except Exception:\n            raise\n        return inst, created"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hmget(self, *args):\n        if args and not any(arg in self._instancehash_fields for arg in args):\n            raise ValueError(\"Only InstanceHashField can be used here.\")\n\n        return self._call_command('hmget', args)", "response": "This command allows getting many instancehash fields with only\n        one redis call."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hmset(self, **kwargs):\n        if kwargs and not any(kwarg in self._instancehash_fields for kwarg in iterkeys(kwargs)):\n            raise ValueError(\"Only InstanceHashField can be used here.\")\n\n        indexed = []\n\n        # main try block to revert indexes if something fail\n        try:\n\n            # Set indexes for indexable fields.\n            for field_name, value in iteritems(kwargs):\n                field = self.get_field(field_name)\n                if field.indexable:\n                    indexed.append(field)\n                    field.deindex()\n                    field.index(value)\n\n            # Call redis (waits for a dict)\n            result = self._call_command('hmset', kwargs)\n\n            return result\n\n        except:\n            # We revert indexes previously set if we have an exception, then\n            # really raise the error\n            for field in indexed:\n                field._rollback_indexes()\n            raise\n        finally:\n            for field in indexed:\n                field._reset_indexes_caches()", "response": "This command allows setting many instancehash fields with only\n        one redis call."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hdel(self, *args):\n        if args and not any(arg in self._instancehash_fields for arg in args):\n            raise ValueError(\"Only InstanceHashField can be used here.\")\n\n        # Set indexes for indexable fields.\n        for field_name in args:\n            field = self.get_field(field_name)\n            if field.indexable:\n                field.deindex()\n\n        # Return the number of fields really deleted\n        return self._call_command('hdel', *args)", "response": "This command allows deleting many instancehash fields with the same name as the passed hash names."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete(self):\n        # Delete each field\n        for field_name in self._fields:\n            field = self.get_field(field_name)\n            if not isinstance(field, PKField):\n                # pk has no stored key\n                field.delete()\n        # Remove the pk from the model collection\n        self.connection.srem(self.get_field('pk').collection_key, self._pk)\n        # Deactivate the instance\n        delattr(self, \"_pk\")", "response": "Delete the instance from redis storage."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _thread_lock_storage(cls):\n        if not hasattr(threadlocal, 'limpyd_locked_fields'):\n            threadlocal.limpyd_locked_fields = {}\n        if cls._name not in threadlocal.limpyd_locked_fields:\n            threadlocal.limpyd_locked_fields[cls._name] = set()\n        return threadlocal.limpyd_locked_fields[cls._name]", "response": "Internal helper to get the lock storage for a class"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an iterator over all the keys related to the current instance fields.", "response": "def scan_keys(self, count=None):\n        \"\"\"Iter on all the key related to the current instance fields, using redis SCAN command\n\n        Parameters\n        ----------\n        count: int, default to None (redis uses 10)\n            Hint for redis about the number of expected result\n\n        Yields\n        -------\n        str\n            All keys found by the scan, one by one. A key can be returned multiple times, it's\n            related to the way the SCAN command works in redis.\n\n        \"\"\"\n\n        pattern = self.make_key(\n            self._name,\n            self.pk.get(),\n            '*'\n        )\n\n        return self.database.scan_keys(pattern, count)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nscans the model for all the keys related to the current model.", "response": "def scan_model_keys(cls, count=None):\n        \"\"\"Iter on all the key related to the current model, using redis SCAN command\n\n        Parameters\n        ----------\n        count: int, default to None (redis uses 10)\n            Hint for redis about the number of expected result\n\n        Yields\n        -------\n        str\n            All keys found by the scan, one by one. A key can be returned multiple times, it's\n            related to the way the SCAN command works in redis.\n\n        \"\"\"\n\n        pattern = cls.make_key(\n            cls._name,\n            \"*\",\n        )\n\n        return cls.database.scan_keys(pattern, count)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a model name as app_label.ModelName returns the Django model.", "response": "def get_model(model):\n    \"\"\"\n    Given a model name as ``app_label.ModelName``, returns the Django model.\n    \"\"\"\n    try:\n        if isinstance(model, str):\n            app_label, model_name = model.split('.', 1)\n            m = loading.get_model(app_label, model_name)\n            if not m:  # pragma: no cover\n                raise LookupError()  # Django < 1.7 just returns None\n            return m\n        elif issubclass(model, models.Model):\n            return model\n    except (LookupError, ValueError):\n        pass\n    raise ValueError(model)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking that the content types for the given object are valid for this related content type.", "response": "def _validate_ctypes(self, from_obj, to_obj):\n        \"\"\"\n        Asserts that the content types for the given object are valid for this\n        relationship. If validation fails, ``AssertionError`` will be raised.\n        \"\"\"\n        if from_obj:\n            from_ctype = ContentType.objects.get_for_model(from_obj)\n            assert from_ctype.natural_key() == self.from_content_type.natural_key(), (\n                'Relationship \"%s\" does not support connections '\n                'from \"%s\" types' % (self.name, from_ctype))\n        if to_obj:\n            to_ctype = ContentType.objects.get_for_model(to_obj)\n            assert to_ctype.natural_key() == self.to_content_type.natural_key(), (\n                'Relationship \"%s\" does not support connections '\n                'to \"%s\" types' % (self.name, to_ctype))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate and returns a connection between the given objects.", "response": "def create_connection(self, from_obj, to_obj):\n        \"\"\"\n        Creates and returns a connection between the given objects. If a\n        connection already exists, that connection will be returned instead.\n        \"\"\"\n        self._validate_ctypes(from_obj, to_obj)\n        return Connection.objects.get_or_create(relationship_name=self.name,\n                                                from_pk=from_obj.pk, to_pk=to_obj.pk)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_connection(self, from_obj, to_obj):\n        self._validate_ctypes(from_obj, to_obj)\n        try:\n            return self.connections.get(from_pk=from_obj.pk, to_pk=to_obj.pk)\n        except Connection.DoesNotExist:\n            return None", "response": "Returns a Connection instance for the given objects or None if there s no connection."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef connection_exists(self, from_obj, to_obj):\n        self._validate_ctypes(from_obj, to_obj)\n        return self.connections.filter(from_pk=from_obj.pk, to_pk=to_obj.pk).exists()", "response": "Returns True if a connection between the given objects exists False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connections_from_object(self, from_obj):\n        self._validate_ctypes(from_obj, None)\n        return self.connections.filter(from_pk=from_obj.pk)", "response": "Returns a QuerySet containing all connections with the given object as a source."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connections_to_object(self, to_obj):\n        self._validate_ctypes(None, to_obj)\n        return self.connections.filter(to_pk=to_obj.pk)", "response": "Returns a QuerySet containing all connections with the given object as a destination."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a QuerySet of all connected objects with the given object as a source.", "response": "def connected_objects(self, from_obj):\n        \"\"\"\n        Returns a query set matching all connected objects with the given\n        object as a source.\n        \"\"\"\n        return self.to_content_type.get_all_objects_for_this_type(pk__in=self.connected_object_ids(from_obj))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a QuerySet of all connected objects with the given object as a destination.", "response": "def connected_to_objects(self, to_obj):\n        \"\"\"\n        Returns a query set matching all connected objects with the given\n        object as a destination.\n        \"\"\"\n        return self.from_content_type.get_all_objects_for_this_type(pk__in=self.connected_to_object_ids(to_obj))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef distance_between(self, from_obj, to_obj, limit=2):\n        self._validate_ctypes(from_obj, to_obj)\n        \n        if from_obj == to_obj:\n            return 0\n        \n        d = 1\n        pk = to_obj.pk\n        qs = self.connections\n        pks = qs.filter(from_pk=from_obj.pk).values_list('to_pk', flat=True)\n        while limit > 0:\n            if pk in pks:\n                return d\n            else:\n                pks = qs.filter(from_pk__in=pks).values_list('pk', flat=True)\n                d += 1\n                limit -= 1\n        \n        return None", "response": "Calculates the distance between two objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate an MS that contains all calibrator scans with 1 s integration time.", "response": "def genms(self, scans=[]):\n        \"\"\" Generate an MS that contains all calibrator scans with 1 s integration time.\n        \"\"\"\n\n        if len(scans):\n            scanstr = string.join([str(ss) for ss in sorted(scans)], ',')\n        else:\n            scanstr = self.allstr\n\n        print 'Splitting out all cal scans (%s) with 1s int time' % scanstr\n        newname = ps.sdm2ms(self.sdmfile, self.sdmfile.rstrip('/')+'.ms', scanstr, inttime='1')   # integrate down to 1s during split\n\n        return newname"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_fluxinfo(self):\n\n        knowncals = ['3C286', '3C48', '3C147', '3C138']\n\n        # find scans with knowncals in the name\n        sourcenames = [self.sources[source]['source'] for source in self.sources]\n        calsources = [cal for src in sourcenames for cal in knowncals if cal in src]\n        calsources_full = [src for src in sourcenames for cal in knowncals if cal in src]\n        if len(calsources):\n            # if cal found, set band name from first spw\n            self.band = self.sdm['Receiver'][0].frequencyBand.split('_')[1]\n\n            if len(calsources) > 1:\n                print 'Found multiple flux calibrators:', calsources\n            self.fluxname = calsources[0]\n            self.fluxname_full = calsources_full[0]\n            print 'Set flux calibrator to %s and band to %s.' % (self.fluxname_full, self.band)\n        else:\n            self.fluxname = ''\n            self.fluxname_full = ''\n            self.band = ''", "response": "Sets the flux name and band name for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nflag data for a single item in a flagfile or a list of flags.", "response": "def flagdata(self, msfile, flagfile='', flaglist=[]):\n        \"\"\" Use flagfile (first) or flaglist (alternately) to run CASA flagging tool.\n        \"\"\"\n\n        if not flagfile:\n            # write flag data to text file\n            flagfile = os.path.join(self.workdir, 'flags.txt')\n            print 'Writing flaglist to %s.' % flagfile\n\n            if not flaglist:\n                flaglist = [\"mode='unflag'\", \"mode='shadow'\", \"mode='clip' clipzeros=True\",\n                            \"mode='rflag' freqdevscale=4 timedevscale=5\",\n                            \"mode='extend' growaround=True growtime=60 growfreq=40 extendpols=True\",\n                            \"mode='quack' quackinterval=20\", \"mode='summary'\"]\n\n            with open(flagfile, 'w') as flfile:\n                for flag in flags:\n                    flfile.write(flag + '\\n')\n\n        else:\n            print 'Using flags in %s.' % flagfile\n\n        print 'Flagging with these commands:'\n        for ff in enumerate(open(flagfile)): print ff[1].rstrip()\n\n        cfg = tl.FlaglistConfig()  # configure split\n        cfg.vis = msfile\n        cfg.inpfile = flagfile\n        tl.flaglist(cfg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self, refant=[], antsel=[], uvrange='', fluxname='', fluxname_full='', band='', spw0='', spw1='', flaglist=[]):\n\n        os.chdir(self.workdir)\n\n        if not len(refant):\n            refant = self.find_refants()\n\n        antposname = self.fileroot + '.antpos'   # antpos\n        delayname = self.fileroot + '.delay'   # delay cal\n        g0name = self.fileroot + '.g0'   # initial gain correction before bp\n        b1name = self.fileroot + '.b1'   # bandpass file\n        g1name = self.fileroot + '.g1'   # gain cal per scan\n        g2name = self.fileroot + '.g2'   # flux scale applied\n\n        # overload auto detected flux cal info, if desired\n        if fluxname:\n            self.fluxname = fluxname\n        if band:\n            self.band = band\n        if fluxname_full:\n            self.fluxname_full = fluxname\n\n        # if flux calibrator available, use its model\n        if self.fluxname and self.band:\n            if self.band == 'P':\n                calband = 'L'\n            else:\n                calband = self.band\n            fluxmodel = '/home/casa/packages/RHEL5/release/casapy-41.0.24668-001-64b/data/nrao/VLA/CalModels/' + self.fluxname + '_' + calband + '.im'\n        else:\n            fluxmodel = ''\n\n        # set up MS file\n        msfile = self.genms()\n\n        # flag data\n        if flaglist:\n            self.flagdata(msfile, flaglist=flaglist)\n        elif os.path.exists(os.path.join(self.workdir, 'flags.txt')):\n            self.flagdata(msfile, flagfile=os.path.join(self.workdir, 'flags.txt'))\n        else:\n            print 'No flagging.'\n\n        # Calibrate!\n        if fluxmodel:\n            if not os.path.exists(g0name):\n                print 'Applying flux model for BP calibrator...'\n                cfg = tl.SetjyConfig()\n                cfg.vis = msfile\n                cfg.scan = self.bpstr\n                cfg.modimage = fluxmodel\n                cfg.standard = 'Perley-Butler 2010'    # for some reason 2013 standard can't find 3C48\n                tl.setjy(cfg)\n\n                print 'Starting initial gain cal...'\n                cfg = tl.GaincalConfig()\n                cfg.vis = msfile\n                cfg.caltable = g0name\n                cfg.gaintable = []\n                cfg.scan = self.bpstr\n                cfg.gaintype = 'G'\n                cfg.solint = 'inf'\n                cfg.spw = spw0\n                cfg.refant = refant\n                cfg.minsnr = 5.\n                cfg.calmode = 'p'\n                cfg.antenna = antsel\n                cfg.uvrange = uvrange\n                tl.gaincal(cfg)\n            else:\n                print '%s exists' % g0name\n\n            if not os.path.exists(b1name):\n                print 'Starting bp cal...'\n                cfg = tl.GaincalConfig()\n                cfg.vis = msfile\n                cfg.caltable = b1name\n                cfg.gaintable = [g0name]\n                cfg.scan = self.bpstr\n                cfg.spw = spw1\n                cfg.gaintype = 'BPOLY'\n                cfg.degamp = 5\n                cfg.degphase = 2\n                cfg.maskedge = 6\n                cfg.solint = 'inf'\n                cfg.combine = ['scan']\n                cfg.solnorm = True\n                cfg.refant = refant\n                cfg.antenna = antsel\n                cfg.uvrange = uvrange\n                tl.gaincal(cfg)\n            else:\n                print '%s exists' % b1name\n\n            if not os.path.exists(g1name) or not os.path.exists(g2name):\n                print 'Starting gain cal...'\n                cfg = tl.GaincalConfig()\n                cfg.vis = msfile\n                cfg.caltable = g1name\n                cfg.gaintable = [b1name]\n                cfg.scan = self.allstr\n                cfg.gaintype = 'G'\n                cfg.solint = 'inf'\n                cfg.spw = spw1\n                cfg.refant = refant\n                cfg.minsnr = 5.\n                cfg.calmode='ap'\n                cfg.antenna = antsel\n                cfg.uvrange = uvrange\n                tl.gaincal(cfg)\n\n                print 'Transferring flux scale...'\n                cfg = tl.FluxscaleConfig()\n                cfg.vis = msfile\n                cfg.caltable = g1name\n                cfg.fluxtable = g2name\n                cfg.reference = self.fluxname_full\n                tl.fluxscale(cfg)\n            else:\n                print 'either %s or %s exist' % (g1name, g2name)\n\n        else:    # without fluxscale\n            if not os.path.exists(g0name):\n                print 'Starting initial gain cal...'\n                cfg = tl.GaincalConfig()\n                cfg.vis = msfile\n                cfg.caltable = g0name\n                cfg.gaintable = []\n                cfg.scan = self.bpstr\n                cfg.gaintype = 'G'\n                cfg.solint = 'inf'\n                cfg.spw = spw0\n                cfg.refant = refant\n                cfg.minsnr = 5.\n                cfg.calmode = 'p'\n                cfg.antenna = antsel\n                cfg.uvrange = uvrange\n                tl.gaincal(cfg)\n            else:\n                print '%s exists' % g0name\n\n            if not os.path.exists(b1name):\n                print 'Starting bp cal...'\n                cfg = tl.GaincalConfig()\n                cfg.vis = msfile\n                cfg.caltable = b1name\n                cfg.gaintable = [g0name]\n                cfg.scan = self.bpstr\n                cfg.spw = spw1\n                cfg.gaintype = 'BPOLY'\n                cfg.degamp = 5\n                cfg.degphase = 2\n                cfg.maskedge = 6\n                cfg.solint = 'inf'\n                cfg.combine = ['scan']\n                cfg.solnorm = True\n                cfg.refant = refant\n                cfg.antenna = antsel\n                cfg.uvrange = uvrange\n                tl.gaincal(cfg)\n            else:\n                print '%s exists' % b1name\n\n            if not os.path.exists(g1name):\n                print 'Starting gain cal...'\n                cfg = tl.GaincalConfig()\n                cfg.vis = msfile\n                cfg.caltable = g1name\n                cfg.gaintable = [b1name]\n                cfg.scan = self.allstr\n                cfg.gaintype = 'G'\n                cfg.solint = 'inf'\n                cfg.spw = spw1\n                cfg.refant = refant\n                cfg.minsnr = 5.\n                cfg.calmode='ap'\n                cfg.antenna = antsel\n                cfg.uvrange = uvrange\n                tl.gaincal(cfg)\n            else:\n                print '%s exists' % g1name\n\n        return 0", "response": "Run the calibration pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreplace emoticons by HTML images with regular expressions.", "response": "def regexp_replace_emoticons(content):\n    \"\"\"\n    Replace the emoticons string by HTML images,\n    with regular expressions.\n    \"\"\"\n    for emoticon, emoticon_html in EMOTICONS_COMPILED:\n        if emoticon.search(content):\n            content = emoticon.sub(emoticon_html, content)\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreplaces the emoticons string by HTML images.", "response": "def replace_emoticons(content, excluded_markups):\n    \"\"\"\n    Replace the emoticons string by HTML images.\n    If some markups should be excluded from replacement,\n    BeautifulSoup will be used.\n    \"\"\"\n    if not excluded_markups:\n        return regexp_replace_emoticons(content)\n\n    excluded_markups = excluded_markups.split(',') + ['[document]']\n    soup = BeautifulSoup(content, 'html.parser')\n\n    for content_string in list(soup.strings):\n        if content_string.parent.name not in excluded_markups:\n            replaced_content_string = regexp_replace_emoticons(content_string)\n            if content_string != replaced_content_string:\n                content_string.replace_with(\n                    BeautifulSoup(replaced_content_string, 'html.parser'))\n    return str(soup)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef emoticons_tag(parser, token):\n    exclude = ''\n    args = token.split_contents()\n    if len(args) == 2:\n        exclude = args[1]\n    elif len(args) > 2:\n        raise template.TemplateSyntaxError(\n            'emoticons tag has only one optional argument')\n\n    nodelist = parser.parse(['endemoticons'])\n    parser.delete_first_token()\n    return EmoticonNode(nodelist, exclude)", "response": "Tag for rendering emoticons."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfilter for rendering emoticons.", "response": "def emoticons_filter(content, exclude='', autoescape=None):\n    \"\"\"\n    Filter for rendering emoticons.\n    \"\"\"\n    esc = autoescape and conditional_escape or (lambda x: x)\n    content = mark_safe(replace_emoticons(esc(content), exclude))\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, obj, label, format='text'):\n\n        # initialize hidden state directory\n\n        objloc = '{0}/{1}'.format(self.statedir, label)\n\n        with open(objloc, 'w') as fp:\n            if format == 'pickle':\n                pickle.dump(obj, fp)\n            elif format == 'text':\n                fp.write(str(obj))\n            else:\n                print('Format {0} not recognized. Please choose either pickle or text.'.format(format))\n\n        print('Saving {0} to label {1}'.format(obj, label))", "response": "Save or update a single object in pkl file with name label \n."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload obj with give label from hidden state directory", "response": "def load(self, label):\n        \"\"\" Load obj with give label from hidden state directory \"\"\"\n\n        objloc = '{0}/{1}'.format(self.statedir, label)\n\n        try:\n            obj = pickle.load(open(objloc, 'r')) \n        except (KeyError, IndexError, EOFError):\n            obj = open(objloc, 'r').read()\n            try:\n                obj = float(obj)\n            except ValueError:\n                pass\n        except IOError:\n            obj = None\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the text in a notebook pipeline", "response": "def setText(self, label, default='', description='Set Text', format='text'):\n        \"\"\" Set text in a notebook pipeline (via interaction or with nbconvert) \"\"\"\n\n        obj = self.load(label)\n        if obj == None:\n            obj=default\n            self.save(obj, label)  # initialize with default\n\n        textw = Text(value=obj, description=description)\n        hndl = interact(self.save, obj=textw, label=fixed(label), format=fixed(format))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting a float in a notebook pipeline", "response": "def setFloat(self, label, default=0, min=-20, max=20, description='Set Float', format='text'):\n        \"\"\" Set float in a notebook pipeline (via interaction or with nbconvert) \"\"\"\n\n        obj = self.load(label)\n        if obj == None:\n            obj=default\n            self.save(obj, label)  # initialize with default\n\n        floatw = FloatSlider(value=obj, min=min, max=max, description=description)\n        hndl = interact(self.save, obj=floatw, label=fixed(label), format=fixed(format))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets a Dropdown in a notebook pipeline", "response": "def setDropdown(self, label, default=None, options=[], description='Set Dropdown', format='text'):\n        \"\"\" Set float in a notebook pipeline (via interaction or with nbconvert) \"\"\"\n\n        obj = self.load(label)\n        if obj == None:\n            obj=default\n            self.save(obj, label)  # initialize with default\n\n        dropdownw = Dropdown(value=obj, options=options, description=description)\n        hndl = interact(self.save, obj=dropdownw, label=fixed(label), format=fixed(format))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef FDMT(data, f_min, f_max, maxDT, dataType):\n\n    nint, nbl, nchan, npol = data.shape\n    niters = int(np.log2(nchan))\n\n    assert nchan in 2**np.arange(30) and nint in 2**np.arange(30), \"Input dimensions must be a power of 2\"\n\n    logger.info('Input data dimensions: {0}'.format(data.shape))\n    data = FDMT_initialization(data, f_min, f_max, maxDT, dataType)\n\n    logger.info('Iterating {0} times to calculate to maxDT of {1}'.format(niters, maxDT))\n    for i_t in range(1, niters+1):\n        data = FDMT_iteration(data, maxDT, nchan, f_min, f_max, i_t, dataType)\n\n    [nint, dT, nbl, nchan, npol] = data.shape\n    assert nchan == 1, 'Channel axis should have length 1 after all FDMT iterations.'\n\n    # put dT axis first and remove chan axis\n    return np.rollaxis(data[:,:,:,0,:], 1)", "response": "This function implements the DFMT algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsummarize DM grid and other parameters.", "response": "def FDMT_params(f_min, f_max, maxDT, inttime):\n    \"\"\"\n    Summarize DM grid and other parameters.\n    \"\"\"\n\n    maxDM = inttime*maxDT/(4.1488e-3 * (1/f_min**2 - 1/f_max**2))\n    logger.info('Freqs from {0}-{1}, MaxDT {2}, Int time {3} => maxDM {4}'.format(f_min, f_max, maxDT, inttime, maxDM))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dmtoind(dm, f_min, f_max, nchan0, inttime, it):\n\n#    maxDT = dmtodt(dm) # need to write\n\n    if it>0:\n        correction = dF/2.\n    else:\n        correction = 0\n\n    shift = []\n    nchan = nchan0/2**(iteration_num)\n    for i_F in range(nchan):\n        f_start = (f_max - f_min)/float(nchan) * (i_F) + f_min\n        f_end = (f_max - f_min)/float(nchan) *(i_F+1) + f_min\n        f_middle = (f_end - f_start)/2. + f_start - correction\n        f_middle_larger = (f_end - f_start)/2 + f_start + correction\n\n        dT_middle = int(round(i_dT * (1./f_middle**2 - 1./f_start**2)/(1./f_end**2 - 1./f_start**2)))\n        dT_middle_larger = int(round(i_dT * (1./f_middle_larger**2 - 1./f_start**2)/(1./f_end**2 - 1./f_start**2)))\n\n        shift.append( (-dT_middle_larger, i_F) )", "response": "Given a state return indices to slice partial FDMT solution and sump to a given DM"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef FDMT_initialization(datain, f_min, f_max, maxDT, dataType):\n    # Data initialization is done prior to the first FDMT iteration\n    # See Equations 17 and 19 in Zackay & Ofek (2014)\n\n    [nint, nbl, nchan, npol] = datain.shape\n\n    deltaF = (f_max - f_min)/float(nchan)\n    deltaT = int(np.ceil((maxDT-1) *(1./f_min**2 - 1./(f_min + deltaF)**2) / (1./f_min**2 - 1./f_max**2)))\n\n    dataout = np.zeros([nint, deltaT+1, nbl, nchan, npol], dataType)\n    dataout[:,0,:,:,:] = datain\n    \n    for i_dT in xrange(1, deltaT+1):\n        dataout[i_dT:, i_dT, :, :, :] = dataout[i_dT:, i_dT-1, :, :, :] + datain[:-i_dT]\n    return dataout", "response": "This function initializes the FDMT data structure for a base - band and base - band dispersion curve."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef FDMT_iteration(datain, maxDT, nchan0, f_min, f_max, iteration_num, dataType):\n\n    nint, dT, nbl, nchan, npol = datain.shape\n#    output_dims = list(input_dims)\n    \n    deltaF = 2**(iteration_num) * (f_max - f_min)/float(nchan0)\n    dF = (f_max - f_min)/float(nchan0)\n    # the maximum deltaT needed to calculate at the i'th iteration\n    deltaT = int(np.ceil((maxDT-1) *(1./f_min**2 - 1./(f_min + deltaF)**2) / (1./f_min**2 - 1./f_max**2)))\n    logger.debug(\"deltaT = {0}\".format(deltaT))\n    logger.debug(\"N_f = {0}\".format(nchan0/2**(iteration_num)))\n    \n    dataout = np.zeros((nint, deltaT+1, nbl, nchan/2, npol), dataType)\n\n    logger.debug('input_dims = {0}'.format(datain.shape))\n    logger.debug('output_dims = {0}'.format(dataout.shape))\n    \n    # No negative D's are calculated => no shift is needed\n    # If you want negative dispersions, this will have to change to 1+deltaT,1+deltaTOld\n    # Might want to calculate negative dispersions when using coherent dedispersion, to reduce the number of trial dispersions by a factor of 2 (reducing the complexity of the coherent part of the hybrid)\n    ShiftOutput = 0\n    ShiftInput = 0\n\n    F_jumps = nchan/2\n\n    # For some situations, it is beneficial to play with this correction.\n    # When applied to real data, one should carefully analyze and understand the effect of \n    # this correction on the pulse he is looking for (especially if convolving with a specific pulse profile)\n    if iteration_num>0:\n        correction = dF/2.\n    else:\n        correction = 0\n\n    for i_F in range(F_jumps):\n        f_start = (f_max - f_min)/float(F_jumps) * (i_F) + f_min\n        f_end = (f_max - f_min)/float(F_jumps) *(i_F+1) + f_min\n        f_middle = (f_end - f_start)/2. + f_start - correction\n\n        # it turned out in the end, that putting the correction +dF to f_middle_larger (or -dF/2 to f_middle, and +dF/2 to f_middle larger)\n        # is less sensitive than doing nothing when dedispersing a coherently dispersed pulse.\n        # The confusing part is that the hitting efficiency is better with the corrections (!?!).\n\n        f_middle_larger = (f_end - f_start)/2 + f_start + correction\n        deltaTLocal = int(np.ceil((maxDT-1) *(1./f_start**2 - 1./(f_end)**2) / (1./f_min**2 - 1./f_max**2)))\n        logger.debug('deltaT {0} deltaTLocal {1}'.format(deltaT, deltaTLocal))\n\n        for i_dT in range(deltaTLocal+1):\n            dT_middle = int(round(i_dT * (1./f_middle**2 - 1./f_start**2)/(1./f_end**2 - 1./f_start**2)))\n            dT_middle_index = dT_middle + ShiftInput\n            \n            dT_middle_larger = int(round(i_dT * (1./f_middle_larger**2 - 1./f_start**2)/(1./f_end**2 - 1./f_start**2)))\n            \n            dT_rest = i_dT - dT_middle_larger\n            dT_rest_index = dT_rest + ShiftInput\n            \n            logger.debug('{0}:{1}, {2}+{3}, {4} <= {5}, {6}'.format(i_T_min, i_T_max, i_dT, ShiftOutput, i_F, dT_middle_index, 2*i_F))\n\n            # out of bounds data?\n            i_T_min = 0\n            i_T_max = dT_middle_larger\n            dataout[i_T_min:i_T_max, i_dT + ShiftOutput, :, i_F, :] = datain[i_T_min:i_T_max, dT_middle_index, :, 2*i_F, :]\n\n            # fully dedispersed data\n            i_T_min = dT_middle_larger\n            i_T_max = nint\n            dataout[i_T_min:i_T_max, i_dT + ShiftOutput, :, i_F, :] = datain[i_T_min:i_T_max, dT_middle_index, :, 2*i_F, :] + datain[i_T_min - dT_middle_larger:i_T_max-dT_middle_larger, dT_rest_index, :, 2*i_F+1, :]\n    \n    return dataout", "response": "This function takes a 3d array and returns the frequency - bin of the base - band dispersion curve at a given iteration."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a unique keyname that does not exists is the connection keyspace.", "response": "def unique_key(connection):\n    \"\"\"\n    Generate a unique keyname that does not exists is the connection\n    keyspace.\n    \"\"\"\n    while 1:\n        key = str(uuid.uuid4().hex)\n        if not connection.exists(key):\n            break\n    return key"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normalize(value):\n    if value and isinstance(value, bytes):\n        value = value.decode('utf-8')\n    return value", "response": "Simple method to always have the same kind of value as\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccepting new clients and sends them to the _handle_accepted within a subthread", "response": "def _mainthread_accept_clients(self):\n        \"\"\"Accepts new clients and sends them to the to _handle_accepted within a subthread\n        \"\"\"\n        try:\n            if self._accept_selector.select(timeout=self.block_time):\n                client = self._server_socket.accept()\n                logging.info('Client connected: {}'.format(client[1]))\n\n                self._threads_limiter.start_thread(target=self._subthread_handle_accepted,\n                                                   args=(client,))\n        except socket.error:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches for readable client sockets and adds a subthread to handle them.", "response": "def _mainthread_poll_readable(self):\n        \"\"\"Searches for readable client sockets. These sockets are then put in a subthread\n        to be handled by _handle_readable\n        \"\"\"\n        events = self._recv_selector.select(self.block_time)\n        for key, mask in events:\n            if mask == selectors.EVENT_READ:\n                self._recv_selector.unregister(key.fileobj)\n\n                self._threads_limiter.start_thread(target=self._subthread_handle_readable,\n                                                   args=(key.fileobj,))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _subthread_handle_accepted(self, client):\n\n        conn, addr = client\n        if self.handle_incoming(conn, addr):\n            logging.info('Accepted connection from client: {}'.format(addr))\n            conn.setblocking(False)\n            self.clients[conn] = addr\n            self.register(conn)\n        else:\n            logging.info('Refused connection from client: {}'.format(addr))\n            self.disconnect(conn)", "response": "Handles the incoming client and sets up the client socket."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling readable client sockets. Calls the user modified handle_readable with the client socket as the only variable.", "response": "def _subthread_handle_readable(self, conn):\n        \"\"\"Handles readable client sockets. Calls the user modified handle_readable with\n        the client socket as the only variable. If the handle_readable function returns\n        true the client is again registered to the selector object otherwise the client\n        is disconnected.\n        \"\"\"\n\n        if self.handle_readable(conn):\n            self.register(conn)\n        else:\n            self.disconnect(conn)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsingles - threaded pipeline for data prep for a single segment.", "response": "def pipeline_dataprep(d, segment):\n    \"\"\" Single-threaded pipeline for data prep that can be started in a pool.\n    \"\"\"\n\n    logger.debug('dataprep starting for segment %d' % segment)\n\n    # dataprep reads for a single segment, so d['segment'] defined here\n    d['segment'] = segment\n\n    # set up numpy arrays, as expected by dataprep functions\n    data_read = numpyview(data_read_mem, 'complex64', datashape(d), raw=False); data = numpyview(data_mem, 'complex64', datashape(d), raw=False)\n    u_read = numpyview(u_read_mem, 'float32', d['nbl'], raw=False); u = numpyview(u_mem, 'float32', d['nbl'], raw=False)\n    v_read = numpyview(v_read_mem, 'float32', d['nbl'], raw=False); v = numpyview(v_mem, 'float32', d['nbl'], raw=False)\n    w_read = numpyview(w_read_mem, 'float32', d['nbl'], raw=False); w = numpyview(w_mem, 'float32', d['nbl'], raw=False)\n\n    ####    ####    ####    ####\n    # 1) Read data\n    ####    ####    ####    ####\n\n    with data_read_mem.get_lock():\n        if d['dataformat'] == 'ms':   # CASA-based read\n            segread = pm.readsegment(d, segment)\n            data_read[:] = segread[0]\n            (u_read[:], v_read[:], w_read[:]) = (segread[1][d['readints']/2], segread[2][d['readints']/2], segread[3][d['readints']/2])  # mid int good enough for segment. could extend this to save per chunk\n            del segread\n        elif d['dataformat'] == 'sdm':\n            data_read[:] = ps.read_bdf_segment(d, segment)\n            (u_read[:], v_read[:], w_read[:]) = ps.get_uvw_segment(d, segment)\n\n        ####    ####    ####    ####\n        # 2) Prepare data\n        ####    ####    ####    ####\n\n        # calibrate data\n        if os.path.exists(d['gainfile']):\n            try:\n                radec = (); spwind = []; calname = ''  # set defaults\n                if '.GN' in d['gainfile']: # if telcal file\n                    if d.has_key('calname'):\n                        calname = d['calname']\n\n                    sols = pc.telcal_sol(d['gainfile'])   # parse gainfile\n                else:   # if CASA table\n                    if d.has_key('calradec'):\n                        radec = d['calradec']  # optionally defined cal location\n\n                    spwind = d['spw']\n                    sols = pc.casa_sol(d['gainfile'], flagants=d['flagantsol'])   # parse gainfile\n                    sols.parsebp(d['bpfile'])   # parse bpfile\n\n                # if gainfile parsed ok, choose best solution for data\n                sols.set_selection(d['segmenttimes'][segment].mean(), d['freq']*1e9, rtlib.calc_blarr(d), calname=calname, pols=d['pols'], radec=radec, spwind=spwind)\n                sols.apply(data_read)\n            except:\n                logger.warning('Could not parse or apply gainfile %s.' % d['gainfile'])\n                raise\n        else:\n            logger.warn('Calibration file not found. Proceeding with no calibration applied.')\n\n        # flag data\n        if len(d['flaglist']):\n            logger.info('Flagging with flaglist: %s' % d['flaglist'])\n            dataflag(d, data_read)\n        else:\n            logger.warn('No real-time flagging.')\n\n        # mean t vis subtration\n        if d['timesub'] == 'mean':\n            logger.info('Subtracting mean visibility in time...')\n            rtlib.meantsub(data_read, [0, d['nbl']])\n        else:\n            logger.warn('No mean time subtraction.')\n\n        # save noise pickle\n        if d['savenoise']:\n            noisepickle(d, data_read, u_read, v_read, w_read, chunk=200)\n\n        # phase to new location if l1,m1 set and nonzero value\n        try:\n            if any([d['l1'], d['m1']]):\n                logger.info('Rephasing data to (l, m)=(%.4f, %.4f).' % (d['l1'], d['m1']))\n                rtlib.phaseshift_threaded(data_read, d, d['l1'], d['m1'], u_read, v_read)\n                d['l0'] = d['l1']\n                d['m0'] = d['m1']\n            else:\n                logger.debug('Not rephasing.')\n        except KeyError:\n            pass\n\n        if d['mock']: # could be list or int\n            # assume that std of vis in the middle of the segment is\n            # characteristic of noise throughout the segment\n            falsecands = {}\n            datamid = n.ma.masked_equal(data_read[d['readints']/2].real, 0, copy=True)\n            madstd = 1.4826 * n.ma.median(n.abs(datamid - n.ma.median(datamid)))/n.sqrt(d['npol']*d['nbl']*d['nchan'])\n            std = datamid.std()/n.sqrt(d['npol']*d['nbl']*d['nchan'])\n            logger.debug('Noise per vis in central int: madstd {}, std {}'.format(madstd, std))\n            dt = 1 # pulse width in integrations\n\n            if isinstance(d['mock'], int):\n                for i in n.random.randint(d['datadelay'][-1], d['readints'], d['mock']):  # add nmock transients at random ints\n                    (loff, moff, A, DM) = make_transient(madstd, max(d['dmarr']), Amin=1.2*d['sigma_image1'])\n                    candid =  (int(segment), int(i), DM, int(dt), int(0))\n                    falsecands[candid] = [A/madstd, A, loff, moff]\n            elif isinstance(d['mock'], list):\n                for mock in d['mock']:\n                    try:\n                        (i, DM, loff, moff, SNR) = mock\n                        candid =  (int(segment), int(i), DM, int(dt), int(0))\n                        falsecands[candid] = [SNR, SNR*madstd, loff, moff]\n                    except:\n                        logger.warn('Could not parse mock parameters: {}'.format(mock))\n            else:\n                logger.warn('Not a recognized type for mock.')\n\n            for candid in falsecands:\n                (segment, i, DM, dt, beamnum) = candid\n                (SNR, A, loff, moff) = falsecands[candid]\n                logger.info('Adding mock transient at int %d, DM %.1f, (l, m) = (%f, %f) at est SNR %.1f' % (i, DM, loff, moff, SNR))\n                add_transient(d, data_read, u_read, v_read, w_read, loff, moff, i, A, DM, dt)\n            \n            if d['savecands']:\n                savecands(d, falsecands, domock=True)\n\n        with data_mem.get_lock():\n            data[:] = data_read[:]\n            u[:] = u_read[:]; v[:] = v_read[:]; w[:] = w_read[:]\n    logger.debug('All data unlocked for segment %d' % segment)\n\n    # d now has segment keyword defined\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreproduces data and candidates with given candloc or lm coordinate.", "response": "def pipeline_reproduce(d, candloc=[], segment=None, lm=None, product='data'):\n    \"\"\" Reproduce data and/or candidates with given candloc or lm coordinate.\n\n    d and segment can be given, if only reading data.\n    candloc is length 5 or 6 with ([scan], segment, candint, dmind, dtind, beamnum).\n    product can be 'data', 'dataph', 'imdata', 'datacorr'.\n    lm is tuple of (l,m) coordinates in radians.\n    \"\"\"\n\n    # set up shared arrays to fill\n    data_reproduce_mem = mps.Array(mps.ctypes.c_float, datasize(d)*2)\n    data_read_mem = mps.Array(mps.ctypes.c_float, datasize(d)*2)\n    data_mem = mps.Array(mps.ctypes.c_float, datasize(d)*2)\n    u_read_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    u_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    v_read_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    v_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    w_read_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    w_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n\n    # get numpy views of memory spaces\n    data = numpyview(data_mem, 'complex64', datashape(d)) # optional\n    data_read = numpyview(data_read_mem, 'complex64', datashape(d)) # optional\n    u = numpyview(u_mem, 'float32', d['nbl'], raw=False)\n    v = numpyview(v_mem, 'float32', d['nbl'], raw=False)\n    w = numpyview(w_mem, 'float32', d['nbl'], raw=False)\n\n    # set up state dict for merge pkl\n    if len(candloc) == 6:\n        scan, segment, candint, dmind, dtind, beamnum = candloc\n# this is now defined by call to rtpipe.set_pipeline in parsecands.plot_cand\n#        d['scan'] = scan\n#        d['starttime_mjd'] = d['starttime_mjddict'][scan]\n#        d['nsegments'] = len(d['segmenttimesdict'][scan])\n#        d['segmenttimes'] = d['segmenttimesdict'][scan]\n    elif len(candloc) == 5:  # if not a merge pkl, then d['scan'] is correct\n        segment, candint, dmind, dtind, beamnum = candloc        \n    elif isinstance(segment, int):\n        assert product == 'data', 'If only providing segment, then only data product can be produced.'\n    else:\n        logger.error('candloc must be length 5 or 6 or segment provided.')\n        return\n\n    with closing(mp.Pool(1, initializer=initread, initargs=(data_read_mem, u_read_mem, v_read_mem, w_read_mem, data_mem, u_mem, v_mem, w_mem))) as readpool:  \n        readpool.apply(pipeline_dataprep, (d, segment))\n\n    if product == 'data':\n        logger.info('Returning prepared data...')\n        return data\n\n    elif product == 'dataph':\n        logger.info('Reproducing data and phasing...')\n        assert lm, 'lm must be tuple with (l, m) coords in radians.'\n        data = runreproduce(d, data_mem, data_reproduce_mem, u, v, w, dmind, dtind, lm=lm)\n        return data\n\n    elif product == 'datacorr':\n        logger.info('Reproducing data...')\n        data = runreproduce(d, data_mem, data_reproduce_mem, u, v, w, dmind, dtind)\n        return data\n\n    elif product == 'imdata':\n        logger.info('Reproducing candidate...')\n        im, data = runreproduce(d, data_mem, data_reproduce_mem, u, v, w, dmind, dtind, candint=candint)\n        return im, data\n\n    else:\n        logger.error('product must be data, dataph, or imdata.')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef meantsubpool(d, data_read):\n\n    logger.info('Subtracting mean visibility in time...')\n    data_read = numpyview(data_read_mem, 'complex64', datashape(d))\n    tsubpart = partial(rtlib.meantsub, data_read)\n\n    blranges = [(d['nbl'] * t/d['nthread'], d['nbl']*(t+1)/d['nthread']) for t in range(d['nthread'])]\n    with closing(mp.Pool(1, initializer=initreadonly, initargs=(data_read_mem,))) as tsubpool:\n        tsubpool.map(tsubpart, blr)", "response": "Wrapper for mean visibility subtraction in time."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nflagging data in single process", "response": "def dataflag(d, data_read):\n    \"\"\" Flagging data in single process \n    \"\"\"\n\n    for flag in d['flaglist']:\n        mode, sig, conv = flag\n#        resultlist = []\n#        with closing(mp.Pool(4, initializer=initreadonly, initargs=(data_read_mem,))) as flagpool:\n        for ss in d['spw']:\n            chans = n.arange(d['spw_chanr_select'][ss][0], d['spw_chanr_select'][ss][1])\n            for pol in range(d['npol']):\n                status = rtlib.dataflag(data_read, chans, pol, d, sig, mode, conv)\n                logger.info(status)\n\n    # hack to get rid of bad spw/pol combos whacked by rfi\n    if 'badspwpol' in d:\n        logger.info('Comparing overall power between spw/pol. Removing those with %d times typical value' % d['badspwpol'])\n        spwpol = {}\n        for spw in d['spw']:\n            chans = n.arange(d['spw_chanr_select'][spw][0], d['spw_chanr_select'][spw][1])\n            for pol in range(d['npol']):\n                spwpol[(spw, pol)] = n.abs(data_read[:,:,chans,pol]).std()\n        \n        meanstd = n.mean(spwpol.values())\n        for (spw,pol) in spwpol:\n            if spwpol[(spw, pol)] > d['badspwpol']*meanstd:\n                logger.info('Flagging all of (spw %d, pol %d) for excess noise.' % (spw, pol))\n                chans = n.arange(d['spw_chanr_select'][spw][0], d['spw_chanr_select'][spw][1])\n                data_read[:,:,chans,pol] = 0j"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dataflagatom(chans, pol, d, sig, mode, conv):\n\n    data = numpyview(data_mem, 'complex64', datashape(d))\n#    data = n.ma.masked_array(data, data==0j)  # this causes massive overflagging on 14sep03 data\n\n    return rtlib.dataflag(data, chans, pol, d, sig, mode, conv)", "response": "Wrapper function to get shared memory as numpy array into mps. Array\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches function. Queues all trials with multiprocessing. Assumes shared memory system with single uvw grid for all images.", "response": "def search(d, data_mem, u_mem, v_mem, w_mem):\n    \"\"\" Search function.\n    Queues all trials with multiprocessing.\n    Assumes shared memory system with single uvw grid for all images.\n    \"\"\"\n\n    data = numpyview(data_mem, 'complex64', datashape(d))\n    u = numpyview(u_mem, 'float32', d['nbl'])\n    v = numpyview(v_mem, 'float32', d['nbl'])\n    w = numpyview(w_mem, 'float32', d['nbl'])\n    data_resamp_mem = mps.Array(mps.ctypes.c_float, datasize(d)*2)\n    data_resamp = numpyview(data_resamp_mem, 'complex64', datashape(d))\n\n    logger.debug('Search of segment %d' % d['segment'])\n\n    beamnum = 0   # not yet implemented\n    cands = {}\n\n    candsfile = getcandsfile(d)\n    if d['savecands'] and os.path.exists(candsfile):\n        logger.warn('candsfile %s already exists' % candsfile)\n        return cands\n\n    # make wterm kernels\n    if d['searchtype'] == 'image2w':\n        wres = 100\n        npix = max(d['npixx_full'], d['npixy_full'])\n        bls, uvkers = rtlib.genuvkernels(w, wres, npix, d['uvres'], thresh=0.05)\n\n    # SUBMITTING THE LOOPS\n    if n.any(data):\n        logger.debug('Searching in %d chunks with %d threads' % (d['nchunk'], d['nthread']))\n        logger.info('Dedispering to max (DM, dt) of (%d, %d) ...' % (d['dmarr'][-1], d['dtarr'][-1]) )\n\n        # open pool\n        with closing(mp.Pool(d['nthread'], initializer=initresamp, initargs=(data_mem, data_resamp_mem))) as resamppool:\n            blranges = [(d['nbl'] * t/d['nthread'], d['nbl']*(t+1)/d['nthread']) for t in range(d['nthread'])]           \n            for dmind in xrange(len(d['dmarr'])):\n                dm = d['dmarr'][dmind]\n                logger.debug('Dedispersing for %d' % dm,)\n                dedisppart = partial(correct_dm, d, dm)   # moves in fresh data\n                dedispresults = resamppool.map(dedisppart, blranges)\n\n                dtlast = 1\n                for dtind in xrange(len(d['dtarr'])):\n                    dt = d['dtarr'][dtind]\n                    \n                    if dt > 1:\n                        # dedispersion in shared memory, mapped over baselines\n                        # set partial functions for pool.map\n\n                        logger.debug('Resampling for %d' % dt,)\n                        resample = dt/dtlast\n                        resamppart = partial(correct_dt, d, resample)   # corrects in place\n                        resampresults = resamppool.map(resamppart, blranges)\n                        dtlast = dt\n\n                    # set dm- and dt-dependent int ranges for segment\n                    nskip_dm = ((d['datadelay'][-1] - d['datadelay'][dmind]) / dt) * (d['segment'] != 0)  # nskip=0 for first segment\n                    searchints = (d['readints'] - d['datadelay'][dmind]) / dt - nskip_dm\n                    logger.debug('Imaging %d ints from %d for (%d,%d)' % (searchints, nskip_dm, dm, dt),)\n\n                    # imaging in shared memory, mapped over ints\n                    image1part = partial(image1, d, u, v, w, dmind, dtind, beamnum)\n                    nchunkdt = min(searchints, max(d['nthread'], d['nchunk']/dt))  # parallelize in range bounded by (searchints, nthread)\n                    irange = [(nskip_dm + searchints*chunk/nchunkdt, nskip_dm + searchints*(chunk+1)/nchunkdt) for chunk in range(nchunkdt)]\n                    imageresults = resamppool.map(image1part, irange)\n\n                    # COLLECTING THE RESULTS per dm/dt. Clears the way for overwriting data_resamp\n                    for imageresult in imageresults:\n                        for kk in imageresult.keys():\n                            cands[kk] = imageresult[kk]\n\n        if 'sigma_plot' in d:\n            from rtpipe.reproduce import make_cand_plot as makecp\n            if 'snr2' in d['features']:\n                snrcol = d['features'].index('snr2')\n            elif 'snr1' in d['features']:\n                snrcol = d['features'].index('snr1')\n\n            snrs = n.array([value[snrcol] for value in cands.itervalues()])\n\n            maxsnr = max([0] + [value[snrcol] for value in cands.itervalues()])  # be sure max includes at least one value\n            if maxsnr > d['sigma_plot']:\n                segment, candint, dmind, dtind, beamnum = [key for key, value in cands.iteritems() if value[snrcol] == maxsnr][0]\n                logger.info('Making cand plot for scan %d, segment %d, candint %d, dmind %d, dtint %d with SNR %.1f.' % (d['scan'], segment, candint, dmind, dtind, maxsnr))\n                im, data = runreproduce(d, data_mem, data_resamp_mem, u, v, w, dmind, dtind, candint)\n                loclabel = [d['scan'], segment, candint, dmind, dtind, beamnum]\n                makecp(d, im, data, loclabel, version=2, snrs=snrs)\n            else:\n                logger.info('No candidate in segment %d above sigma_plot %.1f' % (d['segment'], d['sigma_plot']))\n\n    else:\n        logger.warn('Data for processing is zeros. Moving on...')\n\n    logger.info('Found %d cands in scan %d segment %d of %s. ' % (len(cands), d['scan'], d['segment'], d['filename']))\n    return cands"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef runreproduce(d, data_mem, data_resamp_mem, u, v, w, dmind, dtind, candint=-1, lm=None, twindow=30):\n\n    data_resamp = numpyview(data_resamp_mem, 'complex64', datashape(d))\n\n    with closing(mp.Pool(1, initializer=initresamp, initargs=(data_mem, data_resamp_mem))) as repropool:\n        # dedisperse\n        logger.info('Dedispersing with DM=%.1f, dt=%d...' % (d['dmarr'][dmind], d['dtarr'][dtind]))\n        repropool.apply(correct_dmdt, [d, dmind, dtind, (0,d['nbl'])])\n\n        # set up image\n        if 'image1' in d['searchtype']:\n            npixx = d['npixx']\n            npixy = d['npixy']\n        elif 'image2' in d['searchtype']:\n            npixx = d['npixx_full']\n            npixy = d['npixy_full']\n\n        if candint > -1:\n            if lm:\n                logger.warn('Using candint image to get l,m. Not using provided l,m.')\n\n            # image\n            logger.info('Imaging int %d with %d %d pixels...' % (candint, npixx, npixy))\n            im = repropool.apply(image1wrap, [d, u, v, w, npixx, npixy, candint/d['dtarr'][dtind]])\n\n            snrmin = im.min()/im.std()\n            snrmax = im.max()/im.std()\n            logger.info('Made image with SNR min, max: %.1f, %.1f' % (snrmin, snrmax))\n            if snrmax > -1*snrmin:\n                l1, m1 = calc_lm(d, im, minmax='max')\n            else:\n                l1, m1 = calc_lm(d, im, minmax='min')\n\n            # rephase and trim interesting ints out\n            repropool.apply(move_phasecenter, [d, l1, m1, u, v])\n            minint = max(candint/d['dtarr'][dtind]-twindow/2, 0)\n            maxint = min(candint/d['dtarr'][dtind]+twindow/2, len(data_resamp)/d['dtarr'][dtind])\n\n            return(im, data_resamp[minint:maxint].mean(axis=1))\n        else:\n            if lm:\n                l1, m1 = lm\n                repropool.apply(move_phasecenter, [d, l1, m1, u, v])\n\n            return data_resamp", "response": "Reproduce function much like search."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a transient to data.", "response": "def add_transient(d, data, u, v, w, l1, m1, i, s, dm=0, dt=1):\n    \"\"\" Add a transient to data.\n    l1, m1 are relative direction cosines (location) of transient\n    added at integration i (at highest freq) with brightness s (per int/chan/bl/pol in data units)\n    dm/dt are dispersion (in pc/cm3) and pulse width (in s).\n    \"\"\"\n\n    ang = lambda ch: l1 * u * d['freq'][ch]/d['freq_orig'][0] + m1 * v * d['freq'][ch]/d['freq_orig'][0]\n    delay = lambda ch: n.round(4.1488e-3 * dm * (d['freq'][ch]**(-2) - d['freq'][-1]**(-2))/d['inttime'], 0).astype(int)\n\n    #snr_ideal = s/(data[i].real.std()/n.sqrt(d['npol']*d['nbl']*d['nchan']))\n    #logger.info('SNR of source with system brightness %.1f = %d (idealized; ok at low SNR)' % (s, int(snr_ideal)))\n\n    for ch in range(d['nchan']):\n        data[i+delay(ch):i+delay(ch)+dt, :, ch] += s * n.exp(2j*n.pi*ang(ch)[None,:,None])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_transient(std, DMmax, Amin=6., Amax=20., rmax=20., rmin=0., DMmin=0.):\n\n    rad_arcmin = math.pi/(180*60)\n    phimin =  0.0\n    phimax = 2*math.pi\n    \n    # Amplitude of transient, done in units of the std\n    # std is calculated assuming that noise level in the middle of the data, \n    # at index d['readints']/2, is characteristic of that throughout the data\n    A = random.uniform(Amin, Amax) * std\n\n    # Position of transient, in direction cosines\n    r = random.uniform(rmin, rmax)\n    phi = random.uniform(phimin, phimax)\n    loff = r*math.cos(phi) * rad_arcmin\n    moff = r*math.sin(phi) * rad_arcmin\n\n    # Dispersion measure\n    DM = random.uniform(DMmin, DMmax)\n    return loff, moff, A, DM", "response": "Generates a mock transient pulse source for characterizing the current pipeline."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pipeline_refine(d0, candloc, scaledm=2.1, scalepix=2, scaleuv=1.0, chans=[], returndata=False):\n\n    import rtpipe.parseparams as pp\n\n    assert len(candloc) == 6, 'candloc should be (scan, segment, candint, dmind, dtind, beamnum).'\n    scan, segment, candint, dmind, dtind, beamnum = candloc\n\n    d1 = d0.copy() # dont mess with original (mutable!)\n\n    segmenttimes = d1['segmenttimesdict'][scan]\n\n    # if file not at stated full path, assume it is local\n    if not os.path.exists(d1['filename']):\n        workdir = os.getcwd()\n        filename = os.path.join(workdir, os.path.basename(d1['filename']))\n    else:\n        filename = d1['filename']\n\n    # clean up d1 of superfluous keys\n    params = pp.Params()  # will be used as input to rt.set_pipeline\n    for key in d1.keys():\n        if not hasattr(params, key):\n            _ = d1.pop(key)\n\n    d1['npix'] = 0; d1['uvres'] = 0\n    d1['savecands'] = False\n    d1['savenoise'] = False\n    d1['logfile'] = False\n\n    # redefine d. many parameters modified after this to keep from messing up time boundaries/cand location\n    d = set_pipeline(filename, scan, **d1)\n    if chans:\n        d['chans'] = chans\n\n    d['segmenttimes'] = segmenttimes\n    d['nsegments'] = len(segmenttimes)\n\n    data_mem = mps.Array(mps.ctypes.c_float, datasize(d)*2)\n    u_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    v_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    w_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    data = numpyview(data_mem, 'complex64', datashape(d))\n    u = numpyview(u_mem, 'float32', d['nbl'])\n    v = numpyview(v_mem, 'float32', d['nbl'])\n    w = numpyview(w_mem, 'float32', d['nbl'])\n\n    # fill data, uvw\n    data[:] = pipeline_reproduce(d, segment=segment, product='data')\n    d['segment'] = segment\n    u[:], v[:], w[:] = ps.get_uvw_segment(d, segment)\n\n    # refine parameters\n    dmcand = d['dmarr'][dmind]\n    if scaledm > 1.:\n        try:\n            dmdelta = d['dmarr'][dmind+1] - d['dmarr'][dmind]\n        except IndexError:\n            try:\n                dmdelta = d['dmarr'][dmind] - d['dmarr'][dmind-1]\n            except IndexError:\n                dmdelta = 0.1*dmcand\n        d['dmarr'] = list(n.arange(dmcand-dmdelta, dmcand+dmdelta, dmdelta/scaledm))\n    elif scaledm == 1.:\n        d['dmarr'] = [dmcand]\n\n    d['datadelay'] = [rtlib.calc_delay(d['freq'], d['inttime'],dm).max() for dm in d['dmarr']] + [d['datadelay'][-1]]\n    d['dtarr'] = [d['dtarr'][dtind]]\n    d['npixx'] = scalepix*d['npixx']\n    d['npixy'] = scalepix*d['npixy']\n    d['uvres'] = scaleuv*d['uvres']\n\n    # search\n    logger.info('Refining DM grid to %s and expanding images to (%d, %d) pix with uvres %d' % (str(d['dmarr']), d['npixx'], d['npixy'], d['uvres']))\n    cands = search(d, data_mem, u_mem, v_mem, w_mem)\n    cands = {tuple([scan]+list(loc)):list(prop) for (loc, prop) in cands.iteritems()}\n    d['featureind'].insert(0, 'scan')\n\n# making cand plot from this\n# need to keep from confusing old and new indices\n#    im, data = rt.pipeline_reproduce(d, loc[candnum], product='imdata')\n#    scan, segment, candint, dmind, dtind, beamnum = loc\n#    loclabel = scan, segment, candint, dmind, dtind, beamnum\n#    make_cand_plot(d, im, data, loclabel, outname=outname)\n\n    # return info to reproduce/visualize refined cands\n    if returndata:\n        return data\n    else:\n        return d, cands", "response": "Reproduces candidate and potentially improves sensitivity through better DM and imaging parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes a lightcurve at given phase center and number of segments.", "response": "def pipeline_lightcurve(d, l1=0, m1=0, segments=[], scan=-1):\n    \"\"\" Makes lightcurve at given (l1, m1)\n    l1, m1 define phase center. if not set, then image max is used.\n    \"\"\"\n\n    if scan == -1: scan = d['scan']\n    if segments == []: segments = range(d['nsegments'])\n\n    d = set_pipeline(d['filename'], scan, fileroot=d['fileroot'], dmarr=[0], dtarr=[1], savenoise=False, timesub='', logfile=False, nsegments=d['nsegments'])\n\n    # define memory and numpy arrays\n    data_mem = mps.Array(mps.ctypes.c_float, datasize(d)*2)\n    data_read_mem = mps.Array(mps.ctypes.c_float, datasize(d)*2)\n    data_resamp_mem = mps.Array(mps.ctypes.c_float, datasize(d)*2)\n    u_read_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    u_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    v_read_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    v_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    w_read_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    w_mem = mps.Array(mps.ctypes.c_float, d['nbl'])\n    data_read = numpyview(data_read_mem, 'complex64', datashape(d)) # optional\n    u_read = numpyview(u_read_mem, 'float32', d['nbl'], raw=False)\n    v_read = numpyview(v_read_mem, 'float32', d['nbl'], raw=False)\n    w_read = numpyview(w_read_mem, 'float32', d['nbl'], raw=False)\n    lightcurve = n.zeros(shape=(d['nints'], d['nchan'], d['npol']), dtype='complex64')\n\n    phasecenters = []\n    with closing(mp.Pool(1, initializer=initread, initargs=(data_read_mem, u_read_mem, v_read_mem, w_read_mem, data_mem, u_mem, v_mem, w_mem))) as readpool:  \n        for segment in segments:\n            logger.info('Reading data...')\n            readpool.apply(pipeline_dataprep, (d, segment))\n\n            # get image peak for rephasing\n            if not any([l1, m1]):\n                im = sample_image(d, data_read, u_read, v_read, w_read, i=-1, verbose=1, imager='xy')\n                l2, m2 = calc_lm(d, im)\n            else:\n                l2 = l1\n                m2 = m1\n\n            logger.info('Rephasing data to (l, m)=(%.4f, %.4f).' % (l2, m2))\n            rtlib.phaseshift_threaded(data_read, d, l2, m2, u_read, v_read)\n            phasecenters.append( (l2,m2) )\n\n            nskip = (24*3600*(d['segmenttimes'][segment,0] - d['starttime_mjd'])/d['inttime']).astype(int)   # insure that lc is set as what is read\n            lightcurve[nskip: nskip+d['readints']] = data_read.mean(axis=1)\n\n    return phasecenters, lightcurve"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_pipeline(filename, scan, fileroot='', paramfile='', **kwargs):\n\n    \n    workdir = os.path.dirname(os.path.abspath(filename))\n    filename = filename.rstrip('/')\n    assert os.path.exists(filename)\n\n    # then get all metadata\n    if os.path.exists(os.path.join(filename, 'Main.xml')):\n        d = ps.get_metadata(filename, scan, paramfile=paramfile, **kwargs)   # can take file name or Params instance\n        d['dataformat'] = 'sdm'\n    else:\n        d = pm.get_metadata(filename, scan, paramfile=paramfile, **kwargs)\n        d['dataformat'] = 'ms'\n\n    # set version\n    d['rtpipe_version'] = __version__\n\n    # define rootname for in/out cal/products\n    if fileroot:\n        d['fileroot'] = fileroot\n    else:\n        d['fileroot'] = os.path.basename(os.path.abspath(filename))\n\n    # autodetect calibration products locally\n    if not d['gainfile'] or not os.path.exists(d['gainfile']):\n        # first try to get CASA gain file\n        gainfilelist = glob.glob(os.path.join(d['workdir'], d['fileroot'] + '.g?'))\n        bpfilelist = glob.glob(os.path.join(d['workdir'], d['fileroot'] + '.b?'))\n\n        # if not in workdir, look locally\n        if not gainfilelist or not bpfilelist:\n            gainfilelist = glob.glob(d['fileroot'] + '.g?')\n            bpfilelist = glob.glob(d['fileroot'] + '.b?')\n            \n        if gainfilelist and bpfilelist:\n            gainfilelist.sort()\n            d['gainfile'] = gainfilelist[-1]\n            logger.info('Autodetected CASA gainfile %s' % d['gainfile'])\n            bpfilelist.sort()\n            d['bpfile'] = bpfilelist[-1]\n            logger.info('Autodetected CASA bpfile %s' % d['bpfile'])\n\n        # if that fails, look for telcal file\n        filelist = glob.glob(os.path.join(d['workdir'], filename + '.GN'))\n        if not filelist:\n            filelist = glob.glob(filename + '.GN')\n\n        if filelist:\n            d['gainfile'] = filelist[0]\n            logger.info('Autodetected telcal file %s' % d['gainfile'])\n\n        if not os.path.exists(d['gainfile']):\n            logger.warn('Calibration file autodetection failed for gainfile {0}'.format(d['gainfile']))\n\n    # define features\n    d['featureind'] = ['segment', 'int', 'dmind', 'dtind', 'beamnum']  # feature index. should be stable.\n    if 'features' not in d:\n        if d['searchtype'] == 'image1':\n            d['features'] = ['snr1', 'immax1', 'l1', 'm1']   # features returned by image1\n        elif d['searchtype'] == 'image1snip':\n            d['features'] = ['snr1', 'immax1', 'l1', 'm1', 'im40', 'spec20']\n        elif d['searchtype'] == 'image1stats':\n            d['features'] = ['snr1', 'immax1', 'l1', 'm1', 'specstd', 'specskew', 'speckurtosis', 'imskew', 'imkurtosis']  # note: spec statistics are all or nothing.\n        elif 'image2' in d['searchtype']:\n            d['features'] = ['snr1', 'immax1', 'l1', 'm1', 'snr2', 'immax2', 'l2', 'm2']   # features returned by image1\n\n    # set imaging parameters to use\n    if d['uvres'] == 0:\n        d['uvres'] = d['uvres_full']\n    else:\n        urange = d['urange'][scan]*(d['freq'].max()/d['freq_orig'][0])   # uvw from get_uvw already in lambda at ch0\n        vrange = d['vrange'][scan]*(d['freq'].max()/d['freq_orig'][0])\n        powers = n.fromfunction(lambda i,j: 2**i*3**j, (14,10), dtype='int')   # power array for 2**i * 3**j\n        rangex = n.round(d['uvoversample']*urange).astype('int')\n        rangey = n.round(d['uvoversample']*vrange).astype('int')\n        largerx = n.where(powers-rangex/d['uvres'] > 0, powers, powers[-1,-1])\n        p2x, p3x = n.where(largerx == largerx.min())\n        largery = n.where(powers-rangey/d['uvres'] > 0, powers, powers[-1,-1])\n        p2y, p3y = n.where(largery == largery.min())\n        d['npixx_full'] = (2**p2x * 3**p3x)[0]\n        d['npixy_full'] = (2**p2y * 3**p3y)[0]\n\n    # set number of pixels to image\n    d['npixx'] = d['npixx_full']\n    d['npixy'] = d['npixy_full']\n    if 'npix_max' in d:\n        if d['npix_max']:\n            d['npixx'] = min(d['npix_max'], d['npixx_full'])\n            d['npixy'] = min(d['npix_max'], d['npixy_full'])\n    if d['npix']:\n        d['npixx'] = d['npix']\n        d['npixy'] = d['npix']\n    else:\n        d['npix'] = max(d['npixx'], d['npixy'])   # this used to define fringe time\n\n    # define dmarr, if not already\n    if len(d['dmarr']) == 0:\n        if d.has_key('dm_maxloss') and d.has_key('maxdm') and d.has_key('dm_pulsewidth'):\n            d['dmarr'] = calc_dmgrid(d, maxloss=d['dm_maxloss'], maxdm=d['maxdm'], dt=d['dm_pulsewidth'])\n            if d['maxdm'] > 0:\n                logger.info('Calculated %d dms for max sensitivity loss %.2f, maxdm %d pc/cm3, and pulse width %d ms' % (len(d['dmarr']), d['dm_maxloss'], d['maxdm'], d['dm_pulsewidth']/1000))\n        else:\n            d['dmarr'] = [0]\n            logger.info('Can\\'t calculate dm grid without dm_maxloss, maxdm, and dm_pulsewidth defined. Setting to [0].')\n\n    # define times for data to read\n    d['t_overlap'] = rtlib.calc_delay(d['freq'], d['inttime'], max(d['dmarr'])).max()*d['inttime']   # time of overlap for total dm coverage at segment boundaries\n    d['datadelay'] = [rtlib.calc_delay(d['freq'], d['inttime'],dm).max() for dm in d['dmarr']]\n    d['nints'] = d['nints'] - d['nskip']\n\n    # pols\n    if d.has_key('selectpol'):\n        d['pols'] = [pol for pol in d['pols_orig'] if pol in d['selectpol']]\n    else:\n        d['pols'] = d['pols_orig']\n    d['npol'] = len(d['pols'])\n\n    # split imaging into chunks. ideally one per thread, but can modify to fit available memory\n    if d['nchunk'] == 0:\n        d['nchunk'] = d['nthread']\n\n    # if nsegments is 0, then auto-define within memory limit\n    if not d['nsegments']:\n        fringetime = calc_fringetime(d)\n        d['nsegments'] = max(1, min(d['nints'], int(d['scale_nsegments']*d['inttime']*d['nints']/(fringetime-d['t_overlap']))))  # at least 1, at most nints\n        calc_segment_times(d)\n\n        # if auto nsegment definition makes segment too large, try to scale it down to fit in memory_limit (if provided)\n        # limit defined for dm sweep time and max nchunk/nthread ratio\n        if d.has_key('memory_limit'):\n            (vismem0, immem0) = calc_memory_footprint(d, limit=True)\n            assert vismem0+immem0 < d['memory_limit'], 'memory_limit of {0} is smaller than best solution of {1}. Try forcing nsegments/nchunk larger than {2}/{3} or reducing maxdm/npix'.format(d['memory_limit'], vismem0+immem0, d['nsegments'], max(d['dtarr'])/min(d['dtarr']))\n\n            (vismem, immem) = calc_memory_footprint(d)\n            if vismem+immem > d['memory_limit']:\n                logger.info('Over memory limit of {4} when reading {0} segments with {1} chunks ({2}/{3} GB for visibilities/imaging). Searching for solution down to {5}/{6} GB...'.format(d['nsegments'], d['nchunk'], vismem, immem, d['memory_limit'], vismem0, immem0))\n\n            while vismem+immem > d['memory_limit']:\n                (vismem, immem) = calc_memory_footprint(d)\n                logger.debug('Using {0} segments with {1} chunks ({2}/{3} GB for visibilities/imaging). Searching for better solution...'.format(d['nchunk'], vismem, immem, d['memory_limit']))\n                d['scale_nsegments'] = d['scale_nsegments'] * (vismem+immem)/float(d['memory_limit'])\n                d['nsegments'] = max(1, min(d['nints'], int(d['scale_nsegments']*d['inttime']*d['nints']/(fringetime-d['t_overlap']))))  # at least 1, at most nints\n                calc_segment_times(d)\n\n                (vismem, immem) = calc_memory_footprint(d)\n                while vismem+immem > d['memory_limit']:\n                    logger.debug('Doubling nchunk from %d to fit in %d GB memory limit.' % (d['nchunk'], d['memory_limit']))\n                    d['nchunk'] = 2*d['nchunk']\n                    (vismem, immem) = calc_memory_footprint(d)\n                    if d['nchunk'] >= max(d['dtarr'])/min(d['dtarr'])*d['nthread']: # limit nchunk/nthread to at most the range in dt\n                        d['nchunk'] = d['nthread']\n                        break\n\n                (vismem, immem) = calc_memory_footprint(d)\n\n    # final set up of memory\n    calc_segment_times(d)\n    (vismem, immem) = calc_memory_footprint(d)\n\n    # scaling of number of integrations beyond dt=1\n    assert all(d['dtarr']) and (d['dtarr'] == sorted(d['dtarr'])), 'dtarr must be larger than 0 and in increasing order'\n\n    # calculate number of thermal noise candidates per segment\n    nfalse = calc_nfalse(d)\n\n    logger.info('')\n    logger.info('Pipeline summary:')\n    if '.GN' in d['gainfile']:\n        logger.info('\\t Products saved with %s. telcal calibration with %s' % (d['fileroot'], os.path.basename(d['gainfile'])))\n    else:\n        logger.info('\\t Products saved with %s. CASA calibration files (%s, %s)' % (d['fileroot'], os.path.basename(d['gainfile']), os.path.basename(d['bpfile'])))\n    logger.info('\\t Using %d segment%s of %d ints (%.1f s) with overlap of %.1f s' % (d['nsegments'], \"s\"[not d['nsegments']-1:], d['readints'], d['t_segment'], d['t_overlap']))\n    if d['t_overlap'] > d['t_segment']/3.:\n        logger.info('\\t\\t Lots of segments needed, since Max DM sweep (%.1f s) close to segment size (%.2f s)' % (d['t_overlap'], d['t_segment']))\n    logger.info('\\t Downsampling in time/freq by %d/%d and skipping %d ints from start of scan.' % (d['read_tdownsample'], d['read_fdownsample'], d['nskip']))\n    logger.info('\\t Excluding ants %s' % (d['excludeants']))\n    logger.info('\\t Using pols %s' % (d['pols']))\n    logger.info('')\n\n    logger.info('\\t Search with %s and threshold %.1f.' % (d['searchtype'], d['sigma_image1']))\n    logger.info('\\t Using %d DMs from %.1f to %.1f and dts %s.' % (len(d['dmarr']), min(d['dmarr']), max(d['dmarr']), d['dtarr']))\n    logger.info('\\t Using uvgrid npix=(%d,%d) and res=%d.' % (d['npixx'], d['npixy'], d['uvres']))\n    logger.info('\\t Expect %d thermal false positives per segment.' % nfalse)\n\n    logger.info('')\n    logger.info('\\t Visibility memory usage is %.1f GB/segment' % vismem)\n    logger.info('\\t Imaging in %d chunk%s using max of %.1f GB/segment' % (d['nchunk'], \"s\"[not d['nsegments']-1:], immem))\n    logger.info('\\t Grand total memory usage: %.1f GB/segment' % (vismem + immem))\n\n    return d", "response": "Function defines pipeline state for search. Takes data and scan as input."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns name of candsfile for a given dictionary. Must have segment defined.", "response": "def getcandsfile(d, segment=-1, domock=False):\n    \"\"\" Return name of candsfile for a given dictionary. Must have d['segment'] defined.\n    domock is option to save simulated cands.\n    \"\"\"\n    if domock:\n        prefix = 'candsmock_'\n    else:\n        prefix= 'cands_'\n\n    if d.has_key('segment'):\n        return os.path.join(d['workdir'], prefix + d['fileroot'] + '_sc' + str(d['scan']) + 'seg' + str(d['segment']) + '.pkl')\n    elif segment >= 0:\n        return os.path.join(d['workdir'], prefix + d['fileroot'] + '_sc' + str(d['scan']) + 'seg' + str(segment) + '.pkl')\n    else:\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getnoisefile(d, segment=-1):\n    if d.has_key('segment'):\n        return os.path.join(d['workdir'], 'noise_' + d['fileroot'] + '_sc' + str(d['scan']) + 'seg' + str(d['segment']) + '.pkl')\n    elif segment >= 0:\n        return os.path.join(d['workdir'], 'noise_' + d['fileroot'] + '_sc' + str(d['scan']) + 'seg' + str(segment) + '.pkl')\n    else:\n        return ''", "response": "Return name of noisefile for a given dictionary. Must have segment defined."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the number of thermal - noise false positives per segment.", "response": "def calc_nfalse(d):\n    \"\"\" Calculate the number of thermal-noise false positives per segment.\n    \"\"\"\n\n    dtfactor = n.sum([1./i for i in d['dtarr']])    # assumes dedisperse-all algorithm\n    ntrials = d['readints'] * dtfactor * len(d['dmarr']) * d['npixx'] * d['npixy']\n    qfrac = 1 - (erf(d['sigma_image1']/n.sqrt(2)) + 1)/2.\n    nfalse = int(qfrac*ntrials)\n    return nfalse"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calc_memory_footprint(d, headroom=4., visonly=False, limit=False):\n\n    toGB = 8/1024.**3   # number of complex64s to GB\n    d0 = d.copy()\n\n    # limit defined for dm sweep time and max nchunk/nthread ratio\n    if limit:\n        d0['readints'] = d['t_overlap']/d['inttime']\n        d0['nchunk'] = max(d['dtarr'])/min(d['dtarr']) * d['nthread']\n\n    vismem = headroom * datasize(d0) * toGB\n    if visonly:\n        return vismem\n    else:\n        immem = d0['nthread'] * (d0['readints']/d0['nchunk'] * d0['npixx'] * d0['npixy']) * toGB\n        return (vismem, immem)", "response": "Given a pipeline state dict this function calculates the memory required by the pipeline to store visibilities and make images."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calc_fringetime(d):\n\n    maxbl = d['uvres']*d['npix']/2    # fringe time for imaged data only\n    fringetime = 0.5*(24*3600)/(2*n.pi*maxbl/25.)   # max fringe window in seconds\n    return fringetime", "response": "Estimate largest time span of a segment."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef correct_dmdt(d, dmind, dtind, blrange):\n\n    data = numpyview(data_mem, 'complex64', datashape(d))\n    data_resamp = numpyview(data_resamp_mem, 'complex64', datashape(d))\n    bl0,bl1 = blrange\n    data_resamp[:, bl0:bl1] = data[:, bl0:bl1]\n    rtlib.dedisperse_resample(data_resamp, d['freq'], d['inttime'], d['dmarr'][dmind], d['dtarr'][dtind], blrange, verbose=0)", "response": "Resamples data in place."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef correct_dm(d, dm, blrange):\n\n    data = numpyview(data_mem, 'complex64', datashape(d))\n    data_resamp = numpyview(data_resamp_mem, 'complex64', datashape(d))\n    bl0,bl1 = blrange\n    data_resamp[:, bl0:bl1] = data[:, bl0:bl1]\n    rtlib.dedisperse_par(data_resamp, d['freq'], d['inttime'], dm, blrange, verbose=0)", "response": "Dedisperses data into data_resamp\n    Drops edges since it assumes that data is read with overlapping chunks in time."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calc_lm(d, im=[], pix=(), minmax='max'):\n\n    if len(pix) == 0:  # default is to get pixel from image\n        if minmax == 'max':\n            peakl, peakm = n.where(im == im.max())\n        elif minmax == 'min':\n            peakl, peakm = n.where(im == im.min())\n        peakl = peakl[0]; peakm = peakm[0]\n    elif len(pix) == 2:   # can also specify\n        peakl, peakm = pix\n\n    if len(im):\n        npixx, npixy = im.shape\n    else:\n        npixx = d['npixx']\n        npixy = d['npixy']\n\n    l1 = (npixx/2. - peakl)/(npixx*d['uvres'])\n    m1 = (npixy/2. - peakm)/(npixy*d['uvres'])\n\n    return l1, m1", "response": "Helper function to calculate location of image in l m coords."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef move_phasecenter(d, l1, m1, u, v):\n\n    logger.info('Rephasing data to (l, m)=(%.4f, %.4f).' % (l1, m1))\n    data_resamp = numpyview(data_resamp_mem, 'complex64', datashape(d))\n    rtlib.phaseshift_threaded(data_resamp, d, l1, m1, u, v)", "response": "Move data to phase center."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfunction to calculate the DM values for a given maximum sensitivity loss and bin width.", "response": "def calc_dmgrid(d, maxloss=0.05, dt=3000., mindm=0., maxdm=0.):\n    \"\"\" Function to calculate the DM values for a given maximum sensitivity loss.\n    maxloss is sensitivity loss tolerated by dm bin width. dt is assumed pulse width in microsec.\n    \"\"\"\n\n    # parameters\n    tsamp = d['inttime']*1e6  # in microsec\n    k = 8.3\n    freq = d['freq'].mean()  # central (mean) frequency in GHz\n    bw = 1e3*(d['freq'][-1] - d['freq'][0])\n    ch = 1e3*(d['freq'][1] - d['freq'][0])  # channel width in MHz\n\n    # width functions and loss factor\n    dt0 = lambda dm: n.sqrt(dt**2 + tsamp**2 + ((k*dm*ch)/(freq**3))**2)\n    dt1 = lambda dm, ddm: n.sqrt(dt**2 + tsamp**2 + ((k*dm*ch)/(freq**3))**2 + ((k*ddm*bw)/(freq**3.))**2)\n    loss = lambda dm, ddm: 1 - n.sqrt(dt0(dm)/dt1(dm,ddm))\n    loss_cordes = lambda ddm, dfreq, dt, freq: 1 - (n.sqrt(n.pi) / (2 * 6.91e-3 * ddm * dfreq / (dt*freq**3))) * erf(6.91e-3 * ddm * dfreq / (dt*freq**3))  # not quite right for underresolved pulses\n\n    if maxdm == 0:\n        return [0]\n    else:\n        # iterate over dmgrid to find optimal dm values. go higher than maxdm to be sure final list includes full range.\n        dmgrid = n.arange(mindm, maxdm, 0.05)\n        dmgrid_final = [dmgrid[0]]\n        for i in range(len(dmgrid)):\n            ddm = (dmgrid[i] - dmgrid_final[-1])/2.\n            ll = loss(dmgrid[i],ddm)\n            if ll > maxloss:\n                dmgrid_final.append(dmgrid[i])\n\n    return dmgrid_final"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef image1(d, u, v, w, dmind, dtind, beamnum, irange):\n\n    i0, i1 = irange\n    data_resamp = numpyview(data_resamp_mem, 'complex64', datashape(d))\n\n#    logger.info('i0 {0}, i1 {1}, dm {2}, dt {3}, len {4}'.format(i0, i1, dmind, dtind, len(data_resamp)))\n    ims,snr,candints = rtlib.imgallfullfilterxyflux(n.outer(u, d['freq']/d['freq_orig'][0]), n.outer(v, d['freq']/d['freq_orig'][0]), data_resamp[i0:i1], d['npixx'], d['npixy'], d['uvres'], d['sigma_image1'])\n\n#    logger.info('finished imaging candints {0}'.format(candints))\n\n    feat = {}\n    for i in xrange(len(candints)):\n        if snr[i] > 0:\n            l1, m1 = calc_lm(d, ims[i], minmax='max')\n        else:\n            l1, m1 = calc_lm(d, ims[i], minmax='min')\n        logger.info('Got one!  Int=%d, DM=%d, dt=%d: SNR_im=%.1f @ (%.2e,%.2e).' % ((i0+candints[i])*d['dtarr'][dtind], d['dmarr'][dmind], d['dtarr'][dtind], snr[i], l1, m1))\n        candid =  (d['segment'], (i0+candints[i])*d['dtarr'][dtind], dmind, dtind, beamnum)\n\n#        logger.info(candid)\n        \n        # assemble feature in requested order\n        ff = []\n        for feature in d['features']:\n            if feature == 'snr1':\n                ff.append(snr[i])\n            elif feature == 'immax1':\n                if snr[i] > 0:\n                    ff.append(ims[i].max())\n                else:\n                    ff.append(ims[i].min())\n            elif feature == 'l1':\n                ff.append(l1)\n            elif feature == 'm1':\n                ff.append(m1)\n            elif feature == 'im40':  # 40 pixel image peak cutout\n                peakx, peaky = n.where(ims[i] == ims[i].max())\n                sizex, sizey = ims[i].shape\n                # set image window with min=0 and max=size\n                xmin = max(0, peakx - 20); xmax = min(peakx + 20, sizex)   \n                ymin = max(0, peaky - 20); ymax = min(peaky + 20, sizey)\n                ff.append(ims[i][xmin:xmax,ymin:ymax])\n            elif feature == 'spec20':  # 20 int spectrum cutout\n                # set int window with min 0 and max len()\n                imin = max(0, (i0+candints[i])*d['dtarr'][dtind] - 10)\n                imax = min( (i0+candints[i])*d['dtarr'][dtind] + 10, len(data_resamp))\n                data_cut = data_resamp[imin:imax].copy()\n                rtlib.phaseshift_threaded(data_cut, d, l1, m1, u, v)\n                ff.append(data_cut.mean(axis=1))\n            elif feature in ['specstd', 'specskew', 'speckurtosis']:  # this is standard set and must all appear together\n                if feature == 'specstd':  # first this one, then others will use same data\n                    seli = (i0+candints[i])*d['dtarr'][dtind]\n                    datasel = data_resamp[seli:seli+1].copy()\n                    rtlib.phaseshift_threaded(datasel, d, l1, m1, u, v)\n                    data = n.ma.masked_equal(datasel, 0j)\n                    spec = data.mean(axis=3).mean(axis=1).mean(axis=0).real\n                    std = spec.std(axis=0)\n                    ff.append(std)\n                elif feature == 'specskew':\n                    skew = float(mstats.skew(spec))\n                    ff.append(skew)\n                elif feature == 'speckurtosis':\n                    kurtosis = float(mstats.kurtosis(spec))\n                    ff.append(kurtosis)\n            elif feature == 'imskew':\n                skew = float(mstats.skew(ims[i].flatten()))\n                ff.append(skew)\n            elif feature == 'imkurtosis':\n                kurtosis = float(mstats.kurtosis(ims[i].flatten()))\n                ff.append(kurtosis)\n\n        feat[candid] = list(ff)\n    return feat", "response": "Image 1 - stage imaging for single dm"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef image2(d, i0, i1, u, v, w, dmind, dtind, beamnum):\n\n    data_resamp = numpyview(data_resamp_mem, 'complex64', datashape(d))\n    ims,snr,candints = rtlib.imgallfullfilterxy(n.outer(u, d['freq']/d['freq_orig'][0]), n.outer(v, d['freq']/d['freq_orig'][0]), data_resamp[i0:i1], d['npixx'], d['npixy'], d['uvres'], d['sigma_image1'])\n\n    feat = {}\n    for i in xrange(len(candints)):\n        # reimage\n        im2 = rtlib.imgonefullxy(n.outer(u, d['freq']/d['freq_orig'][0]), n.outer(v, d['freq']/d['freq_orig'][0]), data_resamp[i0+candints[i]], d['npixx_full'], d['npixy_full'], d['uvres'], verbose=0)\n\n        # find most extreme pixel\n        snrmax = im2.max()/im2.std()\n        snrmin = im2.min()/im2.std()\n        if snrmax >= abs(snrmin):\n            snr2 = snrmax\n        else:\n            snr2 = snrmin\n        # threshold\n        if abs(snr2) > d['sigma_image2']:\n            # calc loc in first image\n            if snr[i] > 0:\n                l1, m1 = calc_lm(d, ims[i], minmax='max')\n            else:\n                l1, m1 = calc_lm(d, ims[i], minmax='min')\n\n            # calc src loc in second image\n            if snr2 > 0:\n                l2, m2 = calc_lm(d, im2, minmax='max')\n            else:\n                l2, m2 = calc_lm(d, im2, minmax='min')\n            logger.info('Got one!  Int=%d, DM=%d, dt=%d: SNR_im1=%.1f, SNR_im2=%.1f @ (%.2e,%.2e).' % ((i0+candints[i])*d['dtarr'][dtind], d['dmarr'][dmind], d['dtarr'][dtind], snr[i], snr2, l2, m2))\n            candid =  (d['segment'], (i0+candints[i])*d['dtarr'][dtind], dmind, dtind, beamnum)\n\n            # assemble feature in requested order\n            ff = []\n            for feature in d['features']:\n                if feature == 'snr1':\n                    ff.append(snr[i])\n                elif feature == 'immax1':\n                    if snr[i] > 0:\n                        ff.append(ims[i].max())\n                    else:\n                        ff.append(ims[i].min())\n                elif feature == 'l1':\n                    ff.append(l1)\n                elif feature == 'm1':\n                    ff.append(m1)\n                elif feature == 'snr2':\n                    ff.append(snr2)\n                elif feature == 'immax2':\n                    if snr2 > 0:\n                        ff.append(im2.max())\n                    else:\n                        ff.append(im2.min())\n                elif feature == 'l2':\n                    ff.append(l2)\n                elif feature == 'm2':\n                    ff.append(m2)\n\n            feat[candid] = list(ff)\n        else:\n            logger.info('Almost...  Int=%d, DM=%d, dt=%d: SNR_im1=%.1f, SNR_im2=%.1f.' % ((i0+candints[i])*d['dtarr'][dtind], d['dmarr'][dmind], d['dtarr'][dtind], snr[i], snr2))\n\n    return feat", "response": "Image 2 - stage imaging"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef image1wrap(d, u, v, w, npixx, npixy, candint):\n\n    data_resamp = numpyview(data_resamp_mem, 'complex64', datashape(d))\n    image = rtlib.imgonefullxy(n.outer(u, d['freq']/d['freq_orig'][0]), n.outer(v, d['freq']/d['freq_orig'][0]), data_resamp[candint], npixx, npixy, d['uvres'], verbose=1)\n    return image", "response": "Image 1 - wrap the data in a single dm."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef imagearm(sdmfile, scan, segment, npix=512, res=50, **kwargs):\n\n    import sdmpy\n    sdm = sdmpy.SDM(sdmfile)\n    ants = {ant.stationId:ant.name for ant in sdm['Antenna']}\n    stations = {st.stationId: st.name for st in sdm['Station'] if 'X' not in str(st.name)}\n    west = [int(str(ants[st]).lstrip('ea')) for st in stations if 'W' in str(stations[st])]\n    east = [int(str(ants[st]).lstrip('ea')) for st in stations if 'E' in str(stations[st])]\n    north = [int(str(ants[st]).lstrip('ea')) for st in stations if 'N' in str(stations[st])]\n\n    d = set_pipeline(sdmfile, scan, **kwargs)\n    blarr = rtlib.calc_blarr(d)\n    selwest = [i for i in range(len(blarr)) if all([b in west for b in blarr[i]])]\n    seleast = [i for i in range(len(blarr)) if all([b in east for b in blarr[i]])]\n    selnorth = [i for i in range(len(blarr)) if all([b in north for b in blarr[i]])]\n\n    u,v,w = ps.get_uvw_segment(d, segment=segment)\n    data = pipeline_reproduce(d, segment=segment, product='data')\n    dataw = data[:,selwest].mean(axis=3).mean(axis=2)\n    datae = data[:,seleast].mean(axis=3).mean(axis=2)\n    datan = data[:,selnorth].mean(axis=3).mean(axis=2)\n    uw = u[selwest]\n    ue = u[seleast]\n    un = u[selnorth]\n    vw = v[selwest]\n    ve = v[seleast]\n    vn = v[selnorth]\n\n    grid = n.zeros((len(data), npix), dtype='complex64')\n    grid2 = n.zeros((len(data), npix), dtype='float32')\n    datalist = []\n    for (uu, vv, dd) in [(uw, vw, dataw), (ue, ve, datae), (un, vn, datan)]:\n#        uu = n.round(uu/res).astype(int)\n#        vv = n.round(vv/res).astype(int)\n        uu = n.mod(uu/res, npix)\n        vv = n.mod(vv/res, npix)\n        uv = n.sqrt(uu**2 + vv**2)\n        uv = n.round(uv).astype(int)\n        for i in range(len(uv)):\n            if uv[i] < 512:\n                grid[:, uv[i]] = dd[:, i]\n        grid2 = n.fft.ifft(grid, axis=1).real\n        datalist.append(grid2)\n\n    return datalist", "response": "Function to arm - based imaging on a single segment"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsampling one integration and returns image", "response": "def sample_image(d, data, u, v, w, i=-1, verbose=0, imager='xy', wres=100):\n    \"\"\" Samples one integration and returns image\n    i is integration to image. Default is mid int.\n    \"\"\"\n\n    if i == -1:\n        i = len(data)/2\n\n    if imager == 'xy':\n        image = rtlib.imgonefullxy(n.outer(u, d['freq']/d['freq_orig'][0]), n.outer(v, d['freq']/d['freq_orig'][0]), data[i], d['npixx'], d['npixy'], d['uvres'], verbose=verbose)\n    elif imager == 'w':\n        npix = max(d['npixx'], d['npixy'])\n        bls, uvkers = rtlib.genuvkernels(w, wres, npix, d['uvres'], ksize=21, oversample=1)\n        image = rtlib.imgonefullw(n.outer(u, d['freq']/d['freq_orig'][0]), n.outer(v, d['freq']/d['freq_orig'][0]), data[i], npix, d['uvres'], bls, uvkers, verbose=verbose)\n\n#        bls, lmkers = rtlib.genlmkernels(w, wres, npix, d['uvres'])\n#        image = rtlib.imgonefullw(n.outer(u, d['freq']/d['freq_orig'][0]), n.outer(v, d['freq']/d['freq_orig'][0]), data[i], npix, d['uvres'], [bls[0]], [lmkers[0]], verbose=verbose)\n\n    return image"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nestimating noise per bl for a large data array and sigma clips it to find noise per bl for input to detect_bispectra.", "response": "def estimate_noiseperbl(data):\n    \"\"\" Takes large data array and sigma clips it to find noise per bl for input to detect_bispectra.\n    Takes mean across pols and channels for now, as in detect_bispectra.\n    \"\"\"\n    \n    # define noise per baseline for data seen by detect_bispectra or image\n    datamean = data.mean(axis=2).imag                      # use imaginary part to estimate noise without calibrated, on-axis signal\n    (datameanmin, datameanmax) = rtlib.sigma_clip(datamean.flatten())\n    good = n.where( (datamean>datameanmin) & (datamean<datameanmax) )\n    noiseperbl = datamean[good].std()   # measure single noise for input to detect_bispectra\n    logger.debug('Clipped to %d%% of data (%.3f to %.3f). Noise = %.3f.' % (100.*len(good[0])/len(datamean.flatten()), datameanmin, datameanmax, noiseperbl))\n    return noiseperbl"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate noise properties and saves values to pickle.", "response": "def noisepickle(d, data, u, v, w, chunk=200):\n    \"\"\" Calculates noise properties and saves values to pickle.\n    chunk defines window for measurement. at least one measurement always made.\n    \"\"\"\n\n    if d['savenoise']:\n        noisefile = getnoisefile(d)\n\n        if os.path.exists(noisefile):\n            logger.warn('noisefile %s already exists' % noisefile)\n        else:\n            nints = len(data)\n            chunk = min(chunk, nints)  # ensure at least one measurement\n            results = []\n\n            rr = range(0, nints, chunk)\n            if len(rr) == 1: rr.append(1)   # hack. need to make sure it iterates for nints=1 case\n            for i in range(len(rr)-1):\n                imid = (rr[i]+rr[i+1])/2\n                noiseperbl = estimate_noiseperbl(data[rr[i]:rr[i+1]])\n                imstd = sample_image(d, data, u, v, w, imid, verbose=0).std()\n                zerofrac = float(len(n.where(data[rr[i]:rr[i+1]] == 0j)[0]))/data[rr[i]:rr[i+1]].size\n                results.append( (d['segment'], noiseperbl, zerofrac, imstd) )\n\n            with open(noisefile, 'a') as pkl:\n                pickle.dump(results, pkl)\n            logger.info('Wrote %d noise measurement%s to %s.' % (len(results), 's'[:len(results)-1], noisefile))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave all candidates in pkl file for later aggregation and filtering.", "response": "def savecands(d, cands, domock=False):\n    \"\"\" Save all candidates in pkl file for later aggregation and filtering.\n    domock is option to save simulated cands file\n    \"\"\"\n\n    with open(getcandsfile(d, domock=domock), 'w') as pkl:\n        pickle.dump(d, pkl)\n        pickle.dump(cands, pkl)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef numpyview(arr, datatype, shape, raw=False):\n\n    if raw:\n        return n.frombuffer(arr, dtype=n.dtype(datatype)).view(n.dtype(datatype)).reshape(shape)   # for shared mps.RawArray\n    else:\n        return n.frombuffer(arr.get_obj(), dtype=n.dtype(datatype)).view(n.dtype(datatype)).reshape(shape)", "response": "Takes mp shared array and returns numpy array with given shape."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsplits the path into parent and child names.", "response": "def splitpath(self):\n        \"\"\" p.splitpath() -> Return (p.parent, p.name). \"\"\"\n        parent, child = os.path.split(self)\n        return self.__class__(parent), child"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef splitext(self):\n        filename, ext = os.path.splitext(self)\n        return self.__class__(filename), ext", "response": "splitext - Split the filename extension from this path and return the first part of the filename and the extension of the last path segment."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\njoin two or more path components adding a separator character to the end of the path. Returns a new path object.", "response": "def joinpath(self, *args):\n        \"\"\" Join two or more path components, adding a separator\n        character (os.sep) if needed.  Returns a new path\n        object.\n        \"\"\"\n        return self.__class__(os.path.join(self, *args))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef relpath(self):\n        cwd = self.__class__(os.getcwd())\n        return cwd.relpathto(self)", "response": "Return this path as a relative path based from the current working directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef relpathto(self, dest):\n        origin = self.abspath()\n        dest = self.__class__(dest).abspath()\n\n        orig_list = origin.normcase().splitall()\n        # Don't normcase dest!  We want to preserve the case.\n        dest_list = dest.splitall()\n\n        if orig_list[0] != os.path.normcase(dest_list[0]):\n            # Can't get here from there.\n            return dest\n\n        # Find the location where the two paths start to differ.\n        i = 0\n        for start_seg, dest_seg in zip(orig_list, dest_list):\n            if start_seg != os.path.normcase(dest_seg):\n                break\n            i += 1\n\n        # Now i is the point where the two paths diverge.\n        # Need a certain number of \"os.pardir\"s to work up\n        # from the origin to the point of divergence.\n        segments = [os.pardir] * (len(orig_list) - i)\n        # Need to add the diverging part of dest_list.\n        segments += dest_list[i:]\n        if len(segments) == 0:\n            # If they happen to be identical, use os.curdir.\n            relpath = os.curdir\n        else:\n            relpath = os.path.join(*segments)\n        return self.__class__(relpath)", "response": "Return a relative path from self to dest."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef listdir(self, pattern=None):\n        names = os.listdir(self)\n        if pattern is not None:\n            names = fnmatch.filter(names, pattern)\n        return [self / child for child in names]", "response": "A list of items in this directory."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef walk(self, pattern=None, errors='strict'):\n        if errors not in ('strict', 'warn', 'ignore'):\n            raise ValueError(\"invalid errors parameter\")\n\n        try:\n            childList = self.listdir()\n        except Exception:\n            if errors == 'ignore':\n                return\n            elif errors == 'warn':\n                warnings.warn(\n                    \"Unable to list directory '%s': %s\"\n                    % (self, sys.exc_info()[1]),\n                    TreeWalkWarning)\n                return\n            else:\n                raise\n\n        for child in childList:\n            if pattern is None or child.fnmatch(pattern):\n                yield child\n            try:\n                isdir = child.isdir()\n            except Exception:\n                if errors == 'ignore':\n                    isdir = False\n                elif errors == 'warn':\n                    warnings.warn(\n                        \"Unable to access '%s': %s\"\n                        % (child, sys.exc_info()[1]),\n                        TreeWalkWarning)\n                    isdir = False\n                else:\n                    raise\n\n            if isdir:\n                for item in child.walk(pattern, errors):\n                    yield item", "response": "A recursive generator that returns all the files and subdirs of this directory and all its descendants."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef glob(self, pattern):\n        cls = self.__class__\n        return [cls(s) for s in glob.glob(_base(self / pattern))]", "response": "Return a list of path objects that match the pattern."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nopens this file and write the given bytes to it.", "response": "def write_bytes(self, bytes, append=False):\n        \"\"\" Open this file and write the given bytes to it.\n\n        Default behavior is to overwrite any existing file.\n        Call p.write_bytes(bytes, append=True) to append instead.\n        \"\"\"\n        def _write_bytes(bytes, append):\n            if append:\n                mode = 'ab'\n            else:\n                mode = 'wb'\n            f = self.open(mode)\n            try:\n                f.write(bytes)\n            finally:\n                f.close()\n\n        dry(\"write_bytes %s '%r...' append=%r\" % (self, bytes[:20], append),\n            _write_bytes, bytes, append)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_lines(self, lines, encoding=None, errors='strict',\n                    linesep=os.linesep, append=False):\n        r\"\"\" Write the given lines of text to this file.\n\n        By default this overwrites any existing file at this path.\n\n        This puts a platform-specific newline sequence on every line.\n        See 'linesep' below.\n\n        lines - A list of strings.\n\n        encoding - A Unicode encoding to use.  This applies only if\n            'lines' contains any Unicode strings.\n\n        errors - How to handle errors in Unicode encoding.  This\n            also applies only to Unicode strings.\n\n        linesep - The desired line-ending.  This line-ending is\n            applied to every line.  If a line already has any\n            standard line ending ('\\r', '\\n', '\\r\\n', u'\\x85',\n            u'\\r\\x85', u'\\u2028'), that will be stripped off and\n            this will be used instead.  The default is os.linesep,\n            which is platform-dependent ('\\r\\n' on Windows, '\\n' on\n            Unix, etc.)  Specify None to write the lines as-is,\n            like file.writelines().\n\n        Use the keyword argument append=True to append lines to the\n        file.  The default is to overwrite the file.  Warning:\n        When you use this with Unicode data, if the encoding of the\n        existing data in the file is different from the encoding\n        you specify with the encoding= parameter, the result is\n        mixed-encoding data, which can really confuse someone trying\n        to read the file later.\n        \"\"\"\n        if append:\n            mode = 'ab'\n        else:\n            mode = 'wb'\n        f = self.open(mode)\n        try:\n            for line in lines:\n                isUnicode = isinstance(line, unicode)\n                if linesep is not None:\n                    # Strip off any existing line-end and add the\n                    # specified linesep string.\n                    if isUnicode:\n                        if line[-2:] in (u'\\r\\n', u'\\x0d\\x85'):\n                            line = line[:-2]\n                        elif line[-1:] in (u'\\r', u'\\n',\n                                           u'\\x85', u'\\u2028'):\n                            line = line[:-1]\n                    else:\n                        if line[-2:] == '\\r\\n':\n                            line = line[:-2]\n                        elif line[-1:] in ('\\r', '\\n'):\n                            line = line[:-1]\n                    line += linesep\n                if isUnicode:\n                    if encoding is None:\n                        encoding = sys.getdefaultencoding()\n                    line = line.encode(encoding, errors)\n                f.write(line)\n        finally:\n            f.close()", "response": "r Write the given lines of text to the file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_md5(self, hex=False):\n        f = self.open('rb')\n        try:\n            m = hashlib.md5()\n            while True:\n                d = f.read(8192)\n                if not d:\n                    break\n                m.update(d)\n        finally:\n            f.close()\n        if hex:\n            return m.hexdigest()\n        else:\n            return m.digest()", "response": "Calculate the md5 hash for this file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef owner(self):\n        if os.name == 'nt':\n            if win32security is None:\n                raise Exception(\"path.owner requires win32all to be installed\")\n            desc = win32security.GetFileSecurity(\n                self, win32security.OWNER_SECURITY_INFORMATION)\n            sid = desc.GetSecurityDescriptorOwner()\n            account, domain, typecode = win32security.LookupAccountSid(None, sid)\n            return domain + u'\\\\' + account\n        else:\n            if pwd is None:\n                raise NotImplementedError(\"path.owner is not implemented on this platform.\")\n            st = self.stat()\n            return pwd.getpwuid(st.st_uid).pw_name", "response": "r Return the name of the owner of this file or directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ensure_dir(self, mode=0777):\n        if not self.exists() or not self.isdir():\n            os.makedirs(self, mode)", "response": "Make sure the directory exists create if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef install(self, to, chmod=0644):\n        self.copy(to)\n        path(to).chmod(chmod)", "response": "Copy data and set mode to chmod."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(self, paramfile):\n\n        with open(paramfile, 'r') as f:\n            for line in f.readlines():\n                line_clean = line.rstrip('\\n').split('#')[0]   # trim out comments and trailing cr\n                if line_clean and '=' in line:   # use valid lines only\n                    attribute, value = line_clean.split('=')\n                    try:\n                        value_eval = eval(value.strip())\n                    except NameError:\n                        value_eval = value.strip()\n                    finally:\n                        setattr(self, attribute.strip(), value_eval)", "response": "Read parameter file and set parameter values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(self, indexables):\n        try:\n            data = Persistence.read(self.path, create_file=True)\n        except ValueError:\n            data = {}\n\n        return self.load_data(data, indexables)", "response": "Load the index file and reorder the banks based in order listed in indexables"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _process_state_embryo(self, job_record):\n        uow, is_duplicate = self.insert_and_publish_uow(job_record, 0, 0)\n        try:\n            target_state = self._compute_next_job_state(job_record)\n            self.update_job(job_record, uow, target_state)\n        except ValueError:\n            # do no processing for the future timeperiods\n            pass", "response": "method that takes care of processing job records in STATE_EMBRYO state"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register(self, observer):\n        self.observer_manager.append(observer)\n        observer.manager = self", "response": "Register an observer for it be notified when occurs changes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the observers of the observers list. It will not receive any more notifications when occurs changes. :param UpdatesObserver observer: Observer you will not receive any more notifications then occurs changes.", "response": "def unregister(self, observer):\n        \"\"\"\n        Remove the observers of the observers list.\n        It will not receive any more notifications when occurs changes.\n\n        :param UpdatesObserver observer: Observer you will not receive any more notifications then\n                                         occurs changes.\n        \"\"\"\n        self.observer_manager.observers.remove(observer)\n        observer.manager = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _process_state_in_progress(self, job_record):\n        time_qualifier = context.process_context[job_record.process_name].time_qualifier\n        actual_timeperiod = time_helper.actual_timeperiod(time_qualifier)\n        is_job_finalizable = self.timetable.is_job_record_finalizable(job_record)\n        uow = self.uow_dao.get_one(job_record.related_unit_of_work)\n\n        if job_record.timeperiod == actual_timeperiod or is_job_finalizable is False:\n            self.__process_non_finalizable_job(job_record, uow)\n\n        elif job_record.timeperiod < actual_timeperiod and is_job_finalizable is True:\n            self.__process_finalizable_job(job_record, uow)\n\n        else:\n            msg = 'Job {0} has timeperiod {1} from the future vs current timeperiod {2}' \\\n                  .format(job_record.db_id, job_record.timeperiod, actual_timeperiod)\n            self._log_message(ERROR, job_record.process_name, job_record.timeperiod, msg)", "response": "method that takes care of processing job records in STATE_IN_PROGRESS state"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_logger(process_name, append_to_console=None, redirect_stdstream=None):\n    if append_to_console is None:\n        append_to_console = settings.settings['under_test']\n    if redirect_stdstream is None:\n        redirect_stdstream=not settings.settings['under_test']\n\n    if process_name not in logger_pool:\n        file_name = get_log_filename(process_name)\n        log_tag = get_log_tag(process_name)\n        logger_pool[process_name] = Logger(file_name, log_tag,\n                                           append_to_console=append_to_console,\n                                           redirect_stdstream=redirect_stdstream)\n    return logger_pool[process_name].get_logger()", "response": "method returns initiated logger"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_log_tag(process_name):\n    process_obj = context.process_context[process_name]\n    if isinstance(process_obj, FreerunProcessEntry):\n        return str(process_obj.token)\n    elif isinstance(process_obj, ManagedProcessEntry):\n        return str(process_obj.token) + str(process_obj.time_qualifier)\n    elif isinstance(process_obj, DaemonProcessEntry):\n        return str(process_obj.token)\n    else:\n        raise ValueError('Unknown process type: {0}'.format(process_obj.__class__.__name__))", "response": "method returns tag that all messages will be preceded with"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef consume(self, seq):\n        '''Counts all k-mers in sequence.'''\n        for kmer in iter_kmers(seq, self.k, canonical=self.canonical):\n            self._incr(kmer)", "response": "Counts all k - mers in sequence."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncount all kmers in all sequences in a FASTA file.", "response": "def consume_file(self, filename):\n        \"\"\"Counts all kmers in all sequences in a FASTA/FASTQ file.\"\"\"\n        with screed.open(filename) as sequences:\n            for seq in sequences:\n                self.consume(seq['sequence'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsubtract all k - mers in sequence.", "response": "def unconsume(self, seq):\n        '''Subtracts all k-mers in sequence.'''\n        for kmer in iter_kmers(seq, self.k, canonical=self.canonical):\n            self._decr(kmer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reload(self, metadata, ignore_unsupported_plugins=True):\n        supported_plugins = self._supported_plugins\n\n        for plugin in metadata:\n            if not ignore_unsupported_plugins \\\n            or plugin['uri'] in supported_plugins:\n                self._plugins[plugin['uri']] = Lv2Plugin(plugin)", "response": "Reloads the internal list of available audio plugins."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a new Lv2Effect by the valid lv2_uri.", "response": "def build(self, lv2_uri):\n        \"\"\"\n        Returns a new :class:`.Lv2Effect` by the valid lv2_uri\n\n        :param string lv2_uri:\n        :return Lv2Effect: Effect created\n        \"\"\"\n        try:\n            plugin = self._plugins[lv2_uri]\n        except KeyError:\n            raise Lv2EffectBuilderError(\n                \"Lv2EffectBuilder not contains metadata information about the plugin '{}'. \\n\"\n                \"Try re-scan the installed plugins using the reload method::\\n\"\n                \"   >>> lv2_effect_builder.reload(lv2_effect_builder.lv2_plugins_data())\".format(lv2_uri))\n\n        return Lv2Effect(plugin)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _mq_callback(self, message):\n        try:\n            self.logger.info('JobStatusListener {')\n\n            mq_request = MqTransmission.from_json(message.body)\n            job_record = self.job_dao.get_by_id(mq_request.process_name, mq_request.record_db_id)\n\n            # step 1: identify dependant tree nodes\n            tree_obj = self.timetable.get_tree(job_record.process_name)\n            tree_node = tree_obj.get_node(job_record.process_name, job_record.timeperiod)\n            dependant_nodes = self.timetable._find_dependant_tree_nodes(tree_node)\n\n            # step 2: form list of handlers to trigger\n            handlers_to_trigger = set()\n            for node in dependant_nodes:\n                state_machine = self.scheduler.state_machine_for(node.process_name)\n                if state_machine.run_on_active_timeperiod:\n                    # ignore dependant processes whose state machine can run on an active timeperiod\n                    continue\n                handlers_to_trigger.add(self.scheduler.managed_handlers[node.process_name])\n\n            # step 3: iterate the list of handlers and trigger them\n            for handler in handlers_to_trigger:\n                assert isinstance(handler, ManagedThreadHandler)\n                handler.trigger()\n\n        except KeyError:\n            self.logger.error('Access error for {0}'.format(message.body), exc_info=True)\n        except Exception:\n            self.logger.error('Error during ManagedThreadHandler.trigger call {0}'.format(message.body), exc_info=True)\n        finally:\n            self.consumer.acknowledge(message.delivery_tag)\n            self.logger.info('JobStatusListener }')", "response": "This method is called when a message is received from Synergy Scheduler."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self, hostname=None, port=None):\n        if hostname is None:\n            hostname = settings.settings['mx_host']\n        if port is None:\n            port = settings.settings['mx_port']\n\n        reloader = False        # use_reloader: the default setting for the reloader.\n        debugger = False        #\n        evalex = True           # should the exception evaluation feature be enabled?\n        threaded = False        # True if each request is handled in a separate thread\n        processes = 1           # if greater than 1 then handle each request in a new process\n        reloader_interval = 1   # the interval for the reloader in seconds.\n        static_files = None     # static_files: optional dict of static files.\n        extra_files = None      # extra_files: optional list of extra files to track for reloading.\n        ssl_context = None      # ssl_context: optional SSL context for running server in HTTPS mode.\n\n        self.mx_thread = Thread(target=run_simple(hostname=hostname,\n                                                  port=port,\n                                                  application=self,\n                                                  use_debugger=debugger,\n                                                  use_evalex=evalex,\n                                                  extra_files=extra_files,\n                                                  use_reloader=reloader,\n                                                  reloader_interval=reloader_interval,\n                                                  threaded=threaded,\n                                                  processes=processes,\n                                                  static_files=static_files,\n                                                  ssl_context=ssl_context))\n        self.mx_thread.daemon = True\n        self.mx_thread.start()", "response": "Spawns a new HTTP server and starts it."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nappends an item to the end of the list.", "response": "def append(self, item):\n        \"\"\"\n        See :meth:`~pluginsmanager.observer.observable_list.ObservableList.append()` method\n        \"\"\"\n        self.check_insertion(item)\n\n        self.real_list.append(item)\n        self._items |= {item}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove(self, item):\n        self.real_list.remove(item)\n        self._items.remove(item)", "response": "Removes an item from the list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insert(self, index, x):\n        self.check_insertion(x)\n\n        self.real_list.insert(index, x)\n        self._items |= {x}", "response": "Insert a new item into the list at the specified index."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pop(self, index=None):\n        if index is None:\n            index = len(self.real_list) - 1\n\n        effect = self[index]\n        returned = self.real_list.pop(index)\n\n        self._items.remove(effect)\n        return returned", "response": "Removes the item at the specified index from the list. If index is None remove the last item from the list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():\n\n    global _DEBUG_\n    _DEBUG_ = False\n\n    global tpb_url\n    global tpb_categories\n    global transmission_rcp\n    global tvdbapi_tag\n\n    # Init locals variables\n    serie_title = None\n    search_type = None\n    serie_season = \"\"\n    serie_episode = \"\"\n    seeders_min = 0\n    download_tag = False\n    display_all_tag = False\n    hd_tag = False\n    save_torrent_dir = None\n\n    # Manage args\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], \"T:S:t:s:e:l:qdc:p:aiVDhv\")\n    except getopt.GetoptError as err:\n        # Print help information and exit:\n        print(\"Syntax error, %s\" % str(err))\n        sys.exit(2)\n    for opt, arg in opts:\n        if opt in (\"-t\"):\n            try:\n                serie_title = arg\n            except:\n                printVersion()\n                sys.exit(1)\n        elif opt in (\"-s\"):\n            try:\n                serie_season = arg\n            except:\n                printVersion()\n                sys.exit(1)\n        elif opt in (\"-e\"):\n            try:\n                serie_episode = arg\n            except:\n                printVersion()\n                sys.exit(1)\n        elif opt in (\"-l\"):\n            try:\n                seeders_min = int(arg)\n            except:\n                printVersion()\n                sys.exit(1)\n        elif opt in (\"-q\"):\n            hd_tag = True\n        elif opt in (\"-d\"):\n            download_tag = True\n        elif opt in (\"-c\"):\n            transmission_rcp = arg\n        elif opt in (\"-p\"):\n            try:\n                tpb_url = arg\n            except:\n                printVersion()\n                sys.exit(1)\n        elif opt in (\"-a\"):\n            display_all_tag = True\n        elif opt in (\"-i\"):\n            tvdbapi_tag = False\n        elif opt in (\"-h\"):\n            printVersion()\n            printSyntax()\n            sys.exit(0)\n        elif opt in (\"-v\"):\n            printVersion()\n            sys.exit(0)\n        elif opt in (\"-V\"):\n            _DEBUG_ = True\n            # Verbose mode is ON\n            logging.basicConfig(\n                level=logging.INFO,\n                format='%(asctime)s %(levelname)s - %(message)s',\n                datefmt='%d/%m/%Y %H:%M:%S',\n            )\n            logging.debug(\"Verbose mode is ON\")\n        elif opt in (\"-D\"):\n            _DEBUG_ = True\n            # Debug mode is ON\n            logging.basicConfig(\n                level=logging.DEBUG,\n                format='%(asctime)s %(levelname)s - %(message)s',\n                datefmt='%d/%m/%Y %H:%M:%S',\n            )\n            logging.debug(\"Debug mode is ON\")\n        elif opt in (\"-T\"):\n            if arg=='pb' or arg=='t411':\n                search_type=arg\n            else:\n                logging.error('Invalid type of search : t411 (torrent411) or pb (Piracy Bay). ')\n                sys.exit(1)\n        elif opt in (\"-S\"):\n            logging.info('Saving torrent from torrent411 to: %s' % arg)\n            save_torrent_dir = arg\n        # Add others options here...\n        else:\n            printSyntax()\n            sys.exit(1)\n    \n    if (not _DEBUG_):\n        # Set default logging message to ERROR\n        logging.basicConfig(\n            level=logging.ERROR,\n            format='%(asctime)s %(levelname)s - %(message)s',\n            datefmt='%d/%m/%Y %H:%M:%S',\n        )\n\n    logging.info(\"Running %s version %s\" % (__appname__, __version__))\n\n    # Test args\n    if (serie_title is None):\n        # A serie's title is needed... always\n        logging.error(\"Need a serie's title. Use the -t tag.\")\n        sys.exit(1)\n    else:\n        logging.info(\"Search for title %s\" % serie_title)\n    if search_type==None:\n        logging.error(\"Need a type of search : t411 (torrent411) or pb (Piracy Bay). Use the -T tag.\")\n        sys.exit(1)\n    else:\n        if search_type=='pb':\n            logging.info(\"Search on PiracyBay\")\n        else:\n            logging.info(\"Search on torrent411\")\n    if (serie_season != \"\"):\n        # Optionnal season number\n        logging.info(\"Search for season %s\" % serie_season)\n    if (serie_episode != \"\"):\n        # Optionnal episode number\n        logging.info(\"Search for episode %s\" % serie_episode)\n    if (download_tag and not transmissionrpc_tag):\n        logging.error(\"-d tag need the TransmissionRPC Python lib\")\n        sys.exit(1)\n    if (hd_tag):\n        # HD tag is True: search only in the HD category\n        tpb_categories.update(tpb_categories_hd)\n        logging.info(\"Filter HD series\")\n    else:\n        # By default search on all categories (SD and HD)\n        tpb_categories.update(tpb_categories_ld)\n        tpb_categories.update(tpb_categories_hd)\n    if (download_tag and display_all_tag):\n        logging.error(\"-d tag can not be used with the -a tag\")\n        sys.exit(1)\n    if (download_tag and not display_all_tag):\n        logging.info(\"Download mode is ON\")\n        try:\n            transmission_rcp_host, transmission_rcp_port = transmission_rcp.split(':')\n            transmission_rcp_port = int(transmission_rcp_port)\n        except:\n            logging.error(\"Transmission RPC adress should be host:port\")\n            sys.exit(1)\n        else:\n            logging.info(\"Transmission RPC: host=%s / port=%s\" % (transmission_rcp_host, transmission_rcp_port))\n    else:\n        logging.info(\"Download mode is OFF\")\n    if (display_all_tag):\n        logging.info(\"Display all tag is ON\")\n\n    if (tvdbapi_tag):\n        logging.info(\"TVDB API is installed\")\n    else:\n        logging.info(\"TVDB API is not installed\")\n    if (save_torrent_dir and not download_tag):\n        print(\"-S tag need to be used with -d tag\")\n        sys.exit(1)\n\n\n\n    # According to user choice, search in PiracyBay or torrent411\n    if search_type=='pb':    \n        logging.info(\"Piracy Bay URL (use -p to overwrite): %s\" % tpb_url)\n        serie = series_pb(tpb_url = tpb_url, title=serie_title, season=serie_season, episode=serie_episode, seeders_min=seeders_min)\n    else:\n        serie = series_t411(title=serie_title, season=serie_season, episode=serie_episode, seeders_min=seeders_min, directory_download=save_torrent_dir)\n    best = serie.getbest()\n\n    # Display result\n    if (best is not None):\n        if (display_all_tag):\n            logging.info(\"Display all results\")\n            for r in serie.getall():\n                print(\"*\"*79)\n                print(\"Title:   %s\" % r[0])\n                print(\"Seeders: %s\" % r[1])\n                if search_type=='pb':\n                    print(\"Magnet:  %s\" % r[2])\n                else:\n                    print(\"Id:  %s\" % r[2])\n                # print(\"Torrent: %s\" % r[3])\n        else:\n            logging.info(\"Best match is %s\" % best[0])\n            print(\"Title:   %s\" % best[0])\n            print(\"Seeders: %s\" % best[1])\n            if search_type=='pb':\n                print(\"Magnet:  %s\" % best[2])\n            else:\n               print(\"Id:  %s\" % best[2])\n            # print(\"Torrent: %s\" % best[3])\n    else:\n        print(\"No torrent found for %s...\" % serie_title)\n\n    # Download\n    if ((best is not None) and download_tag):\n        uri = None\n        if search_type=='pb':\n            uri = best[2]\n            logging.info(\"Send best magnet to Transmission\")\n            print(\"Uri:  %s\" % uri)\n        \n        try:\n            tc = transmissionrpc.Client(transmission_rcp_host, port=transmission_rcp_port)\n        except:\n            print(\"Error: Can not connect to Transmission (%s:%s)\" % (transmission_rcp_host, transmission_rcp_port))\n            print(\"Info: Transmission remote control access should be enabled on host %s, port %s\" % (transmission_rcp_host, transmission_rcp_port))\n            logging.info(\"Can not connect to Transmission (%s:%s)\" % (transmission_rcp_host, transmission_rcp_port))\n            sys.exit(1)\n        else:\n            logging.debug(\"Transmission connection completed\")\n        try:\n            if search_type=='pb':\n                tc.add_uri(best[2])\n            else:\n                tc.add(serie.downloadbest())\n        except:\n            logging.error(\"Error while sending download request to Transmission\")\n            sys.exit(1)\n        else:\n            print(\"Transmission start downloading...\")\n\n    # End of the game\n    sys.exit(0)", "response": "Main function for the\nearch script."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndefine the regexp used for the search", "response": "def search_regexp(self):\n        \"\"\"\n        Define the regexp used for the search\n        \"\"\"\n        if ((self.season == \"\") and (self.episode == \"\")):\n            regexp = '^%s.*' % self.title.lower()\n        elif (self.episode == \"\"):\n            regexp = '^%s.*(s[0]*%s|season[\\s\\_\\-\\.]*%s).*' % (self.title.lower(), self.season, self.season)\n        else:\n            regexp = '^%s.*((s[0]*%s.*e[0]*%s)|[0]*%sx[0]*%s).*' % (self.title.lower(), self.season, self.episode, self.season, self.episode)\n        return regexp"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef buildlist(self, category=tpb.CATEGORIES.VIDEO.TV_SHOWS, limit=1000):\n\n        try:\n            s = self.source.search(self.title.lower(), limit)\n        except Exception as e:\n            logging.error(\"Can not send search request to the t411 server\")\n            logging.error(e.message)\n            sys.exit(1)\n        \n\n        try:\n            for t in s.items():\n                pass\n        except:\n            logging.error(\"t411 server returned an invalid result\")\n            sys.exit(1)\n\n        torrentlist = []\n        for torrent in s['torrents']:\n            if isinstance(torrent, dict):    \n                #logging.debug(\"Compare regex to: %s\" % t.title.lower())\n                if (re.search(self.regexp, torrent['name'].lower()) and (int(torrent['seeders']) >= self.seeders_min)):\n                    # logging.debug(\"Matched\")\n                    torrentlist.append((torrent['name'], torrent['seeders'], torrent['id']))\n\n        logging.debug(\"Found %d matching items \" % (len(torrentlist)))\n\n        # Return the list\n        return torrentlist", "response": "Build the list of torrents associated with this id"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndefining the regexp used for the search", "response": "def search_regexp(self):\n        \"\"\"\n        Define the regexp used for the search\n        \"\"\"\n        if ((self.season == \"\") and (self.episode == \"\")):\n            # Find serie\n            try:\n                print(\"%s has %s seasons (the serie is %s)\" % (self.tvdb.data['seriesname'], self.tvdb.get_season_number(), self.tvdb.data['status'].lower()))\n                # print self.tvdb.data\n            except:\n                pass\n            regexp = '^%s.*' % self.title.lower()\n        elif (self.episode == \"\"):\n            # Find season\n            try:\n                print(\"%s has %s episodes in season %s\" % (self.tvdb.data['seriesname'], self.tvdb.get_episode_number(int(self.season)), self.season))\n            except:\n                pass\n            regexp = '^%s.*(s[0]*%s|season[\\s\\_\\-\\.]*%s).*' % (self.title.lower(), self.season, self.season)\n        else:\n            # Find season and episode\n            try:\n                print(\"%s S%sE%s name is \\\"%s\\\"\" % (self.tvdb.data['seriesname'], self.season, self.episode, self.tvdb.get_episode(int(self.season), int(self.episode))['episodename']))\n            except:\n                pass\n            regexp = '^%s.*((s[0]*%s.*e[0]*%s)|[0]*%sx[0]*%s).*' % (self.title.lower(), self.season, self.episode, self.season, self.episode)\n        return regexp"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild the list of torrents in the given category", "response": "def buildlist(self, category=tpb.CATEGORIES.VIDEO.TV_SHOWS):\n        \"\"\"\n        Build the torrent list\n        Return list of list sorted by Seeders\n        [[<title>, <Seeders>, <MagnetURL>, <TorrentURL] ...]\n        \"\"\"\n\n        try:\n            s = self.source.search(self.title.lower(), category=category)\n        except:\n            logging.error(\"Can not send search request to the Piracy Bay\")\n            self.__tpb_error_()\n            sys.exit(1)\n\n        logging.info(\"Search %s in the category %s...\" % (self.title.lower(), tpb_categories[category]))\n\n        try:\n            for t in s.items():\n                pass\n        except:\n            logging.error(\"The Piracy Bay return an invalid result\")\n            self.__tpb_error_()\n            sys.exit(1)\n\n        torrentlist = []\n        for t in s.items():\n            # logging.debug(\"Compare regex to: %s\" % t.title.lower())\n            if (re.search(self.regexp, t.title.lower()) and (t.seeders >= self.seeders_min)):\n                # logging.debug(\"Matched\")\n                torrentlist.append((t.title, t.seeders, t.magnet_link, t.torrent_link))\n        logging.debug(\"Found %s matching items in category %s\" % (len(torrentlist), tpb_categories[category]))\n\n        # Return the list\n        return torrentlist"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_bed(fileobj, field_sep=b'\\t', interval_maker=None):\n        '''\n        Initialize a ``GenomeIntervalTree`` from a BED file.\n        Each line of the file must consist of several fields, separated using ``field_sep``.\n        The first three fields are ``chrom``, ``start`` and ``end`` (where ``start`` is 0-based and\n        the corresponding interval is ``[start, end)``). The remaining fields are ``name``, ``score``,\n        ``strand``, ..., or something else, depending on the flavor of the format.\n\n        Each Interval in the tree has its data field set to a list with \"remaining\" fields,\n        i.e. interval.data[0] should be the ``name``, interval.data[1] is the ``score``, etc.\n\n        if the ``interval_maker`` parameter is not None, intervals are created by calling this function with the BED line split into fields as input.\n        The function must return an iterable of ``Interval`` objects.\n\n        Example::\n            >>> test_url = 'http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeAwgTfbsUniform/wgEncodeAwgTfbsBroadDnd41Ezh239875UniPk.narrowPeak.gz'\n            >>> data = zlib.decompress(urlopen(test_url).read(), 16+zlib.MAX_WBITS)\n            >>> gtree = GenomeIntervalTree.from_bed(BytesIO(data))\n            >>> len(gtree)\n            1732\n            >>> assert gtree[b'chr10'].search(22610878) == set([Interval(22610878, 22611813, [b'.', b'1000', b'.', b'471.725544438908', b'-1', b'3.21510858105313', b'389']), Interval(22610878, 22611813, [b'.', b'791', b'.', b'123.885507169449', b'-1', b'3.21510858105313', b'596'])])\n            >>> assert gtree[b'chr10'].search(22611813) == set([])\n            >>> assert gtree[b'chr1'].search(145036590, 145036594) == set([Interval(145036593, 145037123, [b'.', b'247', b'.', b'38.6720804428054', b'-1', b'3.06233123683911', b'265'])])\n            >>> assert gtree[b'chr10'].search(145036594, 145036595) == set([])\n\n        '''\n        # We collect all intervals into a set of lists, and then put them all at once into the tree structures\n        # It is slightly more efficient than adding intervals one by one.\n        # Moreover, the current implementation throws a \"maximum recursion depth exceeded\" error\n        # in this case on large files (TODO)\n\n        interval_lists = defaultdict(list)\n        for ln in fileobj:\n            if ln.endswith(b'\\n'):\n                ln = ln[0:-1]\n            ln = ln.split(field_sep)\n            if interval_maker is not None:\n                for interval in interval_maker(ln):\n                    interval_lists[ln[0]].append(_fix(interval))\n            else:\n                interval_lists[ln[0]].append(_fix(Interval(int(ln[1]), int(ln[2]), data=ln[3:])))\n        gtree = GenomeIntervalTree()\n        for k, v in getattr(interval_lists, 'iteritems', interval_lists.items)():\n            gtree[k] = IntervalTree(v)\n        return gtree", "response": "Initialize a GenomeIntervalTree from a BED file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nform process context entry", "response": "def managed_context_entry(process_name,\n                          classname,\n                          token,\n                          time_qualifier,\n                          trigger_frequency='every 60',\n                          state_machine_name=STATE_MACHINE_DISCRETE,\n                          is_on=True,\n                          exchange=EXCHANGE_MANAGED_WORKER,\n                          blocking_type=BLOCKING_NORMAL,\n                          present_on_boxes=None,\n                          time_grouping=1,\n                          arguments=None,\n                          queue=None,\n                          routing=None,\n                          source=None,\n                          sink=None,\n                          pid_file=None,\n                          log_file=None):\n    \"\"\" forms process context entry \"\"\"\n    _ROUTING_PREFIX = 'routing_'\n    _QUEUE_PREFIX = 'queue_'\n\n    if arguments is not None:\n        assert isinstance(arguments, dict)\n\n    process_entry = ManagedProcessEntry(\n        process_name=process_name,\n        trigger_frequency=trigger_frequency,\n        state_machine_name=state_machine_name,\n        is_on=is_on,\n        blocking_type=blocking_type,\n        classname=classname,\n        token=token,\n        source=source,\n        sink=sink,\n        mq_queue=queue if queue is not None else _QUEUE_PREFIX + token + time_qualifier,\n        mq_routing_key=routing if routing is not None else _ROUTING_PREFIX + token + time_qualifier,\n        mq_exchange=exchange,\n        present_on_boxes=present_on_boxes,\n        arguments=arguments if arguments is not None else dict(),\n        time_qualifier=time_qualifier,\n        time_grouping=time_grouping,\n        log_filename=log_file if log_file is not None else token + time_qualifier + '.log',\n        pid_filename=pid_file if pid_file is not None else token + time_qualifier + '.pid')\n    return process_entry"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate_key(func):\n\n    @wraps(func)\n    def wrapper(self, key, *args, **kwargs):\n        if posixpath.sep in key:\n            raise ValueError('Keys cannot contains slashes')\n\n        return func(self, key, *args, **kwargs)\n\n    return wrapper", "response": "Decorator to validate a key for zookeeper.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef persist(self, key, value):\n        encoded = self.encoding.encode(value)\n        self.__set_or_create(key, encoded)\n        self.__increment_last_updated()", "response": "Encode and save value at key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef depersist(self, key):\n        self.connection.retry(self.connection.delete, self.__path_of(key))\n        self.__increment_last_updated()", "response": "Removes the key from the Zookeeper."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a dictionary of all keys and their values in Zookeeper.", "response": "def durables(self):\n        \"\"\"\n        Dictionary of all keys and their values in Zookeeper.\n        \"\"\"\n        results = dict()\n\n        for child in self.connection.retry(self.connection.get_children, self.keyspace):\n            value, _ = self.connection.retry(\n                self.connection.get,\n                self.__path_of(child),\n                watch=self.__increment_last_updated\n            )\n            results[child] = self.encoding.decode(value)\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a key from the Zookeeper and returns the value. If no key is present in Zookeper or if default is given the value returned is returned. If default is given the value returned is returned. If default is given the value returned is returned.", "response": "def _pop(self, key, default=None):\n        \"\"\"\n        If ``key`` is present in Zookeeper, removes it from Zookeeper and\n        returns the value.  If key is not in Zookeper and ``default`` argument\n        is provided, ``default`` is returned.  If ``default`` argument is not\n        provided, ``KeyError`` is raised.\n\n        :param key: Key to remove from Zookeeper\n        :type key: string\n        :param default: Default object to return if ``key`` is not present.\n        :type default: object\n        \"\"\"\n        path = self.__path_of(key)\n        value = None\n\n        try:\n            # We need to both delete and return the value that was in ZK here.\n            raw_value, _ = self.connection.retry(self.connection.get, path)\n            value = self.encoding.decode(raw_value)\n        except self.no_node_error:\n            # The node is already gone, so if a default is given, return it,\n            # otherwise, raise KeyError\n            if default:\n                return default\n            else:\n                raise KeyError\n\n        # Made it this far, it means have a value from the node and it existed\n        # at least by that point in time\n        try:\n            # Try to delete the node\n            self.connection.retry(self.connection.delete, path)\n            self.__increment_last_updated()\n        except self.no_node_error:\n            # Someone deleted the node in the mean time...how nice!\n            pass\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the value of the key to default.", "response": "def _setdefault(self, key, default=None):\n        \"\"\"\n        If ``key`` is not present, set it as ``default`` and return it.  If\n        ``key`` is present, return its value.\n\n        :param key: Key to add to Zookeeper\n        :type key: string\n        :param default: Default object to return if ``key`` is present.\n        :type default: object\n\n        Will retry trying to get or create a node based on the \"retry\" config\n        from the Kazoo client.\n        \"\"\"\n        return self.connection.retry(self.__inner_set_default, key, default)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __inner_set_default(self, key, value):\n        path = self.__path_of(key)\n\n        try:\n            # Try to get and return the existing node with its data\n            value, _ = self.connection.retry(self.connection.get, path)\n            return self.encoding.decode(value)\n        except self.no_node_error:\n            # Node does not exist, we have to create it\n            self.connection.retry(self.connection.create, path, self.encoding.encode(value))\n            self.__increment_last_updated()\n            return value", "response": "Attempts to return the value at key. If the key does not exist attempts to create it with the value. If the key does exist attempts to get the existing node with the value. If the node does not exist attempts to create it with the value."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints a table of k - mers and counts of observed k - mers.", "response": "def print_table(self, sparse=False, file=None, sep='\\t'):\n        '''\n        Prints a table of k-mer counts\n\n        Parameters\n        ----------\n        sparse: bool\n            Print only observed kmers\n        file: IO object\n            Print to `file`\n        sep: str\n            Separate k-mers and their counts with `sep`\n        '''\n\n        for kmer, count in sorted(self.to_dict(sparse=sparse).items()):\n            print(kmer, count, sep=sep, file=file)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unregister_dependent_on(self, tree):\n        if tree in self.dependent_on:\n            self.dependent_on.remove(tree)", "response": "unregistering tree that we are dependent on"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nuse by _get_next_child_node to find next possible parent node.", "response": "def _get_next_parent_node(self, parent):\n        \"\"\" Used by _get_next_child_node, this method is called to find next possible parent.\n            For example if timeperiod 2011010200 has all children processed, but is not yet processed itself\n            then it makes sense to look in 2011010300 for hourly nodes \"\"\"\n        grandparent = parent.parent\n        if grandparent is None:\n            # here, we work at yearly/linear level\n            return None\n\n        parent_siblings = list(grandparent.children)\n        sorted_keys = sorted(parent_siblings)\n        index = sorted_keys.index(parent.timeperiod)\n        if index + 1 >= len(sorted_keys):\n            return None\n        else:\n            return grandparent.children[sorted_keys[index + 1]]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_next_child_node(self, parent):\n        children_keys = list(parent.children)\n        sorted_keys = sorted(children_keys)\n        for key in sorted_keys:\n            node = parent.children[key]\n            if node.job_record is None:\n                self.timetable.assign_job_record(node)\n                return node\n            elif self.should_skip_tree_node(node):\n                continue\n            elif node.job_record.is_active:\n                return node\n\n        # special case, when all children of the parent node are not suitable for processing\n        new_parent = self._get_next_parent_node(parent)\n        if new_parent is not None:\n            # in case all nodes are processed or blocked - look for next valid parent node\n            return self._get_next_child_node(new_parent)\n        else:\n            # if all valid parents are exploited - return current node\n            process_name = parent.children[sorted_keys[0]].process_name\n            time_qualifier = parent.children[sorted_keys[0]].time_qualifier\n            actual_timeperiod = time_helper.actual_timeperiod(time_qualifier)\n            return self.get_node(process_name, actual_timeperiod)", "response": "This method returns the next child node that can be processed or blocked."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_next_node(self, time_qualifier):\n        hierarchy_entry = self.process_hierarchy.get_by_qualifier(time_qualifier)\n        if hierarchy_entry.parent:\n            parent_time_qualifier = hierarchy_entry.parent.process_entry.time_qualifier\n            parent = self._get_next_node(parent_time_qualifier)\n        else:\n            parent = self.root\n\n        return self._get_next_child_node(parent)", "response": "Method returns the next suitable node for processing\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef should_skip_tree_node(self, node):\n        # case 1: node processing is complete\n        if node.job_record.is_finished:\n            return True\n\n        # case 2: this is a bottom-level leaf node. retry this node for MAX_NUMBER_OF_FAILURES\n        if node.process_name == self.process_hierarchy.bottom_process.process_name:\n            if len(node.children) == 0:\n                # no children - this is a leaf\n                return node.job_record.number_of_failures > MAX_NUMBER_OF_FAILURES\n\n        # case 3: here we process process_daily, process_monthly and process_yearly that have children\n        # iterate thru children and check if all of them are in STATE_SKIPPED (i.e. no data for parent to process)\n        # if any is still in processing (i.e. has produced some data) - then we can not skip parent of the child node\n        # case 3': consider parent as worth processing (i.e. do not skip) if child's job_record is None\n        all_children_spoiled = True\n        for key, child in node.children.items():\n            if child.job_record is None or \\\n                    (child.job_record.number_of_failures <= MAX_NUMBER_OF_FAILURES\n                     and not child.job_record.is_skipped):\n                all_children_spoiled = False\n                break\n        return all_children_spoiled", "response": "Returns True if the node should be skipped and not included into processing"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_tree(self, rebuild=False):\n\n        time_qualifier = self.process_hierarchy.bottom_process.time_qualifier\n        process_name = self.process_hierarchy.bottom_process.process_name\n        if rebuild or self.build_timeperiod is None:\n            timeperiod = settings.settings['synergy_start_timeperiod']\n        else:\n            timeperiod = self.build_timeperiod\n\n        timeperiod = cast_to_time_qualifier(time_qualifier, timeperiod)\n        actual_timeperiod = time_helper.actual_timeperiod(time_qualifier)\n\n        while actual_timeperiod >= timeperiod:\n            self.get_node(process_name, timeperiod)\n            timeperiod = time_helper.increment_timeperiod(time_qualifier, timeperiod)\n\n        self.build_timeperiod = actual_timeperiod", "response": "method builds tree by iterating from the synergy_start_timeperiod to the current time\n            and inserting corresponding nodes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the next node to process by a process with process_name", "response": "def get_next_node(self, process_name):\n        \"\"\" :return: <AbstractTreeNode> next node to process by a process with process_name \"\"\"\n        if process_name not in self.process_hierarchy:\n            raise ValueError('unable to compute the next_node due to unknown process: {0}'.format(process_name))\n\n        time_qualifier = self.process_hierarchy[process_name].process_entry.time_qualifier\n        return self._get_next_node(time_qualifier)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the job record property for a tree node associated with the given Job record.", "response": "def update_node(self, job_record):\n        \"\"\" Updates job record property for a tree node associated with the given Job \"\"\"\n        if job_record.process_name not in self.process_hierarchy:\n            raise ValueError('unable to update the node due to unknown process: {0}'.format(job_record.process_name))\n\n        time_qualifier = self.process_hierarchy[job_record.process_name].process_entry.time_qualifier\n        node = self._get_node(time_qualifier, job_record.timeperiod)\n        node.job_record = job_record"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_node(self, process_name, timeperiod):\n        if process_name not in self.process_hierarchy:\n            raise ValueError('unable to retrieve the node due to unknown process: {0}'.format(process_name))\n\n        time_qualifier = self.process_hierarchy[process_name].process_entry.time_qualifier\n        return self._get_node(time_qualifier, timeperiod)", "response": "Method retrieves a tree node identified by the time_qualifier and timeperiod"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef error_for(response):\n    klass = error_classes.get(response.status)\n    if klass is None:\n        if 400 <= response.status < 500:\n            klass = ClientError\n        if 500 <= response.status < 600:\n            klass = ServerError  # pragma: no cover\n    return klass(response)", "response": "Return the appropriate initialized exception class for a response."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef piper(self, in_sock, out_sock, out_addr, onkill):\n        \"Worker thread for data reading\"\n        try:\n            while True:\n                written = in_sock.recv(32768)\n                if not written:\n                    try:\n                        out_sock.shutdown(socket.SHUT_WR)\n                    except socket.error:\n                        self.threads[onkill].kill()\n                    break\n                try:\n                    out_sock.sendall(written)\n                except socket.error:\n                    pass\n                self.data_handled += len(written)\n        except greenlet.GreenletExit:\n            return", "response": "Worker thread for data reading"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nforming process context entry", "response": "def daemon_context_entry(process_name,\n                         classname,\n                         token,\n                         exchange=EXCHANGE_UTILS,\n                         present_on_boxes=None,\n                         arguments=None,\n                         queue=None,\n                         routing=None,\n                         pid_file=None,\n                         log_file=None):\n    \"\"\" forms process context entry \"\"\"\n    _ROUTING_PREFIX = 'routing_'\n    _QUEUE_PREFIX = 'queue_'\n    _SUFFIX = '_daemon'\n\n    if arguments is not None:\n        assert isinstance(arguments, dict)\n\n    process_entry = DaemonProcessEntry(\n        process_name=process_name,\n        classname=classname,\n        token=token,\n        mq_queue=queue if queue is not None else _QUEUE_PREFIX + token + _SUFFIX,\n        mq_routing_key=routing if routing is not None else _ROUTING_PREFIX + token + _SUFFIX,\n        mq_exchange=exchange,\n        present_on_boxes=present_on_boxes,\n        arguments=arguments if arguments is not None else dict(),\n        log_filename=log_file if log_file is not None else token + _SUFFIX + '.log',\n        pid_filename=pid_file if pid_file is not None else token + _SUFFIX + '.pid')\n    return process_entry"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef timetable_tree_entry(tree_name,\n                         enclosed_processes,\n                         dependent_on=None,\n                         mx_name=None,\n                         mx_page=None):\n    \"\"\" creates timetable context entry \"\"\"\n    assert enclosed_processes is not None and not isinstance(enclosed_processes, string_types)\n    assert dependent_on is not None and not isinstance(dependent_on, string_types)\n\n    timetable_entry = TimetableTreeEntry(tree_name=tree_name,\n                                         enclosed_processes=enclosed_processes,\n                                         dependent_on=dependent_on,\n                                         mx_name=mx_name,\n                                         mx_page=mx_page)\n    return timetable_entry", "response": "creates timetable context entry"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef device_configuration(self, pending=False, use_included=False):\n        device_configs = self.device_configurations(use_included=use_included)\n        for device_config in device_configs:\n            if device_config.is_loaded() is not pending:\n                return device_config\n        return None", "response": "Get a specific device configuration based on a given flag."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndetermines the path to the virtualenv python", "response": "def get_python():\n    \"\"\"Determine the path to the virtualenv python\"\"\"\n    if sys.platform == 'win32':\n        python = path.join(VE_ROOT, 'Scripts', 'python.exe')\n    else:\n        python = path.join(VE_ROOT, 'bin', 'python')\n    return python"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrerun this script within the virtualenv with same args NOTICE : parent process will wait for created subprocess to complete", "response": "def go_to_ve():\n    \"\"\" Rerun this script within the virtualenv with same args\n        NOTICE: parent process will wait for created subprocess to complete \"\"\"\n    # two options are possible\n    if not path.abspath(sys.prefix) == VE_ROOT:\n        # Option A: we are in the parental process that was called from command line like\n        # $> ./launch.py start PROCESS_NAME\n        # in this case sys.prefix points to Global Interpreter\n        python = get_python()\n        retcode = subprocess.call([python, __file__] + sys.argv[1:])\n        sys.exit(retcode)\n    else:\n        # Option B: we have already followed Option A and instantiated Virtual Environment command\n        # This mean that sys.prefix points to Virtual Environment\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef install_virtualenv_p2(root, python_version):\n    try:\n        import virtualenv\n    except ImportError:\n        sys.stdout.write('Installing virtualenv into global interpreter \\n')\n        ret_code = subprocess.call([VE_GLOBAL_SCRIPT, PROJECT_ROOT])\n        sys.stdout.write('Installation finished with code {0}. Re-run ./launch.py install \\n'.format(ret_code))\n        sys.exit(ret_code)\n\n    if path.exists(root):\n        shutil.rmtree(root)\n    virtualenv.logger = virtualenv.Logger(consumers=[])\n    virtualenv.create_environment(root, site_packages=False)\n    ret_code = subprocess.call([VE_SCRIPT, PROJECT_ROOT, root, python_version])\n    sys.exit(ret_code)", "response": "Install virtual environment for Python 2. 7 +"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef install_virtualenv_p3(root, python_version):\n    import venv\n    builder = venv.EnvBuilder(system_site_packages=False, clear=True, symlinks=False, upgrade=False)\n    builder.create(root)\n    ret_code = subprocess.call([VE_SCRIPT, PROJECT_ROOT, root, python_version])\n    sys.exit(ret_code)", "response": "Install virtual environment for Python 3. 3 +"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef install_virtualenv(parser_args):\n    python_version = '.'.join(str(v) for v in sys.version_info[:2])\n    sys.stdout.write('Installing Python {0} virtualenv into {1} \\n'.format(python_version, VE_ROOT))\n    if sys.version_info < (3, 3):\n        install_virtualenv_p2(VE_ROOT, python_version)\n    else:\n        install_virtualenv_p3(VE_ROOT, python_version)", "response": "Installs virtual environment into the virtualenv directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmanage Synergy DB state", "response": "def db_command(parser_args):\n    \"\"\" Manages Synergy DB state \"\"\"\n    from synergy.db.manager import db_manager\n\n    if parser_args.reset:\n        db_manager.reset_db()\n        # initialize DB with the context.process_context entries\n        parser_args.update = True\n\n    if parser_args.update:\n        db_manager.update_db()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start_process(parser_args):\n    import psutil\n    import process_starter\n    from synergy.system import process_helper\n\n    try:\n        pid = process_helper.get_process_pid(parser_args.process_name)\n        if pid is not None:\n            if psutil.pid_exists(pid):\n                message = 'ERROR: Process {0} is already running with pid {1}\\n'.format(parser_args.process_name, pid)\n                sys.stderr.write(message)\n                sys.exit(1)\n\n        if not parser_args.console:\n            # this block triggers if the options.console is not defined or is False\n            process_helper.start_process(parser_args.process_name, parser_args.extra_parameters)\n        else:\n            process_starter.start_by_process_name(parser_args.process_name, parser_args.extra_parameters)\n    except Exception as e:\n        sys.stderr.write('Exception on starting {0} : {1}\\n'.format(parser_args.process_name, e))\n        traceback.print_exc(file=sys.stderr)", "response": "Start up specific daemon"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nputs this decorator before your view to check if the user is logged in via httpauth and return a JSON 401 error if he/she is not.", "response": "def httpauth_login_required(func):\n    \"\"\"\n        Put this decorator before your view to check if the user is logged in\n        via httpauth and return a JSON 401 error if he/she is not.\n    \"\"\"\n\n    def wrapper(request, *args, **kwargs):\n        user = None\n        # get the Basic username and password from the request.\n        auth_string = request.META.get('HTTP_AUTHORIZATION', None)\n\n        if auth_string:\n            (authmeth, auth) = auth_string.split(\" \", 1)\n            auth = auth.strip().decode('base64')\n            (username, password) = auth.split(':', 1)\n\n            # print username, password\n            user = authenticate(username=username, password=password)\n\n        if not user or not user.is_active:\n            return HttpResponse(unauthorized_json_response(),\n                                content_type=\"application/json\", status=401)\n        login(request, user)\n        return func(request, *args, **kwargs)\n\n    return update_wrapper(wrapper, func)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ip_verification_required(func):\n\n    def wrapper(request, *args, **kwargs):\n\n        slug = kwargs.get('slug', \"\")\n        if not slug:\n            return kickoutt_404(\"Not found.\", content_type=\"application/json\")\n\n        try:\n            wip = WriteAPIIP.objects.get(slug=slug)\n            ip = get_client_ip(request)\n            if ip not in wip.allowable_ips() and \"0.0.0.0\" not in wip.allowable_ips():\n                msg = \"The IP %s is not authorized to make the API call.\" % (\n                    ip)\n                return kickout_401(msg)\n\n        except WriteAPIIP.DoesNotExist:\n            return HttpResponse(unauthorized_json_response(),\n                                content_type=\"application/json\")\n\n        return func(request, *args, **kwargs)\n\n    return update_wrapper(wrapper, func)", "response": "Decorator that checks if the function is coming from an IP on file\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall after login decorator.", "response": "def check_public_ok(func):\n    \"\"\"\n        Call after login decorator.\n    \"\"\"\n\n    def wrapper(request, *args, **kwargs):\n        default_to_open = getattr(settings, 'DEFAULT_TO_OPEN_READ', False)\n        database_name = kwargs.get('database_name', \"\")\n        collection_name = kwargs.get('collection_name', \"\")\n        if not default_to_open:\n            if not database_name or not collection_name:\n                return HttpResponse(unauthorized_json_response(),\n                                    content_type=\"application/json\")\n            try:\n                pub_read_api = PublicReadAPI.objects.get(\n                    database_name=database_name, collection_name=collection_name)\n            except PublicReadAPI.DoesNotExist:\n                return HttpResponse(unauthorized_json_response(),\n                                    content_type=\"application/json\")\n\n            # If search keys have been limited...\n            if pub_read_api.search_keys:\n                search_key_list = shlex.split(pub_read_api.search_keys)\n                keys = []\n                for k in request.GET.keys():\n\n                    if k not in search_key_list:\n                        message = \"Search key %s is not allowed.\" % (k)\n\n                        body = {\"code\": 400,\n                                \"message\": k,\n                                \"errors\": [message, ]}\n\n                        return HttpResponse(json.dumps(body, indent=4, ),\n                                            content_type=\"application/json\")\n        return func(request, *args, **kwargs)\n\n    return update_wrapper(wrapper, func)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall after login decorator.", "response": "def check_read_httpauth_access(func):\n    \"\"\"\n        Call after login decorator.\n    \"\"\"\n\n    def wrapper(request, *args, **kwargs):\n        database_name = kwargs.get('database_name', \"\")\n        collection_name = kwargs.get('collection_name', \"\")\n        if not database_name or not collection_name:\n            return HttpResponse(unauthorized_json_response(),\n                                content_type=\"application/json\")\n\n        try:\n            # Check to see if we have a matching record in DB access.\n            dac = HTTPAuthReadAPI.objects.get(\n                database_name=database_name, collection_name=collection_name)\n        except HTTPAuthReadAPI.DoesNotExist:\n            return HttpResponse(unauthorized_json_response(),\n                                content_type=\"application/json\")\n\n        dac_groups = dac.groups.all()\n        user_groups = request.user.groups.all()\n\n       # allowedgroups\n        in_group = False\n        group = None\n        for dg in dac_groups:\n            if dg in user_groups:\n                in_group = True\n                group = dg\n\n        if not in_group:\n            message = \"NOT-IN-GROUP: You do not have access to this collection. Please see your system administrator.\"\n\n            body = {\"code\": 400,\n                    \"message\": message,\n                    \"errors\": [message, ]}\n            return HttpResponse(json.dumps(body, indent=4, ),\n                                content_type=\"application/json\")\n\n        # If search keys have been limitied...\n        if dac.search_keys:\n            search_key_list = shlex.split(dac.search_keys)\n            keys = []\n            for k in request.GET.keys():\n\n                if k not in search_key_list:\n                    message = \"Search key %s  is not allowed.\" % (k)\n\n                    body = {\"code\": 400,\n                            \"message\": k,\n                            \"errors\": [message, ]}\n\n                    return HttpResponse(json.dumps(body, indent=4, ),\n                                        content_type=\"application/json\")\n\n        return func(request, *args, **kwargs)\n\n    return update_wrapper(wrapper, func)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nforms a freerun process context entry", "response": "def freerun_context_entry(process_name,\n                          entry_name,\n                          classname,\n                          token,\n                          trigger_frequency,\n                          is_on=True,\n                          present_on_boxes=None,\n                          description=None,\n                          arguments=None,\n                          exchange=EXCHANGE_FREERUN_WORKER,\n                          queue=None,\n                          routing=None,\n                          pid_file=None,\n                          log_file=None):\n    \"\"\" forms process context entry \"\"\"\n    _ROUTING_PREFIX = 'routing_'\n    _QUEUE_PREFIX = 'queue_'\n    _SUFFIX = '_freerun'\n\n    if arguments is not None:\n        assert isinstance(arguments, dict)\n\n    process_entry = FreerunProcessEntry(\n        process_name=process_name,\n        entry_name=entry_name,\n        trigger_frequency=trigger_frequency,\n        state_machine_name=STATE_MACHINE_FREERUN,\n        is_on=is_on,\n        classname=classname,\n        token=token,\n        present_on_boxes=present_on_boxes,\n        description=description,\n        mq_queue=queue if queue is not None else _QUEUE_PREFIX + token + _SUFFIX,\n        mq_routing_key=routing if routing is not None else _ROUTING_PREFIX + token + _SUFFIX,\n        mq_exchange=exchange,\n        arguments=arguments if arguments is not None else dict(),\n        log_filename=log_file if log_file is not None else token + _SUFFIX + '.log',\n        pid_filename=pid_file if pid_file is not None else token + _SUFFIX + '.pid')\n    return process_entry"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_query(self, query):\n        collection = self.ds.connection(self.collection_name)\n\n        cursor = collection.find(query)\n        if cursor.count() == 0:\n            raise LookupError('Collection {0} has no {1} records'\n                              .format(self.collection_name, self.model_klass.__name__))\n        return [self.model_klass.from_json(entry) for entry in cursor]", "response": "method runs query on a specified collection and returns a list of filtered Model records"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef audio_inputs(self):\n        return self.client.get_ports(is_audio=True, is_physical=True, is_input=True)", "response": "A list of audio inputs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef audio_outputs(self):\n        return self.client.get_ports(is_audio=True, is_physical=True, is_output=True)", "response": "A list of audio output ports."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef midi_inputs(self):\n        return self.client.get_ports(is_midi=True, is_physical=True, is_input=True)", "response": "Returns a list of MIDI inputs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef midi_outputs(self):\n        return self.client.get_ports(is_midi=True, is_physical=True, is_output=True)", "response": "Returns a list of MIDI output ports."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a one to one relation to a given target class.", "response": "def to_one(dest_class, type=RelationType.DIRECT, resource_classes=None,\n           reverse=None, reverse_type=RelationType.DIRECT,\n           writable=False):\n    \"\"\"Create a one to one relation to a given target :class:`Resource`.\n\n    Args:\n\n        dest_class(Resource): The *target* class for the relationship\n\n    Keyword Args:\n\n        type(RelationType): The relationship approach to use.\n        reverse(to_may or to_one): An *optional* reverse relationship.\n        reverse_type(RelationType): The reverse relationship approach.\n        resource_classes(Resource): The kinds of Resources to expect\n            in the relationship\n\n    Returns:\n\n        A builder function which, given a source class creates a\n        one-to-one relationship with the target\n\n    A one to one relationship means that you can get the associated\n    target object from the object on which the ``to_one`` was declared.\n\n    .. code-block:: python\n\n        @to_one(Organization)\n        def User(Resource):\n            pass\n\n    Declares that a User is associated with *one* Organization. The\n    decorator automatically adds a method to fetch the associated\n    organization:\n\n    .. code-block:: python\n\n        org = user.organization()\n\n    \"\"\"\n    def method_builder(cls):\n        dest_resource_type = dest_class._resource_type()\n        dest_method_name = dest_resource_type.replace('-', '_')\n        doc_variables = {\n            'from_class': cls.__name__,\n            'to_class': dest_class.__name__,\n            'to_name': dest_method_name\n        }\n\n        fetch_method_doc = \"\"\"Fetch the {2} associated with this :class:`{0}`.\n\n        Returns:\n\n          {1}: The :class:`{1}` of this :class:`{0}`\n        \"\"\".format(cls.__name__, dest_class.__name__, dest_method_name)\n\n        def _fetch_relationship_included(self):\n            session = self._session\n            include = self._include\n            if include is None or dest_class not in include:\n                # You requested an included relationship that was\n                # not originally included\n                error = \"{} was not included\".format(dest_class.__name__)\n                raise AttributeError(error)\n            included = self._included.get(dest_resource_type)\n            if len(included) == 0:\n                return None\n            mk_one = dest_class._mk_one(session,\n                                        resource_classes=resource_classes)\n            return mk_one({\n                'data': included[0]\n            })\n\n        def fetch_relationship_direct(self, use_included=False):\n            if use_included:\n                return _fetch_relationship_included(self)\n            session = self._session\n            id = None if self.is_singleton() else self.id\n            url = session._build_url(self._resource_path(), id,\n                                     dest_resource_type)\n            process = dest_class._mk_one(session,\n                                         resource_classes=resource_classes)\n            return session.get(url, CB.json(200, process))\n\n        def fetch_relationship_include(self, use_included=False):\n            if use_included:\n                return _fetch_relationship_included(self)\n            session = self._session\n            id = None if self.is_singleton() else self.id\n            url = session._build_url(self._resource_path(), id)\n            params = build_request_include([dest_class], None)\n\n            def _process(json):\n                included = json.get('included')\n                if len(included) == 0:\n                    return None\n\n                mk_one = dest_class._mk_one(session,\n                                            resource_classes=resource_classes)\n                return mk_one({\n                    'data': included[0]\n                })\n            return session.get(url, CB.json(200, _process),\n                               params=params)\n\n        if type == RelationType.DIRECT:\n            fetch_relationship = fetch_relationship_direct\n        elif type == RelationType.INCLUDE:\n            fetch_relationship = fetch_relationship_include\n        else:  # pragma: no cover\n            raise ValueError(\"Invalid RelationType: {}\".format(type))\n\n        fetch_relationship.__doc__ = fetch_method_doc\n\n        def update_method(self, resource):\n            \"\"\"Set the {to_name} for this :class:`{from_class}`.\n\n            Args:\n\n              resource: The :class:`{to_class}` to set\n\n            Returns:\n\n                True if successful\n            \"\"\"\n            session, url, json = _build_relatonship(self, dest_resource_type,\n                                                    resource)\n            return session.patch(url, CB.boolean(200), json=json)\n\n        methods = [(dest_method_name, fetch_relationship)]\n        if writable:\n            methods.extend([\n                ('update_{}'.format(dest_method_name), update_method)\n            ])\n        for name, method in methods:\n            method.__doc__ = method.__doc__.format(**doc_variables)\n            setattr(cls, name, method)\n\n        if reverse is not None:\n            reverse(cls, type=reverse_type)(dest_class)\n\n        return cls\n\n    return method_builder"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_many(dest_class, type=RelationType.DIRECT,\n            reverse=None, reverse_type=RelationType.DIRECT,\n            resource_classes=None, writable=False):\n    \"\"\"Create a one to many relation to a given target :class:`Resource`.\n\n    Args:\n\n        dest_class(Resource): The *target* class for the relationship\n\n    Keyword Args:\n\n        type(RelationType): The relationship approach to use.\n        writable(bool): Whether the relationship is mutable.\n        reverse(to_may or to_one): An *optional* reverse relationship.\n        reverse_type(RelationType): The reverse relationship approach.\n        resource_classes(Resource): The kinds of Resources to expect\n            in the relationship\n\n\n    Returns:\n\n        A builder function which, given a source class creates a\n        one-to-many relationship with the previously supplied target.\n\n    A to-many relationship means that the there are many *dest_class*\n    resources associated with the given source class. The returned\n    method builder will automatically create methods for fetching the\n    associated objects. If the *reverse* function is supplied the\n    builder will create the correponding reverse relationship methods\n    on the target class.\n\n    .. code-block:: python\n\n        @to_many(Sensor, writable=True)\n        class Label:\n            pass\n\n        # find a label, then fetch sensors\n        sensor = label.sensors()\n\n    Since the example above also declares that the relationship is\n    *writable* you can also add, remove and update all target\n    resources from the source object:\n\n    .. code-block:: python\n\n        # fetch a couple of sensors then add them to the label\n        label.add_sensors([sensor1, sensor2])\n\n        # remove a sensor from the label\n        label.remove_sensors([sensor1])\n\n        # remove all sensors from the label\n        label.update_sensors([])\n\n    \"\"\"\n    def method_builder(cls):\n        dest_resource_type = dest_class._resource_type()\n        dest_method_name = pluralize(dest_resource_type).replace('-', '_')\n        doc_variables = {\n            'from_class': cls.__name__,\n            'to_class': dest_class.__name__,\n            'to_name': dest_method_name\n        }\n\n        fetch_method_doc = \"\"\"Fetch the {to_name} associated with this :class:`{from_class}`.\n\n        Returns:\n\n              iterable({to_class}): The {to_name} of :class:`{from_class}`\n        \"\"\"\n\n        def _fetch_relationship_included(self, filter=None):\n            session = self._session\n            include = self._include\n            if include is None or dest_class not in include:\n                # You requested an included relationship that was\n                # not originally included\n                error = \"{} was not included\".format(dest_class.__name__)\n                raise AttributeError(error)\n            included = self._included.get(dest_resource_type)\n            mk_one = dest_class._mk_one(session,\n                                        resource_classes=resource_classes)\n            result = [mk_one({'data': entry}) for entry in included]\n            return result if filter is None else list(_filter(filter, result))\n\n        def fetch_relationship_include(self, use_included=False, filter=None):\n            if use_included:\n                return _fetch_relationship_included(self, filter=filter)\n            session = self._session\n            id = None if self.is_singleton() else self.id\n            url = session._build_url(self._resource_path(), id)\n            params = build_request_include([dest_class], None)\n\n            def _process(json):\n                included = json.get('included')\n                mk_one = dest_class._mk_one(session,\n                                            resource_classes=resource_classes)\n                result = [mk_one({'data': entry}) for entry in included]\n                return result if filter is None else list(_filter(filter, result))\n            return session.get(url, CB.json(200, _process), params=params)\n\n        def fetch_relationship_direct(self, use_included=False, filter=None):\n            if use_included:\n                return _fetch_relationship_included(self)\n            session = self._session\n            id = None if self.is_singleton() else self.id\n            url = session._build_url(self._resource_path(), id,\n                                     dest_resource_type)\n            process = dest_class._mk_many(session,\n                                          resource_classes=resource_classes,\n                                          filter=filter)\n            return session.get(url, CB.json(200, process))\n\n        if type == RelationType.DIRECT:\n            fetch_relationship = fetch_relationship_direct\n        elif type == RelationType.INCLUDE:\n            fetch_relationship = fetch_relationship_include\n        else:  # pragma: no cover\n            raise ValueError(\"Invalid RelationType: {}\".format(type))\n\n        fetch_relationship.__doc__ = fetch_method_doc\n\n        def add_many(self, resources):\n            \"\"\"Add {to_name} to this :class:`{from_class}`.\n\n            Args:\n\n              resources: A list of :class:`{to_class}` to add\n\n            Returns:\n\n                True if the relationship was mutated, False otherwise\n            \"\"\"\n            session, url, json = _build_relatonship(self, dest_resource_type,\n                                                    resources)\n            return session.post(url, CB.boolean(200, false_code=204),\n                                json=json)\n\n        def remove_many(self, resources):\n            \"\"\"Remove {to_name} from this :class:`{from_class}`.\n\n            Args:\n\n              resources: A list of :class:`{to_class}` to remove\n\n            Returns:\n\n                True if the relationship was mutated, False otherwise\n            \"\"\"\n            session, url, json = _build_relatonship(self, dest_resource_type,\n                                                    resources)\n            return session.delete(url, CB.boolean(200, false_code=204),\n                                  json=json)\n\n        def update_method(self, resources):\n            \"\"\"Set the {to_name} for this :class:`{from_class}`.\n\n            To remove all {to_name} pass in an empty list.\n\n            Args:\n\n              resources: A list of :class:`{to_class}` to set\n\n            Returns:\n\n                True if successful\n            \"\"\"\n            session, url, json = _build_relatonship(self, dest_resource_type,\n                                                    resources)\n            return session.patch(url, CB.boolean(200), json=json)\n\n        methods = [(dest_method_name, fetch_relationship)]\n        if writable:\n            methods.extend([\n                ('add_{}'.format(dest_method_name), add_many),\n                ('remove_{}'.format(dest_method_name), remove_many),\n                ('update_{}'.format(dest_method_name), update_method)\n            ])\n        for name, method in methods:\n            method.__doc__ = method.__doc__.format(**doc_variables)\n            setattr(cls, name, method)\n\n        if reverse is not None:\n            reverse(cls, type=reverse_type)(dest_class)\n\n        return cls\n\n    return method_builder", "response": "Creates a method that creates a one to many relation to a given target class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, table_name, primary_key, instance):\n        assert isinstance(primary_key, dict)\n        assert isinstance(instance, BaseDocument)\n        collection = self._db[table_name]\n\n        # work with a copy of the document, as the direct type change of the _id field\n        # is later negated by the `BaseDocument.to_json` method\n        document = instance.document\n        if '_id' in document:\n            document['_id'] = ObjectId(document['_id'])\n\n        update_result = collection.replace_one(filter=primary_key, replacement=document, upsert=True)\n        if update_result.upserted_id:\n            instance['_id'] = update_result.upserted_id\n        return update_result.upserted_id", "response": "Replaces a document identified by the primary_key or creates one if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload the parameters of the effect.", "response": "def _load_params_of(self, effect):\n        \"\"\"\n        Called only when a effect has created\n        Param changes calls :meth:`~pluginsmanager.observer.host_observer.host_observer.HostObserver.on_param_value_changed()`\n        \"\"\"\n        for param in effect.params:\n            if param.value != param.default:\n                self._set_param_value(param)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a message that is sent to the server to connect to the specified source and destination ports.", "response": "def connect(connection):\n        \"\"\"\n        ``connect <origin_port> <destination_port>``\n\n        connect two plugin audio ports\n\n        e.g.::\n\n            connect system:capture_1 plugin_0:in\n\n        :param pluginsmanager.model.connection.Connection connection: Connection with a valid\n               :class:`.Output` and :class:`.Input`\n        \"\"\"\n        return ProtocolParser._connect_message(\n            ProtocolParser._get_out_name_of(connection.output),\n            ProtocolParser._get_in_name_of(connection.input)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string that can be used to disconnect a specific object.", "response": "def disconnect(connection):\n        \"\"\"\n        ``disconnect <origin_port> <destination_port>``\n\n        disconnect two plugin audio ports\n\n        e.g.::\n\n            disconnect system:capture_1 plugin_0:in\n\n        :param pluginsmanager.model.connection.Connection connection: Connection with a valid\n               :class:`.Output` and :class:`.Input`\n        \"\"\"\n        return 'disconnect {} {}'.format(\n            ProtocolParser._get_out_name_of(connection.output),\n            ProtocolParser._get_in_name_of(connection.input)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef param_set(param):\n        instance = param.effect.instance\n\n        return 'param_set {} {} {}'.format(instance, param.symbol, param.value)", "response": "Return a string that can be used to update the value of a parameter in a control set."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef param_get(param):\n        instance = param.effect.instance\n\n        return 'param_get {} {}'.format(instance, param.symbol)", "response": "Return the string that will be passed to the parameter_get function"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a tuple of all connections that this effect is present in the Pedalboard.", "response": "def connections(self):\n        \"\"\"\n        :return list[Connection]: Connections that this effects is present (with input or output port)\n        \"\"\"\n        function = lambda connection: connection.input.effect == self \\\n                                   or connection.output.effect == self\n\n        return tuple([c for c in self.pedalboard.connections if function(c)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef index(self):\n        if self.pedalboard is None:\n            raise IndexError('Effect not contains a pedalboard')\n\n        return self.pedalboard.effects.index(self)", "response": "Returns the index of the effect in your pedalboard"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nforce all models to call full_clean before save", "response": "def pre_save_full_clean_handler(sender, instance, *args, **kwargs):\n    \"\"\" Force all models to call full_clean before save \"\"\"\n    from django.contrib.sessions.models import Session\n    if sender != Session:\n        instance.full_clean()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconfigures the user settings.", "response": "def configure(self, default_settings=global_settings, **options):\n        \"\"\"\n        Called to manually configure the settings. The 'default_settings'\n        parameter sets where to retrieve any unspecified values from (its\n        argument must support attribute access (__getattr__)).\n        \"\"\"\n        if self._wrapped is not empty:\n            raise RuntimeError('Settings already configured.')\n        holder = UserSettingsHolder(default_settings)\n        for name, value in options.items():\n            setattr(holder, name, value)\n        self._wrapped = holder"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload the settings module pointed to by the environment variable.", "response": "def _setup(self):\n        \"\"\"\n        Load the settings module pointed to by the environment variable. This\n        is used the first time we need any settings at all, if the user has not\n        previously configured the settings manually.\n        \"\"\"\n        settings_module = os.environ.get(ENVIRONMENT_SETTINGS_VARIABLE, 'settings')\n        if not settings_module:\n            raise ImproperlyConfigured(\n                'Requested settings module points to an empty variable. '\n                'You must either define the environment variable {0} '\n                'or call settings.configure() before accessing the settings.'\n                .format(ENVIRONMENT_SETTINGS_VARIABLE))\n\n        self._wrapped = Settings(settings_module, default_settings=global_settings)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload the context module pointed to by the environment variable. This is used the first time we need the context at all, if the user has not previously configured the context manually.", "response": "def _setup(self):\n        \"\"\"\n        Load the context module pointed to by the environment variable. This\n        is used the first time we need the context at all, if the user has not\n        previously configured the context manually.\n        \"\"\"\n        context_module = os.environ.get(ENVIRONMENT_CONTEXT_VARIABLE, 'context')\n        if not context_module:\n            raise ImproperlyConfigured(\n                'Requested context points to an empty variable. '\n                'You must either define the environment variable {0} '\n                'or call context.configure() before accessing the context.'\n                .format(ENVIRONMENT_CONTEXT_VARIABLE))\n\n        self._wrapped = Settings(context_module, default_settings=global_context)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the json data in path xid", "response": "def read(path, create_file=False):\n        \"\"\"\n        Reads the json data in path\n\n        :param Path path: Path that json data will be readed\n        :param create_file: Creates the file if it isn't exists\n\n        :return: json data\n        \"\"\"\n        if create_file:\n            with open(str(path), 'a+') as data_file:\n                data_file.seek(0)\n                return json.load(data_file)\n\n        else:\n            with open(str(path)) as data_file:\n                return json.load(data_file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(path, json_data):\n        try:\n            loop = asyncio.get_event_loop()\n            if loop.is_running():\n                asyncio.run_coroutine_threadsafe(Persistence._save(path, json_data), loop)\n            else:\n                loop.run_until_complete(Persistence._save(path, json_data))\n        except AssertionError:\n            Persistence._save(path, json_data)", "response": "Saves json_data in path\n\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_at_subprocess(self, use_subprocess, foo, *args, **kwrags):\n        if use_subprocess is False:\n            return foo(*args, **kwrags)\n\n        child_pid = os.fork()\n        if child_pid == 0:\n            foo(*args, **kwrags)\n            sys.exit(0)\n        return os.waitpid(child_pid, 0)[1] == 0", "response": "This method is used to run some function at subprocess."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform the MapReduce build keys form.", "response": "def build_keys(request, database_name, collection_name):\n    \"\"\"Perform the map/reduce to refresh the keys form.\n       The display the custom report screen\"\"\"\n    build_keys_with_mapreduce(database_name, collection_name)\n    messages.success(request, _(\n        \"Successfully completed MapReduce operation. \"\n        \"Key rebuild for custom report complete.\"))\n    return HttpResponseRedirect(reverse(\"djmongo_show_dbs\"))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_custom_public_read_api(\n        request,\n        database_name,\n        collection_name,\n        slug):\n    \"\"\"Delete CustomPublicReadAPI\"\"\"\n    ss = get_object_or_404(CustomPublicReadAPI, datbase_name=database_name,\n                           collection_name=collection_name, slug=slug)\n    ss.delete()\n    messages.success(request, _(\"Custom Public Read API deleted.\"))\n    return HttpResponseRedirect(\n        reverse('djmongo_show_apis',\n                args=(ss.database_name, ss.collection_name)))", "response": "Delete Custom Public Read API."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_simple_public_read_api(\n        request,\n        database_name,\n        collection_name,\n        slug):\n    \"\"\"Delete Simple PublicReadAPI\"\"\"\n    ss = get_object_or_404(PublicReadAPI, database_name=database_name,\n                           collection_name=collection_name, slug=slug)\n    ss.delete()\n    messages.success(request, _(\"Simple Public Read API deleted.\"))\n    return HttpResponseRedirect(\n        reverse('djmongo_show_apis',\n                args=(ss.database_name, ss.collection_name)))", "response": "Delete Simple Public Read API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_simple_httpauth_read_api(\n        request,\n        database_name,\n        collection_name,\n        slug):\n    \"\"\"Delete Simple PublicReadAPI\"\"\"\n    ss = get_object_or_404(HTTPAuthReadAPI, database_name=database_name,\n                           collection_name=collection_name, slug=slug)\n    ss.delete()\n    messages.success(request, _(\"Simple HTTP Auth Read API deleted.\"))\n    return HttpResponseRedirect(\n        reverse('djmongo_show_apis',\n                args=(ss.database_name, ss.collection_name)))", "response": "Delete Simple HTTP Auth Read API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the next trigger frequency of the event", "response": "def next_trigger_frequency(self, utc_now=None):\n        \"\"\" :param utc_now: optional parameter to be used by Unit Tests as a definition of \"now\"\n            :return: datetime instance presenting next trigger time of the event \"\"\"\n        if utc_now is None:\n            utc_now = datetime.utcnow()\n\n        def wind_days(start_date):\n            while True:\n                if self.day_of_week == EVERY_DAY or start_date.weekday() == int(self.day_of_week):\n                    return start_date.replace(hour=self.time_of_day.hour, minute=self.time_of_day.minute)\n                else:\n                    start_date += timedelta(days=1)\n\n        if utc_now.time() > self.time_of_day.time():\n            return wind_days(utc_now + timedelta(days=1))\n        else:\n            return wind_days(utc_now)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange the interval of the event.", "response": "def change_interval(self, value):\n        \"\"\" :param value: list of strings in format 'Day_of_Week-HH:MM' \"\"\"\n        assert not isinstance(value, string_types)\n        self.timestamps = []\n\n        for timestamp in value:\n            event = EventTime(timestamp)\n            self.timestamps.append(event)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the timedelta instance presenting amount of time before the trigger is triggered next time or None if the EventClock instance is not running", "response": "def next_run_in(self, utc_now=None):\n        \"\"\" :param utc_now: optional parameter to be used by Unit Tests as a definition of \"now\"\n            :return: timedelta instance presenting amount of time before the trigger is triggered next time\n         or None if the EventClock instance is not running \"\"\"\n        if utc_now is None:\n            utc_now = datetime.utcnow()\n\n        if self.is_alive():\n            smallest_timedelta = timedelta(days=99, hours=0, minutes=0, seconds=0, microseconds=0, milliseconds=0)\n            for event_time in self.timestamps:\n                next_trigger = event_time.next_trigger_frequency(utc_now)\n                if next_trigger - utc_now < smallest_timedelta:\n                    smallest_timedelta = next_trigger - utc_now\n            return smallest_timedelta\n\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear(self):\n        collection = self.ds.connection(COLLECTION_MANAGED_PROCESS)\n        return collection.delete_many(filter={})", "response": "removes all documents in this collection"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compute_gzip_md5(file_name):\n    md5 = hashlib.md5()\n    file_obj = gzip.open(file_name, 'rb')\n    for chunk in iter(lambda: file_obj.read(8192), ''):\n        md5.update(chunk)\n\n    file_obj.close()\n    return md5.hexdigest()", "response": "method traverses compressed file and calculates its MD5 checksum"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy_and_sum_families(family_source, family_target):\n    for every in family_source:\n        if every not in family_target:\n            family_target[every] = family_source[every]\n        else:\n            family_target[every] += family_source[every]", "response": "methods iterates thru source family and copies its entries to target family"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_pid_file(process_name):\n    pid_filename = get_pid_filename(process_name)\n    try:\n        with open(pid_filename, mode='w') as pid_file:\n            pid_file.write(str(os.getpid()))\n    except Exception as e:\n        print('Unable to create pid file at: {0}, because of: {1}'.format(pid_filename, e),\n              file=sys.stderr)", "response": "creates pid file and writes os. pid in there"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef host_errors(self, hostname, details):\n        if not hostname or not isinstance(hostname, basestring):\n            return \"hostname_invalid\"\n        if not isinstance(details, list):\n            return \"host_details_not_list\"\n        if len(details) != 3:\n            return \"host_details_wrong_length\"\n        if details[0] not in self.balancer.action_mapping:\n            return \"host_action_invalid:%s\" % details[0]\n        if not isinstance(details[1], dict):\n            return \"host_kwargs_not_dict\"\n        if not isinstance(details[2], bool):\n            return \"host_match_subdomains_not_bool\"\n        return None", "response": "Returns a string describing the error message for a host entry."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_all(self, path, body):\n        \"Replaces the hosts list with the provided input\"\n        # Do some error checking\n        if not isinstance(body, dict):\n            raise HttpBadRequest(\"body_not_a_dict\")\n        for hostname, details in body.items():\n            error = self.host_errors(hostname, details)\n            if error:\n                raise HttpBadRequest(\"%s:%s\" % (hostname, error))\n        # Replace\n        old_hostnames = set(self.balancer.hosts.keys())\n        new_hostnames = set(body.keys())\n        self.balancer.hosts = body\n        # Clean up stats dict\n        for hostname in new_hostnames - old_hostnames:\n            self.balancer.stats[hostname] = {}\n        for hostname in old_hostnames - new_hostnames:\n            try:\n                del self.balancer.stats[hostname]\n            except KeyError:\n                pass\n        return {\"ok\": True}", "response": "Replaces the hosts list with the provided input"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef boolean(cls, true_code, false_code=None):\n        def func(response):\n            if response is not None:\n                status_code = response.status\n                if status_code == true_code:\n                    return True\n                if false_code is not None and status_code == false_code:\n                    return False\n                raise error_for(response)\n        return func", "response": "Returns a callback that checks whether a given response has a status code that is considered good and raises an appropriate error if not."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef json(cls, status_code, process):\n        def func(response):\n            ret = None\n            if cls.boolean(status_code)(response):\n                ret = response.json() or {}\n            return process(ret)\n        return func", "response": "Returns a callback that checks a given response for the given status_code using a function that returns the JSON object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a URL. Args: callback(func): The response callback function Keyword Args: params(dict): Parameters for the request json(dict): JSON body for the request headers(dict): Additional headers for the request Returns: The result of the callback handling the resopnse from the executed request", "response": "def get(self, url, callback,\n            params=None, json=None, headers=None):\n        \"\"\"Get a URL.\n\n        Args:\n\n            callback(func): The response callback function\n\n        Keyword Args:\n\n            params(dict): Parameters for the request\n\n            json(dict): JSON body for the request\n\n            headers(dict): Additional headers for the request\n\n        Returns:\n\n            The result of the callback handling the resopnse from the\n                executed request\n\n        \"\"\"\n        return self.adapter.get(url, callback,\n                                params=params, json=json, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nput to a URL.", "response": "def put(self, url, callback,\n            params=None, json=None, headers=None):\n        \"\"\"Put to a URL.\n\n        Args:\n\n            url(string): URL for the request\n\n            callback(func): The response callback function\n\n        Keyword Args:\n\n            params(dict): Parameters for the request\n\n            json(dict): JSON body for the request\n\n            headers(dict): HTTP headers for the request\n\n        Returns:\n\n            The result of the callback handling the resopnse from the\n                executed request\n\n        \"\"\"\n        return self.adapter.put(url, callback, params=params, json=json)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef patch(self, url, callback,\n              params=None, json=None, headers=None):\n        \"\"\"Patch a URL.\n\n        Args:\n\n            url(string): URL for the request\n\n            callback(func): The response callback function\n\n            headers(dict): HTTP headers for the request\n\n        Keyword Args:\n\n            params(dict): Parameters for the request\n\n            json(dict): JSON body for the request\n\n        Returns:\n\n            The result of the callback handling the resopnse from the\n                executed request\n\n        \"\"\"\n        return self.adapter.patch(url, callback,\n                                  params=params, json=json, headers=headers)", "response": "Patch a URL.\n\n        Args:\n\n            url(string): URL for the request\n\n            callback(func): The response callback function\n\n            headers(dict): HTTP headers for the request\n\n        Keyword Args:\n\n            params(dict): Parameters for the request\n\n            json(dict): JSON body for the request\n\n        Returns:\n\n            The result of the callback handling the resopnse from the\n                executed request"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes a URL. Args: url(string): URL for the request callback(func): The response callback function Keyword Args: json(dict): JSON body for the request Returns: The result of the callback handling the resopnse from the executed request", "response": "def delete(self, url, callback, json=None):\n        \"\"\"Delete a URL.\n\n        Args:\n\n            url(string): URL for the request\n\n            callback(func): The response callback function\n\n        Keyword Args:\n\n            json(dict): JSON body for the request\n\n        Returns:\n\n            The result of the callback handling the resopnse from the\n                executed request\n\n        \"\"\"\n        return self.adapter.delete(url, callback, json=json)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef live(self, url, resource_class, resource_args, params=None):\n        return self.adapter.live(self, url, resource_class, resource_args,\n                                 params=params)", "response": "Get a live endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __touch_and_multi(self, *args, **kwargs):\n\n        with self.connection.pipeline() as pipe:\n            pipe.incr(self.__last_update_key)\n            [getattr(pipe, function)(*a) for function, a in args]\n            results = pipe.execute()\n\n            if kwargs.get('returns'):\n                return results[kwargs.get('returns')]\n            else:\n                return results", "response": "Runs each tuple of redis_cmd args and returns the result of the multi - block command."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading a list of Banks from the data_path.", "response": "def load(self, system_effect):\n        \"\"\"\n        Return a list if banks presents in data_path\n\n        :param SystemEffect system_effect: SystemEffect used in pedalboards\n        :return list[Bank]: List with Banks persisted in\n                :attr:`~pluginsmanager.observer.autosaver.banks_files.BanksFiles.data_path`\n        \"\"\"\n        persistence = PersistenceDecoder(system_effect)\n\n        banks = []\n\n        for file in glob(str(self.data_path) + \"/*.json\"):\n            bank = persistence.read(Persistence.read(file))\n            bank._uuid = file.split('/')[-1].split('.json')[0]\n            banks.append(bank)\n\n        return banks"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_bank(self, bank):\n        path = self._bank_path(bank)\n        Persistence.save(path, bank.json)", "response": "Save the bank in your file\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_bank(self, bank):\n        path = self._bank_path(bank)\n        Persistence.delete(path)", "response": "Delete the file holding the specific bank"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_all_banks(self):\n        for file in glob(str(self.data_path) + \"/*.json\"):\n            Persistence.delete(file)", "response": "Delete all banks files in the data directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract audio interfaces from the audio system.", "response": "def audio_interfaces():\n        \"\"\"\n        Extracts audio interfaces data\n\n        :return list[AudioInterface]: Audio interfaces data\n        \"\"\"\n        p = pyaudio.PyAudio()\n\n        interfaces = []\n        for i in range(p.get_device_count()):\n            data = p.get_device_info_by_index(i)\n            if 'hw' not in data['name']:\n                interfaces.append(AudioInterface(data))\n\n        p.terminate()\n\n        return interfaces"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef latency(self):\n        return {\n            'input': {\n                'min': self.data['defaultLowInputLatency'],\n                'max': self.data['defaultHighInputLatency'],\n            },\n            'output': {\n                'min': self.data['defaultLowOutputLatency'],\n                'max': self.data['defaultHighOutputLatency'],\n            }\n        }", "response": "Return a dict of minimum and maximum latency for input and output channels\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npoll process for status of a process", "response": "def _poll_process(self):\n        \"\"\" between death of a process and its actual termination lies poorly documented requirement -\n            <purging process' io pipes and reading exit status>.\n            this can be done either by os.wait() or process.wait()\n            :return tuple (boolean: alive, int: return_code) \"\"\"\n        try:\n            self.logger.warning(self.cli_process.stderr.read())\n            self.logger.info(self.cli_process.stdout.read())\n            return_code = self.cli_process.wait(timeout=0.01)\n            if return_code is None:\n                # process is already terminated\n                self.logger.info('Process {0} is terminated'.format(self.process_name))\n            else:\n                # process is terminated; possibly by OS\n                self.logger.info('Process {0} got terminated. Cleaning up'.format(self.process_name))\n            self.cli_process = None\n            return False, return_code\n        except TimeoutExpired:\n            # process is alive and OK\n            return True, None\n        except Exception:\n            self.logger.error('Exception on polling: {0}'.format(self.process_name), exc_info=True)\n            return False, 999"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun Aggregation By Slug", "response": "def run_aggregation_by_slug(request, slug):\n    \"\"\"Run Aggregation By Slug\"\"\"\n    sa = get_object_or_404(Aggregation, slug=slug)\n    sa.execute_now = True\n    sa.save()\n    messages.success(request, _(\"Saved aggregation executed.\"))\n    return HttpResponseRedirect(\n        reverse(\n            'djmongo_browse_saved_aggregations_w_params',\n            args=(\n                sa.database_name,\n                sa.collection_name)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete Saved Aggregation By Slug", "response": "def delete_saved_aggregation_by_slug(request, slug):\n    \"\"\"Delete Saved Aggregation By Slug\"\"\"\n    ss = get_object_or_404(Aggregation, slug=slug)\n    ss.delete()\n    messages.success(request, _(\"Saved aggregation deleted.\"))\n    return HttpResponseRedirect(\n        reverse(\n            'djmongo_browse_saved_aggregations_w_params',\n            args=(\n                ss.database_name,\n                ss.collection_name)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_one(self, key):\n        query = {'_id': ObjectId(key)}\n        collection = self.ds.connection(COLLECTION_UNIT_OF_WORK)\n\n        document = collection.find_one(query)\n        if document is None:\n            msg = 'UOW with ID={0} was not found'.format(key)\n            self.logger.warning(msg)\n            raise LookupError(msg)\n        return UnitOfWork.from_json(document)", "response": "method finds a unit_of_work record and returns it to the caller"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_reprocessing_candidates(self, since=None):\n        collection = self.ds.connection(COLLECTION_UNIT_OF_WORK)\n\n        query = {unit_of_work.STATE: {'$in': [unit_of_work.STATE_IN_PROGRESS,\n                                              unit_of_work.STATE_INVALID,\n                                              unit_of_work.STATE_REQUESTED]},\n                 unit_of_work.UNIT_OF_WORK_TYPE: unit_of_work.TYPE_MANAGED}\n\n        if since is None:\n            cursor = collection.find(query).sort('_id', ASCENDING)\n            candidates = [UnitOfWork.from_json(document) for document in cursor]\n        else:\n            candidates = []\n            yearly_timeperiod = time_helper.cast_to_time_qualifier(QUALIFIER_YEARLY, since)\n            query[unit_of_work.START_TIMEPERIOD] = {'$gte': yearly_timeperiod}\n\n            cursor = collection.find(query).sort('_id', ASCENDING)\n            for document in cursor:\n                uow = UnitOfWork.from_json(document)\n                if uow.process_name not in context.process_context:\n                    # this is a decommissioned process\n                    continue\n\n                time_qualifier = context.process_context[uow.process_name].time_qualifier\n                if time_qualifier == QUALIFIER_REAL_TIME:\n                    time_qualifier = QUALIFIER_HOURLY\n                process_specific_since = time_helper.cast_to_time_qualifier(time_qualifier, since)\n\n                if process_specific_since <= uow.start_timeperiod:\n                    candidates.append(uow)\n\n        if len(candidates) == 0:\n            raise LookupError('MongoDB has no UOW reprocessing candidates')\n        return candidates", "response": "method queries Unit Of Work whose start_timeperiod is younger than since and returns a list of UnitOfWork objects that can be re - processed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_by_params(self, process_name, timeperiod, start_id, end_id):\n        query = {unit_of_work.PROCESS_NAME: process_name,\n                 unit_of_work.TIMEPERIOD: timeperiod,\n                 unit_of_work.START_ID: start_id,\n                 unit_of_work.END_ID: end_id}\n        collection = self.ds.connection(COLLECTION_UNIT_OF_WORK)\n\n        document = collection.find_one(query)\n        if document is None:\n            raise LookupError('UOW satisfying query {0} was not found'.format(query))\n        return UnitOfWork.from_json(document)", "response": "method finds a unit_of_work record and returns it to the caller"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, instance):\n        assert isinstance(instance, UnitOfWork)\n        if instance.db_id:\n            query = {'_id': ObjectId(instance.db_id)}\n        else:\n            query = {unit_of_work.PROCESS_NAME: instance.process_name,\n                     unit_of_work.TIMEPERIOD: instance.timeperiod,\n                     unit_of_work.START_ID: instance.start_id,\n                     unit_of_work.END_ID: instance.end_id}\n        self.ds.update(COLLECTION_UNIT_OF_WORK, query, instance)\n        return instance.db_id", "response": "method updates the status of a unit_of_work record"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninserting a unit of work into MongoDB", "response": "def insert(self, instance):\n        \"\"\" inserts a unit of work into MongoDB.\n        :raises DuplicateKeyError: if such record already exist \"\"\"\n        assert isinstance(instance, UnitOfWork)\n        collection = self.ds.connection(COLLECTION_UNIT_OF_WORK)\n        try:\n            return collection.insert_one(instance.document).inserted_id\n        except MongoDuplicateKeyError as e:\n            exc = DuplicateKeyError(instance.process_name,\n                                    instance.start_timeperiod,\n                                    instance.start_id,\n                                    instance.end_id,\n                                    e)\n            raise exc"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef recover_from_duplicatekeyerror(self, e):\n        if isinstance(e, DuplicateKeyError):\n            try:\n                return self.get_by_params(e.process_name, e.timeperiod, e.start_id, e.end_id)\n            except LookupError as e:\n                self.logger.error('Unable to recover from DuplicateKeyError error due to {0}'.format(e), exc_info=True)\n        else:\n            msg = 'Unable to recover from DuplicateKeyError due to unspecified UOW primary key'\n            self.logger.error(msg)", "response": "method tries to recover from DuplicateKeyError error"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef thread_safe(method):\n\n    @functools.wraps(method)\n    def _locker(self, *args, **kwargs):\n        assert hasattr(self, 'lock'), \\\n            'thread_safe decorator applied to method {0}.{1}: missing required field {0}.lock'\\\n            .format(self.__class__.__name__, method.__name__)\n\n        try:\n            self.lock.acquire()\n            return method(self, *args, **kwargs)\n        finally:\n            try:\n                self.lock.release()\n            except:\n                sys.stderr.write('Exception on releasing lock at method {0}'.format(method.__name__))\n                traceback.print_exc(file=sys.stderr)\n\n    return _locker", "response": "Decorator for thread - safe methods."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef with_reconnect(func):\n    from pymongo.errors import AutoReconnect\n\n    @functools.wraps(func)\n    def _reconnector(*args, **kwargs):\n        for _ in range(20):\n            try:\n                return func(*args, **kwargs)\n            except AutoReconnect:\n                time.sleep(0.250)\n        raise\n\n    return _reconnector", "response": "Decorator for creating a reconnector function that will raise AutoReconnect exceptions."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a function that creates a new instance of the class", "response": "def singleton(cls):\n    \"\"\"\n    turns class to singleton\n    :param cls: class itself\n    :return: function that either creates new instance of the class or returns existing one\n    \"\"\"\n\n    # the only way to implement nonlocal closure variables in Python 2.X\n    instances = {}\n\n    def get_instance():\n        if cls not in instances:\n            instances[cls] = cls()\n        return instances[cls]\n\n    return get_instance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef attach(self):\n        log_recording = LogRecording(parent_object_id=self.parent_object_id, created_at=datetime.utcnow())\n        self.log_recording_dao.remove(self.parent_object_id)\n        self.log_recording_dao.update(log_recording)\n\n        formatter = logging.Formatter(fmt='%(asctime)s %(levelname)-8s %(message)s',\n                                      datefmt='%Y-%m-%d %H:%M:%S')\n        self.setFormatter(formatter)\n        self.logger.addHandler(self)", "response": "method creates a new log_recorder entry for given parent_object_id creates a new one and attaches this handler to the logger"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfires API Call for named method.", "response": "def _make_api_call(self, api_method, **kwargs):\n        '''Fire API Call for named method.\n        '''\n        api_url = '/'.join((self.api_base_url, api_method))\n        parameters = dict()\n        parameters.update(self.default_parameters)\n        parameters.update(kwargs)\n        post_params = urlencode(parameters).encode('utf-8')\n        response = self.opener.open(api_url, post_params)\n        return json.loads(response.read().decode('utf-8'))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of the DROP TABLE SQL then the CREATE TABLE SQL for the given module.", "response": "def sql_reset(app, style, connection):\n    \"Returns a list of the DROP TABLE SQL, then the CREATE TABLE SQL, for the given module.\"\n    return sql_delete(app, style, connection) + sql_all(app, style, connection)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _mq_callback(self, message):\n        try:\n            self.logger.info('UowStatusListener {')\n\n            mq_request = MqTransmission.from_json(message.body)\n            uow = self.uow_dao.get_one(mq_request.record_db_id)\n            if uow.unit_of_work_type != unit_of_work.TYPE_MANAGED:\n                self.logger.info('Received transmission from non-managed UOW execution: {0}. Ignoring it.'\n                                 .format(uow.unit_of_work_type))\n                return\n\n            tree = self.timetable.get_tree(uow.process_name)\n            node = tree.get_node(uow.process_name, uow.timeperiod)\n\n            if uow.db_id != node.job_record.related_unit_of_work:\n                self.logger.info('Received transmission is likely outdated. Ignoring it.')\n                return\n\n            if not uow.is_finished:\n                # rely on Garbage Collector to re-trigger the failing unit_of_work\n                self.logger.info('Received transmission from {0}@{1} in non-final state {2}. Ignoring it.'\n                                 .format(uow.process_name, uow.timeperiod, uow.state))\n                return\n\n            state_machine = self.scheduler.state_machine_for(node.process_name)\n            self.logger.info('Commencing StateMachine.notify with UOW from {0}@{1} in {2}.'\n                             .format(uow.process_name, uow.timeperiod, uow.state))\n            state_machine.notify(uow)\n\n        except KeyError:\n            self.logger.error('Access error for {0}'.format(message.body), exc_info=True)\n        except Exception:\n            self.logger.error('Error during StateMachine.notify call {0}'.format(message.body), exc_info=True)\n        finally:\n            self.consumer.acknowledge(message.delivery_tag)\n            self.logger.info('UowStatusListener }')", "response": "This method processes messages from Synergy Worker and updates corresponding Timetable record and the job itself."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles payment received and respond with a dictionary", "response": "def process_lipisha_payment(request):\n    \"\"\"Handle payment received and respond with a dictionary\"\"\"\n    log.debug(request.POST)\n    schema = LipishaInitiateSchema\n    api_type = request.POST.get('api_type')\n    if api_type == TYPE_ACKNOWLEDGE:\n        schema = LipishaAcknowledgeSchema\n    form = Form(request, schema())\n    transaction_status_code = STATUS_SUCCESS\n    transaction_status = 'Processed'\n    transaction_status_description = 'Processed'\n    if form.validate():\n        if api_type == TYPE_INITIATE:\n            # Process new payment\n            pass\n        elif api_type == TYPE_ACKNOWLEDGE:\n            if form.data.get('transaction_status_code') == STATUS_SUCCESS:\n                # Process successful accknowledgement\n                pass\n            else:\n                log.error('Invalid payment acknowledgement')\n                log.error(request.POST)\n    else:\n        log.error(\"Error while processing payment\")\n        for error in form.all_errors():\n            log.error(error)\n        transaction_status_code = STATUS_INITIATE_FAILURE\n        transaction_status = 'Error'\n        transaction_status_description = 'Error while processing'\n    if api_type == TYPE_INITIATE:\n        data = request.POST\n        return dict(\n            api_key=LIPISHA_API_KEY,\n            api_signature=LIPISHA_API_SIGNATURE,\n            api_version=data.get('api_version'),\n            api_type=TYPE_RECEIPT,\n            transaction_reference=data.get('transaction_reference'),\n            transaction_status_code=transaction_status_code,\n            transaction_status=transaction_status,\n            transaction_status_description=transaction_status_description,\n        )\n    return {}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprocess lipisha IPN - Initiate or Acknowledge", "response": "def lipisha_ipn(self):\n        \"\"\"Process lipisha IPN - Initiate/Acknowledge\"\"\"\n        if not (self.request.POST.get('api_key') == LIPISHA_API_KEY and\n                self.request.POST.get('api_signature') == LIPISHA_API_SIGNATURE):\n            raise HTTPBadRequest\n        return process_lipisha_payment(self.request)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate(self):\n\n        # step 1: request Job record if current one is not set\n        if self.job_record is None:\n            self.tree.timetable.assign_job_record(self)\n\n        # step 2: define if current node has a younger sibling\n        next_timeperiod = time_helper.increment_timeperiod(self.time_qualifier, self.timeperiod)\n        has_younger_sibling = next_timeperiod in self.parent.children\n\n        # step 3: define if all children are done and if perhaps they all are in STATE_SKIPPED\n        all_children_skipped = True\n        all_children_finished = True\n        for timeperiod, child in self.children.items():\n            child.validate()\n\n            if child.job_record.is_active:\n                all_children_finished = False\n            if not child.job_record.is_skipped:\n                all_children_skipped = False\n\n        # step 4: request this node's reprocessing if it is enroute to STATE_PROCESSED\n        # while some of its children are still performing processing\n        if all_children_finished is False and self.job_record.is_finished:\n            self.tree.timetable.reprocess_tree_node(self)\n\n        # step 5: verify if this node should be transferred to STATE_SKIPPED\n        # algorithm is following:\n        # point a: node must have children\n        # point b: existence of a younger sibling means that the tree contains another node of the same level\n        # thus - should the tree.build_timeperiod be not None - the children level of this node is fully constructed\n        # point c: if all children of this node are in STATE_SKIPPED then we will set this node state to STATE_SKIPPED\n        if len(self.children) != 0 \\\n                and all_children_skipped \\\n                and self.tree.build_timeperiod is not None \\\n                and has_younger_sibling is True \\\n                and not self.job_record.is_skipped:\n            self.tree.timetable.skip_tree_node(self)", "response": "method performs basic validation of the tree node"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_log_entry(self, entry):\n        event_log = self.job_record.event_log\n        if len(event_log) > job.MAX_NUMBER_OF_EVENTS:\n            del event_log[-1]\n        event_log.insert(0, entry)", "response": "Adds a log entry to the event log."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_counterpart_in(self, tree_b):\n\n        tree_b_hierarchy_entry = tree_b.process_hierarchy.get_by_qualifier(self.time_qualifier)\n        if not tree_b_hierarchy_entry:\n            # special case when tree with more levels depends on the tree with smaller amount of levels\n            # for example ThreeLevel Financial tree depends on TwoLevel Google Channel\n            # in this case - we just verify time-periods that matches in both trees;\n            # for levels that have no match, we assume that dependency does not exists\n            # for example Financial Monthly has no counterpart in Google Daily Report -\n            # so we assume that its not blocked\n            node_b = None\n        else:\n            node_b = tree_b.get_node(tree_b_hierarchy_entry.process_entry.process_name, self.timeperiod)\n\n        return node_b", "response": "Finds a TreeNode counterpart for this node in tree_b that has the same timeperiod as self. timeperiod and returns that TreeNode."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dependent_on_composite_state(self):\n        composite_state = NodesCompositeState()\n\n        for dependent_on in self.tree.dependent_on:\n            node_b = self.find_counterpart_in(dependent_on)\n\n            if node_b is None:\n                # special case when counterpart tree has no process with corresponding time_qualifier\n                # for example Financial Monthly has no counterpart in Third-party Daily Report -\n                # so we assume that its not blocked\n                continue\n\n            composite_state.enlist(node_b)\n\n        return composite_state", "response": "method iterates over all nodes that provide dependency to the current node and compile composite state of them"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new database and collection by inserting one document.", "response": "def create_mongo_db(database_name, collection_name, initial_document):\n    \"\"\"Create a new database and collection by inserting one document.\"\"\"\n    response_dict = {}\n    try:\n        mongodb_client_url = getattr(settings, 'MONGODB_CLIENT',\n                                 'mongodb://localhost:27017/')\n        mc = MongoClient(mongodb_client_url,document_class=OrderedDict)\n\n        db = mc[str(database_name)]\n        collection = db[str(collection_name)]\n\n        d = json.loads(initial_document, object_pairs_hook=OrderedDict)\n\n        collection.save(d)\n\n    except:\n        # error connecting to mongodb\n        response_dict['error'] = str(sys.exc_info())\n\n    return response_dict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_dbs():\n\n    l = []\n    mc = client_connector()\n    if not mc:\n        # The client couldn't connect\n        return ()\n\n    dbs = mc.database_names()\n    for d in dbs:\n        dbc = mc[d]\n        collections = dbc.collection_names()\n        collections = remove_values_from_list(collections, \"system.indexes\")\n        l.append({\"name\": d, \"collections\": collections})\n    return tuple(l)", "response": "return a list of all dbs and related collections"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbrowses IP - based authentication for Write APIs.", "response": "def browse_ip_write_apis(request, database_name=None, collection_name=None):\n    \"\"\"Deprecated\"\"\"\n    name = \"Write APIs Using IP-based Authentication\"\n    if database_name and collection_name:\n        wapis = WriteAPIIP.objects.filter(\n            database_name=database_name,\n            collection_name=collection_name)\n    else:\n        wapis = WriteAPIIP.objects.all()\n    context = {'name': name, 'wapis': wapis,\n               'database_name': database_name,\n               'collection_name': collection_name}\n    return render(\n        request,\n        'djmongo/console/browse-ip-write-apis.html',\n        context)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef browse_httpauth_write_apis(\n        request,\n        database_name=None,\n        collection_name=None):\n    \"\"\"Deprecated\"\"\"\n    name = \"Write APIs Using HTTPAuth Authentication\"\n    if database_name and collection_name:\n        wapis = WriteAPIHTTPAuth.objects.filter(\n            database_name=database_name,\n            collection_name=collection_name)\n    else:\n        wapis = WriteAPIHTTPAuth.objects.all()\n    context = {'name': name, 'wapis': wapis,\n               'database_name': database_name,\n               'collection_name': collection_name}\n    return render(\n        request,\n        'djmongo/console/browse-httpauth-write-apis.html',\n        context)", "response": "Browse HTTPAuth Write APIs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _kill_process(self, box_config):\n        try:\n            self.logger.info('kill: {0} {{'.format(box_config.process_name))\n            self.logger.info('target process pid={0}'.format(box_config.pid))\n            if box_config.pid and psutil.pid_exists(box_config.pid):\n                p = psutil.Process(box_config.pid)\n                p.kill()\n                p.wait()\n                box_config.pid = None\n                self.bc_dao.update(box_config)\n                remove_pid_file(box_config.process_name)\n        except Exception:\n            self.logger.error('Exception on killing: {0}'.format(box_config.process_name), exc_info=True)\n        finally:\n            self.logger.info('}')", "response": "method is called to kill a running process"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npolls a process and update its status", "response": "def _poll_process(self, box_config):\n        \"\"\" between killing a process and its actual termination lies poorly documented requirement -\n            <purging process' io pipes and reading exit status>.\n            this can be done either by os.wait() or process.wait() \"\"\"\n        try:\n            p = psutil.Process(box_config.pid)\n\n            return_code = p.wait(timeout=0.01)\n            if return_code is None:\n                # process is already terminated\n                self.logger.info('Process {0} is terminated'.format(box_config.process_name))\n                return\n            else:\n                # process is terminated; possibly by OS\n                box_config.pid = None\n                self.bc_dao.update(box_config)\n                self.logger.info('Process {0} got terminated. Cleaning up'.format(box_config.process_name))\n        except TimeoutExpired:\n            # process is alive and OK\n            pass\n        except Exception:\n            self.logger.error('Exception on polling: {0}'.format(box_config.process_name), exc_info=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start(self, *_):\n        try:\n            box_configurations = self.bc_dao.run_query(QUERY_PROCESSES_FOR_BOX_ID(self.box_id))\n\n            for box_config in box_configurations:\n                handler = RepeatTimer(TRIGGER_INTERVAL, self.manage_process, args=[box_config.process_name])\n                self.thread_handlers[box_config.process_name] = handler\n                handler.start()\n                self.logger.info('Started Supervisor Thread for {0}, triggering every {1} seconds'\n                                 .format(box_config.process_name, TRIGGER_INTERVAL))\n        except LookupError as e:\n            self.logger.error('Supervisor failed to start because of: {0}'.format(e))", "response": "Start the supervisor thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef manage_process(self, *args):\n        process_name = args[0]\n        try:\n            box_config = self.bc_dao.get_one([self.box_id, process_name])\n            if not box_config.is_on:\n                if box_config.pid is not None:\n                    self._kill_process(box_config)\n                return\n\n            if not box_config.pid or not psutil.pid_exists(box_config.pid):\n                self._start_process(box_config)\n            elif box_config.pid and psutil.pid_exists(box_config.pid):\n                self._poll_process(box_config)\n        except Exception as e:\n            self.logger.error('Exception: {0}'.format(e), exc_info=True)", "response": "reads box configuration and starts or kills processes. performs process monitoring."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef purge_mq_queue(mq_queue_name):\n    conn = None\n    chan = None\n    try:\n        conn = Connection()\n        chan = conn.connection.channel()\n        n = chan.queue_purge(mq_queue_name)\n        sys.stdout.write('Purged {0} messages from {1} queue\\n'.format(n, mq_queue_name))\n        return n\n    except Exception as e:\n        sys.stderr.write('Unable to purge {0} due to {1}\\n'.format(mq_queue_name, e))\n    finally:\n        if chan is not None:\n            chan.close()\n        if conn is not None:\n            conn.close()", "response": "Purges all messages from a queue"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a valid Publisher instance", "response": "def get(self):\n        \"\"\" :return valid :mq::flopsy::Publisher instance \"\"\"\n        if len(self.publishers) == 0:\n            return Publisher(name=self.name, parent_pool=self)\n        else:\n            return self.publishers.pop()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npurge all connections. method closes ampq connection (disconnects)", "response": "def close(self, suppress_logging=False):\n        \"\"\" purges all connections. method closes ampq connection (disconnects) \"\"\"\n        for publisher in self.publishers:\n            try:\n                publisher.close()\n            except Exception as e:\n                self.logger.error('Exception on closing Flopsy Publisher {0}: {1}'.format(self.name, e),\n                                  exc_info=not suppress_logging)\n        self.publishers.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the object with the given name", "response": "def get(self, name):\n        \"\"\" creates connection to the MQ with process-specific settings\n        :return :mq::flopsy::Publisher instance\"\"\"\n        if name not in self.pools:\n            self.pools[name] = _Pool(logger=self.logger, name=name)\n        return self.pools[name].get()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreleasing the Publisher instance for reuse", "response": "def put(self, publisher):\n        \"\"\" releases the Publisher instance for reuse\"\"\"\n        if publisher.name not in self.pools:\n            self.pools[publisher.name] = _Pool(logger=self.logger, name=publisher.name)\n        self.pools[publisher.name].put(publisher)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nresets all the connection pool", "response": "def reset_all(self, suppress_logging=False):\n        \"\"\" iterates thru the list of established connections and resets them by disconnecting and reconnecting \"\"\"\n        pool_names = list(self.pools)\n        for name in pool_names:\n            self.reset(name, suppress_logging)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreset the Flopsy Pool by disconnecting and reconnecting", "response": "def reset(self, name, suppress_logging=False):\n        \"\"\" resets established connection by disconnecting and reconnecting \"\"\"\n        self._close(name, suppress_logging)\n        self.get(name)\n        self.logger.info('Reset Flopsy Pool for {0}'.format(name))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _close(self, name, suppress_logging):\n        try:\n            pool_names = list(self.pools)\n            if name in pool_names:\n                self.pools[name].close()\n                del self.pools[name]\n        except Exception as e:\n            self.logger.error('Exception on closing Flopsy Pool for {0}: {1}'.format(name, e),\n                              exc_info=not suppress_logging)", "response": "Closes one particular Flopsy Pool and all its amqp connections"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose all publisher pools and all its resources", "response": "def close(self, suppress_logging=False):\n        \"\"\" iterates thru all publisher pools and closes them \"\"\"\n        pool_names = list(self.pools)\n        for name in pool_names:\n            self._close(name, suppress_logging)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread box configuration entries for all boxes managed by Synergy Supervisor", "response": "def entries(self):\n        \"\"\" reading box configuration entries for all boxes managed by Synergy Supervisor \"\"\"\n        list_of_rows = []\n        try:\n            list_of_rows = self.bc_dao.get_all()\n        except LookupError as e:\n            self.logger.error('MX Exception {0}'.format(e), exc_info=True)\n        return list_of_rows"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_SimData(g):\n    return SimData([i.position for i in g.mutations()],\n                   [i for i in g.haplotypes()])", "response": "Construct a libsequence. polytable. SimData from a generator of generator objects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, collection_name, instance):\n        assert isinstance(instance, SiteStatistics)\n        if instance.db_id:\n            query = {'_id': ObjectId(instance.db_id)}\n        else:\n            query = {DOMAIN_NAME: instance.domain_name,\n                     TIMEPERIOD: instance.timeperiod}\n        self.ds.update(collection_name, query, instance)\n        return instance.db_id", "response": "method finds Site Statistics record and update it DB representation"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef insert(self, collection_name, instance):\n        assert isinstance(instance, SiteStatistics)\n        collection = self.ds.connection(collection_name)\n        return collection.insert_one(instance.document).inserted_id", "response": "inserts a unit of work into MongoDB"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_job_collection_name(self, process_name):\n        qualifier = context.process_context[process_name].time_qualifier\n\n        if qualifier == QUALIFIER_HOURLY:\n            collection_name = COLLECTION_JOB_HOURLY\n        elif qualifier == QUALIFIER_DAILY:\n            collection_name = COLLECTION_JOB_DAILY\n        elif qualifier == QUALIFIER_MONTHLY:\n            collection_name = COLLECTION_JOB_MONTHLY\n        elif qualifier == QUALIFIER_YEARLY:\n            collection_name = COLLECTION_JOB_YEARLY\n        else:\n            raise ValueError('Unknown time qualifier: {0} for {1}'.format(qualifier, process_name))\n        return collection_name", "response": "Returns the name of the job collection for the given process name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_by_id(self, process_name, db_id):\n        collection_name = self._get_job_collection_name(process_name)\n        collection = self.ds.connection(collection_name)\n        document = collection.find_one({'_id': ObjectId(db_id)})\n\n        if document is None:\n            raise LookupError('MongoDB has no job record in collection {0} for {1}'\n                              .format(collection, db_id))\n        return Job.from_json(document)", "response": "method finds a single job record and returns it to the caller"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_query(self, collection_name, query):\n        cursor = self.ds.filter(collection_name, query)\n        return [Job.from_json(document) for document in cursor]", "response": "method runs query on a specified collection and returns a list of filtered Job records"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_box_id(logger):\n    try:\n        box_id = None\n        config_file = settings.settings['config_file']\n        with open(config_file) as a_file:\n            for a_line in a_file:\n                a_line = a_line.strip()\n                if a_line.startswith('#'):\n                    continue\n\n                tokens = a_line.split('=')\n                if tokens[0] == 'BOX_ID':\n                    box_id = tokens[1]\n                    return box_id\n\n        if box_id is None:\n            raise LookupError('BOX_ID is not defined in {0}'.format(config_file))\n\n    except EnvironmentError:  # parent of IOError, OSError, FileNotFoundError\n        logger.error('Can not read configuration file.', exc_info=True)\n        raise", "response": "returns the box id from the configuration file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef action_list(self):\n        \"Lists all hosts on the LB\"\n        format = \"%-35s %-25s %-8s\"\n        print format % (\"HOST\", \"ACTION\", \"SUBDOMS\")\n        for host, details in sorted(self.client.get_all().items()):\n            if details[0] in (\"proxy\", \"mirror\"):\n                action = \"%s<%s>\" % (\n                    details[0],\n                    \",\".join(\n                        \"%s:%s\" % (host, port)\n                        for host, port in details[1]['backends']\n                    )\n                )\n            elif details[0] == \"static\":\n                action = \"%s<%s>\" % (\n                    details[0],\n                    details[1]['type'],\n                )\n            elif details[0] == \"redirect\":\n                action = \"%s<%s>\" % (\n                    details[0],\n                    details[1]['redirect_to'],\n                )\n            elif details[0] == \"empty\":\n                action = \"%s<%s>\" % (\n                    details[0],\n                    details[1]['code'],\n                )\n            else:\n                action = details[0]\n            print format % (host, action, details[2])", "response": "Lists all hosts on the LB"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a hostname to the LB or alters an existing one", "response": "def action_set(self, hostname=None, action=None, subdoms=None, *args):\n        \"Adds a hostname to the LB, or alters an existing one\"\n        usage = \"set <hostname> <action> <subdoms> [option=value, ...]\"\n        if hostname is None:\n            sys.stderr.write(\"You must supply a hostname.\\n\")\n            sys.stderr.write(\"Usage: %s\\n\" % usage)\n            sys.exit(1)\n        if action is None:\n            sys.stderr.write(\"You must supply an action.\\n\")\n            sys.stderr.write(\"Usage: %s\\n\" % usage)\n            sys.exit(1)\n        if subdoms is None or subdoms.lower() not in (\"true\", \"false\"):\n            sys.stderr.write(\"You must supply True or False for the subdomains flag.\\n\")\n            sys.stderr.write(\"Usage: %s\\n\" % usage)\n            sys.exit(1)\n        # Grab options\n        options = {}\n        for arg in args:\n            if \"=\" not in arg:\n                sys.stderr.write(\"%s is not a valid option (no =)\\n\" % (\n                    arg\n                ))\n                sys.exit(1)\n            key, value = arg.split(\"=\", 1)\n            options[key] = value\n        # Sanity-check options\n        if action in (\"proxy, mirror\") and \"backends\" not in options:\n            sys.stderr.write(\"The %s action requires a backends option.\\n\" % action)\n            sys.exit(1)\n        if action == \"static\" and \"type\" not in options:\n            sys.stderr.write(\"The %s action requires a type option.\\n\" % action)\n            sys.exit(1)\n        if action == \"redirect\" and \"redirect_to\" not in options:\n            sys.stderr.write(\"The %s action requires a redirect_to option.\\n\" % action)\n            sys.exit(1)\n        if action == \"empty\" and \"code\" not in options:\n            sys.stderr.write(\"The %s action requires a code option.\\n\" % action)\n            sys.exit(1)\n        # Expand some options from text to datastructure\n        if \"backends\" in options:\n            options['backends'] = [\n                (lambda x: (x[0], int(x[1])))(bit.split(\":\", 1))\n                for bit in options['backends'].split(\",\")\n            ]\n        # Set!\n        self.client.set(\n            hostname,\n            [action, options, subdoms.lower() == \"true\"]\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing stats ( possibly limited by hostname )", "response": "def action_stats(self, hostname=None):\n        \"Shows stats (possibly limited by hostname)\"\n        format = \"%-35s %-11s %-11s %-11s %-11s\"\n        print format % (\"HOST\", \"OPEN\", \"COMPLETED\", \"BYTES IN\", \"BYTES OUT\")\n        for host, details in sorted(self.client.stats(hostname).items()):\n            print format % (\n                host,\n                details.get(\"open_requests\", 0),\n                details.get(\"completed_requests\", 0),\n                details.get(\"bytes_received\", 0),\n                details.get(\"bytes_sent\", 0),\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef retrieve_records(self, timeperiod, include_running,\n                         include_processed, include_noop, include_failed, include_disabled):\n        \"\"\" method looks for suitable job records in all Job collections and returns them as a dict\"\"\"\n        resp = dict()\n        resp.update(self._search_by_level(COLLECTION_JOB_HOURLY, timeperiod, include_running,\n                                          include_processed, include_noop, include_failed, include_disabled))\n        resp.update(self._search_by_level(COLLECTION_JOB_DAILY, timeperiod, include_running,\n                                          include_processed, include_noop, include_failed, include_disabled))\n\n        timeperiod = time_helper.cast_to_time_qualifier(QUALIFIER_MONTHLY, timeperiod)\n        resp.update(self._search_by_level(COLLECTION_JOB_MONTHLY, timeperiod, include_running,\n                                          include_processed, include_noop, include_failed, include_disabled))\n\n        timeperiod = time_helper.cast_to_time_qualifier(QUALIFIER_YEARLY, timeperiod)\n        resp.update(self._search_by_level(COLLECTION_JOB_YEARLY, timeperiod, include_running,\n                                          include_processed, include_noop, include_failed, include_disabled))\n        return resp", "response": "method looks for suitable job records in all Job collections and returns them as a dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef service(cls):\n    '''\n    Marks the decorated class as a singleton ``service``.\n\n    Injects following classmethods:\n\n        .. py:method:: .get(context)\n\n            Returns a singleton instance of the class for given ``context``\n\n            :param context: context to look in\n            :type context: :class:`Context`\n            :returns: ``cls``\n    '''\n\n    if not cls:\n        return None\n\n    # Inject methods\n    def get(cls, context):\n        return context.get_service(cls)\n    cls.get = get.__get__(cls)\n\n    log.debug('Registering [%s] (service)', get_fqdn(cls))\n\n    return cls", "response": "Decorator to mark a class as a singleton service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef interface(cls):\n    '''\n    Marks the decorated class as an abstract interface.\n\n    Injects following classmethods:\n\n        .. py:method:: .all(context) \n\n            Returns a list of instances of each component in the ``context`` implementing this ``@interface``\n\n            :param context: context to look in\n            :type context: :class:`Context`\n            :returns: list(``cls``)\n\n        .. py:method:: .any(context)\n\n            Returns the first suitable instance implementing this ``@interface`` or raises :exc:`NoImplementationError` if none is available.\n\n            :param context: context to look in\n            :type context: :class:`Context`\n            :returns: ``cls``\n\n        .. py:method:: .classes()\n\n            Returns a list of classes implementing this ``@interface``\n\n            :returns: list(class)\n    '''\n\n    if not cls:\n        return None\n\n    cls.implementations = []\n\n    # Inject methods\n    def _all(cls, context, ignore_exceptions=False):\n        return list(context.get_components(cls, ignore_exceptions=ignore_exceptions))\n    cls.all = _all.__get__(cls)\n\n    def _any(cls, context):\n        instances = cls.all(context)\n        if instances:\n            return instances[0]\n        raise NoImplementationError(cls)\n    cls.any = _any.__get__(cls)\n\n    def _classes(cls):\n        return list(cls.implementations)\n    cls.classes = _classes.__get__(cls)\n\n    log.debug('Registering [%s] (interface)', get_fqdn(cls))\n\n    return cls", "response": "Decorator to mark a class as an abstract interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmarks the decorated class as a component implementing the given ``iface`` :param iface: the interface to implement :type iface: :func:`interface`", "response": "def component(iface):\n    '''\n    Marks the decorated class as a component implementing the given ``iface``\n\n    :param iface: the interface to implement\n    :type iface: :func:`interface`\n    '''\n\n    def decorator(cls):\n        if not cls:\n            return None\n\n        # Run custom verificator if any\n        if hasattr(cls, '__verify__'):\n            if not cls.__verify__():\n                return None\n\n        if not hasattr(iface, 'implementations'):\n            log.error('%s is not an @interface', iface)\n\n        log.debug(\n            'Registering [%s] (implementation of [%s])' % (\n                get_fqdn(cls),\n                get_fqdn(iface)\n            )\n        )\n        iface.implementations.append(cls)\n\n        def get(cls, context):\n            return context.get_component(cls)\n        cls.get = get.__get__(cls)\n\n        return cls\n\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self):\n        if self.address != 'localhost':\n            raise ModHostError('The host configured in the constructor isn''t \"localhost\". '\n                               'It is not possible to start a process on another device.')\n\n        try:\n            subprocess.call([self.process, '-p', str(self.port)])\n\n        except FileNotFoundError as e:\n            exception = ModHostError(\n                'mod-host not found. Did you install it? '\n                '(https://github.com/moddevices/mod-host#building)'\n            )\n\n            raise exception from e\n\n        self._started_with_this_api = True", "response": "Starts the mod - host process."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncloses the mod - host connection with mod - host.", "response": "def close(self):\n        \"\"\"\n        Remove the audio plugins loaded and closes connection with mod-host.\n\n        .. note::\n\n            If the mod-host process has been created with :meth:`~pluginsmanager.observer.mod_host.ModHost.start()`\n            method, it will be finished.\n        \"\"\"\n        if self.host is None:\n            raise ModHostError('There is no established connection with mod-host. '\n                               'Did you call the `connect()` method?')\n\n        super(ModHost, self).close()\n\n        if self._started_with_this_api:\n            self.host.quit()\n        else:\n            self.host.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef synch_db():\n    logger = get_logger(PROCESS_SCHEDULER)\n    managed_process_dao = ManagedProcessDao(logger)\n\n    try:\n        process_entries = managed_process_dao.get_all()\n    except LookupError:\n        logger.error('Synergy DB is not initialized. Aborting.')\n        exit(1)\n\n    for process_entry in process_entries:\n        process_name = process_entry.process_name\n        if process_name not in context.process_context:\n            logger.warning('Process {0} has no reflection in the context. Skipping it.'.format(process_name))\n            continue\n\n        if not isinstance(context.process_context[process_name], ManagedProcessEntry):\n            logger.error('Process entry {0} of non-managed type {1} found in managed_process table. Skipping it.'\n                         .format(process_name, context.process_context[process_name].__class__.__name__))\n            continue\n\n        context.process_context[process_name] = process_entry\n        logger.info('Context updated with process entry {0}.'.format(process_entry.key))", "response": "function reads managed_process and updates context entries appropriately"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite to managed_process table records from the context. process_context", "response": "def update_db():\n    \"\"\" writes to managed_process table records from the context.process_context \"\"\"\n    logger = get_logger(PROCESS_SCHEDULER)\n    managed_process_dao = ManagedProcessDao(logger)\n    managed_process_dao.clear()\n\n    for process_name, process_entry in context.process_context.items():\n        if not isinstance(process_entry, ManagedProcessEntry):\n            continue\n\n        managed_process_dao.update(process_entry)\n        logger.info('Updated DB with process entry {0} from the context.'.format(process_entry.key))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reset_db():\n    logger = get_logger(PROCESS_SCHEDULER)\n    logger.info('Starting *scheduler* DB reset')\n\n    ds = ds_manager.ds_factory(logger)\n    ds._db_client.drop_database(settings.settings['mongo_db_name'])\n    logger.info('*scheduler* db has been dropped')\n\n    connection = ds.connection(COLLECTION_MANAGED_PROCESS)\n    connection.create_index([(PROCESS_NAME, pymongo.ASCENDING)], unique=True)\n\n    connection = ds.connection(COLLECTION_FREERUN_PROCESS)\n    connection.create_index([(PROCESS_NAME, pymongo.ASCENDING), (ENTRY_NAME, pymongo.ASCENDING)], unique=True)\n\n    connection = ds.connection(COLLECTION_UNIT_OF_WORK)\n    connection.create_index([(PROCESS_NAME, pymongo.ASCENDING),\n                             (TIMEPERIOD, pymongo.ASCENDING),\n                             (START_ID, pymongo.ASCENDING),\n                             (END_ID, pymongo.ASCENDING)], unique=True)\n\n    connection = ds.connection(COLLECTION_LOG_RECORDING)\n    connection.create_index([(PARENT_OBJECT_ID, pymongo.ASCENDING)], unique=True)\n\n    # expireAfterSeconds: <int> Used to create an expiring (TTL) collection.\n    # MongoDB will automatically delete documents from this collection after <int> seconds.\n    # The indexed field must be a UTC datetime or the data will not expire.\n    ttl_seconds = settings.settings['db_log_ttl_days'] * 86400     # number of seconds for TTL\n    connection.create_index(CREATED_AT, expireAfterSeconds=ttl_seconds)\n\n    for collection_name in [COLLECTION_JOB_HOURLY, COLLECTION_JOB_DAILY,\n                            COLLECTION_JOB_MONTHLY, COLLECTION_JOB_YEARLY]:\n        connection = ds.connection(collection_name)\n        connection.create_index([(PROCESS_NAME, pymongo.ASCENDING), (TIMEPERIOD, pymongo.ASCENDING)], unique=True)\n\n    # reset Synergy Flow tables\n    db_manager.reset_db()\n    logger.info('*scheduler* db has been recreated')", "response": "Resets the database and schema of the process."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nappending an item to the end of the internal list.", "response": "def append(self, item):\n        \"\"\"\n        See :meth:`list.append()` method\n\n        Calls observer ``self.observer(UpdateType.CREATED, item, index)`` where\n        **index** is *item position*\n        \"\"\"\n        self.real_list.append(item)\n        self.observer(UpdateType.CREATED, item, len(self.real_list) - 1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving the item from the internal list.", "response": "def remove(self, item):\n        \"\"\"\n        See :meth:`list.remove()` method\n\n        Calls observer ``self.observer(UpdateType.DELETED, item, index)`` where\n        **index** is *item position*\n        \"\"\"\n        index = self.index(item)\n        self.real_list.remove(item)\n        self.observer(UpdateType.DELETED, item, index)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef insert(self, index, x):\n        self.real_list.insert(index, x)\n        self.observer(UpdateType.CREATED, x, index)", "response": "Insert a new entry into the internal list at the specified index."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmoves an item to a new position in the list.", "response": "def move(self, item, new_position):\n        \"\"\"\n        Moves a item list to new position\n\n        Calls observer ``self.observer(UpdateType.DELETED, item, index)``\n        and observer ``self.observer(UpdateType.CREATED, item, index)``\n        if ``val != self[index]``\n\n        :param item: Item that will be moved to new_position\n        :param new_position: Item's new position\n        \"\"\"\n        if item == self[new_position]:\n            return\n\n        self.remove(item)\n        self.insert(new_position, item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_builder(self, json, audio_port):\n        if 'effect' in json[audio_port]:\n            return Lv2AudioPortBuilder(self.pedalboard)\n        else:\n            return SystemAudioPortBuilder(self.system_effect)", "response": "Generate a new AudioPortBuilder object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmatching a request with parameter to it s corresponding route", "response": "def match_route(self, reqpath):\n        '''match a request with parameter to it's corresponding route'''\n        route_dicts = [routes for _, routes in self.api.http.routes.items()][0]\n        routes = [route for route, _ in route_dicts.items()]\n        #no prameters in path\n        if reqpath in routes:\n            return reqpath\n        for route in routes:\n            #replace params in route with regex\n            if re.match(re.sub(r'/{[^{}]+}', '/\\w+', route) + '$', reqpath):\n                return route\n        return reqpath"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new UnitOfWork object and inserts it into the DB", "response": "def _insert_uow(self, process_name, timeperiod, start_timeperiod, end_timeperiod, start_id, end_id):\n        \"\"\"creates unit_of_work and inserts it into the DB\n            :raise DuplicateKeyError: if unit_of_work with given parameters already exists \"\"\"\n        uow = UnitOfWork()\n        uow.process_name = process_name\n        uow.timeperiod = timeperiod\n        uow.start_id = str(start_id)\n        uow.end_id = str(end_id)\n        uow.start_timeperiod = start_timeperiod\n        uow.end_timeperiod = end_timeperiod\n        uow.created_at = datetime.utcnow()\n        uow.submitted_at = datetime.utcnow()\n        uow.source = context.process_context[process_name].source\n        uow.sink = context.process_context[process_name].sink\n        uow.state = unit_of_work.STATE_REQUESTED\n        uow.unit_of_work_type = unit_of_work.TYPE_MANAGED\n        uow.number_of_retries = 0\n        uow.arguments = context.process_context[process_name].arguments\n        uow.db_id = self.uow_dao.insert(uow)\n\n        msg = 'Created: UOW {0} for {1}@{2}.'.format(uow.db_id, process_name, start_timeperiod)\n        self._log_message(INFO, process_name, start_timeperiod, msg)\n        return uow"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef insert_and_publish_uow(self, job_record, start_id, end_id):\n        process_name = job_record.process_name\n        timeperiod = job_record.timeperiod\n        start_timeperiod = self.compute_start_timeperiod(job_record.process_name, job_record.timeperiod)\n        end_timeperiod = self.compute_end_timeperiod(job_record.process_name, job_record.timeperiod)\n\n        try:\n            is_duplicate = False\n            uow = self._insert_uow(process_name, timeperiod, start_timeperiod, end_timeperiod, start_id, end_id)\n        except DuplicateKeyError as e:\n            is_duplicate = True\n            msg = 'Catching up with latest UOW {0}@{1}, because of: {2}' \\\n                  .format(process_name, start_timeperiod, e)\n            self._log_message(WARNING, process_name, start_timeperiod, msg)\n            uow = self.uow_dao.recover_from_duplicatekeyerror(e)\n\n        if not uow:\n            msg = 'PERSISTENT TIER ERROR! Unable to locate UOW for {0}@{1}' \\\n                  .format(process_name, start_timeperiod)\n            self._log_message(WARNING, process_name, start_timeperiod, msg)\n            raise UserWarning(msg)\n\n        if uow.is_canceled:\n            # this UOW was marked for re-processing. recycle it\n            uow.created_at = datetime.utcnow()      # reset created_at to bypass GC cancellation logic\n            uow.submitted_at = datetime.utcnow()    # reset submitted_at to allow 1 hour free of GC resubmitting\n            del uow.started_at\n            del uow.finished_at\n            del uow.number_of_aggregated_documents\n            del uow.number_of_processed_documents\n            uow.state = unit_of_work.STATE_REQUESTED\n            self.uow_dao.update(uow)\n\n        # publish the created/recovered/recycled unit_of_work\n        self._publish_uow(uow)\n        return uow, is_duplicate", "response": "method creates and publishes a unit_of_work. it handles DuplicateKeyError and attempts recovery\n            and returns a tuple of uow and is_duplicate."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute lowest *inclusive* timeperiod boundary for job to process for process with time_grouping == 1, it returns given timeperiod with no change for process with time_grouping != 1, it computes first timeperiod, not processed by the previous job run For instance: with time_grouping = 3, QUALIFIER_HOURLY, and timeperiod = 2016042018, the start_timeperiod will be = 2016042016 (computed as 2016042018 - 3 + 1)", "response": "def compute_start_timeperiod(self, process_name, timeperiod):\n        \"\"\" computes lowest *inclusive* timeperiod boundary for job to process\n            for process with time_grouping == 1, it returns given timeperiod with no change\n            for process with time_grouping != 1, it computes first timeperiod, not processed by the previous job run\n            For instance: with time_grouping = 3, QUALIFIER_HOURLY, and timeperiod = 2016042018,\n            the start_timeperiod will be = 2016042016 (computed as 2016042018 - 3 + 1)\n        \"\"\"\n        time_grouping = context.process_context[process_name].time_grouping\n        if time_grouping == 1:\n            return timeperiod\n\n        # step1: translate given timeperiod to the time grouped one\n        process_hierarchy = self.timetable.get_tree(process_name).process_hierarchy\n        timeperiod_dict = process_hierarchy[process_name].timeperiod_dict\n        translated_timeperiod = timeperiod_dict._translate_timeperiod(timeperiod)\n\n        # step 2: compute previous grouped period\n        # NOTICE: simple `time_helper.increment_timeperiod(time_qualifier, timeperiod)` is insufficient\n        #         as it does not address edge cases, such as the last day of the month or the last hour of the day\n        # For instance: with time_grouping=3, QUALIFIER_DAILY, and 2016123100\n        # the `increment_timeperiod` will yield 2016122800 instead of 2016123100\n        time_qualifier = context.process_context[process_name].time_qualifier\n        for i in range(1, time_grouping + 1):\n            prev_timeperiod = time_helper.increment_timeperiod(time_qualifier, translated_timeperiod, delta=-i)\n            if prev_timeperiod == timeperiod_dict._translate_timeperiod(prev_timeperiod):\n                # prev_timeperiod is currently at the last grouped timeperiod\n                break\n\n        # step 3: compute first exclusive timeperiod after the *prev_timeperiod*,\n        # which becomes first inclusive timeperiod for this job run\n        over_the_edge_timeperiod = time_helper.increment_timeperiod(time_qualifier, prev_timeperiod, delta=-1)\n        if prev_timeperiod != timeperiod_dict._translate_timeperiod(over_the_edge_timeperiod):\n            # over_the_edge_timeperiod fell into previous day or month or year\n            # *prev_timeperiod* points to the first month, first day of the month or 00 hour\n            start_timeperiod = prev_timeperiod\n        else:\n            start_timeperiod = self.compute_end_timeperiod(process_name, prev_timeperiod)\n\n        return start_timeperiod"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compute_end_timeperiod(self, process_name, timeperiod):\n        time_qualifier = context.process_context[process_name].time_qualifier\n        end_timeperiod = time_helper.increment_timeperiod(time_qualifier, timeperiod)\n        return end_timeperiod", "response": "computes the end timeperiod for the job to process"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _is_noop_timeperiod(self, process_name, timeperiod):\n        time_grouping = context.process_context[process_name].time_grouping\n        if time_grouping == 1:\n            return False\n\n        process_hierarchy = self.timetable.get_tree(process_name).process_hierarchy\n        timeperiod_dict = process_hierarchy[process_name].timeperiod_dict\n        return timeperiod_dict._translate_timeperiod(timeperiod) != timeperiod", "response": "method verifies if the given timeperiod for given process is valid or falls in - between grouping checkpoints\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _process_noop_timeperiod(self, job_record):\n        job_record.state = job.STATE_NOOP\n        self.job_dao.update(job_record)\n\n        time_grouping = context.process_context[job_record.process_name].time_grouping\n        msg = 'Job {0}@{1} with time_grouping {2} was transferred to STATE_NOOP' \\\n              .format(job_record.process_name, job_record.timeperiod, time_grouping)\n        self._log_message(INFO, job_record.process_name, job_record.timeperiod, msg)", "response": "method is valid for processes having time_grouping!= 1.\n            should be a job record that fall in - between grouped time milestones and state to STATE_NOOP without any processing"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef manage_job_with_blocking_children(self, job_record):\n        is_job_finalizable = self.timetable.is_job_record_finalizable(job_record)\n        if is_job_finalizable:\n            self.manage_job(job_record)\n        else:\n            msg = 'Job {0}@{1} is blocked by unprocessed children/dependencies. Waiting another tick' \\\n                  .format(job_record.process_name, job_record.timeperiod)\n            self._log_message(INFO, job_record.process_name, job_record.timeperiod, msg)", "response": "method will trigger job processing only if all children are finished and all external dependencies are finalized"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef manage_job_with_blocking_dependencies(self, job_record):\n        composite_state = self.timetable.dependent_on_composite_state(job_record)\n        assert isinstance(composite_state, NodesCompositeState)\n\n        if composite_state.all_processed:\n            self.manage_job(job_record)\n        elif composite_state.skipped_present:\n            # As soon as among <dependent on> periods are in STATE_SKIPPED\n            # there is very little sense in waiting for them to become STATE_PROCESSED\n            # Skip this timeperiod itself\n            job_record.state = job.STATE_SKIPPED\n            self.job_dao.update(job_record)\n            self.mq_transmitter.publish_job_status(job_record)\n\n            msg = 'Job {0}@{1} is blocked by STATE_SKIPPED dependencies. ' \\\n                  'Transferred the job to STATE_SKIPPED'.format(job_record.process_name, job_record.timeperiod)\n            self._log_message(WARNING, job_record.process_name, job_record.timeperiod, msg)\n        else:\n            msg = 'Job {0}@{1} is blocked by unprocessed dependencies. Waiting another tick' \\\n                  .format(job_record.process_name, job_record.timeperiod)\n            self._log_message(INFO, job_record.process_name, job_record.timeperiod, msg)", "response": "method will trigger processing of jobs with blocking dependencies"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef manage_job(self, job_record):\n        assert isinstance(job_record, Job)\n        try:\n            if self._is_noop_timeperiod(job_record.process_name, job_record.timeperiod):\n                self._process_noop_timeperiod(job_record)\n                return\n\n            if job_record.is_embryo:\n                self._process_state_embryo(job_record)\n\n            elif job_record.is_in_progress:\n                self._process_state_in_progress(job_record)\n\n            elif job_record.is_final_run:\n                self._process_state_final_run(job_record)\n\n            elif job_record.is_skipped:\n                self._process_terminal_state(job_record)\n\n            elif job_record.is_processed:\n                self._process_terminal_state(job_record)\n\n            elif job_record.is_noop:\n                self._process_terminal_state(job_record)\n\n            else:\n                msg = 'Unknown state {0} of the job {1}'.format(job_record.state, job_record.db_id)\n                self._log_message(ERROR, job_record.process_name, job_record.timeperiod, msg)\n\n        except LookupError as e:\n            job_record.number_of_failures += 1\n            self.job_dao.update(job_record)\n            self.timetable.skip_if_needed(job_record)\n            msg = 'Increasing fail counter for Job {0}@{1}, because of: {2}' \\\n                  .format(job_record.process_name, job_record.timeperiod, e)\n            self._log_message(WARNING, job_record.process_name, job_record.timeperiod, msg)\n\n        finally:\n            self.mq_transmitter.publish_job_status(job_record)", "response": "method manage_job - manage the job"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef skip_job(self, job_record):\n        original_job_state = job_record.state\n\n        if not job_record.is_finished:\n            job_record.state = job.STATE_SKIPPED\n            self.job_dao.update(job_record)\n\n        if job_record.related_unit_of_work:\n            uow = self.uow_dao.get_one(job_record.related_unit_of_work)\n            if not uow.is_finished:\n                uow.state = unit_of_work.STATE_CANCELED\n                uow.submitted_at = datetime.utcnow()\n                self.uow_dao.update(uow)\n\n        msg = 'Skipped Job {0} for {1}@{2}: state transfer {3} -> {4};' \\\n              .format(job_record.db_id, job_record.process_name, job_record.timeperiod,\n                      original_job_state, job_record.state)\n        self._log_message(WARNING, job_record.process_name, job_record.timeperiod, msg)", "response": "method skip_job - updates the job_record and notifies the job manager that it is in the finished state"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_job(self, job_record, uow, new_state):\n        original_job_state = job_record.state\n        job_record.state = new_state\n        job_record.related_unit_of_work = uow.db_id\n        self.job_dao.update(job_record)\n\n        msg = 'Updated Job {0} for {1}@{2}: state transfer {3} -> {4};' \\\n              .format(job_record.db_id, job_record.process_name, job_record.timeperiod, original_job_state, new_state)\n        self._log_message(INFO, job_record.process_name, job_record.timeperiod, msg)", "response": "method updates job record with a new unit_of_work and new state"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading JSON request from the mq message and delivers it for processing", "response": "def _mq_callback(self, message):\n        \"\"\" reads JSON request from the mq message and delivers it for processing \"\"\"\n        while threading.active_count() > settings.settings['bash_runnable_count'] + self.initial_thread_count:\n            time.sleep(0.1)\n\n        t = BashRunnable(self.logger, message, self.consumer, self.performance_tracker)\n        t.daemon = True\n        t.start()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload the state from the state file", "response": "def load(self):\n        \"Loads the state from the state file\"\n        try:\n            if os.path.getsize(self.state_file) <= 1:\n                raise IOError(\"File is empty.\")\n            with open(self.state_file) as fh:\n                state = json.load(fh)\n                assert isinstance(state, dict)\n                self.hosts = state['hosts']\n                self.stats = state['stats']\n            for key in self.stats:\n                self.stats[key]['open_requests'] = 0\n        except (IOError, OSError):\n            # There is no state file; start empty.\n            self.hosts = {}\n            self.stats = {}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave the state to the state file", "response": "def save(self):\n        \"Saves the state to the state file\"\n        with open(self.state_file, \"w\") as fh:\n            json.dump({\n                \"hosts\": self.hosts,\n                \"stats\": self.stats,\n            }, fh)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_loop(self):\n        last_hash = hash(repr(self.hosts))\n        while self.running:\n            eventlet.sleep(self.save_interval)\n            next_hash = hash(repr(self.hosts))\n            if next_hash != last_hash:\n                self.save()\n                last_hash = next_hash", "response": "Save the state if it has changed."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts serving management requests.", "response": "def management_loop(self, address, family):\n        \"\"\"\n        Accepts management requests.\n        \"\"\"\n        try:\n            sock = eventlet.listen(address, family)\n        except socket.error, e:\n            logging.critical(\"Cannot listen on (%s, %s): %s\" % (address, family, e))\n            return\n        # Sleep to ensure we've dropped privileges by the time we start serving\n        eventlet.sleep(0.5)\n        # Actually serve management\n        logging.info(\"Listening for management on %s\" % (address, ))\n        management_app = ManagementApp(self)\n        try:\n            with open(\"/dev/null\", \"w\") as log_dest:\n                wsgi.server(\n                    sock,\n                    management_app.handle,\n                    log = log_dest,\n                )\n        finally:\n            sock.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef listen_loop(self, address, family, internal=False):\n        try:\n            sock = eventlet.listen(address, family)\n        except socket.error, e:\n            if e.errno == errno.EADDRINUSE:\n                logging.critical(\"Cannot listen on (%s, %s): already in use\" % (address, family))\n                raise\n            elif e.errno == errno.EACCES and address[1] <= 1024:\n                logging.critical(\"Cannot listen on (%s, %s) (you might need to launch as root)\" % (address, family))\n                return\n            logging.critical(\"Cannot listen on (%s, %s): %s\" % (address, family, e))\n            return\n        # Sleep to ensure we've dropped privileges by the time we start serving\n        eventlet.sleep(0.5)\n        # Start serving\n        logging.info(\"Listening for requests on %s\" % (address, ))\n        try:\n            eventlet.serve(\n                sock,\n                lambda sock, addr: self.handle(sock, addr, internal),\n                concurrency = 10000,\n            )\n        finally:\n            sock.close()", "response": "Listen for incoming connections."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle(self, sock, address, internal=False):\n        try:\n            sock = StatsSocket(sock)\n            rfile = sock.makefile('rb', 4096)\n            # Read the first line\n            first = rfile.readline().strip(\"\\r\\n\")\n            words = first.split()\n            # Ensure it looks kind of like HTTP\n            if not (2 <= len(words) <= 3):\n                sock.sendall(\"HTTP/1.0 400 Bad Request\\r\\nConnection: close\\r\\nContent-length: 0\\r\\n\\r\\n\")\n                return\n            path = words[1]\n            # Read the headers\n            headers = mimetools.Message(rfile, 0)\n            # Work out the host\n            try:\n                host = headers['Host']\n            except KeyError:\n                host = \"unknown\"\n            headers['Connection'] = \"close\"\n            if not internal:\n                headers['X-Forwarded-For'] = address[0]\n                headers['X-Forwarded-Protocol'] = \"\"\n                headers['X-Forwarded-Proto'] = \"\"\n            # Make sure they're not using odd encodings\n            if \"Transfer-Encoding\" in headers:\n                sock.sendall(\"HTTP/1.0 411 Length Required\\r\\nConnection: close\\r\\nContent-length: 0\\r\\n\\r\\n\")\n                return\n            # Match the host to an action\n            protocol = \"http\"\n            if headers.get('X-Forwarded-Protocol', headers.get('X-Forwarded-Proto', \"\")).lower() in (\"ssl\", \"https\"):\n                protocol = \"https\"\n            action = self.resolve_host(host, protocol)\n            # Record us as an open connection\n            stats_dict = self.stats.setdefault(action.matched_host, {})\n            stats_dict['open_requests'] = stats_dict.get('open_requests', 0) + 1\n            # Run the action\n            try:\n                rfile._rbuf.seek(0)\n                action.handle(\n                    sock = sock,\n                    read_data = first + \"\\r\\n\" + str(headers) + \"\\r\\n\" + rfile._rbuf.read(),\n                    path = path,\n                    headers = headers,\n                )\n            finally:\n                stats_dict['open_requests'] -= 1\n                stats_dict['completed_requests'] = stats_dict.get('completed_requests', 0) + 1\n                stats_dict['bytes_sent'] = stats_dict.get('bytes_sent', 0) + sock.bytes_sent\n                stats_dict['bytes_received'] = stats_dict.get('bytes_received', 0) + sock.bytes_received\n        except socket.error, e:\n            if e.errno not in (errno.EPIPE, errno.ETIMEDOUT, errno.ECONNRESET):\n                logging.error(traceback.format_exc())\n        except:\n            logging.error(traceback.format_exc())\n            try:\n                sock.sendall(\"HTTP/1.0 500 Internal Server Error\\r\\n\\r\\nThere has been an internal error in the load balancer.\")\n            except socket.error, e:\n                if e.errno != errno.EPIPE:\n                    raise\n        finally:\n            try:\n                sock.close()\n                rfile.close()\n            except:\n                logging.error(traceback.format_exc())", "response": "Handles an incoming HTTP connection."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _mq_callback(self, message):\n        try:\n            raw_data = RawData.from_json(message.body)\n            try:\n                session = self.ss_dao.find_by_session_id(raw_data.domain_name, raw_data.session_id)\n\n                # update the click_xxx info\n                session = self.update_session_body(raw_data, session)\n\n                epoch_current = calendar.timegm(raw_data.timestamp.replace(tzinfo=None).utctimetuple())\n                epoch_start = time_helper.session_to_epoch(session.timeperiod)\n                session.browsing_history.total_duration = (epoch_current - epoch_start) / 1000\n\n                index = session.browsing_history.number_of_entries\n                self.add_entry(session, index, raw_data)\n                self.performance_tracker.update.increment_success()\n            except LookupError:\n                # insert the record\n                session = SingleSession()\n\n                # input data constraints - both session_id and user_id must be present in MQ message\n                session.key = (raw_data.domain_name,\n                               time_helper.datetime_to_synergy(QUALIFIER_HOURLY, raw_data.timestamp),\n                               raw_data.session_id)\n                session.ip = raw_data.ip\n                session.total_duration = 0\n\n                session = self.update_session_body(raw_data, session)\n                self.add_entry(session, 0, raw_data)\n                self.performance_tracker.insert.increment_success()\n\n            self.ss_dao.update(session)\n            self.consumer.acknowledge(message.delivery_tag)\n        except AutoReconnect as e:\n            self.logger.error('MongoDB connection error: {0}\\nRe-queueing message & exiting the worker'.format(e))\n            self.consumer.reject(message.delivery_tag)\n            raise e\n        except (KeyError, IndexError) as e:\n            self.logger.error('Error is considered Unrecoverable: {0}\\nCancelled message: {1}'.format(e, message.body))\n            self.consumer.cancel(message.delivery_tag)\n        except Exception as e:\n            self.logger.error('Error is considered Recoverable: {0}\\nRe-queueing message: {1}'.format(e, message.body))\n            self.consumer.reject(message.delivery_tag)", "response": "This method is called by the MQ thread when a message is received from the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload scheduler managed entries.", "response": "def _load_managed_entries(self):\n        \"\"\" loads scheduler managed entries. no start-up procedures are performed \"\"\"\n        for process_name, process_entry in context.process_context.items():\n            if isinstance(process_entry, ManagedProcessEntry):\n                function = self.fire_managed_worker\n            else:\n                self.logger.warning('Skipping non-managed context entry {0} of type {1}.'\n                                    .format(process_name, process_entry.__class__.__name__))\n                continue\n\n            try:\n                self._register_process_entry(process_entry, function)\n            except Exception:\n                self.logger.error('Managed Thread Handler {0} failed to start. Skipping it.'\n                                  .format(process_entry.key), exc_info=True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _load_freerun_entries(self):\n        freerun_entries = self.freerun_process_dao.get_all()\n        for freerun_entry in freerun_entries:\n            try:\n                self._register_process_entry(freerun_entry, self.fire_freerun_worker)\n            except Exception:\n                self.logger.error('Freerun Thread Handler {0} failed to start. Skipping it.'\n                                  .format(freerun_entry.key), exc_info=True)", "response": "reads scheduler managed entries and starts timers to trigger events"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start(self, *_):\n        self.logger.info('Starting Scheduler...')\n        db_manager.synch_db()\n        self._load_managed_entries()\n\n        try:\n            self._load_freerun_entries()\n        except LookupError as e:\n            self.logger.warning('DB Lookup: {0}'.format(e))\n\n        # Scheduler is initialized and running. GarbageCollector can be safely started\n        self.gc.start()\n\n        # Job/UOW Status Listeners can be safely started\n        self.uow_listener.start()\n        self.job_listener.start()\n\n        self.logger.info('Startup Sequence Completed. Starting MX.')\n        # Management Extension (MX) should be the last to start\n        self.mx.start()", "response": "reads managed process entries and starts timer instances; starts dependant threads"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the state machine for the given process name", "response": "def state_machine_for(self, process_name):\n        \"\"\" :return: state machine for the given process name \"\"\"\n        process_entry = self.managed_handlers[process_name].process_entry\n        return self.timetable.state_machines[process_entry.state_machine_name]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfiring next valid job for given process and manages its state", "response": "def fire_managed_worker(self, thread_handler_header):\n        \"\"\" requests next valid job for given process and manages its state \"\"\"\n\n        def _fire_worker(process_entry, prev_job_record):\n            assert isinstance(process_entry, ManagedProcessEntry)\n            job_record = self.timetable.get_next_job_record(process_entry.process_name)\n            state_machine = self.timetable.state_machines[process_entry.state_machine_name]\n            if job_record == prev_job_record:\n                # avoid the loop\n                return None\n\n            if not state_machine.run_on_active_timeperiod:\n                time_qualifier = process_entry.time_qualifier\n                incremented_timeperiod = time_helper.increment_timeperiod(time_qualifier, job_record.timeperiod)\n                dt_record_timestamp = time_helper.synergy_to_datetime(time_qualifier, incremented_timeperiod)\n                dt_record_timestamp += timedelta(minutes=LAG_5_MINUTES)\n\n                if datetime.utcnow() <= dt_record_timestamp:\n                    self.logger.info('Job {0} for {1}@{2} will not be triggered until {3}.'\n                                     .format(job_record.db_id,\n                                             job_record.process_name,\n                                             job_record.timeperiod,\n                                             dt_record_timestamp.strftime('%Y-%m-%d %H:%M:%S')))\n                    return None\n\n            blocking_type = process_entry.blocking_type\n            if blocking_type == BLOCKING_DEPENDENCIES:\n                state_machine.manage_job_with_blocking_dependencies(job_record)\n            elif blocking_type == BLOCKING_CHILDREN:\n                state_machine.manage_job_with_blocking_children(job_record)\n            elif blocking_type == BLOCKING_NORMAL:\n                state_machine.manage_job(job_record)\n            else:\n                raise ValueError('Unknown managed process type {0}'.format(blocking_type))\n\n            return job_record\n\n        try:\n            assert isinstance(thread_handler_header, ThreadHandlerHeader)\n            self.logger.info('{0} {{'.format(thread_handler_header.key))\n\n            job_record = _fire_worker(thread_handler_header.process_entry, None)\n            while job_record and job_record.is_finished:\n                job_record = _fire_worker(thread_handler_header.process_entry, job_record)\n\n        except Exception as e:\n            self.logger.error('Exception: {0}'.format(e), exc_info=True)\n        finally:\n            self.logger.info('}')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfires free - run worker with no dependencies to track", "response": "def fire_freerun_worker(self, thread_handler_header):\n        \"\"\" fires free-run worker with no dependencies to track \"\"\"\n        try:\n            assert isinstance(thread_handler_header, ThreadHandlerHeader)\n            self.logger.info('{0} {{'.format(thread_handler_header.key))\n\n            state_machine = self.timetable.state_machines[STATE_MACHINE_FREERUN]\n            state_machine.manage_schedulable(thread_handler_header.process_entry)\n\n        except Exception as e:\n            self.logger.error('fire_freerun_worker: {0}'.format(e))\n        finally:\n            self.logger.info('}')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef timeseries():\n    def method_builder(cls):\n        method_doc = \"\"\"Fetch the timeseries for this :class:`{0}`.\n\n        Returns:\n\n            The :class:`Timeseries` for this :class:`{0}`\n\n        Keyword Args:\n\n            **kwargs: The :class:`Timeseries` object constructor arguments.\n        \"\"\".format(cls.__name__)\n\n        def method(self, **kwargs):\n            resource_id = None if self.is_singleton() else self.id\n            return Timeseries(self._session, cls, resource_id, **kwargs)\n\n        method.__doc__ = method_doc\n        setattr(cls, 'timeseries', method)\n        return cls\n    return method_builder", "response": "Creates a method which creates a timeseries for a given class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sensor_id(self):\n        if hasattr(self, '_sensor_id'):\n            return self._sensor_id\n        relationships = self._json_data.get('relationships')\n        sensor_id = relationships.get('sensor').get('data').get('id')\n        self._sensor_id = sensor_id\n        return sensor_id", "response": "The id of the sensor that generated this datapoint. Will throw an AttributeError if no sensor id was found in the data point."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(self, port, value, timestamp=None):\n        session = self._session\n        datapoint_class = self._datapoint_class\n        attributes = {\n            'port': port,\n            'value': value,\n        }\n        if timestamp is not None:\n            attributes['timestamp'] = to_iso_date(timestamp)\n        attributes = build_request_body('data-point', None,\n                                        attributes=attributes)\n\n        def _process(json):\n            data = json.get('data')\n            return datapoint_class(data, session)\n        return session.post(self._base_url, CB.json(201, _process),\n                            json=attributes)", "response": "Post a new reading to a timeseries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a live stream of timeseries readings.", "response": "def live(self):\n        \"\"\"Get a live stream of timeseries readings.\n\n        This returns an Iterable over a live stream of readings. Note\n        that the result will need to be closed since the system can\n        not tell when you'll be done with it.\n\n        You can either call ``close`` on the endpoint when you're or\n        use the context management facilities of the endpoint.\n\n\n        .. code-block:: python\n\n            # Fetch a sensor\n            timeseries = sensor.timeseries()\n\n            # ensure live endpoint closed\n            with timeseries.live() as live:\n                # Wait for 10 readings\n                first10 = list(islice(live, 10))\n\n        Returns:\n\n        \"\"\"\n        session = self._session\n        url = \"{}/live\".format(self._base_url)\n        supported_params = frozenset(['filter[port]'])\n        params = {k: v for k, v in iteritems(self._params)\n                  if k in supported_params}\n        return session.live(url, self._datapoint_class, {\n            'is_aggregate': self._is_aggregate\n        }, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _construct_state_machines(self):\n        state_machines = dict()\n        for state_machine in [StateMachineRecomputing(self.logger, self),\n                              StateMachineContinuous(self.logger, self),\n                              StateMachineDiscrete(self.logger, self),\n                              StateMachineFreerun(self.logger)]:\n            state_machines[state_machine.name] = state_machine\n        return state_machines", "response": "Constructs a dictionary of state machines."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _register_dependencies(self):\n        for tree_name, context_entry in context.timetable_context.items():\n            tree = self.trees[tree_name]\n            assert isinstance(tree, MultiLevelTree)\n            for dependent_on in context_entry.dependent_on:\n                dependent_on_tree = self.trees[dependent_on]\n                assert isinstance(dependent_on_tree, MultiLevelTree)\n                tree.register_dependent_on(dependent_on_tree)", "response": "register dependencies between trees"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _find_dependant_trees(self, tree_obj):\n        dependant_trees = []\n        for tree_name, tree in self.trees.items():\n            if tree_obj in tree.dependent_on:\n                dependant_trees.append(tree)\n        return dependant_trees", "response": "returns list of trees that are dependent_on given tree_obj"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef skip_tree_node(self, tree_node, tx_context=None):\n        if not tx_context:\n            # create transaction context if one was not provided\n            # format: {process_name: {timeperiod: AbstractTreeNode} }\n            tx_context = collections.defaultdict(dict)\n\n        if tree_node.timeperiod in tx_context[tree_node.process_name]:\n            # the node has already been marked for skipping\n            return tx_context\n\n        if tree_node.job_record.is_finished:\n            # the node is finished and does not require skipping\n            pass\n        else:\n            state_machine_name = context.process_context[tree_node.process_name].state_machine_name\n            state_machine = self.state_machines[state_machine_name]\n            state_machine.skip_job(tree_node.job_record)\n\n        tx_context[tree_node.process_name][tree_node.timeperiod] = tree_node\n        for timeperiod, node in tree_node.children.items():\n            self.skip_tree_node(node, tx_context)\n\n        dependant_nodes = self._find_dependant_tree_nodes(tree_node)\n        for node in dependant_nodes:\n            self.skip_tree_node(node, tx_context)\n\n        return tx_context", "response": "method skips the node and all its dependants and child nodes"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nassigns a job record to the given tree node.", "response": "def assign_job_record(self, tree_node):\n        \"\"\" - looks for an existing job record in the DB, and if not found\n            - creates a job record in STATE_EMBRYO and bind it to the given tree node \"\"\"\n        try:\n            job_record = self.job_dao.get_one(tree_node.process_name, tree_node.timeperiod)\n        except LookupError:\n            state_machine_name = context.process_context[tree_node.process_name].state_machine_name\n            state_machine = self.state_machines[state_machine_name]\n            job_record = state_machine.create_job(tree_node.process_name, tree_node.timeperiod)\n        tree_node.job_record = job_record"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn tree that is managing time - periods for given process", "response": "def get_tree(self, process_name):\n        \"\"\" return tree that is managing time-periods for given process\"\"\"\n        for tree_name, tree in self.trees.items():\n            if process_name in tree:\n                return tree"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dependent_on_composite_state(self, job_record):\n        assert isinstance(job_record, Job)\n        tree = self.get_tree(job_record.process_name)\n        node = tree.get_node(job_record.process_name, job_record.timeperiod)\n        return node.dependent_on_composite_state()", "response": "Returns the dependent_on_composite_state method of the given job record."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the next job record for the given process", "response": "def get_next_job_record(self, process_name):\n        \"\"\" :returns: the next job record to work on for the given process\"\"\"\n        tree = self.get_tree(process_name)\n        node = tree.get_next_node(process_name)\n\n        if node.job_record is None:\n            self.assign_job_record(node)\n        return node.job_record"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_job_record_finalizable(self, job_record):\n        assert isinstance(job_record, Job)\n        tree = self.get_tree(job_record.process_name)\n        node = tree.get_node(job_record.process_name, job_record.timeperiod)\n        return node.is_finalizable()", "response": "Returns True if the job record is finalizable."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_log_entry(self, process_name, timeperiod, msg):\n        tree = self.get_tree(process_name)\n        node = tree.get_node(process_name, timeperiod)\n        node.add_log_entry([datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'), msg])", "response": "Adds a non - persistent log entry to the tree node"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the banks files and returns a BanksManager instance with the banks persisted in the pedalboards attribute.", "response": "def load(self, system_effect):\n        \"\"\"\n        Return a :class:`.BanksManager` instance contains the banks present in\n        :attr:`~pluginsmanager.observer.autosaver.autosaver.Autosaver.data_path`\n\n        :param SystemEffect system_effect: SystemEffect used in pedalboards\n        :return BanksManager: :class:`.BanksManager` with banks persisted in\n                :attr:`~pluginsmanager.observer.autosaver.autosaver.Autosaver.data_path`\n        \"\"\"\n        banks = self.banks_files.load(system_effect)\n        banks_ordered = self.index_file.load(banks)\n\n        manager = BanksManager()\n        manager.register(self)\n\n        for bank in banks_ordered:\n            manager.append(bank)\n            bank.manager = manager\n\n        return manager"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, banks_manager):\n        self.banks_files.delete_all_banks()\n        self.banks_files.save(banks_manager)\n        self.index_file.save(banks_manager)", "response": "Save all data from a banks manager"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef apply(cls, self, *args, **kwargs):\n        for key in kwargs:\n          if key in [ x.name for x in cls.INPUTS ]:\n            setattr(self, key, kwargs[key])\n          if key in [ x.name for x in cls.OUTPUTS ]:\n            setattr(self, key, kwargs[key])\n          if key in [ x.name for x in cls.PARAMETERS ]:\n            setattr(self, key, kwargs[key])", "response": "Applies the specified arguments to the instance passed as the first\n        argument to the call."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a dictionary that represents the processor.", "response": "def spec(self):\n        \"\"\"\n        Generate spec for the processor as a Python dictionary.\n\n        A spec is a standard way to describe a MountainLab processor in a way\n        that is easy to process, yet still understandable by humans.\n        This method generates a Python dictionary that complies with a spec\n        definition.\n        \"\"\"\n        pspec = {}\n        pspec['name'] = self.NAME\n        pspec['version'] = self.VERSION\n        pspec['description'] = self.DESCRIPTION\n        #if hasattr(self, 'run') and callable(self.run):\n        components = [sys.argv[0], self.NAME]\n        if self.USE_ARGUMENTS: components.append('$(arguments)')\n        pspec['exe_command'] = self.COMMAND or ' '.join(components)\n\n        pspec['inputs'] = [ inp.spec for inp in self.INPUTS ]\n        pspec['outputs'] = [ out.spec for out in self.OUTPUTS ]\n        pspec['parameters'] = [ param.spec for param in self.PARAMETERS ]\n        if hasattr(self, 'test') and callable(self.test):\n            pspec['has_test'] = True\n\n        return pspec"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef invoke_parser(self, supparser=None, noexit=False):\n        if supparser:\n            parser = supparser.add_parser(self.NAME, description=self.DESCRIPTION)\n        else:\n            if noexit:\n                class NoExitArgumentParser(argparse.ArgumentParser):\n                    def exit(self, status=0, message=None):\n                        raise ParserError()\n                    def error(self, message):\n                        raise ParserError()\n\n                parser = NoExitArgumentParser(prog=self.NAME, description=self.DESCRIPTION)\n            else:\n                parser = argparse.ArgumentParser(prog=self.NAME, description=self.DESCRIPTION)\n\n\n        def populate_parser(parser, dataset):\n            for elem in dataset:\n                opts = {}\n                opts['help'] = elem.description\n                opts['required'] = not elem.optional\n                if elem.multi: opts['action'] = 'append'\n                parser.add_argument('--'+elem.name, **opts)\n\n        # populate parser with INPUTS\n        populate_parser(parser, self.INPUTS)\n        # populate parser with OUTPUTS\n        populate_parser(parser, self.OUTPUTS)\n        # populate parser with PARAMETERS\n        for param in self.PARAMETERS:\n            opts = {}\n            opts['help'] = param.description\n            opts['required'] = not param.optional\n            if isinstance(param.datatype, tuple):\n                opts['type'] = str\n                #opts['type'] = param.datatype[1]\n            else:\n                opts['type'] = param.datatype\n\n            if param.multi: opts['action'] = 'append'\n            if param.choices:\n                if isinstance(param.choices, tuple):\n                    # if choices is a tuple, assume it is a tuple of mappings\n                    # and expand them\n                    opts['choices'] = [ choice[0] for choice in param.choices ]\n                else:\n                    opts['choices'] = param.choices\n            parser.add_argument('--'+param.name, **opts)\n\n        if self.USE_ARGUMENTS:\n            parser.add_argument('--_tempdir',required=False, help=argparse.SUPPRESS)\n        return parser", "response": "Invoke the command line parser for the processor."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes the processor passing given arguments.", "response": "def invoke(proc, args=None, *, _instance = None, **kwargs):\n        \"\"\"\n        Executes the processor passing given arguments.\n\n        :param args: a list of parameters in --key=value format.\n        \"\"\"\n        if args is None:\n            args=[]\n        for kwargname in kwargs:\n            args.append('--'+kwargname)\n            args.append('{}'.format(kwargs[kwargname]))\n        parser = proc.invoke_parser(noexit=(_instance is not None))\n        opts = parser.parse_args(args)\n        kwargs0 = {}\n\n\n        def handle_set(opts, dataset, kwargs0, canMulti = False):\n            for elem in dataset:\n                elemname = elem.name\n                # ml-run-process passes values for not provided inputs, outputs and params as empty strings ('')\n                if hasattr(opts, elemname) and getattr(opts, elemname) not in [None, '']:\n                    # value for element was given in the invocation\n                    elemvalue = getattr(opts, elemname)\n                    if canMulti and isinstance(elemvalue, list):\n                        elemlist = elemvalue\n                    else:\n                        elemlist = [ elemvalue ]\n                    for elemelem in elemlist:\n                        for validator in elem.validators: validator(elemelem)\n                    if hasattr(opts, elem.name):\n                        prepared = elem.prepare(elemvalue) or elemvalue\n                        kwargs0[elem.name] = prepared\n                elif elem.optional:\n                    # value was not set but is optional so ignore it\n                    kwargs0[elem.name] = None\n                else:\n                    # value was not set and is mandatory -- error\n                    raise AttributeError('Missing value for {} '.format(elemname))\n\n        try:\n            handle_set(opts, proc.INPUTS, kwargs0, True)\n            handle_set(opts, proc.OUTPUTS, kwargs0, True)\n\n            for param in proc.PARAMETERS:\n                if hasattr(opts, param.name) and getattr(opts, param.name) is not None and getattr(opts, param.name) is not '':\n                    value = getattr(opts, param.name)\n                    # validate if needed\n                    for validator in param.validators:\n                        validator(value)\n                    # if param is a tuple of choices, each choice is a tuple itself\n                    # with first element of the input value and second element\n                    # containing the value to be passed to the processor\n                    if param.choices and isinstance(param.choices, tuple):\n                        for choice in param.choices:\n                            if choice[0] == value:\n                                kwargs0[param.name] = choice[1]\n                                break\n                    else:\n                        kwargs0[param.name] = value\n                elif param.optional:\n                    kwargs0[param.name] = param.default\n                else:\n                    raise AttributeError('Missing value for {} parameter'.format(param.name))\n            if not _instance:\n                _instance = proc(**kwargs0)\n            else:\n                _instance.apply(_instance, **kwargs0)\n            return _instance.run()\n            # todo: cleanup\n        except Exception as e:\n            print(\"Error:\", e)\n#            traceback.print_exc()\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef index(self):\n        if self.bank is None:\n            raise IndexError('Pedalboard not contains a bank')\n\n        return self.bank.pedalboards.index(self)", "response": "Returns the index of the pedalboard in your bank"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconnecting two : class :. Effect instances in this pedalboard.", "response": "def connect(self, output_port, input_port):\n        \"\"\"\n        Connect two :class:`.Effect` instances in this pedalboard.\n        For this, is necessary informs the output port origin and the input port destination::\n\n            >>> pedalboard.append(driver)\n            >>> pedalboard.append(reverb)\n            >>> driver_output = driver.outputs[0]\n            >>> reverb_input = reverb.inputs[0]\n            >>> Connection(driver_output, reverb_input) in driver.connections\n            False\n            >>> pedalboard.connect(driver_output, reverb_input)\n            >>> Connection(driver_output, reverb_input) in driver.connections\n            True\n\n        :param Port output_port: Effect output port\n        :param Port input_port: Effect input port\n        \"\"\"\n        ConnectionClass = output_port.connection_class\n        self.connections.append(ConnectionClass(output_port, input_port))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef disconnect(self, output_port, input_port):\n        ConnectionClass = output_port.connection_class\n        self.connections.remove(ConnectionClass(output_port, input_port))", "response": "Removes a connection between two ports of the same type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transitions(self):\n        if self._transitions is not None:\n            return self._transitions\n        transitions = self.array.astype(np.float)\n        transitions /= transitions.sum(1)[:, np.newaxis]\n        self._transitions = transitions\n        return transitions", "response": "Dense [ k - 1 ] x4 transition frequency matrix"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef P(self):\n        if self._P is not None:\n            return self._P\n        sparse_P = sparse.lil_matrix((self.n, self.n))\n        alpha_size = len(self.alphabet)\n        bitmask = (self.n-1)  # Mask w/ all bits set hi within (k-1)mer range.\n        for fr in range(self.n):\n            for a in range(alpha_size):\n                to = (fr << 2 | a) & bitmask\n                sparse_P[fr, to] = self.transitions[fr, a]\n        self._P = sparse_P\n        return sparse_P", "response": "Sparse [ k - 1 ] x [ k - 1 ] transition frequency matrix."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef steady_state(self):\n        v, w = linalg.eigs(self.P.transpose(), which='LR')\n        ssf = np.real(w[:, v.argmax()])\n        ssf /= ssf.sum()\n        return ssf", "response": "Steady - state frequencies of each k - 1 - mer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stem_frequencies(self):\n        stemfreq = self.array.sum(axis=1).astype(np.float)\n        stemfreq /= stemfreq.sum()\n        return stemfreq", "response": "Returns the frequency of each stem in the log."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_process_pid(process_name):\n    try:\n        pid_filename = get_pid_filename(process_name)\n        with open(pid_filename, mode='r') as pid_file:\n            pid = int(pid_file.read().strip())\n    except IOError:\n        pid = None\n    return pid", "response": "check for process pid file and returns pid from there"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef kill_process(process_name):\n    try:\n        sys.stdout.write('killing: {0} {{ \\n'.format(process_name))\n        pid = get_process_pid(process_name)\n        if pid is not None and psutil.pid_exists(int(pid)):\n            p = psutil.Process(pid)\n            p.kill()\n            p.wait()\n            remove_pid_file(process_name)\n    except Exception as e:\n        sys.stderr.write('Exception on killing {0} : {1} \\n'.format(process_name, e))\n    finally:\n        sys.stdout.write('}')", "response": "method is called to kill a running process"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if a process is alive and returns True if the process is still alive and OK and False if the process was terminated.", "response": "def poll_process(process_name):\n    \"\"\" between killing a process and its actual termination lies poorly documented requirement -\n        <purging process' io pipes and reading exit status>.\n        this can be done either by os.wait() or process.wait()\n        :return True if the process is alive and OK and False is the process was terminated \"\"\"\n    try:\n        pid = get_process_pid(process_name)\n        if pid is None:\n            sys.stdout.write('PID file was not found. Process {0} is likely terminated.\\n'.format(process_name))\n            return False\n\n        p = psutil.Process(pid)\n        return_code = p.wait(timeout=0.01)\n\n        if return_code is None:\n            # process is already terminated\n            sys.stdout.write('Process {0} is terminated \\n'.format(process_name))\n            return False\n        else:\n            # process is terminated; possibly by OS\n            sys.stdout.write('Process {0} got terminated \\n'.format(process_name))\n            return False\n    except TimeoutExpired:\n        sys.stdout.write('Process {0} is alive and OK \\n'.format(process_name))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cancel(self):\n        self.event.clear()\n        if self.__timer is not None:\n            self.__timer.cancel()", "response": "stops the timer. call_back function is not called"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls the call_back function. interrupts the timer to start a new countdown", "response": "def trigger(self):\n        \"\"\" calls the call_back function. interrupts the timer to start a new countdown \"\"\"\n        self.call_back(*self.args, **self.kwargs)\n        if self.__timer is not None:\n            self.__timer.cancel()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the next run time in the specified time.", "response": "def next_run_in(self, utc_now=None):\n        \"\"\" :param utc_now: optional parameter to be used by Unit Tests as a definition of \"now\"\n            :return: timedelta instance presenting amount of time before the trigger is triggered next time\n         or None if the RepeatTimer instance is not running \"\"\"\n        if utc_now is None:\n            utc_now = datetime.utcnow()\n\n        if self.is_alive():\n            next_run = timedelta(seconds=self.interval_current) + self.activation_dt\n            return next_run - utc_now\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert session timestamp to hour format", "response": "def session_to_hour(timestamp):\n    \"\"\":param timestamp: as string in YYYYMMDDHHmmSS format\n    :return string in YYYYMMDDHH format\"\"\"\n    t = datetime.strptime(timestamp, SYNERGY_SESSION_PATTERN)\n    return t.strftime(SYNERGY_HOURLY_PATTERN)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a timeperiod in YYYYMMDDHH format to a day", "response": "def hour_to_day(timeperiod):\n    \"\"\":param timeperiod: as string in YYYYMMDDHH format\n    :return string in YYYYMMDD00 format\"\"\"\n    t = datetime.strptime(timeperiod, SYNERGY_HOURLY_PATTERN)\n    return t.strftime(SYNERGY_DAILY_PATTERN)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a date in YYYYMMDD00 format to a month", "response": "def day_to_month(timeperiod):\n    \"\"\":param timeperiod: as string in YYYYMMDD00 format\n    :return string in YYYYMM0000 format\"\"\"\n    t = datetime.strptime(timeperiod, SYNERGY_DAILY_PATTERN)\n    return t.strftime(SYNERGY_MONTHLY_PATTERN)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef month_to_year(timeperiod):\n    t = datetime.strptime(timeperiod, SYNERGY_MONTHLY_PATTERN)\n    return t.strftime(SYNERGY_YEARLY_PATTERN)", "response": "converts a timeperiod in YYYYMM0000 format to YYYY000000 format"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef increment_timeperiod(time_qualifier, timeperiod, delta=1):\n\n    pattern = define_pattern(timeperiod)\n    t = datetime.strptime(timeperiod, pattern)\n\n    if time_qualifier == QUALIFIER_HOURLY:\n        t = t + timedelta(hours=delta)\n        return t.strftime(SYNERGY_HOURLY_PATTERN)\n\n    elif time_qualifier == QUALIFIER_DAILY:\n        t = t + timedelta(days=delta)\n        return t.strftime(SYNERGY_DAILY_PATTERN)\n\n    elif time_qualifier == QUALIFIER_MONTHLY:\n        yearly_increment = abs(delta) // 12\n        yearly_increment = yearly_increment if delta >= 0 else -yearly_increment\n        monthly_increment = delta - yearly_increment * 12\n\n        if t.month + monthly_increment > 12:\n            new_month = t.month + monthly_increment - 12\n            new_year = t.year + yearly_increment + 1\n            t = t.replace(year=new_year, month=new_month)\n        elif t.month + monthly_increment < 1:\n            new_month = t.month + monthly_increment + 12\n            new_year = t.year + yearly_increment - 1\n            t = t.replace(year=new_year, month=new_month)\n        else:\n            t = t.replace(year=t.year + yearly_increment, month=t.month + monthly_increment)\n        return t.strftime(SYNERGY_MONTHLY_PATTERN)\n\n    elif time_qualifier == QUALIFIER_YEARLY:\n        t = t.replace(year=t.year + delta)\n        return t.strftime(SYNERGY_YEARLY_PATTERN)\n    else:\n        raise ValueError('unknown time qualifier: {0}'.format(time_qualifier))", "response": "method performs simple increment of the timeperiods of the current object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef datetime_to_synergy(time_qualifier, dt):\n    if time_qualifier == QUALIFIER_HOURLY:\n        date_format = SYNERGY_HOURLY_PATTERN\n    elif time_qualifier == QUALIFIER_DAILY:\n        date_format = SYNERGY_DAILY_PATTERN\n    elif time_qualifier == QUALIFIER_MONTHLY:\n        date_format = SYNERGY_MONTHLY_PATTERN\n    elif time_qualifier == QUALIFIER_YEARLY:\n        date_format = SYNERGY_YEARLY_PATTERN\n    elif time_qualifier == QUALIFIER_REAL_TIME:\n        date_format = SYNERGY_SESSION_PATTERN\n    else:\n        raise ValueError('unknown time qualifier: {0}'.format(time_qualifier))\n    return dt.strftime(date_format)", "response": "method parses datetime and returns Synergy Date"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef synergy_to_datetime(time_qualifier, timeperiod):\n    if time_qualifier == QUALIFIER_HOURLY:\n        date_format = SYNERGY_HOURLY_PATTERN\n    elif time_qualifier == QUALIFIER_DAILY:\n        date_format = SYNERGY_DAILY_PATTERN\n    elif time_qualifier == QUALIFIER_MONTHLY:\n        date_format = SYNERGY_MONTHLY_PATTERN\n    elif time_qualifier == QUALIFIER_YEARLY:\n        date_format = SYNERGY_YEARLY_PATTERN\n    elif time_qualifier == QUALIFIER_REAL_TIME:\n        date_format = SYNERGY_SESSION_PATTERN\n    else:\n        raise ValueError('unknown time qualifier: {0}'.format(time_qualifier))\n    return datetime.strptime(timeperiod, date_format).replace(tzinfo=None)", "response": "method receives timeperiod in Synergy format YYYYMMDDHH and convert it to UTC _naive_ datetime"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert Synergy Timestamp for session to UTC zone seconds since epoch", "response": "def session_to_epoch(timestamp):\n    \"\"\" converts Synergy Timestamp for session to UTC zone seconds since epoch \"\"\"\n    utc_timetuple = datetime.strptime(timestamp, SYNERGY_SESSION_PATTERN).replace(tzinfo=None).utctimetuple()\n    return calendar.timegm(utc_timetuple)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_class(kls):\n    parts = kls.split('.')\n    try:\n        # First, try to import module hosting starter function\n        module = '.'.join(parts[:-1])\n        m = __import__(module)\n    except ImportError:\n        # Alternatively, try to import module hosting Class with a starter method\n        module = '.'.join(parts[:-2])\n        m = __import__(module)\n\n    t = None\n    starter = None\n    for i in range(1, len(parts)):\n        comp = parts[i]\n        starter = parts[i:]\n        m = getattr(m, comp)\n\n        if isinstance(m, class_types):\n            t = type\n            starter = None if len(parts[i:]) == 1 else '.'.join(parts[i + 1:])\n            break\n        if isinstance(m, types.FunctionType):\n            t = types.FunctionType\n            starter = None\n            break\n\n    return t, m, starter", "response": "Returns a tuple of type object and starter for a given string."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions starts the process by process name", "response": "def start_by_process_name(process_name, *args):\n    \"\"\"\n    Function starts the process by:\n    1. retrieving its fully specified path name\n    2. if the path name ends with starter method - then creates an instance of the wrapping class\n        and calls <code>starter(*args)</code> method on it\n    3. if the path name ends with starter function - then retrieves its module\n        and calls <code>starter(*args)</code> function on it\n    \"\"\"\n    sys.stdout.write('INFO: Starter path {0} \\n'.format(context.process_context[process_name].classname))\n    t, m, starter = get_class(context.process_context[process_name].classname)\n    if isinstance(m, class_types):\n        sys.stdout.write('INFO: Starting process by calling starter method {0} \\n'.format(starter))\n        instance = m(process_name)\n        method = getattr(instance, starter)\n        method(*args)\n    elif isinstance(m, types.FunctionType):\n        sys.stdout.write('INFO: Starting module.\\n')\n        function = m\n        function(*args)\n    else:\n        raise ValueError('Improper starter path {0}'.format(context.process_context[process_name].classname))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding an LV2 plugin encapsulated as a jack client", "response": "def add(self, effect):\n        \"\"\"\n        Add an LV2 plugin encapsulated as a jack client\n\n        :param Lv2Effect effect: Effect that will be loaded as LV2 plugin encapsulated\n        \"\"\"\n        effect.instance = self.instance_index\n        self.instance_index += 1\n\n        self.connection.send(ProtocolParser.add(effect))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close(self):\n        if self.connection is not None:\n            self.connection.close()\n        if self.connection_fd is not None:\n            self.connection_fd.close()", "response": "Close the mod - host connection with mod - host"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _compute_and_transfer_to_progress(self, process_name, start_timeperiod, end_timeperiod, job_record):\n        source_collection_name = context.process_context[process_name].source\n        start_id = self.ds.highest_primary_key(source_collection_name, start_timeperiod, end_timeperiod)\n        end_id = self.ds.lowest_primary_key(source_collection_name, start_timeperiod, end_timeperiod)\n        uow, is_duplicate = self.insert_and_publish_uow(job_record, start_id, end_id)\n        self.update_job(job_record, uow, job.STATE_IN_PROGRESS)", "response": "method computes new unit_of_work for job record and transfer it to the progress queue"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the stem upper boundary for the dictionary s time_qualifier", "response": "def _get_stem_upper_boundary(self, timeperiod=None):\n        \"\"\"\n        :param timeperiod: optional parameter, applicable for QUALIFIER_DAILY qualifier only\n        :return: upper boundary for dictionary's time_qualifier\n        \"\"\"\n\n        if self.time_qualifier == QUALIFIER_HOURLY:\n            upper_boundary = 23\n        elif self.time_qualifier == QUALIFIER_DAILY:\n            if timeperiod:\n                # DAILY upper boundary is month-dependent\n                # i.e. it is 28 for Feb 2015; and 31 for Mar 2015\n                year, month, day, hour = time_helper.tokenize_timeperiod(timeperiod)\n                monthrange_tuple = calendar.monthrange(int(year), int(month))\n                upper_boundary = monthrange_tuple[1]\n            else:\n                upper_boundary = 28\n        elif self.time_qualifier == QUALIFIER_MONTHLY:\n            upper_boundary = 12\n        elif self.time_qualifier == QUALIFIER_YEARLY:\n            upper_boundary = 1\n        else:\n            raise ValueError('unknown time qualifier: {0}'.format(self.time_qualifier))\n        return upper_boundary"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _do_stem_grouping(self, timeperiod, stem):\n\n        # exclude 00 from lower boundary, unless the grouping == 1\n        lower_boundary = 0 if self.time_grouping == 1 else 1\n        upper_boundary = self._get_stem_upper_boundary(timeperiod)\n\n        for i in range(lower_boundary, upper_boundary):\n            candidate = i * self.time_grouping\n            if stem <= candidate <= upper_boundary:\n                return candidate\n        return upper_boundary", "response": "This method performs the stem grouping."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _translate_timeperiod(self, timeperiod):\n        if self.time_grouping == 1:\n            # no translation is performed for identity grouping\n            return timeperiod\n\n        # step 1: tokenize timeperiod into: (year, month, day, hour)\n        # for instance: daily 2015031400 -> ('2015', '03', '14', '00')\n        year, month, day, hour = time_helper.tokenize_timeperiod(timeperiod)\n\n        # step 2: perform grouping on the stem\n        # ex1: stem of 14 with grouping 20 -> 20\n        # ex2: stem of 21 with grouping 20 -> 23\n        if self.time_qualifier == QUALIFIER_HOURLY:\n            stem = self._do_stem_grouping(timeperiod, int(hour))\n            result = '{0}{1}{2}{3:02d}'.format(year, month, day, stem)\n        elif self.time_qualifier == QUALIFIER_DAILY:\n            stem = self._do_stem_grouping(timeperiod, int(day))\n            result = '{0}{1}{2:02d}{3}'.format(year, month, stem, hour)\n        else:  # self.time_qualifier == QUALIFIER_MONTHLY:\n            stem = self._do_stem_grouping(timeperiod, int(month))\n            result = '{0}{1:02d}{2}{3}'.format(year, stem, day, hour)\n        return result", "response": "method translates given timeperiod to the grouped timeperiod"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_time_trigger_string(trigger_frequency):\n    # replace multiple spaces with one\n    trigger_frequency = ' '.join(trigger_frequency.split())\n\n    if trigger_frequency.startswith(TRIGGER_PREAMBLE_AT):\n        # EventClock block\n        trigger_frequency = trigger_frequency[len(TRIGGER_PREAMBLE_AT):]\n        parsed_trigger_frequency = trigger_frequency.replace(' ', '').replace(',', ' ').split(' ')\n        timer_klass = EventClock\n    elif trigger_frequency.startswith(TRIGGER_PREAMBLE_EVERY):\n        # RepeatTimer block\n        trigger_frequency = trigger_frequency[len(TRIGGER_PREAMBLE_EVERY):]\n        parsed_trigger_frequency = int(trigger_frequency)\n        timer_klass = RepeatTimer\n    else:\n        raise ValueError('Unknown time trigger format {0}'.format(trigger_frequency))\n\n    return parsed_trigger_frequency, timer_klass", "response": "Parse a string in one of two formats of time trigger frequency and return a tuple of the parsed trigger frequency and timer class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef format_time_trigger_string(timer_instance):\n    if isinstance(timer_instance, RepeatTimer):\n        return TRIGGER_PREAMBLE_EVERY + str(timer_instance.interval_new)\n    elif isinstance(timer_instance, EventClock):\n        timestamps = [repr(x) for x in timer_instance.timestamps]\n        return TRIGGER_PREAMBLE_AT + ','.join(timestamps)\n    else:\n        raise ValueError('Unknown timer instance type {0}'.format(timer_instance.__class__.__name__))", "response": "Returns a human - readable string that can be used to display a time trigger."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef query_mongo(\n        database_name,\n        collection_name,\n        query={},\n        include_num_results=\"0\",\n        skip=0,\n        sort=None,\n        limit=getattr(\n            settings,\n            'MONGO_LIMIT',\n            200),\n        cast_strings_to_integers=False,\n        return_keys=()):\n    \"\"\"return a response_dict  with a list of search results\"\"\"\n\n    l = []\n    response_dict = {}\n\n    try:\n        mongodb_client_url = getattr(settings, 'MONGODB_CLIENT',\n                                 'mongodb://localhost:27017/')\n        mc = MongoClient(mongodb_client_url,document_class=OrderedDict)\n\n        db = mc[str(database_name)]\n        collection = db[str(collection_name)]\n\n        # Cast the query to integers\n        if cast_strings_to_integers:\n            query = cast_number_strings_to_integers(query)\n\n        # print query\n        if return_keys:\n            return_dict = {}\n            for k in return_keys:\n                return_dict[k] = 1\n            # print \"returndict=\",return_dict\n            mysearchresult = collection.find(\n                query, return_dict).skip(skip).limit(limit)\n        else:\n            mysearchresult = collection.find(query).skip(skip).limit(limit)\n\n        if sort:\n            mysearchresult.sort(sort)\n\n        response_dict['code'] = 200\n        if include_num_results == \"1\":\n            response_dict['num_results'] = response_dict['num_results'] = int(\n                mysearchresult.count(with_limit_and_skip=False))\n\n        if include_num_results == \"2\":\n            response_dict['num_results'] = response_dict['num_results'] = int(\n                mysearchresult.count(with_limit_and_skip=True))\n\n        response_dict['type'] = \"search-results\"\n        for d in mysearchresult:\n            d['id'] = d['_id'].__str__()\n            del d['_id']\n            l.append(d)\n        response_dict['results'] = l\n\n    except:\n        print(\"Error reading from Mongo\")\n        print(str(sys.exc_info()))\n        response_dict['num_results'] = 0\n        response_dict['code'] = 500\n        response_dict['type'] = \"Error\"\n        response_dict['results'] = []\n        response_dict['message'] = str(sys.exc_info())\n\n    return response_dict", "response": "Query the database for a set of items in a set of items in a set of items in a set of items."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nquery a set of items in a decending order of a set of items", "response": "def query_mongo_sort_decend(\n        database_name,\n        collection_name,\n        query={},\n        skip=0,\n        limit=getattr(\n            settings,\n            'MONGO_LIMIT',\n            200),\n    return_keys=(),\n        sortkey=None):\n    \"\"\"return a response_dict  with a list of search results in decending\n    order based on a sort key\n    \"\"\"\n\n    l = []\n    response_dict = {}\n\n    try:\n        mongodb_client_url = getattr(settings, 'MONGODB_CLIENT',\n                                     'mongodb://localhost:27017/')\n        mc = MongoClient(mongodb_client_url,document_class=OrderedDict)\n\n        db = mc[str(database_name)]\n        collection = db[str(collection_name)]\n\n        if return_keys:\n            return_dict = {}\n            for k in return_keys:\n                return_dict[k] = 1\n            # print \"returndict=\",return_dict\n            mysearchresult = collection.find(\n                query, return_dict).skip(skip).limit(limit).sort(\n                sortkey, DESCENDING)\n        else:\n            mysearchresult = collection.find(query).skip(\n                skip).limit(limit).sort(sortkey, DESCENDING)\n\n        # response_dict['num_results']=int(mysearchresult.count(with_limit_and_skip=False))\n        response_dict['code'] = 200\n        response_dict['type'] = \"search-results\"\n        for d in mysearchresult:\n            d['id'] = d['_id'].__str__()\n            del d['_id']\n            l.append(d)\n        response_dict['results'] = l\n\n    except:\n        print(\"Error reading from Mongo\")\n        print(str(sys.exc_info()))\n        response_dict['num_results'] = 0\n        response_dict['code'] = 500\n        response_dict['type'] = \"Error\"\n        response_dict['results'] = []\n        response_dict['message'] = str(sys.exc_info())\n    return response_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes from mongo helper", "response": "def delete_mongo(database_name, collection_name,\n                 query={}, just_one=False):\n    \"\"\"delete from mongo helper\"\"\"\n\n    l = []\n    response_dict = {}\n\n    try:\n        mongodb_client_url = getattr(settings, 'MONGODB_CLIENT',\n                                     'mongodb://localhost:27017/')\n        mc = MongoClient(mongodb_client_url, document_class=OrderedDict)\n        db = mc[str(database_name)]\n        collection = db[str(collection_name)]\n\n        mysearchresult = collection.remove(query, just_one)\n\n        response_dict['code'] = 200\n        response_dict['type'] = \"remove-confirmation\"\n\n    except:\n        # print \"Error reading from Mongo\"\n        # print str(sys.exc_info())\n        response_dict['num_results'] = 0\n        response_dict['code'] = 500\n        response_dict['type'] = \"Error\"\n        response_dict['results'] = []\n        response_dict['message'] = str(sys.exc_info())\n    return response_dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_mongo(document, database_name,\n                collection_name, update=False):\n    \"\"\"Write a document to the collection. Return a response_dict containing\n    the written record. Method functions as both insert or update based on update\n    parameter\"\"\"\n\n    l = []\n    response_dict = {}\n    try:\n        mongodb_client_url = getattr(settings, 'MONGODB_CLIENT',\n                                 'mongodb://localhost:27017/')\n        mc = MongoClient(mongodb_client_url,document_class=OrderedDict)\n        db = mc[str(database_name)]\n        collection = db[str(collection_name)]\n\n        # Cast the query to integers\n        # if settings.CAST_ININGS_TO_INTEGERS:\n        #    query = cast_number_strings_to_integers(query)\n\n        potential_key_found = False\n        existing_transaction_id = None\n        existing_mongo_id = None\n\n        # enforce non-repudiation constraint on create\n        # if document.has_key(\"transaction_id\"):\n        #    existing_transaction_id = collection.find_one({'transaction_id':document['transaction_id']})\n        #    if existing_transaction_id:\n        #        potential_key_found = True\n\n        if \"id\" in document:\n            document[\"_id\"] = ObjectId(document[\"id\"])\n            del document[\"id\"]\n\n        if \"_id\" in document:\n            existing_mongo_id = collection.find_one({'_id': document['_id']})\n            if existing_mongo_id:\n                potential_key_found = True\n\n        if update == False and potential_key_found == True:\n            \"\"\"409 conflict\"\"\"\n            response_dict['code'] = 409\n            response_dict['type'] = \"Error\"\n            response_dict['results'] = []\n            response_dict[\n                'message'] = \"Perhaps you meant to perform an update instead?\"\n            response_dict['errors'] = [\n                \"Conflict. This transaction_id has already been created.\", ]\n            return response_dict\n\n        elif update and potential_key_found:  # this is an update\n            # set kwargs _id to the existing_id to force to overwrite existing\n            # document\n\n            # if existing_transaction_id:\n            #\n            #    document['_id'] = ObjectId(existing_transaction_id['_id'])\n            #    document['history']=True\n            #    history_collection_name = \"%s_history\" % str(collection_name)\n            #    history_collection   = db[str(history_collection_name)]\n            #\n            #    history_object = existing_transaction_id\n            #    history_object['historical_id'] = existing_transaction_id['_id']\n            #    del history_object['_id']\n            #    #now write the record to the historical collection\n            #    written_object = history_collection.insert(history_object)\n\n            if existing_mongo_id:\n                document['_id'] = ObjectId(existing_mongo_id['_id'])\n                document['history'] = True\n                document['verified'] = False\n                history_collection_name = \"%s_history\" % str(collection_name)\n                history_collection = db[str(history_collection_name)]\n\n                # print history_collection\n                # print existing_mongo_id\n\n                history_object = existing_mongo_id\n\n                history_object['historical_id'] = existing_mongo_id['_id']\n                del history_object['_id']\n                # print history_object\n\n                # now write the record to the historical collection\n                written_object = history_collection.insert(history_object)\n\n            # update the record\n            myobjectid = collection.save(document)\n\n        else:\n            # this is new so perform an insert.\n            myobjectid = collection.insert(document)\n\n        # now fetch the record we just wrote so that we write it back to the\n        # DB.\n        myobject = collection.find_one({'_id': myobjectid})\n        response_dict['code'] = 200\n        response_dict['type'] = \"write-results\"\n        myobject['id'] = myobject['_id'].__str__()\n        del myobject['_id']\n        l.append(myobject)\n        response_dict['results'] = l\n\n    except:\n        # print \"Error reading from Mongo\"\n        # print str(sys.exc_info())\n        response_dict['code'] = 400\n        response_dict['type'] = \"Error\"\n        response_dict['results'] = []\n        response_dict['message'] = str(sys.exc_info())\n    return response_dict", "response": "Write a document to the collection."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bulk_csv_import_mongo(csvfile, database_name, collection_name,\n                          delete_collection_before_import=False):\n    \"\"\"return a response_dict  with a list of search results\"\"\"\n    \"\"\"method can be insert or update\"\"\"\n\n    l = []\n    response_dict = {}\n    try:\n        mongodb_client_url = getattr(settings, 'MONGODB_CLIENT',\n                                 'mongodb://localhost:27017/')\n        mc = MongoClient(mongodb_client_url,document_class=OrderedDict)\n        db = mconnection[database_name]\n        collection = db[collection_name]\n\n        if delete_collection_before_import:\n            myobjectid = collection.remove({})\n\n        # open the csv file.\n        csvhandle = csv.reader(open(csvfile._get_path(), 'rb'), delimiter=',')\n\n        rowindex = 0\n        errors = 0\n        error_list = []\n        success = 0\n        for row in csvhandle:\n\n            if rowindex == 0:\n                column_headers = row\n                cleaned_headers = []\n                for c in column_headers:\n                    c = c.replace(\".\", \"\")\n                    c = c.replace(\"$\", \"-\")\n                    c = c.replace(\" \", \"_\")\n                    cleaned_headers.append(c)\n            else:\n\n                record = OrderedDict(zip(cleaned_headers, row))\n                # if there is no values, skip the key value pair\n                kwargs = OrderedDict()\n\n                # Only populate fields that are not blank.\n                for k, v in record.items():\n                    if v:\n                        if v.isdigit():\n                            kwargs[k] = int(v)\n                        else:\n                            kwargs[k] = v\n                try:\n\n                    myobjectid = collection.insert(kwargs)\n                    success += 1\n                except:\n                    error_message = \"Error on row \" + \\\n                        rowindex + \". \" + str(sys.exc_info())\n                    error_list.append(str(sys.exc_info()))\n\n            rowindex += 1\n\n        if error_list:\n            response_dict = {}\n            response_dict['num_rows_imported'] = rowindex\n            response_dict['num_rows_errors'] = len(error_list)\n            response_dict['errors'] = error_list\n            response_dict['code'] = 400\n            response_dict['message'] = \"Completed with errors\"\n        else:\n\n            response_dict = {}\n            response_dict['num_rows_imported'] = success\n            response_dict['code'] = 200\n            response_dict['message'] = \"Completed.\"\n        return response_dict\n\n    except:\n        # print \"Error reading from Mongo\"\n        # print str(sys.exc_info())\n        response_dict['num_results'] = 0\n        response_dict['code'] = 400\n        response_dict['type'] = \"Error\"\n        response_dict['results'] = []\n        response_dict['message'] = str(sys.exc_info())\n    return response_dict", "response": "bulk_csv_import_mongo - import a CSV file into a MongoDB collection"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying a single object from a MongoDB database", "response": "def raw_query_mongo_db(kwargs, database_name, collection_name):\n    # for key in kwargs:\n    #    print \"arg: %s: %s\" % (key, kwargs[key])\n    \"\"\"return a result list or an empty list\"\"\"\n    l = []\n    response_dict = {}\n\n    try:\n        mongodb_client_url = getattr(settings, 'MONGODB_CLIENT',\n                                 'mongodb://localhost:27017/')\n        mc = MongoClient(mongodb_client_url,document_class=OrderedDict)\n        db = mc[database_name]\n        transactions = db[collection_name]\n        mysearchresult = transactions.find(kwargs)\n        mysearchcount = mysearchresult.count()\n        if mysearchcount > 0:\n            response_dict['code'] = 200\n            for d in mysearchresult:\n                l.append(d)\n            response_dict['results'] = l\n    except:\n        # print \"Error reading from Mongo\"\n        # print str(sys.exc_info())\n        response_dict['code'] = 400\n\n        response_dict['type'] = \"Error\"\n        response_dict['message'] = str(sys.exc_info())\n    return response_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cast_number_strings_to_integers(d):\n    for k, v in d.items():\n        # print type(v)\n        if determine_if_str_or_unicode(v):\n            if v.isdigit():\n                d[k] = int(v)\n    return d", "response": "d is a dict where keys are the names of the user s authors and values are integers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_details(cls, node, as_model=False):\n        rest_job = RestJob(\n            process_name=node.process_name,\n            timeperiod=node.timeperiod,\n            time_qualifier=node.time_qualifier,\n            number_of_children=len(node.children),\n            number_of_failures='NA' if not node.job_record else node.job_record.number_of_failures,\n            state='NA' if not node.job_record else node.job_record.state,\n            event_log=[] if not node.job_record else node.job_record.event_log)\n\n        if as_model:\n            return rest_job\n        else:\n            return rest_job.document", "response": "method returns either RestJob instance or corresponding document depending on the as_model argument"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef index(self):\n        if self.manager is None:\n            raise IndexError('Bank not contains a manager')\n\n        return self.manager.banks.index(self)", "response": "Returns the index of the given instance of a Bank."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the child entry associated with the given parent_qualifier", "response": "def get_child_by_qualifier(self, parent_qualifier):\n        \"\"\"\n        :param parent_qualifier: time_qualifier of the parent process\n        :return: <HierarchyEntry> child entry to the HierarchyEntry associated with the parent_qualifier\n                or None if the given parent_qualifier is not registered in this hierarchy\n                or None if the given parent_qualifier is the bottom process\n        \"\"\"\n        if parent_qualifier not in self.qualifiers:\n            return None\n\n        process_qualifiers = list(self.qualifiers)\n        if parent_qualifier == process_qualifiers[-1]:\n            return None\n\n        parent_index = process_qualifiers.index(parent_qualifier)\n        return self.qualifiers[process_qualifiers[parent_index + 1]]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef top_process(self):\n        key = next(iter(self.entries))\n        return self.entries[key].process_entry", "response": "Return the ManagedProcessEntry of the hierarchy s top entry"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bottom_process(self):\n        key = next(reversed(self.entries))\n        return self.entries[key].process_entry", "response": "Return the first managed process entry in the hierarchy"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _load_mod_ui_libraries(self, path):\n        path = path / Path('mod')\n        sys.path.append(str(path))", "response": "Load mod_ui libraries from path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a Pedalboard to a new version of it.", "response": "def convert(self, pedalboard_path, system_effect=None):\n        \"\"\"\n        :param Path pedalboard_path: Path that the pedalboard has been persisted.\n                                     Generally is in format `path/to/pedalboard/name.pedalboard`\n        :param SystemEffect system_effect: Effect that contains the audio interface outputs and inputs\n                                           or None for **auto discover**\n        :return Pedalboard: Pedalboard loaded\n        \"\"\"\n        info = self.get_pedalboard_info(pedalboard_path)\n\n        if system_effect is None:\n            system_effect = self.discover_system_effect(info)\n\n        pedalboard = Pedalboard(info['title'])\n\n        effects_instance = {}\n\n        for effect_data in info['plugins']:\n            effect = self._generate_effect(effect_data)\n            pedalboard.append(effect)\n            effects_instance[effect_data['instance']] = effect\n\n        try:\n            for connection_data in info['connections']:\n                output_port = self._get_port(connection_data['source'], effects_instance, system_effect)\n                input_port = self._get_port(connection_data['target'], effects_instance, system_effect)\n\n                pedalboard.connect(output_port, input_port)\n        except PortNotFoundError as e:\n            if self.ignore_errors:\n                print(\"WARNING:\", e)\n            else:\n                raise e\n\n        return pedalboard"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef discover_system_effect(self, pedalboard_info):\n        # MOD swap ins and outs!!!\n        hardware = pedalboard_info['hardware']\n\n        total_audio_outs = hardware['audio_ins']\n        total_audio_ins = hardware['audio_outs']\n\n        outputs = ['capture_{}'.format(i) for i in range(1, total_audio_outs+1)]\n        inputs = ['playback_{}'.format(i) for i in range(1, total_audio_ins+1)]\n\n        midi_inputs = [\n            'serial_midi_out' if hardware['serial_midi_out'] else midi_out['symbol']\n            for midi_out in hardware['midi_outs'] if midi_out['valid']\n        ]\n        midi_outputs = [\n            'serial_midi_in' if hardware['serial_midi_in'] else midi_in['symbol']\n            for midi_in in hardware['midi_ins'] if midi_in['valid']\n        ]\n\n        return SystemEffect('system', outputs, inputs, midi_outputs, midi_inputs)", "response": "Generate the system effect based in the given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _insert_uow(self, freerun_entry, flow_request=None):\n        process_entry = context.process_context[freerun_entry.process_name]\n        arguments = process_entry.arguments\n        arguments.update(freerun_entry.arguments)\n\n        if flow_request:\n            schedulable_name = flow_request.schedulable_name\n            timeperiod = flow_request.timeperiod\n            start_timeperiod = flow_request.start_timeperiod\n            end_timeperiod = flow_request.end_timeperiod\n            arguments.update(flow_request.arguments)\n        else:\n            schedulable_name = freerun_entry.schedulable_name\n            timeperiod = time_helper.actual_timeperiod(QUALIFIER_REAL_TIME)\n            start_timeperiod = timeperiod\n            end_timeperiod = timeperiod\n\n        uow = UnitOfWork()\n        uow.process_name = schedulable_name\n        uow.timeperiod = timeperiod\n        uow.start_id = 0\n        uow.end_id = 0\n        uow.start_timeperiod = start_timeperiod\n        uow.end_timeperiod = end_timeperiod\n        uow.created_at = datetime.utcnow()\n        uow.submitted_at = datetime.utcnow()\n        uow.source = process_entry.source if hasattr(process_entry, 'source') else None\n        uow.sink = process_entry.sink if hasattr(process_entry, 'sink') else None\n        uow.state = unit_of_work.STATE_REQUESTED\n        uow.unit_of_work_type = unit_of_work.TYPE_FREERUN\n        uow.number_of_retries = 0\n        uow.arguments = arguments\n        uow.db_id = self.uow_dao.insert(uow)\n\n        msg = 'Created: UOW {0} for {1}@{2}.' \\\n              .format(uow.db_id, freerun_entry.schedulable_name, timeperiod)\n        self._log_message(INFO, freerun_entry, msg)\n        return uow", "response": "Creates a UnitOfWork object and inserts it into the DB."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreset the UOW for a single flow entry", "response": "def _reset_flow_uow(self, freerun_entry, uow, flow_request):\n        \"\"\" there can be multiple freeruns for a single combination of workflow+step+timeperiod\n            hence, we have to *recycle* finished UOW \"\"\"\n        process_entry = context.process_context[freerun_entry.process_name]\n        arguments = process_entry.arguments\n        arguments.update(freerun_entry.arguments)\n        arguments.update(flow_request.arguments)\n\n        uow.created_at = datetime.utcnow()\n        uow.submitted_at = datetime.utcnow()\n        uow.state = unit_of_work.STATE_REQUESTED\n        uow.unit_of_work_type = unit_of_work.TYPE_FREERUN\n        del uow.started_at\n        del uow.finished_at\n        del uow.number_of_aggregated_documents\n        del uow.number_of_processed_documents\n        uow.number_of_retries = 0\n        uow.arguments = arguments\n        self.uow_dao.update(uow)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _process_terminal_state(self, freerun_entry, uow, flow_request=None):\n        msg = 'UOW for {0} found in state {1}.'.format(freerun_entry.schedulable_name, uow.state)\n        self._log_message(INFO, freerun_entry, msg)\n        self.insert_and_publish_uow(freerun_entry, flow_request, reset_uow=True)", "response": "method that takes care of processing unit_of_work records in\n            STATE_PROCESSED STATE_INVALID STATE_CANCELED states in\n            STATE_CANCELED states in\n            STATE_CANCELED states"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a tuple of tuples", "response": "def tupleize(\r\n    rows,\r\n    alphabetize_columns=getattr(\r\n        settings,\r\n        'ALPHABETIZE_COLUMNS',\r\n        False)):\r\n    \"\"\"Also alphabetizes columns and returns a tuple of tuples\"\"\"\r\n\r\n    # define a blank list as our return object\r\n    l = []\r\n    for r in rows:\r\n        row = []\r\n        row = list(r.values())\r\n        l.append(row)\r\n\r\n    # alphabetize\r\n    if alphabetize_columns:\r\n        col = sorted(zip(*l))\r\n        result = zip(*col)\r\n        return result\r\n    else:\r\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _flush_aggregated_objects(self):\n        if len(self.aggregated_objects) == 0:\n            # nothing to do\n            return 0\n\n        number_of_aggregated_objects = len(self.aggregated_objects)\n        self.logger.info('Aggregated {0} documents. Performing flush.'.format(number_of_aggregated_objects))\n\n        for key in self.aggregated_objects:\n            document = self.aggregated_objects[key]\n            mongo_pk = self._mongo_sink_key(*key)\n            self.ds.update(self.sink, mongo_pk, document)\n\n        self.logger.info('Flush successful.')\n\n        del self.aggregated_objects\n        self.aggregated_objects = dict()\n        gc.collect()\n        return number_of_aggregated_objects", "response": "method inserts aggregated objects into MongoDB\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_aggregated_object(self, composite_key):\n        if composite_key not in self.aggregated_objects:\n            self.aggregated_objects[composite_key] = self._init_sink_object(composite_key)\n        return self.aggregated_objects[composite_key]", "response": "method talks with the map of instances of aggregated objects\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _run_custom_data_engine(self, start_id_obj, end_id_obj, start_timeperiod, end_timeperiod):\n        collection_name = context.process_context[self.process_name].source\n        iteration = 0\n        while True:\n            cursor = self.ds.cursor_fine(collection_name,\n                                         start_id_obj,\n                                         end_id_obj,\n                                         iteration,\n                                         start_timeperiod,\n                                         end_timeperiod)\n\n            if iteration == 0 and cursor.count(with_limit_and_skip=True) == 0:\n                msg = 'No entries in {0} at range [{1} : {2}]'.format(collection_name, start_id_obj, end_id_obj)\n                self.logger.warning(msg)\n                break\n\n            start_id_obj = None\n            for document in cursor:\n                start_id_obj = document['_id']\n                self._process_single_document(document)\n                self.performance_tracker.increment_success()\n            if start_id_obj is None:\n                break\n            iteration += 1\n\n        self._cursor_exploited()\n        msg = 'Cursor exploited after {0} iterations'.format(iteration)\n        self.logger.info(msg)", "response": "Fine - tuned data engine. MongoDB legacy."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handle(self, sock, read_data, path, headers):\n        \"Sends back a static error page.\"\n        try:\n            sock.sendall(\"HTTP/1.0 %s %s\\r\\nConnection: close\\r\\nContent-length: 0\\r\\n\\r\\n\" % (self.code, responses.get(self.code, \"Unknown\")))\n        except socket.error, e:\n            if e.errno != errno.EPIPE:\n                raise", "response": "Sends back a static error page."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle(self, sock, read_data, path, headers):\n        \"Sends back a static error page.\"\n        assert self.type is not None\n        try:\n            # Get the correct file\n            try:\n                fh = open(os.path.join(self.balancer.static_dir, \"%s.http\" % self.type))\n            except IOError:\n                fh = open(os.path.join(os.path.dirname(__file__), \"static\", \"%s.http\" % self.type))\n            # Send it, using sendfile if poss. (no fileno() means we're probably using mock sockets)\n            try:\n                self._sendfile(sock.fileno(), fh.fileno(), 0, os.fstat(fh.fileno()).st_size)\n            except (TypeError, AttributeError):\n                sock.sendall(fh.read())\n            # Close the file and socket\n            fh.close()\n            sock.close()\n        except socket.error, e:\n            if e.errno != errno.EPIPE:\n                raise", "response": "Sends back a static error page."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends back a static error page.", "response": "def handle(self, sock, read_data, path, headers):\n        \"Sends back a static error page.\"\n        if \"://\" not in self.redirect_to:\n            destination = \"http%s://%s\" % (\n                \"s\" if headers.get('X-Forwarded-Protocol', headers.get('X-Forwarded-Proto', \"\")).lower() in (\"https\", \"ssl\") else \"\",\n                self.redirect_to\n            )\n        else:\n            destination = self.redirect_to\n        try:\n            sock.sendall(\"HTTP/1.0 302 Found\\r\\nLocation: %s/%s\\r\\n\\r\\n\" % (\n                destination.rstrip(\"/\"),\n                path.lstrip(\"/\"),\n            ))\n        except socket.error, e:\n            if e.errno != errno.EPIPE:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle(self, sock, read_data, path, headers):\n        \"Sends back a static error page.\"\n        for i in range(self.attempts):\n            try:\n                server_sock = eventlet.connect(\n                    tuple(random.choice(self.backends)),\n                )\n            except socket.error:\n                eventlet.sleep(self.delay)\n                continue\n            # Function to help track data usage\n            def send_onwards(data):\n                server_sock.sendall(data)\n                return len(data)\n            try:\n                size = send_onwards(read_data)\n                size += SocketMelder(sock, server_sock).run()\n            except socket.error, e:\n                if e.errno != errno.EPIPE:\n                    raise", "response": "Sends back a static error page."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_request_body(type, id, attributes=None, relationships=None):\n    result = {\n        \"data\": {\n            \"type\": type\n        }\n    }\n    data = result['data']\n    if attributes is not None:\n        data['attributes'] = attributes\n    if relationships is not None:\n        data['relationships'] = relationships\n    if id is not None:\n        data['id'] = id\n    return result", "response": "Builds a request body object for the specified resource type id attributes and relationships."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_request_relationship(type, ids):\n    if ids is None:\n        return {\n            'data': None\n        }\n    elif isinstance(ids, str):\n        return {\n            'data': {'id': ids, 'type': type}\n        }\n    else:\n        return {\n            \"data\": [{\"id\": id, \"type\": type} for id in ids]\n        }", "response": "Builds a relationship list for a resource request."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naugment request parameters with includes.", "response": "def build_request_include(include, params):\n    \"\"\"Augment request parameters with includes.\n\n    When one or all resources are requested an additional set of\n    resources can be requested as part of the request. This function\n    extends the given parameters for a request with a list of resource\n    types passed in as a list of :class:`Resource` subclasses.\n\n    Args:\n\n        include([Resource class]): A list of resource classes to include\n\n        params(dict): The (optional) dictionary of request parameters to extend\n\n    Returns:\n\n        An updated or new dictionary of parameters extended with an\n        include query parameter.\n\n    \"\"\"\n    params = params or OrderedDict()\n    if include is not None:\n        params['include'] = ','.join([cls._resource_type() for cls in include])\n    return params"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find(cls, session, resource_id, include=None):\n        url = session._build_url(cls._resource_path(), resource_id)\n        params = build_request_include(include, None)\n        process = cls._mk_one(session, include=include)\n        return session.get(url, CB.json(200, process), params=params)", "response": "Retrieve a single resource in the specified session."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef where(cls, session, include=None, metadata=None, filter=None):\n        url = session._build_url(cls._resource_path())\n        params = build_request_include(include, None)\n        if metadata is not None:\n            params['filter[metadata]'] = to_json(metadata)\n        process = cls._mk_many(session, include=include, filter=filter)\n        return session.get(url, CB.json(200, process), params=params)", "response": "Get filtered resources of the given resource class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(cls, session, attributes=None, relationships=None):\n        resource_type = cls._resource_type()\n        resource_path = cls._resource_path()\n        url = session._build_url(resource_path)\n        json = build_request_body(resource_type, None,\n                                  attributes=attributes,\n                                  relationships=relationships)\n        process = cls._mk_one(session)\n        return session.post(url, CB.json(201, process), json=json)", "response": "Create a new resource of the resource type."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the singleton API key for a given API key.", "response": "def singleton(cls, session, include=None):\n        \"\"\"Get the a singleton API resource.\n\n        Some Helium API resources are singletons. The authorized user\n        and organization for a given API key are examples of this.\n\n        .. code-block:: python\n\n            authorized_user = User.singleton(session)\n\n        will retrieve the authorized user for the given\n        :class:`Session`\n\n        Keyword Args:\n\n            include: Resource classes to include\n\n        \"\"\"\n        params = build_request_include(include, None)\n        url = session._build_url(cls._resource_path())\n        process = cls._mk_one(session, singleton=True, include=include)\n        return session.get(url, CB.json(200, process), params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, attributes=None):\n        resource_type = self._resource_type()\n        resource_path = self._resource_path()\n        session = self._session\n        singleton = self.is_singleton()\n        id = None if singleton else self.id\n        url = session._build_url(resource_path, id)\n        attributes = build_request_body(resource_type, self.id,\n                                        attributes=attributes)\n        process = self._mk_one(session, singleton=singleton)\n        return session.patch(url, CB.json(200, process), json=attributes)", "response": "Update this resource s attributes."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self):\n        session = self._session\n        url = session._build_url(self._resource_path(), self.id)\n        return session.delete(url, CB.boolean(204))", "response": "Delete the resource.\n\n        Returns:\n\n          True if the delete is successful. Will throw an error if\n          other errors occur"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef chmod(path, mode=None, user=None, group=None, other=None, recursive=False):\n    successful = True\n    mode = _ops_mode(mode)\n    if user is not None:\n        mode.user = user\n    if group is not None:\n        mode.group = group\n    if other is not None:\n        mode.other = other\n    if recursive:\n        for p in find(path, no_peek=True):\n            successful = _chmod(p, mode) and successful\n    else:\n        successful = _chmod(path, mode)\n    return successful", "response": "Change the permissions of a file or directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef chown(path, user=None, group=None, recursive=False):\n    successful = True\n    uid = -1\n    gid = -1\n    if user is not None:\n        if isinstance(user, basestring_type):\n            user = _ops_user(name=user)\n        elif isinstance(user, numbers.Number):\n            user = _ops_user(id=user)\n        if isinstance(user, _ops_user):\n            if user:\n                uid = user.id\n            else:\n                log.error('chown: unable to get uid')\n                successful = False\n        else:\n            successful = False\n    if group is not None:\n        if isinstance(group, basestring_type):\n            group = _ops_group(name=group)\n        elif isinstance(group, numbers.Number):\n            group = _ops_group(id=group)\n        if isinstance(group, _ops_group):\n            if group:\n                gid = group.id\n            else:\n                log.error('chown: unable to get gid')\n                successful = False\n        else:\n            successful = False\n    if not (uid == -1 and gid == -1):\n        if recursive:\n            for p in find(path, no_peek=True):\n                successful = _chown(p, uid=uid, gid=gid) and successful\n        else:\n            successful = _chown(path, uid=uid, gid=gid)\n    else:\n        successful = False\n    return successful", "response": "Change file owner and group."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncopying source to destination.", "response": "def cp(src_path, dst_path, follow_links=False, recursive=True):\n    \"\"\"Copy source to destination.\n\n      >>> if cp('/tmp/one', '/tmp/two'):\n      ...     print('OK')\n      OK\n    \"\"\"\n    successful = False\n    try:\n        if follow_links and os.path.islink(src_path):\n            src_path = os.path.realpath(src_path)\n        if follow_links and os.path.islink(dst_path):\n            dst_path = os.path.realpath(dst_path)\n        if os.path.isdir(src_path):\n            if not recursive:\n                return successful\n            shutil.copytree(src_path, dst_path, symlinks=follow_links)\n            successful = True\n        elif os.path.exists(src_path):\n            if os.path.isdir(dst_path):\n                dst_path = os.path.join(dst_path, os.path.basename(src_path))\n            shutil.copy2(src_path, dst_path)\n            successful = True\n        else:\n            log.error('cp: source not found: %s' % src_path)\n    except (OSError, TypeError) as error:\n        log.error('cp: execute failed: %s => %s (%s)' % (src_path, dst_path, error))\n    return successful"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexits and print text to stderr if code > 0 or stdout Elems otherwise.", "response": "def exit(code=0, text=''):\n    \"\"\"Exit and print text (if defined) to stderr if code > 0 or stdout\n    otherwise.\n\n      >>> exit(code=1, text='Invalid directory path')\n    \"\"\"\n    if not isinstance(text, basestring_type):\n        text = unicode_type(text)\n    if code > 0:\n        if text:\n            if not isinstance(text, basestring_type):\n                text = unicode_type(text)\n            sys.stderr.write(text)\n        sys.exit(code)\n    else:\n        if text:\n            print(text)\n        sys.exit(0)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef normalize(value, default=None, type=None, raise_exception=False):\n    NUMBER_RE = re.compile('^[-+]?(([0-9]+\\.?[0-9]*)|([0-9]*\\.?[0-9]+))$')\n    if type is None and default is None:\n        type = unicode_type\n    elif type is None:\n        type = type_(default)\n    if type in str_types:\n        if value is not None:\n            if isinstance(value, unicode_type):\n                return value\n            elif py3 and isinstance(value, bytes_type):\n                return value.decode('utf-8')\n            return unicode_type(value)\n        if default is None:\n            if raise_exception:\n                raise ValidationError('invalid string')\n            else:\n                return unicode_type()\n    elif type in (bool, 'bool', 'boolean'):\n        if value is not None:\n            value = value.lower().strip()\n            if value in ('1', 'true', 'yes', 'on'):\n                return True\n            elif value in ('0', 'false', 'no', 'off'):\n                return False\n        if default is None:\n            if raise_exception:\n                raise ValidationError('invalid boolean')\n            else:\n                return False\n    elif type in (numbers.Number, 'number'):\n        if value is not None:\n            if value.isdigit():\n                return int(value)\n            elif NUMBER_RE.match(value):\n                return eval(value)\n        if default is None:\n            if raise_exception:\n                raise ValidationError('invalid number')\n            else:\n                return 0\n    elif type in (int, 'int', 'integer'):\n        try:\n            return int(value)\n        except Exception:\n            if isinstance(value, basestring_type) and NUMBER_RE.match(value):\n                return int(eval(value))\n            if default is None:\n                if raise_exception:\n                    raise ValidationError('invalid number')\n                else:\n                    return 0\n    elif type in (float, 'float'):\n        if value is not None and NUMBER_RE.match(value):\n            return float(value)\n        if default is None:\n            if raise_exception:\n                raise ValidationError('invalid number')\n            else:\n                return 0.0\n    return default", "response": "Convert a string variable to a specified type."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rm(path, recursive=False):\n    try:\n        if recursive:\n            if os.path.isfile(path):\n                os.remove(path)\n            else:\n                shutil.rmtree(path)\n        else:\n            if os.path.isfile(path):\n                os.remove(path)\n            else:\n                os.rmdir(path)\n    except OSError as error:\n        log.error('rm: execute failed: %s (%s)' % (path, error))\n        return False\n    return True", "response": "Delete a specified file or directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns a shell command and wait for the response.", "response": "def run(command, **kwargs):\n    \"\"\"Run a shell command and wait for the response. The result object will\n    resolve to True if result.code == 0 and output/error results can be\n    retrieved from result.stdout and result.stderr variables.\n\n      >>> result = run('echo ${content}', content='Some $%^$## \"\" + \\' content')\n      >>> result.code\n      0\n      >>> if result:\n      ...     print('Stdout: %s' % result.stdout)\n      ... else:\n      ...     print('Stderr: %s' % result.stderr)\n      Stdout: Some $%^$## \"\" + ' content\n      >>> print(result.command)\n      echo 'Some $%^$## \"\" + '\"'\"' content'\n    \"\"\"\n    env = None\n    if 'env' in kwargs:\n        if kwargs.get('env_empty'):\n            env = {}\n        else:\n            env = copy.deepcopy(os.environ)\n        env.update(kwargs['env'])\n    stdin = kwargs.get('stdin')\n    stdout = kwargs.get('stdout', False)\n    stderr = kwargs.get('stderr', False)\n    combine = kwargs.get('combine', False)\n    if stdout is True:\n        stdout = sys.stdout.write\n    if stderr is True:\n        stderr = sys.stderr.write\n    if kwargs:\n        args = {}\n        q = pipes.quote\n        for name, value in kwargs.items():\n            if isinstance(value, basestring_type):\n                args[name] = q(value)\n            elif isinstance(value, (list, tuple)):\n                args[name] = u' '.join([q(unicode_type(v)) for v in value])\n            elif isinstance(value, dict):\n                args[name] = u' '.join([u'%s %s' % (q(n), q(v)) for n, v in value.items()])\n            else:\n                args[name] = pipes.quote(unicode_type(value))\n        command = string.Template(command).safe_substitute(args)\n    log.debug('run: %s' % command)\n    ref = subprocess.Popen(\n        command,\n        stdin=None if stdin is None else subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT if combine is True else subprocess.PIPE,\n        shell=kwargs.get('shell', True),\n        close_fds=kwargs.get('close_fds', True),\n        env=env,\n        cwd=kwargs.get('cwd', tempfile.gettempdir()),\n    )\n    if stdin is not None:\n        if not isinstance(stdin, basestring_type):\n            stdin = unicode_type(stdin)\n        if not isinstance(stdin, bytes_type):\n            stdin = stdin.encode('utf-8')\n        ref.stdin.write(stdin)\n        ref.stdin.flush()\n        ref.stdin.close()\n    fds = [ref.stdout]\n    if combine is not True:\n        fds.append(ref.stderr)\n    stdout_result = b''\n    stderr_result = b''\n    while fds:\n        for fd in select.select(fds, tuple(), tuple())[0]:\n            line = fd.readline()\n            if line:\n                if fd == ref.stdout:\n                    if stdout:\n                        stdout(line)\n                    stdout_result += line\n                elif fd == ref.stderr:\n                    if stderr:\n                        stderr(line)\n                    stderr_result += line\n            else:\n                fds.remove(fd)\n    ref.wait()\n    return obj({\n        'code': ref.returncode,\n        'command': command,\n        'stdout': stdout_result,\n        'stderr': stderr_result,\n    }, bool=ref.returncode == 0, grow=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a method builder that returns a metadata object for the given class.", "response": "def metadata():\n    \"\"\"Create a metadata method builder.\n\n    Returns:\n\n        A builder function that, given a class, creates a metadata\n        relationship for that class.\n    \"\"\"\n    def method_builder(cls):\n        method_doc = \"\"\"Fetch the metadata for this :class:`{0}`.\n\n        Returns:\n\n            The :class:`Metadata` for this :class:`{0}`\n        \"\"\".format(cls.__name__)\n\n        def method(self):\n            session = self._session\n            resource_id = None if self.is_singleton() else self.id\n            resource_path = cls._resource_path()\n            url = session._build_url(resource_path, resource_id, 'metadata')\n\n            def _process(json):\n                data = json.get('data')\n                metadata = Metadata(data, session, resource_path)\n                if self.is_singleton():\n                    setattr(metadata, '_singleton', True)\n                return metadata\n\n            return session.get(url, CB.json(200, _process))\n\n        method.__doc__ = method_doc\n        setattr(cls, 'metadata', method)\n        return cls\n\n    return method_builder"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _generate_hash(self, lista):\n        hash_elements = defaultdict(list)\n\n        for element in lista:\n            key = self.similarity_key(element)\n            hash_elements[key].append(element)\n\n        return hash_elements", "response": "Generate a hash of the list of similarity elements."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef drop_collection(request, database_name, collection_name):\n    name = \"\"\"Retype \"%s\" to drop the collection\"\"\" % (collection_name)\n    if request.method == 'POST':\n        form = ConfirmDropForm(request.POST)\n        if form.is_valid():\n            name = form.cleaned_data['name']\n            if name != collection_name:\n                messages.error(request, _('The name did not match. \\\n                                         Drop operation aborted'))\n                return HttpResponseRedirect(\n                    reverse(\n                        'djmongo_drop_collection',\n                        args=(\n                            database_name,\n                            collection_name)))\n\n            response = mongodb_drop_collection(database_name, collection_name)\n            if response:\n                errormsg = _(\"ERROR\", response)\n                messages.error(request, errormsg)\n                return HttpResponseRedirect(reverse('djmongo_show_dbs'))\n            else:\n                messages.success(request, _(\"The collection was deleted.\"))\n                return HttpResponseRedirect(reverse('djmongo_show_dbs'))\n        else:\n            # The form is invalid\n            messages.error(\n                request, _(\"Please correct the errors in the form.\"))\n            return render(request,\n                          'djmongo/console/generic/bootstrapform.html',\n                          {'form': form, 'name': name})\n    # This is a GET\n    context = {'name': name,\n               'form': ConfirmDropForm(\n                   initial={})}\n    return render(request, 'djmongo/console/generic/bootstrapform.html',\n                  context)", "response": "Drop a collection from a database."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef simple_ensure_index(request, database_name, collection_name):\n    name = \"Ensure a MongoDB index on a particular field name\"\n\n    if request.method == 'POST':\n        form = EnsureIndexForm(request.POST)\n\n        if form.is_valid():\n            result = form.save(database_name, collection_name)\n            messages.success(request,\n                             _(\"Index for %s created successfully\" % result))\n            return HttpResponseRedirect(reverse('djmongo_show_dbs'))\n        else:\n            # The form is invalid\n            messages.error(\n                request, _(\"Please correct the errors in the form.\"))\n            return render(request,\n                          'djmongo/console/generic/bootstrapform.html',\n                          {'form': form, 'name': name})\n\n    else:\n        # this is a GET\n        context = {'name': name,\n                   'form': EnsureIndexForm(\n                       initial={\"database_name\": database_name,\n                                \"collection_name\": collection_name})\n                   }\n        return render(request, 'djmongo/console/generic/bootstrapform.html',\n                      context)", "response": "Simple ensure index for a particular field name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_new_database(request):\n    name = \"Create a New MongoDB Database\"\n\n    if request.method == 'POST':\n        form = CreateDatabaseForm(request.POST)\n\n        if form.is_valid():\n            result = form.save()\n            if \"error\" in result:\n                messages.error(\n                    request, \"The database creation operation failed.\")\n                messages.error(request, result[\"error\"])\n            else:\n                messages.success(request, \"Database created.\")\n            return HttpResponseRedirect(reverse('djmongo_show_dbs'))\n        else:\n            # The form is invalid\n            messages.error(\n                request, _(\"Please correct the errors in the form.\"))\n            return render(request,\n                          'djmongo/console/generic/bootstrapform.html',\n                          {'form': form,\n                           'name': name})\n\n    else:\n        # this is a GET\n        context = {'name': name,\n                   'form': CreateDatabaseForm(\n                       initial={\"initial_document\": '{ \"foo\" : \"bar\" }'\n                                })\n                   }\n        return render(request, 'djmongo/console/generic/bootstrapform.html',\n                      context)", "response": "Create a New Mongo Database by adding a single document."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwrapping method with verification for is_request_valid", "response": "def valid_action_request(method):\n    \"\"\" wraps method with verification for is_request_valid\"\"\"\n\n    @functools.wraps(method)\n    def _wrapper(self, *args, **kwargs):\n        assert isinstance(self, BaseRequestHandler)\n        if not self.is_request_valid:\n            return self.reply_bad_request()\n\n        try:\n            return method(self, *args, **kwargs)\n        except UserWarning as e:\n            return self.reply_server_error(e)\n        except Exception as e:\n            return self.reply_server_error(e)\n\n    return _wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef safe_json_response(method):\n\n    def _safe_document(document):\n        \"\"\" function modifies the document in place\n            it iterates over the json document and stringify all non-string types\n            :return: modified document \"\"\"\n        assert isinstance(document, dict), 'Error: provided document is not of DICT type: {0}' \\\n            .format(document.__class__.__name__)\n\n        for key, value in document.items():\n            if isinstance(value, dict):\n                document[key] = {k: str(v) for k, v in value.items()}\n            elif isinstance(value, list):\n                document[key] = [str(v) for v in value]\n            else:\n                document[key] = str(document[key])\n        return document\n\n    @functools.wraps(method)\n    def _wrapper(self, *args, **kwargs):\n        try:\n            document = method(self, *args, **kwargs)\n            return _safe_document(document)\n        except Exception as e:\n            return self.reply_server_error(e)\n\n    return _wrapper", "response": "Decorator that makes sure the response has all leaf - fields converted to string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef download(self, torrent_id, directory, filename) :\n        return self.call('torrents/download/%s' % torrent_id, params={'filename' : filename, 'directory' : directory})", "response": "Download a torrent from the server to a directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nflushes the given queue of entries that have not expired.", "response": "def _flush_queue(self, q, ignore_priority=False):\n        \"\"\"\n        :param q: PriorityQueue instance holding GarbageCollector entries\n        :param ignore_priority: If True - all GarbageCollector entries should be resubmitted\n                If False - only those entries whose waiting time has expired will be resubmitted\n        \"\"\"\n        assert isinstance(q, PriorityQueue)\n\n        current_timestamp = compute_release_time(lag_in_minutes=0)\n        for _ in range(len(q)):\n            entry = q.pop()\n            assert isinstance(entry, PriorityEntry)\n\n            if ignore_priority or entry.release_time < current_timestamp:\n                self._resubmit_uow(entry.entry)\n            else:\n                q.put(entry)\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef flush(self, ignore_priority=False):\n        for process_name, q in self.reprocess_uows.items():\n            self._flush_queue(q, ignore_priority)", "response": "method flushes all the reprocessing queues and re - submissions UOWs that have expired"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending a message to the server and returns the message received.", "response": "def send(self, message):\n        \"\"\"\n        Sends message to *mod-host*.\n\n        .. note::\n\n            Uses :class:`.ProtocolParser` for a high-level management.\n            As example, view :class:`.Host`\n\n        :param string message: Message that will be sent for *mod-host*\n        \"\"\"\n        print(message.encode('utf-8'))\n        self.client.send(message.encode('utf-8'))\n        received = self.client.recv(1024)\n\n        return received"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns trees assigned to given MX Page", "response": "def mx_page_trees(self, mx_page):\n        \"\"\" return trees assigned to given MX Page \"\"\"\n        resp = dict()\n        for tree_name, tree in self.scheduler.timetable.trees.items():\n            if tree.mx_page == mx_page:\n                rest_tree = self._get_tree_details(tree_name)\n                resp[tree.tree_name] = rest_tree.document\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nform queue s context entry", "response": "def queue_context_entry(exchange,\n                        queue_name,\n                        routing=None):\n    \"\"\" forms queue's context entry \"\"\"\n    if routing is None:\n        routing = queue_name\n\n    queue_entry = QueueContextEntry(mq_queue=queue_name,\n                                    mq_exchange=exchange,\n                                    mq_routing_key=routing)\n    return queue_entry"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef select_parser(self, request, parsers):\n\n        if not request.content_type:\n            return parsers[0], parsers[0].mimetype\n\n        mimetype = MimeType.parse(request.content_type)\n\n        for parser in parsers:\n            if mimetype.match(parser.mimetype):\n                return parser, mimetype\n\n        return None, None", "response": "Selects the appropriated parser which matches to the request s content type."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef select_renderer(self, request, renderers):\n        if not len(request.accept_mimetypes):\n            return renderers[0], renderers[0].mimetype\n\n        for mimetype, quality in request.accept_mimetypes:\n            accept_mimetype = MimeType.parse(mimetype)\n            for renderer in renderers:\n                if accept_mimetype.match(renderer.mimetype):\n                    return renderer, renderer.mimetype.replace(params=accept_mimetype.params)\n\n        return None, None", "response": "Selects the appropriated parser which matches to the request s accept mimetype."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the FCSP SA and AUTH element and set the protocol auth type to the value of the auth_type attribute.", "response": "def fcsp_sa_fcsp_auth_proto_auth_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcsp_sa = ET.SubElement(config, \"fcsp-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-fc-auth\")\n        fcsp = ET.SubElement(fcsp_sa, \"fcsp\")\n        auth = ET.SubElement(fcsp, \"auth\")\n        proto = ET.SubElement(auth, \"proto\")\n        auth_type = ET.SubElement(proto, \"auth-type\")\n        auth_type.text = kwargs.pop('auth_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fcsp_sa_fcsp_auth_proto_group(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcsp_sa = ET.SubElement(config, \"fcsp-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-fc-auth\")\n        fcsp = ET.SubElement(fcsp_sa, \"fcsp\")\n        auth = ET.SubElement(fcsp, \"auth\")\n        proto = ET.SubElement(auth, \"proto\")\n        group = ET.SubElement(proto, \"group\")\n        group.text = kwargs.pop('group')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the related entry from the FCSP SA auth proto group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fcsp_sa_fcsp_auth_proto_hash(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcsp_sa = ET.SubElement(config, \"fcsp-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-fc-auth\")\n        fcsp = ET.SubElement(fcsp_sa, \"fcsp\")\n        auth = ET.SubElement(fcsp, \"auth\")\n        proto = ET.SubElement(auth, \"proto\")\n        hash = ET.SubElement(proto, \"hash\")\n        hash.text = kwargs.pop('hash')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the related FCSP SA and AUTH protocol hash for a specific FCS class"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fcsp_sa_fcsp_auth_policy_switch(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcsp_sa = ET.SubElement(config, \"fcsp-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-fc-auth\")\n        fcsp = ET.SubElement(fcsp_sa, \"fcsp\")\n        auth = ET.SubElement(fcsp, \"auth\")\n        policy = ET.SubElement(auth, \"policy\")\n        switch = ET.SubElement(policy, \"switch\")\n        switch.text = kwargs.pop('switch')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current FCSP SA entry and set the policy of the current FCSSP SA entry to switch."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of the SECPOLICY_SA section of the CO - Link", "response": "def secpolicy_sa_secpolicy_defined_policy_policies_policy(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        secpolicy_sa = ET.SubElement(config, \"secpolicy-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-fc-auth\")\n        secpolicy = ET.SubElement(secpolicy_sa, \"secpolicy\")\n        defined_policy = ET.SubElement(secpolicy, \"defined-policy\")\n        policies = ET.SubElement(defined_policy, \"policies\")\n        policy = ET.SubElement(policies, \"policy\")\n        policy.text = kwargs.pop('policy')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the configuration of the section SA secpolicy defined policy policies member entry member", "response": "def secpolicy_sa_secpolicy_defined_policy_policies_member_entry_member(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        secpolicy_sa = ET.SubElement(config, \"secpolicy-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-fc-auth\")\n        secpolicy = ET.SubElement(secpolicy_sa, \"secpolicy\")\n        defined_policy = ET.SubElement(secpolicy, \"defined-policy\")\n        policies = ET.SubElement(defined_policy, \"policies\")\n        policy_key = ET.SubElement(policies, \"policy\")\n        policy_key.text = kwargs.pop('policy')\n        member_entry = ET.SubElement(policies, \"member-entry\")\n        member = ET.SubElement(member_entry, \"member\")\n        member.text = kwargs.pop('member')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef secpolicy_sa_secpolicy_active_policy_policies_policy(self, **kwargs):\n        config = ET.Element(\"config\")\n        secpolicy_sa = ET.SubElement(config, \"secpolicy-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-fc-auth\")\n        secpolicy = ET.SubElement(secpolicy_sa, \"secpolicy\")\n        active_policy = ET.SubElement(secpolicy, \"active-policy\")\n        policies = ET.SubElement(active_policy, \"policies\")\n        policy = ET.SubElement(policies, \"policy\")\n        policy.text = kwargs.pop('policy')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current active policy for the SA secpolicy"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nenable the Alerting Link in the SFlow", "response": "def sflow_enable(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")\n        enable = ET.SubElement(sflow, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget collector IP address", "response": "def sflow_collector_collector_ip_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")\n        collector = ET.SubElement(sflow, \"collector\")\n        collector_port_number_key = ET.SubElement(collector, \"collector-port-number\")\n        collector_port_number_key.text = kwargs.pop('collector_port_number')\n        collector_ip_address = ET.SubElement(collector, \"collector-ip-address\")\n        collector_ip_address.text = kwargs.pop('collector_ip_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sflow_source_ip(self, **kwargs):\n        config = ET.Element(\"config\")\n        sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")\n        source_ip = ET.SubElement(sflow, \"source-ip\")\n        source_ip.text = kwargs.pop('source_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the object cache source IP"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting polling interval for the sflow", "response": "def sflow_polling_interval(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")\n        polling_interval = ET.SubElement(sflow, \"polling-interval\")\n        polling_interval.text = kwargs.pop('polling_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset sample rate of the current node", "response": "def sflow_sample_rate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")\n        sample_rate = ET.SubElement(sflow, \"sample-rate\")\n        sample_rate.text = kwargs.pop('sample_rate')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the name of the profile for the current sflow", "response": "def sflow_profile_profile_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        sflow_profile = ET.SubElement(config, \"sflow-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")\n        profile_name = ET.SubElement(sflow_profile, \"profile-name\")\n        profile_name.text = kwargs.pop('profile_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of the sflow profile profile_sampling_rate", "response": "def sflow_profile_profile_sampling_rate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        sflow_profile = ET.SubElement(config, \"sflow-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")\n        profile_name_key = ET.SubElement(sflow_profile, \"profile-name\")\n        profile_name_key.text = kwargs.pop('profile_name')\n        profile_sampling_rate = ET.SubElement(sflow_profile, \"profile-sampling-rate\")\n        profile_sampling_rate.text = kwargs.pop('profile_sampling_rate')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset VCS cluster mode", "response": "def vcsmode_vcs_cluster_mode(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vcsmode = ET.SubElement(config, \"vcsmode\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        vcs_cluster_mode = ET.SubElement(vcsmode, \"vcs-cluster-mode\")\n        vcs_cluster_mode.text = kwargs.pop('vcs_cluster_mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the current CMSCS date from the local node.", "response": "def local_node_swbd_number(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        local_node = ET.SubElement(config, \"local-node\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        swbd_number = ET.SubElement(local_node, \"swbd-number\")\n        swbd_number.text = kwargs.pop('swbd_number')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_last_config_update_time_output_last_config_update_time(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_last_config_update_time = ET.Element(\"get_last_config_update_time\")\n        config = get_last_config_update_time\n        output = ET.SubElement(get_last_config_update_time, \"output\")\n        last_config_update_time = ET.SubElement(output, \"last-config-update-time\")\n        last_config_update_time.text = kwargs.pop('last_config_update_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Last Config Update Time for a resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_vcs_output_principal_switch_wwn(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        principal_switch_wwn = ET.SubElement(output, \"principal-switch-wwn\")\n        principal_switch_wwn.text = kwargs.pop('principal_switch_wwn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS entry set principal switch WWN."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_vcs_output_co_ordinator_wwn(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        co_ordinator_wwn = ET.SubElement(output, \"co-ordinator-wwn\")\n        co_ordinator_wwn.text = kwargs.pop('co_ordinator_wwn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS co - ordinator - wwn."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing VCS Cluster Type Info element.", "response": "def show_vcs_output_vcs_cluster_type_info(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_cluster_type_info = ET.SubElement(output, \"vcs-cluster-type-info\")\n        vcs_cluster_type_info.text = kwargs.pop('vcs_cluster_type_info')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows VCS Entry and VCS GUID.", "response": "def show_vcs_output_vcs_guid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_guid = ET.SubElement(output, \"vcs-guid\")\n        vcs_guid.text = kwargs.pop('vcs_guid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_vcs_output_virtual_ip_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        virtual_ip_address = ET.SubElement(output, \"virtual-ip-address\")\n        virtual_ip_address.text = kwargs.pop('virtual_ip_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS virtual IP address."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow VCS virtual - ipv6 address.", "response": "def show_vcs_output_virtual_ipv6_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        virtual_ipv6_address = ET.SubElement(output, \"virtual-ipv6-address\")\n        virtual_ipv6_address.text = kwargs.pop('virtual_ipv6_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_vcs_output_total_nodes_in_cluster(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        total_nodes_in_cluster = ET.SubElement(output, \"total-nodes-in-cluster\")\n        total_nodes_in_cluster.text = kwargs.pop('total_nodes_in_cluster')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS total nodes in cluster."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows VCS Cluster Nodes Disconnected From Cluster", "response": "def show_vcs_output_nodes_disconnected_from_cluster(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        nodes_disconnected_from_cluster = ET.SubElement(output, \"nodes-disconnected-from-cluster\")\n        nodes_disconnected_from_cluster.text = kwargs.pop('nodes_disconnected_from_cluster')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_vcs_output_cluster_generic_status(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        cluster_generic_status = ET.SubElement(output, \"cluster-generic-status\")\n        cluster_generic_status.text = kwargs.pop('cluster_generic_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Cluster Generic Status"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nshow VCS cluster - specific status.", "response": "def show_vcs_output_cluster_specific_status(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        cluster_specific_status = ET.SubElement(output, \"cluster-specific-status\")\n        cluster_specific_status.text = kwargs.pop('cluster_specific_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshow VCS Node Information Element", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_node_num(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_num = ET.SubElement(vcs_node_info, \"node-num\")\n        node_num.text = kwargs.pop('node_num')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_serial_num(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_serial_num = ET.SubElement(vcs_node_info, \"node-serial-num\")\n        node_serial_num.text = kwargs.pop('node_serial_num')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Information Node Serial Number"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_condition(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_condition = ET.SubElement(vcs_node_info, \"node-condition\")\n        node_condition.text = kwargs.pop('node_condition')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Information Node Condition"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nshow VCS Node Status", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_node_status(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_status = ET.SubElement(vcs_node_info, \"node-status\")\n        node_status.text = kwargs.pop('node_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_hw_sync_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_hw_sync_state = ET.SubElement(vcs_node_info, \"node-hw-sync-state\")\n        node_hw_sync_state.text = kwargs.pop('node_hw_sync_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Information and Hardware Sync State"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_vcs_mode(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_vcs_mode = ET.SubElement(vcs_node_info, \"node-vcs-mode\")\n        node_vcs_mode.text = kwargs.pop('node_vcs_mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Information and VCS Mode."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_vcs_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_vcs_id = ET.SubElement(vcs_node_info, \"node-vcs-id\")\n        node_vcs_id.text = kwargs.pop('node_vcs_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Information Node VCS ID"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshow VCS output VCS node info and node - rbridge - id.", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_node_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_rbridge_id = ET.SubElement(vcs_node_info, \"node-rbridge-id\")\n        node_rbridge_id.text = kwargs.pop('node_rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_is_principal(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_is_principal = ET.SubElement(vcs_node_info, \"node-is-principal\")\n        node_is_principal.text = kwargs.pop('node_is_principal')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Info Node Is Principal"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nshow VCS Node Information and Co - Orinator.", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_co_ordinator(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        co_ordinator = ET.SubElement(vcs_node_info, \"co-ordinator\")\n        co_ordinator.text = kwargs.pop('co_ordinator')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows VCS Node Information and Node Switch MAC.", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_node_switch_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_switch_mac = ET.SubElement(vcs_node_info, \"node-switch-mac\")\n        node_switch_mac.text = kwargs.pop('node_switch_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nshow VCS Node Information and Node Switch WWN.", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_node_switch_wwn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_switch_wwn = ET.SubElement(vcs_node_info, \"node-switch-wwn\")\n        node_switch_wwn.text = kwargs.pop('node_switch_wwn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshowing VCS Node Information and Switch FCF MAC.", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_switch_fcf_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        switch_fcf_mac = ET.SubElement(vcs_node_info, \"switch-fcf-mac\")\n        switch_fcf_mac.text = kwargs.pop('switch_fcf_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshowing VCS Node Information Node Internal IP Address", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_node_internal_ip_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_internal_ip_address = ET.SubElement(vcs_node_info, \"node-internal-ip-address\")\n        node_internal_ip_address.text = kwargs.pop('node_internal_ip_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_public_ip_addresses_node_public_ip_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_public_ip_addresses = ET.SubElement(vcs_node_info, \"node-public-ip-addresses\")\n        node_public_ip_address = ET.SubElement(node_public_ip_addresses, \"node-public-ip-address\")\n        node_public_ip_address.text = kwargs.pop('node_public_ip_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Info and Node Public IP Address."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshows VCS Node Info and Node Public IPv6 Address.", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_node_public_ipv6_addresses_node_public_ipv6_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_public_ipv6_addresses = ET.SubElement(vcs_node_info, \"node-public-ipv6-addresses\")\n        node_public_ipv6_address = ET.SubElement(node_public_ipv6_addresses, \"node-public-ipv6-address\")\n        node_public_ipv6_address.text = kwargs.pop('node_public_ipv6_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows VCS Node Information Firmware Version", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_firmware_version(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        firmware_version = ET.SubElement(vcs_node_info, \"firmware-version\")\n        firmware_version.text = kwargs.pop('firmware_version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_swbd_number(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_swbd_number = ET.SubElement(vcs_node_info, \"node-swbd-number\")\n        node_swbd_number.text = kwargs.pop('node_swbd_number')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Information Node SWBD Number."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshowing VCS Node Information Node Switch Name", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_node_switchname(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_switchname = ET.SubElement(vcs_node_info, \"node-switchname\")\n        node_switchname.text = kwargs.pop('node_switchname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_switchtype(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_switchtype = ET.SubElement(vcs_node_info, \"node-switchtype\")\n        node_switchtype.text = kwargs.pop('node_switchtype')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Information and Node Switch Type"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_switch_subtype(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_switch_subtype = ET.SubElement(vcs_node_info, \"node-switch-subtype\")\n        node_switch_subtype.text = kwargs.pop('node_switch_subtype')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Information and Node Switch Subtype."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_switch_description(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_switch_description = ET.SubElement(vcs_node_info, \"node-switch-description\")\n        node_switch_description.text = kwargs.pop('node_switch_description')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Information and Node Switch Description."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow VCS Node Information for a VCS node.", "response": "def show_vcs_output_vcs_nodes_vcs_node_info_manufacturer_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        manufacturer_name = ET.SubElement(vcs_node_info, \"manufacturer-name\")\n        manufacturer_name.text = kwargs.pop('manufacturer_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_state = ET.SubElement(vcs_node_info, \"node-state\")\n        node_state.text = kwargs.pop('node_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Information Node State"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_vcs_output_vcs_nodes_vcs_node_info_node_fabric_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_vcs = ET.Element(\"show_vcs\")\n        config = show_vcs\n        output = ET.SubElement(show_vcs, \"output\")\n        vcs_nodes = ET.SubElement(output, \"vcs-nodes\")\n        vcs_node_info = ET.SubElement(vcs_nodes, \"vcs-node-info\")\n        node_fabric_state = ET.SubElement(vcs_node_info, \"node-fabric-state\")\n        node_fabric_state.text = kwargs.pop('node_fabric_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show VCS Node Info and Node Fabric State"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget VCS details output of principal switch WWN", "response": "def get_vcs_details_output_vcs_details_principal_switch_wwn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vcs_details = ET.Element(\"get_vcs_details\")\n        config = get_vcs_details\n        output = ET.SubElement(get_vcs_details, \"output\")\n        vcs_details = ET.SubElement(output, \"vcs-details\")\n        principal_switch_wwn = ET.SubElement(vcs_details, \"principal-switch-wwn\")\n        principal_switch_wwn.text = kwargs.pop('principal_switch_wwn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget VCS details output for CO - Orthinator WWN", "response": "def get_vcs_details_output_vcs_details_co_ordinator_wwn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vcs_details = ET.Element(\"get_vcs_details\")\n        config = get_vcs_details\n        output = ET.SubElement(get_vcs_details, \"output\")\n        vcs_details = ET.SubElement(output, \"vcs-details\")\n        co_ordinator_wwn = ET.SubElement(vcs_details, \"co-ordinator-wwn\")\n        co_ordinator_wwn.text = kwargs.pop('co_ordinator_wwn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget VCS details output for a local switch WWN", "response": "def get_vcs_details_output_vcs_details_local_switch_wwn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vcs_details = ET.Element(\"get_vcs_details\")\n        config = get_vcs_details\n        output = ET.SubElement(get_vcs_details, \"output\")\n        vcs_details = ET.SubElement(output, \"vcs-details\")\n        local_switch_wwn = ET.SubElement(vcs_details, \"local-switch-wwn\")\n        local_switch_wwn.text = kwargs.pop('local_switch_wwn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets VCS details output for a node VCS level", "response": "def get_vcs_details_output_vcs_details_node_vcs_mode(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vcs_details = ET.Element(\"get_vcs_details\")\n        config = get_vcs_details\n        output = ET.SubElement(get_vcs_details, \"output\")\n        vcs_details = ET.SubElement(output, \"vcs-details\")\n        node_vcs_mode = ET.SubElement(vcs_details, \"node-vcs-mode\")\n        node_vcs_mode.text = kwargs.pop('node_vcs_mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vcs_details_output_vcs_details_node_vcs_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vcs_details = ET.Element(\"get_vcs_details\")\n        config = get_vcs_details\n        output = ET.SubElement(get_vcs_details, \"output\")\n        vcs_details = ET.SubElement(output, \"vcs-details\")\n        node_vcs_type = ET.SubElement(vcs_details, \"node-vcs-type\")\n        node_vcs_type.text = kwargs.pop('node_vcs_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VCS Node VCS Type from XML node."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets VCS details output node VCS ID.", "response": "def get_vcs_details_output_vcs_details_node_vcs_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vcs_details = ET.Element(\"get_vcs_details\")\n        config = get_vcs_details\n        output = ET.SubElement(get_vcs_details, \"output\")\n        vcs_details = ET.SubElement(output, \"vcs-details\")\n        node_vcs_id = ET.SubElement(vcs_details, \"node-vcs-id\")\n        node_vcs_id.text = kwargs.pop('node_vcs_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconfiguring VCS Interrupt Config from VCS Id.", "response": "def vcs_rbridge_config_input_vcs_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vcs_rbridge_config = ET.Element(\"vcs_rbridge_config\")\n        config = vcs_rbridge_config\n        input = ET.SubElement(vcs_rbridge_config, \"input\")\n        vcs_id = ET.SubElement(input, \"vcs-id\")\n        vcs_id.text = kwargs.pop('vcs_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef vcs_rbridge_config_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcs_rbridge_config = ET.Element(\"vcs_rbridge_config\")\n        config = vcs_rbridge_config\n        input = ET.SubElement(vcs_rbridge_config, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VCS Interrupt Config from input rbridge ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconfigures VCS Interrupt Config for a resource.", "response": "def vcs_rbridge_context_input_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vcs_rbridge_context = ET.Element(\"vcs_rbridge_context\")\n        config = vcs_rbridge_context\n        input = ET.SubElement(vcs_rbridge_context, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Last Config Update Time for XPaths input xpath - strings xpath - string", "response": "def get_last_config_update_time_for_xpaths_input_xpath_strings_xpath_string(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_last_config_update_time_for_xpaths = ET.Element(\"get_last_config_update_time_for_xpaths\")\n        config = get_last_config_update_time_for_xpaths\n        input = ET.SubElement(get_last_config_update_time_for_xpaths, \"input\")\n        xpath_strings = ET.SubElement(input, \"xpath-strings\")\n        xpath_string = ET.SubElement(xpath_strings, \"xpath-string\")\n        xpath_string.text = kwargs.pop('xpath_string')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Last Config Update Time for XPaths output.", "response": "def get_last_config_update_time_for_xpaths_output_last_config_update_time_for_xpaths_xpath_string(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_last_config_update_time_for_xpaths = ET.Element(\"get_last_config_update_time_for_xpaths\")\n        config = get_last_config_update_time_for_xpaths\n        output = ET.SubElement(get_last_config_update_time_for_xpaths, \"output\")\n        last_config_update_time_for_xpaths = ET.SubElement(output, \"last-config-update-time-for-xpaths\")\n        xpath_string = ET.SubElement(last_config_update_time_for_xpaths, \"xpath-string\")\n        xpath_string.text = kwargs.pop('xpath_string')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the last config update time for xpaths output of the last config update for xpaths.", "response": "def get_last_config_update_time_for_xpaths_output_last_config_update_time_for_xpaths_last_config_update_time(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_last_config_update_time_for_xpaths = ET.Element(\"get_last_config_update_time_for_xpaths\")\n        config = get_last_config_update_time_for_xpaths\n        output = ET.SubElement(get_last_config_update_time_for_xpaths, \"output\")\n        last_config_update_time_for_xpaths = ET.SubElement(output, \"last-config-update-time-for-xpaths\")\n        xpath_string_key = ET.SubElement(last_config_update_time_for_xpaths, \"xpath-string\")\n        xpath_string_key.text = kwargs.pop('xpath_string')\n        last_config_update_time = ET.SubElement(last_config_update_time_for_xpaths, \"last-config-update-time\")\n        last_config_update_time.text = kwargs.pop('last_config_update_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets virtual IP address of a resource.", "response": "def vcs_virtual_ip_address_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vcs = ET.SubElement(config, \"vcs\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        virtual = ET.SubElement(vcs, \"virtual\")\n        ip = ET.SubElement(virtual, \"ip\")\n        address = ET.SubElement(ip, \"address\")\n        address = ET.SubElement(address, \"address\")\n        address.text = kwargs.pop('address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef vcs_virtual_ip_address_inband_interface_ve(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcs = ET.SubElement(config, \"vcs\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        virtual = ET.SubElement(vcs, \"virtual\")\n        ip = ET.SubElement(virtual, \"ip\")\n        address = ET.SubElement(ip, \"address\")\n        address_key = ET.SubElement(address, \"address\")\n        address_key.text = kwargs.pop('address')\n        inband = ET.SubElement(address, \"inband\")\n        interface = ET.SubElement(inband, \"interface\")\n        ve = ET.SubElement(interface, \"ve\")\n        ve.text = kwargs.pop('ve')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VCS virtual IP address inband interface and VE"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets virtual IPv6 address and ipv6 address.", "response": "def vcs_virtual_ipv6_address_ipv6address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vcs = ET.SubElement(config, \"vcs\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        virtual = ET.SubElement(vcs, \"virtual\")\n        ipv6 = ET.SubElement(virtual, \"ipv6\")\n        address = ET.SubElement(ipv6, \"address\")\n        ipv6address = ET.SubElement(address, \"ipv6address\")\n        ipv6address.text = kwargs.pop('ipv6address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vcs_virtual_fabric_vfab_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcs = ET.SubElement(config, \"vcs\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        virtual_fabric = ET.SubElement(vcs, \"virtual-fabric\")\n        vfab_enable = ET.SubElement(virtual_fabric, \"vfab-enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable VCS Virtual Fabric VFAB"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef vcsNodeState_originator_switch_info_switchIdentifier(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcsNodeState = ET.SubElement(config, \"vcsNodeState\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        originator_switch_info = ET.SubElement(vcsNodeState, \"originator-switch-info\")\n        switchIdentifier = ET.SubElement(originator_switch_info, \"switchIdentifier\")\n        switchIdentifier.text = kwargs.pop('switchIdentifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Current VCS Node Originator Switch Information"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Current VCS ID for the originator switch.", "response": "def vcsNodeState_originator_switch_info_switchVcsId(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vcsNodeState = ET.SubElement(config, \"vcsNodeState\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        originator_switch_info = ET.SubElement(vcsNodeState, \"originator-switch-info\")\n        switchVcsId = ET.SubElement(originator_switch_info, \"switchVcsId\")\n        switchVcsId.text = kwargs.pop('switchVcsId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting State of Originator Switch Information", "response": "def vcsNodeState_originator_switch_info_switchIpV4Address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vcsNodeState = ET.SubElement(config, \"vcsNodeState\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        originator_switch_info = ET.SubElement(vcsNodeState, \"originator-switch-info\")\n        switchIpV4Address = ET.SubElement(originator_switch_info, \"switchIpV4Address\")\n        switchIpV4Address.text = kwargs.pop('switchIpV4Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vcsNodeState_originator_switch_info_switchIpV6Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcsNodeState = ET.SubElement(config, \"vcsNodeState\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        originator_switch_info = ET.SubElement(vcsNodeState, \"originator-switch-info\")\n        switchIpV6Address = ET.SubElement(originator_switch_info, \"switchIpV6Address\")\n        switchIpV6Address.text = kwargs.pop('switchIpV6Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get State of Originator Switch Information"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the state of the node Rbridge ID", "response": "def vcsNodeState_nodeRbridgeid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vcsNodeState = ET.SubElement(config, \"vcsNodeState\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        nodeRbridgeid = ET.SubElement(vcsNodeState, \"nodeRbridgeid\")\n        nodeRbridgeid.text = kwargs.pop('nodeRbridgeid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vcsNodeState_nodeState(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcsNodeState = ET.SubElement(config, \"vcsNodeState\", xmlns=\"urn:brocade.com:mgmt:brocade-vcs\")\n        nodeState = ET.SubElement(vcsNodeState, \"nodeState\")\n        nodeState.text = kwargs.pop('nodeState')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set state of the node"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the configuration of the DPOD port ID", "response": "def dpod_port_id_port_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        dpod = ET.SubElement(config, \"dpod\", xmlns=\"urn:brocade.com:mgmt:brocade-license\")\n        port_id = ET.SubElement(dpod, \"port-id\")\n        port_id = ET.SubElement(port_id, \"port-id\")\n        port_id.text = kwargs.pop('port_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dpod_port_id_operation(self, **kwargs):\n        config = ET.Element(\"config\")\n        dpod = ET.SubElement(config, \"dpod\", xmlns=\"urn:brocade.com:mgmt:brocade-license\")\n        port_id = ET.SubElement(dpod, \"port-id\")\n        port_id_key = ET.SubElement(port_id, \"port-id\")\n        port_id_key.text = kwargs.pop('port_id')\n        operation = ET.SubElement(port_id, \"operation\")\n        operation.text = kwargs.pop('operation')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the DPOD port - id operation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the configuration of the NIC version", "response": "def confd_state_version(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        version = ET.SubElement(confd_state, \"version\")\n        version.text = kwargs.pop('version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of the Nagios SMP number of threads.", "response": "def confd_state_smp_number_of_threads(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        smp = ET.SubElement(confd_state, \"smp\")\n        number_of_threads = ET.SubElement(smp, \"number-of-threads\")\n        number_of_threads.text = kwargs.pop('number_of_threads')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef confd_state_epoll(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        epoll = ET.SubElement(confd_state, \"epoll\")\n        epoll.text = kwargs.pop('epoll')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of the Nagios Thread Endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the configuration of the NIC daemon status", "response": "def confd_state_daemon_status(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        daemon_status = ET.SubElement(confd_state, \"daemon-status\")\n        daemon_status.text = kwargs.pop('daemon_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the configuration of the NIC read - only mode", "response": "def confd_state_read_only_mode(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        read_only_mode = ET.SubElement(confd_state, \"read-only-mode\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the configuration of the NIC - Link Service upgrade - mode.", "response": "def confd_state_upgrade_mode(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        upgrade_mode = ET.SubElement(confd_state, \"upgrade-mode\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef confd_state_ha_mode(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        ha = ET.SubElement(confd_state, \"ha\")\n        mode = ET.SubElement(ha, \"mode\")\n        mode.text = kwargs.pop('mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the NIC AH mode"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the configuration of the HA node_id", "response": "def confd_state_ha_node_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        ha = ET.SubElement(confd_state, \"ha\")\n        node_id = ET.SubElement(ha, \"node-id\")\n        node_id.text = kwargs.pop('node_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef confd_state_ha_master_node_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        ha = ET.SubElement(confd_state, \"ha\")\n        master_node_id = ET.SubElement(ha, \"master-node-id\")\n        master_node_id.text = kwargs.pop('master_node_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the NIC s master node ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef confd_state_loaded_data_models_data_model_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        loaded_data_models = ET.SubElement(confd_state, \"loaded-data-models\")\n        data_model = ET.SubElement(loaded_data_models, \"data-model\")\n        name = ET.SubElement(data_model, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the loaded data models and data model name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef confd_state_loaded_data_models_data_model_revision(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        loaded_data_models = ET.SubElement(confd_state, \"loaded-data-models\")\n        data_model = ET.SubElement(loaded_data_models, \"data-model\")\n        name_key = ET.SubElement(data_model, \"name\")\n        name_key.text = kwargs.pop('name')\n        revision = ET.SubElement(data_model, \"revision\")\n        revision.text = kwargs.pop('revision')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the loaded data models and data model revision."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef confd_state_loaded_data_models_data_model_namespace(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        loaded_data_models = ET.SubElement(confd_state, \"loaded-data-models\")\n        data_model = ET.SubElement(loaded_data_models, \"data-model\")\n        name_key = ET.SubElement(data_model, \"name\")\n        name_key.text = kwargs.pop('name')\n        namespace = ET.SubElement(data_model, \"namespace\")\n        namespace.text = kwargs.pop('namespace')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the loaded data models and data model namespace."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the configuration of the loaded data models and data model prefix.", "response": "def confd_state_loaded_data_models_data_model_prefix(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        loaded_data_models = ET.SubElement(confd_state, \"loaded-data-models\")\n        data_model = ET.SubElement(loaded_data_models, \"data-model\")\n        name_key = ET.SubElement(data_model, \"name\")\n        name_key.text = kwargs.pop('name')\n        prefix = ET.SubElement(data_model, \"prefix\")\n        prefix.text = kwargs.pop('prefix')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef confd_state_loaded_data_models_data_model_exported_exported_to_all_exported_to_all(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        loaded_data_models = ET.SubElement(confd_state, \"loaded-data-models\")\n        data_model = ET.SubElement(loaded_data_models, \"data-model\")\n        name_key = ET.SubElement(data_model, \"name\")\n        name_key.text = kwargs.pop('name')\n        exported = ET.SubElement(data_model, \"exported\")\n        exported_to_all = ET.SubElement(exported, \"exported-to-all\")\n        exported_to_all = ET.SubElement(exported_to_all, \"exported-to-all\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize loaded data models data model exported to all exported to all."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the state of the NIC s NetConf listen TCP and IP.", "response": "def confd_state_netconf_listen_tcp_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        netconf = ET.SubElement(confd_state, \"netconf\")\n        listen = ET.SubElement(netconf, \"listen\")\n        tcp = ET.SubElement(listen, \"tcp\")\n        ip = ET.SubElement(tcp, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the state of Netconf listen TCP and Port.", "response": "def confd_state_netconf_listen_tcp_port(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        netconf = ET.SubElement(confd_state, \"netconf\")\n        listen = ET.SubElement(netconf, \"listen\")\n        tcp = ET.SubElement(listen, \"tcp\")\n        port = ET.SubElement(tcp, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the state of the NIC s Netconf listen and SSH IP.", "response": "def confd_state_netconf_listen_ssh_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        netconf = ET.SubElement(confd_state, \"netconf\")\n        listen = ET.SubElement(netconf, \"listen\")\n        ssh = ET.SubElement(listen, \"ssh\")\n        ip = ET.SubElement(ssh, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef confd_state_netconf_listen_ssh_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        netconf = ET.SubElement(confd_state, \"netconf\")\n        listen = ET.SubElement(netconf, \"listen\")\n        ssh = ET.SubElement(listen, \"ssh\")\n        port = ET.SubElement(ssh, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of Netconf listen and ssh ports."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the state of the cluster listen and ssh ip", "response": "def confd_state_cli_listen_ssh_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        cli = ET.SubElement(confd_state, \"cli\")\n        listen = ET.SubElement(cli, \"listen\")\n        ssh = ET.SubElement(listen, \"ssh\")\n        ip = ET.SubElement(ssh, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef confd_state_cli_listen_ssh_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        cli = ET.SubElement(confd_state, \"cli\")\n        listen = ET.SubElement(cli, \"listen\")\n        ssh = ET.SubElement(listen, \"ssh\")\n        port = ET.SubElement(ssh, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the Nagios cluster listen and ssh ports."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef confd_state_webui_listen_tcp_ip(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        webui = ET.SubElement(confd_state, \"webui\")\n        listen = ET.SubElement(webui, \"listen\")\n        tcp = ET.SubElement(listen, \"tcp\")\n        ip = ET.SubElement(tcp, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the NIC s webui listen TCP and IP."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef confd_state_webui_listen_tcp_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        webui = ET.SubElement(confd_state, \"webui\")\n        listen = ET.SubElement(webui, \"listen\")\n        tcp = ET.SubElement(listen, \"tcp\")\n        port = ET.SubElement(tcp, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the NIC s webui listen TCP and TCP ports."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the configuration of the NIC s webui listen and ssl IP.", "response": "def confd_state_webui_listen_ssl_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        webui = ET.SubElement(confd_state, \"webui\")\n        listen = ET.SubElement(webui, \"listen\")\n        ssl = ET.SubElement(listen, \"ssl\")\n        ip = ET.SubElement(ssl, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef confd_state_webui_listen_ssl_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        webui = ET.SubElement(confd_state, \"webui\")\n        listen = ET.SubElement(webui, \"listen\")\n        ssl = ET.SubElement(listen, \"ssl\")\n        port = ET.SubElement(ssl, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the NIC s webui listen and ssl ports."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of the NIC s rest_listen_tcp_ip attribute.", "response": "def confd_state_rest_listen_tcp_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        rest = ET.SubElement(confd_state, \"rest\")\n        listen = ET.SubElement(rest, \"listen\")\n        tcp = ET.SubElement(listen, \"tcp\")\n        ip = ET.SubElement(tcp, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef confd_state_rest_listen_tcp_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        rest = ET.SubElement(confd_state, \"rest\")\n        listen = ET.SubElement(rest, \"listen\")\n        tcp = ET.SubElement(listen, \"tcp\")\n        port = ET.SubElement(tcp, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Configuration of Rest Listen TCP and Port"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the configuration of the Nagios Domain", "response": "def confd_state_rest_listen_ssl_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        rest = ET.SubElement(confd_state, \"rest\")\n        listen = ET.SubElement(rest, \"listen\")\n        ssl = ET.SubElement(listen, \"ssl\")\n        ip = ET.SubElement(ssl, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets Configuration of Identity System", "response": "def confd_state_rest_listen_ssl_port(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        rest = ET.SubElement(confd_state, \"rest\")\n        listen = ET.SubElement(rest, \"listen\")\n        ssl = ET.SubElement(listen, \"ssl\")\n        port = ET.SubElement(ssl, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef confd_state_snmp_listen_udp_ip(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        snmp = ET.SubElement(confd_state, \"snmp\")\n        listen = ET.SubElement(snmp, \"listen\")\n        udp = ET.SubElement(listen, \"udp\")\n        ip = ET.SubElement(udp, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the NIC - related resources."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the configuration of the NIC s SNMP listen and UDP ports.", "response": "def confd_state_snmp_listen_udp_port(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        snmp = ET.SubElement(confd_state, \"snmp\")\n        listen = ET.SubElement(snmp, \"listen\")\n        udp = ET.SubElement(listen, \"udp\")\n        port = ET.SubElement(udp, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef confd_state_snmp_version_v1(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        snmp = ET.SubElement(confd_state, \"snmp\")\n        version = ET.SubElement(snmp, \"version\")\n        v1 = ET.SubElement(version, \"v1\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the NIC version 1."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef confd_state_snmp_version_v2c(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        snmp = ET.SubElement(confd_state, \"snmp\")\n        version = ET.SubElement(snmp, \"version\")\n        v2c = ET.SubElement(version, \"v2c\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the NIC version of the current NIC."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the configuration of the NIC version 3 of the current configuration.", "response": "def confd_state_snmp_version_v3(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        snmp = ET.SubElement(confd_state, \"snmp\")\n        version = ET.SubElement(snmp, \"version\")\n        v3 = ET.SubElement(version, \"v3\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the configuration of the NIC s SNMP engine ID.", "response": "def confd_state_snmp_engine_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        snmp = ET.SubElement(confd_state, \"snmp\")\n        engine_id = ET.SubElement(snmp, \"engine-id\")\n        engine_id.text = kwargs.pop('engine_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef confd_state_internal_callpoints_callpoint_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        callpoint = ET.SubElement(callpoints, \"callpoint\")\n        id = ET.SubElement(callpoint, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the internal callpoints and the id of the base class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef confd_state_internal_callpoints_callpoint_registration_type_range_path(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        callpoint = ET.SubElement(callpoints, \"callpoint\")\n        id_key = ET.SubElement(callpoint, \"id\")\n        id_key.text = kwargs.pop('id')\n        registration_type = ET.SubElement(callpoint, \"registration-type\")\n        range = ET.SubElement(registration_type, \"range\")\n        path = ET.SubElement(range, \"path\")\n        path.text = kwargs.pop('path')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the internal callpoints and the registration type and range path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the ID of the internal callpoints and validationpoint.", "response": "def confd_state_internal_callpoints_validationpoint_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        validationpoint = ET.SubElement(callpoints, \"validationpoint\")\n        id = ET.SubElement(validationpoint, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the configuration of the internal callpoints validationpoint registration type and file file.", "response": "def confd_state_internal_callpoints_validationpoint_registration_type_file_file(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        validationpoint = ET.SubElement(callpoints, \"validationpoint\")\n        id_key = ET.SubElement(validationpoint, \"id\")\n        id_key.text = kwargs.pop('id')\n        registration_type = ET.SubElement(validationpoint, \"registration-type\")\n        file = ET.SubElement(registration_type, \"file\")\n        file = ET.SubElement(file, \"file\")\n        file.text = kwargs.pop('file')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets internal callpoint id from confd state internal callpoints actionpoint id", "response": "def confd_state_internal_callpoints_actionpoint_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        actionpoint = ET.SubElement(callpoints, \"actionpoint\")\n        id = ET.SubElement(actionpoint, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the configuration of the internal callpoints SNMP inbound callback.", "response": "def confd_state_internal_callpoints_snmp_inform_callback_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        snmp_inform_callback = ET.SubElement(callpoints, \"snmp-inform-callback\")\n        id = ET.SubElement(snmp_inform_callback, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef confd_state_internal_callpoints_snmp_notification_subscription_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        snmp_notification_subscription = ET.SubElement(callpoints, \"snmp-notification-subscription\")\n        id = ET.SubElement(snmp_notification_subscription, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of internal callpoints SNMP notification subscription id."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef confd_state_internal_callpoints_error_formatting_callback_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        error_formatting_callback = ET.SubElement(callpoints, \"error-formatting-callback\")\n        id = ET.SubElement(error_formatting_callback, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the internal callpoints error formatting callback."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef confd_state_internal_callpoints_typepoint_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        typepoint = ET.SubElement(callpoints, \"typepoint\")\n        id = ET.SubElement(typepoint, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get internal callpoints typepoint id"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef confd_state_internal_callpoints_typepoint_registration_type_range_range_daemon_error(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        typepoint = ET.SubElement(callpoints, \"typepoint\")\n        id_key = ET.SubElement(typepoint, \"id\")\n        id_key.text = kwargs.pop('id')\n        registration_type = ET.SubElement(typepoint, \"registration-type\")\n        range = ET.SubElement(registration_type, \"range\")\n        range = ET.SubElement(range, \"range\")\n        daemon = ET.SubElement(range, \"daemon\")\n        error = ET.SubElement(daemon, \"error\")\n        error.text = kwargs.pop('error')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get internal callpoints typepoint registration type range and daemon error."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef confd_state_internal_callpoints_notification_stream_replay_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        notification_stream_replay = ET.SubElement(callpoints, \"notification-stream-replay\")\n        name = ET.SubElement(notification_stream_replay, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the internal callpoint notification stream replay."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the configuration of the internal callpoints notification stream replay support.", "response": "def confd_state_internal_callpoints_notification_stream_replay_replay_support(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        notification_stream_replay = ET.SubElement(callpoints, \"notification-stream-replay\")\n        name_key = ET.SubElement(notification_stream_replay, \"name\")\n        name_key.text = kwargs.pop('name')\n        replay_support = ET.SubElement(notification_stream_replay, \"replay-support\")\n        replay_support.text = kwargs.pop('replay_support')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the configuration of the internal callpoints notification stream replay registration type and range path.", "response": "def confd_state_internal_callpoints_notification_stream_replay_registration_type_range_path(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        notification_stream_replay = ET.SubElement(callpoints, \"notification-stream-replay\")\n        name_key = ET.SubElement(notification_stream_replay, \"name\")\n        name_key.text = kwargs.pop('name')\n        registration_type = ET.SubElement(notification_stream_replay, \"registration-type\")\n        range = ET.SubElement(registration_type, \"range\")\n        path = ET.SubElement(range, \"path\")\n        path.text = kwargs.pop('path')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef confd_state_internal_callpoints_notification_stream_replay_registration_type_file_file(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        notification_stream_replay = ET.SubElement(callpoints, \"notification-stream-replay\")\n        name_key = ET.SubElement(notification_stream_replay, \"name\")\n        name_key.text = kwargs.pop('name')\n        registration_type = ET.SubElement(notification_stream_replay, \"registration-type\")\n        file = ET.SubElement(registration_type, \"file\")\n        file = ET.SubElement(file, \"file\")\n        file.text = kwargs.pop('file')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the internal callpoints notification stream replay registration type and file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nenable or disable the authentication callback for the internal callpoints.", "response": "def confd_state_internal_callpoints_authentication_callback_enabled(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        authentication_callback = ET.SubElement(callpoints, \"authentication-callback\")\n        enabled = ET.SubElement(authentication_callback, \"enabled\")\n        enabled.text = kwargs.pop('enabled')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the configuration of the internal callpoints authentication callback registration type and range default.", "response": "def confd_state_internal_callpoints_authentication_callback_registration_type_range_range_default(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        authentication_callback = ET.SubElement(callpoints, \"authentication-callback\")\n        registration_type = ET.SubElement(authentication_callback, \"registration-type\")\n        range = ET.SubElement(registration_type, \"range\")\n        range = ET.SubElement(range, \"range\")\n        default = ET.SubElement(range, \"default\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef confd_state_internal_callpoints_authorization_callbacks_enabled(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        authorization_callbacks = ET.SubElement(callpoints, \"authorization-callbacks\")\n        enabled = ET.SubElement(authorization_callbacks, \"enabled\")\n        enabled.text = kwargs.pop('enabled')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Configure confd state internal callpoints authorization callbacks enabled"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the configuration of the confd_state internal_callpoints authorization callbacks registration type daemon name.", "response": "def confd_state_internal_callpoints_authorization_callbacks_registration_type_daemon_daemon_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        authorization_callbacks = ET.SubElement(callpoints, \"authorization-callbacks\")\n        registration_type = ET.SubElement(authorization_callbacks, \"registration-type\")\n        daemon = ET.SubElement(registration_type, \"daemon\")\n        daemon = ET.SubElement(daemon, \"daemon\")\n        name = ET.SubElement(daemon, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef confd_state_internal_callpoints_authorization_callbacks_registration_type_range_path(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        authorization_callbacks = ET.SubElement(callpoints, \"authorization-callbacks\")\n        registration_type = ET.SubElement(authorization_callbacks, \"registration-type\")\n        range = ET.SubElement(registration_type, \"range\")\n        path = ET.SubElement(range, \"path\")\n        path.text = kwargs.pop('path')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the internal callpoints authorization callbacks registration type and range path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the configuration of the internal callpoints authorization callbacks registration type and file.", "response": "def confd_state_internal_callpoints_authorization_callbacks_registration_type_file_file(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        callpoints = ET.SubElement(internal, \"callpoints\")\n        authorization_callbacks = ET.SubElement(callpoints, \"authorization-callbacks\")\n        registration_type = ET.SubElement(authorization_callbacks, \"registration-type\")\n        file = ET.SubElement(registration_type, \"file\")\n        file = ET.SubElement(file, \"file\")\n        file.text = kwargs.pop('file')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef confd_state_internal_cdb_datastore_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        cdb = ET.SubElement(internal, \"cdb\")\n        datastore = ET.SubElement(cdb, \"datastore\")\n        name = ET.SubElement(datastore, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the internal CDB and datastore."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the configuration of the internal CDB datastore and the transaction ID.", "response": "def confd_state_internal_cdb_datastore_transaction_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        cdb = ET.SubElement(internal, \"cdb\")\n        datastore = ET.SubElement(cdb, \"datastore\")\n        name_key = ET.SubElement(datastore, \"name\")\n        name_key.text = kwargs.pop('name')\n        transaction_id = ET.SubElement(datastore, \"transaction-id\")\n        transaction_id.text = kwargs.pop('transaction_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef confd_state_internal_cdb_datastore_pending_subscription_sync_priority(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        cdb = ET.SubElement(internal, \"cdb\")\n        datastore = ET.SubElement(cdb, \"datastore\")\n        name_key = ET.SubElement(datastore, \"name\")\n        name_key.text = kwargs.pop('name')\n        pending_subscription_sync = ET.SubElement(datastore, \"pending-subscription-sync\")\n        priority = ET.SubElement(pending_subscription_sync, \"priority\")\n        priority.text = kwargs.pop('priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of internal CDB datastore and pending subscription sync priority."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the state of internal CDB datastore and pending notification queue notifications priority.", "response": "def confd_state_internal_cdb_datastore_pending_notification_queue_notification_priority(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        cdb = ET.SubElement(internal, \"cdb\")\n        datastore = ET.SubElement(cdb, \"datastore\")\n        name_key = ET.SubElement(datastore, \"name\")\n        name_key.text = kwargs.pop('name')\n        pending_notification_queue = ET.SubElement(datastore, \"pending-notification-queue\")\n        notification = ET.SubElement(pending_notification_queue, \"notification\")\n        priority = ET.SubElement(notification, \"priority\")\n        priority.text = kwargs.pop('priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the name of the internal CDB client.", "response": "def confd_state_internal_cdb_client_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        cdb = ET.SubElement(internal, \"cdb\")\n        client = ET.SubElement(cdb, \"client\")\n        name = ET.SubElement(client, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting internal cdb client info", "response": "def confd_state_internal_cdb_client_info(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        cdb = ET.SubElement(internal, \"cdb\")\n        client = ET.SubElement(cdb, \"client\")\n        info = ET.SubElement(client, \"info\")\n        info.text = kwargs.pop('info')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the configuration of the internal cdb client type.", "response": "def confd_state_internal_cdb_client_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        cdb = ET.SubElement(internal, \"cdb\")\n        client = ET.SubElement(cdb, \"client\")\n        type = ET.SubElement(client, \"type\")\n        type.text = kwargs.pop('type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the state of internal CDB client lock.", "response": "def confd_state_internal_cdb_client_lock(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        cdb = ET.SubElement(internal, \"cdb\")\n        client = ET.SubElement(cdb, \"client\")\n        lock = ET.SubElement(client, \"lock\")\n        lock.text = kwargs.pop('lock')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef confd_state_internal_cdb_client_subscription_twophase(self, **kwargs):\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        cdb = ET.SubElement(internal, \"cdb\")\n        client = ET.SubElement(cdb, \"client\")\n        subscription = ET.SubElement(client, \"subscription\")\n        twophase = ET.SubElement(subscription, \"twophase\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of internal CDB client subscription and twophase."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the configuration of internal CDB client subscription and priority.", "response": "def confd_state_internal_cdb_client_subscription_priority(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        confd_state = ET.SubElement(config, \"confd-state\", xmlns=\"http://tail-f.com/yang/confd-monitoring\")\n        internal = ET.SubElement(confd_state, \"internal\")\n        cdb = ET.SubElement(internal, \"cdb\")\n        client = ET.SubElement(cdb, \"client\")\n        subscription = ET.SubElement(client, \"subscription\")\n        priority = ET.SubElement(subscription, \"priority\")\n        priority.text = kwargs.pop('priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the mimetype into a tuple with the full type and parameters.", "response": "def parse(cls, mimetype):\n        \"\"\"\n        Extracts the full type and parameters from the given MimeType.\n        :param str mimetype: The mimetype to be parsed.\n        :return: Returns a tuple with full type and parameters.\n        \"\"\"\n        plist = mimetype.split(';')\n\n        main_type, _, sub_type = plist.pop(0).lower().strip().partition('/')\n        params = {}\n\n        for p in plist:\n            kv = p.split('=')\n            if len(kv) != 2:\n                continue\n            v = kv[1].strip()\n            if v:\n                params[kv[0].strip()] = v\n\n        return MimeType(main_type, sub_type, params)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef match(self, other):\n        if self.sub_type != '*' and other.sub_type != '*' and other.sub_type != self.sub_type:\n            return False\n\n        if self.main_type != '*' and other.main_type != '*' and other.main_type != self.main_type:\n            return False\n\n        return True", "response": "Checks if the given MimeType matches to the this MimeType."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef replace(self, main_type=None, sub_type=None, params=None):\n        if main_type is None:\n            main_type = self.main_type\n\n        if sub_type is None:\n            sub_type = self.sub_type\n\n        if params is None:\n            params = self.params\n\n        return MimeType(main_type, sub_type, params)", "response": "Returns a new MimeType with new values for the specified fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef request_args(self):\n        '''\n        Returns the arguments passed with the request in a dictionary.\n        Returns both URL resolved arguments and query string arguments.\n        '''\n        kwargs = {}\n        kwargs.update(self.request.match_info.items())\n        kwargs.update(self.request.query.items())\n        return kwargs", "response": "Returns the arguments passed with the request in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hide_arp_holder_system_max_arp(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_arp_holder = ET.SubElement(config, \"hide-arp-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-arp\")\n        system_max = ET.SubElement(hide_arp_holder, \"system-max\")\n        arp = ET.SubElement(system_max, \"arp\")\n        arp.text = kwargs.pop('arp')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Hide ARP Holder for system max."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hide_arp_holder_arp_entry_arp_ip_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_arp_holder = ET.SubElement(config, \"hide-arp-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-arp\")\n        arp_entry = ET.SubElement(hide_arp_holder, \"arp-entry\")\n        arp_ip_address = ET.SubElement(arp_entry, \"arp-ip-address\")\n        arp_ip_address.text = kwargs.pop('arp_ip_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Hide ARP Holder for the entry and arp IP Address."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes an empty arp entry and set the MAC address value in the hide ARP holder.", "response": "def hide_arp_holder_arp_entry_mac_address_value(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_arp_holder = ET.SubElement(config, \"hide-arp-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-arp\")\n        arp_entry = ET.SubElement(hide_arp_holder, \"arp-entry\")\n        arp_ip_address_key = ET.SubElement(arp_entry, \"arp-ip-address\")\n        arp_ip_address_key.text = kwargs.pop('arp_ip_address')\n        mac_address_value = ET.SubElement(arp_entry, \"mac-address-value\")\n        mac_address_value.text = kwargs.pop('mac_address_value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhides ARP Holder for a specific resource", "response": "def hide_arp_holder_arp_entry_interfacename(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_arp_holder = ET.SubElement(config, \"hide-arp-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-arp\")\n        arp_entry = ET.SubElement(hide_arp_holder, \"arp-entry\")\n        arp_ip_address_key = ET.SubElement(arp_entry, \"arp-ip-address\")\n        arp_ip_address_key.text = kwargs.pop('arp_ip_address')\n        interfacename = ET.SubElement(arp_entry, \"interfacename\")\n        interfacename.text = kwargs.pop('interfacename')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhide ARP Entry Interfacetype Port Channel", "response": "def hide_arp_holder_arp_entry_interfacetype_Port_channel_Port_channel(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_arp_holder = ET.SubElement(config, \"hide-arp-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-arp\")\n        arp_entry = ET.SubElement(hide_arp_holder, \"arp-entry\")\n        arp_ip_address_key = ET.SubElement(arp_entry, \"arp-ip-address\")\n        arp_ip_address_key.text = kwargs.pop('arp_ip_address')\n        interfacetype = ET.SubElement(arp_entry, \"interfacetype\")\n        Port_channel = ET.SubElement(interfacetype, \"Port-channel\")\n        Port_channel = ET.SubElement(Port_channel, \"Port-channel\")\n        Port_channel.text = kwargs.pop('Port_channel')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhiding ARP Holder for Gigabit Ethernet", "response": "def hide_arp_holder_arp_entry_interfacetype_GigabitEthernet_GigabitEthernet(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_arp_holder = ET.SubElement(config, \"hide-arp-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-arp\")\n        arp_entry = ET.SubElement(hide_arp_holder, \"arp-entry\")\n        arp_ip_address_key = ET.SubElement(arp_entry, \"arp-ip-address\")\n        arp_ip_address_key.text = kwargs.pop('arp_ip_address')\n        interfacetype = ET.SubElement(arp_entry, \"interfacetype\")\n        GigabitEthernet = ET.SubElement(interfacetype, \"GigabitEthernet\")\n        GigabitEthernet = ET.SubElement(GigabitEthernet, \"GigabitEthernet\")\n        GigabitEthernet.text = kwargs.pop('GigabitEthernet')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhiding ARP Holder for Ten Gigabit Ethernet", "response": "def hide_arp_holder_arp_entry_interfacetype_TenGigabitEthernet_TenGigabitEthernet(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_arp_holder = ET.SubElement(config, \"hide-arp-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-arp\")\n        arp_entry = ET.SubElement(hide_arp_holder, \"arp-entry\")\n        arp_ip_address_key = ET.SubElement(arp_entry, \"arp-ip-address\")\n        arp_ip_address_key.text = kwargs.pop('arp_ip_address')\n        interfacetype = ET.SubElement(arp_entry, \"interfacetype\")\n        TenGigabitEthernet = ET.SubElement(interfacetype, \"TenGigabitEthernet\")\n        TenGigabitEthernet = ET.SubElement(TenGigabitEthernet, \"TenGigabitEthernet\")\n        TenGigabitEthernet.text = kwargs.pop('TenGigabitEthernet')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hide_arp_holder_arp_entry_interfacetype_FortyGigabitEthernet_FortyGigabitEthernet(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_arp_holder = ET.SubElement(config, \"hide-arp-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-arp\")\n        arp_entry = ET.SubElement(hide_arp_holder, \"arp-entry\")\n        arp_ip_address_key = ET.SubElement(arp_entry, \"arp-ip-address\")\n        arp_ip_address_key.text = kwargs.pop('arp_ip_address')\n        interfacetype = ET.SubElement(arp_entry, \"interfacetype\")\n        FortyGigabitEthernet = ET.SubElement(interfacetype, \"FortyGigabitEthernet\")\n        FortyGigabitEthernet = ET.SubElement(FortyGigabitEthernet, \"FortyGigabitEthernet\")\n        FortyGigabitEthernet.text = kwargs.pop('FortyGigabitEthernet')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Hide ARP Holder for specific interfacetype Forty Gigabit Ethernet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhiding ARP Holder entry for Hundred Gigabit Ethernet", "response": "def hide_arp_holder_arp_entry_interfacetype_HundredGigabitEthernet_HundredGigabitEthernet(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_arp_holder = ET.SubElement(config, \"hide-arp-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-arp\")\n        arp_entry = ET.SubElement(hide_arp_holder, \"arp-entry\")\n        arp_ip_address_key = ET.SubElement(arp_entry, \"arp-ip-address\")\n        arp_ip_address_key.text = kwargs.pop('arp_ip_address')\n        interfacetype = ET.SubElement(arp_entry, \"interfacetype\")\n        HundredGigabitEthernet = ET.SubElement(interfacetype, \"HundredGigabitEthernet\")\n        HundredGigabitEthernet = ET.SubElement(HundredGigabitEthernet, \"HundredGigabitEthernet\")\n        HundredGigabitEthernet.text = kwargs.pop('HundredGigabitEthernet')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hide_arp_holder_arp_entry_interfacetype_Ve_Ve(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_arp_holder = ET.SubElement(config, \"hide-arp-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-arp\")\n        arp_entry = ET.SubElement(hide_arp_holder, \"arp-entry\")\n        arp_ip_address_key = ET.SubElement(arp_entry, \"arp-ip-address\")\n        arp_ip_address_key.text = kwargs.pop('arp_ip_address')\n        interfacetype = ET.SubElement(arp_entry, \"interfacetype\")\n        Ve = ET.SubElement(interfacetype, \"Ve\")\n        Ve = ET.SubElement(Ve, \"Ve\")\n        Ve.text = kwargs.pop('Ve')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Hide ARP Holder Entry Interfacetype Ve"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_arp_input_input_type_interface_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        input = ET.SubElement(get_arp, \"input\")\n        input_type = ET.SubElement(input, \"input-type\")\n        interface = ET.SubElement(input_type, \"interface\")\n        interface_type = ET.SubElement(interface, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get APK input type and interface type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget ARP input - type interface - name", "response": "def get_arp_input_input_type_interface_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        input = ET.SubElement(get_arp, \"input\")\n        input_type = ET.SubElement(input, \"input-type\")\n        interface = ET.SubElement(input_type, \"interface\")\n        interface_name = ET.SubElement(interface, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_arp_input_input_type_dynamic_dynamic(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        input = ET.SubElement(get_arp, \"input\")\n        input_type = ET.SubElement(input, \"input-type\")\n        dynamic = ET.SubElement(input_type, \"dynamic\")\n        dynamic = ET.SubElement(dynamic, \"dynamic\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get ARP input - type dynamic - dynamic"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget ARP input - type static - static", "response": "def get_arp_input_input_type_static_static(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        input = ET.SubElement(get_arp, \"input\")\n        input_type = ET.SubElement(input, \"input-type\")\n        static = ET.SubElement(input_type, \"static\")\n        static = ET.SubElement(static, \"static\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_arp_input_input_type_ip_ip_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        input = ET.SubElement(get_arp, \"input\")\n        input_type = ET.SubElement(input, \"input-type\")\n        ip = ET.SubElement(input_type, \"ip\")\n        ip_address = ET.SubElement(ip, \"ip-address\")\n        ip_address.text = kwargs.pop('ip_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get ARP input - type ip - address"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_arp_output_arp_entry_ip_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        output = ET.SubElement(get_arp, \"output\")\n        arp_entry = ET.SubElement(output, \"arp-entry\")\n        ip_address = ET.SubElement(arp_entry, \"ip-address\")\n        ip_address.text = kwargs.pop('ip_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get ARP output entry ip_address."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_arp_output_arp_entry_mac_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        output = ET.SubElement(get_arp, \"output\")\n        arp_entry = ET.SubElement(output, \"arp-entry\")\n        ip_address_key = ET.SubElement(arp_entry, \"ip-address\")\n        ip_address_key.text = kwargs.pop('ip_address')\n        mac_address = ET.SubElement(arp_entry, \"mac-address\")\n        mac_address.text = kwargs.pop('mac_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get ARP output entry MAC address."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting ARP output entry interface type.", "response": "def get_arp_output_arp_entry_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        output = ET.SubElement(get_arp, \"output\")\n        arp_entry = ET.SubElement(output, \"arp-entry\")\n        ip_address_key = ET.SubElement(arp_entry, \"ip-address\")\n        ip_address_key.text = kwargs.pop('ip_address')\n        interface_type = ET.SubElement(arp_entry, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets ARP output entry for a specific interface name.", "response": "def get_arp_output_arp_entry_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        output = ET.SubElement(get_arp, \"output\")\n        arp_entry = ET.SubElement(output, \"arp-entry\")\n        ip_address_key = ET.SubElement(arp_entry, \"ip-address\")\n        ip_address_key.text = kwargs.pop('ip_address')\n        interface_name = ET.SubElement(arp_entry, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_arp_output_arp_entry_is_resolved(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        output = ET.SubElement(get_arp, \"output\")\n        arp_entry = ET.SubElement(output, \"arp-entry\")\n        ip_address_key = ET.SubElement(arp_entry, \"ip-address\")\n        ip_address_key.text = kwargs.pop('ip_address')\n        is_resolved = ET.SubElement(arp_entry, \"is-resolved\")\n        is_resolved.text = kwargs.pop('is_resolved')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the arp output entry is_resolved."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets ARP output entry age", "response": "def get_arp_output_arp_entry_age(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        output = ET.SubElement(get_arp, \"output\")\n        arp_entry = ET.SubElement(output, \"arp-entry\")\n        ip_address_key = ET.SubElement(arp_entry, \"ip-address\")\n        ip_address_key.text = kwargs.pop('ip_address')\n        age = ET.SubElement(arp_entry, \"age\")\n        age.text = kwargs.pop('age')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_arp_output_arp_entry_entry_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_arp = ET.Element(\"get_arp\")\n        config = get_arp\n        output = ET.SubElement(get_arp, \"output\")\n        arp_entry = ET.SubElement(output, \"arp-entry\")\n        ip_address_key = ET.SubElement(arp_entry, \"ip-address\")\n        ip_address_key.text = kwargs.pop('ip_address')\n        entry_type = ET.SubElement(arp_entry, \"entry-type\")\n        entry_type.text = kwargs.pop('entry_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get ARP output entry type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting BGP session state originator switch info switch identifier.", "response": "def BGPSessionState_originator_switch_info_switchIdentifier(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        BGPSessionState = ET.SubElement(config, \"BGPSessionState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(BGPSessionState, \"originator-switch-info\")\n        switchIdentifier = ET.SubElement(originator_switch_info, \"switchIdentifier\")\n        switchIdentifier.text = kwargs.pop('switchIdentifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef BGPSessionState_originator_switch_info_switchVcsId(self, **kwargs):\n        config = ET.Element(\"config\")\n        BGPSessionState = ET.SubElement(config, \"BGPSessionState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(BGPSessionState, \"originator-switch-info\")\n        switchVcsId = ET.SubElement(originator_switch_info, \"switchVcsId\")\n        switchVcsId.text = kwargs.pop('switchVcsId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get BGP session state originator switch info switch VcsId"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting BGP session state for originator switch info switchIpV4Address", "response": "def BGPSessionState_originator_switch_info_switchIpV4Address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        BGPSessionState = ET.SubElement(config, \"BGPSessionState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(BGPSessionState, \"originator-switch-info\")\n        switchIpV4Address = ET.SubElement(originator_switch_info, \"switchIpV4Address\")\n        switchIpV4Address.text = kwargs.pop('switchIpV4Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef BGPSessionState_originator_switch_info_switchIpV6Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        BGPSessionState = ET.SubElement(config, \"BGPSessionState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(BGPSessionState, \"originator-switch-info\")\n        switchIpV6Address = ET.SubElement(originator_switch_info, \"switchIpV6Address\")\n        switchIpV6Address.text = kwargs.pop('switchIpV6Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get BGP session state for originator switch info switchIpV6Address"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef BGPSessionState_BGPPeerIpAddress(self, **kwargs):\n        config = ET.Element(\"config\")\n        BGPSessionState = ET.SubElement(config, \"BGPSessionState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        BGPPeerIpAddress = ET.SubElement(BGPSessionState, \"BGPPeerIpAddress\")\n        BGPPeerIpAddress.text = kwargs.pop('BGPPeerIpAddress')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get BGP session state"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef BGPSessionState_BGPPeerState(self, **kwargs):\n        config = ET.Element(\"config\")\n        BGPSessionState = ET.SubElement(config, \"BGPSessionState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        BGPPeerState = ET.SubElement(BGPSessionState, \"BGPPeerState\")\n        BGPPeerState.text = kwargs.pop('BGPPeerState')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set BGP Session State Element"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting BGP Neighbor Prefix Exceeded Origininator Switch Information", "response": "def BGPNeighborPrefixExceeded_originator_switch_info_switchIdentifier(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        BGPNeighborPrefixExceeded = ET.SubElement(config, \"BGPNeighborPrefixExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(BGPNeighborPrefixExceeded, \"originator-switch-info\")\n        switchIdentifier = ET.SubElement(originator_switch_info, \"switchIdentifier\")\n        switchIdentifier.text = kwargs.pop('switchIdentifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget BGP Neighbor Prefix Exceeded Origininator Switch Information.", "response": "def BGPNeighborPrefixExceeded_originator_switch_info_switchVcsId(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        BGPNeighborPrefixExceeded = ET.SubElement(config, \"BGPNeighborPrefixExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(BGPNeighborPrefixExceeded, \"originator-switch-info\")\n        switchVcsId = ET.SubElement(originator_switch_info, \"switchVcsId\")\n        switchVcsId.text = kwargs.pop('switchVcsId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef BGPNeighborPrefixExceeded_originator_switch_info_switchIpV4Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        BGPNeighborPrefixExceeded = ET.SubElement(config, \"BGPNeighborPrefixExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(BGPNeighborPrefixExceeded, \"originator-switch-info\")\n        switchIpV4Address = ET.SubElement(originator_switch_info, \"switchIpV4Address\")\n        switchIpV4Address.text = kwargs.pop('switchIpV4Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get BGP Neighbor Prefix Exceeded Origininator Switch Info switchIpV4Address."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef BGPNeighborPrefixExceeded_originator_switch_info_switchIpV6Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        BGPNeighborPrefixExceeded = ET.SubElement(config, \"BGPNeighborPrefixExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(BGPNeighborPrefixExceeded, \"originator-switch-info\")\n        switchIpV6Address = ET.SubElement(originator_switch_info, \"switchIpV6Address\")\n        switchIpV6Address.text = kwargs.pop('switchIpV6Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get BGP Neighbor Prefix Exceeded Origininator Switch Info switchIpV6Address."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef BGPNeighborPrefixExceeded_BGPNeighborIpAddress(self, **kwargs):\n        config = ET.Element(\"config\")\n        BGPNeighborPrefixExceeded = ET.SubElement(config, \"BGPNeighborPrefixExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        BGPNeighborIpAddress = ET.SubElement(BGPNeighborPrefixExceeded, \"BGPNeighborIpAddress\")\n        BGPNeighborIpAddress.text = kwargs.pop('BGPNeighborIpAddress')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get BGP Neighbor Address"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets BGP Neighbor Prefix Exceeded Element", "response": "def BGPNeighborPrefixExceeded_neighborPrefixLimit(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        BGPNeighborPrefixExceeded = ET.SubElement(config, \"BGPNeighborPrefixExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        neighborPrefixLimit = ET.SubElement(BGPNeighborPrefixExceeded, \"neighborPrefixLimit\")\n        neighborPrefixLimit.text = kwargs.pop('neighborPrefixLimit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef RIBSystemRouteLimitExceeded_originator_switch_info_switchIdentifier(self, **kwargs):\n        config = ET.Element(\"config\")\n        RIBSystemRouteLimitExceeded = ET.SubElement(config, \"RIBSystemRouteLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBSystemRouteLimitExceeded, \"originator-switch-info\")\n        switchIdentifier = ET.SubElement(originator_switch_info, \"switchIdentifier\")\n        switchIdentifier.text = kwargs.pop('switchIdentifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get RIB System Route Limit Exceeded Originator Switch Information"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets RIB System Route Limit Exceeded Originator Switch Information", "response": "def RIBSystemRouteLimitExceeded_originator_switch_info_switchVcsId(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        RIBSystemRouteLimitExceeded = ET.SubElement(config, \"RIBSystemRouteLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBSystemRouteLimitExceeded, \"originator-switch-info\")\n        switchVcsId = ET.SubElement(originator_switch_info, \"switchVcsId\")\n        switchVcsId.text = kwargs.pop('switchVcsId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef RIBSystemRouteLimitExceeded_originator_switch_info_switchIpV4Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        RIBSystemRouteLimitExceeded = ET.SubElement(config, \"RIBSystemRouteLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBSystemRouteLimitExceeded, \"originator-switch-info\")\n        switchIpV4Address = ET.SubElement(originator_switch_info, \"switchIpV4Address\")\n        switchIpV4Address.text = kwargs.pop('switchIpV4Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get RIB System Route Limit Exceeded Originator Switch Info switchIpV4Address."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget RIB System Route Limit Exceeded Originator Switch Info switchIpV6Address.", "response": "def RIBSystemRouteLimitExceeded_originator_switch_info_switchIpV6Address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        RIBSystemRouteLimitExceeded = ET.SubElement(config, \"RIBSystemRouteLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBSystemRouteLimitExceeded, \"originator-switch-info\")\n        switchIpV6Address = ET.SubElement(originator_switch_info, \"switchIpV6Address\")\n        switchIpV6Address.text = kwargs.pop('switchIpV6Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef RIBSystemRouteLimitExceeded_RIBRouteLimit(self, **kwargs):\n        config = ET.Element(\"config\")\n        RIBSystemRouteLimitExceeded = ET.SubElement(config, \"RIBSystemRouteLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        RIBRouteLimit = ET.SubElement(RIBSystemRouteLimitExceeded, \"RIBRouteLimit\")\n        RIBRouteLimit.text = kwargs.pop('RIBRouteLimit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set RIB System Route Limit Exceeded for a resource"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting RIB Next Hop Limit Exceeded Originator Switch Information", "response": "def RIBNextHopLimitExceeded_originator_switch_info_switchIdentifier(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        RIBNextHopLimitExceeded = ET.SubElement(config, \"RIBNextHopLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBNextHopLimitExceeded, \"originator-switch-info\")\n        switchIdentifier = ET.SubElement(originator_switch_info, \"switchIdentifier\")\n        switchIdentifier.text = kwargs.pop('switchIdentifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget RIB Next Hop Limit Exceeded Originator Switch Information.", "response": "def RIBNextHopLimitExceeded_originator_switch_info_switchVcsId(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        RIBNextHopLimitExceeded = ET.SubElement(config, \"RIBNextHopLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBNextHopLimitExceeded, \"originator-switch-info\")\n        switchVcsId = ET.SubElement(originator_switch_info, \"switchVcsId\")\n        switchVcsId.text = kwargs.pop('switchVcsId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef RIBNextHopLimitExceeded_originator_switch_info_switchIpV4Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        RIBNextHopLimitExceeded = ET.SubElement(config, \"RIBNextHopLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBNextHopLimitExceeded, \"originator-switch-info\")\n        switchIpV4Address = ET.SubElement(originator_switch_info, \"switchIpV4Address\")\n        switchIpV4Address.text = kwargs.pop('switchIpV4Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get RIB Next Hop Limit Exceeded Originator Switch Info switchIpV4Address."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef RIBNextHopLimitExceeded_originator_switch_info_switchIpV6Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        RIBNextHopLimitExceeded = ET.SubElement(config, \"RIBNextHopLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBNextHopLimitExceeded, \"originator-switch-info\")\n        switchIpV6Address = ET.SubElement(originator_switch_info, \"switchIpV6Address\")\n        switchIpV6Address.text = kwargs.pop('switchIpV6Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get RIB Next Hop Limit Exceeded Originator Switch Info switchIpV6Address."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset RIB Next Hop Limit Exceeded for a resource.", "response": "def RIBNextHopLimitExceeded_RIBNextHopLimit(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        RIBNextHopLimitExceeded = ET.SubElement(config, \"RIBNextHopLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        RIBNextHopLimit = ET.SubElement(RIBNextHopLimitExceeded, \"RIBNextHopLimit\")\n        RIBNextHopLimit.text = kwargs.pop('RIBNextHopLimit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Originator Switch Information", "response": "def VxLANTunnelState_originator_switch_info_switchIdentifier(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        VxLANTunnelState = ET.SubElement(config, \"VxLANTunnelState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(VxLANTunnelState, \"originator-switch-info\")\n        switchIdentifier = ET.SubElement(originator_switch_info, \"switchIdentifier\")\n        switchIdentifier.text = kwargs.pop('switchIdentifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef VxLANTunnelState_originator_switch_info_switchVcsId(self, **kwargs):\n        config = ET.Element(\"config\")\n        VxLANTunnelState = ET.SubElement(config, \"VxLANTunnelState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(VxLANTunnelState, \"originator-switch-info\")\n        switchVcsId = ET.SubElement(originator_switch_info, \"switchVcsId\")\n        switchVcsId.text = kwargs.pop('switchVcsId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Originator Switch Info"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef VxLANTunnelState_originator_switch_info_switchIpV4Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        VxLANTunnelState = ET.SubElement(config, \"VxLANTunnelState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(VxLANTunnelState, \"originator-switch-info\")\n        switchIpV4Address = ET.SubElement(originator_switch_info, \"switchIpV4Address\")\n        switchIpV4Address.text = kwargs.pop('switchIpV4Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Originator Switch Info"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets Originator Switch Info", "response": "def VxLANTunnelState_originator_switch_info_switchIpV6Address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        VxLANTunnelState = ET.SubElement(config, \"VxLANTunnelState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(VxLANTunnelState, \"originator-switch-info\")\n        switchIpV6Address = ET.SubElement(originator_switch_info, \"switchIpV6Address\")\n        switchIpV6Address.text = kwargs.pop('switchIpV6Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets tunnel destination IP Address in the state of the Tunnel.", "response": "def VxLANTunnelState_TunnelDestinationIpAddress(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        VxLANTunnelState = ET.SubElement(config, \"VxLANTunnelState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        TunnelDestinationIpAddress = ET.SubElement(VxLANTunnelState, \"TunnelDestinationIpAddress\")\n        TunnelDestinationIpAddress.text = kwargs.pop('TunnelDestinationIpAddress')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Tunnel State Element", "response": "def VxLANTunnelState_TunnelState(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        VxLANTunnelState = ET.SubElement(config, \"VxLANTunnelState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        TunnelState = ET.SubElement(VxLANTunnelState, \"TunnelState\")\n        TunnelState.text = kwargs.pop('TunnelState')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef OSPFNeighborState_originator_switch_info_switchIdentifier(self, **kwargs):\n        config = ET.Element(\"config\")\n        OSPFNeighborState = ET.SubElement(config, \"OSPFNeighborState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(OSPFNeighborState, \"originator-switch-info\")\n        switchIdentifier = ET.SubElement(originator_switch_info, \"switchIdentifier\")\n        switchIdentifier.text = kwargs.pop('switchIdentifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Originator Switch Information"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget OSPF Neighbor Switch Info", "response": "def OSPFNeighborState_originator_switch_info_switchVcsId(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        OSPFNeighborState = ET.SubElement(config, \"OSPFNeighborState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(OSPFNeighborState, \"originator-switch-info\")\n        switchVcsId = ET.SubElement(originator_switch_info, \"switchVcsId\")\n        switchVcsId.text = kwargs.pop('switchVcsId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting state of originator switch info", "response": "def OSPFNeighborState_originator_switch_info_switchIpV4Address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        OSPFNeighborState = ET.SubElement(config, \"OSPFNeighborState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(OSPFNeighborState, \"originator-switch-info\")\n        switchIpV4Address = ET.SubElement(originator_switch_info, \"switchIpV4Address\")\n        switchIpV4Address.text = kwargs.pop('switchIpV4Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef OSPFNeighborState_originator_switch_info_switchIpV6Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        OSPFNeighborState = ET.SubElement(config, \"OSPFNeighborState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(OSPFNeighborState, \"originator-switch-info\")\n        switchIpV6Address = ET.SubElement(originator_switch_info, \"switchIpV6Address\")\n        switchIpV6Address.text = kwargs.pop('switchIpV6Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get state of originator switch info"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef OSPFNeighborState_OSPFNeighborIpAddress(self, **kwargs):\n        config = ET.Element(\"config\")\n        OSPFNeighborState = ET.SubElement(config, \"OSPFNeighborState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        OSPFNeighborIpAddress = ET.SubElement(OSPFNeighborState, \"OSPFNeighborIpAddress\")\n        OSPFNeighborIpAddress.text = kwargs.pop('OSPFNeighborIpAddress')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of the OSPF neighbor IP address."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef OSPFNeighborState_NeighborState(self, **kwargs):\n        config = ET.Element(\"config\")\n        OSPFNeighborState = ET.SubElement(config, \"OSPFNeighborState\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        NeighborState = ET.SubElement(OSPFNeighborState, \"NeighborState\")\n        NeighborState.text = kwargs.pop('NeighborState')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of the OSPF neighbor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef VRRPNewMaster_originator_switch_info_switchIdentifier(self, **kwargs):\n        config = ET.Element(\"config\")\n        VRRPNewMaster = ET.SubElement(config, \"VRRPNewMaster\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(VRRPNewMaster, \"originator-switch-info\")\n        switchIdentifier = ET.SubElement(originator_switch_info, \"switchIdentifier\")\n        switchIdentifier.text = kwargs.pop('switchIdentifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Current Originator Switch Information"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget Current VRRP originator switch Vcs Id.", "response": "def VRRPNewMaster_originator_switch_info_switchVcsId(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        VRRPNewMaster = ET.SubElement(config, \"VRRPNewMaster\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(VRRPNewMaster, \"originator-switch-info\")\n        switchVcsId = ET.SubElement(originator_switch_info, \"switchVcsId\")\n        switchVcsId.text = kwargs.pop('switchVcsId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget Current VRRP Entry from Originator Switch Info Element.", "response": "def VRRPNewMaster_originator_switch_info_switchIpV4Address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        VRRPNewMaster = ET.SubElement(config, \"VRRPNewMaster\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(VRRPNewMaster, \"originator-switch-info\")\n        switchIpV4Address = ET.SubElement(originator_switch_info, \"switchIpV4Address\")\n        switchIpV4Address.text = kwargs.pop('switchIpV4Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef VRRPNewMaster_originator_switch_info_switchIpV6Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        VRRPNewMaster = ET.SubElement(config, \"VRRPNewMaster\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(VRRPNewMaster, \"originator-switch-info\")\n        switchIpV6Address = ET.SubElement(originator_switch_info, \"switchIpV6Address\")\n        switchIpV6Address.text = kwargs.pop('switchIpV6Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Current Originator Switch Info"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef VRRPNewMaster_NewMasterIpAddress(self, **kwargs):\n        config = ET.Element(\"config\")\n        VRRPNewMaster = ET.SubElement(config, \"VRRPNewMaster\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        NewMasterIpAddress = ET.SubElement(VRRPNewMaster, \"NewMasterIpAddress\")\n        NewMasterIpAddress.text = kwargs.pop('NewMasterIpAddress')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set New Master Ip Address in the VRRP New Master Element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef VRRPNewMaster_VRRPSessionId(self, **kwargs):\n        config = ET.Element(\"config\")\n        VRRPNewMaster = ET.SubElement(config, \"VRRPNewMaster\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        VRRPSessionId = ET.SubElement(VRRPNewMaster, \"VRRPSessionId\")\n        VRRPSessionId.text = kwargs.pop('VRRPSessionId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VRRP New Master Session ID"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef RIBVRFRouteLimitExceeded_originator_switch_info_switchIdentifier(self, **kwargs):\n        config = ET.Element(\"config\")\n        RIBVRFRouteLimitExceeded = ET.SubElement(config, \"RIBVRFRouteLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBVRFRouteLimitExceeded, \"originator-switch-info\")\n        switchIdentifier = ET.SubElement(originator_switch_info, \"switchIdentifier\")\n        switchIdentifier.text = kwargs.pop('switchIdentifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get RIBVRF Route Limit Exceeded Originator Switch Information"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets RIBVRF Route Limit Exceeded Originator Switch Information.", "response": "def RIBVRFRouteLimitExceeded_originator_switch_info_switchVcsId(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        RIBVRFRouteLimitExceeded = ET.SubElement(config, \"RIBVRFRouteLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBVRFRouteLimitExceeded, \"originator-switch-info\")\n        switchVcsId = ET.SubElement(originator_switch_info, \"switchVcsId\")\n        switchVcsId.text = kwargs.pop('switchVcsId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef RIBVRFRouteLimitExceeded_originator_switch_info_switchIpV4Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        RIBVRFRouteLimitExceeded = ET.SubElement(config, \"RIBVRFRouteLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBVRFRouteLimitExceeded, \"originator-switch-info\")\n        switchIpV4Address = ET.SubElement(originator_switch_info, \"switchIpV4Address\")\n        switchIpV4Address.text = kwargs.pop('switchIpV4Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set switchIpV4Address of a new originator switch"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets switchIpV6Address of the originator switch", "response": "def RIBVRFRouteLimitExceeded_originator_switch_info_switchIpV6Address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        RIBVRFRouteLimitExceeded = ET.SubElement(config, \"RIBVRFRouteLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(RIBVRFRouteLimitExceeded, \"originator-switch-info\")\n        switchIpV6Address = ET.SubElement(originator_switch_info, \"switchIpV6Address\")\n        switchIpV6Address.text = kwargs.pop('switchIpV6Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets RIBVRF Route Limit Exceeded for a resource", "response": "def RIBVRFRouteLimitExceeded_RIBVRFRouteLimit(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        RIBVRFRouteLimitExceeded = ET.SubElement(config, \"RIBVRFRouteLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        RIBVRFRouteLimit = ET.SubElement(RIBVRFRouteLimitExceeded, \"RIBVRFRouteLimit\")\n        RIBVRFRouteLimit.text = kwargs.pop('RIBVRFRouteLimit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets ARP Limit Exceeded Originator Switch Information", "response": "def ARPLimitExceeded_originator_switch_info_switchIdentifier(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ARPLimitExceeded = ET.SubElement(config, \"ARPLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(ARPLimitExceeded, \"originator-switch-info\")\n        switchIdentifier = ET.SubElement(originator_switch_info, \"switchIdentifier\")\n        switchIdentifier.text = kwargs.pop('switchIdentifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets config of ARP Limit Exceeded Originator Switch Information.", "response": "def ARPLimitExceeded_originator_switch_info_switchVcsId(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ARPLimitExceeded = ET.SubElement(config, \"ARPLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(ARPLimitExceeded, \"originator-switch-info\")\n        switchVcsId = ET.SubElement(originator_switch_info, \"switchVcsId\")\n        switchVcsId.text = kwargs.pop('switchVcsId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ARPLimitExceeded_originator_switch_info_switchIpV4Address(self, **kwargs):\n        config = ET.Element(\"config\")\n        ARPLimitExceeded = ET.SubElement(config, \"ARPLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(ARPLimitExceeded, \"originator-switch-info\")\n        switchIpV4Address = ET.SubElement(originator_switch_info, \"switchIpV4Address\")\n        switchIpV4Address.text = kwargs.pop('switchIpV4Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the ARP Limit Exceeded Originator Switch Info switchIpV4Address."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the configuration of the ARP Limit Exceeded Originator Switch Info.", "response": "def ARPLimitExceeded_originator_switch_info_switchIpV6Address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ARPLimitExceeded = ET.SubElement(config, \"ARPLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(ARPLimitExceeded, \"originator-switch-info\")\n        switchIpV6Address = ET.SubElement(originator_switch_info, \"switchIpV6Address\")\n        switchIpV6Address.text = kwargs.pop('switchIpV6Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget NDLimitExceeded originator switch identifier.", "response": "def NDLimitExceeded_originator_switch_info_switchIdentifier(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        NDLimitExceeded = ET.SubElement(config, \"NDLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(NDLimitExceeded, \"originator-switch-info\")\n        switchIdentifier = ET.SubElement(originator_switch_info, \"switchIdentifier\")\n        switchIdentifier.text = kwargs.pop('switchIdentifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets ND Limit Exceeded Originator Switch Information", "response": "def NDLimitExceeded_originator_switch_info_switchVcsId(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        NDLimitExceeded = ET.SubElement(config, \"NDLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(NDLimitExceeded, \"originator-switch-info\")\n        switchVcsId = ET.SubElement(originator_switch_info, \"switchVcsId\")\n        switchVcsId.text = kwargs.pop('switchVcsId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets ND Limit Exceeded Originator Switch Info switchIpV4Address.", "response": "def NDLimitExceeded_originator_switch_info_switchIpV4Address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        NDLimitExceeded = ET.SubElement(config, \"NDLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(NDLimitExceeded, \"originator-switch-info\")\n        switchIpV4Address = ET.SubElement(originator_switch_info, \"switchIpV4Address\")\n        switchIpV4Address.text = kwargs.pop('switchIpV4Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget ND Limit Exceeded Originator Switch Info switchIpV6Address.", "response": "def NDLimitExceeded_originator_switch_info_switchIpV6Address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        NDLimitExceeded = ET.SubElement(config, \"NDLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        originator_switch_info = ET.SubElement(NDLimitExceeded, \"originator-switch-info\")\n        switchIpV6Address = ET.SubElement(originator_switch_info, \"switchIpV6Address\")\n        switchIpV6Address.text = kwargs.pop('switchIpV6Address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef NDLimitExceeded_NDLimit(self, **kwargs):\n        config = ET.Element(\"config\")\n        NDLimitExceeded = ET.SubElement(config, \"NDLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        NDLimit = ET.SubElement(NDLimitExceeded, \"NDLimit\")\n        NDLimit.text = kwargs.pop('NDLimit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        ND Limit Exceeded"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing 2D coordinates of the piece.", "response": "def compute_coordinates(self):\n        \"\"\" Compute 2D coordinates of the piece. \"\"\"\n        self._x, self._y = self.board.index_to_coordinates(self.index)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef horizontals(self):\n        horizontal_shifts = set(izip_longest(map(\n            lambda i: i - self.x, range(self.board.length)), [], fillvalue=0))\n        horizontal_shifts.discard((0, 0))\n        return horizontal_shifts", "response": "Returns a list of relative movements up to the board s bound."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef verticals(self):\n        vertical_shifts = set(izip_longest([], map(\n            lambda i: i - self.y, range(self.board.height)), fillvalue=0))\n        vertical_shifts.discard((0, 0))\n        return vertical_shifts", "response": "Returns a list of relative movements up to the board s bound."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef diagonals(self):\n        left_top_shifts = map(lambda i: (-(i + 1), -(i + 1)), range(min(\n            self.left_distance, self.top_distance)))\n        left_bottom_shifts = map(lambda i: (-(i + 1), +(i + 1)), range(min(\n            self.left_distance, self.bottom_distance)))\n        right_top_shifts = map(lambda i: (+(i + 1), -(i + 1)), range(min(\n            self.right_distance, self.top_distance)))\n        right_bottom_shifts = map(lambda i: (+(i + 1), +(i + 1)), range(min(\n            self.right_distance, self.bottom_distance)))\n        return set(chain(\n            left_top_shifts, left_bottom_shifts,\n            right_top_shifts, right_bottom_shifts))", "response": "Returns a list of relative movements up to the board s bound."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the cached territory occupied by the piece.", "response": "def territory(self):\n        \"\"\" Return the cached territory occupied by the piece. \"\"\"\n        cache_key = (\n            self.board.length, self.board.height, self.uid, self.index)\n        if cache_key not in self.territory_cache:\n            vector = self.compute_territory()\n            self.territory_cache[cache_key] = vector\n        else:\n            vector = self.territory_cache[cache_key]\n        return vector"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compute_territory(self):\n        # Initialize the square occupancy vector of the board.\n        vector = self.board.new_vector()\n\n        # Mark current position as reachable.\n        vector[self.index] = True\n\n        # List all places reacheable by the piece from its current position.\n        for x_shift, y_shift in self.movements:\n            # Mark side positions as reachable if in the limit of the board.\n            try:\n                reachable_index = self.board.coordinates_to_index(\n                    self.x, self.y, x_shift, y_shift)\n            except ForbiddenCoordinates:\n                continue\n            vector[reachable_index] = True\n\n        return vector", "response": "Compute territory reachable by the piece from its current position."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_netconf_client_capabilities_input_session_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_netconf_client_capabilities = ET.Element(\"get_netconf_client_capabilities\")\n        config = get_netconf_client_capabilities\n        input = ET.SubElement(get_netconf_client_capabilities, \"input\")\n        session_id = ET.SubElement(input, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf Client Capabilities input session_id."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_netconf_client_capabilities_output_session_session_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_netconf_client_capabilities = ET.Element(\"get_netconf_client_capabilities\")\n        config = get_netconf_client_capabilities\n        output = ET.SubElement(get_netconf_client_capabilities, \"output\")\n        session = ET.SubElement(output, \"session\")\n        session_id = ET.SubElement(session, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf Client Capabilities output session id"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_netconf_client_capabilities_output_session_user_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_netconf_client_capabilities = ET.Element(\"get_netconf_client_capabilities\")\n        config = get_netconf_client_capabilities\n        output = ET.SubElement(get_netconf_client_capabilities, \"output\")\n        session = ET.SubElement(output, \"session\")\n        user_name = ET.SubElement(session, \"user-name\")\n        user_name.text = kwargs.pop('user_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf Client Capabilities output session user_name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets Netconf Client Capabilities output session vendor", "response": "def get_netconf_client_capabilities_output_session_vendor(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_netconf_client_capabilities = ET.Element(\"get_netconf_client_capabilities\")\n        config = get_netconf_client_capabilities\n        output = ET.SubElement(get_netconf_client_capabilities, \"output\")\n        session = ET.SubElement(output, \"session\")\n        vendor = ET.SubElement(session, \"vendor\")\n        vendor.text = kwargs.pop('vendor')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_netconf_client_capabilities_output_session_product(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_netconf_client_capabilities = ET.Element(\"get_netconf_client_capabilities\")\n        config = get_netconf_client_capabilities\n        output = ET.SubElement(get_netconf_client_capabilities, \"output\")\n        session = ET.SubElement(output, \"session\")\n        product = ET.SubElement(session, \"product\")\n        product.text = kwargs.pop('product')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf Client Capabilities output session product"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget Netconf Client Capabilities output session version.", "response": "def get_netconf_client_capabilities_output_session_version(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_netconf_client_capabilities = ET.Element(\"get_netconf_client_capabilities\")\n        config = get_netconf_client_capabilities\n        output = ET.SubElement(get_netconf_client_capabilities, \"output\")\n        session = ET.SubElement(output, \"session\")\n        version = ET.SubElement(session, \"version\")\n        version.text = kwargs.pop('version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_netconf_client_capabilities_output_session_identity(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_netconf_client_capabilities = ET.Element(\"get_netconf_client_capabilities\")\n        config = get_netconf_client_capabilities\n        output = ET.SubElement(get_netconf_client_capabilities, \"output\")\n        session = ET.SubElement(output, \"session\")\n        identity = ET.SubElement(session, \"identity\")\n        identity.text = kwargs.pop('identity')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf Client Capabilities output session identity"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_netconf_client_capabilities_output_session_af_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_netconf_client_capabilities = ET.Element(\"get_netconf_client_capabilities\")\n        config = get_netconf_client_capabilities\n        output = ET.SubElement(get_netconf_client_capabilities, \"output\")\n        session = ET.SubElement(output, \"session\")\n        af_type = ET.SubElement(session, \"af-type\")\n        af_type.text = kwargs.pop('af_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf Client Capabilities output session AF Type."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_netconf_client_capabilities_output_session_host_ip_v6(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_netconf_client_capabilities = ET.Element(\"get_netconf_client_capabilities\")\n        config = get_netconf_client_capabilities\n        output = ET.SubElement(get_netconf_client_capabilities, \"output\")\n        session = ET.SubElement(output, \"session\")\n        host_ip_v6 = ET.SubElement(session, \"host-ip-v6\")\n        host_ip_v6.text = kwargs.pop('host_ip_v6')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf Client Capabilities output session host - ip - v6"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_netconf_client_capabilities_output_session_host_ip(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_netconf_client_capabilities = ET.Element(\"get_netconf_client_capabilities\")\n        config = get_netconf_client_capabilities\n        output = ET.SubElement(get_netconf_client_capabilities, \"output\")\n        session = ET.SubElement(output, \"session\")\n        host_ip = ET.SubElement(session, \"host-ip\")\n        host_ip.text = kwargs.pop('host_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf Client Capabilities output session host - ip"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget Netconf Client Capabilities output session time.", "response": "def get_netconf_client_capabilities_output_session_time(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_netconf_client_capabilities = ET.Element(\"get_netconf_client_capabilities\")\n        config = get_netconf_client_capabilities\n        output = ET.SubElement(get_netconf_client_capabilities, \"output\")\n        session = ET.SubElement(output, \"session\")\n        time = ET.SubElement(session, \"time\")\n        time.text = kwargs.pop('time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rmon_event_entry_event_index(self, **kwargs):\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        event_entry = ET.SubElement(rmon, \"event-entry\")\n        event_index = ET.SubElement(event_entry, \"event-index\")\n        event_index.text = kwargs.pop('event_index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the index of the event entry in the rmon event table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rmon_event_entry_event_description(self, **kwargs):\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        event_entry = ET.SubElement(rmon, \"event-entry\")\n        event_index_key = ET.SubElement(event_entry, \"event-index\")\n        event_index_key.text = kwargs.pop('event_index')\n        event_description = ET.SubElement(event_entry, \"event-description\")\n        event_description.text = kwargs.pop('event_description')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of the rmon event entry event description"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the log of the last event entry in the rmon event log", "response": "def rmon_event_entry_log(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        event_entry = ET.SubElement(rmon, \"event-entry\")\n        event_index_key = ET.SubElement(event_entry, \"event-index\")\n        event_index_key.text = kwargs.pop('event_index')\n        log = ET.SubElement(event_entry, \"log\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rmon_event_entry_event_community(self, **kwargs):\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        event_entry = ET.SubElement(rmon, \"event-entry\")\n        event_index_key = ET.SubElement(event_entry, \"event-index\")\n        event_index_key.text = kwargs.pop('event_index')\n        event_community = ET.SubElement(event_entry, \"event-community\")\n        event_community.text = kwargs.pop('event_community')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of the rmon event entry event community"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the config of the rmon event entry event owner", "response": "def rmon_event_entry_event_owner(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        event_entry = ET.SubElement(rmon, \"event-entry\")\n        event_index_key = ET.SubElement(event_entry, \"event-index\")\n        event_index_key.text = kwargs.pop('event_index')\n        event_owner = ET.SubElement(event_entry, \"event-owner\")\n        event_owner.text = kwargs.pop('event_owner')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rmon_alarm_entry_alarm_index(self, **kwargs):\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        alarm_entry = ET.SubElement(rmon, \"alarm-entry\")\n        alarm_index = ET.SubElement(alarm_entry, \"alarm-index\")\n        alarm_index.text = kwargs.pop('alarm_index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the index of the alarm entry in the rmon"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the OID of the CMU alarm entry.", "response": "def rmon_alarm_entry_snmp_oid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        alarm_entry = ET.SubElement(rmon, \"alarm-entry\")\n        alarm_index_key = ET.SubElement(alarm_entry, \"alarm-index\")\n        alarm_index_key.text = kwargs.pop('alarm_index')\n        snmp_oid = ET.SubElement(alarm_entry, \"snmp-oid\")\n        snmp_oid.text = kwargs.pop('snmp_oid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rmon_alarm_entry_alarm_interval(self, **kwargs):\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        alarm_entry = ET.SubElement(rmon, \"alarm-entry\")\n        alarm_index_key = ET.SubElement(alarm_entry, \"alarm-index\")\n        alarm_index_key.text = kwargs.pop('alarm_index')\n        alarm_interval = ET.SubElement(alarm_entry, \"alarm-interval\")\n        alarm_interval.text = kwargs.pop('alarm_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get alarm interval for the current resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget alarm sample from rmon alarm entry", "response": "def rmon_alarm_entry_alarm_sample(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        alarm_entry = ET.SubElement(rmon, \"alarm-entry\")\n        alarm_index_key = ET.SubElement(alarm_entry, \"alarm-index\")\n        alarm_index_key.text = kwargs.pop('alarm_index')\n        alarm_sample = ET.SubElement(alarm_entry, \"alarm-sample\")\n        alarm_sample.text = kwargs.pop('alarm_sample')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the alarm rising threshold for the current resource.", "response": "def rmon_alarm_entry_alarm_rising_threshold(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        alarm_entry = ET.SubElement(rmon, \"alarm-entry\")\n        alarm_index_key = ET.SubElement(alarm_entry, \"alarm-index\")\n        alarm_index_key.text = kwargs.pop('alarm_index')\n        alarm_rising_threshold = ET.SubElement(alarm_entry, \"alarm-rising-threshold\")\n        alarm_rising_threshold.text = kwargs.pop('alarm_rising_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the alarm entry for the rmon entry and update the alarm rising event index", "response": "def rmon_alarm_entry_alarm_rising_event_index(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        alarm_entry = ET.SubElement(rmon, \"alarm-entry\")\n        alarm_index_key = ET.SubElement(alarm_entry, \"alarm-index\")\n        alarm_index_key.text = kwargs.pop('alarm_index')\n        alarm_rising_event_index = ET.SubElement(alarm_entry, \"alarm-rising-event-index\")\n        alarm_rising_event_index.text = kwargs.pop('alarm_rising_event_index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the alarm falling threshold for the current resource.", "response": "def rmon_alarm_entry_alarm_falling_threshold(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        alarm_entry = ET.SubElement(rmon, \"alarm-entry\")\n        alarm_index_key = ET.SubElement(alarm_entry, \"alarm-index\")\n        alarm_index_key.text = kwargs.pop('alarm_index')\n        alarm_falling_threshold = ET.SubElement(alarm_entry, \"alarm-falling-threshold\")\n        alarm_falling_threshold.text = kwargs.pop('alarm_falling_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the alarm entry for the current resource.", "response": "def rmon_alarm_entry_alarm_falling_event_index(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        alarm_entry = ET.SubElement(rmon, \"alarm-entry\")\n        alarm_index_key = ET.SubElement(alarm_entry, \"alarm-index\")\n        alarm_index_key.text = kwargs.pop('alarm_index')\n        alarm_falling_event_index = ET.SubElement(alarm_entry, \"alarm-falling-event-index\")\n        alarm_falling_event_index.text = kwargs.pop('alarm_falling_event_index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of the rmon alarm entry and alarm owner", "response": "def rmon_alarm_entry_alarm_owner(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rmon = ET.SubElement(config, \"rmon\", xmlns=\"urn:brocade.com:mgmt:brocade-rmon\")\n        alarm_entry = ET.SubElement(rmon, \"alarm-entry\")\n        alarm_index_key = ET.SubElement(alarm_entry, \"alarm-index\")\n        alarm_index_key.text = kwargs.pop('alarm_index')\n        alarm_owner = ET.SubElement(alarm_entry, \"alarm-owner\")\n        alarm_owner.text = kwargs.pop('alarm_owner')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconnect a signal to a receiver function", "response": "def connect(self, receiver, sender):\n        '''\n        Connects a signal to a receiver function\n\n        :param receiver:\n            The callback function which will be connected to this signal\n\n        :param sender:\n            Specifies a particular sender to receive signals from.\n            Used to limit the receiver function to signal from particular sender types\n        '''\n        logger.info('Signal connected: {}'.format(receiver))\n        ''' connect a receiver to a sender for signaling '''\n        assert callable(receiver)\n        receiver_id = _make_id(receiver)\n        sender_id = _make_id(sender)\n        r = ref\n        if hasattr(receiver, '__self__') and hasattr(receiver, '__func__'):\n            r = WeakMethod\n\n        receiver = r(receiver)\n\n        self.receivers.setdefault((receiver_id, sender_id), receiver)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a signal from the sender to all connected receivers", "response": "async def send(self, sender, **kwargs):\n        ''' send a signal from the sender to all connected receivers '''\n        if not self.receivers:\n            return []\n        responses = []\n        futures = []\n        for receiver in self._get_receivers(sender):\n            method = receiver()\n            if callable(method):\n                futures.append(method(sender=sender, **kwargs))\n        if len(futures) > 0:\n            responses = await asyncio.gather(*futures)\n        return responses"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters only receiver functions which correspond to the provided sender", "response": "def _get_receivers(self, sender):\n        ''' filter only receiver functions which correspond to the provided sender '''\n        key = _make_id(sender)\n        receivers = []\n        for (receiver_key, sender_key), receiver in self.receivers.items():\n            if sender_key == key:\n                receivers.append(receiver)\n        return receivers"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresets internal state of the current object.", "response": "def reset(self):\n        \"\"\" Empty board, remove all pieces and reset internal states. \"\"\"\n        # Store positionned pieces on the board.\n        self.pieces = set()\n\n        # Squares on the board already occupied by a piece.\n        self.occupancy = self.new_vector()\n\n        # Territory susceptible to attacke, i.e. squares reachable by at least\n        # a piece.\n        self.exposed_territory = self.new_vector()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef positions(self):\n        for y in range(self.height):\n            for x in range(self.length):\n                yield x, y", "response": "Generator producing all 2D positions of all squares."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck that a linear index is within board s bounds.", "response": "def validate_index(self, index):\n        \"\"\" Check that a linear index of a square is within board's bounds. \"\"\"\n        if index < 0 or index >= self.size:\n            raise ForbiddenIndex(\"Linear index {} not in {}x{} board.\".format(\n                index, self.length, self.height))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the piece lie within the board.", "response": "def validate_coordinates(self, x, y):\n        \"\"\" Check if the piece lie within the board. \"\"\"\n        if not(0 <= x < self.length and 0 <= y < self.height):\n            raise ForbiddenCoordinates(\n                \"x={}, y={} outside of {}x{} board.\".format(\n                    x, y, self.length, self.height))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef index_to_coordinates(self, index):\n        self.validate_index(index)\n        x = int(index % self.length)\n        y = int((index - x) / self.length)\n        return x, y", "response": "Return a set of 2D coordinates from a linear index."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a linear index from a set of 2D coordinates.", "response": "def coordinates_to_index(self, x, y, x_shift=0, y_shift=0):\n        \"\"\" Return a linear index from a set of 2D coordinates.\n\n        Optionnal vertical and horizontal shifts might be applied.\n        \"\"\"\n        target_x = x + x_shift\n        target_y = y + y_shift\n        self.validate_coordinates(target_x, target_y)\n        index = (target_y * self.length) + target_x\n        return index"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a piece to the board at the provided linear position.", "response": "def add(self, piece_uid, index):\n        \"\"\" Add a piece to the board at the provided linear position. \"\"\"\n        # Square already occupied by another piece.\n        if self.occupancy[index]:\n            raise OccupiedPosition\n\n        # Square reachable by another piece.\n        if self.exposed_territory[index]:\n            raise VulnerablePosition\n\n        # Create a new instance of the piece.\n        klass = PIECE_CLASSES[piece_uid]\n        piece = klass(self, index)\n\n        # Check if a piece can attack another one from its position.\n        territory = piece.territory\n        for i in self.indexes:\n            if self.occupancy[i] and territory[i]:\n                raise AttackablePiece\n\n        # Mark the territory covered by the piece as exposed and secure its\n        # position on the board.\n        self.pieces.add(piece)\n        self.occupancy[index] = True\n        self.exposed_territory = list(\n            map(or_, self.exposed_territory, territory))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, x, y):\n        for piece in self.pieces:\n            if (piece.x, piece.y) == (x, y):\n                return piece", "response": "Return the piece placed at the provided coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the name of the Nexx Controller", "response": "def nsx_controller_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nsx_controller = ET.SubElement(config, \"nsx-controller\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name = ET.SubElement(nsx_controller, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nsx_controller_connection_addr_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        nsx_controller = ET.SubElement(config, \"nsx-controller\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(nsx_controller, \"name\")\n        name_key.text = kwargs.pop('name')\n        connection_addr = ET.SubElement(nsx_controller, \"connection-addr\")\n        address = ET.SubElement(connection_addr, \"address\")\n        address.text = kwargs.pop('address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the nsx - controller connection - addr address."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the configuration of the nsx - controller connection - addr - port", "response": "def nsx_controller_connection_addr_port(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nsx_controller = ET.SubElement(config, \"nsx-controller\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(nsx_controller, \"name\")\n        name_key.text = kwargs.pop('name')\n        connection_addr = ET.SubElement(nsx_controller, \"connection-addr\")\n        port = ET.SubElement(connection_addr, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the configuration of the nsx controller connection - addr method.", "response": "def nsx_controller_connection_addr_method(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nsx_controller = ET.SubElement(config, \"nsx-controller\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(nsx_controller, \"name\")\n        name_key.text = kwargs.pop('name')\n        connection_addr = ET.SubElement(nsx_controller, \"connection-addr\")\n        method = ET.SubElement(connection_addr, \"method\")\n        method.text = kwargs.pop('method')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nsx_controller_reconnect_interval(self, **kwargs):\n        config = ET.Element(\"config\")\n        nsx_controller = ET.SubElement(config, \"nsx-controller\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(nsx_controller, \"name\")\n        name_key.text = kwargs.pop('name')\n        reconnect_interval = ET.SubElement(nsx_controller, \"reconnect-interval\")\n        reconnect_interval.text = kwargs.pop('reconnect_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NSX Controller Reconnect Interval"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nsx_controller_activate(self, **kwargs):\n        config = ET.Element(\"config\")\n        nsx_controller = ET.SubElement(config, \"nsx-controller\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(nsx_controller, \"name\")\n        name_key.text = kwargs.pop('name')\n        activate = ET.SubElement(nsx_controller, \"activate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Activate a new resource in the NSMX Controller"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef overlay_gateway_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name = ET.SubElement(overlay_gateway, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set name of the overlay gateway"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef overlay_gateway_gw_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        gw_type = ET.SubElement(overlay_gateway, \"gw-type\")\n        gw_type.text = kwargs.pop('gw_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Overlay Gateway gateway type"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the configuration of a new legacy legacy", "response": "def overlay_gateway_ip_interface_ve_ve_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        ip = ET.SubElement(overlay_gateway, \"ip\")\n        interface = ET.SubElement(ip, \"interface\")\n        ve = ET.SubElement(interface, \"ve\")\n        ve_id = ET.SubElement(ve, \"ve-id\")\n        ve_id.text = kwargs.pop('ve_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget Overlay Gateway IP Interface Loopback ID", "response": "def overlay_gateway_ip_interface_loopback_loopback_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        ip = ET.SubElement(overlay_gateway, \"ip\")\n        interface = ET.SubElement(ip, \"interface\")\n        loopback = ET.SubElement(interface, \"loopback\")\n        loopback_id = ET.SubElement(loopback, \"loopback-id\")\n        loopback_id.text = kwargs.pop('loopback_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef overlay_gateway_attach_rbridge_id_rb_add(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        attach = ET.SubElement(overlay_gateway, \"attach\")\n        rbridge_id = ET.SubElement(attach, \"rbridge-id\")\n        rb_add = ET.SubElement(rbridge_id, \"rb-add\")\n        rb_add.text = kwargs.pop('rb_add')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Add new entry to the overlay gateway attach rbridge - id rb - add."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef overlay_gateway_attach_rbridge_id_rb_remove(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        attach = ET.SubElement(overlay_gateway, \"attach\")\n        rbridge_id = ET.SubElement(attach, \"rbridge-id\")\n        rb_remove = ET.SubElement(rbridge_id, \"rb-remove\")\n        rb_remove.text = kwargs.pop('rb_remove')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get datapath entry from overlay gateway attach rbridge - id rb - remove"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef overlay_gateway_attach_vlan_vid(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        attach = ET.SubElement(overlay_gateway, \"attach\")\n        vlan = ET.SubElement(attach, \"vlan\")\n        mac_key = ET.SubElement(vlan, \"mac\")\n        mac_key.text = kwargs.pop('mac')\n        vid = ET.SubElement(vlan, \"vid\")\n        vid.text = kwargs.pop('vid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the datapath entry in the Overlay Gateway attach vlan and vid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the datapath entry in the Overlay Gateway attach VLAN MAC and return the config.", "response": "def overlay_gateway_attach_vlan_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        attach = ET.SubElement(overlay_gateway, \"attach\")\n        vlan = ET.SubElement(attach, \"vlan\")\n        vid_key = ET.SubElement(vlan, \"vid\")\n        vid_key.text = kwargs.pop('vid')\n        mac = ET.SubElement(vlan, \"mac\")\n        mac.text = kwargs.pop('mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef overlay_gateway_map_vlan_vni_mapping_vid(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        map = ET.SubElement(overlay_gateway, \"map\")\n        vlan_vni_mapping = ET.SubElement(map, \"vlan-vni-mapping\")\n        vid = ET.SubElement(vlan_vni_mapping, \"vid\")\n        vid.text = kwargs.pop('vid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a new cluster entry in the overlay gateway."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset Overlay Gateway map vlan - vni - mapping vni to new ones", "response": "def overlay_gateway_map_vlan_vni_mapping_vni(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        map = ET.SubElement(overlay_gateway, \"map\")\n        vlan_vni_mapping = ET.SubElement(map, \"vlan-vni-mapping\")\n        vid_key = ET.SubElement(vlan_vni_mapping, \"vid\")\n        vid_key.text = kwargs.pop('vid')\n        vni = ET.SubElement(vlan_vni_mapping, \"vni\")\n        vni.text = kwargs.pop('vni')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting site name in Overlay Gateway", "response": "def overlay_gateway_site_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        site = ET.SubElement(overlay_gateway, \"site\")\n        name = ET.SubElement(site, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef overlay_gateway_site_tunnel_dst_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        site = ET.SubElement(overlay_gateway, \"site\")\n        name_key = ET.SubElement(site, \"name\")\n        name_key.text = kwargs.pop('name')\n        tunnel_dst = ET.SubElement(site, \"tunnel-dst\")\n        address = ET.SubElement(tunnel_dst, \"address\")\n        address.text = kwargs.pop('address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set tunnel destination address for the site in the overlay gateway."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef overlay_gateway_site_extend_vlan_add(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        site = ET.SubElement(overlay_gateway, \"site\")\n        name_key = ET.SubElement(site, \"name\")\n        name_key.text = kwargs.pop('name')\n        extend = ET.SubElement(site, \"extend\")\n        vlan = ET.SubElement(extend, \"vlan\")\n        add = ET.SubElement(vlan, \"add\")\n        add.text = kwargs.pop('add')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Add new entry to the overlay gateway site extend vlan add"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef overlay_gateway_site_mac_learning_protocol(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        site = ET.SubElement(overlay_gateway, \"site\")\n        name_key = ET.SubElement(site, \"name\")\n        name_key.text = kwargs.pop('name')\n        mac_learning = ET.SubElement(site, \"mac-learning\")\n        protocol = ET.SubElement(mac_learning, \"protocol\")\n        protocol.text = kwargs.pop('protocol')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the MAC Learning Protocol for the specified site in the Overlay Gateway."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef overlay_gateway_site_bfd_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        site = ET.SubElement(overlay_gateway, \"site\")\n        name_key = ET.SubElement(site, \"name\")\n        name_key.text = kwargs.pop('name')\n        bfd_enable = ET.SubElement(site, \"bfd-enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable BFD on the site of the overlay gateway."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the datapath entry in the Overlay Gateway site BFD and params interval and minimum tx.", "response": "def overlay_gateway_site_bfd_params_interval_min_tx(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        site = ET.SubElement(overlay_gateway, \"site\")\n        name_key = ET.SubElement(site, \"name\")\n        name_key.text = kwargs.pop('name')\n        bfd = ET.SubElement(site, \"bfd\")\n        params = ET.SubElement(bfd, \"params\")\n        interval = ET.SubElement(params, \"interval\")\n        min_tx = ET.SubElement(interval, \"min-tx\")\n        min_tx.text = kwargs.pop('min_tx')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the overlay gateway site bfd - params bfd - shutdown", "response": "def overlay_gateway_site_bfd_params_bfd_shutdown(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        site = ET.SubElement(overlay_gateway, \"site\")\n        name_key = ET.SubElement(site, \"name\")\n        name_key.text = kwargs.pop('name')\n        bfd = ET.SubElement(site, \"bfd\")\n        params = ET.SubElement(bfd, \"params\")\n        bfd_shutdown = ET.SubElement(params, \"bfd-shutdown\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the site shutdown element for the overlay gateway", "response": "def overlay_gateway_site_shutdown(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        site = ET.SubElement(overlay_gateway, \"site\")\n        name_key = ET.SubElement(site, \"name\")\n        name_key.text = kwargs.pop('name')\n        shutdown = ET.SubElement(site, \"shutdown\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef overlay_gateway_enable_statistics_stats_direction(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        enable = ET.SubElement(overlay_gateway, \"enable\")\n        statistics = ET.SubElement(enable, \"statistics\")\n        stats_direction = ET.SubElement(statistics, \"stats-direction\")\n        stats_direction.text = kwargs.pop('stats_direction')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable the statistics of the current resource in the overlay gateway"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nenables the statistics vlan action for the current legacy cluster.", "response": "def overlay_gateway_enable_statistics_vlan_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        enable = ET.SubElement(overlay_gateway, \"enable\")\n        statistics = ET.SubElement(enable, \"statistics\")\n        vlan_action = ET.SubElement(statistics, \"vlan-action\")\n        vlan_action.text = kwargs.pop('vlan_action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nenable the statistics vlan list for the current overlay gateway", "response": "def overlay_gateway_enable_statistics_vlan_list(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        enable = ET.SubElement(overlay_gateway, \"enable\")\n        statistics = ET.SubElement(enable, \"statistics\")\n        vlan_list = ET.SubElement(statistics, \"vlan-list\")\n        vlan_list.text = kwargs.pop('vlan_list')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmonitors the session of the named cluster", "response": "def overlay_gateway_monitor_session(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        monitor = ET.SubElement(overlay_gateway, \"monitor\")\n        session = ET.SubElement(monitor, \"session\")\n        session.text = kwargs.pop('session')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the overlay gateway monitor direction", "response": "def overlay_gateway_monitor_direction(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        monitor = ET.SubElement(overlay_gateway, \"monitor\")\n        session_key = ET.SubElement(monitor, \"session\")\n        session_key.text = kwargs.pop('session')\n        direction = ET.SubElement(monitor, \"direction\")\n        direction.text = kwargs.pop('direction')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef overlay_gateway_monitor_remote_endpoint(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        monitor = ET.SubElement(overlay_gateway, \"monitor\")\n        session_key = ET.SubElement(monitor, \"session\")\n        session_key.text = kwargs.pop('session')\n        remote_endpoint = ET.SubElement(monitor, \"remote-endpoint\")\n        remote_endpoint.text = kwargs.pop('remote_endpoint')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Monitor the remote endpoint of the named overlay gateway"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmonitors VLAN Leaf of Overlay Gateway", "response": "def overlay_gateway_monitor_vlan_leaf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        monitor = ET.SubElement(overlay_gateway, \"monitor\")\n        session_key = ET.SubElement(monitor, \"session\")\n        session_key.text = kwargs.pop('session')\n        vlan_leaf = ET.SubElement(monitor, \"vlan-leaf\")\n        vlan_leaf.text = kwargs.pop('vlan_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes the overlay gateway monitor vlan add remove", "response": "def overlay_gateway_monitor_vlan_add_remove(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        monitor = ET.SubElement(overlay_gateway, \"monitor\")\n        session_key = ET.SubElement(monitor, \"session\")\n        session_key.text = kwargs.pop('session')\n        vlan_add_remove = ET.SubElement(monitor, \"vlan-add-remove\")\n        vlan_add_remove.text = kwargs.pop('vlan_add_remove')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef overlay_gateway_monitor_vlan_range(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        monitor = ET.SubElement(overlay_gateway, \"monitor\")\n        session_key = ET.SubElement(monitor, \"session\")\n        session_key.text = kwargs.pop('session')\n        vlan_range = ET.SubElement(monitor, \"vlan-range\")\n        vlan_range.text = kwargs.pop('vlan_range')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the datapath entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the name of the sflow profile for the current resource.", "response": "def overlay_gateway_sflow_sflow_profile_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        sflow = ET.SubElement(overlay_gateway, \"sflow\")\n        sflow_profile_name = ET.SubElement(sflow, \"sflow-profile-name\")\n        sflow_profile_name.text = kwargs.pop('sflow_profile_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the configuration of a new resource from the overlay gateway sflow remote endpoint", "response": "def overlay_gateway_sflow_sflow_remote_endpoint(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        sflow = ET.SubElement(overlay_gateway, \"sflow\")\n        sflow_profile_name_key = ET.SubElement(sflow, \"sflow-profile-name\")\n        sflow_profile_name_key.text = kwargs.pop('sflow_profile_name')\n        sflow_remote_endpoint = ET.SubElement(sflow, \"sflow-remote-endpoint\")\n        sflow_remote_endpoint.text = kwargs.pop('sflow_remote_endpoint')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef overlay_gateway_sflow_sflow_vlan_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        sflow = ET.SubElement(overlay_gateway, \"sflow\")\n        sflow_profile_name_key = ET.SubElement(sflow, \"sflow-profile-name\")\n        sflow_profile_name_key.text = kwargs.pop('sflow_profile_name')\n        sflow_vlan_action = ET.SubElement(sflow, \"sflow-vlan-action\")\n        sflow_vlan_action.text = kwargs.pop('sflow_vlan_action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a new resource from the overlay gateway sflow vlan action"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the config of the cluster s flow sflow vlan range", "response": "def overlay_gateway_sflow_sflow_vlan_range(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        sflow = ET.SubElement(overlay_gateway, \"sflow\")\n        sflow_profile_name_key = ET.SubElement(sflow, \"sflow-profile-name\")\n        sflow_profile_name_key.text = kwargs.pop('sflow_profile_name')\n        sflow_vlan_range = ET.SubElement(sflow, \"sflow-vlan-range\")\n        sflow_vlan_range.text = kwargs.pop('sflow_vlan_range')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload the config of a resource from the overlay gateway access - lists mac in cg mac acl in name", "response": "def overlay_gateway_access_lists_mac_in_cg_mac_acl_in_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        access_lists = ET.SubElement(overlay_gateway, \"access-lists\")\n        mac = ET.SubElement(access_lists, \"mac\")\n        in_cg = ET.SubElement(mac, \"in\")\n        mac_acl_in_name = ET.SubElement(in_cg, \"mac-acl-in-name\")\n        mac_acl_in_name.text = kwargs.pop('mac_acl_in_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading the config of a resource from the overlay gateway access - lists MAC - Out MAC - ACL - OUT name.", "response": "def overlay_gateway_access_lists_mac_out_mac_acl_out_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        access_lists = ET.SubElement(overlay_gateway, \"access-lists\")\n        mac = ET.SubElement(access_lists, \"mac\")\n        out = ET.SubElement(mac, \"out\")\n        mac_acl_out_name = ET.SubElement(out, \"mac-acl-out-name\")\n        mac_acl_out_name.text = kwargs.pop('mac_acl_out_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the config of an overlay - gateway access - lists ipv4 in - cg ipv4 - acl - in - name", "response": "def overlay_gateway_access_lists_ipv4_in_cg_ipv4_acl_in_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        access_lists = ET.SubElement(overlay_gateway, \"access-lists\")\n        ipv4 = ET.SubElement(access_lists, \"ipv4\")\n        in_cg = ET.SubElement(ipv4, \"in\")\n        ipv4_acl_in_name = ET.SubElement(in_cg, \"ipv4-acl-in-name\")\n        ipv4_acl_in_name.text = kwargs.pop('ipv4_acl_in_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the config of an overlay - gateway access - lists ipv4 out - ipv4 acl - out - name", "response": "def overlay_gateway_access_lists_ipv4_out_ipv4_acl_out_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        access_lists = ET.SubElement(overlay_gateway, \"access-lists\")\n        ipv4 = ET.SubElement(access_lists, \"ipv4\")\n        out = ET.SubElement(ipv4, \"out\")\n        ipv4_acl_out_name = ET.SubElement(out, \"ipv4-acl-out-name\")\n        ipv4_acl_out_name.text = kwargs.pop('ipv4_acl_out_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef overlay_gateway_access_lists_ipv6_in_cg_ipv6_acl_in_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        access_lists = ET.SubElement(overlay_gateway, \"access-lists\")\n        ipv6 = ET.SubElement(access_lists, \"ipv6\")\n        in_cg = ET.SubElement(ipv6, \"in\")\n        ipv6_acl_in_name = ET.SubElement(in_cg, \"ipv6-acl-in-name\")\n        ipv6_acl_in_name.text = kwargs.pop('ipv6_acl_in_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Load the config of an overlay - gateway access - lists ipv6 - in - cg ipv6 - acl - in - name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the config of a new overlay - gateway access - lists ipv6 - out - ipv6 - acl - out - name", "response": "def overlay_gateway_access_lists_ipv6_out_ipv6_acl_out_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        access_lists = ET.SubElement(overlay_gateway, \"access-lists\")\n        ipv6 = ET.SubElement(access_lists, \"ipv6\")\n        out = ET.SubElement(ipv6, \"out\")\n        ipv6_acl_out_name = ET.SubElement(out, \"ipv6-acl-out-name\")\n        ipv6_acl_out_name.text = kwargs.pop('ipv6_acl_out_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef overlay_gateway_activate(self, **kwargs):\n        config = ET.Element(\"config\")\n        overlay_gateway = ET.SubElement(config, \"overlay-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(overlay_gateway, \"name\")\n        name_key.text = kwargs.pop('name')\n        activate = ET.SubElement(overlay_gateway, \"activate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Activate the named resource in the overlay gateway."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ovsdb_server_ip_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        ovsdb_server = ET.SubElement(config, \"ovsdb-server\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(ovsdb_server, \"name\")\n        name_key.text = kwargs.pop('name')\n        ip = ET.SubElement(ovsdb_server, \"ip\")\n        address = ET.SubElement(ip, \"address\")\n        address.text = kwargs.pop('address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current NIC metadata from OVSDB server ip address."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the method of the available OVS server", "response": "def ovsdb_server_method(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ovsdb_server = ET.SubElement(config, \"ovsdb-server\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(ovsdb_server, \"name\")\n        name_key.text = kwargs.pop('name')\n        method = ET.SubElement(ovsdb_server, \"method\")\n        method.text = kwargs.pop('method')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ovsdb_server_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        ovsdb_server = ET.SubElement(config, \"ovsdb-server\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(ovsdb_server, \"name\")\n        name_key.text = kwargs.pop('name')\n        port = ET.SubElement(ovsdb_server, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the NIC - related cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nactivate the current cluster.", "response": "def ovsdb_server_activate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ovsdb_server = ET.SubElement(config, \"ovsdb-server\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        name_key = ET.SubElement(ovsdb_server, \"name\")\n        name_key.text = kwargs.pop('name')\n        activate = ET.SubElement(ovsdb_server, \"activate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tunnel_settings_system_tunnel_suppress_debounce(self, **kwargs):\n        config = ET.Element(\"config\")\n        tunnel_settings = ET.SubElement(config, \"tunnel-settings\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        system = ET.SubElement(tunnel_settings, \"system\")\n        tunnel = ET.SubElement(system, \"tunnel\")\n        suppress_debounce = ET.SubElement(tunnel, \"suppress-debounce\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the system tunnel suppress debounce setting"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget system tunnel replicator load balance", "response": "def tunnel_settings_system_tunnel_replicator_load_balance(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        tunnel_settings = ET.SubElement(config, \"tunnel-settings\", xmlns=\"urn:brocade.com:mgmt:brocade-tunnels\")\n        system = ET.SubElement(tunnel_settings, \"system\")\n        tunnel = ET.SubElement(system, \"tunnel\")\n        replicator = ET.SubElement(tunnel, \"replicator\")\n        load_balance = ET.SubElement(replicator, \"load-balance\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef describe(self, **kwargs):\n        response = self._new_response()\n        description = {\n            'cruddy_version': __version__,\n            'table_name': self.table_name,\n            'supported_operations': copy.copy(self.supported_ops),\n            'prototype': copy.deepcopy(self.prototype),\n            'operations': {}\n        }\n        for name, method in inspect.getmembers(self, inspect.ismethod):\n            if not name.startswith('_'):\n                argspec = inspect.getargspec(method)\n                if argspec.defaults is None:\n                    defaults = None\n                else:\n                    defaults = list(argspec.defaults)\n                method_info = {\n                    'docs': inspect.getdoc(method),\n                    'argspec': {\n                        'args': argspec.args,\n                        'varargs': argspec.varargs,\n                        'keywords': argspec.keywords,\n                        'defaults': defaults\n                    }\n                }\n                description['operations'][name] = method_info\n        response.data = description\n        return response", "response": "Returns descriptive information about this cruddy handler and the methods supported by it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of items in the database. Encrypted attributes are not decrypted when listing items.", "response": "def list(self, **kwargs):\n        \"\"\"\n        Returns a list of items in the database.  Encrypted attributes are not\n        decrypted when listing items.\n        \"\"\"\n        response = self._new_response()\n        if self._check_supported_op('list', response):\n            self._call_ddb_method(self.table.scan, {}, response)\n            if response.status == 'success':\n                response.data = self._replace_decimals(\n                    response.raw_response['Items'])\n        response.prepare()\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, id, decrypt=False, id_name='id', **kwargs):\n        response = self._new_response()\n        if self._check_supported_op('get', response):\n            if id is None:\n                response.status = 'error'\n                response.error_type = 'IDRequired'\n                response.error_message = 'Get requires an id'\n            else:\n                params = {'Key': {id_name: id},\n                          'ConsistentRead': True}\n                self._call_ddb_method(self.table.get_item,\n                                      params, response)\n                if response.status == 'success':\n                    if 'Item' in response.raw_response:\n                        item = response.raw_response['Item']\n                        if decrypt:\n                            self._decrypt(item)\n                        response.data = self._replace_decimals(item)\n                    else:\n                        response.status = 'error'\n                        response.error_type = 'NotFound'\n                        msg = 'item ({}) not found'.format(id)\n                        response.error_message = msg\n        response.prepare()\n        return response", "response": "Returns the item corresponding to id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self, item, **kwargs):\n        response = self._new_response()\n        if self._prototype_handler.check(item, 'create', response):\n            self._encrypt(item)\n            params = {'Item': item}\n            self._call_ddb_method(self.table.put_item,\n                                  params, response)\n            if response.status == 'success':\n                response.data = item\n        response.prepare()\n        return response", "response": "Creates a new item in the database. You pass in an item containing initial values."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the item based on the current values of the passed item.", "response": "def update(self, item, encrypt=True, **kwargs):\n        \"\"\"\n        Updates the item based on the current values of the dictionary passed\n        in.\n        \"\"\"\n        response = self._new_response()\n        if self._check_supported_op('update', response):\n            if self._prototype_handler.check(item, 'update', response):\n                if encrypt:\n                    self._encrypt(item)\n                params = {'Item': item}\n                self._call_ddb_method(self.table.put_item,\n                                      params, response)\n                if response.status == 'success':\n                    response.data = item\n        response.prepare()\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef increment_counter(self, id, counter_name, increment=1,\n                          id_name='id', **kwargs):\n        \"\"\"\n        Atomically increments a counter attribute in the item identified by\n        ``id``.  You must specify the name of the attribute as ``counter_name``\n        and, optionally, the ``increment`` which defaults to ``1``.\n        \"\"\"\n        response = self._new_response()\n        if self._check_supported_op('increment_counter', response):\n            params = {\n                'Key': {id_name: id},\n                'UpdateExpression': 'set #ctr = #ctr + :val',\n                'ExpressionAttributeNames': {\"#ctr\": counter_name},\n                'ExpressionAttributeValues': {\n                    ':val': decimal.Decimal(increment)},\n                'ReturnValues': 'UPDATED_NEW'\n            }\n            self._call_ddb_method(self.table.update_item, params, response)\n            if response.status == 'success':\n                if 'Attributes' in response.raw_response:\n                    self._replace_decimals(response.raw_response)\n                    attr = response.raw_response['Attributes'][counter_name]\n                    response.data = attr\n        response.prepare()\n        return response", "response": "Atomically increments a counter attribute in the item identified by id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting the item corresponding to id.", "response": "def delete(self, id, id_name='id', **kwargs):\n        \"\"\"\n        Deletes the item corresponding to ``id``.\n        \"\"\"\n        response = self._new_response()\n        if self._check_supported_op('delete', response):\n            params = {'Key': {id_name: id}}\n            self._call_ddb_method(self.table.delete_item, params, response)\n            response.data = 'true'\n        response.prepare()\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bulk_delete(self, query, **kwargs):\n        response = self._new_response()\n        if self._check_supported_op('search', response):\n            n = 0\n            pe = 'id'\n            response = self.search(query, projection_expression=pe, **kwargs)\n            while response.status == 'success' and response.data:\n                for item in response.data:\n                    delete_response = self.delete(item['id'])\n                    if response.status != 'success':\n                        response = delete_response\n                        break\n                    n += 1\n                response = self.search(\n                    query, projection_expression=pe, **kwargs)\n            if response.status == 'success':\n                response.data = {'deleted': n}\n        return response", "response": "Perform a search and delete all items that match."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handler(self, operation=None, **kwargs):\n        response = self._new_response()\n        if operation is None:\n            response.status = 'error'\n            response.error_type = 'MissingOperation'\n            response.error_message = 'You must pass an operation'\n            return response\n        operation = operation.lower()\n        self._check_supported_op(operation, response)\n        if response.status == 'success':\n            method = getattr(self, operation, None)\n            if callable(method):\n                response = method(**kwargs)\n            else:\n                response.status == 'error'\n                response.error_type = 'NotImplemented'\n                msg = 'Operation: {} is not implemented'.format(operation)\n                response.error_message = msg\n        return response", "response": "This method provides a generic handler interface for the cruddy API."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget LDP neighbor detail input request - type get - request - interface - type", "response": "def get_lldp_neighbor_detail_input_request_type_get_request_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        input = ET.SubElement(get_lldp_neighbor_detail, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        interface_type = ET.SubElement(get_request, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_lldp_neighbor_detail_input_request_type_get_request_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        input = ET.SubElement(get_lldp_neighbor_detail, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        interface_name = ET.SubElement(get_request, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDP neighbor detail input request type get request interface name"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget LDP neighbor detail input request type get next request last rcvd ifindex", "response": "def get_lldp_neighbor_detail_input_request_type_get_next_request_last_rcvd_ifindex(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        input = ET.SubElement(get_lldp_neighbor_detail, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        last_rcvd_ifindex = ET.SubElement(get_next_request, \"last-rcvd-ifindex\")\n        last_rcvd_ifindex.text = kwargs.pop('last_rcvd_ifindex')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_lldp_neighbor_detail_input_request_type_get_rbridge_specific_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        input = ET.SubElement(get_lldp_neighbor_detail, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_rbridge_specific = ET.SubElement(request_type, \"get-rbridge-specific\")\n        rbridge_id = ET.SubElement(get_rbridge_specific, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDP neighbor detail input request type get rbridge specific rbridge id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget LDP neighbor detail output for local_interface_name", "response": "def get_lldp_neighbor_detail_output_lldp_neighbor_detail_local_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        local_interface_name = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name.text = kwargs.pop('local_interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting LDP neighbor detail output for local_interface_mac.", "response": "def get_lldp_neighbor_detail_output_lldp_neighbor_detail_local_interface_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        local_interface_mac = ET.SubElement(lldp_neighbor_detail, \"local-interface-mac\")\n        local_interface_mac.text = kwargs.pop('local_interface_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget LDP neighbor detail output for local interface ifindex.", "response": "def get_lldp_neighbor_detail_output_lldp_neighbor_detail_local_interface_ifindex(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        local_interface_ifindex = ET.SubElement(lldp_neighbor_detail, \"local-interface-ifindex\")\n        local_interface_ifindex.text = kwargs.pop('local_interface_ifindex')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_lldp_neighbor_detail_output_lldp_neighbor_detail_remote_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name.text = kwargs.pop('remote_interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDP neighbor detail output for a specific local interface name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting LDP neighbor detail output for a single remote interface.", "response": "def get_lldp_neighbor_detail_output_lldp_neighbor_detail_remote_interface_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        remote_interface_mac = ET.SubElement(lldp_neighbor_detail, \"remote-interface-mac\")\n        remote_interface_mac.text = kwargs.pop('remote_interface_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_lldp_neighbor_detail_output_lldp_neighbor_detail_remote_management_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        remote_management_address = ET.SubElement(lldp_neighbor_detail, \"remote-management-address\")\n        remote_management_address.text = kwargs.pop('remote_management_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDP neighbor detail output for a specific local interface and remote management address."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_lldp_neighbor_detail_output_lldp_neighbor_detail_remote_unnum_interface_mac(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        remote_unnum_interface_mac = ET.SubElement(lldp_neighbor_detail, \"remote-unnum-interface-mac\")\n        remote_unnum_interface_mac.text = kwargs.pop('remote_unnum_interface_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDP neighbor detail output for a single local interface."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_lldp_neighbor_detail_output_lldp_neighbor_detail_remote_unnum_ip_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        remote_unnum_ip_address = ET.SubElement(lldp_neighbor_detail, \"remote-unnum-ip-address\")\n        remote_unnum_ip_address.text = kwargs.pop('remote_unnum_ip_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDP neighbor detail output for a specific local interface and remote unnum ip address."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting LDP Neighbor Detail output for a specific local interface and remote port description.", "response": "def get_lldp_neighbor_detail_output_lldp_neighbor_detail_remote_port_description(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        remote_port_description = ET.SubElement(lldp_neighbor_detail, \"remote-port-description\")\n        remote_port_description.text = kwargs.pop('remote_port_description')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget LDP neighbor detail output for a remote chassis.", "response": "def get_lldp_neighbor_detail_output_lldp_neighbor_detail_remote_chassis_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        remote_chassis_id = ET.SubElement(lldp_neighbor_detail, \"remote-chassis-id\")\n        remote_chassis_id.text = kwargs.pop('remote_chassis_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_lldp_neighbor_detail_output_lldp_neighbor_detail_remote_system_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        remote_system_name = ET.SubElement(lldp_neighbor_detail, \"remote-system-name\")\n        remote_system_name.text = kwargs.pop('remote_system_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDP neighbor detail output for a single local interface and remote system name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget LDP neighbor detail output for a single local interface and remote system description.", "response": "def get_lldp_neighbor_detail_output_lldp_neighbor_detail_remote_system_description(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        remote_system_description = ET.SubElement(lldp_neighbor_detail, \"remote-system-description\")\n        remote_system_description.text = kwargs.pop('remote_system_description')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting LDP neighbor detail output for a specific local interface and dead interval.", "response": "def get_lldp_neighbor_detail_output_lldp_neighbor_detail_dead_interval(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        dead_interval = ET.SubElement(lldp_neighbor_detail, \"dead-interval\")\n        dead_interval.text = kwargs.pop('dead_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_lldp_neighbor_detail_output_lldp_neighbor_detail_remaining_life(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        remaining_life = ET.SubElement(lldp_neighbor_detail, \"remaining-life\")\n        remaining_life.text = kwargs.pop('remaining_life')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDP neighbor detail output of get_lldp_neighbor_detail output of get_lldp_neighbor_detail_remaining_life"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget LDP neighbor detail output for a specific local interface and LDP PDU transmitted.", "response": "def get_lldp_neighbor_detail_output_lldp_neighbor_detail_lldp_pdu_transmitted(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        lldp_pdu_transmitted = ET.SubElement(lldp_neighbor_detail, \"lldp-pdu-transmitted\")\n        lldp_pdu_transmitted.text = kwargs.pop('lldp_pdu_transmitted')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting LDP neighbor detail output for a specific local interface and LDP PDU received.", "response": "def get_lldp_neighbor_detail_output_lldp_neighbor_detail_lldp_pdu_received(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        lldp_neighbor_detail = ET.SubElement(output, \"lldp-neighbor-detail\")\n        local_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"local-interface-name\")\n        local_interface_name_key.text = kwargs.pop('local_interface_name')\n        remote_interface_name_key = ET.SubElement(lldp_neighbor_detail, \"remote-interface-name\")\n        remote_interface_name_key.text = kwargs.pop('remote_interface_name')\n        lldp_pdu_received = ET.SubElement(lldp_neighbor_detail, \"lldp-pdu-received\")\n        lldp_pdu_received.text = kwargs.pop('lldp_pdu_received')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_lldp_neighbor_detail_output_has_more(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_lldp_neighbor_detail = ET.Element(\"get_lldp_neighbor_detail\")\n        config = get_lldp_neighbor_detail\n        output = ET.SubElement(get_lldp_neighbor_detail, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDP neighbor detail output has - more."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget Port Profile for Interface input rbridge - id.", "response": "def get_port_profile_for_intf_input_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_for_intf = ET.Element(\"get_port_profile_for_intf\")\n        config = get_port_profile_for_intf\n        input = ET.SubElement(get_port_profile_for_intf, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Port Profile for Interface input request type get request interface type", "response": "def get_port_profile_for_intf_input_request_type_get_request_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_for_intf = ET.Element(\"get_port_profile_for_intf\")\n        config = get_port_profile_for_intf\n        input = ET.SubElement(get_port_profile_for_intf, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        interface_type = ET.SubElement(get_request, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_port_profile_for_intf_input_request_type_get_request_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_profile_for_intf = ET.Element(\"get_port_profile_for_intf\")\n        config = get_port_profile_for_intf\n        input = ET.SubElement(get_port_profile_for_intf, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        interface_name = ET.SubElement(get_request, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Profile for Interface input request type get request interface name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget Port Profile for Interface input request type getnext request last received interface info interface type", "response": "def get_port_profile_for_intf_input_request_type_getnext_request_last_received_interface_info_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_for_intf = ET.Element(\"get_port_profile_for_intf\")\n        config = get_port_profile_for_intf\n        input = ET.SubElement(get_port_profile_for_intf, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        getnext_request = ET.SubElement(request_type, \"getnext-request\")\n        last_received_interface_info = ET.SubElement(getnext_request, \"last-received-interface-info\")\n        interface_type = ET.SubElement(last_received_interface_info, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_port_profile_for_intf_input_request_type_getnext_request_last_received_interface_info_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_profile_for_intf = ET.Element(\"get_port_profile_for_intf\")\n        config = get_port_profile_for_intf\n        input = ET.SubElement(get_port_profile_for_intf, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        getnext_request = ET.SubElement(request_type, \"getnext-request\")\n        last_received_interface_info = ET.SubElement(getnext_request, \"last-received-interface-info\")\n        interface_name = ET.SubElement(last_received_interface_info, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Profile for Interface input request type getnext request last received interface info interface name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget Port Profile for Interface output and interface type.", "response": "def get_port_profile_for_intf_output_interface_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_for_intf = ET.Element(\"get_port_profile_for_intf\")\n        config = get_port_profile_for_intf\n        output = ET.SubElement(get_port_profile_for_intf, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type = ET.SubElement(interface, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the port profile for interface for interface name.", "response": "def get_port_profile_for_intf_output_interface_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_for_intf = ET.Element(\"get_port_profile_for_intf\")\n        config = get_port_profile_for_intf\n        output = ET.SubElement(get_port_profile_for_intf, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_name = ET.SubElement(interface, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_port_profile_for_intf_output_interface_port_profile_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_profile_for_intf = ET.Element(\"get_port_profile_for_intf\")\n        config = get_port_profile_for_intf\n        output = ET.SubElement(get_port_profile_for_intf, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        port_profile = ET.SubElement(interface, \"port-profile\")\n        name = ET.SubElement(port_profile, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the port profile for interface output for the interface and port profile name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_port_profile_for_intf_output_has_more(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_profile_for_intf = ET.Element(\"get_port_profile_for_intf\")\n        config = get_port_profile_for_intf\n        output = ET.SubElement(get_port_profile_for_intf, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Profile for Interface output has - more."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Port Profile Status input rbridge - id.", "response": "def get_port_profile_status_input_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_status = ET.Element(\"get_port_profile_status\")\n        config = get_port_profile_status\n        input = ET.SubElement(get_port_profile_status, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Port Profile Status input Port Profile Name", "response": "def get_port_profile_status_input_port_profile_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_status = ET.Element(\"get_port_profile_status\")\n        config = get_port_profile_status\n        input = ET.SubElement(get_port_profile_status, \"input\")\n        port_profile_name = ET.SubElement(input, \"port-profile-name\")\n        port_profile_name.text = kwargs.pop('port_profile_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets Port Profile Status input.", "response": "def get_port_profile_status_input_port_profile_status(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_status = ET.Element(\"get_port_profile_status\")\n        config = get_port_profile_status\n        input = ET.SubElement(get_port_profile_status, \"input\")\n        port_profile_status = ET.SubElement(input, \"port-profile-status\")\n        port_profile_status.text = kwargs.pop('port_profile_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_port_profile_status_input_request_type_getnext_request_last_received_port_profile_info_profile_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_profile_status = ET.Element(\"get_port_profile_status\")\n        config = get_port_profile_status\n        input = ET.SubElement(get_port_profile_status, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        getnext_request = ET.SubElement(request_type, \"getnext-request\")\n        last_received_port_profile_info = ET.SubElement(getnext_request, \"last-received-port-profile-info\")\n        profile_name = ET.SubElement(last_received_port_profile_info, \"profile-name\")\n        profile_name.text = kwargs.pop('profile_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Profile Status input request Type GetNext Request Last Received Port Profile Info Profile Name"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets Port Profile Status input request type getnext request last received port - profile - info profile mac", "response": "def get_port_profile_status_input_request_type_getnext_request_last_received_port_profile_info_profile_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_status = ET.Element(\"get_port_profile_status\")\n        config = get_port_profile_status\n        input = ET.SubElement(get_port_profile_status, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        getnext_request = ET.SubElement(request_type, \"getnext-request\")\n        last_received_port_profile_info = ET.SubElement(getnext_request, \"last-received-port-profile-info\")\n        profile_mac = ET.SubElement(last_received_port_profile_info, \"profile-mac\")\n        profile_mac.text = kwargs.pop('profile_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets Port Profile Status output port - profile name.", "response": "def get_port_profile_status_output_port_profile_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_status = ET.Element(\"get_port_profile_status\")\n        config = get_port_profile_status\n        output = ET.SubElement(get_port_profile_status, \"output\")\n        port_profile = ET.SubElement(output, \"port-profile\")\n        name = ET.SubElement(port_profile, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_port_profile_status_output_port_profile_ppid(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_profile_status = ET.Element(\"get_port_profile_status\")\n        config = get_port_profile_status\n        output = ET.SubElement(get_port_profile_status, \"output\")\n        port_profile = ET.SubElement(output, \"port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        ppid = ET.SubElement(port_profile, \"ppid\")\n        ppid.text = kwargs.pop('ppid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Profile Status output port - profile ppid."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_port_profile_status_output_port_profile_is_active(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_profile_status = ET.Element(\"get_port_profile_status\")\n        config = get_port_profile_status\n        output = ET.SubElement(get_port_profile_status, \"output\")\n        port_profile = ET.SubElement(output, \"port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        is_active = ET.SubElement(port_profile, \"is-active\")\n        is_active.text = kwargs.pop('is_active')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Profile Status output Port Profile Is Active"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_port_profile_status_output_port_profile_mac_association_mac(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_profile_status = ET.Element(\"get_port_profile_status\")\n        config = get_port_profile_status\n        output = ET.SubElement(get_port_profile_status, \"output\")\n        port_profile = ET.SubElement(output, \"port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        mac_association = ET.SubElement(port_profile, \"mac-association\")\n        mac = ET.SubElement(mac_association, \"mac\")\n        mac.text = kwargs.pop('mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Profile Status output port - profile mac - association mac"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the status of a port profile status output of a MAC Association Applied Interface", "response": "def get_port_profile_status_output_port_profile_mac_association_applied_interface_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_status = ET.Element(\"get_port_profile_status\")\n        config = get_port_profile_status\n        output = ET.SubElement(get_port_profile_status, \"output\")\n        port_profile = ET.SubElement(output, \"port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        mac_association = ET.SubElement(port_profile, \"mac-association\")\n        mac_key = ET.SubElement(mac_association, \"mac\")\n        mac_key.text = kwargs.pop('mac')\n        applied_interface = ET.SubElement(mac_association, \"applied-interface\")\n        interface_type = ET.SubElement(applied_interface, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Port Profile Status output port - profile has - more.", "response": "def get_port_profile_status_output_port_profile_has_more(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_profile_status = ET.Element(\"get_port_profile_status\")\n        config = get_port_profile_status\n        output = ET.SubElement(get_port_profile_status, \"output\")\n        port_profile = ET.SubElement(output, \"port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        has_more = ET.SubElement(port_profile, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef zoning_defined_configuration_cfg_cfg_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        zoning = ET.SubElement(config, \"zoning\", xmlns=\"urn:brocade.com:mgmt:brocade-zone\")\n        defined_configuration = ET.SubElement(zoning, \"defined-configuration\")\n        cfg = ET.SubElement(defined_configuration, \"cfg\")\n        cfg_name = ET.SubElement(cfg, \"cfg-name\")\n        cfg_name.text = kwargs.pop('cfg_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        zoning_defined_configuration_cfg cfg_name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef zoning_defined_configuration_cfg_member_zone_zone_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        zoning = ET.SubElement(config, \"zoning\", xmlns=\"urn:brocade.com:mgmt:brocade-zone\")\n        defined_configuration = ET.SubElement(zoning, \"defined-configuration\")\n        cfg = ET.SubElement(defined_configuration, \"cfg\")\n        cfg_name_key = ET.SubElement(cfg, \"cfg-name\")\n        cfg_name_key.text = kwargs.pop('cfg_name')\n        member_zone = ET.SubElement(cfg, \"member-zone\")\n        zone_name = ET.SubElement(member_zone, \"zone-name\")\n        zone_name.text = kwargs.pop('zone_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        zoning_defined_configuration_cfg member - zone - zone - name"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the config element for the zoning defined configuration zone zone_name", "response": "def zoning_defined_configuration_zone_zone_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        zoning = ET.SubElement(config, \"zoning\", xmlns=\"urn:brocade.com:mgmt:brocade-zone\")\n        defined_configuration = ET.SubElement(zoning, \"defined-configuration\")\n        zone = ET.SubElement(defined_configuration, \"zone\")\n        zone_name = ET.SubElement(zone, \"zone-name\")\n        zone_name.text = kwargs.pop('zone_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the name of the member entry in the defined configuration zone.", "response": "def zoning_defined_configuration_zone_member_entry_entry_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        zoning = ET.SubElement(config, \"zoning\", xmlns=\"urn:brocade.com:mgmt:brocade-zone\")\n        defined_configuration = ET.SubElement(zoning, \"defined-configuration\")\n        zone = ET.SubElement(defined_configuration, \"zone\")\n        zone_name_key = ET.SubElement(zone, \"zone-name\")\n        zone_name_key.text = kwargs.pop('zone_name')\n        member_entry = ET.SubElement(zone, \"member-entry\")\n        entry_name = ET.SubElement(member_entry, \"entry-name\")\n        entry_name.text = kwargs.pop('entry_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the config element for the zoning defined configuration alias member entry alias entry name.", "response": "def zoning_defined_configuration_alias_member_entry_alias_entry_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        zoning = ET.SubElement(config, \"zoning\", xmlns=\"urn:brocade.com:mgmt:brocade-zone\")\n        defined_configuration = ET.SubElement(zoning, \"defined-configuration\")\n        alias = ET.SubElement(defined_configuration, \"alias\")\n        alias_name_key = ET.SubElement(alias, \"alias-name\")\n        alias_name_key.text = kwargs.pop('alias_name')\n        member_entry = ET.SubElement(alias, \"member-entry\")\n        alias_entry_name = ET.SubElement(member_entry, \"alias-entry-name\")\n        alias_entry_name.text = kwargs.pop('alias_entry_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef zoning_enabled_configuration_cfg_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        zoning = ET.SubElement(config, \"zoning\", xmlns=\"urn:brocade.com:mgmt:brocade-zone\")\n        enabled_configuration = ET.SubElement(zoning, \"enabled-configuration\")\n        cfg_name = ET.SubElement(enabled_configuration, \"cfg-name\")\n        cfg_name.text = kwargs.pop('cfg_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the zoning enabled configuration cfg_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef zoning_enabled_configuration_default_zone_access(self, **kwargs):\n        config = ET.Element(\"config\")\n        zoning = ET.SubElement(config, \"zoning\", xmlns=\"urn:brocade.com:mgmt:brocade-zone\")\n        enabled_configuration = ET.SubElement(zoning, \"enabled-configuration\")\n        default_zone_access = ET.SubElement(enabled_configuration, \"default-zone-access\")\n        default_zone_access.text = kwargs.pop('default_zone_access')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config element for the zoning enabled configuration and default zone access"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef zoning_enabled_configuration_cfg_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        zoning = ET.SubElement(config, \"zoning\", xmlns=\"urn:brocade.com:mgmt:brocade-zone\")\n        enabled_configuration = ET.SubElement(zoning, \"enabled-configuration\")\n        cfg_action = ET.SubElement(enabled_configuration, \"cfg-action\")\n        cfg_action.text = kwargs.pop('cfg_action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get zoning enabled configuration cfg action"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_zoning_enabled_configuration_input_request_type_get_request_zone_name_pattern(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_zoning_enabled_configuration = ET.Element(\"show_zoning_enabled_configuration\")\n        config = show_zoning_enabled_configuration\n        input = ET.SubElement(show_zoning_enabled_configuration, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        zone_name_pattern = ET.SubElement(get_request, \"zone-name-pattern\")\n        zone_name_pattern.text = kwargs.pop('zone_name_pattern')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a show zoning enabled configuration input request type get request zone name pattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_zoning_enabled_configuration_input_request_type_get_next_request_last_rcvd_zone_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_zoning_enabled_configuration = ET.Element(\"show_zoning_enabled_configuration\")\n        config = show_zoning_enabled_configuration\n        input = ET.SubElement(show_zoning_enabled_configuration, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        last_rcvd_zone_name = ET.SubElement(get_next_request, \"last-rcvd-zone-name\")\n        last_rcvd_zone_name.text = kwargs.pop('last_rcvd_zone_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Zoning Enabled Configuration input request type get next request last rcvd zone name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_zoning_enabled_configuration_output_enabled_configuration_cfg_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_zoning_enabled_configuration = ET.Element(\"show_zoning_enabled_configuration\")\n        config = show_zoning_enabled_configuration\n        output = ET.SubElement(show_zoning_enabled_configuration, \"output\")\n        enabled_configuration = ET.SubElement(output, \"enabled-configuration\")\n        cfg_name = ET.SubElement(enabled_configuration, \"cfg-name\")\n        cfg_name.text = kwargs.pop('cfg_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Zoning Enabled Configuration output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_zoning_enabled_configuration_output_enabled_configuration_enabled_zone_zone_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_zoning_enabled_configuration = ET.Element(\"show_zoning_enabled_configuration\")\n        config = show_zoning_enabled_configuration\n        output = ET.SubElement(show_zoning_enabled_configuration, \"output\")\n        enabled_configuration = ET.SubElement(output, \"enabled-configuration\")\n        enabled_zone = ET.SubElement(enabled_configuration, \"enabled-zone\")\n        zone_name = ET.SubElement(enabled_zone, \"zone-name\")\n        zone_name.text = kwargs.pop('zone_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Zoning Enabled Configuration output Enabled Zone Name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_zoning_enabled_configuration_output_enabled_configuration_enabled_zone_member_entry_entry_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_zoning_enabled_configuration = ET.Element(\"show_zoning_enabled_configuration\")\n        config = show_zoning_enabled_configuration\n        output = ET.SubElement(show_zoning_enabled_configuration, \"output\")\n        enabled_configuration = ET.SubElement(output, \"enabled-configuration\")\n        enabled_zone = ET.SubElement(enabled_configuration, \"enabled-zone\")\n        zone_name_key = ET.SubElement(enabled_zone, \"zone-name\")\n        zone_name_key.text = kwargs.pop('zone_name')\n        member_entry = ET.SubElement(enabled_zone, \"member-entry\")\n        entry_name = ET.SubElement(member_entry, \"entry-name\")\n        entry_name.text = kwargs.pop('entry_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Zoning Enabled Configuration output enabled - zone member - entry name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_zoning_enabled_configuration_output_enabled_configuration_has_more(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_zoning_enabled_configuration = ET.Element(\"show_zoning_enabled_configuration\")\n        config = show_zoning_enabled_configuration\n        output = ET.SubElement(show_zoning_enabled_configuration, \"output\")\n        enabled_configuration = ET.SubElement(output, \"enabled-configuration\")\n        has_more = ET.SubElement(enabled_configuration, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Zoning Enabled Configuration output Enabled Configuration Has More"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_lldp_neighbors_request(last_ifindex, rbridge_id):\n\n        request_lldp = ET.Element(\n            'get-lldp-neighbor-detail',\n            xmlns=\"urn:brocade.com:mgmt:brocade-lldp-ext\"\n        )\n        if rbridge_id is not None:\n            rbridge_el = ET.SubElement(request_lldp, \"rbridge-id\")\n            rbridge_el.text = rbridge_id\n        elif last_ifindex != '':\n            last_received_int = ET.SubElement(request_lldp,\n                                              \"last-rcvd-ifindex\")\n            last_received_int.text = last_ifindex\n\n        return request_lldp", "response": "Creates a Netconf request based on the last received or ifindex."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_tunnel_info_input_page_cursor(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        input = ET.SubElement(get_tunnel_info, \"input\")\n        page_cursor = ET.SubElement(input, \"page-cursor\")\n        page_cursor.text = kwargs.pop('page_cursor')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get tunnel info input page cursor"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_tunnel_info_input_filter_type_filter_by_id_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        input = ET.SubElement(get_tunnel_info, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_id = ET.SubElement(filter_type, \"filter-by-id\")\n        id = ET.SubElement(filter_by_id, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get tunnel info input filter type filter by id id"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_tunnel_info_input_filter_type_filter_by_mode_mode(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        input = ET.SubElement(get_tunnel_info, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_mode = ET.SubElement(filter_type, \"filter-by-mode\")\n        mode = ET.SubElement(filter_by_mode, \"mode\")\n        mode.text = kwargs.pop('mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get tunnel info input filter type filter by mode mode"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_tunnel_info_input_filter_type_filter_by_gateway_gw_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        input = ET.SubElement(get_tunnel_info, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_gateway = ET.SubElement(filter_type, \"filter-by-gateway\")\n        gw_name = ET.SubElement(filter_by_gateway, \"gw-name\")\n        gw_name.text = kwargs.pop('gw_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get tunnel info input filter type filter by gateway gw name"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets tunnel info input filter type filter by SIP src IP", "response": "def get_tunnel_info_input_filter_type_filter_by_sip_src_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        input = ET.SubElement(get_tunnel_info, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_sip = ET.SubElement(filter_type, \"filter-by-sip\")\n        src_ip = ET.SubElement(filter_by_sip, \"src-ip\")\n        src_ip.text = kwargs.pop('src_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting tunnel info input filter type filter by dip dest ip", "response": "def get_tunnel_info_input_filter_type_filter_by_dip_dest_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        input = ET.SubElement(get_tunnel_info, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_dip = ET.SubElement(filter_type, \"filter-by-dip\")\n        dest_ip = ET.SubElement(filter_by_dip, \"dest-ip\")\n        dest_ip.text = kwargs.pop('dest_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_tunnel_info_input_filter_type_filter_by_cfg_src_config_src(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        input = ET.SubElement(get_tunnel_info, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_cfg_src = ET.SubElement(filter_type, \"filter-by-cfg-src\")\n        config_src = ET.SubElement(filter_by_cfg_src, \"config-src\")\n        config_src.text = kwargs.pop('config_src')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get tunnel info input filter - type filter - by - cfg - src config - src"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets tunnel info input filter type filter by site name", "response": "def get_tunnel_info_input_filter_type_filter_by_site_site_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        input = ET.SubElement(get_tunnel_info, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_site = ET.SubElement(filter_type, \"filter-by-site\")\n        site_name = ET.SubElement(filter_by_site, \"site-name\")\n        site_name.text = kwargs.pop('site_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_tunnel_info_input_filter_type_filter_by_adm_state_admin_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        input = ET.SubElement(get_tunnel_info, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_adm_state = ET.SubElement(filter_type, \"filter-by-adm-state\")\n        admin_state = ET.SubElement(filter_by_adm_state, \"admin-state\")\n        admin_state.text = kwargs.pop('admin_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get tunnel info input filter - type filter - by - adm - state admin - state"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets tunnel info input filter - type filter - by - Oper - State", "response": "def get_tunnel_info_input_filter_type_filter_by_opr_state_oper_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        input = ET.SubElement(get_tunnel_info, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_opr_state = ET.SubElement(filter_type, \"filter-by-opr-state\")\n        oper_state = ET.SubElement(filter_by_opr_state, \"oper-state\")\n        oper_state.text = kwargs.pop('oper_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets tunnel info input filter - type filter - by - bfd - state bfd - state", "response": "def get_tunnel_info_input_filter_type_filter_by_bfd_state_bfd_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        input = ET.SubElement(get_tunnel_info, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_bfd_state = ET.SubElement(filter_type, \"filter-by-bfd-state\")\n        bfd_state = ET.SubElement(filter_by_bfd_state, \"bfd-state\")\n        bfd_state.text = kwargs.pop('bfd_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_tunnel_info_output_tunnel_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        tunnel = ET.SubElement(output, \"tunnel\")\n        id = ET.SubElement(tunnel, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get tunnel info output tunnel id"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets tunnel info output tunnel mode", "response": "def get_tunnel_info_output_tunnel_mode(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        tunnel = ET.SubElement(output, \"tunnel\")\n        mode = ET.SubElement(tunnel, \"mode\")\n        mode.text = kwargs.pop('mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets tunnel info output tunnel src ip", "response": "def get_tunnel_info_output_tunnel_src_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        tunnel = ET.SubElement(output, \"tunnel\")\n        src_ip = ET.SubElement(tunnel, \"src-ip\")\n        src_ip.text = kwargs.pop('src_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting tunnel info output tunnel dest ip", "response": "def get_tunnel_info_output_tunnel_dest_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        tunnel = ET.SubElement(output, \"tunnel\")\n        dest_ip = ET.SubElement(tunnel, \"dest-ip\")\n        dest_ip.text = kwargs.pop('dest_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets tunnel info output for a specific locale.", "response": "def get_tunnel_info_output_tunnel_vrf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        tunnel = ET.SubElement(output, \"tunnel\")\n        vrf = ET.SubElement(tunnel, \"vrf\")\n        vrf.text = kwargs.pop('vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_tunnel_info_output_tunnel_config_src(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        tunnel = ET.SubElement(output, \"tunnel\")\n        config_src = ET.SubElement(tunnel, \"config-src\")\n        config_src.text = kwargs.pop('config_src')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get tunnel info output tunnel config src."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_tunnel_info_output_tunnel_admin_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        tunnel = ET.SubElement(output, \"tunnel\")\n        admin_state = ET.SubElement(tunnel, \"admin-state\")\n        admin_state.text = kwargs.pop('admin_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get tunnel info output tunnel admin state"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_tunnel_info_output_tunnel_oper_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        tunnel = ET.SubElement(output, \"tunnel\")\n        oper_state = ET.SubElement(tunnel, \"oper-state\")\n        oper_state.text = kwargs.pop('oper_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Tunnel Info output tunnel and oper state."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_tunnel_info_output_tunnel_bfd_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        tunnel = ET.SubElement(output, \"tunnel\")\n        bfd_state = ET.SubElement(tunnel, \"bfd-state\")\n        bfd_state.text = kwargs.pop('bfd_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get tunnel info output tunnel bfd state"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting tunnel info output tunnel has conflicts", "response": "def get_tunnel_info_output_tunnel_has_conflicts(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        tunnel = ET.SubElement(output, \"tunnel\")\n        has_conflicts = ET.SubElement(tunnel, \"has-conflicts\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_tunnel_info_output_next_page_cursor(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        next_page_cursor = ET.SubElement(output, \"next-page-cursor\")\n        next_page_cursor.text = kwargs.pop('next_page_cursor')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get tunnel info output next page cursor"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_tunnel_statistics_input_page_cursor(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_statistics = ET.Element(\"get_tunnel_statistics\")\n        config = get_tunnel_statistics\n        input = ET.SubElement(get_tunnel_statistics, \"input\")\n        page_cursor = ET.SubElement(input, \"page-cursor\")\n        page_cursor.text = kwargs.pop('page_cursor')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Tunnel Statistics input page cursor"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets Tunnel Statistics input filter type filter by id id", "response": "def get_tunnel_statistics_input_filter_type_filter_by_id_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_statistics = ET.Element(\"get_tunnel_statistics\")\n        config = get_tunnel_statistics\n        input = ET.SubElement(get_tunnel_statistics, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_id = ET.SubElement(filter_type, \"filter-by-id\")\n        id = ET.SubElement(filter_by_id, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets Tunnel Statistics input filter type filter by mode mode.", "response": "def get_tunnel_statistics_input_filter_type_filter_by_mode_mode(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_statistics = ET.Element(\"get_tunnel_statistics\")\n        config = get_tunnel_statistics\n        input = ET.SubElement(get_tunnel_statistics, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_mode = ET.SubElement(filter_type, \"filter-by-mode\")\n        mode = ET.SubElement(filter_by_mode, \"mode\")\n        mode.text = kwargs.pop('mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Tunnel Statistics input filter type filter by gateway gw name", "response": "def get_tunnel_statistics_input_filter_type_filter_by_gateway_gw_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_statistics = ET.Element(\"get_tunnel_statistics\")\n        config = get_tunnel_statistics\n        input = ET.SubElement(get_tunnel_statistics, \"input\")\n        filter_type = ET.SubElement(input, \"filter-type\")\n        filter_by_gateway = ET.SubElement(filter_type, \"filter-by-gateway\")\n        gw_name = ET.SubElement(filter_by_gateway, \"gw-name\")\n        gw_name.text = kwargs.pop('gw_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Tunnel Statistics output tunnel stat id.", "response": "def get_tunnel_statistics_output_tunnel_stat_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_statistics = ET.Element(\"get_tunnel_statistics\")\n        config = get_tunnel_statistics\n        output = ET.SubElement(get_tunnel_statistics, \"output\")\n        tunnel_stat = ET.SubElement(output, \"tunnel-stat\")\n        id = ET.SubElement(tunnel_stat, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Tunnel Statistics output tunnel stat and tx frames.", "response": "def get_tunnel_statistics_output_tunnel_stat_tx_frames(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_statistics = ET.Element(\"get_tunnel_statistics\")\n        config = get_tunnel_statistics\n        output = ET.SubElement(get_tunnel_statistics, \"output\")\n        tunnel_stat = ET.SubElement(output, \"tunnel-stat\")\n        tx_frames = ET.SubElement(tunnel_stat, \"tx-frames\")\n        tx_frames.text = kwargs.pop('tx_frames')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_tunnel_statistics_output_tunnel_stat_tx_bytes(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_statistics = ET.Element(\"get_tunnel_statistics\")\n        config = get_tunnel_statistics\n        output = ET.SubElement(get_tunnel_statistics, \"output\")\n        tunnel_stat = ET.SubElement(output, \"tunnel-stat\")\n        tx_bytes = ET.SubElement(tunnel_stat, \"tx-bytes\")\n        tx_bytes.text = kwargs.pop('tx_bytes')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Tunnel Statistics output tunnel stat tx bytes"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Tunnel Statistics output tunnel stat and rx frames", "response": "def get_tunnel_statistics_output_tunnel_stat_rx_frames(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_statistics = ET.Element(\"get_tunnel_statistics\")\n        config = get_tunnel_statistics\n        output = ET.SubElement(get_tunnel_statistics, \"output\")\n        tunnel_stat = ET.SubElement(output, \"tunnel-stat\")\n        rx_frames = ET.SubElement(tunnel_stat, \"rx-frames\")\n        rx_frames.text = kwargs.pop('rx_frames')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Tunnel Statistics output tunnel stat and rx bytes", "response": "def get_tunnel_statistics_output_tunnel_stat_rx_bytes(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_tunnel_statistics = ET.Element(\"get_tunnel_statistics\")\n        config = get_tunnel_statistics\n        output = ET.SubElement(get_tunnel_statistics, \"output\")\n        tunnel_stat = ET.SubElement(output, \"tunnel-stat\")\n        rx_bytes = ET.SubElement(tunnel_stat, \"rx-bytes\")\n        rx_bytes.text = kwargs.pop('rx_bytes')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_tunnel_statistics_output_next_page_cursor(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_tunnel_statistics = ET.Element(\"get_tunnel_statistics\")\n        config = get_tunnel_statistics\n        output = ET.SubElement(get_tunnel_statistics, \"output\")\n        next_page_cursor = ET.SubElement(output, \"next-page-cursor\")\n        next_page_cursor.text = kwargs.pop('next_page_cursor')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Tunnel Statistics output next page cursor"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ipv6_acl_ipv6_access_list_standard_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        ipv6_acl = ET.SubElement(config, \"ipv6-acl\", xmlns=\"urn:brocade.com:mgmt:brocade-ipv6-access-list\")\n        ipv6 = ET.SubElement(ipv6_acl, \"ipv6\")\n        access_list = ET.SubElement(ipv6, \"access-list\")\n        standard = ET.SubElement(access_list, \"standard\")\n        name = ET.SubElement(standard, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the standard name of the ipv6 access list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the configuration of the ipv6_access_list standard_seq_seq_id", "response": "def ipv6_acl_ipv6_access_list_standard_seq_seq_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ipv6_acl = ET.SubElement(config, \"ipv6-acl\", xmlns=\"urn:brocade.com:mgmt:brocade-ipv6-access-list\")\n        ipv6 = ET.SubElement(ipv6_acl, \"ipv6\")\n        access_list = ET.SubElement(ipv6, \"access-list\")\n        standard = ET.SubElement(access_list, \"standard\")\n        name_key = ET.SubElement(standard, \"name\")\n        name_key.text = kwargs.pop('name')\n        seq = ET.SubElement(standard, \"seq\")\n        seq_id = ET.SubElement(seq, \"seq-id\")\n        seq_id.text = kwargs.pop('seq_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ipv6_acl_ipv6_access_list_standard_seq_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        ipv6_acl = ET.SubElement(config, \"ipv6-acl\", xmlns=\"urn:brocade.com:mgmt:brocade-ipv6-access-list\")\n        ipv6 = ET.SubElement(ipv6_acl, \"ipv6\")\n        access_list = ET.SubElement(ipv6, \"access-list\")\n        standard = ET.SubElement(access_list, \"standard\")\n        name_key = ET.SubElement(standard, \"name\")\n        name_key.text = kwargs.pop('name')\n        seq = ET.SubElement(standard, \"seq\")\n        seq_id_key = ET.SubElement(seq, \"seq-id\")\n        seq_id_key.text = kwargs.pop('seq_id')\n        action = ET.SubElement(seq, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of the ipv6_access_list standard_seq_action"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the name of the extended name of the current locale", "response": "def ipv6_acl_ipv6_access_list_extended_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ipv6_acl = ET.SubElement(config, \"ipv6-acl\", xmlns=\"urn:brocade.com:mgmt:brocade-ipv6-access-list\")\n        ipv6 = ET.SubElement(ipv6_acl, \"ipv6\")\n        access_list = ET.SubElement(ipv6, \"access-list\")\n        extended = ET.SubElement(access_list, \"extended\")\n        name = ET.SubElement(extended, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init_app(self, app):\n\n        self.__app = app\n        self.__app.before_first_request(self.__setup)\n\n        self.tracer.enabled = self.__app.config.get('TRACE_ENABLED', self.tracer.enabled)", "response": "Initialize this class with the specified Flask application."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef created(self, data, schema=None, envelope=None):\n\n        data = marshal(data, schema, envelope)\n        return self.__make_response((data, 201))", "response": "Returns a Flask response object with the specified data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ok(self, data, schema=None, envelope=None):\n\n        data = marshal(data, schema, envelope)\n        return self.__make_response(data)", "response": "Gets a 200 response with the specified data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef authenticators(self, auths):\n\n        if not isinstance(auths, (list, tuple)):\n            auths = [auths]\n\n        instances = []\n\n        for auth in auths:\n            if isclass(auth):\n                instances.append(auth())\n            else:\n                instances.append(auth)\n\n        def decorator(func):\n            func.authenticators = instances\n            return func\n        return decorator", "response": "A decorator that sets a list of authenticators for a function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_body(self, param_name, schema):\n\n        schema = schema() if isclass(schema) else schema\n\n        def decorator(func):\n            @functools.wraps(func)\n            def wrapper(*args, **kwargs):\n                kwargs[param_name] = self.__parse_body(schema)\n                return func(*args, **kwargs)\n            return wrapper\n        return decorator", "response": "A decorator that converts the request body into a function parameter based on the specified schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_query(self, param_name, field):\n\n        return self.__from_source(param_name, field, lambda: request.args, 'query')", "response": "A decorator that converts a query string into a function parameter based on the specified field."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef marshal_with(self, schema, envelope=None):\n\n        # schema is pre instantiated to avoid instantiate it\n        # on every request\n        schema_is_class = isclass(schema)\n        schema_cache = schema() if schema_is_class else schema\n\n        def decorator(func):\n            @functools.wraps(func)\n            def wrapper(*args, **kwargs):\n                data = func(*args, **kwargs)\n                if isinstance(data, self.__app.response_class):\n                    return data\n\n                schema_instance = schema_cache\n\n                # if there is the parameter 'fields' in the url\n                # we cannot use the cached schema instance\n                # in this case we have to instantiate the schema\n                # on every request.\n                if schema_is_class:\n                    only = get_fields_from_request(schema=schema)\n                    if only:\n                        schema_instance = schema(only=only)\n\n                return marshal(data, schema_instance, envelope)\n            return wrapper\n        return decorator", "response": "A decorator that apply marshalling to the return values of your methods."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __make_response(self, data, default_renderer=None):\n\n        status = headers = None\n        if isinstance(data, tuple):\n            data, status, headers = unpack(data)\n\n        if data is None:\n            data = self.__app.response_class(status=204)\n        elif not isinstance(data, self.__app.response_class):\n            renderer, mimetype = self.content_negotiation.select_renderer(request, self.default_renderers)\n\n            if not renderer:\n                if not default_renderer:\n                    raise NotAcceptable()\n\n                renderer = default_renderer\n                mimetype = default_renderer.mimetype\n\n            data_bytes = renderer.render(data, mimetype)\n            data = self.__app.response_class(data_bytes, mimetype=str(mimetype))\n\n        if status is not None:\n            data.status_code = status\n\n        if headers:\n            data.headers.extend(headers)\n\n        return data", "response": "Creates a Flask response object from the specified data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nenable NACM for the current user.", "response": "def nacm_enable_nacm(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        enable_nacm = ET.SubElement(nacm, \"enable-nacm\")\n        enable_nacm.text = kwargs.pop('enable_nacm')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef nacm_write_default(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        write_default = ET.SubElement(nacm, \"write-default\")\n        write_default.text = kwargs.pop('write_default')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set write_default in nacm element."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nacm_exec_default(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        exec_default = ET.SubElement(nacm, \"exec-default\")\n        exec_default.text = kwargs.pop('exec_default')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        is an idempotent operation."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconfigures NACM External Groups", "response": "def nacm_enable_external_groups(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        enable_external_groups = ET.SubElement(nacm, \"enable-external-groups\")\n        enable_external_groups.text = kwargs.pop('enable_external_groups')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset Denied Operations to NACM", "response": "def nacm_denied_operations(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        denied_operations = ET.SubElement(nacm, \"denied-operations\")\n        denied_operations.text = kwargs.pop('denied_operations')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nacm_denied_data_writes(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        denied_data_writes = ET.SubElement(nacm, \"denied-data-writes\")\n        denied_data_writes.text = kwargs.pop('denied_data_writes')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set Denied Data Write status for NACM."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset Denied Notifications for NACM.", "response": "def nacm_denied_notifications(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        denied_notifications = ET.SubElement(nacm, \"denied-notifications\")\n        denied_notifications.text = kwargs.pop('denied_notifications')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nacm_groups_group_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        groups = ET.SubElement(nacm, \"groups\")\n        group = ET.SubElement(groups, \"group\")\n        name = ET.SubElement(group, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NACM group name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nacm_groups_group_gid(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        groups = ET.SubElement(nacm, \"groups\")\n        group = ET.SubElement(groups, \"group\")\n        name_key = ET.SubElement(group, \"name\")\n        name_key.text = kwargs.pop('name')\n        gid = ET.SubElement(group, \"gid\", xmlns=\"http://tail-f.com/yang/acm\")\n        gid.text = kwargs.pop('gid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NACM groups group gid"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget NACM rule list name.", "response": "def nacm_rule_list_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name = ET.SubElement(rule_list, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting NACM System Rule List rule name", "response": "def nacm_rule_list_rule_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule = ET.SubElement(rule_list, \"rule\")\n        name = ET.SubElement(rule, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef nacm_rule_list_rule_module_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule = ET.SubElement(rule_list, \"rule\")\n        name_key = ET.SubElement(rule, \"name\")\n        name_key.text = kwargs.pop('name')\n        module_name = ET.SubElement(rule, \"module-name\")\n        module_name.text = kwargs.pop('module_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NACM resource entry from rule list rule module name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting NACM Cache entry", "response": "def nacm_rule_list_rule_rule_type_protocol_operation_rpc_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule = ET.SubElement(rule_list, \"rule\")\n        name_key = ET.SubElement(rule, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule_type = ET.SubElement(rule, \"rule-type\")\n        protocol_operation = ET.SubElement(rule_type, \"protocol-operation\")\n        rpc_name = ET.SubElement(protocol_operation, \"rpc-name\")\n        rpc_name.text = kwargs.pop('rpc_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget NACM System Rule List", "response": "def nacm_rule_list_rule_rule_type_notification_notification_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule = ET.SubElement(rule_list, \"rule\")\n        name_key = ET.SubElement(rule, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule_type = ET.SubElement(rule, \"rule-type\")\n        notification = ET.SubElement(rule_type, \"notification\")\n        notification_name = ET.SubElement(notification, \"notification-name\")\n        notification_name.text = kwargs.pop('notification_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nacm_rule_list_rule_rule_type_data_node_path(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule = ET.SubElement(rule_list, \"rule\")\n        name_key = ET.SubElement(rule, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule_type = ET.SubElement(rule, \"rule-type\")\n        data_node = ET.SubElement(rule_type, \"data-node\")\n        path = ET.SubElement(data_node, \"path\")\n        path.text = kwargs.pop('path')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NACM Entry Rule List Rule Type and Data Node Path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget NACM rule list rule access operations.", "response": "def nacm_rule_list_rule_access_operations(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule = ET.SubElement(rule_list, \"rule\")\n        name_key = ET.SubElement(rule, \"name\")\n        name_key.text = kwargs.pop('name')\n        access_operations = ET.SubElement(rule, \"access-operations\")\n        access_operations.text = kwargs.pop('access_operations')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef nacm_rule_list_rule_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule = ET.SubElement(rule_list, \"rule\")\n        name_key = ET.SubElement(rule, \"name\")\n        name_key.text = kwargs.pop('name')\n        action = ET.SubElement(rule, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NACM System Rule List rule action"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef nacm_rule_list_rule_comment(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule = ET.SubElement(rule_list, \"rule\")\n        name_key = ET.SubElement(rule, \"name\")\n        name_key.text = kwargs.pop('name')\n        comment = ET.SubElement(rule, \"comment\")\n        comment.text = kwargs.pop('comment')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NACM Entry Rule Comment"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting NACM System Rule List Rule Context", "response": "def nacm_rule_list_rule_context(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule = ET.SubElement(rule_list, \"rule\")\n        name_key = ET.SubElement(rule, \"name\")\n        name_key.text = kwargs.pop('name')\n        context = ET.SubElement(rule, \"context\", xmlns=\"http://tail-f.com/yang/acm\")\n        context.text = kwargs.pop('context')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets NACM System Rule List rule log - if - permit", "response": "def nacm_rule_list_rule_log_if_permit(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        rule = ET.SubElement(rule_list, \"rule\")\n        name_key = ET.SubElement(rule, \"name\")\n        name_key.text = kwargs.pop('name')\n        log_if_permit = ET.SubElement(rule, \"log-if-permit\", xmlns=\"http://tail-f.com/yang/acm\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting NACM System Rule List", "response": "def nacm_rule_list_cmdrule_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        cmdrule = ET.SubElement(rule_list, \"cmdrule\", xmlns=\"http://tail-f.com/yang/acm\")\n        name = ET.SubElement(cmdrule, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nacm_rule_list_cmdrule_context(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        cmdrule = ET.SubElement(rule_list, \"cmdrule\", xmlns=\"http://tail-f.com/yang/acm\")\n        name_key = ET.SubElement(cmdrule, \"name\")\n        name_key.text = kwargs.pop('name')\n        context = ET.SubElement(cmdrule, \"context\")\n        context.text = kwargs.pop('context')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NACM Entry Link Rule List"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef nacm_rule_list_cmdrule_command(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        cmdrule = ET.SubElement(rule_list, \"cmdrule\", xmlns=\"http://tail-f.com/yang/acm\")\n        name_key = ET.SubElement(cmdrule, \"name\")\n        name_key.text = kwargs.pop('name')\n        command = ET.SubElement(cmdrule, \"command\")\n        command.text = kwargs.pop('command')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NACM System Rule List Command"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef nacm_rule_list_cmdrule_access_operations(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        cmdrule = ET.SubElement(rule_list, \"cmdrule\", xmlns=\"http://tail-f.com/yang/acm\")\n        name_key = ET.SubElement(cmdrule, \"name\")\n        name_key.text = kwargs.pop('name')\n        access_operations = ET.SubElement(cmdrule, \"access-operations\")\n        access_operations.text = kwargs.pop('access_operations')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NACM Entry Link Rule List and Access Operations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef nacm_rule_list_cmdrule_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        cmdrule = ET.SubElement(rule_list, \"cmdrule\", xmlns=\"http://tail-f.com/yang/acm\")\n        name_key = ET.SubElement(cmdrule, \"name\")\n        name_key.text = kwargs.pop('name')\n        action = ET.SubElement(cmdrule, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NACM Entry Link Rule List"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets NACM System Rule List", "response": "def nacm_rule_list_cmdrule_log_if_permit(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        cmdrule = ET.SubElement(rule_list, \"cmdrule\", xmlns=\"http://tail-f.com/yang/acm\")\n        name_key = ET.SubElement(cmdrule, \"name\")\n        name_key.text = kwargs.pop('name')\n        log_if_permit = ET.SubElement(cmdrule, \"log-if-permit\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting NACM Entry from Command Rule List.", "response": "def nacm_rule_list_cmdrule_comment(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        rule_list = ET.SubElement(nacm, \"rule-list\")\n        name_key = ET.SubElement(rule_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        cmdrule = ET.SubElement(rule_list, \"cmdrule\", xmlns=\"http://tail-f.com/yang/acm\")\n        name_key = ET.SubElement(cmdrule, \"name\")\n        name_key.text = kwargs.pop('name')\n        comment = ET.SubElement(cmdrule, \"comment\")\n        comment.text = kwargs.pop('comment')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets NACM read - default command.", "response": "def nacm_cmd_read_default(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        cmd_read_default = ET.SubElement(nacm, \"cmd-read-default\", xmlns=\"http://tail-f.com/yang/acm\")\n        cmd_read_default.text = kwargs.pop('cmd_read_default')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset command exec default in nacm element", "response": "def nacm_cmd_exec_default(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        nacm = ET.SubElement(config, \"nacm\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\")\n        cmd_exec_default = ET.SubElement(nacm, \"cmd-exec-default\", xmlns=\"http://tail-f.com/yang/acm\")\n        cmd_exec_default.text = kwargs.pop('cmd_exec_default')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log(verbose=False):\n\n    terminal.log.config(verbose=verbose)\n    terminal.log.info('this is a info message')\n    terminal.log.verbose.info('this is a verbose message')", "response": "print a log test\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ip_dns_dom_name_domain_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        dns = ET.SubElement(ip, \"dns\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-administration\")\n        dom_name = ET.SubElement(dns, \"dom-name\")\n        domain_name = ET.SubElement(dom_name, \"domain-name\")\n        domain_name.text = kwargs.pop('domain_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the object from the IP DNS domain name and domain name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the configuration of the object from the ip DNS name server and IP address.", "response": "def ip_dns_name_server_name_server_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        dns = ET.SubElement(ip, \"dns\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-administration\")\n        name_server = ET.SubElement(dns, \"name-server\")\n        name_server_ip = ET.SubElement(name_server, \"name-server-ip\")\n        name_server_ip.text = kwargs.pop('name_server_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the name of the resource from the hide - as - path - holder as - path - access - list.", "response": "def ip_hide_as_path_holder_as_path_access_list_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_as_path_holder = ET.SubElement(ip, \"hide-as-path-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        as_path = ET.SubElement(hide_as_path_holder, \"as-path\")\n        access_list = ET.SubElement(as_path, \"access-list\")\n        seq_keyword_key = ET.SubElement(access_list, \"seq-keyword\")\n        seq_keyword_key.text = kwargs.pop('seq_keyword')\n        instance_key = ET.SubElement(access_list, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        name = ET.SubElement(access_list, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the state of the resource from the hide - as - path - holder as - path - access - list seq - keyword.", "response": "def ip_hide_as_path_holder_as_path_access_list_seq_keyword(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_as_path_holder = ET.SubElement(ip, \"hide-as-path-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        as_path = ET.SubElement(hide_as_path_holder, \"as-path\")\n        access_list = ET.SubElement(as_path, \"access-list\")\n        name_key = ET.SubElement(access_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        instance_key = ET.SubElement(access_list, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        seq_keyword = ET.SubElement(access_list, \"seq-keyword\")\n        seq_keyword.text = kwargs.pop('seq_keyword')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the details of the resource from the ip hide - as - path - holder as - path - access - list instance.", "response": "def ip_hide_as_path_holder_as_path_access_list_instance(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_as_path_holder = ET.SubElement(ip, \"hide-as-path-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        as_path = ET.SubElement(hide_as_path_holder, \"as-path\")\n        access_list = ET.SubElement(as_path, \"access-list\")\n        name_key = ET.SubElement(access_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        seq_keyword_key = ET.SubElement(access_list, \"seq-keyword\")\n        seq_keyword_key.text = kwargs.pop('seq_keyword')\n        instance = ET.SubElement(access_list, \"instance\")\n        instance.text = kwargs.pop('instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the state of the resource from the ip hide - as - path - holder as - path - access - list ip - action", "response": "def ip_hide_as_path_holder_as_path_access_list_ip_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_as_path_holder = ET.SubElement(ip, \"hide-as-path-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        as_path = ET.SubElement(hide_as_path_holder, \"as-path\")\n        access_list = ET.SubElement(as_path, \"access-list\")\n        name_key = ET.SubElement(access_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        seq_keyword_key = ET.SubElement(access_list, \"seq-keyword\")\n        seq_keyword_key.text = kwargs.pop('seq_keyword')\n        instance_key = ET.SubElement(access_list, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        ip_action = ET.SubElement(access_list, \"ip-action\")\n        ip_action.text = kwargs.pop('ip_action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the name of the current resource from the hide community list holder.", "response": "def ip_hide_community_list_holder_community_list_standard_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_community_list_holder = ET.SubElement(ip, \"hide-community-list-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        community_list = ET.SubElement(hide_community_list_holder, \"community-list\")\n        standard = ET.SubElement(community_list, \"standard\")\n        seq_keyword_key = ET.SubElement(standard, \"seq-keyword\")\n        seq_keyword_key.text = kwargs.pop('seq_keyword')\n        instance_key = ET.SubElement(standard, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        name = ET.SubElement(standard, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the value of the seq_keyword attribute of the resource in the hide community list holder.", "response": "def ip_hide_community_list_holder_community_list_standard_seq_keyword(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_community_list_holder = ET.SubElement(ip, \"hide-community-list-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        community_list = ET.SubElement(hide_community_list_holder, \"community-list\")\n        standard = ET.SubElement(community_list, \"standard\")\n        name_key = ET.SubElement(standard, \"name\")\n        name_key.text = kwargs.pop('name')\n        instance_key = ET.SubElement(standard, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        seq_keyword = ET.SubElement(standard, \"seq-keyword\")\n        seq_keyword.text = kwargs.pop('seq_keyword')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the current state of the resource from the community list holder.", "response": "def ip_hide_community_list_holder_community_list_standard_instance(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_community_list_holder = ET.SubElement(ip, \"hide-community-list-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        community_list = ET.SubElement(hide_community_list_holder, \"community-list\")\n        standard = ET.SubElement(community_list, \"standard\")\n        name_key = ET.SubElement(standard, \"name\")\n        name_key.text = kwargs.pop('name')\n        seq_keyword_key = ET.SubElement(standard, \"seq-keyword\")\n        seq_keyword_key.text = kwargs.pop('seq_keyword')\n        instance = ET.SubElement(standard, \"instance\")\n        instance.text = kwargs.pop('instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\noverwriting the ip hide - community - list - holder extended - ip - action", "response": "def ip_hide_community_list_holder_community_list_extended_ip_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_community_list_holder = ET.SubElement(ip, \"hide-community-list-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        community_list = ET.SubElement(hide_community_list_holder, \"community-list\")\n        extended = ET.SubElement(community_list, \"extended\")\n        name_key = ET.SubElement(extended, \"name\")\n        name_key.text = kwargs.pop('name')\n        seq_keyword_key = ET.SubElement(extended, \"seq-keyword\")\n        seq_keyword_key.text = kwargs.pop('seq_keyword')\n        instance_key = ET.SubElement(extended, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        ip_action = ET.SubElement(extended, \"ip-action\")\n        ip_action.text = kwargs.pop('ip_action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ip_hide_ext_community_list_holder_extcommunity_list_extcommunity_list_num(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_ext_community_list_holder = ET.SubElement(ip, \"hide-ext-community-list-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        extcommunity_list = ET.SubElement(hide_ext_community_list_holder, \"extcommunity-list\")\n        extcommunity_list_num = ET.SubElement(extcommunity_list, \"extcommunity-list-num\")\n        extcommunity_list_num.text = kwargs.pop('extcommunity_list_num')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Hide extended community list holder for the current ip"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ip_hide_ext_community_list_holder_extcommunity_list_ext_community_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_ext_community_list_holder = ET.SubElement(ip, \"hide-ext-community-list-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        extcommunity_list = ET.SubElement(hide_ext_community_list_holder, \"extcommunity-list\")\n        extcommunity_list_num_key = ET.SubElement(extcommunity_list, \"extcommunity-list-num\")\n        extcommunity_list_num_key.text = kwargs.pop('extcommunity_list_num')\n        ext_community_action = ET.SubElement(extcommunity_list, \"ext-community-action\")\n        ext_community_action.text = kwargs.pop('ext_community_action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Hide extended community list holder for the current ip"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the extended - community - list of the current ip", "response": "def ip_hide_ext_community_list_holder_extcommunity_list_ext_community_expr(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_ext_community_list_holder = ET.SubElement(ip, \"hide-ext-community-list-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        extcommunity_list = ET.SubElement(hide_ext_community_list_holder, \"extcommunity-list\")\n        extcommunity_list_num_key = ET.SubElement(extcommunity_list, \"extcommunity-list-num\")\n        extcommunity_list_num_key.text = kwargs.pop('extcommunity_list_num')\n        ext_community_expr = ET.SubElement(extcommunity_list, \"ext-community-expr\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the configuration of the current ip RTM entry", "response": "def ip_rtm_config_router_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        router_id = ET.SubElement(rtm_config, \"router-id\")\n        router_id.text = kwargs.pop('router_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the configuration of the available RTM modules.", "response": "def ip_rtm_config_load_sharing(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        load_sharing = ET.SubElement(rtm_config, \"load-sharing\")\n        load_sharing.text = kwargs.pop('load_sharing')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ip_rtm_config_route_static_route_nh_static_route_dest(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_nh = ET.SubElement(route, \"static-route-nh\")\n        static_route_next_hop_key = ET.SubElement(static_route_nh, \"static-route-next-hop\")\n        static_route_next_hop_key.text = kwargs.pop('static_route_next_hop')\n        static_route_dest = ET.SubElement(static_route_nh, \"static-route-dest\")\n        static_route_dest.text = kwargs.pop('static_route_dest')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the IP RTM route and set static route destination"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ip_rtm_config_route_static_route_nh_static_route_next_hop(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_nh = ET.SubElement(route, \"static-route-nh\")\n        static_route_dest_key = ET.SubElement(static_route_nh, \"static-route-dest\")\n        static_route_dest_key.text = kwargs.pop('static_route_dest')\n        static_route_next_hop = ET.SubElement(static_route_nh, \"static-route-next-hop\")\n        static_route_next_hop.text = kwargs.pop('static_route_next_hop')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the IP RTM route and set static route next hop"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the RTM route and route - attributes and metric attributes for the static route", "response": "def ip_rtm_config_route_static_route_nh_route_attributes_metric(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_nh = ET.SubElement(route, \"static-route-nh\")\n        static_route_dest_key = ET.SubElement(static_route_nh, \"static-route-dest\")\n        static_route_dest_key.text = kwargs.pop('static_route_dest')\n        static_route_next_hop_key = ET.SubElement(static_route_nh, \"static-route-next-hop\")\n        static_route_next_hop_key.text = kwargs.pop('static_route_next_hop')\n        route_attributes = ET.SubElement(static_route_nh, \"route-attributes\")\n        metric = ET.SubElement(route_attributes, \"metric\")\n        metric.text = kwargs.pop('metric')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ip_rtm_config_route_static_route_nh_vrf_static_route_next_vrf_dest(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_nh_vrf = ET.SubElement(route, \"static-route-nh-vrf\")\n        next_hop_vrf_key = ET.SubElement(static_route_nh_vrf, \"next-hop-vrf\")\n        next_hop_vrf_key.text = kwargs.pop('next_hop_vrf')\n        static_route_next_hop_key = ET.SubElement(static_route_nh_vrf, \"static-route-next-hop\")\n        static_route_next_hop_key.text = kwargs.pop('static_route_next_hop')\n        static_route_next_vrf_dest = ET.SubElement(static_route_nh_vrf, \"static-route-next-vrf-dest\")\n        static_route_next_vrf_dest.text = kwargs.pop('static_route_next_vrf_dest')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set static route next hopvrf dest in the RTM route"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the IP RTM route and set static route next hop VRF to next hop VRF", "response": "def ip_rtm_config_route_static_route_nh_vrf_next_hop_vrf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_nh_vrf = ET.SubElement(route, \"static-route-nh-vrf\")\n        static_route_next_vrf_dest_key = ET.SubElement(static_route_nh_vrf, \"static-route-next-vrf-dest\")\n        static_route_next_vrf_dest_key.text = kwargs.pop('static_route_next_vrf_dest')\n        static_route_next_hop_key = ET.SubElement(static_route_nh_vrf, \"static-route-next-hop\")\n        static_route_next_hop_key.text = kwargs.pop('static_route_next_hop')\n        next_hop_vrf = ET.SubElement(static_route_nh_vrf, \"next-hop-vrf\")\n        next_hop_vrf.text = kwargs.pop('next_hop_vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ip_rtm_config_route_static_route_nh_vrf_static_route_next_hop(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_nh_vrf = ET.SubElement(route, \"static-route-nh-vrf\")\n        static_route_next_vrf_dest_key = ET.SubElement(static_route_nh_vrf, \"static-route-next-vrf-dest\")\n        static_route_next_vrf_dest_key.text = kwargs.pop('static_route_next_vrf_dest')\n        next_hop_vrf_key = ET.SubElement(static_route_nh_vrf, \"next-hop-vrf\")\n        next_hop_vrf_key.text = kwargs.pop('next_hop_vrf')\n        static_route_next_hop = ET.SubElement(static_route_nh_vrf, \"static-route-next-hop\")\n        static_route_next_hop.text = kwargs.pop('static_route_next_hop')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set static route next hop in the RTM"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets static route next - vrf destination for a static route on an IP", "response": "def ip_rtm_config_route_static_route_oif_vrf_static_route_next_vrf_dest(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_oif_vrf = ET.SubElement(route, \"static-route-oif-vrf\")\n        next_hop_vrf_key = ET.SubElement(static_route_oif_vrf, \"next-hop-vrf\")\n        next_hop_vrf_key.text = kwargs.pop('next_hop_vrf')\n        static_route_oif_type_key = ET.SubElement(static_route_oif_vrf, \"static-route-oif-type\")\n        static_route_oif_type_key.text = kwargs.pop('static_route_oif_type')\n        static_route_oif_name_key = ET.SubElement(static_route_oif_vrf, \"static-route-oif-name\")\n        static_route_oif_name_key.text = kwargs.pop('static_route_oif_name')\n        static_route_next_vrf_dest = ET.SubElement(static_route_oif_vrf, \"static-route-next-vrf-dest\")\n        static_route_next_vrf_dest.text = kwargs.pop('static_route_next_vrf_dest')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ip_rtm_config_route_static_route_oif_vrf_next_hop_vrf(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_oif_vrf = ET.SubElement(route, \"static-route-oif-vrf\")\n        static_route_next_vrf_dest_key = ET.SubElement(static_route_oif_vrf, \"static-route-next-vrf-dest\")\n        static_route_next_vrf_dest_key.text = kwargs.pop('static_route_next_vrf_dest')\n        static_route_oif_type_key = ET.SubElement(static_route_oif_vrf, \"static-route-oif-type\")\n        static_route_oif_type_key.text = kwargs.pop('static_route_oif_type')\n        static_route_oif_name_key = ET.SubElement(static_route_oif_vrf, \"static-route-oif-name\")\n        static_route_oif_name_key.text = kwargs.pop('static_route_oif_name')\n        next_hop_vrf = ET.SubElement(static_route_oif_vrf, \"next-hop-vrf\")\n        next_hop_vrf.text = kwargs.pop('next_hop_vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the IP RTM route and configure static route on hop VRF"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ip_rtm_config_route_static_route_oif_vrf_static_route_oif_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_oif_vrf = ET.SubElement(route, \"static-route-oif-vrf\")\n        static_route_next_vrf_dest_key = ET.SubElement(static_route_oif_vrf, \"static-route-next-vrf-dest\")\n        static_route_next_vrf_dest_key.text = kwargs.pop('static_route_next_vrf_dest')\n        next_hop_vrf_key = ET.SubElement(static_route_oif_vrf, \"next-hop-vrf\")\n        next_hop_vrf_key.text = kwargs.pop('next_hop_vrf')\n        static_route_oif_name_key = ET.SubElement(static_route_oif_vrf, \"static-route-oif-name\")\n        static_route_oif_name_key.text = kwargs.pop('static_route_oif_name')\n        static_route_oif_type = ET.SubElement(static_route_oif_vrf, \"static-route-oif-type\")\n        static_route_oif_type.text = kwargs.pop('static_route_oif_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the IP RTM route and configure static route on ifvrf"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting static route on an IP route", "response": "def ip_rtm_config_route_static_route_oif_vrf_static_route_oif_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_oif_vrf = ET.SubElement(route, \"static-route-oif-vrf\")\n        static_route_next_vrf_dest_key = ET.SubElement(static_route_oif_vrf, \"static-route-next-vrf-dest\")\n        static_route_next_vrf_dest_key.text = kwargs.pop('static_route_next_vrf_dest')\n        next_hop_vrf_key = ET.SubElement(static_route_oif_vrf, \"next-hop-vrf\")\n        next_hop_vrf_key.text = kwargs.pop('next_hop_vrf')\n        static_route_oif_type_key = ET.SubElement(static_route_oif_vrf, \"static-route-oif-type\")\n        static_route_oif_type_key.text = kwargs.pop('static_route_oif_type')\n        static_route_oif_name = ET.SubElement(static_route_oif_vrf, \"static-route-oif-name\")\n        static_route_oif_name.text = kwargs.pop('static_route_oif_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the IP RTM route and set static route destination", "response": "def ip_rtm_config_route_static_route_oif_static_route_dest(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_oif = ET.SubElement(route, \"static-route-oif\")\n        static_route_oif_type_key = ET.SubElement(static_route_oif, \"static-route-oif-type\")\n        static_route_oif_type_key.text = kwargs.pop('static_route_oif_type')\n        static_route_oif_name_key = ET.SubElement(static_route_oif, \"static-route-oif-name\")\n        static_route_oif_name_key.text = kwargs.pop('static_route_oif_name')\n        static_route_dest = ET.SubElement(static_route_oif, \"static-route-dest\")\n        static_route_dest.text = kwargs.pop('static_route_dest')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the IP RTM route and set static route on if type", "response": "def ip_rtm_config_route_static_route_oif_static_route_oif_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_oif = ET.SubElement(route, \"static-route-oif\")\n        static_route_dest_key = ET.SubElement(static_route_oif, \"static-route-dest\")\n        static_route_dest_key.text = kwargs.pop('static_route_dest')\n        static_route_oif_name_key = ET.SubElement(static_route_oif, \"static-route-oif-name\")\n        static_route_oif_name_key.text = kwargs.pop('static_route_oif_name')\n        static_route_oif_type = ET.SubElement(static_route_oif, \"static-route-oif-type\")\n        static_route_oif_type.text = kwargs.pop('static_route_oif_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ip_rtm_config_route_static_route_oif_static_route_oif_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_oif = ET.SubElement(route, \"static-route-oif\")\n        static_route_dest_key = ET.SubElement(static_route_oif, \"static-route-dest\")\n        static_route_dest_key.text = kwargs.pop('static_route_dest')\n        static_route_oif_type_key = ET.SubElement(static_route_oif, \"static-route-oif-type\")\n        static_route_oif_type_key.text = kwargs.pop('static_route_oif_type')\n        static_route_oif_name = ET.SubElement(static_route_oif, \"static-route-oif-name\")\n        static_route_oif_name.text = kwargs.pop('static_route_oif_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set static route on the routing table"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the IP RTM route and static route attributes tag.", "response": "def ip_rtm_config_route_static_route_oif_route_attributes_tag(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static_route_oif = ET.SubElement(route, \"static-route-oif\")\n        static_route_dest_key = ET.SubElement(static_route_oif, \"static-route-dest\")\n        static_route_dest_key.text = kwargs.pop('static_route_dest')\n        static_route_oif_type_key = ET.SubElement(static_route_oif, \"static-route-oif-type\")\n        static_route_oif_type_key.text = kwargs.pop('static_route_oif_type')\n        static_route_oif_name_key = ET.SubElement(static_route_oif, \"static-route-oif-name\")\n        static_route_oif_name_key.text = kwargs.pop('static_route_oif_name')\n        route_attributes = ET.SubElement(static_route_oif, \"route-attributes\")\n        tag = ET.SubElement(route_attributes, \"tag\")\n        tag.text = kwargs.pop('tag')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset route static bfd route to destination", "response": "def ip_rtm_config_route_static_bfd_bfd_static_route_bfd_static_route_dest(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static = ET.SubElement(route, \"static\")\n        bfd = ET.SubElement(static, \"bfd\")\n        bfd_static_route = ET.SubElement(bfd, \"bfd-static-route\")\n        bfd_static_route_src_key = ET.SubElement(bfd_static_route, \"bfd-static-route-src\")\n        bfd_static_route_src_key.text = kwargs.pop('bfd_static_route_src')\n        bfd_static_route_dest = ET.SubElement(bfd_static_route, \"bfd-static-route-dest\")\n        bfd_static_route_dest.text = kwargs.pop('bfd_static_route_dest')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ip_rtm_config_route_static_bfd_bfd_static_route_bfd_static_route_src(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static = ET.SubElement(route, \"static\")\n        bfd = ET.SubElement(static, \"bfd\")\n        bfd_static_route = ET.SubElement(bfd, \"bfd-static-route\")\n        bfd_static_route_dest_key = ET.SubElement(bfd_static_route, \"bfd-static-route-dest\")\n        bfd_static_route_dest_key.text = kwargs.pop('bfd_static_route_dest')\n        bfd_static_route_src = ET.SubElement(bfd_static_route, \"bfd-static-route-src\")\n        bfd_static_route_src.text = kwargs.pop('bfd_static_route_src')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set route and bfd static route for a specific class"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the RTM route and route static bfd and bfd - interval - attributes - interval", "response": "def ip_rtm_config_route_static_bfd_bfd_static_route_bfd_interval_attributes_interval(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip = ET.SubElement(config, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        rtm_config = ET.SubElement(ip, \"rtm-config\", xmlns=\"urn:brocade.com:mgmt:brocade-rtm\")\n        route = ET.SubElement(rtm_config, \"route\")\n        static = ET.SubElement(route, \"static\")\n        bfd = ET.SubElement(static, \"bfd\")\n        bfd_static_route = ET.SubElement(bfd, \"bfd-static-route\")\n        bfd_static_route_dest_key = ET.SubElement(bfd_static_route, \"bfd-static-route-dest\")\n        bfd_static_route_dest_key.text = kwargs.pop('bfd_static_route_dest')\n        bfd_static_route_src_key = ET.SubElement(bfd_static_route, \"bfd-static-route-src\")\n        bfd_static_route_src_key.text = kwargs.pop('bfd_static_route_src')\n        bfd_interval_attributes = ET.SubElement(bfd_static_route, \"bfd-interval-attributes\")\n        interval = ET.SubElement(bfd_interval_attributes, \"interval\")\n        interval.text = kwargs.pop('interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the related cache entry", "response": "def ipv6_ipv6route_route_dest(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ipv6 = ET.SubElement(config, \"ipv6\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        ipv6route = ET.SubElement(ipv6, \"ipv6route\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-forward\")\n        route = ET.SubElement(ipv6route, \"route\")\n        dest = ET.SubElement(route, \"dest\")\n        dest.text = kwargs.pop('dest')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the related object from the ipv6 route next ipv6 hop next hop.", "response": "def ipv6_ipv6route_route_next_ipv6_hop_next_hop(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ipv6 = ET.SubElement(config, \"ipv6\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        ipv6route = ET.SubElement(ipv6, \"ipv6route\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-forward\")\n        route = ET.SubElement(ipv6route, \"route\")\n        dest_key = ET.SubElement(route, \"dest\")\n        dest_key.text = kwargs.pop('dest')\n        next = ET.SubElement(route, \"next\")\n        ipv6_hop = ET.SubElement(next, \"ipv6-hop\")\n        next_hop = ET.SubElement(ipv6_hop, \"next-hop\")\n        next_hop.text = kwargs.pop('next_hop')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the name of the hide - prefix - holder element.", "response": "def ipv6_hide_prefix_holder_prefix_list_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ipv6 = ET.SubElement(config, \"ipv6\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_prefix_holder = ET.SubElement(ipv6, \"hide-prefix-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        prefix_list = ET.SubElement(hide_prefix_holder, \"prefix-list\")\n        seq_keyword_key = ET.SubElement(prefix_list, \"seq-keyword\")\n        seq_keyword_key.text = kwargs.pop('seq_keyword')\n        instance_key = ET.SubElement(prefix_list, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        name = ET.SubElement(prefix_list, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ipv6_hide_prefix_holder_prefix_list_seq_keyword(self, **kwargs):\n        config = ET.Element(\"config\")\n        ipv6 = ET.SubElement(config, \"ipv6\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_prefix_holder = ET.SubElement(ipv6, \"hide-prefix-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        prefix_list = ET.SubElement(hide_prefix_holder, \"prefix-list\")\n        name_key = ET.SubElement(prefix_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        instance_key = ET.SubElement(prefix_list, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        seq_keyword = ET.SubElement(prefix_list, \"seq-keyword\")\n        seq_keyword.text = kwargs.pop('seq_keyword')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config element for the ipv6 hide prefix holder"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the config from ipv6 hide prefix holder", "response": "def ipv6_hide_prefix_holder_prefix_list_instance(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ipv6 = ET.SubElement(config, \"ipv6\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_prefix_holder = ET.SubElement(ipv6, \"hide-prefix-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        prefix_list = ET.SubElement(hide_prefix_holder, \"prefix-list\")\n        name_key = ET.SubElement(prefix_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        seq_keyword_key = ET.SubElement(prefix_list, \"seq-keyword\")\n        seq_keyword_key.text = kwargs.pop('seq_keyword')\n        instance = ET.SubElement(prefix_list, \"instance\")\n        instance.text = kwargs.pop('instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the config from ipv6 hide prefix holder prefix list action - ipp", "response": "def ipv6_hide_prefix_holder_prefix_list_action_ipp(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ipv6 = ET.SubElement(config, \"ipv6\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        hide_prefix_holder = ET.SubElement(ipv6, \"hide-prefix-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        prefix_list = ET.SubElement(hide_prefix_holder, \"prefix-list\")\n        name_key = ET.SubElement(prefix_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        seq_keyword_key = ET.SubElement(prefix_list, \"seq-keyword\")\n        seq_keyword_key.text = kwargs.pop('seq_keyword')\n        instance_key = ET.SubElement(prefix_list, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        action_ipp = ET.SubElement(prefix_list, \"action-ipp\")\n        action_ipp.text = kwargs.pop('action_ipp')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets configuration of a resource from the router", "response": "def router_fabric_virtual_gateway_address_family_ipv4_enable_global(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        router = ET.SubElement(config, \"router\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        fabric_virtual_gateway = ET.SubElement(router, \"fabric-virtual-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-anycast-gateway\")\n        address_family = ET.SubElement(fabric_virtual_gateway, \"address-family\")\n        ipv4 = ET.SubElement(address_family, \"ipv4\")\n        enable_global = ET.SubElement(ipv4, \"enable_global\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef router_fabric_virtual_gateway_address_family_ipv4_gratuitous_arp_timer(self, **kwargs):\n        config = ET.Element(\"config\")\n        router = ET.SubElement(config, \"router\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        fabric_virtual_gateway = ET.SubElement(router, \"fabric-virtual-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-anycast-gateway\")\n        address_family = ET.SubElement(fabric_virtual_gateway, \"address-family\")\n        ipv4 = ET.SubElement(address_family, \"ipv4\")\n        gratuitous_arp = ET.SubElement(ipv4, \"gratuitous-arp\")\n        timer = ET.SubElement(gratuitous_arp, \"timer\")\n        timer.text = kwargs.pop('timer')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a specific resource from the router"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the configuration of a specific resource from the router VLAN Virtual Gateway Address Family IPv4 Gateway MAC Address.", "response": "def router_fabric_virtual_gateway_address_family_ipv4_gateway_mac_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        router = ET.SubElement(config, \"router\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        fabric_virtual_gateway = ET.SubElement(router, \"fabric-virtual-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-anycast-gateway\")\n        address_family = ET.SubElement(fabric_virtual_gateway, \"address-family\")\n        ipv4 = ET.SubElement(address_family, \"ipv4\")\n        gateway_mac_address = ET.SubElement(ipv4, \"gateway-mac-address\")\n        gateway_mac_address.text = kwargs.pop('gateway_mac_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the configuration of a resource from the router", "response": "def router_fabric_virtual_gateway_address_family_ipv4_accept_unicast_arp_request(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        router = ET.SubElement(config, \"router\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        fabric_virtual_gateway = ET.SubElement(router, \"fabric-virtual-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-anycast-gateway\")\n        address_family = ET.SubElement(fabric_virtual_gateway, \"address-family\")\n        ipv4 = ET.SubElement(address_family, \"ipv4\")\n        accept_unicast_arp_request = ET.SubElement(ipv4, \"accept-unicast-arp-request\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget configuration of a resource from the router", "response": "def router_fabric_virtual_gateway_address_family_ipv6_enable_global(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        router = ET.SubElement(config, \"router\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        fabric_virtual_gateway = ET.SubElement(router, \"fabric-virtual-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-anycast-gateway\")\n        address_family = ET.SubElement(fabric_virtual_gateway, \"address-family\")\n        ipv6 = ET.SubElement(address_family, \"ipv6\")\n        enable_global = ET.SubElement(ipv6, \"enable_global\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a new resource from the router VLAN Virtual Gateway Address Family IPv6 Gateway MAC Address", "response": "def router_fabric_virtual_gateway_address_family_ipv6_gateway_mac_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        router = ET.SubElement(config, \"router\", xmlns=\"urn:brocade.com:mgmt:brocade-common-def\")\n        fabric_virtual_gateway = ET.SubElement(router, \"fabric-virtual-gateway\", xmlns=\"urn:brocade.com:mgmt:brocade-anycast-gateway\")\n        address_family = ET.SubElement(fabric_virtual_gateway, \"address-family\")\n        ipv6 = ET.SubElement(address_family, \"ipv6\")\n        gateway_mac_address = ET.SubElement(ipv6, \"gateway-mac-address\")\n        gateway_mac_address.text = kwargs.pop('gateway_mac_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap a request handler with the matching protocol handler", "response": "def wrap_handler(cls, handler, protocol, **kwargs):\n        ''' Wrap a request handler with the matching protocol handler '''\n        def _wrapper(request, *args, **kwargs):\n            instance = cls(request=request, **kwargs)\n            if protocol == Resource.Protocol.http:\n                return instance._wrap_http(handler, request=request, **kwargs)\n            elif protocol == Resource.Protocol.websocket:\n                return instance._wrap_ws(handler, request=request, **kwargs)\n            elif protocol == Resource.Protocol.amqp:\n                return instance._wrap_amqp(view_type, *args, **kwargs)\n            else:\n                raise Exception('Communication protocol not specified')\n        return _wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a function that creates a new instance of the resource class and calls the correct view method for it.", "response": "def as_view(cls, endpoint, protocol, *init_args, **init_kwargs):\n        '''\n        Used for hooking up the endpoints. Returns a wrapper function that creates\n        a new instance of the resource class and calls the correct view method for it.\n        '''\n        def _wrapper(request, *args, **kwargs):\n            ''' Make a new instance of the resource class and returns a coroutine for execution'''\n            instance = cls(*init_args, endpoint=endpoint, request=request, **init_kwargs)\n            if protocol == Resource.Protocol.http:\n                return instance._wrap_http(cls.dispatch, endpoint=endpoint, *args, **kwargs)\n            elif protocol == Resource.Protocol.websocket:\n                return instance._wrap_ws(cls.dispatch, endpoint=endpoint, *args, **kwargs)\n            elif protocol == Resource.Protocol.amqp:\n                return instance._wrap_amqp(endpoint, *args, **kwargs)\n            else:\n                raise Exception('Communication protocol not specified')\n\n        return _wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list views", "response": "def as_list(cls, protocol=Protocol.http, *args, **kwargs):\n        ''' returns list views '''\n        return cls.as_view('list', protocol, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the class as detail views", "response": "def as_detail(cls, protocol=Protocol.http, *args, **kwargs):\n        ''' returns detail views '''\n        return cls.as_view('detail', protocol, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap a handler with an HTTP request - response cycle", "response": "async def _wrap_http(self, handler, *args, **kwargs):\n        ''' wraps a handler with an HTTP request-response cycle'''\n        try:\n            method = self.request_method()\n            # support preflight requests when CORS is enabled\n            if method == 'OPTIONS':\n                return self.build_http_response(None, status=NO_CONTENT)\n            data = await handler(self, *args, **kwargs)\n            # format the response object\n            formatted = self.format(method, data)\n            status = self.responses.get(method, OK)\n            return self.build_http_response(formatted, status=status)\n        except Exception as ex:\n            return self.dispatch_error(ex)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwraps a handler by receiving a websocket request and returning a websocket response", "response": "async def _wrap_ws(self, handler, *args, **kwargs):\n        ''' wraps a handler by receiving a websocket request and returning a websocket response '''\n        try:\n            method = self.request_method()\n            # call the wrapped handler\n            data = await handler(self, *args, **kwargs)\n            status = self.responses.get(method, OK)\n            response = {\n                'type': 'response',\n                'key': getattr(self.request, 'key', None),\n                'status': status,\n                'payload': data\n            }\n        except Exception as ex:\n            response = {\n                'type': 'response',\n                'key': getattr(self.request, 'key', None),\n                'status': getattr(ex, 'status', 500),\n                'payload': getattr(ex, 'msg', 'general error')\n            }\n        # return a formatted response object\n        return self.format(method, response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def dispatch(self, *args, **kwargs):\n        '''\n        This method handles the actual request to the resource.\n        It performs all the neccesary checks and then executes the relevant member method which is mapped to the method name.\n        Handles authentication and de-serialization before calling the required method.\n        Handles the serialization of the response\n        '''\n        method = self.request_method()\n\n        # get the db object associated with the app and assign to resource\n        if hasattr(self.request.app, 'db'):\n            setattr(self, 'db', self.request.app.db)\n\n        # check if method is allowed\n        if method not in self.methods.get(self.endpoint, {}):\n            raise MethodNotImplemented(\"Unsupported method '{0}' for {1} endpoint.\".format(method, self.endpoint))\n\n        if self.is_method_allowed(self.endpoint, method) is False:\n            raise MethodNotAllowed(\"Unsupported method '{0}' for {1} endpoint.\".format(method, self.endpoint))\n\n        # check user authentication\n        if not await self._meta.authentication.is_authenticated(self.request):\n            raise Unauthorized()\n\n        # deserialize request data\n        body = await self.request_body()\n        self.data = self.parse(method, self.endpoint, body)\n        # if method != 'GET':\n            # self.data.update(kwargs)\n        kwargs.update(self.request_args())\n        view_method = getattr(self, self.methods[self.endpoint][method])\n        # call request method\n        data = await view_method(*args, **kwargs)\n        # add hypermedia to the response, if response is not empty\n        if data and self._meta.hypermedia is True:\n            if self.endpoint == 'list' and method == 'GET':\n                for item in data['objects']:\n                    self.add_hypermedia(item)\n            else:\n                self.add_hypermedia(data)\n\n        return data", "response": "This method handles the actual request to the resource and returns the response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling the dispatch of errors", "response": "def dispatch_error(self, err):\n        '''\n        Handles the dispatch of errors\n        '''\n        try:\n            data = {'error': [l for l in err.args]}\n            body = self._meta.formatter.format(data)\n        except Exception as ex:\n            data = {'error': str(err)}\n            body = self._meta.formatter.format(data)\n\n        status = getattr(err, 'status', 500)\n        return self.build_http_response(body, status=status)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(self, method, endpoint, body):\n        ''' calls parse on list or detail '''\n        if isinstance(body, dict):  # request body was already parsed\n            return body\n        if endpoint == 'list':\n            return self.parse_list(body)\n\n        return self.parse_detail(body)", "response": "calls parse on list or detail"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_hypermedia(self, obj):\n        '''\n        Adds HATEOAS links to the resource. Adds href link to self.\n        Override in subclasses to include additional functionality\n        '''\n        if hasattr(self, 'pk'):\n            obj['_links'] = {\n                'self': {\n                    'href': '{}{}/'.format(self.get_resource_uri(), obj[self.pk])\n                }\n            }", "response": "Adds HATEOAS links to the resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling format on list or detail", "response": "def format(self, method, data):\n        ''' Calls format on list or detail '''\n        if data is None:\n            if method == 'GET':\n                raise NotFound()\n            return ''\n\n        return self._meta.formatter.format(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef maps_get_all_policy_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        maps_get_all_policy = ET.Element(\"maps_get_all_policy\")\n        config = maps_get_all_policy\n        input = ET.SubElement(maps_get_all_policy, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get all policy input rbridge - id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting All Policy from the server", "response": "def maps_get_all_policy_output_policy_policyname(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_all_policy = ET.Element(\"maps_get_all_policy\")\n        config = maps_get_all_policy\n        output = ET.SubElement(maps_get_all_policy, \"output\")\n        policy = ET.SubElement(output, \"policy\")\n        policyname = ET.SubElement(policy, \"policyname\")\n        policyname.text = kwargs.pop('policyname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting rules input rbridge - id.", "response": "def maps_get_rules_input_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_rules = ET.Element(\"maps_get_rules\")\n        config = maps_get_rules\n        input = ET.SubElement(maps_get_rules, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef maps_get_rules_output_rules_rbridgeid(self, **kwargs):\n        config = ET.Element(\"config\")\n        maps_get_rules = ET.Element(\"maps_get_rules\")\n        config = maps_get_rules\n        output = ET.SubElement(maps_get_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        rbridgeid = ET.SubElement(rules, \"rbridgeid\")\n        rbridgeid.text = kwargs.pop('rbridgeid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get rules output rules rbridgeid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting Rules output rules rulename", "response": "def maps_get_rules_output_rules_rulename(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_rules = ET.Element(\"maps_get_rules\")\n        config = maps_get_rules\n        output = ET.SubElement(maps_get_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        rulename = ET.SubElement(rules, \"rulename\")\n        rulename.text = kwargs.pop('rulename')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget rules output rules groupname", "response": "def maps_get_rules_output_rules_groupname(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_rules = ET.Element(\"maps_get_rules\")\n        config = maps_get_rules\n        output = ET.SubElement(maps_get_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        groupname = ET.SubElement(rules, \"groupname\")\n        groupname.text = kwargs.pop('groupname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef maps_get_rules_output_rules_monitor(self, **kwargs):\n        config = ET.Element(\"config\")\n        maps_get_rules = ET.Element(\"maps_get_rules\")\n        config = maps_get_rules\n        output = ET.SubElement(maps_get_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        monitor = ET.SubElement(rules, \"monitor\")\n        monitor.text = kwargs.pop('monitor')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Rules Output Rules Monitor"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef maps_get_rules_output_rules_op(self, **kwargs):\n        config = ET.Element(\"config\")\n        maps_get_rules = ET.Element(\"maps_get_rules\")\n        config = maps_get_rules\n        output = ET.SubElement(maps_get_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        op = ET.SubElement(rules, \"op\")\n        op.text = kwargs.pop('op')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Rules Output Rules Operation"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets Rules output rules value", "response": "def maps_get_rules_output_rules_value(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_rules = ET.Element(\"maps_get_rules\")\n        config = maps_get_rules\n        output = ET.SubElement(maps_get_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        value = ET.SubElement(rules, \"value\")\n        value.text = kwargs.pop('value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget Rules Output Rules Action", "response": "def maps_get_rules_output_rules_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_rules = ET.Element(\"maps_get_rules\")\n        config = maps_get_rules\n        output = ET.SubElement(maps_get_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        action = ET.SubElement(rules, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets Rules Output Rules Time Base", "response": "def maps_get_rules_output_rules_timebase(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_rules = ET.Element(\"maps_get_rules\")\n        config = maps_get_rules\n        output = ET.SubElement(maps_get_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        timebase = ET.SubElement(rules, \"timebase\")\n        timebase.text = kwargs.pop('timebase')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Rules output rules policyname", "response": "def maps_get_rules_output_rules_policyname(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_rules = ET.Element(\"maps_get_rules\")\n        config = maps_get_rules\n        output = ET.SubElement(maps_get_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        policyname = ET.SubElement(rules, \"policyname\")\n        policyname.text = kwargs.pop('policyname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreload input rbridge - id.", "response": "def reload_input_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        reload = ET.Element(\"reload\")\n        config = reload\n        input = ET.SubElement(reload, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reload_input_standby(self, **kwargs):\n        config = ET.Element(\"config\")\n        reload = ET.Element(\"reload\")\n        config = reload\n        input = ET.SubElement(reload, \"input\")\n        standby = ET.SubElement(input, \"standby\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Reload the input standby element and return the config."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting NICs Entry Input Interrupt ID", "response": "def get_nameserver_detail_input_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        input = ET.SubElement(get_nameserver_detail, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_nameserver_detail_output_show_nameserver_nameserver_portid(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid.text = kwargs.pop('nameserver_portid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NIC metadata from the detail output."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_nameserver_detail_output_show_nameserver_nameserver_portname(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_portname = ET.SubElement(show_nameserver, \"nameserver-portname\")\n        nameserver_portname.text = kwargs.pop('nameserver_portname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NIC metadata from the XML response."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_nameserver_detail_output_show_nameserver_nameserver_nodename(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_nodename = ET.SubElement(show_nameserver, \"nameserver-nodename\")\n        nameserver_nodename.text = kwargs.pop('nameserver_nodename')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NICs server nameserver name and nodename."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting NIC metadata from the XML response.", "response": "def get_nameserver_detail_output_show_nameserver_nameserver_scr(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_scr = ET.SubElement(show_nameserver, \"nameserver-scr\")\n        nameserver_scr.text = kwargs.pop('nameserver_scr')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_nameserver_detail_output_show_nameserver_nameserver_fc4s(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_fc4s = ET.SubElement(show_nameserver, \"nameserver-fc4s\")\n        nameserver_fc4s.text = kwargs.pop('nameserver_fc4s')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NIC metadata from Get NIC detail output and show NIC nameserver."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_nameserver_detail_output_show_nameserver_nameserver_portsymb(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_portsymb = ET.SubElement(show_nameserver, \"nameserver-portsymb\")\n        nameserver_portsymb.text = kwargs.pop('nameserver_portsymb')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NIC metadata from the detail output of show - nameserver."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_nameserver_detail_output_show_nameserver_nameserver_nodesymb(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_nodesymb = ET.SubElement(show_nameserver, \"nameserver-nodesymb\")\n        nameserver_nodesymb.text = kwargs.pop('nameserver_nodesymb')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NIC metadata from the detail output."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_nameserver_detail_output_show_nameserver_nameserver_fabric_portname(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_fabric_portname = ET.SubElement(show_nameserver, \"nameserver-fabric-portname\")\n        nameserver_fabric_portname.text = kwargs.pop('nameserver_fabric_portname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NIC metadata from Get NIC detail output and show NIC nameserver."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting NIC metadata from the detail output.", "response": "def get_nameserver_detail_output_show_nameserver_nameserver_permanent_portname(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_permanent_portname = ET.SubElement(show_nameserver, \"nameserver-permanent-portname\")\n        nameserver_permanent_portname.text = kwargs.pop('nameserver_permanent_portname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting NIC set detail output and show - nameserver - devicetype.", "response": "def get_nameserver_detail_output_show_nameserver_nameserver_devicetype(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_devicetype = ET.SubElement(show_nameserver, \"nameserver-devicetype\")\n        nameserver_devicetype.text = kwargs.pop('nameserver_devicetype')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget NIC metadata from the XML response.", "response": "def get_nameserver_detail_output_show_nameserver_nameserver_index(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_index = ET.SubElement(show_nameserver, \"nameserver-index\")\n        nameserver_index.text = kwargs.pop('nameserver_index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting NIC metadata from the detail output of a show - nameserver request.", "response": "def get_nameserver_detail_output_show_nameserver_nameserver_porttype(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_porttype = ET.SubElement(show_nameserver, \"nameserver-porttype\")\n        nameserver_porttype.text = kwargs.pop('nameserver_porttype')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_nameserver_detail_output_show_nameserver_nameserver_cos(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_cos = ET.SubElement(show_nameserver, \"nameserver-cos\")\n        nameserver_cos.text = kwargs.pop('nameserver_cos')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NIC metadata from the XML response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_nameserver_detail_output_show_nameserver_nameserver_sharearea(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_sharearea = ET.SubElement(show_nameserver, \"nameserver-sharearea\")\n        nameserver_sharearea.text = kwargs.pop('nameserver_sharearea')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NIC metadata from the XML response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting NICs Entry output show - nameserver - portid and nameserver - redirect", "response": "def get_nameserver_detail_output_show_nameserver_nameserver_redirect(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_redirect = ET.SubElement(show_nameserver, \"nameserver-redirect\")\n        nameserver_redirect.text = kwargs.pop('nameserver_redirect')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_nameserver_detail_output_show_nameserver_nameserver_xlatedomain(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_xlatedomain = ET.SubElement(show_nameserver, \"nameserver-xlatedomain\")\n        nameserver_xlatedomain.text = kwargs.pop('nameserver_xlatedomain')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NIC metadata from the XML response."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_nameserver_detail_output_show_nameserver_nameserver_connected_via_ag(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_connected_via_ag = ET.SubElement(show_nameserver, \"nameserver-connected-via-ag\")\n        nameserver_connected_via_ag.text = kwargs.pop('nameserver_connected_via_ag')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NIC metadata from the XML response."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets NIC metadata from the detail output.", "response": "def get_nameserver_detail_output_show_nameserver_nameserver_ag_base_device(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_ag_base_device = ET.SubElement(show_nameserver, \"nameserver-ag-base-device\")\n        nameserver_ag_base_device.text = kwargs.pop('nameserver_ag_base_device')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget NIC metadata from the detail output.", "response": "def get_nameserver_detail_output_show_nameserver_nameserver_real(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_real = ET.SubElement(show_nameserver, \"nameserver-real\")\n        nameserver_real.text = kwargs.pop('nameserver_real')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting NIC metadata from the XML response.", "response": "def get_nameserver_detail_output_show_nameserver_nameserver_cascaded(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_cascaded = ET.SubElement(show_nameserver, \"nameserver-cascaded\")\n        nameserver_cascaded.text = kwargs.pop('nameserver_cascaded')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cli(ctx, profile, region, lambda_fn, config, debug):\n    ctx.obj = CLIHandler(profile, region, lambda_fn, config, debug)", "response": "This is a cruddy command line interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(handler, item_id, decrypt):\n    data = {'operation': 'get',\n            'decrypt': decrypt,\n            'id': item_id}\n    handler.invoke(data)", "response": "Get an item from a list"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete an item from the list.", "response": "def delete(handler, item_id, id_name):\n    \"\"\"Delete an item\"\"\"\n    data = {'operation': 'delete',\n            'id': item_id,\n            'id_name': id_name}\n    handler.invoke(data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nincrementing a counter attribute atomically", "response": "def increment(handler, increment, item_id, counter_name):\n    \"\"\"Increment a counter attribute atomically\"\"\"\n    data = {'operation': 'increment_counter',\n            'id': item_id,\n            'counter_name': counter_name,\n            'increment': increment}\n    handler.invoke(data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(handler, item_document):\n    data = {'operation': 'create',\n            'item': json.load(item_document)}\n    handler.invoke(data)", "response": "Create a new item from a JSON document"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(handler, item_document):\n    data = {'operation': 'update',\n            'encrypt': encrypt,\n            'item': json.load(item_document)}\n    handler.invoke(data)", "response": "Update an item from a JSON document"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a Markdown document that describes this handler and ridge it s operations.", "response": "def help(handler):\n    \"\"\"\n    Returns a Markdown document that describes this handler and\n    it's operations.\n    \"\"\"\n    data = {'operation': 'describe'}\n    response = handler.invoke(data, raw=True)\n    description = response.data\n    lines = []\n    lines.append('# {}'.format(handler.lambda_fn))\n    lines.append('## Handler Info')\n    lines.append('**Cruddy version**: {}'.format(\n        description['cruddy_version']))\n    lines.append('')\n    lines.append('**Table name**: {}'.format(description['table_name']))\n    lines.append('')\n    lines.append('**Supported operations**:')\n    lines.append('')\n    for op in description['supported_operations']:\n        lines.append('* {}'.format(op))\n    lines.append('')\n    lines.append('**Prototype**:')\n    lines.append('')\n    lines.append('```')\n    lines.append(str(description['prototype']))\n    lines.append('```')\n    lines.append('')\n    lines.append('## Operations')\n    for op_name in description['operations']:\n        op = description['operations'][op_name]\n        lines.append('### {}'.format(op_name))\n        lines.append('')\n        lines.append(_build_signature_line(\n            op_name, description['operations'][op_name]['argspec']))\n        lines.append('')\n        if op['docs'] is None:\n            lines.append('')\n        else:\n            lines.append(op['docs'])\n        lines.append('')\n    click.echo('\\n'.join(lines))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _check_required(self, value):\n        '''\n        Internal method to check if assigned value is None while it is required.\n        Exception is thrown if ``True``\n        '''\n        if value is None and self._required:\n            err_msg = self._errors['required'].format(self.__class__.__name__, self.name)\n            if self.container_model:\n                err_msg += self._errors['required_extra'].format(self.container_model.__name__)\n            raise ValueError(err_msg)", "response": "Internal method to check if assigned value is None while it is required."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_data(self, value):\n        '''\n        Coerce python data type to simple form for serialization.\n        If default value was defined returns the default value if None was passed.\n        Throw exception is value is ``None`` is ``required`` is set to ``True``\n        '''\n        try:\n            if value is None and self._default is not None:\n                return self._export(self.default)\n            self._check_required(value)\n            value = self._export(value)\n            return value\n        except ValueError as ex:\n            raise ValueError(ex, self._errors['to_data'])", "response": "Coerce python data type to simple form for serialization."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncoercing data from primitive form to native Python types.", "response": "def to_python(self, value):\n        '''\n        Coerce data from primitive form to native Python types.\n        Returns the default type (if exists)\n        '''\n        try:\n            if value is None and self._default is not None:\n                return self.default\n            self._check_required(value)\n            if not isinstance(value, self._python_type):\n                value = self._import(value)\n            return value\n        except ValueError as ex:\n            raise ValueError(ex, self._errors['to_python'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nserializing the value into a Python object.", "response": "async def serialize(self, value, native=False):\n        '''\n        Calls the field's ``to_python`` method.\n        Override in derived classes of fields which involve models, such as ``ModelField``\n        '''\n        if native:\n            return self.to_python(value)\n        return self.to_data(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhooking that replaces the Field attribute on a class with a FieldDescriptor.", "response": "def add_to_class(self, cls, name):\n        '''\n        Hook that replaces the `Field` attribute on a class with a named\n        ``FieldDescriptor``. Called by the metaclass during construction of the\n        ``Model``.\n        '''\n        self._name = name\n        self._container_model_class = cls\n        setattr(cls, name, FieldDescriptor(self))\n        self._bound = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the name of the ACL for the current resource.", "response": "def arp_access_list_acl_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        arp = ET.SubElement(config, \"arp\", xmlns=\"urn:brocade.com:mgmt:brocade-dai\")\n        access_list = ET.SubElement(arp, \"access-list\")\n        acl_name = ET.SubElement(access_list, \"acl-name\")\n        acl_name.text = kwargs.pop('acl_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef arp_access_list_permit_permit_list_ip_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        arp = ET.SubElement(config, \"arp\", xmlns=\"urn:brocade.com:mgmt:brocade-dai\")\n        access_list = ET.SubElement(arp, \"access-list\")\n        acl_name_key = ET.SubElement(access_list, \"acl-name\")\n        acl_name_key.text = kwargs.pop('acl_name')\n        permit = ET.SubElement(access_list, \"permit\")\n        permit_list = ET.SubElement(permit, \"permit-list\")\n        host_ip_key = ET.SubElement(permit_list, \"host-ip\")\n        host_ip_key.text = kwargs.pop('host_ip')\n        mac_type_key = ET.SubElement(permit_list, \"mac-type\")\n        mac_type_key.text = kwargs.pop('mac_type')\n        host_mac_key = ET.SubElement(permit_list, \"host-mac\")\n        host_mac_key.text = kwargs.pop('host_mac')\n        ip_type = ET.SubElement(permit_list, \"ip-type\")\n        ip_type.text = kwargs.pop('ip_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new arp entry for a specific resource"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef arp_access_list_permit_permit_list_host_ip(self, **kwargs):\n        config = ET.Element(\"config\")\n        arp = ET.SubElement(config, \"arp\", xmlns=\"urn:brocade.com:mgmt:brocade-dai\")\n        access_list = ET.SubElement(arp, \"access-list\")\n        acl_name_key = ET.SubElement(access_list, \"acl-name\")\n        acl_name_key.text = kwargs.pop('acl_name')\n        permit = ET.SubElement(access_list, \"permit\")\n        permit_list = ET.SubElement(permit, \"permit-list\")\n        ip_type_key = ET.SubElement(permit_list, \"ip-type\")\n        ip_type_key.text = kwargs.pop('ip_type')\n        mac_type_key = ET.SubElement(permit_list, \"mac-type\")\n        mac_type_key.text = kwargs.pop('mac_type')\n        host_mac_key = ET.SubElement(permit_list, \"host-mac\")\n        host_mac_key.text = kwargs.pop('host_mac')\n        host_ip = ET.SubElement(permit_list, \"host-ip\")\n        host_ip.text = kwargs.pop('host_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new arp entry for a specific host ip"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef arp_access_list_permit_permit_list_mac_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        arp = ET.SubElement(config, \"arp\", xmlns=\"urn:brocade.com:mgmt:brocade-dai\")\n        access_list = ET.SubElement(arp, \"access-list\")\n        acl_name_key = ET.SubElement(access_list, \"acl-name\")\n        acl_name_key.text = kwargs.pop('acl_name')\n        permit = ET.SubElement(access_list, \"permit\")\n        permit_list = ET.SubElement(permit, \"permit-list\")\n        ip_type_key = ET.SubElement(permit_list, \"ip-type\")\n        ip_type_key.text = kwargs.pop('ip_type')\n        host_ip_key = ET.SubElement(permit_list, \"host-ip\")\n        host_ip_key.text = kwargs.pop('host_ip')\n        host_mac_key = ET.SubElement(permit_list, \"host-mac\")\n        host_mac_key.text = kwargs.pop('host_mac')\n        mac_type = ET.SubElement(permit_list, \"mac-type\")\n        mac_type.text = kwargs.pop('mac_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new arp entry"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the information of a specific resource from the ARP access list and permit the host MAC.", "response": "def arp_access_list_permit_permit_list_host_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        arp = ET.SubElement(config, \"arp\", xmlns=\"urn:brocade.com:mgmt:brocade-dai\")\n        access_list = ET.SubElement(arp, \"access-list\")\n        acl_name_key = ET.SubElement(access_list, \"acl-name\")\n        acl_name_key.text = kwargs.pop('acl_name')\n        permit = ET.SubElement(access_list, \"permit\")\n        permit_list = ET.SubElement(permit, \"permit-list\")\n        ip_type_key = ET.SubElement(permit_list, \"ip-type\")\n        ip_type_key.text = kwargs.pop('ip_type')\n        host_ip_key = ET.SubElement(permit_list, \"host-ip\")\n        host_ip_key.text = kwargs.pop('host_ip')\n        mac_type_key = ET.SubElement(permit_list, \"mac-type\")\n        mac_type_key.text = kwargs.pop('mac_type')\n        host_mac = ET.SubElement(permit_list, \"host-mac\")\n        host_mac.text = kwargs.pop('host_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload a cache entry from the ARP access list and log", "response": "def arp_access_list_permit_permit_list_log(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        arp = ET.SubElement(config, \"arp\", xmlns=\"urn:brocade.com:mgmt:brocade-dai\")\n        access_list = ET.SubElement(arp, \"access-list\")\n        acl_name_key = ET.SubElement(access_list, \"acl-name\")\n        acl_name_key.text = kwargs.pop('acl_name')\n        permit = ET.SubElement(access_list, \"permit\")\n        permit_list = ET.SubElement(permit, \"permit-list\")\n        ip_type_key = ET.SubElement(permit_list, \"ip-type\")\n        ip_type_key.text = kwargs.pop('ip_type')\n        host_ip_key = ET.SubElement(permit_list, \"host-ip\")\n        host_ip_key.text = kwargs.pop('host_ip')\n        mac_type_key = ET.SubElement(permit_list, \"mac-type\")\n        mac_type_key.text = kwargs.pop('mac_type')\n        host_mac_key = ET.SubElement(permit_list, \"host-mac\")\n        host_mac_key.text = kwargs.pop('host_mac')\n        log = ET.SubElement(permit_list, \"log\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the configuration of a Telnet SA server and shutdown", "response": "def telnet_sa_telnet_server_shutdown(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        telnet_sa = ET.SubElement(config, \"telnet-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        telnet = ET.SubElement(telnet_sa, \"telnet\")\n        server = ET.SubElement(telnet, \"server\")\n        shutdown = ET.SubElement(server, \"shutdown\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef telnet_sa_telnet_server_standby_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        telnet_sa = ET.SubElement(config, \"telnet-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        telnet = ET.SubElement(telnet_sa, \"telnet\")\n        server = ET.SubElement(telnet, \"server\")\n        standby = ET.SubElement(server, \"standby\")\n        enable = ET.SubElement(standby, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Telephone Security Store server and standby enable status"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a new config element for the cache entry", "response": "def telnet_sa_telnet_server_telnet_vrf_cont_use_vrf_use_vrf_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        telnet_sa = ET.SubElement(config, \"telnet-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        telnet = ET.SubElement(telnet_sa, \"telnet\")\n        server = ET.SubElement(telnet, \"server\")\n        telnet_vrf_cont = ET.SubElement(server, \"telnet-vrf-cont\")\n        use_vrf = ET.SubElement(telnet_vrf_cont, \"use-vrf\")\n        use_vrf_name = ET.SubElement(use_vrf, \"use-vrf-name\")\n        use_vrf_name.text = kwargs.pop('use_vrf_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the configuration of a Telepath Security Store resource.", "response": "def telnet_sa_telnet_server_telnet_vrf_cont_use_vrf_telnet_vrf_shutdown(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        telnet_sa = ET.SubElement(config, \"telnet-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        telnet = ET.SubElement(telnet_sa, \"telnet\")\n        server = ET.SubElement(telnet, \"server\")\n        telnet_vrf_cont = ET.SubElement(server, \"telnet-vrf-cont\")\n        use_vrf = ET.SubElement(telnet_vrf_cont, \"use-vrf\")\n        use_vrf_name_key = ET.SubElement(use_vrf, \"use-vrf-name\")\n        use_vrf_name_key.text = kwargs.pop('use_vrf_name')\n        telnet_vrf_shutdown = ET.SubElement(use_vrf, \"telnet-vrf-shutdown\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ssh_sa_ssh_server_key_exchange(self, **kwargs):\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        server = ET.SubElement(ssh, \"server\")\n        key_exchange = ET.SubElement(server, \"key-exchange\")\n        key_exchange.text = kwargs.pop('key_exchange')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the available SSH server key exchange"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the configuration of the available SSH server and rekey interval", "response": "def ssh_sa_ssh_server_rekey_interval(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        server = ET.SubElement(ssh, \"server\")\n        rekey_interval = ET.SubElement(server, \"rekey-interval\")\n        rekey_interval.text = kwargs.pop('rekey_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ssh_sa_ssh_server_cipher(self, **kwargs):\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        server = ET.SubElement(ssh, \"server\")\n        cipher = ET.SubElement(server, \"cipher\")\n        cipher.text = kwargs.pop('cipher')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the SSH SA server and cipher"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ssh_sa_ssh_server_mac(self, **kwargs):\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        server = ET.SubElement(ssh, \"server\")\n        mac = ET.SubElement(server, \"mac\")\n        mac.text = kwargs.pop('mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the available SSH server MAC"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ssh_sa_ssh_server_standby_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        server = ET.SubElement(ssh, \"server\")\n        standby = ET.SubElement(server, \"standby\")\n        enable = ET.SubElement(standby, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        creates a new SSH server and standby element and sets the enable flag to True."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the configuration of the available SSH server key and RSA key", "response": "def ssh_sa_ssh_server_key_rsa(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        server = ET.SubElement(ssh, \"server\")\n        key = ET.SubElement(server, \"key\")\n        rsa = ET.SubElement(key, \"rsa\")\n        rsa.text = kwargs.pop('rsa')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the configuration of the available SSH server key and ECDSA key", "response": "def ssh_sa_ssh_server_key_ecdsa(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        server = ET.SubElement(ssh, \"server\")\n        key = ET.SubElement(server, \"key\")\n        ecdsa = ET.SubElement(key, \"ecdsa\")\n        ecdsa.text = kwargs.pop('ecdsa')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ssh_sa_ssh_server_key_dsa(self, **kwargs):\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        server = ET.SubElement(ssh, \"server\")\n        key = ET.SubElement(server, \"key\")\n        dsa = ET.SubElement(key, \"dsa\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the object from SSH SA server key and DSA"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ssh_sa_ssh_server_ssh_vrf_cont_use_vrf_use_vrf_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        server = ET.SubElement(ssh, \"server\")\n        ssh_vrf_cont = ET.SubElement(server, \"ssh-vrf-cont\")\n        use_vrf = ET.SubElement(ssh_vrf_cont, \"use-vrf\")\n        use_vrf_name = ET.SubElement(use_vrf, \"use-vrf-name\")\n        use_vrf_name.text = kwargs.pop('use_vrf_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the cluster SSH server"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize an SSH SA server and SSH VRF Cont using VRF shutdown.", "response": "def ssh_sa_ssh_server_ssh_vrf_cont_use_vrf_ssh_vrf_shutdown(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        server = ET.SubElement(ssh, \"server\")\n        ssh_vrf_cont = ET.SubElement(server, \"ssh-vrf-cont\")\n        use_vrf = ET.SubElement(ssh_vrf_cont, \"use-vrf\")\n        use_vrf_name_key = ET.SubElement(use_vrf, \"use-vrf-name\")\n        use_vrf_name_key.text = kwargs.pop('use_vrf_name')\n        ssh_vrf_shutdown = ET.SubElement(use_vrf, \"ssh-vrf-shutdown\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting SSH client Cipher", "response": "def ssh_sa_ssh_client_cipher(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        client = ET.SubElement(ssh, \"client\")\n        cipher = ET.SubElement(client, \"cipher\")\n        cipher.text = kwargs.pop('cipher')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the current SSH client MAC address", "response": "def ssh_sa_ssh_client_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        client = ET.SubElement(ssh, \"client\")\n        mac = ET.SubElement(client, \"mac\")\n        mac.text = kwargs.pop('mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget SSH client key exchange", "response": "def ssh_sa_ssh_client_key_exchange(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ssh_sa = ET.SubElement(config, \"ssh-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-sec-services\")\n        ssh = ET.SubElement(ssh_sa, \"ssh\")\n        client = ET.SubElement(ssh, \"client\")\n        key_exchange = ET.SubElement(client, \"key-exchange\")\n        key_exchange.text = kwargs.pop('key_exchange')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nswap the byte - ordering in a packet with N = 4 bytes per word.", "response": "def byteswap(data, word_size=4):\n    \"\"\" Swap the byte-ordering in a packet with N=4 bytes per word\n    \"\"\"\n    return reduce(lambda x,y: x+''.join(reversed(y)), chunks(data, word_size), '')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse(self, data, mimetype):\n        encoding = mimetype.params.get('charset') or 'utf-8'\n\n        return json.loads(data.decode(encoding))", "response": "Parses a byte array containing a JSON document and returns a Python object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef vcs_nodes(self):\n        urn = \"{urn:brocade.com:mgmt:brocade-vcs}\"\n        namespace = 'urn:brocade.com:mgmt:brocade-vcs'\n        show_vcs = ET.Element('show-vcs', xmlns=namespace)\n        results = self._callback(show_vcs, handler='get')\n        result = []\n        for nodes in results.findall('%svcs-nodes' % urn):\n            for item in nodes.findall('%svcs-node-info' % urn):\n                serial_number = item.find('%snode-serial-num' % urn).text\n                node_status = item.find('%snode-status' % urn).text\n                vcs_id = item.find('%snode-vcs-id' % urn).text\n                rbridge_id = item.find('%snode-rbridge-id' % urn).text\n                switch_mac = item.find('%snode-switch-mac' % urn).text\n                switch_wwn = item.find('%snode-switch-wwn' % urn).text\n                switch_name = item.find('%snode-switchname' % urn).text\n                node_is_principal = item.find('%snode-is-principal' % urn).text\n                switch_ip = ''\n                for switch_ip_addr in item.findall(\n                        '%snode-public-ip-addresses' % urn):\n                    switch_ip = switch_ip_addr.find(\n                        '%snode-public-ip-address' % urn).text\n                    break\n                item_results = {'node-serial-num': serial_number,\n                                'node-status': node_status,\n                                'node-vcs-id': vcs_id,\n                                'node-rbridge-id': rbridge_id,\n                                'node-switch-mac': switch_mac,\n                                'node-switch-wwn': switch_wwn,\n                                'node-switch-ip': switch_ip,\n                                'node-switchname': switch_name,\n                                'node-is-principal': node_is_principal}\n\n                result.append(item_results)\n\n        return result", "response": "get the list of VCS node details"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset VCS Virtual IP.", "response": "def vcs_vip(self, **kwargs):\n        \"\"\"Set VCS Virtual IP.\n\n        Args:\n            vip (str): IPv4/IPv6 Virtual IP Address.\n            rbridge_id (str): rbridge-id for device. Only required when type is\n                `ve`.\n            delete (bool): Deletes the virtual ip if `delete` is ``True``.\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n        Raises:\n            KeyError: if `vip` is not passed.\n            ValueError: if `vip` is invalid.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         dev.interface.vcs_vip(vip='10.1.1.1/24')\n            ...         dev.interface.vcs_vip(vip='fe80::cafe:beef:1000:1/64')\n            ...         dev.interface.vcs_vip(vip='10.1.1.1/24',get=True)\n            ...         dev.interface.vcs_vip(vip='fe80::cafe:beef:1000:1/64',\n            ...                               get=True)\n            ...         dev.interface.vcs_vip(vip='fe80::cafe:beef:1000:1/64',\n            ...                               delete=True)\n            ...         dev.interface.vcs_vip(vip='10.1.1.1/24',get=True)\n            ...         dev.interface.vcs_vip(vip='fe80::cafe:beef:1000:1/64',\n            ...                               get=True)\n            ...         dev.interface.vcs_vip(vip='10.1.1.1/24',delete=True)\n            ...         dev.interface.vcs_vip(vip='fe80::cafe:beef:1000:1/64',\n            ...                               delete=True)\n        \"\"\"\n\n        get_config = kwargs.pop('get', False)\n        delete = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        method_class = self._vcs\n\n        if not get_config:\n            vip = str(kwargs.pop('vip'))\n            ipaddress = ip_interface(unicode(vip))\n            vcs_vip = None\n\n            if ipaddress.version == 4:\n                method_name = 'vcs_virtual_ip_address_address'\n                vcs_args = dict(address=vip)\n                vcs_vip = getattr(method_class, method_name)\n            elif ipaddress.version == 6:\n                method_name = 'vcs_virtual_ipv6_address_ipv6address'\n                vcs_args = dict(ipv6address=vip)\n                vcs_vip = getattr(method_class, method_name)\n\n            if not delete:\n                config = vcs_vip(**vcs_args)\n            else:\n                if ipaddress.version == 4:\n                    config = vcs_vip(**vcs_args)\n                    config.find('.//*address').set('operation', 'delete')\n                elif ipaddress.version == 6:\n                    config = vcs_vip(**vcs_args)\n                    config.find('.//*ipv6address').set('operation', 'delete')\n\n        elif get_config:\n            vip_info = {}\n\n            method_name = 'vcs_virtual_ip_address_address'\n            vcs_args = dict(address='')\n            vcs_vip = getattr(method_class, method_name)\n            config = vcs_vip(**vcs_args)\n            vip_info['ipv4_vip'] = callback(config, handler='get_config')\n\n            method_name = 'vcs_virtual_ipv6_address_ipv6address'\n            vcs_args = dict(ipv6address='')\n            vcs_vip = getattr(method_class, method_name)\n            config = vcs_vip(**vcs_args)\n            vip_info['ipv6_vip'] = callback(config, handler='get_config')\n            return vip_info\n\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets FCoE Interface Name in XML format.", "response": "def fcoe_get_interface_input_fcoe_intf_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        input = ET.SubElement(fcoe_get_interface, \"input\")\n        fcoe_intf_name = ET.SubElement(input, \"fcoe-intf-name\")\n        fcoe_intf_name.text = kwargs.pop('fcoe_intf_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting FCoE Interface input FCoE Interrupt Domain", "response": "def fcoe_get_interface_input_fcoe_intf_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        input = ET.SubElement(fcoe_get_interface, \"input\")\n        fcoe_intf_rbridge_id = ET.SubElement(input, \"fcoe-intf-rbridge-id\")\n        fcoe_intf_rbridge_id.text = kwargs.pop('fcoe_intf_rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget FCoE Interface input FCoE include Stats", "response": "def fcoe_get_interface_input_fcoe_intf_include_stats(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        input = ET.SubElement(fcoe_get_interface, \"input\")\n        fcoe_intf_include_stats = ET.SubElement(input, \"fcoe-intf-include-stats\")\n        fcoe_intf_include_stats.text = kwargs.pop('fcoe_intf_include_stats')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget FCoE Interface List FCoE Interface FCoE Port ID", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_fcoe_port_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting FCoE Interface List FCoE Interface Port Type", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_port_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_port_type = ET.SubElement(fcoe_intf_list, \"fcoe-intf-port-type\")\n        fcoe_intf_port_type.text = kwargs.pop('fcoe_intf_port_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget FCoE Interface List FCoE Interface Config Port Type", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_config_port_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_config_port_type = ET.SubElement(fcoe_intf_list, \"fcoe-intf-config-port-type\")\n        fcoe_intf_config_port_type.text = kwargs.pop('fcoe_intf_config_port_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets FCoE Interface List FCoE Interface State", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_port_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_port_state = ET.SubElement(fcoe_intf_list, \"fcoe-intf-port-state\")\n        fcoe_intf_port_state.text = kwargs.pop('fcoe_intf_port_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting FCoE Interface List FCoE Family Name", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_fabric_map_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_fabric_map_name = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fabric-map-name\")\n        fcoe_intf_fabric_map_name.text = kwargs.pop('fcoe_intf_fabric_map_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_eth_port_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_eth_port_id = ET.SubElement(fcoe_intf_list, \"fcoe-intf-eth-port-id\")\n        fcoe_intf_eth_port_id.text = kwargs.pop('fcoe_intf_eth_port_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Interface List FCoE Interface Ethernet Port ID"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget FCoE Interface List Interface Type", "response": "def fcoe_get_interface_output_fcoe_intf_list_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        interface_type = ET.SubElement(fcoe_intf_list, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets FCoE Interface List Interface Name", "response": "def fcoe_get_interface_output_fcoe_intf_list_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        interface_name = ET.SubElement(fcoe_intf_list, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_admin_status(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_admin_status = ET.SubElement(fcoe_intf_list, \"fcoe-intf-admin-status\")\n        fcoe_intf_admin_status.text = kwargs.pop('fcoe_intf_admin_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Interface List FCoE Admin Status"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget FCoE Interface List FCF MAC.", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_peer_fcf_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_peer_fcf_mac = ET.SubElement(fcoe_intf_list, \"fcoe-intf-peer-fcf-mac\")\n        fcoe_intf_peer_fcf_mac.text = kwargs.pop('fcoe_intf_peer_fcf_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_device_count(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_device_count = ET.SubElement(fcoe_intf_list, \"fcoe-intf-device-count\")\n        fcoe_intf_device_count.text = kwargs.pop('fcoe_intf_device_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Interface List FCoE Interface Device Count"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget FCoE Interface List FCoE Interface ifindex.", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_ifindex(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_ifindex = ET.SubElement(fcoe_intf_list, \"fcoe-intf-ifindex\")\n        fcoe_intf_ifindex.text = kwargs.pop('fcoe_intf_ifindex')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_wwn(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_wwn = ET.SubElement(fcoe_intf_list, \"fcoe-intf-wwn\")\n        fcoe_intf_wwn.text = kwargs.pop('fcoe_intf_wwn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Interface List FCoE Interface WWN"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting FCoE Interface List FCoE Node Bind Type", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_enode_bind_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_enode_bind_type = ET.SubElement(fcoe_intf_list, \"fcoe-intf-enode-bind-type\")\n        fcoe_intf_enode_bind_type.text = kwargs.pop('fcoe_intf_enode_bind_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets FCoE Interface List FCoE Interface Port Bind Type", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_port_bind_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_port_bind_type = ET.SubElement(fcoe_intf_list, \"fcoe-intf-port-bind-type\")\n        fcoe_intf_port_bind_type.text = kwargs.pop('fcoe_intf_port_bind_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets FCoE Interface output FCoE Link List FCoE Link Node MAC Address", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_enode_mac_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_enode_mac_address = ET.SubElement(fcoe_intf_list, \"fcoe-intf-enode-mac-address\")\n        fcoe_intf_enode_mac_address.text = kwargs.pop('fcoe_intf_enode_mac_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_rx_vlan_disc_req(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_rx_vlan_disc_req = ET.SubElement(fcoe_intf_list, \"fcoe-intf-rx-vlan-disc-req\")\n        fcoe_intf_rx_vlan_disc_req.text = kwargs.pop('fcoe_intf_rx_vlan_disc_req')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Interface List FCoE Interface Rx VLAN Disc Request"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting FCoE Interface List FCOE Interface Rx - Disolicitations", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_rx_disc_solicitations(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_rx_disc_solicitations = ET.SubElement(fcoe_intf_list, \"fcoe-intf-rx-disc-solicitations\")\n        fcoe_intf_rx_disc_solicitations.text = kwargs.pop('fcoe_intf_rx_disc_solicitations')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_rx_flogi(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_rx_flogi = ET.SubElement(fcoe_intf_list, \"fcoe-intf-rx-flogi\")\n        fcoe_intf_rx_flogi.text = kwargs.pop('fcoe_intf_rx_flogi')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Interface List FCOE Interface Rx Flogi"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting FCoE Interface List FCoE Interface Rx Fdiscs", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_rx_fdiscs(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_rx_fdiscs = ET.SubElement(fcoe_intf_list, \"fcoe-intf-rx-fdiscs\")\n        fcoe_intf_rx_fdiscs.text = kwargs.pop('fcoe_intf_rx_fdiscs')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget FCoE Interface List FCoE Link", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_rx_logo(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_rx_logo = ET.SubElement(fcoe_intf_list, \"fcoe-intf-rx-logo\")\n        fcoe_intf_rx_logo.text = kwargs.pop('fcoe_intf_rx_logo')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget FCoE Interface List FCoE Interface Rx Errors", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_rx_errors(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_rx_errors = ET.SubElement(fcoe_intf_list, \"fcoe-intf-rx-errors\")\n        fcoe_intf_rx_errors.text = kwargs.pop('fcoe_intf_rx_errors')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_tx_vlan_disc_resp(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_tx_vlan_disc_resp = ET.SubElement(fcoe_intf_list, \"fcoe-intf-tx-vlan-disc-resp\")\n        fcoe_intf_tx_vlan_disc_resp.text = kwargs.pop('fcoe_intf_tx_vlan_disc_resp')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Interface List FCoE Interface Tx VLAN Disc Response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting FCoE Interface List FCoE Link Out of Sonos and Sonos Son Sos Son of Sonos and Sonos and Sonos Son Sonos Son S", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_tx_disc_sol_adv(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_tx_disc_sol_adv = ET.SubElement(fcoe_intf_list, \"fcoe-intf-tx-disc-sol-adv\")\n        fcoe_intf_tx_disc_sol_adv.text = kwargs.pop('fcoe_intf_tx_disc_sol_adv')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting FCoE Interface List FCOE Interface Tx Disconnection Unsol Advival Advertisement", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_tx_disc_unsol_adv(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_tx_disc_unsol_adv = ET.SubElement(fcoe_intf_list, \"fcoe-intf-tx-disc-unsol-adv\")\n        fcoe_intf_tx_disc_unsol_adv.text = kwargs.pop('fcoe_intf_tx_disc_unsol_adv')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting FCoE Interface List FCoE Interface Rx Node Ka", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_rx_enode_ka(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_rx_enode_ka = ET.SubElement(fcoe_intf_list, \"fcoe-intf-rx-enode-ka\")\n        fcoe_intf_rx_enode_ka.text = kwargs.pop('fcoe_intf_rx_enode_ka')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_rx_vnport_ka(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_rx_vnport_ka = ET.SubElement(fcoe_intf_list, \"fcoe-intf-rx-vnport-ka\")\n        fcoe_intf_rx_vnport_ka.text = kwargs.pop('fcoe_intf_rx_vnport_ka')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Interface List FCoE Interface Rx VNU Port Ka"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets FCoE Interface List FCoE Interface Transmits", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_tx_accepts(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_tx_accepts = ET.SubElement(fcoe_intf_list, \"fcoe-intf-tx-accepts\")\n        fcoe_intf_tx_accepts.text = kwargs.pop('fcoe_intf_tx_accepts')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_tx_ls_rjt(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_tx_ls_rjt = ET.SubElement(fcoe_intf_list, \"fcoe-intf-tx-ls-rjt\")\n        fcoe_intf_tx_ls_rjt.text = kwargs.pop('fcoe_intf_tx_ls_rjt')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Interface List FCoE Interface Transmit LST and RST"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets FCoE Interface List FCoE Link Time Since Last Change", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_time_since_last_change(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_time_since_last_change = ET.SubElement(fcoe_intf_list, \"fcoe-intf-time-since-last-change\")\n        fcoe_intf_time_since_last_change.text = kwargs.pop('fcoe_intf_time_since_last_change')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget FCoE Interface List FCoE Link Last Counter Cleared", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_last_counters_cleared(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_last_counters_cleared = ET.SubElement(fcoe_intf_list, \"fcoe-intf-last-counters-cleared\")\n        fcoe_intf_last_counters_cleared.text = kwargs.pop('fcoe_intf_last_counters_cleared')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets FCoE Interface List FCoE Interface Tx CVLS", "response": "def fcoe_get_interface_output_fcoe_intf_list_fcoe_intf_tx_cvls(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_list = ET.SubElement(output, \"fcoe-intf-list\")\n        fcoe_intf_fcoe_port_id_key = ET.SubElement(fcoe_intf_list, \"fcoe-intf-fcoe-port-id\")\n        fcoe_intf_fcoe_port_id_key.text = kwargs.pop('fcoe_intf_fcoe_port_id')\n        fcoe_intf_tx_cvls = ET.SubElement(fcoe_intf_list, \"fcoe-intf-tx-cvls\")\n        fcoe_intf_tx_cvls.text = kwargs.pop('fcoe_intf_tx_cvls')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fcoe_get_interface_output_fcoe_intf_total_interfaces(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_interface = ET.Element(\"fcoe_get_interface\")\n        config = fcoe_get_interface\n        output = ET.SubElement(fcoe_get_interface, \"output\")\n        fcoe_intf_total_interfaces = ET.SubElement(output, \"fcoe-intf-total-interfaces\")\n        fcoe_intf_total_interfaces.text = kwargs.pop('fcoe_intf_total_interfaces')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Interface total Interfaces."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting FCoE Login Input", "response": "def fcoe_get_login_input_fcoe_login_interface(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        input = ET.SubElement(fcoe_get_login, \"input\")\n        fcoe_login_interface = ET.SubElement(input, \"fcoe-login-interface\")\n        fcoe_login_interface.text = kwargs.pop('fcoe_login_interface')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fcoe_get_login_input_fcoe_login_vfid(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        input = ET.SubElement(fcoe_get_login, \"input\")\n        fcoe_login_vfid = ET.SubElement(input, \"fcoe-login-vfid\")\n        fcoe_login_vfid.text = kwargs.pop('fcoe_login_vfid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Login input."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fcoe_get_login_input_fcoe_login_vlan(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        input = ET.SubElement(fcoe_get_login, \"input\")\n        fcoe_login_vlan = ET.SubElement(input, \"fcoe-login-vlan\")\n        fcoe_login_vlan.text = kwargs.pop('fcoe_login_vlan')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE login input."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget FCoE Login Information for FCoE server.", "response": "def fcoe_get_login_input_fcoe_login_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        input = ET.SubElement(fcoe_get_login, \"input\")\n        fcoe_login_rbridge_id = ET.SubElement(input, \"fcoe-login-rbridge-id\")\n        fcoe_login_rbridge_id.text = kwargs.pop('fcoe_login_rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting FCoE Login List and Session MAC.", "response": "def fcoe_get_login_output_fcoe_login_list_fcoe_login_session_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        output = ET.SubElement(fcoe_get_login, \"output\")\n        fcoe_login_list = ET.SubElement(output, \"fcoe-login-list\")\n        fcoe_login_session_mac = ET.SubElement(fcoe_login_list, \"fcoe-login-session-mac\")\n        fcoe_login_session_mac.text = kwargs.pop('fcoe_login_session_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting FCoE Login List FCoE Session MAC and FCoE Interface Name.", "response": "def fcoe_get_login_output_fcoe_login_list_fcoe_login_fcoe_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        output = ET.SubElement(fcoe_get_login, \"output\")\n        fcoe_login_list = ET.SubElement(output, \"fcoe-login-list\")\n        fcoe_login_session_mac_key = ET.SubElement(fcoe_login_list, \"fcoe-login-session-mac\")\n        fcoe_login_session_mac_key.text = kwargs.pop('fcoe_login_session_mac')\n        fcoe_login_fcoe_interface_name = ET.SubElement(fcoe_login_list, \"fcoe-login-fcoe-interface-name\")\n        fcoe_login_fcoe_interface_name.text = kwargs.pop('fcoe_login_fcoe_interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets FCoE Login List", "response": "def fcoe_get_login_output_fcoe_login_list_fcoe_login_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        output = ET.SubElement(fcoe_get_login, \"output\")\n        fcoe_login_list = ET.SubElement(output, \"fcoe-login-list\")\n        fcoe_login_session_mac_key = ET.SubElement(fcoe_login_list, \"fcoe-login-session-mac\")\n        fcoe_login_session_mac_key.text = kwargs.pop('fcoe_login_session_mac')\n        fcoe_login_interface_name = ET.SubElement(fcoe_login_list, \"fcoe-login-interface-name\")\n        fcoe_login_interface_name.text = kwargs.pop('fcoe_login_interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fcoe_get_login_output_fcoe_login_list_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        output = ET.SubElement(fcoe_get_login, \"output\")\n        fcoe_login_list = ET.SubElement(output, \"fcoe-login-list\")\n        fcoe_login_session_mac_key = ET.SubElement(fcoe_login_list, \"fcoe-login-session-mac\")\n        fcoe_login_session_mac_key.text = kwargs.pop('fcoe_login_session_mac')\n        interface_type = ET.SubElement(fcoe_login_list, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Login List Interface Type"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting FCoE Login List Interface Name", "response": "def fcoe_get_login_output_fcoe_login_list_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        output = ET.SubElement(fcoe_get_login, \"output\")\n        fcoe_login_list = ET.SubElement(output, \"fcoe-login-list\")\n        fcoe_login_session_mac_key = ET.SubElement(fcoe_login_list, \"fcoe-login-session-mac\")\n        fcoe_login_session_mac_key.text = kwargs.pop('fcoe_login_session_mac')\n        interface_name = ET.SubElement(fcoe_login_list, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets FCoE Login List FCoE Session MAC and WWN.", "response": "def fcoe_get_login_output_fcoe_login_list_fcoe_login_device_wwn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        output = ET.SubElement(fcoe_get_login, \"output\")\n        fcoe_login_list = ET.SubElement(output, \"fcoe-login-list\")\n        fcoe_login_session_mac_key = ET.SubElement(fcoe_login_list, \"fcoe-login-session-mac\")\n        fcoe_login_session_mac_key.text = kwargs.pop('fcoe_login_session_mac')\n        fcoe_login_device_wwn = ET.SubElement(fcoe_login_list, \"fcoe-login-device-wwn\")\n        fcoe_login_device_wwn.text = kwargs.pop('fcoe_login_device_wwn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fcoe_get_login_output_fcoe_login_list_fcoe_login_device_mac(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        output = ET.SubElement(fcoe_get_login, \"output\")\n        fcoe_login_list = ET.SubElement(output, \"fcoe-login-list\")\n        fcoe_login_session_mac_key = ET.SubElement(fcoe_login_list, \"fcoe-login-session-mac\")\n        fcoe_login_session_mac_key.text = kwargs.pop('fcoe_login_session_mac')\n        fcoe_login_device_mac = ET.SubElement(fcoe_login_list, \"fcoe-login-device-mac\")\n        fcoe_login_device_mac.text = kwargs.pop('fcoe_login_device_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Login List"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fcoe_get_login_output_fcoe_login_list_fcoe_login_direct_attached(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        output = ET.SubElement(fcoe_get_login, \"output\")\n        fcoe_login_list = ET.SubElement(output, \"fcoe-login-list\")\n        fcoe_login_session_mac_key = ET.SubElement(fcoe_login_list, \"fcoe-login-session-mac\")\n        fcoe_login_session_mac_key.text = kwargs.pop('fcoe_login_session_mac')\n        fcoe_login_direct_attached = ET.SubElement(fcoe_login_list, \"fcoe-login-direct-attached\")\n        fcoe_login_direct_attached.text = kwargs.pop('fcoe_login_direct_attached')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Login List FCoE Session MAC and Direct Attached"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fcoe_get_login_output_fcoe_login_list_fcoe_login_connected_peer_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        output = ET.SubElement(fcoe_get_login, \"output\")\n        fcoe_login_list = ET.SubElement(output, \"fcoe-login-list\")\n        fcoe_login_session_mac_key = ET.SubElement(fcoe_login_list, \"fcoe-login-session-mac\")\n        fcoe_login_session_mac_key.text = kwargs.pop('fcoe_login_session_mac')\n        fcoe_login_connected_peer_type = ET.SubElement(fcoe_login_list, \"fcoe-login-connected-peer-type\")\n        fcoe_login_connected_peer_type.text = kwargs.pop('fcoe_login_connected_peer_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Login List FCoE Session MAC and FCoE Connect Peer Type"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget FCoE Login Number and Total Logins.", "response": "def fcoe_get_login_output_fcoe_login_total_logins(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_get_login = ET.Element(\"fcoe_get_login\")\n        config = fcoe_get_login\n        output = ET.SubElement(fcoe_get_login, \"output\")\n        fcoe_login_total_logins = ET.SubElement(output, \"fcoe-login-total-logins\")\n        fcoe_login_total_logins.text = kwargs.pop('fcoe_login_total_logins')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef enabled(self):\n        namespace = 'urn:ietf:params:xml:ns:netconf:base:1.0'\n        bgp_filter = 'rbridge-id/router/bgp'\n        bgp_config = ET.Element('get-config', xmlns=\"%s\" % namespace)\n        source = ET.SubElement(bgp_config, 'source')\n        ET.SubElement(source, 'running')\n        ET.SubElement(bgp_config, 'filter',\n                      type=\"xpath\", select=\"%s\" % bgp_filter)\n        bgp_config = self._callback(bgp_config, handler='get')\n        namespace = 'urn:brocade.com:mgmt:brocade-bgp'\n        enabled = bgp_config.find('.//*{%s}bgp' % namespace)\n        if enabled is not None:\n            return True\n        return False", "response": "Check if BGP is enabled"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef local_asn(self, **kwargs):\n        vrf = kwargs.pop('vrf', 'default')\n        is_get_config = kwargs.pop('get', False)\n        if not is_get_config:\n            local_as = kwargs.pop('local_as')\n        else:\n            local_as = ''\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        bgp_args = dict(vrf_name=vrf, rbridge_id=rbridge_id)\n        config = self._rbridge.rbridge_id_router_bgp_vrf_name(**bgp_args)\n        if not is_get_config:\n            callback(config)\n        local_as_args = dict(vrf_name=vrf,\n                             local_as=local_as,\n                             rbridge_id=rbridge_id)\n        local_as = getattr(self._rbridge,\n                           'rbridge_id_router_bgp_router_bgp_cmds_holder_'\n                           'router_bgp_attributes_local_as')\n        config = local_as(**local_as_args)\n        if is_get_config:\n            return callback(config, handler='get_config')\n        return callback(config)", "response": "Set BGP local ASN of NOS deice."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_bgp(self, **kwargs):\n        vrf = kwargs.pop('vrf', 'default')\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        bgp_args = dict(vrf_name=vrf, rbridge_id=rbridge_id)\n        config = self._rbridge.rbridge_id_router_bgp_vrf_name(**bgp_args)\n        config.find('.//*bgp').set('operation', 'delete')\n\n        return callback(config)", "response": "Remove BGP process completely."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a BGP neighbor to the BGP configuration.", "response": "def neighbor(self, **kwargs):\n        \"\"\"Add BGP neighbor.\n\n        Args:\n            ip_addr (str): IP Address of BGP neighbor.\n            remote_as (str): Remote ASN of BGP neighbor.\n            vrf (str): The VRF for this BGP process.\n            rbridge_id (str): The rbridge ID of the device on which BGP will be\n                configured in a VCS fabric.\n            delete (bool): Deletes the neighbor if `delete` is ``True``.\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `remote_as` or `ip_addr` is not specified.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.211', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.bgp.local_asn(local_as='65535',\n            ...     rbridge_id='225')\n            ...     output = dev.bgp.neighbor(ip_addr='10.10.10.10',\n            ...     remote_as='65535', rbridge_id='225')\n            ...     output = dev.bgp.neighbor(ip_addr='10.10.10.10', get=True,\n            ...     remote_as='65535', rbridge_id='225')\n            ...     output = dev.bgp.neighbor(remote_as='65535',\n            ...     rbridge_id='225',\n            ...     ip_addr='2001:4818:f000:1ab:cafe:beef:1000:1')\n            ...     output = dev.bgp.neighbor(remote_as='65535', get=True,\n            ...     rbridge_id='225',\n            ...     ip_addr='2001:4818:f000:1ab:cafe:beef:1000:1')\n            ...     output = dev.bgp.neighbor(ip_addr='10.10.10.10',\n            ...     delete=True, rbridge_id='225')\n            ...     output = dev.bgp.neighbor(delete=True, rbridge_id='225',\n            ...     ip_addr='2001:4818:f000:1ab:cafe:beef:1000:1')\n            ...     dev.bgp.neighbor() # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError\n            KeyError\n        \"\"\"\n        ip_addr = kwargs.pop('ip_addr')\n        remote_as = kwargs.pop('remote_as', None)\n        vrf = kwargs.pop('vrf', 'default')\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        delete = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        ip_addr = ip_interface(unicode(ip_addr))\n\n        if not delete and remote_as is None:\n            raise ValueError('When configuring a neighbor, you must specify '\n                             'its remote-as.')\n\n        neighbor_args = dict(router_bgp_neighbor_address=str(ip_addr.ip),\n                             remote_as=remote_as,\n                             vrf_name=vrf,\n                             rbridge_id=rbridge_id)\n\n        if ip_addr.version == 4:\n            neighbor = getattr(self._rbridge,\n                               'rbridge_id_router_bgp_router_bgp_cmds_holder_'\n                               'router_bgp_attributes_neighbor_ips_'\n                               'neighbor_addr_remote_as')\n            ip_addr_path = './/*neighbor-addr'\n        else:\n            neighbor_args['router_bgp_neighbor_ipv6_address'] = str(ip_addr.ip)\n            neighbor = getattr(self._rbridge,\n                               'rbridge_id_router_bgp_router_bgp_cmds_holder_'\n                               'router_bgp_attributes_neighbor_ipv6s_neighbor_'\n                               'ipv6_addr_remote_as')\n            ip_addr_path = './/*neighbor-ipv6-addr'\n\n        config = neighbor(**neighbor_args)\n\n        if delete:\n            neighbor = config.find(ip_addr_path)\n            neighbor.set('operation', 'delete')\n            neighbor.remove(neighbor.find('remote-as'))\n            if ip_addr.version == 6:\n                activate_args = dict(vrf_name=vrf, rbridge_id=rbridge_id,\n                                     af_ipv6_neighbor_address=str(ip_addr.ip))\n                activate_neighbor = getattr(self._rbridge,\n                                            'rbridge_id_router_bgp_router_bgp_'\n                                            'cmds_holder_address_family_ipv6_'\n                                            'ipv6_unicast_af_ipv6_neighbor_'\n                                            'address_holder_af_ipv6_'\n                                            'neighbor_address_activate')\n                deactivate = activate_neighbor(**activate_args)\n                deactivate.find('.//*af-ipv6-neighbor-'\n                                'address').set('operation', 'delete')\n                callback(deactivate)\n        else:\n            if ip_addr.version == 6:\n                callback(config)\n                activate_args = dict(vrf_name=vrf, rbridge_id=rbridge_id,\n                                     af_ipv6_neighbor_address=str(ip_addr.ip))\n                activate_neighbor = getattr(self._rbridge,\n                                            'rbridge_id_router_bgp_router_bgp_'\n                                            'cmds_holder_address_family_ipv6_'\n                                            'ipv6_unicast_af_ipv6_neighbor_'\n                                            'address_holder_af_ipv6_'\n                                            'neighbor_address_activate')\n                config = activate_neighbor(**activate_args)\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_bgp_neighbors(self, **kwargs):\n        callback = kwargs.pop('callback', self._callback)\n\n        neighbor_args = dict(router_bgp_neighbor_address='',\n                             remote_as='',\n                             vrf_name=kwargs.pop('vrf', 'default'),\n                             rbridge_id=kwargs.pop('rbridge_id', '1'))\n\n        neighbor = getattr(self._rbridge,\n                           'rbridge_id_router_bgp_router_bgp_cmds_holder_'\n                           'router_bgp_attributes_neighbor_ips_'\n                           'neighbor_addr_remote_as')\n        config = neighbor(**neighbor_args)\n        output = callback(config, handler='get_config')\n        result = []\n        urn = \"{urn:brocade.com:mgmt:brocade-bgp}\"\n        # IPv4 BGP Neighbor Handling\n        for item in output.data.findall(\n                './/{*}neighbor-addr'):\n            neighbor_address = item.find(\n                '%srouter-bgp-neighbor-address' % urn).text\n            remote_as = item.find('%sremote-as' % urn).text\n\n            item_results = {'neighbor-address': neighbor_address,\n                            'remote-as': remote_as}\n            result.append(item_results)\n\n        # IPv6 BGP Neighbor handling\n        neighbor_args['router_bgp_neighbor_ipv6_address'] = ''\n        neighbor = getattr(self._rbridge,\n                           'rbridge_id_router_bgp_router_bgp_cmds_holder_'\n                           'router_bgp_attributes_neighbor_ipv6s_neighbor_'\n                           'ipv6_addr_remote_as')\n        config = neighbor(**neighbor_args)\n        output = callback(config, handler='get_config')\n        for item in output.data.findall(\n                './/{*}neighbor-ipv6-addr'):\n            neighbor_address = item.find(\n                '%srouter-bgp-neighbor-ipv6-address' % urn).text\n            remote_as = item.find('%sremote-as' % urn).text\n\n            item_results = {'neighbor-address': neighbor_address,\n                            'remote-as': remote_as}\n            result.append(item_results)\n\n        return result", "response": "Get BGP neighbors configured on a device."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef multihop(self, **kwargs):\n        callback = kwargs.pop('callback', self._callback)\n        ip_addr = ip_interface(unicode(kwargs.pop('neighbor')))\n        config = self._multihop_xml(neighbor=ip_addr,\n                                    count=kwargs.pop('count'),\n                                    rbridge_id=kwargs.pop('rbridge_id', '1'),\n                                    vrf=kwargs.pop('vrf', 'default'))\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        if kwargs.pop('delete', False):\n            config.find('.//*ebgp-multihop').set('operation', 'delete')\n        return callback(config)", "response": "Set BGP multihop property for a neighbor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_source(self, **kwargs):\n        callback = kwargs.pop('callback', self._callback)\n        ip_addr = ip_interface(unicode(kwargs.pop('neighbor')))\n        config = self._update_source_xml(neighbor=ip_addr,\n                                         int_type=kwargs.pop('int_type'),\n                                         int_name=kwargs.pop('int_name'),\n                                         rbridge_id=kwargs.pop('rbridge_id',\n                                                               '1'),\n                                         vrf=kwargs.pop('vrf', 'default'))\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        if kwargs.pop('delete', False):\n            config.find('.//*update-source').set('operation', 'delete')\n        return callback(config)", "response": "Set BGP update source property for a neighbor."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the name of the cee map", "response": "def cee_map_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name = ET.SubElement(cee_map, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cee_map_precedence(self, **kwargs):\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        precedence = ET.SubElement(cee_map, \"precedence\")\n        precedence.text = kwargs.pop('precedence')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a CEE - Map entry"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cee_map_priority_group_table_PGID(self, **kwargs):\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        priority_group_table = ET.SubElement(cee_map, \"priority-group-table\")\n        PGID = ET.SubElement(priority_group_table, \"PGID\")\n        PGID.text = kwargs.pop('PGID')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current CEE - Map entry from the priority group table."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cee_map_priority_group_table_weight(self, **kwargs):\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        priority_group_table = ET.SubElement(cee_map, \"priority-group-table\")\n        PGID_key = ET.SubElement(priority_group_table, \"PGID\")\n        PGID_key.text = kwargs.pop('PGID')\n        weight = ET.SubElement(priority_group_table, \"weight\")\n        weight.text = kwargs.pop('weight')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a CEE - Map priority group table weight."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cee_map_priority_group_table_pfc(self, **kwargs):\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        priority_group_table = ET.SubElement(cee_map, \"priority-group-table\")\n        PGID_key = ET.SubElement(priority_group_table, \"PGID\")\n        PGID_key.text = kwargs.pop('PGID')\n        pfc = ET.SubElement(priority_group_table, \"pfc\")\n        pfc.text = kwargs.pop('pfc')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current CEE - Map entry from priority group table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cee_map_priority_table_map_cos0_pgid(self, **kwargs):\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        priority_table = ET.SubElement(cee_map, \"priority-table\")\n        map_cos0_pgid = ET.SubElement(priority_table, \"map-cos0-pgid\")\n        map_cos0_pgid.text = kwargs.pop('map_cos0_pgid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new cee map entry based on the map cos0 PGID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cee_map_priority_table_map_cos1_pgid(self, **kwargs):\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        priority_table = ET.SubElement(cee_map, \"priority-table\")\n        map_cos1_pgid = ET.SubElement(priority_table, \"map-cos1-pgid\")\n        map_cos1_pgid.text = kwargs.pop('map_cos1_pgid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new cee map entry based on the map cos1 PGID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget CEE - Map Priority Table map cos2 PG ID", "response": "def cee_map_priority_table_map_cos2_pgid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        priority_table = ET.SubElement(cee_map, \"priority-table\")\n        map_cos2_pgid = ET.SubElement(priority_table, \"map-cos2-pgid\")\n        map_cos2_pgid.text = kwargs.pop('map_cos2_pgid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cee_map_priority_table_map_cos3_pgid(self, **kwargs):\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        priority_table = ET.SubElement(cee_map, \"priority-table\")\n        map_cos3_pgid = ET.SubElement(priority_table, \"map-cos3-pgid\")\n        map_cos3_pgid.text = kwargs.pop('map_cos3_pgid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get CEE - Map priority table map cos3 pgid"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets CEE - Map Priority Table map cos4 PG ID", "response": "def cee_map_priority_table_map_cos4_pgid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        priority_table = ET.SubElement(cee_map, \"priority-table\")\n        map_cos4_pgid = ET.SubElement(priority_table, \"map-cos4-pgid\")\n        map_cos4_pgid.text = kwargs.pop('map_cos4_pgid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cee_map_priority_table_map_cos5_pgid(self, **kwargs):\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        priority_table = ET.SubElement(cee_map, \"priority-table\")\n        map_cos5_pgid = ET.SubElement(priority_table, \"map-cos5-pgid\")\n        map_cos5_pgid.text = kwargs.pop('map_cos5_pgid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get CEE - Map priority table map cos5 pgid"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cee_map_priority_table_map_cos6_pgid(self, **kwargs):\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        priority_table = ET.SubElement(cee_map, \"priority-table\")\n        map_cos6_pgid = ET.SubElement(priority_table, \"map-cos6-pgid\")\n        map_cos6_pgid.text = kwargs.pop('map_cos6_pgid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get CEE - Map Priority Table map cos6 PG ID"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cee_map_priority_table_map_cos7_pgid(self, **kwargs):\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        priority_table = ET.SubElement(cee_map, \"priority-table\")\n        map_cos7_pgid = ET.SubElement(priority_table, \"map-cos7-pgid\")\n        map_cos7_pgid.text = kwargs.pop('map_cos7_pgid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get CEE - Map Priority Table map cos7 PG ID"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cee_map_remap_fabric_priority_fabric_remapped_priority(self, **kwargs):\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        remap = ET.SubElement(cee_map, \"remap\")\n        fabric_priority = ET.SubElement(remap, \"fabric-priority\")\n        fabric_remapped_priority = ET.SubElement(fabric_priority, \"fabric-remapped-priority\")\n        fabric_remapped_priority.text = kwargs.pop('fabric_remapped_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current CEE - Map entry from the fabric priority."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget CEE - Map Entry from Lossless Map", "response": "def cee_map_remap_lossless_priority_lossless_remapped_priority(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        cee_map = ET.SubElement(config, \"cee-map\", xmlns=\"urn:brocade.com:mgmt:brocade-cee-map\")\n        name_key = ET.SubElement(cee_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        remap = ET.SubElement(cee_map, \"remap\")\n        lossless_priority = ET.SubElement(remap, \"lossless-priority\")\n        lossless_remapped_priority = ET.SubElement(lossless_priority, \"lossless-remapped-priority\")\n        lossless_remapped_priority.text = kwargs.pop('lossless_remapped_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nencode a Python datetime. datetime object as an ECMA - 262 compliant datetime string.", "response": "def encode_datetime(o):\n    \"\"\" Encodes a Python datetime.datetime object as an ECMA-262 compliant\n    datetime string.\"\"\"\n    r = o.isoformat()\n    if o.microsecond:\n        r = r[:23] + r[26:]\n    if r.endswith('+00:00'):\n        r = r[:-6] + 'Z'\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nencoding a Python datetime. time object as an ECMA - 262 compliant time string.", "response": "def encode_time(o):\n    \"\"\" Encodes a Python datetime.time object as an ECMA-262 compliant\n    time string.\"\"\"\n    r = o.isoformat()\n    if o.microsecond:\n        r = r[:12]\n    if r.endswith('+00:00'):\n        r = r[:-6] + 'Z'\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting contained - in - ID output.", "response": "def get_contained_in_ID_output_contained_in_ID(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_contained_in_ID = ET.Element(\"get_contained_in_ID\")\n        config = get_contained_in_ID\n        output = ET.SubElement(get_contained_in_ID, \"output\")\n        contained_in_ID = ET.SubElement(output, \"contained-in-ID\")\n        contained_in_ID.text = kwargs.pop('contained_in_ID')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_color_supported():\n    \"Find out if your terminal environment supports color.\"\n    # shinx.util.console\n    if not hasattr(sys.stdout, 'isatty'):\n        return False\n\n    if not sys.stdout.isatty() and 'TERMINAL-COLOR' not in os.environ:\n        return False\n\n    if sys.platform == 'win32':  # pragma: no cover\n        try:\n            import colorama\n            colorama.init()\n            return True\n        except ImportError:\n            return False\n\n    if 'COLORTERM' in os.environ:\n        return True\n\n    term = os.environ.get('TERM', 'dumb').lower()\n    return term in ('xterm', 'linux') or 'color' in term", "response": "Find out if your terminal environment supports color."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting an RGB color to 256 ansi graphics.", "response": "def rgb2ansi(r, g, b):\n    \"\"\"\n    Convert an RGB color to 256 ansi graphics.\n    \"\"\"\n\n    # Thanks to\n    # https://github.com/tehmaze/ansi/blob/master/ansi/colour/rgb.py\n\n    grayscale = False\n    poss = True\n    step = 2.5\n\n    while poss:\n        if min(r, g, b) < step:\n            grayscale = max(r, g, b) < step\n            poss = False\n\n        step += 42.5\n\n    if grayscale:\n        return 232 + int(float(sum((r, g, b)) / 33.0))\n\n    m = ((r, 36), (g, 6), (b, 1))\n    return 16 + sum(int(6 * float(val) / 256) * mod for val, mod in m)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting hex code to ansi.", "response": "def hex2ansi(code):\n    \"\"\"\n    Convert hex code to ansi.\n    \"\"\"\n\n    if code.startswith('#'):\n        code = code[1:]\n\n    if len(code) == 3:\n        # efc -> eeffcc\n        return rgb2ansi(*map(lambda o: int(o * 2, 16), code))\n\n    if len(code) != 6:\n        raise ValueError('invalid color code')\n\n    rgb = (code[:2], code[2:4], code[4:])\n    return rgb2ansi(*map(lambda o: int(o, 16), rgb))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef colorize(text, color, background=False):\n\n    if color in _styles:\n        c = Color(text)\n        c.styles = [_styles.index(color) + 1]\n        return c\n\n    c = Color(text)\n    if background:\n        c.bgcolor = _color2ansi(color)\n    else:\n        c.fgcolor = _color2ansi(color)\n    return c", "response": "Colorize text with hex code."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nenable Fibrez Core Channel", "response": "def fcoe_fsb_fcoe_fsb_enable(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe_fsb = ET.SubElement(config, \"fcoe-fsb\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fsb_enable = ET.SubElement(fcoe_fsb, \"fcoe-fsb-enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting FCoE Fabric Map Name", "response": "def fcoe_fcoe_fabric_map_fcoe_fabric_map_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name.text = kwargs.pop('fcoe_fabric_map_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting FCoE Controller Metadata", "response": "def fcoe_fcoe_fabric_map_fcoe_fabric_map_vlan(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name_key = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name_key.text = kwargs.pop('fcoe_fabric_map_name')\n        fcoe_fabric_map_vlan = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-vlan\")\n        fcoe_fabric_map_vlan.text = kwargs.pop('fcoe_fabric_map_vlan')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting FCoE Controller Config", "response": "def fcoe_fcoe_fabric_map_fcoe_fabric_mode(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name_key = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name_key.text = kwargs.pop('fcoe_fabric_map_name')\n        fcoe_fabric_mode = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-mode\")\n        fcoe_fabric_mode.text = kwargs.pop('fcoe_fabric_mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fcoe_fcoe_fabric_map_fcoe_fabric_map_priority(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name_key = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name_key.text = kwargs.pop('fcoe_fabric_map_name')\n        fcoe_fabric_map_priority = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-priority\")\n        fcoe_fabric_map_priority.text = kwargs.pop('fcoe_fabric_map_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Controller configuration"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets FCoE Controller Map", "response": "def fcoe_fcoe_fabric_map_fcoe_fabric_map_virtual_fabric(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name_key = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name_key.text = kwargs.pop('fcoe_fabric_map_name')\n        fcoe_fabric_map_virtual_fabric = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-virtual-fabric\")\n        fcoe_fabric_map_virtual_fabric.text = kwargs.pop('fcoe_fabric_map_virtual_fabric')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget FCoE Fabric Map", "response": "def fcoe_fcoe_fabric_map_fcoe_fabric_map_fcmap(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name_key = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name_key.text = kwargs.pop('fcoe_fabric_map_name')\n        fcoe_fabric_map_fcmap = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-fcmap\")\n        fcoe_fabric_map_fcmap.text = kwargs.pop('fcoe_fabric_map_fcmap')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget FIP advertisement FIP", "response": "def fcoe_fcoe_fabric_map_fcoe_fip_advertisement_fcoe_fip_advertisement_interval(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name_key = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name_key.text = kwargs.pop('fcoe_fabric_map_name')\n        fcoe_fip_advertisement = ET.SubElement(fcoe_fabric_map, \"fcoe-fip-advertisement\")\n        fcoe_fip_advertisement_interval = ET.SubElement(fcoe_fip_advertisement, \"fcoe-fip-advertisement-interval\")\n        fcoe_fip_advertisement_interval.text = kwargs.pop('fcoe_fip_advertisement_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget Fabric Map attributes", "response": "def fcoe_fcoe_fabric_map_fcoe_fip_keep_alive_fcoe_fip_keep_alive_timeout(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name_key = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name_key.text = kwargs.pop('fcoe_fabric_map_name')\n        fcoe_fip_keep_alive = ET.SubElement(fcoe_fabric_map, \"fcoe-fip-keep-alive\")\n        fcoe_fip_keep_alive_timeout = ET.SubElement(fcoe_fip_keep_alive, \"fcoe-fip-keep-alive-timeout\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fcoe_fcoe_fabric_map_fcoe_fcf_map_fcf_map_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name_key = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name_key.text = kwargs.pop('fcoe_fabric_map_name')\n        fcoe_fcf_map = ET.SubElement(fcoe_fabric_map, \"fcoe-fcf-map\")\n        fcf_map_name = ET.SubElement(fcoe_fcf_map, \"fcf-map-name\")\n        fcf_map_name.text = kwargs.pop('fcf_map_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCF map name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fcoe_fcoe_fabric_map_fcoe_fcf_map_fcf_map_fcf_rbid(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name_key = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name_key.text = kwargs.pop('fcoe_fabric_map_name')\n        fcoe_fcf_map = ET.SubElement(fcoe_fabric_map, \"fcoe-fcf-map\")\n        fcf_map_name_key = ET.SubElement(fcoe_fcf_map, \"fcf-map-name\")\n        fcf_map_name_key.text = kwargs.pop('fcf_map_name')\n        fcf_map_fcf_rbid = ET.SubElement(fcoe_fcf_map, \"fcf-map-fcf-rbid\")\n        fcf_map_fcf_rbid.text = kwargs.pop('fcf_map_fcf_rbid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCF Map from Fabric Map"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fcoe_fcoe_fabric_map_fcoe_fcf_map_fcf_map_fif_rbid_fcf_map_fif_rbid_add(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name_key = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name_key.text = kwargs.pop('fcoe_fabric_map_name')\n        fcoe_fcf_map = ET.SubElement(fcoe_fabric_map, \"fcoe-fcf-map\")\n        fcf_map_name_key = ET.SubElement(fcoe_fcf_map, \"fcf-map-name\")\n        fcf_map_name_key.text = kwargs.pop('fcf_map_name')\n        fcf_map_fif_rbid = ET.SubElement(fcoe_fcf_map, \"fcf-map-fif-rbid\")\n        fcf_map_fif_rbid_add = ET.SubElement(fcf_map_fif_rbid, \"fcf-map-fif-rbid-add\")\n        fcf_map_fif_rbid_add.text = kwargs.pop('fcf_map_fif_rbid_add')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Add FCF - Bridging to Fabric Map"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset FCoE Controller config", "response": "def fcoe_fcoe_fabric_map_fcoe_fcport_group_config_fcport_group_rbid_fcport_group_rbid_add(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fabric_map = ET.SubElement(fcoe, \"fcoe-fabric-map\")\n        fcoe_fabric_map_name_key = ET.SubElement(fcoe_fabric_map, \"fcoe-fabric-map-name\")\n        fcoe_fabric_map_name_key.text = kwargs.pop('fcoe_fabric_map_name')\n        fcoe_fcport_group_config = ET.SubElement(fcoe_fabric_map, \"fcoe-fcport-group-config\")\n        fcport_group_rbid = ET.SubElement(fcoe_fcport_group_config, \"fcport-group-rbid\")\n        fcport_group_rbid_add = ET.SubElement(fcport_group_rbid, \"fcport-group-rbid-add\")\n        fcport_group_rbid_add.text = kwargs.pop('fcport_group_rbid_add')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fcoe_fcoe_map_fcoe_map_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_map = ET.SubElement(fcoe, \"fcoe-map\")\n        fcoe_map_name = ET.SubElement(fcoe_map, \"fcoe-map-name\")\n        fcoe_map_name.text = kwargs.pop('fcoe_map_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE map name"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets FCoE Cache Entry leaf", "response": "def fcoe_fcoe_map_fcoe_map_cee_map_fcoe_map_cee_map_leaf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_map = ET.SubElement(fcoe, \"fcoe-map\")\n        fcoe_map_name_key = ET.SubElement(fcoe_map, \"fcoe-map-name\")\n        fcoe_map_name_key.text = kwargs.pop('fcoe_map_name')\n        fcoe_map_cee_map = ET.SubElement(fcoe_map, \"fcoe-map-cee-map\")\n        fcoe_map_cee_map_leaf = ET.SubElement(fcoe_map_cee_map, \"fcoe-map-cee-map-leaf\")\n        fcoe_map_cee_map_leaf.text = kwargs.pop('fcoe_map_cee_map_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_filter(self, methods=None, endpoints=None):\n        if not methods and not endpoints:\n            raise ValueError('Filter cannot be added with no criteria.')\n\n        filter = TraceFilter(methods, endpoints)\n        self.filters.append(filter)\n        return filter", "response": "Adds a filter to the list of filters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the given rule matches with any filter added.", "response": "def match(self, rule):\n        \"\"\"\n        Checks if the given rule matches with any filter added.\n\n        :param rule: The Flask rule to be matched.\n        :return: True if there is a filter that matches.\n        \"\"\"\n        if len(self.filters) == 0:\n            return True\n\n        for filter in self.filters:\n            if filter.match(rule):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncollect the data from the given parameters and emit it.", "response": "def trace(self, request, response, error, latency):\n        \"\"\"\n        Collects the data from the given parameters and emit it.\n\n        :param request: The Flask request.\n        :param response: The Flask response.\n        :param error: The error occurred if any.\n        :param latency: The time elapsed to process the request.\n        \"\"\"\n\n        data = self.__collect_trace_data(request, response, error, latency)\n\n        self.inspector(data)\n        self.emitter(data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __collect_trace_data(self, request, response, error, latency):\n\n        data = OrderedDict()\n        data['latency'] = latency.elapsed\n        data['request_method'] = request.environ['REQUEST_METHOD']\n        data['request_url'] = request.url\n        data['request_headers'] = request.headers\n\n        body = request.get_data(as_text=True)\n        if body:\n            data['request_body'] = body\n\n        if response:\n            data['response_status'] = response.status_code\n\n        if error:\n            data['error'] = str(error)\n\n        return data", "response": "Collect the tracing data from the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite the given tracing data to Python Logging.", "response": "def __default_emit_trace(self, data):\n        \"\"\"\n        Writes the given tracing data to Python Logging.\n\n        :param data: The tracing data to be written.\n        \"\"\"\n        message = format_trace_data(data)\n        self.io.logger.info(message)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef match(self, rule):\n        if self.methods:\n            for method in self.methods:\n                if method in rule.methods:\n                    return True\n\n        if self.endpoints:\n            for endpoint in self.endpoints:\n                if endpoint == rule.endpoint:\n                    return True\n\n        return False", "response": "Checks if the given Flask rule matches with the filter."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the configuration of a L2TRACER input with source MAC.", "response": "def l2traceroute_input_src_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        input = ET.SubElement(l2traceroute, \"input\")\n        src_mac = ET.SubElement(input, \"src-mac\")\n        src_mac.text = kwargs.pop('src_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef l2traceroute_input_dest_mac(self, **kwargs):\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        input = ET.SubElement(l2traceroute, \"input\")\n        dest_mac = ET.SubElement(input, \"dest-mac\")\n        dest_mac.text = kwargs.pop('dest_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Configure L2 TRACER input and destination MAC."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef l2traceroute_input_vlan_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        input = ET.SubElement(l2traceroute, \"input\")\n        vlan_id = ET.SubElement(input, \"vlan-id\")\n        vlan_id.text = kwargs.pop('vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new l2traceroute input VLAN ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef l2traceroute_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        input = ET.SubElement(l2traceroute, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a specific l2traceroute input."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a new l2traceroute entry.", "response": "def l2traceroute_input_protocolType_IP_src_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        input = ET.SubElement(l2traceroute, \"input\")\n        protocolType = ET.SubElement(input, \"protocolType\")\n        IP = ET.SubElement(protocolType, \"IP\")\n        src_ip = ET.SubElement(IP, \"src-ip\")\n        src_ip.text = kwargs.pop('src_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a new l2traceroute with input element with protocolType IP and dest IP.", "response": "def l2traceroute_input_protocolType_IP_dest_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        input = ET.SubElement(l2traceroute, \"input\")\n        protocolType = ET.SubElement(input, \"protocolType\")\n        IP = ET.SubElement(protocolType, \"IP\")\n        dest_ip = ET.SubElement(IP, \"dest-ip\")\n        dest_ip.text = kwargs.pop('dest_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a new l2traceroute with input with the specified protocolType and IP and l4protocol.", "response": "def l2traceroute_input_protocolType_IP_l4protocol(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        input = ET.SubElement(l2traceroute, \"input\")\n        protocolType = ET.SubElement(input, \"protocolType\")\n        IP = ET.SubElement(protocolType, \"IP\")\n        l4protocol = ET.SubElement(IP, \"l4protocol\")\n        l4protocol.text = kwargs.pop('l4protocol')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef l2traceroute_input_protocolType_IP_l4_src_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        input = ET.SubElement(l2traceroute, \"input\")\n        protocolType = ET.SubElement(input, \"protocolType\")\n        IP = ET.SubElement(protocolType, \"IP\")\n        l4_src_port = ET.SubElement(IP, \"l4-src-port\")\n        l4_src_port.text = kwargs.pop('l4_src_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new l2traceroute with input with protocolType IP and l4 - src - port."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef l2traceroute_input_protocolType_IP_l4_dest_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        input = ET.SubElement(l2traceroute, \"input\")\n        protocolType = ET.SubElement(input, \"protocolType\")\n        IP = ET.SubElement(protocolType, \"IP\")\n        l4_dest_port = ET.SubElement(IP, \"l4-dest-port\")\n        l4_dest_port.text = kwargs.pop('l4_dest_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a specific L2TRACER input protocolType IP and l4 destination port."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef l2traceroute_output_session_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        output = ET.SubElement(l2traceroute, \"output\")\n        session_id = ET.SubElement(output, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the L2TRACER output session_id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the configuration of a specific l2traceroute output.", "response": "def l2traceroute_output_l2traceroutedone(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        output = ET.SubElement(l2traceroute, \"output\")\n        l2traceroutedone = ET.SubElement(output, \"l2traceroutedone\")\n        l2traceroutedone.text = kwargs.pop('l2traceroutedone')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the configuration of the L2TRACER output and reason.", "response": "def l2traceroute_output_reason(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute = ET.Element(\"l2traceroute\")\n        config = l2traceroute\n        output = ET.SubElement(l2traceroute, \"output\")\n        reason = ET.SubElement(output, \"reason\")\n        reason.text = kwargs.pop('reason')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the L2TRACER result element for a specific session_id.", "response": "def l2traceroute_result_input_session_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute_result = ET.Element(\"l2traceroute_result\")\n        config = l2traceroute_result\n        input = ET.SubElement(l2traceroute_result, \"input\")\n        session_id = ET.SubElement(input, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the configuration of a specific L2 hop resource.", "response": "def l2traceroute_result_output_l2_hop_results_l2_hop_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute_result = ET.Element(\"l2traceroute_result\")\n        config = l2traceroute_result\n        output = ET.SubElement(l2traceroute_result, \"output\")\n        l2_hop_results = ET.SubElement(output, \"l2-hop-results\")\n        l2_hop = ET.SubElement(l2_hop_results, \"l2-hop\")\n        rbridge_id = ET.SubElement(l2_hop, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef l2traceroute_result_output_l2_hop_results_l2_hop_ingress_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        l2traceroute_result = ET.Element(\"l2traceroute_result\")\n        config = l2traceroute_result\n        output = ET.SubElement(l2traceroute_result, \"output\")\n        l2_hop_results = ET.SubElement(output, \"l2-hop-results\")\n        l2_hop = ET.SubElement(l2_hop_results, \"l2-hop\")\n        ingress = ET.SubElement(l2_hop, \"ingress\")\n        interface_type = ET.SubElement(ingress, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a L2TRACER L2 Hop Results and ingress interface type."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef l2traceroute_result_output_l2_hop_results_l2_hop_ingress_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        l2traceroute_result = ET.Element(\"l2traceroute_result\")\n        config = l2traceroute_result\n        output = ET.SubElement(l2traceroute_result, \"output\")\n        l2_hop_results = ET.SubElement(output, \"l2-hop-results\")\n        l2_hop = ET.SubElement(l2_hop_results, \"l2-hop\")\n        ingress = ET.SubElement(l2_hop, \"ingress\")\n        interface_name = ET.SubElement(ingress, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a L2 - Hop results l2 - hop ingress and interface name."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the L2 Hop Results output and egress XML elements.", "response": "def l2traceroute_result_output_l2_hop_results_l2_hop_egress_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute_result = ET.Element(\"l2traceroute_result\")\n        config = l2traceroute_result\n        output = ET.SubElement(l2traceroute_result, \"output\")\n        l2_hop_results = ET.SubElement(output, \"l2-hop-results\")\n        l2_hop = ET.SubElement(l2_hop_results, \"l2-hop\")\n        egress = ET.SubElement(l2_hop, \"egress\")\n        interface_type = ET.SubElement(egress, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the configuration of a L2 hop results l2 hop egress and interface name.", "response": "def l2traceroute_result_output_l2_hop_results_l2_hop_egress_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute_result = ET.Element(\"l2traceroute_result\")\n        config = l2traceroute_result\n        output = ET.SubElement(l2traceroute_result, \"output\")\n        l2_hop_results = ET.SubElement(output, \"l2-hop-results\")\n        l2_hop = ET.SubElement(l2_hop_results, \"l2-hop\")\n        egress = ET.SubElement(l2_hop, \"egress\")\n        interface_name = ET.SubElement(egress, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef l2traceroute_result_output_l2_hop_results_l2_hop_roundtriptime(self, **kwargs):\n        config = ET.Element(\"config\")\n        l2traceroute_result = ET.Element(\"l2traceroute_result\")\n        config = l2traceroute_result\n        output = ET.SubElement(l2traceroute_result, \"output\")\n        l2_hop_results = ET.SubElement(output, \"l2-hop-results\")\n        l2_hop = ET.SubElement(l2_hop_results, \"l2-hop\")\n        roundtriptime = ET.SubElement(l2_hop, \"roundtriptime\")\n        roundtriptime.text = kwargs.pop('roundtriptime')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a L2 - Hop results l2 - hop and roundtriptime."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the configuration of the L2TRACER OUTDENT condition.", "response": "def l2traceroute_result_output_l2traceroutedone(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute_result = ET.Element(\"l2traceroute_result\")\n        config = l2traceroute_result\n        output = ET.SubElement(l2traceroute_result, \"output\")\n        l2traceroutedone = ET.SubElement(output, \"l2traceroutedone\")\n        l2traceroutedone.text = kwargs.pop('l2traceroutedone')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the l2traceroute result and output with a reason.", "response": "def l2traceroute_result_output_reason(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        l2traceroute_result = ET.Element(\"l2traceroute_result\")\n        config = l2traceroute_result\n        output = ET.SubElement(l2traceroute_result, \"output\")\n        reason = ET.SubElement(output, \"reason\")\n        reason.text = kwargs.pop('reason')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_snmp_community(self, **kwargs):\n        community = kwargs.pop('community')\n        callback = kwargs.pop('callback', self._callback)\n\n        config = ET.Element('config')\n        snmp_server = ET.SubElement(config, 'snmp-server',\n                                    xmlns=(\"urn:brocade.com:mgmt:\"\n                                           \"brocade-snmp\"))\n        community_el = ET.SubElement(snmp_server, 'community')\n        community_name = ET.SubElement(community_el, 'community')\n        community_name.text = community\n\n        return callback(config)", "response": "Adds SNMP Community to NOS device."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding SNMP host to NOS device.", "response": "def add_snmp_host(self, **kwargs):\n        \"\"\"\n        Add SNMP host to NOS device.\n\n        Args:\n            host_info (tuple(str, str)): Tuple of host IP and port.\n            community (str): Community string to be added to device.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `host_info` or `community` is not defined.\n        \"\"\"\n        host_info = kwargs.pop('host_info')\n        community = kwargs.pop('community')\n        callback = kwargs.pop('callback', self._callback)\n\n        config = ET.Element('config')\n        snmp_server = ET.SubElement(config, 'snmp-server',\n                                    xmlns=(\"urn:brocade.com:mgmt:\"\n                                           \"brocade-snmp\"))\n        host = ET.SubElement(snmp_server, 'host')\n        ip_addr = ET.SubElement(host, 'ip')\n        ip_addr.text = host_info[0]\n        com = ET.SubElement(host, 'community')\n        com.text = community\n        udp_port = ET.SubElement(host, 'udp-port')\n        udp_port.text = host_info[1]\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compile_str(contents):\n    ctx = SASS_CLIB.sass_new_context()\n    ctx.contents.source_string = c_char_p(contents)\n\n    SASS_CLIB.compile(ctx)\n\n    if ctx.contents.error_status:\n        print(ctx.contents.error_message)\n\n    return ctx.contents.output_string or \"\"", "response": "Compiles a SASS string and returns the compiled CSS string"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the libsass library if it isn t already loaded.", "response": "def _load(self):\n        \"\"\"Loads the libsass library if it isn't already loaded.\"\"\"\n        if self.clib is None:\n            root_path = os.path.normpath(os.path.join(os.path.dirname(os.path.realpath(__file__ )), '..'))\n            path1 = os.path.join(root_path, 'sass.so')\n            path2 = os.path.join(root_path, '..', 'sass.so')\n\n            if os.path.exists(path1):\n                self.clib = cdll.LoadLibrary(path1)\n            elif os.path.exists(path1):\n                self.clib = cdll.LoadLibrary(path2)\n            else:\n                raise Exception(\"Could not load library\")\n\n            self.clib.sass_new_context.restype = POINTER(SassContext)\n            self.clib.sass_new_file_context.restype = POINTER(SassFileContext)\n            self.clib.sass_new_folder_context.restype = POINTER(SassFolderContext)\n\n            self.clib.sass_compile.restype = c_int\n            self.clib.sass_compile.argtypes = [POINTER(SassContext)]\n\n            self.clib.sass_compile_file.restype = c_int\n            self.clib.sass_compile_file.argtypes = [POINTER(SassFileContext)]\n\n            self.clib.sass_compile_folder.restype = c_int\n            self.clib.sass_compile_folder.argtypes = [POINTER(SassFolderContext)]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hide_routemap_holder_route_map_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        name = ET.SubElement(route_map, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the hide - routers - holder route - map action - rm", "response": "def hide_routemap_holder_route_map_action_rm(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        action_rm = ET.SubElement(route_map, \"action-rm\")\n        action_rm.text = kwargs.pop('action_rm')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hide_routemap_holder_route_map_instance(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance = ET.SubElement(route_map, \"instance\")\n        instance.text = kwargs.pop('instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hide_routemap_holder_route_map_content_match_vrf(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        vrf = ET.SubElement(match, \"vrf\")\n        vrf.text = kwargs.pop('vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content - match - vrf"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize the hide - routers - holder route - map content - match ipv6 - address - ipv6 - prefix - list - rmm", "response": "def hide_routemap_holder_route_map_content_match_ipv6_address_ipv6_prefix_list_rmm(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        ipv6 = ET.SubElement(match, \"ipv6\")\n        address = ET.SubElement(ipv6, \"address\")\n        ipv6_prefix_list_rmm = ET.SubElement(address, \"ipv6-prefix-list-rmm\")\n        ipv6_prefix_list_rmm.text = kwargs.pop('ipv6_prefix_list_rmm')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hide_routemap_holder_route_map_content_match_ipv6_next_hop_ipv6_prefix_list_rmm_n(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        ipv6 = ET.SubElement(match, \"ipv6\")\n        next_hop = ET.SubElement(ipv6, \"next-hop\")\n        ipv6_prefix_list_rmm_n = ET.SubElement(next_hop, \"ipv6-prefix-list-rmm-n\")\n        ipv6_prefix_list_rmm_n.text = kwargs.pop('ipv6_prefix_list_rmm_n')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize an empty routing map for the current ip policy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing an empty routing map for the current ip policy", "response": "def hide_routemap_holder_route_map_content_match_ipv6_route_source_ipv6_prefix_list_rmrs(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        ipv6 = ET.SubElement(match, \"ipv6\")\n        route_source = ET.SubElement(ipv6, \"route-source\")\n        ipv6_prefix_list_rmrs = ET.SubElement(route_source, \"ipv6-prefix-list-rmrs\")\n        ipv6_prefix_list_rmrs.text = kwargs.pop('ipv6_prefix_list_rmrs')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hide_routemap_holder_route_map_content_match_ip_address_prefix_list_rmm(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        ip = ET.SubElement(match, \"ip\")\n        address = ET.SubElement(ip, \"address\")\n        prefix_list_rmm = ET.SubElement(address, \"prefix-list-rmm\")\n        prefix_list_rmm.text = kwargs.pop('prefix_list_rmm')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content match IP address prefix list RMM."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hide_routemap_holder_route_map_content_match_ip_next_hop_prefix_list_rmm_n(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        ip = ET.SubElement(match, \"ip\")\n        next_hop = ET.SubElement(ip, \"next-hop\")\n        prefix_list_rmm_n = ET.SubElement(next_hop, \"prefix-list-rmm-n\")\n        prefix_list_rmm_n.text = kwargs.pop('prefix_list_rmm_n')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content match ip next - hop prefix - list - rmm - n"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hide_routemap_holder_route_map_content_match_ip_route_source_prefix_list_rmrs(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        ip = ET.SubElement(match, \"ip\")\n        route_source = ET.SubElement(ip, \"route-source\")\n        prefix_list_rmrs = ET.SubElement(route_source, \"prefix-list-rmrs\")\n        prefix_list_rmrs.text = kwargs.pop('prefix_list_rmrs')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content match IP route - source prefix - list - rmrs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hide_routemap_holder_route_map_content_match_extcommunity_extcommunity_num(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        extcommunity = ET.SubElement(match, \"extcommunity\")\n        extcommunity_num = ET.SubElement(extcommunity, \"extcommunity-num\")\n        extcommunity_num.text = kwargs.pop('extcommunity_num')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content match extcommunity - num"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hide_routemap_holder_route_map_content_match_metric_metric_rmm(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        metric = ET.SubElement(match, \"metric\")\n        metric_rmm = ET.SubElement(metric, \"metric-rmm\")\n        metric_rmm.text = kwargs.pop('metric_rmm')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content match metric rmm"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hide_routemap_holder_route_map_content_match_route_type_route_type_rmm(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        route_type = ET.SubElement(match, \"route-type\")\n        route_type_rmm = ET.SubElement(route_type, \"route-type-rmm\")\n        route_type_rmm.text = kwargs.pop('route_type_rmm')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content match route - type route - type - rmm"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes the hide - routers - holder route - map content match as - path as - path - access - list - name", "response": "def hide_routemap_holder_route_map_content_match_as_path_as_path_access_list_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        as_path = ET.SubElement(match, \"as-path\")\n        as_path_access_list_name = ET.SubElement(as_path, \"as-path-access-list-name\")\n        as_path_access_list_name.text = kwargs.pop('as_path_access_list_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hide_routemap_holder_route_map_content_match_community_community_access_list_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        community = ET.SubElement(match, \"community\")\n        community_access_list_name = ET.SubElement(community, \"community-access-list-name\")\n        community_access_list_name.text = kwargs.pop('community_access_list_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content - match - community - access - list - name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hide_routemap_holder_route_map_content_match_next_hop_next_hop_filter_val(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        next_hop = ET.SubElement(match, \"next-hop\")\n        next_hop_filter_val = ET.SubElement(next_hop, \"next-hop-filter-val\")\n        next_hop_filter_val.text = kwargs.pop('next_hop_filter_val')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content match next - hop next - hop filter val."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the hide - routers - holder route - map content - match - protocol - protocol - static - container static", "response": "def hide_routemap_holder_route_map_content_match_protocol_protocol_static_container_static(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        match = ET.SubElement(content, \"match\")\n        protocol = ET.SubElement(match, \"protocol\")\n        protocol_static_container = ET.SubElement(protocol, \"protocol-static-container\")\n        static = ET.SubElement(protocol_static_container, \"static\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hide_routemap_holder_route_map_content_set_ip_dscp_dscp_rms(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        ip = ET.SubElement(set, \"ip\")\n        dscp = ET.SubElement(ip, \"dscp\")\n        dscp_rms = ET.SubElement(dscp, \"dscp-rms\")\n        dscp_rms.text = kwargs.pop('dscp_rms')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content - set ip - dscp - rms"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hide_routemap_holder_route_map_content_set_ip_interface_null0(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        ip = ET.SubElement(set, \"ip\")\n        interface = ET.SubElement(ip, \"interface\")\n        null0 = ET.SubElement(interface, \"null0\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content - set ip - interface null0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hide_routemap_holder_route_map_content_set_ip_next_hop_peer_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        ip = ET.SubElement(set, \"ip\")\n        next_hop = ET.SubElement(ip, \"next-hop\")\n        peer_address = ET.SubElement(next_hop, \"peer-address\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content - set ip next - hop peer - address"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hide_routemap_holder_route_map_content_set_ipv6_interface_ipv6_null0(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        ipv6 = ET.SubElement(set, \"ipv6\")\n        interface = ET.SubElement(ipv6, \"interface\")\n        ipv6_null0 = ET.SubElement(interface, \"ipv6-null0\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content - set ipv6 - interface ipv6 - null0"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hide_routemap_holder_route_map_content_set_ipv6_next_vrf_next_vrf_list_vrf(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        ipv6 = ET.SubElement(set, \"ipv6\")\n        next_vrf = ET.SubElement(ipv6, \"next-vrf\")\n        next_vrf_list = ET.SubElement(next_vrf, \"next-vrf-list\")\n        next_hop_key = ET.SubElement(next_vrf_list, \"next-hop\")\n        next_hop_key.text = kwargs.pop('next_hop')\n        vrf = ET.SubElement(next_vrf_list, \"vrf\")\n        vrf.text = kwargs.pop('vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize an empty route map for the current ip policy"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing an empty route map for the current ip policy", "response": "def hide_routemap_holder_route_map_content_set_ipv6_next_vrf_next_vrf_list_next_hop(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        ipv6 = ET.SubElement(set, \"ipv6\")\n        next_vrf = ET.SubElement(ipv6, \"next-vrf\")\n        next_vrf_list = ET.SubElement(next_vrf, \"next-vrf-list\")\n        vrf_key = ET.SubElement(next_vrf_list, \"vrf\")\n        vrf_key.text = kwargs.pop('vrf')\n        next_hop = ET.SubElement(next_vrf_list, \"next-hop\")\n        next_hop.text = kwargs.pop('next_hop')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hide_routemap_holder_route_map_content_set_extcommunity_rt_ASN_NN_rt(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        extcommunity = ET.SubElement(set, \"extcommunity\")\n        rt = ET.SubElement(extcommunity, \"rt\")\n        ASN_NN_rt = ET.SubElement(rt, \"ASN-NN-rt\")\n        ASN_NN_rt.text = kwargs.pop('ASN_NN_rt')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content - set - extcommunity - rt ASN -NN - rt"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes the hide - routers - holder route - map content - set - extcommunity - soo ASN -NN - soo ASN - NN - soo ASN - NN - soo ASN - NN - soo ASN - NN - soo ASN - NN - soo ASN - NN - soo ASN - NN - soo ASN - NN - soo ASN - NN - soo ASN - NN - soo ASN - NN - soo ASN - NN - soo ASN_soo", "response": "def hide_routemap_holder_route_map_content_set_extcommunity_soo_ASN_NN_soo(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        extcommunity = ET.SubElement(set, \"extcommunity\")\n        soo = ET.SubElement(extcommunity, \"soo\")\n        ASN_NN_soo = ET.SubElement(soo, \"ASN-NN-soo\")\n        ASN_NN_soo.text = kwargs.pop('ASN_NN_soo')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes the hide - routers - holder route - map content set community set expression", "response": "def hide_routemap_holder_route_map_content_set_community_set_community_expr(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        community = ET.SubElement(set, \"community\")\n        set_community_expr = ET.SubElement(community, \"set-community-expr\")\n        set_community_expr.text = kwargs.pop('set_community_expr')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing the hide - routers - holder route - map content - set metric - delta - RMS", "response": "def hide_routemap_holder_route_map_content_set_metric_delta_rms(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        metric = ET.SubElement(set, \"metric\")\n        delta_rms = ET.SubElement(metric, \"delta-rms\")\n        delta_rms.text = kwargs.pop('delta_rms')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the hide - routers - holder route - map content - set distance - RMS", "response": "def hide_routemap_holder_route_map_content_set_distance_dist_rms(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        distance = ET.SubElement(set, \"distance\")\n        dist_rms = ET.SubElement(distance, \"dist-rms\")\n        dist_rms.text = kwargs.pop('dist_rms')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hide_routemap_holder_route_map_content_set_route_type_route_type_rms(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        route_type = ET.SubElement(set, \"route-type\")\n        route_type_rms = ET.SubElement(route_type, \"route-type-rms\")\n        route_type_rms.text = kwargs.pop('route_type_rms')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content - set route - type - route - type - RMS"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hide_routemap_holder_route_map_content_set_tag_tag_rms(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        tag = ET.SubElement(set, \"tag\")\n        tag_rms = ET.SubElement(tag, \"tag-rms\")\n        tag_rms.text = kwargs.pop('tag_rms')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content - set - tag - tag - RMS"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the hide - routers - holder route - map content - set weight - value", "response": "def hide_routemap_holder_route_map_content_set_weight_weight_value(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        weight = ET.SubElement(set, \"weight\")\n        weight_value = ET.SubElement(weight, \"weight-value\")\n        weight_value.text = kwargs.pop('weight_value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hide_routemap_holder_route_map_content_set_as_path_aspath_tag(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        as_path = ET.SubElement(set, \"as-path\")\n        aspath_tag = ET.SubElement(as_path, \"aspath-tag\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content set as - path as - path - tag"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the hide - routers - holder route - map content - set automatic - tag - empty = tag - empty", "response": "def hide_routemap_holder_route_map_content_set_automatic_tag_tag_empty(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        automatic_tag = ET.SubElement(set, \"automatic-tag\")\n        tag_empty = ET.SubElement(automatic_tag, \"tag-empty\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hide_routemap_holder_route_map_content_set_comm_list_match_comm_delete(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        comm_list = ET.SubElement(set, \"comm-list\")\n        match_comm_delete = ET.SubElement(comm_list, \"match-comm-delete\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content - set - comm - list match - comm - delete"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the hide - routers - holder route - map content set and dampening half - life", "response": "def hide_routemap_holder_route_map_content_set_dampening_half_life(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        dampening = ET.SubElement(set, \"dampening\")\n        half_life = ET.SubElement(dampening, \"half-life\")\n        half_life.text = kwargs.pop('half_life')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the hide - routers - holder route - map content - set - local - preference - local - preference - value", "response": "def hide_routemap_holder_route_map_content_set_local_preference_local_preference_value(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        local_preference = ET.SubElement(set, \"local-preference\")\n        local_preference_value = ET.SubElement(local_preference, \"local-preference-value\")\n        local_preference_value.text = kwargs.pop('local_preference_value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hide_routemap_holder_route_map_content_set_origin_origin_igp(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        origin = ET.SubElement(set, \"origin\")\n        origin_igp = ET.SubElement(origin, \"origin-igp\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content set origin - igp"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the hide - routers - holder route - map content - set metric - type - external", "response": "def hide_routemap_holder_route_map_content_set_metric_type_external(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        set = ET.SubElement(content, \"set\")\n        metric_type = ET.SubElement(set, \"metric-type\")\n        external = ET.SubElement(metric_type, \"external\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hide_routemap_holder_route_map_content_continue_holder_cont(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_routemap_holder = ET.SubElement(config, \"hide-routemap-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        route_map = ET.SubElement(hide_routemap_holder, \"route-map\")\n        name_key = ET.SubElement(route_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        action_rm_key = ET.SubElement(route_map, \"action-rm\")\n        action_rm_key.text = kwargs.pop('action_rm')\n        instance_key = ET.SubElement(route_map, \"instance\")\n        instance_key.text = kwargs.pop('instance')\n        content = ET.SubElement(route_map, \"content\")\n        continue_holder = ET.SubElement(content, \"continue-holder\")\n        cont = ET.SubElement(continue_holder, \"continue\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the hide - routers - holder route - map content - continue - holder cont"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hide_filter_change_update_delay_holder_filter_change_update_delay_filter_delay_value(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_filter_change_update_delay_holder = ET.SubElement(config, \"hide-filter-change-update-delay-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-policy\")\n        filter_change_update_delay = ET.SubElement(hide_filter_change_update_delay_holder, \"filter-change-update-delay\")\n        filter_delay_value = ET.SubElement(filter_change_update_delay, \"filter-delay-value\")\n        filter_delay_value.text = kwargs.pop('filter_delay_value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Hide the filter change update delay holder filter change update delay value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the type of the overlay gateway", "response": "def hwvtep_set_overlaygw_type(self, **kwargs):\n        \"\"\"\n        Set gateway type\n\n        Args:\n            name  (str): gateway-name\n            type (str): gateway-type\n            callback (function): A function executed upon completion of the\n                method.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            None\n        \"\"\"\n        name = kwargs.pop('name')\n        type = kwargs.pop('type')\n        ip_args = dict(name=name, gw_type=type)\n        method_name = 'overlay_gateway_gw_type'\n        method_class = self._brocade_tunnels\n        gw_attr = getattr(method_class, method_name)\n        config = gw_attr(**ip_args)\n        output = self._callback(config)\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hwvtep_add_rbridgeid(self, **kwargs):\n        name = kwargs.pop('name')\n        id = kwargs.pop('rb_range')\n        ip_args = dict(name=name, rb_add=id)\n        method_name = 'overlay_gateway_attach_rbridge_id_rb_add'\n        method_class = self._brocade_tunnels\n        gw_attr = getattr(method_class, method_name)\n        config = gw_attr(**ip_args)\n        output = self._callback(config)\n        return output", "response": "Adds a range of rbridge - ids to the set of rbridge - ids"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a loopback interface to the overlay - gateway", "response": "def hwvtep_add_loopback_interface(self, **kwargs):\n        \"\"\"\n        Add loopback interface to the overlay-gateway\n\n        Args:\n            name  (str): gateway-name\n            int_id (int): loopback inteface id\n            callback (function): A function executed upon completion of the\n                 method.\n\n        Returns:\n           Return value of `callback`.\n\n        Raises:\n            None\n        \"\"\"\n        name = kwargs.pop('name')\n        id = kwargs.pop('int_id')\n        ip_args = dict(name=name, loopback_id=id)\n        method_name = 'overlay_gateway_ip_interface_loopback_loopback_id'\n        method_class = self._brocade_tunnels\n        gw_attr = getattr(method_class, method_name)\n        config = gw_attr(**ip_args)\n        output = self._callback(config)\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a virtual ethernet interface to the overlay - gateway", "response": "def hwvtep_add_ve_interface(self, **kwargs):\n        \"\"\"\n               Add virtual ethernet (ve) interface to the overlay-gateway\n\n               Args:\n                   name  (str): gateway-name\n                   int_id (int): ve id\n                   vrrp_id (int): VRPP-E group ID\n                   callback (function): A function executed upon completion of the\n                        method.\n\n               Returns:\n                  Return value of `callback`.\n\n               Raises:\n                   None\n               \"\"\"\n        name = kwargs.pop('name')\n        ve_id = kwargs.pop('ve_id')\n        vrrp_id = kwargs.pop('vrrp_id')\n        ve_args = dict(name=name, ve_id=ve_id)\n        method_name = 'overlay_gateway_ip_interface_ve_ve_id'\n        method_class = self._brocade_tunnels\n        ve_attr = getattr(method_class, method_name)\n        config = ve_attr(**ve_args)\n        output = self._callback(config)\n        method_name = 'overlay_gateway_ip_interface_ve_vrrp_extended_group'\n        vrrp_attr = getattr(method_class, method_name)\n        vrrp_args = dict(name=name, vrrp_extended_group=vrrp_id)\n        config = vrrp_attr(**vrrp_args)\n        output = self._callback(config)\n\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nactivate the hwvtep on the specified object.", "response": "def hwvtep_activate_hwvtep(self, **kwargs):\n        \"\"\"\n        Activate the hwvtep\n\n        Args:\n            name (str): overlay_gateway name\n            callback (function): A function executed upon completion of the\n                 method.\n\n        Returns:\n           Return value of `callback`.\n\n        Raises:\n            None\n        \"\"\"\n        name = kwargs.pop('name')\n        name_args = dict(name=name)\n        method_name = 'overlay_gateway_activate'\n        method_class = self._brocade_tunnels\n        gw_attr = getattr(method_class, method_name)\n        config = gw_attr(**name_args)\n        output = self._callback(config)\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hwvtep_attach_vlan_vid(self, **kwargs):\n        name = kwargs.pop('name')\n        mac = kwargs.pop('mac')\n        vlan = kwargs.pop('vlan')\n        name_args = dict(name=name, vid=vlan, mac=mac)\n        method_name = 'overlay_gateway_attach_vlan_mac'\n        method_class = self._brocade_tunnels\n        gw_attr = getattr(method_class, method_name)\n        config = gw_attr(**name_args)\n        output = self._callback(config)\n        return output", "response": "Adds an exported VLAN to an existing VLAN in the VXLAN gateway."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_overlay_gateway(self):\n        urn = \"urn:brocade.com:mgmt:brocade-tunnels\"\n        config = ET.Element(\"config\")\n        ET.SubElement(config, \"overlay-gateway\", xmlns=urn)\n        output = self._callback(config, handler='get_config')\n        result = {}\n        element = ET.fromstring(str(output))\n        for overlayGw in element.iter('{%s}overlay-gateway' % urn):\n            result['name'] = overlayGw.find('{%s}name' % urn).text\n            isactivate = overlayGw.find('{%s}activate' % urn)\n            if isactivate is None:\n                result['activate'] = False\n            else:\n                result['activate'] = True\n\n            gwtype = overlayGw.find('{%s}gw-type' % urn)\n            if gwtype is None:\n                result['gwtype'] = None\n            else:\n                result['gwtype'] = gwtype.text\n\n            attach = overlayGw.find('{%s}attach' % urn)\n            if attach is not None:\n                rbridgeId = attach.find('{%s}rbridge-id' % urn)\n                if rbridgeId is None:\n                    result['attached-rbridgeId'] = None\n                else:\n                    result['attached-rbridgeId'] = rbridgeId.find('{%s}rb-add' % urn).text\n                result['attached-vlan'] = None\n                vlans = []\n                for vlan in attach.iter('{%s}vlan'%urn):\n                    vlans.append(vlan.find('{%s}vid' % urn).text)\n                result['attached-vlan'] = vlans\n\n        return result", "response": "Get overlay - gateway name on the switch"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconfiguring the behavior of the Logger.", "response": "def config(self, **kwargs):\n        \"\"\"\n        Config the behavior of :class:`Logger`.\n\n        Control the output to show :class:`Logger.verbose` log::\n\n            log.config(verbose=True)\n\n        Control the output to show only the :class:`Logger.warn` and\n        :class:`Logger.error` log::\n\n            log.config(quiet=True)\n\n        \"\"\"\n        if 'indent' in kwargs:\n            self._indent = kwargs.get('indent', 0)\n        if 'verbose' in kwargs:\n            self._enable_verbose = kwargs.get('verbose', False)\n        if 'quiet' in kwargs:\n            self._enable_quiet = kwargs.get('quiet', False)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef message(self, level, *args):\n\n        msg = ' '.join((str(o) for o in args))\n        if level not in ('start', 'end', 'debug', 'info', 'warn', 'error'):\n            return msg\n        return '%s: %s' % (level, msg)", "response": "Format the message of the logger."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking it the verbose log.", "response": "def verbose(self):\n        \"\"\"\n        Make it the verbose log.\n\n        A verbose log can be only shown when user want to see more logs.\n        It works as::\n\n            log.verbose.warn('this is a verbose warn')\n            log.verbose.info('this is a verbose info')\n        \"\"\"\n\n        log = copy.copy(self)\n        log._is_verbose = True\n        return log"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart a nested log.", "response": "def start(self, *args):\n        \"\"\"\n        Start a nested log.\n        \"\"\"\n\n        if self._is_verbose:\n            # verbose log has no start method\n            return self\n\n        self.writeln('start', *args)\n        self._indent += 1\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef end(self, *args):\n\n        if self._is_verbose:\n            # verbose log has no end method\n            return self\n\n        if not args:\n            self._indent -= 1\n            return self\n        self.writeln('end', *args)\n        self._indent -= 1\n        return self", "response": "End a nested log."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts Transaction with input target and startup.", "response": "def start_transaction_input_target_target_startup_startup(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        start_transaction = ET.Element(\"start_transaction\")\n        config = start_transaction\n        input = ET.SubElement(start_transaction, \"input\")\n        target = ET.SubElement(input, \"target\")\n        target = ET.SubElement(target, \"target\")\n        startup = ET.SubElement(target, \"startup\")\n        startup = ET.SubElement(startup, \"startup\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart Transaction with input target and running status.", "response": "def start_transaction_input_target_target_running_running(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        start_transaction = ET.Element(\"start_transaction\")\n        config = start_transaction\n        input = ET.SubElement(start_transaction, \"input\")\n        target = ET.SubElement(input, \"target\")\n        target = ET.SubElement(target, \"target\")\n        running = ET.SubElement(target, \"running\")\n        running = ET.SubElement(running, \"running\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start_transaction_input_target_target_candidate_candidate(self, **kwargs):\n        config = ET.Element(\"config\")\n        start_transaction = ET.Element(\"start_transaction\")\n        config = start_transaction\n        input = ET.SubElement(start_transaction, \"input\")\n        target = ET.SubElement(input, \"target\")\n        target = ET.SubElement(target, \"target\")\n        candidate = ET.SubElement(target, \"candidate\")\n        candidate = ET.SubElement(candidate, \"candidate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Start Transaction with input target and candidate."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start_transaction_input_with_inactive(self, **kwargs):\n        config = ET.Element(\"config\")\n        start_transaction = ET.Element(\"start_transaction\")\n        config = start_transaction\n        input = ET.SubElement(start_transaction, \"input\")\n        with_inactive = ET.SubElement(input, \"with-inactive\", xmlns=\"http://tail-f.com/ns/netconf/inactive/1.0\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Start Transaction input with inactive status."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef call_operation(self, operation, **kwargs):\n        data = {'operation': operation}\n        data.update(kwargs)\n        return self.invoke(data)", "response": "A generic method to call any operation supported by the Lambda handler\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmonitors the session number of the current node", "response": "def monitor_session_session_number(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        monitor = ET.SubElement(config, \"monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-span\")\n        session = ET.SubElement(monitor, \"session\")\n        session_number = ET.SubElement(session, \"session-number\")\n        session_number.text = kwargs.pop('session_number')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef monitor_session_description(self, **kwargs):\n        config = ET.Element(\"config\")\n        monitor = ET.SubElement(config, \"monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-span\")\n        session = ET.SubElement(monitor, \"session\")\n        session_number_key = ET.SubElement(session, \"session-number\")\n        session_number_key.text = kwargs.pop('session_number')\n        description = ET.SubElement(session, \"description\")\n        description.text = kwargs.pop('description')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the description of the current session"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmonitor Session Span Command Source", "response": "def monitor_session_span_command_source(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        monitor = ET.SubElement(config, \"monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-span\")\n        session = ET.SubElement(monitor, \"session\")\n        session_number_key = ET.SubElement(session, \"session-number\")\n        session_number_key.text = kwargs.pop('session_number')\n        span_command = ET.SubElement(session, \"span-command\")\n        source = ET.SubElement(span_command, \"source\")\n        source.text = kwargs.pop('source')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef monitor_session_span_command_src_tengigabitethernet(self, **kwargs):\n        config = ET.Element(\"config\")\n        monitor = ET.SubElement(config, \"monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-span\")\n        session = ET.SubElement(monitor, \"session\")\n        session_number_key = ET.SubElement(session, \"session-number\")\n        session_number_key.text = kwargs.pop('session_number')\n        span_command = ET.SubElement(session, \"span-command\")\n        src_tengigabitethernet = ET.SubElement(span_command, \"src-tengigabitethernet\")\n        src_tengigabitethernet.text = kwargs.pop('src_tengigabitethernet')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Monitor Session Span Command Source Tengigabitethernet"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef monitor_session_span_command_src_tengigabitethernet_val(self, **kwargs):\n        config = ET.Element(\"config\")\n        monitor = ET.SubElement(config, \"monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-span\")\n        session = ET.SubElement(monitor, \"session\")\n        session_number_key = ET.SubElement(session, \"session-number\")\n        session_number_key.text = kwargs.pop('session_number')\n        span_command = ET.SubElement(session, \"span-command\")\n        src_tengigabitethernet_val = ET.SubElement(span_command, \"src-tengigabitethernet-val\")\n        src_tengigabitethernet_val.text = kwargs.pop('src_tengigabitethernet_val')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Monitor Session Span Command src Tengigabitethernet Value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef monitor_session_span_command_destination(self, **kwargs):\n        config = ET.Element(\"config\")\n        monitor = ET.SubElement(config, \"monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-span\")\n        session = ET.SubElement(monitor, \"session\")\n        session_number_key = ET.SubElement(session, \"session-number\")\n        session_number_key.text = kwargs.pop('session_number')\n        span_command = ET.SubElement(session, \"span-command\")\n        destination = ET.SubElement(span_command, \"destination\")\n        destination.text = kwargs.pop('destination')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Monitor Session Span Command Destination"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef monitor_session_span_command_dest_tengigabitethernet(self, **kwargs):\n        config = ET.Element(\"config\")\n        monitor = ET.SubElement(config, \"monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-span\")\n        session = ET.SubElement(monitor, \"session\")\n        session_number_key = ET.SubElement(session, \"session-number\")\n        session_number_key.text = kwargs.pop('session_number')\n        span_command = ET.SubElement(session, \"span-command\")\n        dest_tengigabitethernet = ET.SubElement(span_command, \"dest-tengigabitethernet\")\n        dest_tengigabitethernet.text = kwargs.pop('dest_tengigabitethernet')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Monitor Session Span Command Destination Tengigabitethernet"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef monitor_session_span_command_dest_tengigabitethernet_val(self, **kwargs):\n        config = ET.Element(\"config\")\n        monitor = ET.SubElement(config, \"monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-span\")\n        session = ET.SubElement(monitor, \"session\")\n        session_number_key = ET.SubElement(session, \"session-number\")\n        session_number_key.text = kwargs.pop('session_number')\n        span_command = ET.SubElement(session, \"span-command\")\n        dest_tengigabitethernet_val = ET.SubElement(span_command, \"dest-tengigabitethernet-val\")\n        dest_tengigabitethernet_val.text = kwargs.pop('dest_tengigabitethernet_val')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Monitor Session Span Command dest Tengigabitethernet Value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmonitoring Session Span Command dest VLAN Value", "response": "def monitor_session_span_command_dest_vlan_val(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        monitor = ET.SubElement(config, \"monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-span\")\n        session = ET.SubElement(monitor, \"session\")\n        session_number_key = ET.SubElement(session, \"session-number\")\n        session_number_key.text = kwargs.pop('session_number')\n        span_command = ET.SubElement(session, \"span-command\")\n        dest_vlan_val = ET.SubElement(span_command, \"dest-vlan-val\")\n        dest_vlan_val.text = kwargs.pop('dest_vlan_val')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef monitor_session_span_command_direction(self, **kwargs):\n        config = ET.Element(\"config\")\n        monitor = ET.SubElement(config, \"monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-span\")\n        session = ET.SubElement(monitor, \"session\")\n        session_number_key = ET.SubElement(session, \"session-number\")\n        session_number_key.text = kwargs.pop('session_number')\n        span_command = ET.SubElement(session, \"span-command\")\n        direction = ET.SubElement(span_command, \"direction\")\n        direction.text = kwargs.pop('direction')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Monitor Session Span Command Direction"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dot1x_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        dot1x = ET.SubElement(config, \"dot1x\", xmlns=\"urn:brocade.com:mgmt:brocade-dot1x\")\n        enable = ET.SubElement(dot1x, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable the CM1 certificate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_firmware_version_input_switchid(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        input = ET.SubElement(show_firmware_version, \"input\")\n        switchid = ET.SubElement(input, \"switchid\")\n        switchid.text = kwargs.pop('switchid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of the show firmware version input switchid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_firmware_version_output_show_firmware_version_switchid(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        switchid = ET.SubElement(show_firmware_version, \"switchid\")\n        switchid.text = kwargs.pop('switchid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of show_firmware_version output and show_firmware_version switchid."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_firmware_version_output_show_firmware_version_os_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        os_name = ET.SubElement(show_firmware_version, \"os-name\")\n        os_name.text = kwargs.pop('os_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of show_firmware_version output and show_firmware_version os_name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshowing Firmware Version output for a specific OS version.", "response": "def show_firmware_version_output_show_firmware_version_os_version(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        os_version = ET.SubElement(show_firmware_version, \"os-version\")\n        os_version.text = kwargs.pop('os_version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_firmware_version_output_show_firmware_version_copy_right_info(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        copy_right_info = ET.SubElement(show_firmware_version, \"copy-right-info\")\n        copy_right_info.text = kwargs.pop('copy_right_info')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Firmware Version output show firmware version copy right info."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the config of show_firmware_version output and show_firmware_version build time.", "response": "def show_firmware_version_output_show_firmware_version_build_time(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        build_time = ET.SubElement(show_firmware_version, \"build-time\")\n        build_time.text = kwargs.pop('build_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_firmware_version_output_show_firmware_version_firmware_full_version(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        firmware_full_version = ET.SubElement(show_firmware_version, \"firmware-full-version\")\n        firmware_full_version.text = kwargs.pop('firmware_full_version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Firmware Version output for a specific locale."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_firmware_version_output_show_firmware_version_control_processor_vendor(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        control_processor_vendor = ET.SubElement(show_firmware_version, \"control-processor-vendor\")\n        control_processor_vendor.text = kwargs.pop('control_processor_vendor')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of show_firmware_version output and show_firmware_version control_processor_vendor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_firmware_version_output_show_firmware_version_control_processor_chipset(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        control_processor_chipset = ET.SubElement(show_firmware_version, \"control-processor-chipset\")\n        control_processor_chipset.text = kwargs.pop('control_processor_chipset')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of show_firmware_version output and control_processor_chipset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_firmware_version_output_show_firmware_version_control_processor_memory(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        control_processor_memory = ET.SubElement(show_firmware_version, \"control-processor-memory\")\n        control_processor_memory.text = kwargs.pop('control_processor_memory')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Firmware Version output and Control Processor Memory."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the config of show_firmware_version output and show_firmware_version node_info_slot_no.", "response": "def show_firmware_version_output_show_firmware_version_node_info_slot_no(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        node_info = ET.SubElement(show_firmware_version, \"node-info\")\n        slot_no = ET.SubElement(node_info, \"slot-no\")\n        slot_no.text = kwargs.pop('slot_no')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_firmware_version_output_show_firmware_version_node_info_node_instance_no(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        node_info = ET.SubElement(show_firmware_version, \"node-info\")\n        node_instance_no = ET.SubElement(node_info, \"node-instance-no\")\n        node_instance_no.text = kwargs.pop('node_instance_no')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of show_firmware_version output and show_firmware_version node_info node_instance_no."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_firmware_version_output_show_firmware_version_node_info_node_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        node_info = ET.SubElement(show_firmware_version, \"node-info\")\n        node_type = ET.SubElement(node_info, \"node-type\")\n        node_type.text = kwargs.pop('node_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of show_firmware_version output and show_firmware_version node_info node_type."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows Firmware Version output show_firmware_version node_info is_active_cp", "response": "def show_firmware_version_output_show_firmware_version_node_info_is_active_cp(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        node_info = ET.SubElement(show_firmware_version, \"node-info\")\n        is_active_cp = ET.SubElement(node_info, \"is-active-cp\")\n        is_active_cp.text = kwargs.pop('is_active_cp')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nshow Firmware Version output and show Firmware Version Node Info and Firmware Version Info Application Name.", "response": "def show_firmware_version_output_show_firmware_version_node_info_firmware_version_info_application_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        node_info = ET.SubElement(show_firmware_version, \"node-info\")\n        firmware_version_info = ET.SubElement(node_info, \"firmware-version-info\")\n        application_name = ET.SubElement(firmware_version_info, \"application-name\")\n        application_name.text = kwargs.pop('application_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing Firmware Version output.", "response": "def show_firmware_version_output_show_firmware_version_node_info_firmware_version_info_primary_version(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        node_info = ET.SubElement(show_firmware_version, \"node-info\")\n        firmware_version_info = ET.SubElement(node_info, \"firmware-version-info\")\n        primary_version = ET.SubElement(firmware_version_info, \"primary-version\")\n        primary_version.text = kwargs.pop('primary_version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows Firmware Version output.", "response": "def show_firmware_version_output_show_firmware_version_node_info_firmware_version_info_secondary_version(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_firmware_version = ET.Element(\"show_firmware_version\")\n        config = show_firmware_version\n        output = ET.SubElement(show_firmware_version, \"output\")\n        show_firmware_version = ET.SubElement(output, \"show-firmware-version\")\n        node_info = ET.SubElement(show_firmware_version, \"node-info\")\n        firmware_version_info = ET.SubElement(node_info, \"firmware-version-info\")\n        secondary_version = ET.SubElement(firmware_version_info, \"secondary-version\")\n        secondary_version.text = kwargs.pop('secondary_version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Isns VRF and isns - vrf - instance element.", "response": "def isns_isns_vrf_isns_vrf_instance(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        isns = ET.SubElement(config, \"isns\", xmlns=\"urn:brocade.com:mgmt:brocade-isns\")\n        isns_vrf = ET.SubElement(isns, \"isns-vrf\")\n        isns_vrf_instance = ET.SubElement(isns_vrf, \"isns-vrf-instance\")\n        isns_vrf_instance.text = kwargs.pop('isns_vrf_instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef isns_isns_vrf_isns_ipaddress_ip(self, **kwargs):\n        config = ET.Element(\"config\")\n        isns = ET.SubElement(config, \"isns\", xmlns=\"urn:brocade.com:mgmt:brocade-isns\")\n        isns_vrf = ET.SubElement(isns, \"isns-vrf\")\n        isns_vrf_instance_key = ET.SubElement(isns_vrf, \"isns-vrf-instance\")\n        isns_vrf_instance_key.text = kwargs.pop('isns_vrf_instance')\n        isns_ipaddress = ET.SubElement(isns_vrf, \"isns-ipaddress\")\n        ip = ET.SubElement(isns_ipaddress, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get isns metadata from isns vrf isns - ipaddress - ip"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isns_isns_vrf_isns_ipaddress_loopback(self, **kwargs):\n        config = ET.Element(\"config\")\n        isns = ET.SubElement(config, \"isns\", xmlns=\"urn:brocade.com:mgmt:brocade-isns\")\n        isns_vrf = ET.SubElement(isns, \"isns-vrf\")\n        isns_vrf_instance_key = ET.SubElement(isns_vrf, \"isns-vrf-instance\")\n        isns_vrf_instance_key.text = kwargs.pop('isns_vrf_instance')\n        isns_ipaddress = ET.SubElement(isns_vrf, \"isns-ipaddress\")\n        loopback = ET.SubElement(isns_ipaddress, \"loopback\")\n        loopback.text = kwargs.pop('loopback')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Isns VRF isns IP address and loopback"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef isns_isns_vrf_esi_timeout(self, **kwargs):\n        config = ET.Element(\"config\")\n        isns = ET.SubElement(config, \"isns\", xmlns=\"urn:brocade.com:mgmt:brocade-isns\")\n        isns_vrf = ET.SubElement(isns, \"isns-vrf\")\n        isns_vrf_instance_key = ET.SubElement(isns_vrf, \"isns-vrf-instance\")\n        isns_vrf_instance_key.text = kwargs.pop('isns_vrf_instance')\n        esi_timeout = ET.SubElement(isns_vrf, \"esi-timeout\")\n        esi_timeout.text = kwargs.pop('esi_timeout')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Isns VRF ESI Timeout"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Isns VRF isns Discovery Domain Isns Discovery Domain Name", "response": "def isns_isns_vrf_isns_discovery_domain_isns_discovery_domain_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        isns = ET.SubElement(config, \"isns\", xmlns=\"urn:brocade.com:mgmt:brocade-isns\")\n        isns_vrf = ET.SubElement(isns, \"isns-vrf\")\n        isns_vrf_instance_key = ET.SubElement(isns_vrf, \"isns-vrf-instance\")\n        isns_vrf_instance_key.text = kwargs.pop('isns_vrf_instance')\n        isns_discovery_domain = ET.SubElement(isns_vrf, \"isns-discovery-domain\")\n        isns_discovery_domain_name = ET.SubElement(isns_discovery_domain, \"isns-discovery-domain-name\")\n        isns_discovery_domain_name.text = kwargs.pop('isns_discovery_domain_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef isns_isns_vrf_isns_discovery_domain_set_isns_discovery_domain_set_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        isns = ET.SubElement(config, \"isns\", xmlns=\"urn:brocade.com:mgmt:brocade-isns\")\n        isns_vrf = ET.SubElement(isns, \"isns-vrf\")\n        isns_vrf_instance_key = ET.SubElement(isns_vrf, \"isns-vrf-instance\")\n        isns_vrf_instance_key.text = kwargs.pop('isns_vrf_instance')\n        isns_discovery_domain_set = ET.SubElement(isns_vrf, \"isns-discovery-domain-set\")\n        isns_discovery_domain_set_name = ET.SubElement(isns_discovery_domain_set, \"isns-discovery-domain-set-name\")\n        isns_discovery_domain_set_name.text = kwargs.pop('isns_discovery_domain_set_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set isns_vrf_isns_discovery_domain_set_isns_discovery_domain_set_name attribute of isns_vrf"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef isns_isns_vrf_isns_discovery_domain_set_isns_discovery_domain_set_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        isns = ET.SubElement(config, \"isns\", xmlns=\"urn:brocade.com:mgmt:brocade-isns\")\n        isns_vrf = ET.SubElement(isns, \"isns-vrf\")\n        isns_vrf_instance_key = ET.SubElement(isns_vrf, \"isns-vrf-instance\")\n        isns_vrf_instance_key.text = kwargs.pop('isns_vrf_instance')\n        isns_discovery_domain_set = ET.SubElement(isns_vrf, \"isns-discovery-domain-set\")\n        isns_discovery_domain_set_name_key = ET.SubElement(isns_discovery_domain_set, \"isns-discovery-domain-set-name\")\n        isns_discovery_domain_set_name_key.text = kwargs.pop('isns_discovery_domain_set_name')\n        isns_discovery_domain_set_enable = ET.SubElement(isns_discovery_domain_set, \"isns-discovery-domain-set-enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set enable flag for isns discovery domain set"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sflow_collector_collector_port_number(self, **kwargs):\n        config = ET.Element(\"config\")\n        sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")\n        collector = ET.SubElement(sflow, \"collector\")\n        collector_ip_address_key = ET.SubElement(collector, \"collector-ip-address\")\n        collector_ip_address_key.text = kwargs.pop('collector_ip_address')\n        use_vrf_key = ET.SubElement(collector, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        collector_port_number = ET.SubElement(collector, \"collector-port-number\")\n        collector_port_number.text = kwargs.pop('collector_port_number')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get collector port number for a specific resource"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset use VRF flag for the collector record", "response": "def sflow_collector_use_vrf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")\n        collector = ET.SubElement(sflow, \"collector\")\n        collector_ip_address_key = ET.SubElement(collector, \"collector-ip-address\")\n        collector_ip_address_key.text = kwargs.pop('collector_ip_address')\n        collector_port_number_key = ET.SubElement(collector, \"collector-port-number\")\n        collector_port_number_key.text = kwargs.pop('collector_port_number')\n        use_vrf = ET.SubElement(collector, \"use-vrf\")\n        use_vrf.text = kwargs.pop('use_vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling when a datagram is received from the broker.", "response": "def datagramReceived(self, datagram, address):\n        \"\"\"\n        After receiving a datagram, generate the deferreds and add myself to it.\n        \"\"\"\n        def write(result):\n            print \"Writing %r\" % result\n            self.transport.write(result, address)\n\n        d = self.d()\n        #d.addCallbacks(write, log.err)\n        d.addCallback(write)  # errors are silently ignored!\n        d.callback(datagram)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling when data is received from the device.", "response": "def dataReceived(self, data):\n        \"\"\"\n        After receiving the data, generate the deferreds and add myself to it.\n        \"\"\"\n        def write(result):\n            print \"Writing %r\" % result\n            self.transport.write(result)\n        d = self.d()\n        d.addCallback(write)  # errors are silently ignored!\n        d.callback(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_http_application_url_input_config_http_app_url_url(self, **kwargs):\n        config = ET.Element(\"config\")\n        set_http_application_url = ET.Element(\"set_http_application_url\")\n        config = set_http_application_url\n        input = ET.SubElement(set_http_application_url, \"input\")\n        config_http_app_url = ET.SubElement(input, \"config-http-app-url\")\n        url = ET.SubElement(config_http_app_url, \"url\")\n        url.text = kwargs.pop('url')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set HTTP Application URL input config."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_http_application_url_input_config_http_app_url_op_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        set_http_application_url = ET.Element(\"set_http_application_url\")\n        config = set_http_application_url\n        input = ET.SubElement(set_http_application_url, \"input\")\n        config_http_app_url = ET.SubElement(input, \"config-http-app-url\")\n        op_type = ET.SubElement(config_http_app_url, \"op-type\")\n        op_type.text = kwargs.pop('op_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set HTTP Application URL input config."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_http_application_url_output_status_code(self, **kwargs):\n        config = ET.Element(\"config\")\n        set_http_application_url = ET.Element(\"set_http_application_url\")\n        config = set_http_application_url\n        output = ET.SubElement(set_http_application_url, \"output\")\n        status_code = ET.SubElement(output, \"status-code\")\n        status_code.text = kwargs.pop('status_code')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set HTTP Application URL output status code."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_http_application_url_output_status_string(self, **kwargs):\n        config = ET.Element(\"config\")\n        set_http_application_url = ET.Element(\"set_http_application_url\")\n        config = set_http_application_url\n        output = ET.SubElement(set_http_application_url, \"output\")\n        status_string = ET.SubElement(output, \"status-string\")\n        status_string.text = kwargs.pop('status_string')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set HTTP Application URL output status string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ip_unnumbered(self, **kwargs):\n        kwargs['ip_donor_interface_name'] = kwargs.pop('donor_name')\n        kwargs['ip_donor_interface_type'] = kwargs.pop('donor_type')\n        kwargs['delete'] = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['gigabitethernet', 'tengigabitethernet',\n                           'fortygigabitethernet', 'hundredgigabitethernet']\n        if kwargs['int_type'] not in valid_int_types:\n            raise ValueError('int_type must be one of: %s' %\n                             repr(valid_int_types))\n        unnumbered_type = self._ip_unnumbered_type(**kwargs)\n        unnumbered_name = self._ip_unnumbered_name(**kwargs)\n        if kwargs.pop('get', False):\n            return self._get_ip_unnumbered(unnumbered_type, unnumbered_name)\n        config = pynos.utilities.merge_xml(unnumbered_type, unnumbered_name)\n        return callback(config)", "response": "Configure an unnumbered interface."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _ip_unnumbered_name(self, **kwargs):\n\n        method_name = 'interface_%s_ip_ip_config_unnumbered_ip_donor_'\\\n            'interface_name' % kwargs['int_type']\n        ip_unnumbered_name = getattr(self._interface, method_name)\n        config = ip_unnumbered_name(**kwargs)\n        if kwargs['delete']:\n            tag = 'ip-donor-interface-name'\n            config.find('.//*%s' % tag).set('operation', 'delete')\n        return config", "response": "Return the ip unnumbered donor name XML."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the ip unnumbered donor type XML.", "response": "def _ip_unnumbered_type(self, **kwargs):\n        \"\"\"Return the `ip unnumbered` donor type XML.\n\n        You should not use this method.\n        You probably want `Interface.ip_unnumbered`.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                 tengigabitethernet etc).\n            delete (bool): Remove the configuration if ``True``.\n            ip_donor_interface_type (str): The donor interface type (loopback)\n\n        Returns:\n            XML to be passed to the switch.\n\n        Raises:\n            None\n        \"\"\"\n        method_name = 'interface_%s_ip_ip_config_unnumbered_ip_donor_'\\\n            'interface_type' % kwargs['int_type']\n        ip_unnumbered_type = getattr(self._interface, method_name)\n        config = ip_unnumbered_type(**kwargs)\n        if kwargs['delete']:\n            tag = 'ip-donor-interface-type'\n            config.find('.//*%s' % tag).set('operation', 'delete')\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting and merge the ip unnumbered config from an interface.", "response": "def _get_ip_unnumbered(self, unnumbered_type, unnumbered_name):\n        \"\"\"Get and merge the `ip unnumbered` config from an interface.\n\n        You should not use this method.\n        You probably want `Interface.ip_unnumbered`.\n\n        Args:\n            unnumbered_type: XML document with the XML to get the donor type.\n            unnumbered_name: XML document with the XML to get the donor name.\n\n        Returns:\n            Merged XML document.\n\n        Raises:\n            None\n        \"\"\"\n        unnumbered_type = self._callback(unnumbered_type, handler='get_config')\n        unnumbered_name = self._callback(unnumbered_name, handler='get_config')\n        unnumbered_type = pynos.utilities.return_xml(str(unnumbered_type))\n        unnumbered_name = pynos.utilities.return_xml(str(unnumbered_name))\n        return pynos.utilities.merge_xml(unnumbered_type, unnumbered_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconfigures an anycast MAC address.", "response": "def anycast_mac(self, **kwargs):\n        \"\"\"Configure an anycast MAC address.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                 tengigabitethernet etc).\n             mac (str): MAC address to configure\n                 (example: '0011.2233.4455').\n            delete (bool): True is the IP address is added and False if its to\n                be deleted (True, False). Default value will be False if not\n                specified.\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                 method.  The only parameter passed to `callback` will be the\n                 ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `mac` is not passed.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.230']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...    conn = (switch, '22')\n            ...    with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...        output = dev.services.vrrp(ip_version='6',\n            ...        enabled=True, rbridge_id='230')\n            ...        output = dev.services.vrrp(enabled=True,\n            ...        rbridge_id='230')\n            ...        output = dev.services.vrrp(ip_version='6',\n            ...        enabled=False, rbridge_id='230')\n            ...        output = dev.services.vrrp(enabled=False,\n            ...        rbridge_id='230')\n            ...        output = dev.interface.anycast_mac(rbridge_id='230',\n            ...        mac='0011.2233.4455')\n            ...        output = dev.interface.anycast_mac(rbridge_id='230',\n            ...        mac='0011.2233.4455', get=True)\n            ...        output = dev.interface.anycast_mac(rbridge_id='230',\n            ...        mac='0011.2233.4455', delete=True)\n            ...        output = dev.services.vrrp(ip_version='6', enabled=True,\n            ...        rbridge_id='230')\n            ...        output = dev.services.vrrp(enabled=True,\n            ...        rbridge_id='230')\n        \"\"\"\n        callback = kwargs.pop('callback', self._callback)\n        anycast_mac = getattr(self._rbridge, 'rbridge_id_ip_static_ag_ip_'\n                              'config_anycast_gateway_mac_ip_anycast_'\n                              'gateway_mac')\n        config = anycast_mac(rbridge_id=kwargs.pop('rbridge_id', '1'),\n                             ip_anycast_gateway_mac=kwargs.pop('mac'))\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        if kwargs.pop('delete', False):\n            config.find('.//*anycast-gateway-mac').set('operation', 'delete')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bfd(self, **kwargs):\n        int_type = str(kwargs.pop('int_type').lower())\n        kwargs['name'] = str(kwargs.pop('name'))\n        kwargs['min_tx'] = kwargs.pop('tx')\n        kwargs['min_rx'] = kwargs.pop('rx')\n        kwargs['delete'] = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['gigabitethernet', 'tengigabitethernet',\n                           'fortygigabitethernet', 'hundredgigabitethernet']\n\n        if int_type not in valid_int_types:\n            raise ValueError('int_type must be one of: %s' %\n                             repr(valid_int_types))\n        kwargs['int_type'] = int_type\n\n        bfd_tx = self._bfd_tx(**kwargs)\n        bfd_rx = self._bfd_rx(**kwargs)\n        bfd_multiplier = self._bfd_multiplier(**kwargs)\n        if kwargs.pop('get', False):\n            return self._get_bfd(bfd_tx, bfd_rx, bfd_multiplier)\n        config = pynos.utilities.merge_xml(bfd_tx, bfd_rx)\n        config = pynos.utilities.merge_xml(config, bfd_multiplier)\n        return callback(config)", "response": "Configure BFD for the given object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the BFD minimum transmit interval XML.", "response": "def _bfd_tx(self, **kwargs):\n        \"\"\"Return the BFD minimum transmit interval XML.\n\n        You should not use this method.\n        You probably want `BGP.bfd`.\n\n        Args:\n            min_tx (str): BFD transmit interval in milliseconds (300, 500, etc)\n            delete (bool): Remove the configuration if ``True``.\n\n        Returns:\n            XML to be passed to the switch.\n\n        Raises:\n            None\n        \"\"\"\n        int_type = kwargs['int_type']\n        method_name = 'interface_%s_bfd_interval_min_tx' % int_type\n        bfd_tx = getattr(self._interface, method_name)\n        config = bfd_tx(**kwargs)\n        if kwargs['delete']:\n            tag = 'min-tx'\n            config.find('.//*%s' % tag).set('operation', 'delete')\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _bfd_rx(self, **kwargs):\n        int_type = kwargs['int_type']\n        method_name = 'interface_%s_bfd_interval_min_rx' % int_type\n        bfd_rx = getattr(self._interface, method_name)\n        config = bfd_rx(**kwargs)\n        if kwargs['delete']:\n            tag = 'min-rx'\n            config.find('.//*%s' % tag).set('operation', 'delete')\n            pass\n        return config", "response": "Return the BFD minimum receive interval XML."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the BFD multiplier XML.", "response": "def _bfd_multiplier(self, **kwargs):\n        \"\"\"Return the BFD multiplier XML.\n\n        You should not use this method.\n        You probably want `BGP.bfd`.\n\n        Args:\n            min_tx (str): BFD transmit interval in milliseconds (300, 500, etc)\n            delete (bool): Remove the configuration if ``True``.\n\n        Returns:\n            XML to be passed to the switch.\n\n        Raises:\n            None\n        \"\"\"\n        int_type = kwargs['int_type']\n        method_name = 'interface_%s_bfd_interval_multiplier' % int_type\n        bfd_multiplier = getattr(self._interface, method_name)\n        config = bfd_multiplier(**kwargs)\n        if kwargs['delete']:\n            tag = 'multiplier'\n            config.find('.//*%s' % tag).set('operation', 'delete')\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vrf(self, **kwargs):\n        rbridge_id = kwargs['rbridge_id']\n        get_config = kwargs.pop('get', False)\n        delete = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        result = []\n        method_class = self._rbridge\n        method_name = 'rbridge_id_vrf_vrf_name'\n        vrf = getattr(method_class, method_name)\n\n        if not get_config:\n            vrf_name = kwargs['vrf_name']\n            vrf_args = dict(rbridge_id=rbridge_id, vrf_name=vrf_name)\n            config = vrf(**vrf_args)\n\n            if delete:\n                config.find('.//*vrf').set('operation', 'delete')\n            result = callback(config)\n\n        elif get_config:\n            vrf_args = dict(rbridge_id=rbridge_id, vrf_name='')\n            config = vrf(**vrf_args)\n            output = callback(config, handler='get_config')\n            for item in output.data.findall('.//{*}vrf'):\n                vrfname = item.find('.//{*}vrf-name').text\n                tmp = {'rbridge_id': rbridge_id, 'vrf_name': vrfname}\n                result.append(tmp)\n        return result", "response": "Create a vrf.\n        Args:\n            vrf_name (str): Name of the vrf (vrf101, vrf-1 etc).\n            get (bool): Get config instead of editing config. (True, False)\n            delete (bool): False, the vrf is created and True if its to\n                be deleted (True, False). Default value will be False if not\n                specified.\n            rbridge_id (str): rbridge-id for device.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n        Returns:\n            Return value of `callback`.\n        Raises:\n            KeyError: if `rbridge_id`,`vrf_name` is not passed.\n            ValueError: if `rbridge_id`, `vrf_name` is invalid.\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.vrf(vrf_name=vrf1,\n            ...         rbridge_id='225')\n            ...         output = dev.interface.vrf(rbridge_id='225',\n            ...         get=True)\n            ...         output = dev.interface.vrf(vrf_name=vrf1,\n            ...         rbridge_id='225',delete=True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vrf_route_distiniguisher(self, **kwargs):\n        rbridge_id = kwargs['rbridge_id']\n        get_config = kwargs.pop('get', False)\n        delete = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        result = []\n\n        method_class = self._rbridge\n        method_name = 'rbridge_id_vrf_route_distiniguisher'\n        vrf_rd = getattr(method_class, method_name)\n\n        if not get_config:\n            vrf_name = kwargs['vrf_name']\n            rd = kwargs['rd']\n            rd_args = dict(rbridge_id=rbridge_id, vrf_name=vrf_name,\n                           route_distiniguisher=rd)\n            config = vrf_rd(**rd_args)\n\n            if delete:\n                config.find('.//*route-distiniguisher').set('operation',\n                                                            'delete')\n            result = callback(config)\n\n        elif get_config:\n            vrf_name = kwargs.pop('vrf_name', '')\n            rd_args = dict(rbridge_id=rbridge_id, vrf_name=vrf_name,\n                           route_distiniguisher='')\n            config = vrf_rd(**rd_args)\n            output = callback(config, handler='get_config')\n            for item in output.data.findall('.//{*}vrf'):\n                vrfname = item.find('.//{*}vrf-name').text\n                if item.find('.//{*}route-distiniguisher') is not None:\n                    vrfrd = item.find('.//{*}route-distiniguisher').text\n                else:\n                    vrfrd = ''\n\n                tmp = {'rbridge_id': rbridge_id, 'vrf_name': vrfname,\n                       'rd': vrfrd}\n                result.append(tmp)\n        return result", "response": "Configure Route distiniguisher for a given BGP entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconfiguring Layer 3 VNI under vrf.", "response": "def vrf_l3vni(self, **kwargs):\n        \"\"\"Configure Layer3 vni under vrf.\n        Args:\n            rbridge_id (str): rbridge-id for device.\n            vrf_name (str): Name of the vrf (vrf101, vrf-1 etc).\n            l3vni (str): <NUMBER:1-16777215>   Layer 3 VNI.\n            get (bool): Get config instead of editing config. (True, False)\n            delete (bool): False the L3 vni is configured and True if its to\n                be deleted (True, False). Default value will be False if not\n                specified.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n        Returns:\n            Return value of `callback`.\n        Raises:\n            KeyError: if `rbridge_id`,`vrf_name`, 'l3vni' is not passed.\n            ValueError: if `rbridge_id`, `vrf_name`, 'l3vni'  is invalid.\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.vrf_vni(\n            ...         vrf_name=vrf1, rbridge_id='2', l3vni ='7201')\n            ...         output = dev.interface.vrf_vni(rbridge_id='2',\n            ...         get=True)\n            ...         output = dev.interface.vrf_vni(rbridge_id='2',\n            ...         , vrf_name='vrf2' get=True)\n            ...         output = dev.interface.vrf_vni(vrf_name=vrf1,\n            ...         rbridge_id='2', l3vni ='7201', delete=True)\n\n        \"\"\"\n        rbridge_id = kwargs['rbridge_id']\n        get_config = kwargs.pop('get', False)\n        delete = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        result = []\n\n        method_class = self._rbridge\n        method_name = 'rbridge_id_vrf_vni'\n        vrf_vni = getattr(method_class, method_name)\n\n        if not get_config:\n            vrf_name = kwargs['vrf_name']\n            l3vni = kwargs['l3vni']\n            vni_args = dict(rbridge_id=rbridge_id, vrf_name=vrf_name,\n                            vni=l3vni)\n            config = vrf_vni(**vni_args)\n\n            if delete:\n                config.find('.//*vni').set('operation', 'delete')\n            result = callback(config)\n\n        elif get_config:\n            vrf_name = kwargs.pop('vrf_name', '')\n            vni_args = dict(rbridge_id=rbridge_id, vrf_name=vrf_name,\n                            vni='')\n            config = vrf_vni(**vni_args)\n            output = callback(config, handler='get_config')\n            for item in output.data.findall('.//{*}vrf'):\n                vrfname = item.find('.//{*}vrf-name').text\n                if item.find('.//{*}vni') is not None:\n                    vrfvni = item.find('.//{*}vni').text\n                else:\n                    vrfvni = ''\n\n                tmp = {'rbridge_id': rbridge_id, 'vrf_name': vrfname,\n                       'l3vni': vrfvni}\n                result.append(tmp)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconfiguring VPN Extended Community for a specific route - target.", "response": "def vrf_afi_rt_evpn(self, **kwargs):\n        \"\"\"Configure Target VPN Extended Communities\n        Args:\n            rbridge_id (str): rbridge-id for device.\n            vrf_name (str): Name of the vrf (vrf101, vrf-1 etc).\n            rt (str): Route Target(import/export/both).\n            rt_value (str): Route Target Value  ASN:nn Target\n                            VPN Extended Community.\n            afi (str): Address family (ip/ipv6).\n            get (bool): Get config instead of editing config.\n                        List all the details of\n                        all afi under all vrf(True, False)\n            delete_rt (bool): True to delete the route-target under\n                              address family (True, False).\n                              Default value will be False if not\n                              specified.\n            delete_afi (bool): True to delet the ip/ipv6 address family\n                Default value will be False if not specified.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n        Returns:\n            Return value of `callback`.\n        Raises:\n            KeyError: if `rbridge_id`,`vrf_name`, 'afi', 'rt', 'rt_value'\n                      is not passed.\n            ValueError: if `rbridge_id`, `vrf_name`, 'afi', 'rt', rt_value\n                        is invalid.\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.vrf_vni(rbridge_id=\"1\",\n            ...         afi=\"ip\", rt='import', rt_value='101:101',\n            ...         vrf_name=\"vrf1\")\n            ...         output = dev.interface.vrf_vni(rbridge_id=\"1\",\n            ...         afi=\"ip\", rt='import', rt_value='101:101',\n            ...         vrf_name=\"vrf1\",delete_rt=True)\n            ...         output = dev.interface.vrf_vni(rbridge_id=\"1\",\n            ...         afi=\"ip\", rt='import', rt_value='101:101',\n            ...         vrf_name=\"vrf1\",delete_afi=True)\n            ...         output = dev.interface.vrf_vni(rbridge_id=\"1\",\n            ...         afi=\"ip\", get=True)\n            ...         output = dev.interface.vrf_vni(rbridge_id=\"1\",\n            ...         afi=\"ip\", vrf_name=\"vrf2\", get=True)\n\n        \"\"\"\n        rbridge_id = kwargs['rbridge_id']\n        afi = kwargs['afi']\n        get_config = kwargs.pop('get', False)\n        delete_rt = kwargs.pop('delete_rt', False)\n        delete_afi = kwargs.pop('delete_afi', False)\n        callback = kwargs.pop('callback', self._callback)\n        result = []\n\n        method_class = self._rbridge\n        method_name = 'rbridge_id_vrf_address_family_%s_unicast_' \\\n                      'route_target_evpn' % afi\n        vrf_rt = getattr(method_class, method_name)\n\n        if not get_config:\n            vrf_name = kwargs['vrf_name']\n            rt = kwargs['rt']\n            rt_value = kwargs['rt_value']\n            rt_args = dict(rbridge_id=rbridge_id, vrf_name=vrf_name,\n                           action=rt, target_community=rt_value)\n            config = vrf_rt(**rt_args)\n\n            if delete_afi is True:\n                if config.find('.//*ipv6') is not None:\n                    config.find('.//*ipv6').set('operation', 'delete')\n                if config.find('.//*ip') is not None:\n                    config.find('.//*ip').set('operation', 'delete')\n            if delete_rt is True:\n                config.find('.//*route-target').set('operation', 'delete')\n            result = callback(config)\n\n        elif get_config:\n            vrf_name = kwargs.pop('vrf_name', '')\n\n            rt_args = dict(rbridge_id=rbridge_id, vrf_name=vrf_name,\n                           action='', target_community='')\n            config = vrf_rt(**rt_args)\n            output = callback(config, handler='get_config')\n            for vrf_node in output.data.findall('.//{*}vrf'):\n                afi = ''\n                vrfrt = []\n                vrfrtval = []\n                vrfname = vrf_node.find('.//{*}vrf-name').text\n                if vrf_node.find('.//{*}ip') is not None:\n                    afi = \"ip\"\n                    if vrf_node.find('.//{*}route-target') is not None:\n                        for ipv4_action in vrf_node.findall('.//{*}action'):\n                            rttemp = ipv4_action.text\n                            vrfrt.append(rttemp)\n                        for ipv4_rt in vrf_node.findall('.//{'\n                                                        '*}target-community'):\n                            valtemp = ipv4_rt.text\n                            vrfrtval.append(valtemp)\n                if vrf_node.find('.//{*}ipv6') is not None:\n                    afi = \"ipv6\"\n                    if vrf_node.find('.//{*}route-target') is not None:\n                        for ipv6_action in vrf_node.findall('.//{*}action'):\n                            rttemp = ipv6_action.text\n                            vrfrt.append(rttemp)\n                        for ipv6_rt in vrf_node.findall('.//{'\n                                                        '*}target-community'):\n                            valtemp = ipv6_rt.text\n                            vrfrtval.append(valtemp)\n\n                tmp = {'rbridge_id': rbridge_id, 'vrf_name': vrfname,\n                       'afi': afi, 'rt': vrfrt, 'rtvalue': vrfrtval}\n                result.append(tmp)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nenable conversational arp learning on VDX switches.", "response": "def conversational_arp(self, **kwargs):\n        \"\"\"Enable conversational arp learning on VDX switches\n\n        Args:\n            rbridge_id (str): rbridge-id for device.\n            get (bool): Get config instead of editing config. (True, False)\n            delete (bool): True, delete the conversation arp learning.\n                          (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n        Returns:\n            Return value of `callback`.\n        Raises:\n            KeyError: if `rbridge_id` is not passed.\n            ValueError: if `rbridge_id` is invalid.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.211', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.interface.conversational_arp(rbridge_id=\"1\")\n            ...     output = dev.interface.conversational_arp(rbridge_id=\"1\",\n                             get=True)\n            ...     output = dev.interface.conversational_arp(rbridge_id=\"1\",\n                             delete=True)\n        \"\"\"\n\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        arp_config = getattr(self._rbridge,\n                             'rbridge_id_host_table_aging_mode_conversational')\n\n        arp_args = dict(rbridge_id=rbridge_id)\n        config = arp_config(**arp_args)\n        if kwargs.pop('get', False):\n            output = callback(config, handler='get_config')\n            item = output.data.find('.//{*}aging-mode')\n            if item is not None:\n                return True\n            else:\n                return None\n        if kwargs.pop('delete', False):\n            config.find('.//*aging-mode').set('operation', 'delete')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ip_anycast_gateway(self, **kwargs):\n\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        anycast_ip = kwargs.pop('anycast_ip', '')\n        enable = kwargs.pop('enable', True)\n        get = kwargs.pop('get', False)\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['ve']\n        method_class = self._rbridge\n        if get and anycast_ip == '':\n            enable = None\n            if int_type not in valid_int_types:\n                raise ValueError('`int_type` must be one of: %s' %\n                                 repr(valid_int_types))\n            anycast_args = dict(name=name, ip_address=anycast_ip,\n                                ipv6_address=anycast_ip)\n            method_name1 = 'interface_%s_ip_ip_anycast_'\\\n                           'address_ip_address' % int_type\n            method_name2 = 'interface_%s_ipv6_ipv6_'\\\n                           'anycast_address_ipv6_address' % int_type\n            method_name1 = 'rbridge_id_%s' % method_name1\n            method_name2 = 'rbridge_id_%s' % method_name2\n            anycast_args['rbridge_id'] = rbridge_id\n            if not pynos.utilities.valid_vlan_id(name):\n                raise InvalidVlanId(\"`name` must be between `1` and `8191`\")\n            ip_anycast_gateway1 = getattr(method_class, method_name1)\n            ip_anycast_gateway2 = getattr(method_class, method_name2)\n            config1 = ip_anycast_gateway1(**anycast_args)\n            config2 = ip_anycast_gateway2(**anycast_args)\n            result = []\n            result.append(callback(config1, handler='get_config'))\n            result.append(callback(config2, handler='get_config'))\n            return result\n        elif get:\n            enable = None\n        ipaddress = ip_interface(unicode(anycast_ip))\n        if int_type not in valid_int_types:\n            raise ValueError('`int_type` must be one of: %s' %\n                             repr(valid_int_types))\n        if anycast_ip != '':\n            ipaddress = ip_interface(unicode(anycast_ip))\n            if ipaddress.version == 4:\n                anycast_args = dict(name=name, ip_address=anycast_ip)\n                method_name = 'interface_%s_ip_ip_anycast_'\\\n                              'address_ip_address' % int_type\n            elif ipaddress.version == 6:\n                anycast_args = dict(name=name, ipv6_address=anycast_ip)\n                method_name = 'interface_%s_ipv6_ipv6_'\\\n                              'anycast_address_ipv6_address' % int_type\n        method_name = 'rbridge_id_%s' % method_name\n        anycast_args['rbridge_id'] = rbridge_id\n        if not pynos.utilities.valid_vlan_id(name):\n                raise InvalidVlanId(\"`name` must be between `1` and `8191`\")\n        ip_anycast_gateway = getattr(method_class, method_name)\n        config = ip_anycast_gateway(**anycast_args)\n        if get:\n            return callback(config, handler='get_config')\n        if not enable:\n            if ipaddress.version == 4:\n                config.find('.//*ip-anycast-address').\\\n                    set('operation', 'delete')\n            elif ipaddress.version == 6:\n                config.find('.//*ipv6-anycast-address').\\\n                    set('operation', 'delete')\n        return callback(config)", "response": "Add anycast gateway under interface ve."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef arp_suppression(self, **kwargs):\n\n        name = kwargs.pop('name')\n        enable = kwargs.pop('enable', True)\n        get = kwargs.pop('get', False)\n        callback = kwargs.pop('callback', self._callback)\n        method_class = self._interface\n        arp_args = dict(name=name)\n        if name:\n            if not pynos.utilities.valid_vlan_id(name):\n                raise InvalidVlanId(\"`name` must be between `1` and `8191`\")\n        arp_suppression = getattr(method_class,\n                                  'interface_vlan_interface_vlan_suppress_'\n                                  'arp_suppress_arp_enable')\n        config = arp_suppression(**arp_args)\n        if get:\n            return callback(config, handler='get_config')\n        if not enable:\n                config.find('.//*suppress-arp').set('operation', 'delete')\n        return callback(config)", "response": "Enable Arp Suppression on a Vlan."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef evpn_instance_mac_timer_max_count(self, **kwargs):\n\n        evpn_instance_name = kwargs.pop('evpn_instance_name', '')\n        max_count = kwargs.pop('max_count', '5')\n        enable = kwargs.pop('enable', True)\n        get = kwargs.pop('get', False)\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        evpn_args = dict(instance_name=evpn_instance_name,\n                         max_count=max_count)\n        if get:\n            enable = None\n        method_name = 'rbridge_id_evpn_instance_duplicate_'\\\n                      'mac_timer_max_count'\n        method_class = self._rbridge\n        evpn_args['rbridge_id'] = rbridge_id\n        evpn_instance_mac_timer_max_count = getattr(method_class, method_name)\n        config = evpn_instance_mac_timer_max_count(**evpn_args)\n        if get:\n            return callback(config, handler='get_config')\n        if not enable:\n            config.find('.//*duplicate-mac-timer').set('operation', 'delete')\n        return callback(config)", "response": "Adds a duplicate MAC max count to an evpn instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef evpn_instance_rd_auto(self, **kwargs):\n\n        \"\"\"\n        Add RD auto under EVPN instance.\n\n        Args:\n            rbridge_id: Rbrdige id .\n            instance_name: EVPN instance name.\n\n        Returns:\n            True if command completes successfully or False if not.\n\n        Raises:\n            None\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output=dev.interface.evpn_instance_rd_auto(\n            ...         evpn_instance_name='100',\n            ...         rbridge_id='1')\n         \"\"\"\n        config = ET.Element(\"config\")\n        rbridge_id = ET.SubElement(config, \"rbridge-id\",\n                                   xmlns=\"urn:brocade.com\"\n                                         \":mgmt:brocade-rbridge\")\n        rbridge_id_key = ET.SubElement(rbridge_id, \"rbridge-id\")\n        rbridge_id_key.text = kwargs.pop('rbridge_id')\n        evpn_instance = ET.SubElement(rbridge_id, \"evpn-instance\",\n                                      xmlns=\"urn:brocade.com:mgmt:brocade-bgp\")\n        instance_name_key = ET.SubElement(evpn_instance, \"instance-name\")\n        instance_name_key.text = kwargs.pop('instance_name')\n        route_distinguisher = ET.SubElement(evpn_instance,\n                                            \"route-distinguisher\")\n        ET.SubElement(route_distinguisher, \"auto\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Add RD auto under EVPN instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mac_move_detect_enable(self, **kwargs):\n\n        callback = kwargs.pop('callback', self._callback)\n        mac_move = getattr(self._mac_address_table,\n                           'mac_address_table_mac_move_mac_move_'\n                           'detect_enable')\n\n        config = mac_move()\n        if kwargs.pop('get', False):\n            output = callback(config, handler='get_config')\n            item = output.data.find('.//{*}mac-move-detect-enable')\n            if item is not None:\n                return True\n            else:\n                return None\n        if kwargs.pop('delete', False):\n            config.find('.//*mac-move-detect-enable').set('operation',\n                                                          'delete')\n        return callback(config)", "response": "Enable mac move detect on vdx switches\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mac_move_limit(self, **kwargs):\n\n        callback = kwargs.pop('callback', self._callback)\n        get_config = kwargs.pop('get', False)\n        delete = kwargs.pop('delete', False)\n        if not get_config:\n            if not delete:\n                mac_move_limit = kwargs.pop('mac_move_limit')\n                mac_move = getattr(self._mac_address_table,\n                                   'mac_address_table_mac_move_'\n                                   'mac_move_limit')\n                config = mac_move(mac_move_limit=mac_move_limit)\n            else:\n                mac_move = getattr(self._mac_address_table,\n                                   'mac_address_table_mac_move_'\n                                   'mac_move_limit')\n                config = mac_move(mac_move_limit='')\n                config.find('.//*mac-move-limit').set('operation',\n                                                      'delete')\n            return callback(config)\n\n        if get_config:\n            mac_move = getattr(self._mac_address_table,\n                               'mac_address_table_mac_move_mac'\n                               '_move_limit')\n            config = mac_move(mac_move_limit='')\n            output = callback(config, handler='get_config')\n            if output.data.find('.//{*}mac-move-limit') is not None:\n                limit = output.data.find('.//{*}mac-move-limit').text\n                if limit is not None:\n                    return limit\n                else:\n                    return None\n            else:\n                limit_default = \"20\"\n                return limit_default", "response": "Configure the limit of mac move on vdx switches\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the configuration of linkinfo input and all.", "response": "def show_linkinfo_input_all(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_linkinfo = ET.Element(\"show_linkinfo\")\n        config = show_linkinfo\n        input = ET.SubElement(show_linkinfo, \"input\")\n        all = ET.SubElement(input, \"all\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_linkinfo_output_show_link_info_linkinfo_rbridgeid(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_linkinfo = ET.Element(\"show_linkinfo\")\n        config = show_linkinfo\n        output = ET.SubElement(show_linkinfo, \"output\")\n        show_link_info = ET.SubElement(output, \"show-link-info\")\n        linkinfo_rbridgeid = ET.SubElement(show_link_info, \"linkinfo-rbridgeid\")\n        linkinfo_rbridgeid.text = kwargs.pop('linkinfo_rbridgeid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Link Info output with linkinfo - rbridgeid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing Link Info output for a specific resource.", "response": "def show_linkinfo_output_show_link_info_linkinfo_domain_reachable(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_linkinfo = ET.Element(\"show_linkinfo\")\n        config = show_linkinfo\n        output = ET.SubElement(show_linkinfo, \"output\")\n        show_link_info = ET.SubElement(output, \"show-link-info\")\n        linkinfo_rbridgeid_key = ET.SubElement(show_link_info, \"linkinfo-rbridgeid\")\n        linkinfo_rbridgeid_key.text = kwargs.pop('linkinfo_rbridgeid')\n        linkinfo_domain_reachable = ET.SubElement(show_link_info, \"linkinfo-domain-reachable\")\n        linkinfo_domain_reachable.text = kwargs.pop('linkinfo_domain_reachable')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing Link Info output for a specific resource.", "response": "def show_linkinfo_output_show_link_info_linkinfo_wwn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_linkinfo = ET.Element(\"show_linkinfo\")\n        config = show_linkinfo\n        output = ET.SubElement(show_linkinfo, \"output\")\n        show_link_info = ET.SubElement(output, \"show-link-info\")\n        linkinfo_rbridgeid_key = ET.SubElement(show_link_info, \"linkinfo-rbridgeid\")\n        linkinfo_rbridgeid_key.text = kwargs.pop('linkinfo_rbridgeid')\n        linkinfo_wwn = ET.SubElement(show_link_info, \"linkinfo-wwn\")\n        linkinfo_wwn.text = kwargs.pop('linkinfo_wwn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_linkinfo_output_show_link_info_linkinfo_version(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_linkinfo = ET.Element(\"show_linkinfo\")\n        config = show_linkinfo\n        output = ET.SubElement(show_linkinfo, \"output\")\n        show_link_info = ET.SubElement(output, \"show-link-info\")\n        linkinfo_rbridgeid_key = ET.SubElement(show_link_info, \"linkinfo-rbridgeid\")\n        linkinfo_rbridgeid_key.text = kwargs.pop('linkinfo_rbridgeid')\n        linkinfo_version = ET.SubElement(show_link_info, \"linkinfo-version\")\n        linkinfo_version.text = kwargs.pop('linkinfo_version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Link Info output for a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_linkinfo_output_show_link_info_linkinfo_isl_linkinfo_isl_linknumber(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_linkinfo = ET.Element(\"show_linkinfo\")\n        config = show_linkinfo\n        output = ET.SubElement(show_linkinfo, \"output\")\n        show_link_info = ET.SubElement(output, \"show-link-info\")\n        linkinfo_rbridgeid_key = ET.SubElement(show_link_info, \"linkinfo-rbridgeid\")\n        linkinfo_rbridgeid_key.text = kwargs.pop('linkinfo_rbridgeid')\n        linkinfo_isl = ET.SubElement(show_link_info, \"linkinfo-isl\")\n        linkinfo_isl_linknumber = ET.SubElement(linkinfo_isl, \"linkinfo-isl-linknumber\")\n        linkinfo_isl_linknumber.text = kwargs.pop('linkinfo_isl_linknumber')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Link Info output for ILS Link Number"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing Link Info output for ILS Link Information Link", "response": "def show_linkinfo_output_show_link_info_linkinfo_isl_linkinfo_isllink_destdomain(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_linkinfo = ET.Element(\"show_linkinfo\")\n        config = show_linkinfo\n        output = ET.SubElement(show_linkinfo, \"output\")\n        show_link_info = ET.SubElement(output, \"show-link-info\")\n        linkinfo_rbridgeid_key = ET.SubElement(show_link_info, \"linkinfo-rbridgeid\")\n        linkinfo_rbridgeid_key.text = kwargs.pop('linkinfo_rbridgeid')\n        linkinfo_isl = ET.SubElement(show_link_info, \"linkinfo-isl\")\n        linkinfo_isl_linknumber_key = ET.SubElement(linkinfo_isl, \"linkinfo-isl-linknumber\")\n        linkinfo_isl_linknumber_key.text = kwargs.pop('linkinfo_isl_linknumber')\n        linkinfo_isllink_destdomain = ET.SubElement(linkinfo_isl, \"linkinfo-isllink-destdomain\")\n        linkinfo_isllink_destdomain.text = kwargs.pop('linkinfo_isllink_destdomain')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget show portindex interface info input all", "response": "def show_portindex_interface_info_input_all(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_portindex_interface_info = ET.Element(\"show_portindex_interface_info\")\n        config = show_portindex_interface_info\n        input = ET.SubElement(show_portindex_interface_info, \"input\")\n        all = ET.SubElement(input, \"all\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets show_portindex_interface_info output of show_portindex_interface", "response": "def show_portindex_interface_info_output_show_portindex_interface_portsgroup_rbridgeid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_portindex_interface_info = ET.Element(\"show_portindex_interface_info\")\n        config = show_portindex_interface_info\n        output = ET.SubElement(show_portindex_interface_info, \"output\")\n        show_portindex_interface = ET.SubElement(output, \"show-portindex-interface\")\n        portsgroup_rbridgeid = ET.SubElement(show_portindex_interface, \"portsgroup-rbridgeid\")\n        portsgroup_rbridgeid.text = kwargs.pop('portsgroup_rbridgeid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget Show PortIndex Interface info output for a specific class.", "response": "def show_portindex_interface_info_output_show_portindex_interface_show_portindex_port_index(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_portindex_interface_info = ET.Element(\"show_portindex_interface_info\")\n        config = show_portindex_interface_info\n        output = ET.SubElement(show_portindex_interface_info, \"output\")\n        show_portindex_interface = ET.SubElement(output, \"show-portindex-interface\")\n        portsgroup_rbridgeid_key = ET.SubElement(show_portindex_interface, \"portsgroup-rbridgeid\")\n        portsgroup_rbridgeid_key.text = kwargs.pop('portsgroup_rbridgeid')\n        show_portindex = ET.SubElement(show_portindex_interface, \"show-portindex\")\n        port_index = ET.SubElement(show_portindex, \"port-index\")\n        port_index.text = kwargs.pop('port_index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_portindex_interface_info_output_show_portindex_interface_show_portindex_port_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_portindex_interface_info = ET.Element(\"show_portindex_interface_info\")\n        config = show_portindex_interface_info\n        output = ET.SubElement(show_portindex_interface_info, \"output\")\n        show_portindex_interface = ET.SubElement(output, \"show-portindex-interface\")\n        portsgroup_rbridgeid_key = ET.SubElement(show_portindex_interface, \"portsgroup-rbridgeid\")\n        portsgroup_rbridgeid_key.text = kwargs.pop('portsgroup_rbridgeid')\n        show_portindex = ET.SubElement(show_portindex_interface, \"show-portindex\")\n        port_index_key = ET.SubElement(show_portindex, \"port-index\")\n        port_index_key.text = kwargs.pop('port_index')\n        port_type = ET.SubElement(show_portindex, \"port-type\")\n        port_type.text = kwargs.pop('port_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Show PortIndex Interface Information output for a specific class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_fibrechannel_interface_info_input_all(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_fibrechannel_interface_info = ET.Element(\"show_fibrechannel_interface_info\")\n        config = show_fibrechannel_interface_info\n        input = ET.SubElement(show_fibrechannel_interface_info, \"input\")\n        all = ET.SubElement(input, \"all\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FibreChannel Interface Info input all."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget FibreChannel Channel Info output for specific FibreChannel Interface and Portsgroup Id.", "response": "def show_fibrechannel_interface_info_output_show_fibrechannel_interface_portsgroup_rbridgeid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_fibrechannel_interface_info = ET.Element(\"show_fibrechannel_interface_info\")\n        config = show_fibrechannel_interface_info\n        output = ET.SubElement(show_fibrechannel_interface_info, \"output\")\n        show_fibrechannel_interface = ET.SubElement(output, \"show-fibrechannel-interface\")\n        portsgroup_rbridgeid = ET.SubElement(show_fibrechannel_interface, \"portsgroup-rbridgeid\")\n        portsgroup_rbridgeid.text = kwargs.pop('portsgroup_rbridgeid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget show fibrechannel_interface output.", "response": "def show_fibrechannel_interface_info_output_show_fibrechannel_interface_show_fibrechannel_info_port_interface(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_fibrechannel_interface_info = ET.Element(\"show_fibrechannel_interface_info\")\n        config = show_fibrechannel_interface_info\n        output = ET.SubElement(show_fibrechannel_interface_info, \"output\")\n        show_fibrechannel_interface = ET.SubElement(output, \"show-fibrechannel-interface\")\n        portsgroup_rbridgeid_key = ET.SubElement(show_fibrechannel_interface, \"portsgroup-rbridgeid\")\n        portsgroup_rbridgeid_key.text = kwargs.pop('portsgroup_rbridgeid')\n        show_fibrechannel_info = ET.SubElement(show_fibrechannel_interface, \"show-fibrechannel-info\")\n        port_index_key = ET.SubElement(show_fibrechannel_info, \"port-index\")\n        port_index_key.text = kwargs.pop('port_index')\n        port_interface = ET.SubElement(show_fibrechannel_info, \"port-interface\")\n        port_interface.text = kwargs.pop('port_interface')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets show fibrechannel info output for a specific class.", "response": "def show_fibrechannel_interface_info_output_show_fibrechannel_interface_show_fibrechannel_info_port_index(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_fibrechannel_interface_info = ET.Element(\"show_fibrechannel_interface_info\")\n        config = show_fibrechannel_interface_info\n        output = ET.SubElement(show_fibrechannel_interface_info, \"output\")\n        show_fibrechannel_interface = ET.SubElement(output, \"show-fibrechannel-interface\")\n        portsgroup_rbridgeid_key = ET.SubElement(show_fibrechannel_interface, \"portsgroup-rbridgeid\")\n        portsgroup_rbridgeid_key.text = kwargs.pop('portsgroup_rbridgeid')\n        show_fibrechannel_info = ET.SubElement(show_fibrechannel_interface, \"show-fibrechannel-info\")\n        port_index = ET.SubElement(show_fibrechannel_info, \"port-index\")\n        port_index.text = kwargs.pop('port_index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_fabric_trunk_info_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        input = ET.SubElement(show_fabric_trunk_info, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Fabric Trunk Info input rbridge - id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_fabric_trunk_info_output_show_trunk_list_trunk_list_groups_trunk_list_group(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        output = ET.SubElement(show_fabric_trunk_info, \"output\")\n        show_trunk_list = ET.SubElement(output, \"show-trunk-list\")\n        trunk_list_groups = ET.SubElement(show_trunk_list, \"trunk-list-groups\")\n        trunk_list_group = ET.SubElement(trunk_list_groups, \"trunk-list-group\")\n        trunk_list_group.text = kwargs.pop('trunk_list_group')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Troubleshoot List Troubleshoot List Trunk List Groups Troubleshoot List Group"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_fabric_trunk_info_output_show_trunk_list_trunk_list_groups_trunk_list_member_trunk_list_src_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        output = ET.SubElement(show_fabric_trunk_info, \"output\")\n        show_trunk_list = ET.SubElement(output, \"show-trunk-list\")\n        trunk_list_groups = ET.SubElement(show_trunk_list, \"trunk-list-groups\")\n        trunk_list_member = ET.SubElement(trunk_list_groups, \"trunk-list-member\")\n        trunk_list_src_port = ET.SubElement(trunk_list_member, \"trunk-list-src-port\")\n        trunk_list_src_port.text = kwargs.pop('trunk_list_src_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a Troubleshoot Fabric Troubleshoot List"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the config of a Troubleshoot Fabric Troubleshoot List", "response": "def show_fabric_trunk_info_output_show_trunk_list_trunk_list_groups_trunk_list_member_trunk_list_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        output = ET.SubElement(show_fabric_trunk_info, \"output\")\n        show_trunk_list = ET.SubElement(output, \"show-trunk-list\")\n        trunk_list_groups = ET.SubElement(show_trunk_list, \"trunk-list-groups\")\n        trunk_list_member = ET.SubElement(trunk_list_groups, \"trunk-list-member\")\n        trunk_list_interface_type = ET.SubElement(trunk_list_member, \"trunk-list-interface-type\")\n        trunk_list_interface_type.text = kwargs.pop('trunk_list_interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_fabric_trunk_info_output_show_trunk_list_trunk_list_groups_trunk_list_member_trunk_list_src_interface(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        output = ET.SubElement(show_fabric_trunk_info, \"output\")\n        show_trunk_list = ET.SubElement(output, \"show-trunk-list\")\n        trunk_list_groups = ET.SubElement(show_trunk_list, \"trunk-list-groups\")\n        trunk_list_member = ET.SubElement(trunk_list_groups, \"trunk-list-member\")\n        trunk_list_src_interface = ET.SubElement(trunk_list_member, \"trunk-list-src-interface\")\n        trunk_list_src_interface.text = kwargs.pop('trunk_list_src_interface')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Troubleshoot List Troubleshoot Groups Troubleshoot List Member Troubleshoot Source Interface."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_fabric_trunk_info_output_show_trunk_list_trunk_list_groups_trunk_list_member_trunk_list_nbr_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        output = ET.SubElement(show_fabric_trunk_info, \"output\")\n        show_trunk_list = ET.SubElement(output, \"show-trunk-list\")\n        trunk_list_groups = ET.SubElement(show_trunk_list, \"trunk-list-groups\")\n        trunk_list_member = ET.SubElement(trunk_list_groups, \"trunk-list-member\")\n        trunk_list_nbr_rbridge_id = ET.SubElement(trunk_list_member, \"trunk-list-nbr-rbridge-id\")\n        trunk_list_nbr_rbridge_id.text = kwargs.pop('trunk_list_nbr_rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Fabric Trunk List Members and Trunk List NBR rbridge ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_fabric_trunk_info_output_show_trunk_list_trunk_list_groups_trunk_list_member_trunk_list_nbr_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        output = ET.SubElement(show_fabric_trunk_info, \"output\")\n        show_trunk_list = ET.SubElement(output, \"show-trunk-list\")\n        trunk_list_groups = ET.SubElement(show_trunk_list, \"trunk-list-groups\")\n        trunk_list_member = ET.SubElement(trunk_list_groups, \"trunk-list-member\")\n        trunk_list_nbr_port = ET.SubElement(trunk_list_member, \"trunk-list-nbr-port\")\n        trunk_list_nbr_port.text = kwargs.pop('trunk_list_nbr_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a Troubleshoot Fabric Troubleshoot List"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_fabric_trunk_info_output_show_trunk_list_trunk_list_groups_trunk_list_member_trunk_list_nbr_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        output = ET.SubElement(show_fabric_trunk_info, \"output\")\n        show_trunk_list = ET.SubElement(output, \"show-trunk-list\")\n        trunk_list_groups = ET.SubElement(show_trunk_list, \"trunk-list-groups\")\n        trunk_list_member = ET.SubElement(trunk_list_groups, \"trunk-list-member\")\n        trunk_list_nbr_interface_type = ET.SubElement(trunk_list_member, \"trunk-list-nbr-interface-type\")\n        trunk_list_nbr_interface_type.text = kwargs.pop('trunk_list_nbr_interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a Troubleshoot List of Trunk List Groups and Trunk List Member."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the config of a Troubleshoot Fabric Troubleshoot List", "response": "def show_fabric_trunk_info_output_show_trunk_list_trunk_list_groups_trunk_list_member_trunk_list_nbr_interface(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        output = ET.SubElement(show_fabric_trunk_info, \"output\")\n        show_trunk_list = ET.SubElement(output, \"show-trunk-list\")\n        trunk_list_groups = ET.SubElement(show_trunk_list, \"trunk-list-groups\")\n        trunk_list_member = ET.SubElement(trunk_list_groups, \"trunk-list-member\")\n        trunk_list_nbr_interface = ET.SubElement(trunk_list_member, \"trunk-list-nbr-interface\")\n        trunk_list_nbr_interface.text = kwargs.pop('trunk_list_nbr_interface')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_fabric_trunk_info_output_show_trunk_list_trunk_list_groups_trunk_list_member_trunk_list_nbr_wwn(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        output = ET.SubElement(show_fabric_trunk_info, \"output\")\n        show_trunk_list = ET.SubElement(output, \"show-trunk-list\")\n        trunk_list_groups = ET.SubElement(show_trunk_list, \"trunk-list-groups\")\n        trunk_list_member = ET.SubElement(trunk_list_groups, \"trunk-list-member\")\n        trunk_list_nbr_wwn = ET.SubElement(trunk_list_member, \"trunk-list-nbr-wwn\")\n        trunk_list_nbr_wwn.text = kwargs.pop('trunk_list_nbr_wwn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Troubleshoot List Troubleshoot Groups Troubleshoot Member Troubleshoot List NBR WWN."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing Troubleshoot List Troubleshooting Groups Troubleshooting Member Troubleshooting Is Primary", "response": "def show_fabric_trunk_info_output_show_trunk_list_trunk_list_groups_trunk_list_member_trunk_list_is_primary(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        output = ET.SubElement(show_fabric_trunk_info, \"output\")\n        show_trunk_list = ET.SubElement(output, \"show-trunk-list\")\n        trunk_list_groups = ET.SubElement(show_trunk_list, \"trunk-list-groups\")\n        trunk_list_member = ET.SubElement(trunk_list_groups, \"trunk-list-member\")\n        trunk_list_is_primary = ET.SubElement(trunk_list_member, \"trunk-list-is-primary\")\n        trunk_list_is_primary.text = kwargs.pop('trunk_list_is_primary')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the configuration of a resource from the fabric route mcast and rbridge - id.", "response": "def fabric_route_mcast_rbridge_id_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fabric = ET.SubElement(config, \"fabric\", xmlns=\"urn:brocade.com:mgmt:brocade-fabric-service\")\n        route = ET.SubElement(fabric, \"route\")\n        mcast = ET.SubElement(route, \"mcast\")\n        rbridge_id = ET.SubElement(mcast, \"rbridge-id\")\n        rbridge_id = ET.SubElement(rbridge_id, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the configuration of a resource from a route mcast rbridge id and priority.", "response": "def fabric_route_mcast_rbridge_id_priority(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fabric = ET.SubElement(config, \"fabric\", xmlns=\"urn:brocade.com:mgmt:brocade-fabric-service\")\n        route = ET.SubElement(fabric, \"route\")\n        mcast = ET.SubElement(route, \"mcast\")\n        rbridge_id = ET.SubElement(mcast, \"rbridge-id\")\n        rbridge_id_key = ET.SubElement(rbridge_id, \"rbridge-id\")\n        rbridge_id_key.text = kwargs.pop('rbridge_id')\n        priority = ET.SubElement(rbridge_id, \"priority\")\n        priority.text = kwargs.pop('priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget config input source config source candidate candidate", "response": "def get_config_input_source_config_source_candidate_candidate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_config = ET.Element(\"get_config\")\n        config = get_config\n        input = ET.SubElement(get_config, \"input\")\n        source = ET.SubElement(input, \"source\")\n        config_source = ET.SubElement(source, \"config-source\")\n        candidate = ET.SubElement(config_source, \"candidate\")\n        candidate = ET.SubElement(candidate, \"candidate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting config input source config source running running", "response": "def get_config_input_source_config_source_running_running(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_config = ET.Element(\"get_config\")\n        config = get_config\n        input = ET.SubElement(get_config, \"input\")\n        source = ET.SubElement(input, \"source\")\n        config_source = ET.SubElement(source, \"config-source\")\n        running = ET.SubElement(config_source, \"running\")\n        running = ET.SubElement(running, \"running\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting config input source config source startup startup", "response": "def get_config_input_source_config_source_startup_startup(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_config = ET.Element(\"get_config\")\n        config = get_config\n        input = ET.SubElement(get_config, \"input\")\n        source = ET.SubElement(input, \"source\")\n        config_source = ET.SubElement(source, \"config-source\")\n        startup = ET.SubElement(config_source, \"startup\")\n        startup = ET.SubElement(startup, \"startup\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets config input with defaults", "response": "def get_config_input_with_defaults(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_config = ET.Element(\"get_config\")\n        config = get_config\n        input = ET.SubElement(get_config, \"input\")\n        with_defaults = ET.SubElement(input, \"with-defaults\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults\")\n        with_defaults.text = kwargs.pop('with_defaults')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_config_input_with_inactive(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_config = ET.Element(\"get_config\")\n        config = get_config\n        input = ET.SubElement(get_config, \"input\")\n        with_inactive = ET.SubElement(input, \"with-inactive\", xmlns=\"http://tail-f.com/ns/netconf/inactive/1.0\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get config input with inactive status"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nedit config input target config target candidate candidate", "response": "def edit_config_input_target_config_target_candidate_candidate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        edit_config = ET.Element(\"edit_config\")\n        config = edit_config\n        input = ET.SubElement(edit_config, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        candidate = ET.SubElement(config_target, \"candidate\")\n        candidate = ET.SubElement(candidate, \"candidate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nedit config input target config target running running", "response": "def edit_config_input_target_config_target_running_running(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        edit_config = ET.Element(\"edit_config\")\n        config = edit_config\n        input = ET.SubElement(edit_config, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        running = ET.SubElement(config_target, \"running\")\n        running = ET.SubElement(running, \"running\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nedit config input default operation.", "response": "def edit_config_input_default_operation(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        edit_config = ET.Element(\"edit_config\")\n        config = edit_config\n        input = ET.SubElement(edit_config, \"input\")\n        default_operation = ET.SubElement(input, \"default-operation\")\n        default_operation.text = kwargs.pop('default_operation')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef edit_config_input_error_option(self, **kwargs):\n        config = ET.Element(\"config\")\n        edit_config = ET.Element(\"edit_config\")\n        config = edit_config\n        input = ET.SubElement(edit_config, \"input\")\n        error_option = ET.SubElement(input, \"error-option\")\n        error_option.text = kwargs.pop('error_option')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Edit config input error option"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nediting config input edit - content url url", "response": "def edit_config_input_edit_content_url_url(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        edit_config = ET.Element(\"edit_config\")\n        config = edit_config\n        input = ET.SubElement(edit_config, \"input\")\n        edit_content = ET.SubElement(input, \"edit-content\")\n        url = ET.SubElement(edit_content, \"url\")\n        url = ET.SubElement(url, \"url\")\n        url.text = kwargs.pop('url')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nedits config input with inactive status", "response": "def edit_config_input_with_inactive(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        edit_config = ET.Element(\"edit_config\")\n        config = edit_config\n        input = ET.SubElement(edit_config, \"input\")\n        with_inactive = ET.SubElement(input, \"with-inactive\", xmlns=\"http://tail-f.com/ns/netconf/inactive/1.0\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncopy configuration input target config target candidate candidate.", "response": "def copy_config_input_target_config_target_candidate_candidate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        copy_config = ET.Element(\"copy_config\")\n        config = copy_config\n        input = ET.SubElement(copy_config, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        candidate = ET.SubElement(config_target, \"candidate\")\n        candidate = ET.SubElement(candidate, \"candidate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy_config_input_target_config_target_running_running(self, **kwargs):\n        config = ET.Element(\"config\")\n        copy_config = ET.Element(\"copy_config\")\n        config = copy_config\n        input = ET.SubElement(copy_config, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        running = ET.SubElement(config_target, \"running\")\n        running = ET.SubElement(running, \"running\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Copy configuration input target config target running running"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncopies configuration input target config target startup startup", "response": "def copy_config_input_target_config_target_startup_startup(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        copy_config = ET.Element(\"copy_config\")\n        config = copy_config\n        input = ET.SubElement(copy_config, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        startup = ET.SubElement(config_target, \"startup\")\n        startup = ET.SubElement(startup, \"startup\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncopying configuration input target config target url url", "response": "def copy_config_input_target_config_target_url_url(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        copy_config = ET.Element(\"copy_config\")\n        config = copy_config\n        input = ET.SubElement(copy_config, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        url = ET.SubElement(config_target, \"url\")\n        url = ET.SubElement(url, \"url\")\n        url.text = kwargs.pop('url')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncopy configuration input source config source candidate candidate", "response": "def copy_config_input_source_config_source_candidate_candidate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        copy_config = ET.Element(\"copy_config\")\n        config = copy_config\n        input = ET.SubElement(copy_config, \"input\")\n        source = ET.SubElement(input, \"source\")\n        config_source = ET.SubElement(source, \"config-source\")\n        candidate = ET.SubElement(config_source, \"candidate\")\n        candidate = ET.SubElement(candidate, \"candidate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef copy_config_input_source_config_source_running_running(self, **kwargs):\n        config = ET.Element(\"config\")\n        copy_config = ET.Element(\"copy_config\")\n        config = copy_config\n        input = ET.SubElement(copy_config, \"input\")\n        source = ET.SubElement(input, \"source\")\n        config_source = ET.SubElement(source, \"config-source\")\n        running = ET.SubElement(config_source, \"running\")\n        running = ET.SubElement(running, \"running\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Copy configuration input source config source running running"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncopying configuration input source config source startup startup", "response": "def copy_config_input_source_config_source_startup_startup(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        copy_config = ET.Element(\"copy_config\")\n        config = copy_config\n        input = ET.SubElement(copy_config, \"input\")\n        source = ET.SubElement(input, \"source\")\n        config_source = ET.SubElement(source, \"config-source\")\n        startup = ET.SubElement(config_source, \"startup\")\n        startup = ET.SubElement(startup, \"startup\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncopies configuration input source config source url url", "response": "def copy_config_input_source_config_source_url_url(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        copy_config = ET.Element(\"copy_config\")\n        config = copy_config\n        input = ET.SubElement(copy_config, \"input\")\n        source = ET.SubElement(input, \"source\")\n        config_source = ET.SubElement(source, \"config-source\")\n        url = ET.SubElement(config_source, \"url\")\n        url = ET.SubElement(url, \"url\")\n        url.text = kwargs.pop('url')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy_config_input_with_inactive(self, **kwargs):\n        config = ET.Element(\"config\")\n        copy_config = ET.Element(\"copy_config\")\n        config = copy_config\n        input = ET.SubElement(copy_config, \"input\")\n        with_inactive = ET.SubElement(input, \"with-inactive\", xmlns=\"http://tail-f.com/ns/netconf/inactive/1.0\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        Copy Config Input with Inactive"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_config_input_target_config_target_startup_startup(self, **kwargs):\n        config = ET.Element(\"config\")\n        delete_config = ET.Element(\"delete_config\")\n        config = delete_config\n        input = ET.SubElement(delete_config, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        startup = ET.SubElement(config_target, \"startup\")\n        startup = ET.SubElement(startup, \"startup\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Delete config input target config target startup startup."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_config_input_target_config_target_url_url(self, **kwargs):\n        config = ET.Element(\"config\")\n        delete_config = ET.Element(\"delete_config\")\n        config = delete_config\n        input = ET.SubElement(delete_config, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        url = ET.SubElement(config_target, \"url\")\n        url = ET.SubElement(url, \"url\")\n        url.text = kwargs.pop('url')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Delete config input target config target url url"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lock_input_target_config_target_candidate_candidate(self, **kwargs):\n        config = ET.Element(\"config\")\n        lock = ET.Element(\"lock\")\n        config = lock\n        input = ET.SubElement(lock, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        candidate = ET.SubElement(config_target, \"candidate\")\n        candidate = ET.SubElement(candidate, \"candidate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the lock input target config target candidate."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lock_input_target_config_target_running_running(self, **kwargs):\n        config = ET.Element(\"config\")\n        lock = ET.Element(\"lock\")\n        config = lock\n        input = ET.SubElement(lock, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        running = ET.SubElement(config_target, \"running\")\n        running = ET.SubElement(running, \"running\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        config."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lock_input_target_config_target_startup_startup(self, **kwargs):\n        config = ET.Element(\"config\")\n        lock = ET.Element(\"lock\")\n        config = lock\n        input = ET.SubElement(lock, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        startup = ET.SubElement(config_target, \"startup\")\n        startup = ET.SubElement(startup, \"startup\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        config."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nunlocking input target config target candidate candidate.", "response": "def unlock_input_target_config_target_candidate_candidate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        unlock = ET.Element(\"unlock\")\n        config = unlock\n        input = ET.SubElement(unlock, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        candidate = ET.SubElement(config_target, \"candidate\")\n        candidate = ET.SubElement(candidate, \"candidate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nunlocks input target config target running running", "response": "def unlock_input_target_config_target_running_running(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        unlock = ET.Element(\"unlock\")\n        config = unlock\n        input = ET.SubElement(unlock, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        running = ET.SubElement(config_target, \"running\")\n        running = ET.SubElement(running, \"running\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nunlocks input target config target startup startup.", "response": "def unlock_input_target_config_target_startup_startup(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        unlock = ET.Element(\"unlock\")\n        config = unlock\n        input = ET.SubElement(unlock, \"input\")\n        target = ET.SubElement(input, \"target\")\n        config_target = ET.SubElement(target, \"config-target\")\n        startup = ET.SubElement(config_target, \"startup\")\n        startup = ET.SubElement(startup, \"startup\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_input_with_defaults(self, **kwargs):\n        config = ET.Element(\"config\")\n        get = ET.Element(\"get\")\n        config = get\n        input = ET.SubElement(get, \"input\")\n        with_defaults = ET.SubElement(input, \"with-defaults\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults\")\n        with_defaults.text = kwargs.pop('with_defaults')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        Get element with defaults."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the input element of the get resource with inactive status.", "response": "def get_input_with_inactive(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get = ET.Element(\"get\")\n        config = get\n        input = ET.SubElement(get, \"input\")\n        with_inactive = ET.SubElement(input, \"with-inactive\", xmlns=\"http://tail-f.com/ns/netconf/inactive/1.0\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nkills Session input Session ID", "response": "def kill_session_input_session_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        kill_session = ET.Element(\"kill_session\")\n        config = kill_session\n        input = ET.SubElement(kill_session, \"input\")\n        session_id = ET.SubElement(input, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef commit_input_confirm_timeout(self, **kwargs):\n        config = ET.Element(\"config\")\n        commit = ET.Element(\"commit\")\n        config = commit\n        input = ET.SubElement(commit, \"input\")\n        confirm_timeout = ET.SubElement(input, \"confirm-timeout\")\n        confirm_timeout.text = kwargs.pop('confirm_timeout')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        Commit Input Confirm Timeout Element"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef commit_input_persist(self, **kwargs):\n        config = ET.Element(\"config\")\n        commit = ET.Element(\"commit\")\n        config = commit\n        input = ET.SubElement(commit, \"input\")\n        persist = ET.SubElement(input, \"persist\")\n        persist.text = kwargs.pop('persist')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        commit_input_persist"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef commit_input_persist_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        commit = ET.Element(\"commit\")\n        config = commit\n        input = ET.SubElement(commit, \"input\")\n        persist_id = ET.SubElement(input, \"persist-id\")\n        persist_id.text = kwargs.pop('persist_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Commit input persist - id and return config."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncancel Commit and cancel input persist - id.", "response": "def cancel_commit_input_persist_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        cancel_commit = ET.Element(\"cancel_commit\")\n        config = cancel_commit\n        input = ET.SubElement(cancel_commit, \"input\")\n        persist_id = ET.SubElement(input, \"persist-id\")\n        persist_id.text = kwargs.pop('persist_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate_input_source_config_source_candidate_candidate(self, **kwargs):\n        config = ET.Element(\"config\")\n        validate = ET.Element(\"validate\")\n        config = validate\n        input = ET.SubElement(validate, \"input\")\n        source = ET.SubElement(input, \"source\")\n        config_source = ET.SubElement(source, \"config-source\")\n        candidate = ET.SubElement(config_source, \"candidate\")\n        candidate = ET.SubElement(candidate, \"candidate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Validate input source config source candidate candidate"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_input_source_config_source_running_running(self, **kwargs):\n        config = ET.Element(\"config\")\n        validate = ET.Element(\"validate\")\n        config = validate\n        input = ET.SubElement(validate, \"input\")\n        source = ET.SubElement(input, \"source\")\n        config_source = ET.SubElement(source, \"config-source\")\n        running = ET.SubElement(config_source, \"running\")\n        running = ET.SubElement(running, \"running\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Validate input source config source running running"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_input_source_config_source_startup_startup(self, **kwargs):\n        config = ET.Element(\"config\")\n        validate = ET.Element(\"validate\")\n        config = validate\n        input = ET.SubElement(validate, \"input\")\n        source = ET.SubElement(input, \"source\")\n        config_source = ET.SubElement(source, \"config-source\")\n        startup = ET.SubElement(config_source, \"startup\")\n        startup = ET.SubElement(startup, \"startup\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Validate input source config source startup startup."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_input_source_config_source_url_url(self, **kwargs):\n        config = ET.Element(\"config\")\n        validate = ET.Element(\"validate\")\n        config = validate\n        input = ET.SubElement(validate, \"input\")\n        source = ET.SubElement(input, \"source\")\n        config_source = ET.SubElement(source, \"config-source\")\n        url = ET.SubElement(config_source, \"url\")\n        url = ET.SubElement(url, \"url\")\n        url.text = kwargs.pop('url')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Validate input source config source url url"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef user_session_info_output_user_role(self, **kwargs):\n        config = ET.Element(\"config\")\n        user_session_info = ET.Element(\"user_session_info\")\n        config = user_session_info\n        output = ET.SubElement(user_session_info, \"output\")\n        user_role = ET.SubElement(output, \"user-role\")\n        user_role.text = kwargs.pop('user_role')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set user_role attribute of the user_session_info element."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes AAA Authentication Login First", "response": "def aaa_config_aaa_authentication_login_first(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        aaa_config = ET.SubElement(config, \"aaa-config\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        aaa = ET.SubElement(aaa_config, \"aaa\")\n        authentication = ET.SubElement(aaa, \"authentication\")\n        login = ET.SubElement(authentication, \"login\")\n        first = ET.SubElement(login, \"first\")\n        first.text = kwargs.pop('first')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef aaa_config_aaa_authentication_login_second(self, **kwargs):\n        config = ET.Element(\"config\")\n        aaa_config = ET.SubElement(config, \"aaa-config\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        aaa = ET.SubElement(aaa_config, \"aaa\")\n        authentication = ET.SubElement(aaa, \"authentication\")\n        login = ET.SubElement(authentication, \"login\")\n        second = ET.SubElement(login, \"second\")\n        second.text = kwargs.pop('second')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize AAA Authentication Login Second"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize AAA Accounting Exc and Default Access Control", "response": "def aaa_config_aaa_accounting_exc_defaultacc_start_stop_server_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        aaa_config = ET.SubElement(config, \"aaa-config\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        aaa = ET.SubElement(aaa_config, \"aaa\")\n        accounting = ET.SubElement(aaa, \"accounting\")\n        exc = ET.SubElement(accounting, \"exec\")\n        defaultacc = ET.SubElement(exc, \"defaultacc\")\n        start_stop = ET.SubElement(defaultacc, \"start-stop\")\n        server_type = ET.SubElement(start_stop, \"server-type\")\n        server_type.text = kwargs.pop('server_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset username of the current resource", "response": "def username_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        username = ET.SubElement(config, \"username\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        name = ET.SubElement(username, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef username_user_password(self, **kwargs):\n        config = ET.Element(\"config\")\n        username = ET.SubElement(config, \"username\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        name_key = ET.SubElement(username, \"name\")\n        name_key.text = kwargs.pop('name')\n        user_password = ET.SubElement(username, \"user-password\")\n        user_password.text = kwargs.pop('user_password')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set username and user - password for a resource."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting username encryption level", "response": "def username_encryption_level(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        username = ET.SubElement(config, \"username\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        name_key = ET.SubElement(username, \"name\")\n        name_key.text = kwargs.pop('name')\n        encryption_level = ET.SubElement(username, \"encryption-level\")\n        encryption_level.text = kwargs.pop('encryption_level')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef username_role(self, **kwargs):\n        config = ET.Element(\"config\")\n        username = ET.SubElement(config, \"username\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        name_key = ET.SubElement(username, \"name\")\n        name_key.text = kwargs.pop('name')\n        role = ET.SubElement(username, \"role\")\n        role.text = kwargs.pop('role')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set username and role of a resource"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef username_desc(self, **kwargs):\n        config = ET.Element(\"config\")\n        username = ET.SubElement(config, \"username\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        name_key = ET.SubElement(username, \"name\")\n        name_key.text = kwargs.pop('name')\n        desc = ET.SubElement(username, \"desc\")\n        desc.text = kwargs.pop('desc')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set username and description of a resource."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef username_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        username = ET.SubElement(config, \"username\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        name_key = ET.SubElement(username, \"name\")\n        name_key.text = kwargs.pop('name')\n        enable = ET.SubElement(username, \"enable\")\n        enable.text = kwargs.pop('enable')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable the username for the current user"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset username to expire", "response": "def username_expire(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        username = ET.SubElement(config, \"username\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        name_key = ET.SubElement(username, \"name\")\n        name_key.text = kwargs.pop('name')\n        expire = ET.SubElement(username, \"expire\")\n        expire.text = kwargs.pop('expire')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef service_password_encryption(self, **kwargs):\n        config = ET.Element(\"config\")\n        service = ET.SubElement(config, \"service\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        password_encryption = ET.SubElement(service, \"password-encryption\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the user - identity service"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef role_name_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        role = ET.SubElement(config, \"role\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        name = ET.SubElement(role, \"name\")\n        name = ET.SubElement(name, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set name of the log entry role"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset role name and description of a resource.", "response": "def role_name_desc(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        role = ET.SubElement(config, \"role\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        name = ET.SubElement(role, \"name\")\n        name_key = ET.SubElement(name, \"name\")\n        name_key.text = kwargs.pop('name')\n        desc = ET.SubElement(name, \"desc\")\n        desc.text = kwargs.pop('desc')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the config for the resource cache", "response": "def radius_server_host_auth_port(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        radius_server = ET.SubElement(config, \"radius-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(radius_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        auth_port = ET.SubElement(host, \"auth-port\")\n        auth_port.text = kwargs.pop('auth_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef radius_server_host_key(self, **kwargs):\n        config = ET.Element(\"config\")\n        radius_server = ET.SubElement(config, \"radius-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(radius_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        key = ET.SubElement(host, \"key\")\n        key.text = kwargs.pop('key')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the key of the host key for the server"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the configuration of a resource from the radius server host encryption level.", "response": "def radius_server_host_encryption_level(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        radius_server = ET.SubElement(config, \"radius-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(radius_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        encryption_level = ET.SubElement(host, \"encryption-level\")\n        encryption_level.text = kwargs.pop('encryption_level')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the config of the resource cache for the specified host", "response": "def radius_server_host_retries(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        radius_server = ET.SubElement(config, \"radius-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(radius_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        retries = ET.SubElement(host, \"retries\")\n        retries.text = kwargs.pop('retries')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the config of a resource from the radius server host timeout", "response": "def radius_server_host_timeout(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        radius_server = ET.SubElement(config, \"radius-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(radius_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        timeout = ET.SubElement(host, \"timeout\")\n        timeout.text = kwargs.pop('timeout')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tacacs_server_host_hostname(self, **kwargs):\n        config = ET.Element(\"config\")\n        tacacs_server = ET.SubElement(config, \"tacacs-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(tacacs_server, \"host\")\n        hostname = ET.SubElement(host, \"hostname\")\n        hostname.text = kwargs.pop('hostname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config element for the tacacs server host and hostname"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the config element for the tacacs server host and port", "response": "def tacacs_server_host_port(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        tacacs_server = ET.SubElement(config, \"tacacs-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(tacacs_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        port = ET.SubElement(host, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tacacs_server_host_encryption_level(self, **kwargs):\n        config = ET.Element(\"config\")\n        tacacs_server = ET.SubElement(config, \"tacacs-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(tacacs_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        encryption_level = ET.SubElement(host, \"encryption-level\")\n        encryption_level.text = kwargs.pop('encryption_level')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a specific resource from the tacacs server host section."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tacacs_server_host_retries(self, **kwargs):\n        config = ET.Element(\"config\")\n        tacacs_server = ET.SubElement(config, \"tacacs-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(tacacs_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        retries = ET.SubElement(host, \"retries\")\n        retries.text = kwargs.pop('retries')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the resource cache for the specified hostname."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tacacs_server_host_timeout(self, **kwargs):\n        config = ET.Element(\"config\")\n        tacacs_server = ET.SubElement(config, \"tacacs-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(tacacs_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        timeout = ET.SubElement(host, \"timeout\")\n        timeout.text = kwargs.pop('timeout')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the current resource from the tacacs server host timeout."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the config of the current nacacs server", "response": "def tacacs_server_tacacs_source_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        tacacs_server = ET.SubElement(config, \"tacacs-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        tacacs_source_ip = ET.SubElement(tacacs_server, \"tacacs-source-ip\")\n        tacacs_source_ip.text = kwargs.pop('tacacs_source_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ldap_server_host_hostname(self, **kwargs):\n        config = ET.Element(\"config\")\n        ldap_server = ET.SubElement(config, \"ldap-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(ldap_server, \"host\")\n        hostname = ET.SubElement(host, \"hostname\")\n        hostname.text = kwargs.pop('hostname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDAP server host hostname"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ldap_server_host_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        ldap_server = ET.SubElement(config, \"ldap-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(ldap_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        port = ET.SubElement(host, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDAP Server host and port"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting LDAP server host baseddn", "response": "def ldap_server_host_basedn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ldap_server = ET.SubElement(config, \"ldap-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(ldap_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        basedn = ET.SubElement(host, \"basedn\")\n        basedn.text = kwargs.pop('basedn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the current LDAP server entry", "response": "def ldap_server_maprole_group_ad_group(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ldap_server = ET.SubElement(config, \"ldap-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        maprole = ET.SubElement(ldap_server, \"maprole\")\n        group = ET.SubElement(maprole, \"group\")\n        ad_group = ET.SubElement(group, \"ad-group\")\n        ad_group.text = kwargs.pop('ad_group')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the current LDAP server entry entry", "response": "def ldap_server_maprole_group_switch_role(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ldap_server = ET.SubElement(config, \"ldap-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        maprole = ET.SubElement(ldap_server, \"maprole\")\n        group = ET.SubElement(maprole, \"group\")\n        ad_group_key = ET.SubElement(group, \"ad-group\")\n        ad_group_key.text = kwargs.pop('ad_group')\n        switch_role = ET.SubElement(group, \"switch-role\")\n        switch_role.text = kwargs.pop('switch_role')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the minimum length of password attributes", "response": "def password_attributes_min_length(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        password_attributes = ET.SubElement(config, \"password-attributes\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        min_length = ET.SubElement(password_attributes, \"min-length\")\n        min_length.text = kwargs.pop('min_length')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the configuration of the user password attributes max retry", "response": "def password_attributes_max_retry(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        password_attributes = ET.SubElement(config, \"password-attributes\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        max_retry = ET.SubElement(password_attributes, \"max-retry\")\n        max_retry.text = kwargs.pop('max_retry')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting max lockout duration for a resource", "response": "def password_attributes_max_lockout_duration(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        password_attributes = ET.SubElement(config, \"password-attributes\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        max_lockout_duration = ET.SubElement(password_attributes, \"max-lockout-duration\")\n        max_lockout_duration.text = kwargs.pop('max_lockout_duration')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef password_attributes_character_restriction_upper(self, **kwargs):\n        config = ET.Element(\"config\")\n        password_attributes = ET.SubElement(config, \"password-attributes\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        character_restriction = ET.SubElement(password_attributes, \"character-restriction\")\n        upper = ET.SubElement(character_restriction, \"upper\")\n        upper.text = kwargs.pop('upper')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the user password attributes character restriction upper"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef password_attributes_character_restriction_lower(self, **kwargs):\n        config = ET.Element(\"config\")\n        password_attributes = ET.SubElement(config, \"password-attributes\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        character_restriction = ET.SubElement(password_attributes, \"character-restriction\")\n        lower = ET.SubElement(character_restriction, \"lower\")\n        lower.text = kwargs.pop('lower')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the user s password attributes character restriction lower."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the configuration of the user s password attributes character restriction numeric.", "response": "def password_attributes_character_restriction_numeric(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        password_attributes = ET.SubElement(config, \"password-attributes\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        character_restriction = ET.SubElement(password_attributes, \"character-restriction\")\n        numeric = ET.SubElement(character_restriction, \"numeric\")\n        numeric.text = kwargs.pop('numeric')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the config element for the user password attributes character restriction special character", "response": "def password_attributes_character_restriction_special_char(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        password_attributes = ET.SubElement(config, \"password-attributes\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        character_restriction = ET.SubElement(password_attributes, \"character-restriction\")\n        special_char = ET.SubElement(character_restriction, \"special-char\")\n        special_char.text = kwargs.pop('special_char')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rule_index(self, **kwargs):\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index = ET.SubElement(rule, \"index\")\n        index.text = kwargs.pop('index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        index"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the action of the resource index", "response": "def rule_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        action = ET.SubElement(rule, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rule_operation(self, **kwargs):\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        operation = ET.SubElement(rule, \"operation\")\n        operation.text = kwargs.pop('operation')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the rule operation"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rule_role(self, **kwargs):\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        role = ET.SubElement(rule, \"role\")\n        role.text = kwargs.pop('role')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the index and role of a resource entry"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the configuration of a specific resource entry", "response": "def rule_command_cmdlist_container_cmds_enumList(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        command = ET.SubElement(rule, \"command\")\n        cmdlist = ET.SubElement(command, \"cmdlist\")\n        container_cmds = ET.SubElement(cmdlist, \"container-cmds\")\n        enumList = ET.SubElement(container_cmds, \"enumList\")\n        enumList.text = kwargs.pop('enumList')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the config command cmdlist for a specific entry in the log.", "response": "def rule_command_cmdlist_interface_d_interface_fcoe_leaf_interface_fcoe_leaf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        command = ET.SubElement(rule, \"command\")\n        cmdlist = ET.SubElement(command, \"cmdlist\")\n        interface_d = ET.SubElement(cmdlist, \"interface-d\")\n        interface_fcoe_leaf = ET.SubElement(interface_d, \"interface-fcoe-leaf\")\n        interface = ET.SubElement(interface_fcoe_leaf, \"interface\")\n        fcoe_leaf = ET.SubElement(interface, \"fcoe-leaf\")\n        fcoe_leaf.text = kwargs.pop('fcoe_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rule_command_cmdlist_interface_e_interface_te_leaf_interface_tengigabitethernet_leaf(self, **kwargs):\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        command = ET.SubElement(rule, \"command\")\n        cmdlist = ET.SubElement(command, \"cmdlist\")\n        interface_e = ET.SubElement(cmdlist, \"interface-e\")\n        interface_te_leaf = ET.SubElement(interface_e, \"interface-te-leaf\")\n        interface = ET.SubElement(interface_te_leaf, \"interface\")\n        tengigabitethernet_leaf = ET.SubElement(interface, \"tengigabitethernet-leaf\")\n        tengigabitethernet_leaf.text = kwargs.pop('tengigabitethernet_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the command cmdlist for a specific entry in the log."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rule_command_cmdlist_interface_h_interface_ge_leaf_interface_gigabitethernet_leaf(self, **kwargs):\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        command = ET.SubElement(rule, \"command\")\n        cmdlist = ET.SubElement(command, \"cmdlist\")\n        interface_h = ET.SubElement(cmdlist, \"interface-h\")\n        interface_ge_leaf = ET.SubElement(interface_h, \"interface-ge-leaf\")\n        interface = ET.SubElement(interface_ge_leaf, \"interface\")\n        gigabitethernet_leaf = ET.SubElement(interface, \"gigabitethernet-leaf\")\n        gigabitethernet_leaf.text = kwargs.pop('gigabitethernet_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the CFG command cmdlist for a specific entry in the log."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rule_command_cmdlist_interface_j_interface_pc_leaf_interface_port_channel_leaf(self, **kwargs):\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        command = ET.SubElement(rule, \"command\")\n        cmdlist = ET.SubElement(command, \"cmdlist\")\n        interface_j = ET.SubElement(cmdlist, \"interface-j\")\n        interface_pc_leaf = ET.SubElement(interface_j, \"interface-pc-leaf\")\n        interface = ET.SubElement(interface_pc_leaf, \"interface\")\n        port_channel_leaf = ET.SubElement(interface, \"port-channel-leaf\")\n        port_channel_leaf.text = kwargs.pop('port_channel_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the CFG command cmdlist for the log level leaf interface and port channel leaf."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rule_command_cmdlist_interface_l_interface_vlan_leaf_interface_vlan_leaf(self, **kwargs):\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        command = ET.SubElement(rule, \"command\")\n        cmdlist = ET.SubElement(command, \"cmdlist\")\n        interface_l = ET.SubElement(cmdlist, \"interface-l\")\n        interface_vlan_leaf = ET.SubElement(interface_l, \"interface-vlan-leaf\")\n        interface = ET.SubElement(interface_vlan_leaf, \"interface\")\n        vlan_leaf = ET.SubElement(interface, \"vlan-leaf\")\n        vlan_leaf.text = kwargs.pop('vlan_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the config command cmdlist for a specific locale"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the config command cmdlist for a specific interface - o and loopback - leaf.", "response": "def rule_command_cmdlist_interface_o_interface_loopback_leaf_interface_loopback_leaf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        command = ET.SubElement(rule, \"command\")\n        cmdlist = ET.SubElement(command, \"cmdlist\")\n        interface_o = ET.SubElement(cmdlist, \"interface-o\")\n        interface_loopback_leaf = ET.SubElement(interface_o, \"interface-loopback-leaf\")\n        interface = ET.SubElement(interface_loopback_leaf, \"interface\")\n        loopback_leaf = ET.SubElement(interface, \"loopback-leaf\")\n        loopback_leaf.text = kwargs.pop('loopback_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rule_command_cmdlist_interface_q_interface_ve_leaf_interface_ve_leaf(self, **kwargs):\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        command = ET.SubElement(rule, \"command\")\n        cmdlist = ET.SubElement(command, \"cmdlist\")\n        interface_q = ET.SubElement(cmdlist, \"interface-q\")\n        interface_ve_leaf = ET.SubElement(interface_q, \"interface-ve-leaf\")\n        interface = ET.SubElement(interface_ve_leaf, \"interface\")\n        ve_leaf = ET.SubElement(interface, \"ve-leaf\")\n        ve_leaf.text = kwargs.pop('ve_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the command cmdlist interface - q interface - ve - leaf and update the leaf level of the leaf."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rule_command_cmdlist_interface_s_interface_fc_leaf_interface_fibrechannel_leaf(self, **kwargs):\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        command = ET.SubElement(rule, \"command\")\n        cmdlist = ET.SubElement(command, \"cmdlist\")\n        interface_s = ET.SubElement(cmdlist, \"interface-s\")\n        interface_fc_leaf = ET.SubElement(interface_s, \"interface-fc-leaf\")\n        interface = ET.SubElement(interface_fc_leaf, \"interface\")\n        fibrechannel_leaf = ET.SubElement(interface, \"fibrechannel-leaf\")\n        fibrechannel_leaf.text = kwargs.pop('fibrechannel_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the command cmdlist for a specific leaf level of the leaf level of the leaf level of the leaf level of the leaf level of the leaf level of the leaf level of the leaf level of the leaf level of the leaf level of the leaf level of the leaf level of the leaf level of the leaf."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the command cmdlist for the fortygigabitethernet leaf.", "response": "def rule_command_cmdlist_interface_u_interface_fe_leaf_interface_fortygigabitethernet_leaf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        command = ET.SubElement(rule, \"command\")\n        cmdlist = ET.SubElement(command, \"cmdlist\")\n        interface_u = ET.SubElement(cmdlist, \"interface-u\")\n        interface_fe_leaf = ET.SubElement(interface_u, \"interface-fe-leaf\")\n        interface = ET.SubElement(interface_fe_leaf, \"interface\")\n        fortygigabitethernet_leaf = ET.SubElement(interface, \"fortygigabitethernet-leaf\")\n        fortygigabitethernet_leaf.text = kwargs.pop('fortygigabitethernet_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rule_command_cmdlist_interface_w_interface_he_leaf_interface_hundredgigabitethernet_leaf(self, **kwargs):\n        config = ET.Element(\"config\")\n        rule = ET.SubElement(config, \"rule\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        index_key = ET.SubElement(rule, \"index\")\n        index_key.text = kwargs.pop('index')\n        command = ET.SubElement(rule, \"command\")\n        cmdlist = ET.SubElement(command, \"cmdlist\")\n        interface_w = ET.SubElement(cmdlist, \"interface-w\")\n        interface_he_leaf = ET.SubElement(interface_w, \"interface-he-leaf\")\n        interface = ET.SubElement(interface_he_leaf, \"interface\")\n        hundredgigabitethernet_leaf = ET.SubElement(interface, \"hundredgigabitethernet-leaf\")\n        hundredgigabitethernet_leaf.text = kwargs.pop('hundredgigabitethernet_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the command list for a specific entry in the log."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef root_sa_root_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        root_sa = ET.SubElement(config, \"root-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        root = ET.SubElement(root_sa, \"root\")\n        enable = ET.SubElement(root, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable the root SA entry"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the configuration of the root SA related to a resource.", "response": "def root_sa_root_access(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        root_sa = ET.SubElement(config, \"root-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        root = ET.SubElement(root_sa, \"root\")\n        access = ET.SubElement(root, \"access\")\n        access.text = kwargs.pop('access')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef alias_config_user_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        alias_config = ET.SubElement(config, \"alias-config\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        user = ET.SubElement(alias_config, \"user\")\n        name = ET.SubElement(user, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get alias config user name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding user alias name to the config element.", "response": "def alias_config_user_alias_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        alias_config = ET.SubElement(config, \"alias-config\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        user = ET.SubElement(alias_config, \"user\")\n        name_key = ET.SubElement(user, \"name\")\n        name_key.text = kwargs.pop('name')\n        alias = ET.SubElement(user, \"alias\")\n        name = ET.SubElement(alias, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget or set nsx controller name", "response": "def nsx_controller_name(self, **kwargs):\n        \"\"\"\n        Get/Set nsx controller name\n\n        Args:\n            name: (str) :   Name of the nsx controller\n            get (bool) : Get nsx controller config(True,False)\n            callback (function): A function executed upon completion of the\n                 method.\n\n        Returns:\n           Return value of `callback`.\n\n        Raises:\n            None\n        \"\"\"\n        name = kwargs.pop('name')\n        name_args = dict(name=name)\n        method_name = 'nsx_controller_name'\n        method_class = self._brocade_tunnels\n        nsxcontroller_attr = getattr(method_class, method_name)\n        config = nsxcontroller_attr(**name_args)\n\n        if kwargs.pop('get', False):\n            output = self._callback(config, handler='get_config')\n        else:\n            output = self._callback(config)\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the nsx - controller IP for the current user.", "response": "def set_nsxcontroller_ip(self, **kwargs):\n        \"\"\"\n        Set nsx-controller IP\n\n        Args:\n            IP (str): IPV4 address.\n            callback (function): A function executed upon completion of the\n                 method.\n\n        Returns:\n           Return value of `callback`.\n\n        Raises:\n            None\n        \"\"\"\n        name = kwargs.pop('name')\n        ip_addr = str((kwargs.pop('ip_addr', None)))\n        nsxipaddress = ip_interface(unicode(ip_addr))\n        if nsxipaddress.version != 4:\n            raise ValueError('NSX Controller ip must be IPV4')\n\n        ip_args = dict(name=name, address=ip_addr)\n        method_name = 'nsx_controller_connection_addr_address'\n        method_class = self._brocade_tunnels\n        nsxcontroller_attr = getattr(method_class, method_name)\n        config = nsxcontroller_attr(**ip_args)\n        output = self._callback(config)\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef activate_nsxcontroller(self, **kwargs):\n        name = kwargs.pop('name')\n        name_args = dict(name=name)\n        method_name = 'nsx_controller_activate'\n        method_class = self._brocade_tunnels\n        nsxcontroller_attr = getattr(method_class, method_name)\n        config = nsxcontroller_attr(**name_args)\n        output = self._callback(config)\n        return output", "response": "Activate NSX Controller\n\n        Args:\n            name (str): nsxcontroller name\n            callback (function): A function executed upon completion of the\n                 method.\n\n        Returns:\n           Return value of `callback`.\n\n        Raises:\n            None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_nsxcontroller_port(self, **kwargs):\n        name = kwargs.pop('name')\n        port = str(kwargs.pop('port'))\n        port_args = dict(name=name, port=port)\n        method_name = 'nsx_controller_connection_addr_port'\n        method_class = self._brocade_tunnels\n        nsxcontroller_attr = getattr(method_class, method_name)\n        config = nsxcontroller_attr(**port_args)\n        output = self._callback(config)\n        return output", "response": "Set Nsx Controller pot on the switch\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_nsx_controller(self):\n        urn = \"urn:brocade.com:mgmt:brocade-tunnels\"\n        config = ET.Element(\"config\")\n        ET.SubElement(config, \"nsx-controller\", xmlns=urn)\n        output = self._callback(config, handler='get_config')\n        result = {}\n        element = ET.fromstring(str(output))\n        for controller in element.iter('{%s}nsx-controller'%urn):\n            result['name'] = controller.find('{%s}name'%urn).text\n            isactivate = controller.find('{%s}activate'%urn)\n            if isactivate is None:\n                result['activate'] = False\n            else:\n                result['activate'] = True\n            connection = controller.find('{%s}connection-addr'%urn)\n            if connection is None:\n                result['port'] = None\n                result['address'] = None\n            else:\n                result['port'] = connection.find('{%s}port'%urn).text\n                address = connection.find('{%s}address'%urn)\n                if address is None:\n                    result['address'] = None\n                else:\n                    result['address'] = address.text\n\n        return result", "response": "Get the nsx - controller name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading shared celery tasks.", "response": "def celery_module_imports(sender, signal=None, **kwargs):\n    \"\"\"Load shared celery tasks.\"\"\"\n    app = getattr(sender, 'flask_app', None)\n    if app:\n        app.extensions['invenio-celery'].load_entry_points()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads tasks from entry points.", "response": "def load_entry_points(self):\n        \"\"\"Load tasks from entry points.\"\"\"\n        if self.entry_point_group:\n            task_packages = {}\n            for item in pkg_resources.iter_entry_points(\n                    group=self.entry_point_group):\n                # Celery 4.2 requires autodiscover to be called with\n                # related_name for Python 2.7.\n                try:\n                    pkg, related_name = item.module_name.rsplit('.', 1)\n                except ValueError:\n                    warnings.warn(\n                        'The celery task module \"{}\" was not loaded. '\n                        'Defining modules in bare Python modules is no longer '\n                        'supported due to Celery v4.2 constraints. Please '\n                        'move the module into a Python package.'.format(\n                            item.module_name\n                        ),\n                        RuntimeWarning\n                    )\n                    continue\n                if related_name not in task_packages:\n                    task_packages[related_name] = []\n                task_packages[related_name].append(pkg)\n\n            if task_packages:\n                for related_name, packages in task_packages.items():\n                    self.celery.autodiscover_tasks(\n                        packages, related_name=related_name, force=True\n                    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of current active Celery queues.", "response": "def get_queues(self):\n        \"\"\"Return a list of current active Celery queues.\"\"\"\n        res = self.celery.control.inspect().active_queues() or dict()\n        return [result.get('name') for host in res.values() for result in host]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of UUIDs of active tasks.", "response": "def get_active_tasks(self):\n        \"\"\"Return a list of UUIDs of active tasks.\"\"\"\n        current_tasks = self.celery.control.inspect().active() or dict()\n        return [\n            task.get('id') for host in current_tasks.values() for task in host]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef suspend_queues(self, active_queues, sleep_time=10.0):\n        for queue in active_queues:\n            self.disable_queue(queue)\n        while self.get_active_tasks():\n            time.sleep(sleep_time)", "response": "Suspends the active queues and waits for running tasks to complete."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fwdl_status_input_fwdl_tid(self, **kwargs):\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        input = ET.SubElement(fwdl_status, \"input\")\n        fwdl_tid = ET.SubElement(input, \"fwdl-tid\")\n        fwdl_tid.text = kwargs.pop('fwdl_tid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Fwdl Status input for a specific Fwdl TID"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting Fwdl Status output number of entries.", "response": "def fwdl_status_output_number_of_entries(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        output = ET.SubElement(fwdl_status, \"output\")\n        number_of_entries = ET.SubElement(output, \"number-of-entries\")\n        number_of_entries.text = kwargs.pop('number_of_entries')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fwdl_status_output_fwdl_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        output = ET.SubElement(fwdl_status, \"output\")\n        fwdl_state = ET.SubElement(output, \"fwdl-state\")\n        fwdl_state.text = kwargs.pop('fwdl_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Fwdl Status output and fwdl state."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget Fwdl Status output and fwdl entries index.", "response": "def fwdl_status_output_fwdl_entries_index(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        output = ET.SubElement(fwdl_status, \"output\")\n        fwdl_entries = ET.SubElement(output, \"fwdl-entries\")\n        index = ET.SubElement(fwdl_entries, \"index\")\n        index.text = kwargs.pop('index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fwdl_status_output_fwdl_entries_message_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        output = ET.SubElement(fwdl_status, \"output\")\n        fwdl_entries = ET.SubElement(output, \"fwdl-entries\")\n        message_id = ET.SubElement(fwdl_entries, \"message-id\")\n        message_id.text = kwargs.pop('message_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Fwdl Status output and fwdl entries message id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fwdl_status_output_fwdl_entries_date_and_time_info(self, **kwargs):\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        output = ET.SubElement(fwdl_status, \"output\")\n        fwdl_entries = ET.SubElement(output, \"fwdl-entries\")\n        date_and_time_info = ET.SubElement(fwdl_entries, \"date-and-time-info\")\n        date_and_time_info.text = kwargs.pop('date_and_time_info')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Fwdl Status output and fwdl entries date and time info."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a message to the Fwdl Status XML element.", "response": "def fwdl_status_output_fwdl_entries_message(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        output = ET.SubElement(fwdl_status, \"output\")\n        fwdl_entries = ET.SubElement(output, \"fwdl-entries\")\n        message = ET.SubElement(fwdl_entries, \"message\")\n        message.text = kwargs.pop('message')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fwdl_status_output_fwdl_entries_blade_slot(self, **kwargs):\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        output = ET.SubElement(fwdl_status, \"output\")\n        fwdl_entries = ET.SubElement(output, \"fwdl-entries\")\n        blade_slot = ET.SubElement(fwdl_entries, \"blade-slot\")\n        blade_slot.text = kwargs.pop('blade_slot')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Fwdl Status output and Blaze Slot"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Fwdl Status output and Blade SWBD.", "response": "def fwdl_status_output_fwdl_entries_blade_swbd(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        output = ET.SubElement(fwdl_status, \"output\")\n        fwdl_entries = ET.SubElement(output, \"fwdl-entries\")\n        blade_swbd = ET.SubElement(fwdl_entries, \"blade-swbd\")\n        blade_swbd.text = kwargs.pop('blade_swbd')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets Fwdl Status output and Fwdl Entries blade name.", "response": "def fwdl_status_output_fwdl_entries_blade_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        output = ET.SubElement(fwdl_status, \"output\")\n        fwdl_entries = ET.SubElement(output, \"fwdl-entries\")\n        blade_name = ET.SubElement(fwdl_entries, \"blade-name\")\n        blade_name.text = kwargs.pop('blade_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fwdl_status_output_fwdl_entries_blade_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        output = ET.SubElement(fwdl_status, \"output\")\n        fwdl_entries = ET.SubElement(output, \"fwdl-entries\")\n        blade_state = ET.SubElement(fwdl_entries, \"blade-state\")\n        blade_state.text = kwargs.pop('blade_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Fwdl Status output and Blades State"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fwdl_status_output_fwdl_entries_blade_app(self, **kwargs):\n        config = ET.Element(\"config\")\n        fwdl_status = ET.Element(\"fwdl_status\")\n        config = fwdl_status\n        output = ET.SubElement(fwdl_status, \"output\")\n        fwdl_entries = ET.SubElement(output, \"fwdl-entries\")\n        blade_app = ET.SubElement(fwdl_entries, \"blade-app\")\n        blade_app.text = kwargs.pop('blade_app')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Fwdl Status output and Blade App."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef activate_status_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        activate_status = ET.Element(\"activate_status\")\n        config = activate_status\n        input = ET.SubElement(activate_status, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Activate Status input for Alerting Software Classes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nactivating Status Output and Overall Status", "response": "def activate_status_output_overall_status(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        activate_status = ET.Element(\"activate_status\")\n        config = activate_status\n        output = ET.SubElement(activate_status, \"output\")\n        overall_status = ET.SubElement(output, \"overall-status\")\n        overall_status.text = kwargs.pop('overall_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef activate_status_output_overall_error_msg(self, **kwargs):\n        config = ET.Element(\"config\")\n        activate_status = ET.Element(\"activate_status\")\n        config = activate_status\n        output = ET.SubElement(activate_status, \"output\")\n        overall_error_msg = ET.SubElement(output, \"overall-error-msg\")\n        overall_error_msg.text = kwargs.pop('overall_error_msg')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Activate Status Output and Return Current Current"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nactivate Status output activate entries rbridge_id", "response": "def activate_status_output_activate_entries_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        activate_status = ET.Element(\"activate_status\")\n        config = activate_status\n        output = ET.SubElement(activate_status, \"output\")\n        activate_entries = ET.SubElement(output, \"activate-entries\")\n        rbridge_id = ET.SubElement(activate_entries, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nactivates Status output and Activate Entries Status", "response": "def activate_status_output_activate_entries_status(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        activate_status = ET.Element(\"activate_status\")\n        config = activate_status\n        output = ET.SubElement(activate_status, \"output\")\n        activate_entries = ET.SubElement(output, \"activate-entries\")\n        status = ET.SubElement(activate_entries, \"status\")\n        status.text = kwargs.pop('status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the config of a firmware download input protocol - type scp - protocol scp - user", "response": "def firmware_download_input_protocol_type_scp_protocol_scp_user(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        scp_protocol = ET.SubElement(protocol_type, \"scp-protocol\")\n        scp = ET.SubElement(scp_protocol, \"scp\")\n        user = ET.SubElement(scp, \"user\")\n        user.text = kwargs.pop('user')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef firmware_download_input_protocol_type_scp_protocol_scp_password(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        scp_protocol = ET.SubElement(protocol_type, \"scp-protocol\")\n        scp = ET.SubElement(scp_protocol, \"scp\")\n        password = ET.SubElement(scp, \"password\")\n        password.text = kwargs.pop('password')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a firmware download input protocol - type scp - protocol scp - password"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the config of a firmware download input protocol - type scp - protocol scp - host", "response": "def firmware_download_input_protocol_type_scp_protocol_scp_host(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        scp_protocol = ET.SubElement(protocol_type, \"scp-protocol\")\n        scp = ET.SubElement(scp_protocol, \"scp\")\n        host = ET.SubElement(scp, \"host\")\n        host.text = kwargs.pop('host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the configuration of a Firmware Downloader input protocol - type scp - protocol scp - directory", "response": "def firmware_download_input_protocol_type_scp_protocol_scp_directory(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        scp_protocol = ET.SubElement(protocol_type, \"scp-protocol\")\n        scp = ET.SubElement(scp_protocol, \"scp\")\n        directory = ET.SubElement(scp, \"directory\")\n        directory.text = kwargs.pop('directory')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef firmware_download_input_protocol_type_scp_protocol_scp_file(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        scp_protocol = ET.SubElement(protocol_type, \"scp-protocol\")\n        scp = ET.SubElement(scp_protocol, \"scp\")\n        file = ET.SubElement(scp, \"file\")\n        file.text = kwargs.pop('file')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a firmware download input protocol - type scp - protocol scp - file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef firmware_download_input_protocol_type_ftp_protocol_ftp_user(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        ftp_protocol = ET.SubElement(protocol_type, \"ftp-protocol\")\n        ftp = ET.SubElement(ftp_protocol, \"ftp\")\n        user = ET.SubElement(ftp, \"user\")\n        user.text = kwargs.pop('user')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a Firmware Downloader input protocol - type ftp - protocol - ftp - user"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef firmware_download_input_protocol_type_ftp_protocol_ftp_password(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        ftp_protocol = ET.SubElement(protocol_type, \"ftp-protocol\")\n        ftp = ET.SubElement(ftp_protocol, \"ftp\")\n        password = ET.SubElement(ftp, \"password\")\n        password.text = kwargs.pop('password')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a Firmware Downloaded Entry with protocol - type ftp - protocol and password."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the config of a Firmware Downloader input protocol - type ftp - protocol - ftp - host", "response": "def firmware_download_input_protocol_type_ftp_protocol_ftp_host(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        ftp_protocol = ET.SubElement(protocol_type, \"ftp-protocol\")\n        ftp = ET.SubElement(ftp_protocol, \"ftp\")\n        host = ET.SubElement(ftp, \"host\")\n        host.text = kwargs.pop('host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the config of a Firmware Downloaded Entry with protocol - type and ftp - protocol ftp - directory.", "response": "def firmware_download_input_protocol_type_ftp_protocol_ftp_directory(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        ftp_protocol = ET.SubElement(protocol_type, \"ftp-protocol\")\n        ftp = ET.SubElement(ftp_protocol, \"ftp\")\n        directory = ET.SubElement(ftp, \"directory\")\n        directory.text = kwargs.pop('directory')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef firmware_download_input_protocol_type_ftp_protocol_ftp_file(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        ftp_protocol = ET.SubElement(protocol_type, \"ftp-protocol\")\n        ftp = ET.SubElement(ftp_protocol, \"ftp\")\n        file = ET.SubElement(ftp, \"file\")\n        file.text = kwargs.pop('file')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a Firmware Downloaded Entry with protocol type FTP Protocol and file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef firmware_download_input_protocol_type_sftp_protocol_sftp_user(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        sftp_protocol = ET.SubElement(protocol_type, \"sftp-protocol\")\n        sftp = ET.SubElement(sftp_protocol, \"sftp\")\n        user = ET.SubElement(sftp, \"user\")\n        user.text = kwargs.pop('user')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a Firmware Downloaded Protocol Type SFTP Protocol and User."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef firmware_download_input_protocol_type_sftp_protocol_sftp_password(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        sftp_protocol = ET.SubElement(protocol_type, \"sftp-protocol\")\n        sftp = ET.SubElement(sftp_protocol, \"sftp\")\n        password = ET.SubElement(sftp, \"password\")\n        password.text = kwargs.pop('password')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a Firmware Downloader input protocol - type SFTP Protocol and Password."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef firmware_download_input_protocol_type_sftp_protocol_sftp_host(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        sftp_protocol = ET.SubElement(protocol_type, \"sftp-protocol\")\n        sftp = ET.SubElement(sftp_protocol, \"sftp\")\n        host = ET.SubElement(sftp, \"host\")\n        host.text = kwargs.pop('host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a Firmware Downloaded Entry with protocol - type SFTP Protocol and SFTP Host."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the current Firmware Downloaded State of SFTP Protocol and SFTP Directory.", "response": "def firmware_download_input_protocol_type_sftp_protocol_sftp_directory(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        sftp_protocol = ET.SubElement(protocol_type, \"sftp-protocol\")\n        sftp = ET.SubElement(sftp_protocol, \"sftp\")\n        directory = ET.SubElement(sftp, \"directory\")\n        directory.text = kwargs.pop('directory')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the current version of the firmware download input protocol - type - sftp - protocol - sftp - file", "response": "def firmware_download_input_protocol_type_sftp_protocol_sftp_file(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        sftp_protocol = ET.SubElement(protocol_type, \"sftp-protocol\")\n        sftp = ET.SubElement(sftp_protocol, \"sftp\")\n        file = ET.SubElement(sftp, \"file\")\n        file.text = kwargs.pop('file')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef firmware_download_input_protocol_type_sftp_protocol_sftp_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        sftp_protocol = ET.SubElement(protocol_type, \"sftp-protocol\")\n        sftp = ET.SubElement(sftp_protocol, \"sftp\")\n        port = ET.SubElement(sftp, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current version of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef firmware_download_input_protocol_type_sftp_protocol_sftp_host_key_check(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        sftp_protocol = ET.SubElement(protocol_type, \"sftp-protocol\")\n        sftp = ET.SubElement(sftp_protocol, \"sftp\")\n        host_key_check = ET.SubElement(sftp, \"host-key-check\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a Firmware Downloaded Protocol Type SFTP Protocol and Host Key Check."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef firmware_download_input_protocol_type_usb_protocol_usb_directory(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        protocol_type = ET.SubElement(input, \"protocol-type\")\n        usb_protocol = ET.SubElement(protocol_type, \"usb-protocol\")\n        usb = ET.SubElement(usb_protocol, \"usb\")\n        directory = ET.SubElement(usb, \"directory\")\n        directory.text = kwargs.pop('directory')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a Firmware Downloader input protocol - type USB - Protocol USB - Directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef firmware_download_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a firmware download input with rbridge - id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef firmware_download_input_reboot_options_auto_activate_auto_activate(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        reboot_options = ET.SubElement(input, \"reboot-options\")\n        auto_activate = ET.SubElement(reboot_options, \"auto-activate\")\n        auto_activate = ET.SubElement(auto_activate, \"auto-activate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        Parse method for firmware download input reboot options auto - activate auto - activate."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the config of a Firmware Download and output of a Firmware Link", "response": "def firmware_download_output_fwdl_cmd_status(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        output = ET.SubElement(firmware_download, \"output\")\n        fwdl_cmd_status = ET.SubElement(output, \"fwdl-cmd-status\")\n        fwdl_cmd_status.text = kwargs.pop('fwdl_cmd_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the configuration of Firmware Download and output of Firmware Command Message.", "response": "def firmware_download_output_fwdl_cmd_msg(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        output = ET.SubElement(firmware_download, \"output\")\n        fwdl_cmd_msg = ET.SubElement(output, \"fwdl-cmd-msg\")\n        fwdl_cmd_msg.text = kwargs.pop('fwdl_cmd_msg')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the config of the firmware download output cluster output rbridge id.", "response": "def firmware_download_output_cluster_output_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        output = ET.SubElement(firmware_download, \"output\")\n        cluster_output = ET.SubElement(output, \"cluster-output\")\n        rbridge_id = ET.SubElement(cluster_output, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef firmware_download_output_cluster_output_fwdl_status(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        output = ET.SubElement(firmware_download, \"output\")\n        cluster_output = ET.SubElement(output, \"cluster-output\")\n        fwdl_status = ET.SubElement(cluster_output, \"fwdl-status\")\n        fwdl_status.text = kwargs.pop('fwdl_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of Firmware Downloader Cluster Output and FwdL status."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef firmware_download_output_cluster_output_fwdl_msg(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        output = ET.SubElement(firmware_download, \"output\")\n        cluster_output = ET.SubElement(output, \"cluster-output\")\n        fwdl_msg = ET.SubElement(cluster_output, \"fwdl-msg\")\n        fwdl_msg.text = kwargs.pop('fwdl_msg')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of Firmware Downloader Cluster Output and FwdL Message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef logical_chassis_fwdl_sanity_input_user(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        input = ET.SubElement(logical_chassis_fwdl_sanity, \"input\")\n        user = ET.SubElement(input, \"user\")\n        user.text = kwargs.pop('user')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set config logical_chassis_fwdl_sanity_input_user to user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset password for logical chassis forwards sanity input", "response": "def logical_chassis_fwdl_sanity_input_password(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        input = ET.SubElement(logical_chassis_fwdl_sanity, \"input\")\n        password = ET.SubElement(input, \"password\")\n        password.text = kwargs.pop('password')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef logical_chassis_fwdl_sanity_input_host(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        input = ET.SubElement(logical_chassis_fwdl_sanity, \"input\")\n        host = ET.SubElement(input, \"host\")\n        host.text = kwargs.pop('host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis fwdl sanity input host"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef logical_chassis_fwdl_sanity_input_directory(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        input = ET.SubElement(logical_chassis_fwdl_sanity, \"input\")\n        directory = ET.SubElement(input, \"directory\")\n        directory.text = kwargs.pop('directory')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis fwdl sanity input directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets config logical_chassis_fwdl_sanity_input_file to be used when creating logical chassis_fwdl_sanity", "response": "def logical_chassis_fwdl_sanity_input_file(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        input = ET.SubElement(logical_chassis_fwdl_sanity, \"input\")\n        file = ET.SubElement(input, \"file\")\n        file.text = kwargs.pop('file')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef logical_chassis_fwdl_sanity_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        input = ET.SubElement(logical_chassis_fwdl_sanity, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis - fwdl - sanity input rbridge - id."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef logical_chassis_fwdl_sanity_input_cluster_options_auto_activate_auto_activate(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        input = ET.SubElement(logical_chassis_fwdl_sanity, \"input\")\n        cluster_options = ET.SubElement(input, \"cluster-options\")\n        auto_activate = ET.SubElement(cluster_options, \"auto-activate\")\n        auto_activate = ET.SubElement(auto_activate, \"auto-activate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        is an auto - activate option for logical chassis forwarding sanity input cluster - options auto - activate auto - activate"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets logical chassis fwdl sanity input cluster - options coldboot coldboot", "response": "def logical_chassis_fwdl_sanity_input_cluster_options_coldboot_coldboot(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        input = ET.SubElement(logical_chassis_fwdl_sanity, \"input\")\n        cluster_options = ET.SubElement(input, \"cluster-options\")\n        coldboot = ET.SubElement(cluster_options, \"coldboot\")\n        coldboot = ET.SubElement(coldboot, \"coldboot\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef logical_chassis_fwdl_sanity_input_protocol(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        input = ET.SubElement(logical_chassis_fwdl_sanity, \"input\")\n        protocol = ET.SubElement(input, \"protocol\")\n        protocol.text = kwargs.pop('protocol')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis fwdl sanity input protocol."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef logical_chassis_fwdl_sanity_output_fwdl_cmd_status(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        output = ET.SubElement(logical_chassis_fwdl_sanity, \"output\")\n        fwdl_cmd_status = ET.SubElement(output, \"fwdl-cmd-status\")\n        fwdl_cmd_status.text = kwargs.pop('fwdl_cmd_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis fwdl sanity output and fwdl command status."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef logical_chassis_fwdl_sanity_output_fwdl_cmd_msg(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        output = ET.SubElement(logical_chassis_fwdl_sanity, \"output\")\n        fwdl_cmd_msg = ET.SubElement(output, \"fwdl-cmd-msg\")\n        fwdl_cmd_msg.text = kwargs.pop('fwdl_cmd_msg')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set the config of a logical chassis fwdl sanity output and fwdl - cmd - msg."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef logical_chassis_fwdl_sanity_output_cluster_output_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        output = ET.SubElement(logical_chassis_fwdl_sanity, \"output\")\n        cluster_output = ET.SubElement(output, \"cluster-output\")\n        rbridge_id = ET.SubElement(cluster_output, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis sanity output cluster output rbridge id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef logical_chassis_fwdl_sanity_output_cluster_output_fwdl_status(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        output = ET.SubElement(logical_chassis_fwdl_sanity, \"output\")\n        cluster_output = ET.SubElement(output, \"cluster-output\")\n        fwdl_status = ET.SubElement(cluster_output, \"fwdl-status\")\n        fwdl_status.text = kwargs.pop('fwdl_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis fwdl sanity output cluster output fwdl status"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding FwdL message to logical_chassis_fwdl_sanity output cluster output fwdl message.", "response": "def logical_chassis_fwdl_sanity_output_cluster_output_fwdl_msg(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_sanity = ET.Element(\"logical_chassis_fwdl_sanity\")\n        config = logical_chassis_fwdl_sanity\n        output = ET.SubElement(logical_chassis_fwdl_sanity, \"output\")\n        cluster_output = ET.SubElement(output, \"cluster-output\")\n        fwdl_msg = ET.SubElement(cluster_output, \"fwdl-msg\")\n        fwdl_msg.text = kwargs.pop('fwdl_msg')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef logical_chassis_fwdl_status_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        input = ET.SubElement(logical_chassis_fwdl_status, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis fwdl status input rbridge - id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset output and overall status of logical chassis forwards lis", "response": "def logical_chassis_fwdl_status_output_overall_status(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        overall_status = ET.SubElement(output, \"overall-status\")\n        overall_status.text = kwargs.pop('overall_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef logical_chassis_fwdl_status_output_cluster_fwdl_entries_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        cluster_fwdl_entries = ET.SubElement(output, \"cluster-fwdl-entries\")\n        rbridge_id = ET.SubElement(cluster_fwdl_entries, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis fwdl status output cluster - fwdl entries rbridge - id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef logical_chassis_fwdl_status_output_cluster_fwdl_entries_fwdl_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        cluster_fwdl_entries = ET.SubElement(output, \"cluster-fwdl-entries\")\n        fwdl_state = ET.SubElement(cluster_fwdl_entries, \"fwdl-state\")\n        fwdl_state.text = kwargs.pop('fwdl_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis fwdl status output cluster - fwdl - entries fwdl state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting logical chassis fwdl status output cluster - fwdl - entries fwdl entries index.", "response": "def logical_chassis_fwdl_status_output_cluster_fwdl_entries_fwdl_entries_index(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        cluster_fwdl_entries = ET.SubElement(output, \"cluster-fwdl-entries\")\n        fwdl_entries = ET.SubElement(cluster_fwdl_entries, \"fwdl-entries\")\n        index = ET.SubElement(fwdl_entries, \"index\")\n        index.text = kwargs.pop('index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting logical chassis fwdl status output cluster - fwdl - entries fwdl - entries message - id", "response": "def logical_chassis_fwdl_status_output_cluster_fwdl_entries_fwdl_entries_message_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        cluster_fwdl_entries = ET.SubElement(output, \"cluster-fwdl-entries\")\n        fwdl_entries = ET.SubElement(cluster_fwdl_entries, \"fwdl-entries\")\n        message_id = ET.SubElement(fwdl_entries, \"message-id\")\n        message_id.text = kwargs.pop('message_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget logical chassis fwdl status output cluster - fwdl - entries date - and - time - info.", "response": "def logical_chassis_fwdl_status_output_cluster_fwdl_entries_fwdl_entries_date_and_time_info(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        cluster_fwdl_entries = ET.SubElement(output, \"cluster-fwdl-entries\")\n        fwdl_entries = ET.SubElement(cluster_fwdl_entries, \"fwdl-entries\")\n        date_and_time_info = ET.SubElement(fwdl_entries, \"date-and-time-info\")\n        date_and_time_info.text = kwargs.pop('date_and_time_info')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef logical_chassis_fwdl_status_output_cluster_fwdl_entries_fwdl_entries_message(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        cluster_fwdl_entries = ET.SubElement(output, \"cluster-fwdl-entries\")\n        fwdl_entries = ET.SubElement(cluster_fwdl_entries, \"fwdl-entries\")\n        message = ET.SubElement(fwdl_entries, \"message\")\n        message.text = kwargs.pop('message')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Parse the logical chassis fwdl status output cluster - fwdl - entries fwdl - entries message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting logical_chassis_fwdl_status output cluster - fwdl - entries and blade - slot.", "response": "def logical_chassis_fwdl_status_output_cluster_fwdl_entries_fwdl_entries_blade_slot(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        cluster_fwdl_entries = ET.SubElement(output, \"cluster-fwdl-entries\")\n        fwdl_entries = ET.SubElement(cluster_fwdl_entries, \"fwdl-entries\")\n        blade_slot = ET.SubElement(fwdl_entries, \"blade-slot\")\n        blade_slot.text = kwargs.pop('blade_slot')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets logical chassis fwdl status output cluster - fwdl - entries and blade - swbd.", "response": "def logical_chassis_fwdl_status_output_cluster_fwdl_entries_fwdl_entries_blade_swbd(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        cluster_fwdl_entries = ET.SubElement(output, \"cluster-fwdl-entries\")\n        fwdl_entries = ET.SubElement(cluster_fwdl_entries, \"fwdl-entries\")\n        blade_swbd = ET.SubElement(fwdl_entries, \"blade-swbd\")\n        blade_swbd.text = kwargs.pop('blade_swbd')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef logical_chassis_fwdl_status_output_cluster_fwdl_entries_fwdl_entries_blade_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        cluster_fwdl_entries = ET.SubElement(output, \"cluster-fwdl-entries\")\n        fwdl_entries = ET.SubElement(cluster_fwdl_entries, \"fwdl-entries\")\n        blade_name = ET.SubElement(fwdl_entries, \"blade-name\")\n        blade_name.text = kwargs.pop('blade_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis fwdl status output cluster - fwdl - entries and blade name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef logical_chassis_fwdl_status_output_cluster_fwdl_entries_fwdl_entries_blade_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        cluster_fwdl_entries = ET.SubElement(output, \"cluster-fwdl-entries\")\n        fwdl_entries = ET.SubElement(cluster_fwdl_entries, \"fwdl-entries\")\n        blade_state = ET.SubElement(fwdl_entries, \"blade-state\")\n        blade_state.text = kwargs.pop('blade_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis fwdl status output cluster - fwdl - entries and blade state"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef logical_chassis_fwdl_status_output_cluster_fwdl_entries_fwdl_entries_blade_app(self, **kwargs):\n        config = ET.Element(\"config\")\n        logical_chassis_fwdl_status = ET.Element(\"logical_chassis_fwdl_status\")\n        config = logical_chassis_fwdl_status\n        output = ET.SubElement(logical_chassis_fwdl_status, \"output\")\n        cluster_fwdl_entries = ET.SubElement(output, \"cluster-fwdl-entries\")\n        fwdl_entries = ET.SubElement(cluster_fwdl_entries, \"fwdl-entries\")\n        blade_app = ET.SubElement(fwdl_entries, \"blade-app\")\n        blade_app.text = kwargs.pop('blade_app')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get logical chassis fwdl status output cluster - fwdl - entries and blade - app."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dad_status_output_dad_last_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        dad_status = ET.Element(\"dad_status\")\n        config = dad_status\n        output = ET.SubElement(dad_status, \"output\")\n        dad_last_state = ET.SubElement(output, \"dad-last-state\")\n        dad_last_state.text = kwargs.pop('dad_last_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set DAD status output to last state of the DAD entry."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dad_status_output_dad_status_entries_index(self, **kwargs):\n        config = ET.Element(\"config\")\n        dad_status = ET.Element(\"dad_status\")\n        config = dad_status\n        output = ET.SubElement(dad_status, \"output\")\n        dad_status_entries = ET.SubElement(output, \"dad-status-entries\")\n        index = ET.SubElement(dad_status_entries, \"index\")\n        index.text = kwargs.pop('index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set index attribute of DAD status entries output element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the date and time info of the DAD status entries.", "response": "def dad_status_output_dad_status_entries_date_and_time_info(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        dad_status = ET.Element(\"dad_status\")\n        config = dad_status\n        output = ET.SubElement(dad_status, \"output\")\n        dad_status_entries = ET.SubElement(output, \"dad-status-entries\")\n        date_and_time_info = ET.SubElement(dad_status_entries, \"date-and-time-info\")\n        date_and_time_info.text = kwargs.pop('date_and_time_info')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef event_handler_event_handler_list_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        event_handler = ET.SubElement(config, \"event-handler\", xmlns=\"urn:brocade.com:mgmt:brocade-event-handler\")\n        event_handler_list = ET.SubElement(event_handler, \"event-handler-list\")\n        name = ET.SubElement(event_handler_list, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the event handler list"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef event_handler_event_handler_list_trigger_trigger_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        event_handler = ET.SubElement(config, \"event-handler\", xmlns=\"urn:brocade.com:mgmt:brocade-event-handler\")\n        event_handler_list = ET.SubElement(event_handler, \"event-handler-list\")\n        name_key = ET.SubElement(event_handler_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        trigger = ET.SubElement(event_handler_list, \"trigger\")\n        trigger_id = ET.SubElement(trigger, \"trigger-id\")\n        trigger_id.text = kwargs.pop('trigger_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a resource from the event handler list trigger and trigger id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef event_handler_event_handler_list_trigger_trigger_choice_vcs_vcs(self, **kwargs):\n        config = ET.Element(\"config\")\n        event_handler = ET.SubElement(config, \"event-handler\", xmlns=\"urn:brocade.com:mgmt:brocade-event-handler\")\n        event_handler_list = ET.SubElement(event_handler, \"event-handler-list\")\n        name_key = ET.SubElement(event_handler_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        trigger = ET.SubElement(event_handler_list, \"trigger\")\n        trigger_id_key = ET.SubElement(trigger, \"trigger-id\")\n        trigger_id_key.text = kwargs.pop('trigger_id')\n        trigger_choice = ET.SubElement(trigger, \"trigger-choice\")\n        vcs = ET.SubElement(trigger_choice, \"vcs\")\n        vcs = ET.SubElement(vcs, \"vcs\")\n        vcs.text = kwargs.pop('vcs')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config from event handler event handler list trigger choice VCS"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef event_handler_event_handler_list_action_action_choice_python_script_python_script(self, **kwargs):\n        config = ET.Element(\"config\")\n        event_handler = ET.SubElement(config, \"event-handler\", xmlns=\"urn:brocade.com:mgmt:brocade-event-handler\")\n        event_handler_list = ET.SubElement(event_handler, \"event-handler-list\")\n        name_key = ET.SubElement(event_handler_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        action = ET.SubElement(event_handler_list, \"action\")\n        action_choice = ET.SubElement(action, \"action-choice\")\n        python_script = ET.SubElement(action_choice, \"python-script\")\n        python_script = ET.SubElement(python_script, \"python-script\")\n        python_script.text = kwargs.pop('python_script')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the event handler list action - choice - python - script"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets HTTP Sa HTTP VRF Continuation and VRF Name from HTTP server.", "response": "def http_sa_http_server_http_vrf_cont_use_vrf_use_vrf_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        http_sa = ET.SubElement(config, \"http-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-http\")\n        http = ET.SubElement(http_sa, \"http\")\n        server = ET.SubElement(http, \"server\")\n        http_vrf_cont = ET.SubElement(server, \"http-vrf-cont\")\n        use_vrf = ET.SubElement(http_vrf_cont, \"use-vrf\")\n        use_vrf_name = ET.SubElement(use_vrf, \"use-vrf-name\")\n        use_vrf_name.text = kwargs.pop('use_vrf_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef http_sa_http_server_http_vrf_cont_use_vrf_http_vrf_shutdown(self, **kwargs):\n        config = ET.Element(\"config\")\n        http_sa = ET.SubElement(config, \"http-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-http\")\n        http = ET.SubElement(http_sa, \"http\")\n        server = ET.SubElement(http, \"server\")\n        http_vrf_cont = ET.SubElement(server, \"http-vrf-cont\")\n        use_vrf = ET.SubElement(http_vrf_cont, \"use-vrf\")\n        use_vrf_name_key = ET.SubElement(use_vrf, \"use-vrf-name\")\n        use_vrf_name_key.text = kwargs.pop('use_vrf_name')\n        http_vrf_shutdown = ET.SubElement(use_vrf, \"http-vrf-shutdown\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize the object level http_sa http server http - vrf - cont use - vrf http - vrf - shutdown"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_to_class(self, cls, name):\n        '''\n        Overrides the base class to add a PhoheNumberDescriptor rather than the standard FieldDescriptor\n        '''\n        self.model_class = cls\n        setattr(cls, name, PhoneNumberDescriptor(self))\n        self._bound = True", "response": "Adds a PhoneNumberDescriptor to the given class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_app(self, app):\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n\n        service_name = app.config.get('GSSAPI_SERVICE_NAME', 'HTTP')\n        hostname = app.config.get('GSSAPI_HOSTNAME', socket.getfqdn())\n        principal = '{}@{}'.format(service_name, hostname)\n        name = gssapi.Name(principal, gssapi.NameType.hostbased_service)\n\n        app.extensions['gssapi'] = {\n            'creds': gssapi.Credentials(name=name, usage='accept'),\n        }", "response": "Initializes the Negotiate extension for the given application."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef authenticate(self):\n        if request.headers.get('Authorization', '').startswith('Negotiate '):\n            in_token = base64.b64decode(request.headers['Authorization'][10:])\n\n            try:\n                creds = current_app.extensions['gssapi']['creds']\n            except KeyError:\n                raise RuntimeError('flask-gssapi not configured for this app')\n\n            ctx = gssapi.SecurityContext(creds=creds, usage='accept')\n\n            out_token = ctx.step(in_token)\n\n            if ctx.complete:\n                username = ctx._inquire(initiator_name=True).initiator_name\n                return str(username), out_token\n\n        return None, None", "response": "Attempts to authenticate the user if a token was provided."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef require_user(self, *users, user=None):\n\n        # accept old-style single user keyword-argument as well\n        if user:\n            users = (*users, user)\n\n        def _require_auth(view_func):\n            @wraps(view_func)\n            def wrapper(*args, **kwargs):\n                \"\"\" Effective wrapper \"\"\"\n                username, out_token = self.authenticate()\n                if username and out_token:\n                    b64_token = base64.b64encode(out_token).decode('utf-8')\n                    auth_data = 'Negotiate {0}'.format(b64_token)\n                    if not users or username in users:\n                        response = make_response(view_func(*args,\n                                                           username=username,\n                                                           **kwargs))\n                    else:\n                        response = Response(status=403)\n                    response.headers['WWW-Authenticate'] = auth_data\n                    return response\n                return Response(\n                    status=401,\n                    headers={'WWW-Authenticate': 'Negotiate'},\n                )\n\n            return wrapper\n        return _require_auth", "response": "A decorator to protect views with Negotiate authentication."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the username access time", "response": "def username_access_time(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        username = ET.SubElement(config, \"username\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        name_key = ET.SubElement(username, \"name\")\n        name_key.text = kwargs.pop('name')\n        access_time = ET.SubElement(username, \"access-time\")\n        access_time.text = kwargs.pop('access_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef username_end_time(self, **kwargs):\n        config = ET.Element(\"config\")\n        username = ET.SubElement(config, \"username\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        name_key = ET.SubElement(username, \"name\")\n        name_key.text = kwargs.pop('name')\n        end_time = ET.SubElement(username, \"end-time\")\n        end_time.text = kwargs.pop('end_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set username end time"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef radius_server_host_hostname(self, **kwargs):\n        config = ET.Element(\"config\")\n        radius_server = ET.SubElement(config, \"radius-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(radius_server, \"host\")\n        use_vrf_key = ET.SubElement(host, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        hostname = ET.SubElement(host, \"hostname\")\n        hostname.text = kwargs.pop('hostname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a resource from the radius server host hostname."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset use - vrf of the host element.", "response": "def radius_server_host_use_vrf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        radius_server = ET.SubElement(config, \"radius-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(radius_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        use_vrf = ET.SubElement(host, \"use-vrf\")\n        use_vrf.text = kwargs.pop('use_vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the configuration of a resource from the RADIUS server host and protocol.", "response": "def radius_server_host_protocol(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        radius_server = ET.SubElement(config, \"radius-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(radius_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        use_vrf_key = ET.SubElement(host, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        protocol = ET.SubElement(host, \"protocol\")\n        protocol.text = kwargs.pop('protocol')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tacacs_server_host_use_vrf(self, **kwargs):\n        config = ET.Element(\"config\")\n        tacacs_server = ET.SubElement(config, \"tacacs-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(tacacs_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        use_vrf = ET.SubElement(host, \"use-vrf\")\n        use_vrf.text = kwargs.pop('use_vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a resource from the TACACS Server host field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the configuration of the current resource.", "response": "def tacacs_server_host_protocol(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        tacacs_server = ET.SubElement(config, \"tacacs-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(tacacs_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        use_vrf_key = ET.SubElement(host, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        protocol = ET.SubElement(host, \"protocol\")\n        protocol.text = kwargs.pop('protocol')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tacacs_server_host_key(self, **kwargs):\n        config = ET.Element(\"config\")\n        tacacs_server = ET.SubElement(config, \"tacacs-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(tacacs_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        use_vrf_key = ET.SubElement(host, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        key = ET.SubElement(host, \"key\")\n        key.text = kwargs.pop('key')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the current resource from the tacacs server host key."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ldap_server_host_use_vrf(self, **kwargs):\n        config = ET.Element(\"config\")\n        ldap_server = ET.SubElement(config, \"ldap-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(ldap_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        use_vrf = ET.SubElement(host, \"use-vrf\")\n        use_vrf.text = kwargs.pop('use_vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set use - vrf of LDAP server host"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ldap_server_host_retries(self, **kwargs):\n        config = ET.Element(\"config\")\n        ldap_server = ET.SubElement(config, \"ldap-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(ldap_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        use_vrf_key = ET.SubElement(host, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        retries = ET.SubElement(host, \"retries\")\n        retries.text = kwargs.pop('retries')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDAP Server Host Retry list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ldap_server_host_timeout(self, **kwargs):\n        config = ET.Element(\"config\")\n        ldap_server = ET.SubElement(config, \"ldap-server\", xmlns=\"urn:brocade.com:mgmt:brocade-aaa\")\n        host = ET.SubElement(ldap_server, \"host\")\n        hostname_key = ET.SubElement(host, \"hostname\")\n        hostname_key.text = kwargs.pop('hostname')\n        use_vrf_key = ET.SubElement(host, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        timeout = ET.SubElement(host, \"timeout\")\n        timeout.text = kwargs.pop('timeout')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get LDAP server host timeout"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(self, name, description):\n\n        name = name.strip()\n\n        if '<' in name:\n            self.required = True\n            self.boolean = False\n            name = name[:name.index('<')].strip()\n        elif '[' in name:\n            self.required = False\n            self.boolean = False\n            name = name[:name.index('[')].strip()\n        else:\n            self.required = False\n            self.boolean = True\n\n        regex = re.compile(r'(-\\w)?(?:\\,\\s*)?(--[\\w\\-]+)?')\n\n        m = regex.findall(name)\n        if not m:\n            raise ValueError('Invalid Option: %s', name)\n\n        shortname, longname = m[0]\n\n        if not shortname and not longname:\n            raise ValueError('Invalid Option: %s', name)\n\n        self.shortname = shortname\n        self.longname = longname\n\n        # parse store key\n        if longname and longname.startswith('--no-'):\n            self.key = longname[5:]\n        elif longname:\n            self.key = longname[2:]\n        else:\n            self.key = shortname\n\n        if self.boolean:\n            # boolean don't need to parse from description\n            if longname and longname.startswith('--no-'):\n                self.default = True\n            else:\n                self.default = False\n            return self\n\n        if not description:\n            self.default = None\n            return self\n\n        # parse default value from description\n        regex = re.compile(r'\\sdefault:(.*)$')\n        m = regex.findall(description)\n        if not m:\n            self.default = None\n            return self\n\n        # if it has a default value, it is not required\n        self.required = False\n\n        value = m[0].strip()\n        if value.startswith('<') and value.endswith('>'):\n            value = value[1:-1]\n        elif value.startswith('[') and value.endswith(']'):\n            value = value[1:-1]\n\n        self.default = value.strip()\n        return self", "response": "Parse option name.\n\n        :param name: option's name\n        :param description: option's description\n\n        Parsing acceptable names:\n\n            * -f: shortname\n            * --force: longname\n            * -f, --force: shortname and longname\n            * -o <output>: shortname and a required value\n            * -o, --output [output]: shortname, longname and optional value\n\n        Parsing default value from description:\n\n            * source directory, default: src\n            * source directory, default: [src]\n            * source directory, default: <src>"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_python(self, value=None):\n\n        if value is None:\n            return self.default\n\n        if self.resolve:\n            return self.resolve(value)\n        return value", "response": "Transform the option value to python data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, key):\n\n        value = self._results.get(key)\n        if value is not None:\n            return value\n\n        # get from option default value\n        option = list(filter(lambda o: o.key == key, self._option_list))\n        if not option:\n            raise ValueError('No such option: %s' % key)\n\n        option = option[0]\n        return option.default", "response": "Get the value of a key from the parsed result."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds or get option.", "response": "def option(self, name, description=None, action=None, resolve=None):\n        \"\"\"\n        Add or get option.\n\n        Here are some examples::\n\n            command.option('-v, --verbose', 'show more log')\n            command.option('--tag <tag>', 'tag of the package')\n            command.option('-s, --source <source>', 'the source repo')\n\n        :param name: arguments of the option\n        :param description: description of the option\n        :param action: a function to be invoked\n        :param resolve: a function to resolve the data\n\n        \"\"\"\n\n        if isinstance(name, Option):\n            option = name\n        else:\n            name = name.strip()\n            option = Option(\n                name=name, description=description,\n                action=action, resolve=resolve,\n            )\n\n        self._option_list.append(option)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_options(self, arg):\n\n        if not arg.startswith('-'):\n            return False\n\n        value = None\n        if '=' in arg:\n            arg, value = arg.split('=')\n\n        for option in self._option_list:\n\n            if arg not in (option.shortname, option.longname):\n                continue\n\n            action = option.action\n            if action:\n                action()\n\n            if option.key == option.shortname:\n                self._results[option.key] = True\n                return True\n\n            if option.boolean and option.default:\n                self._results[option.key] = False\n                return True\n\n            if option.boolean:\n                self._results[option.key] = True\n                return True\n\n            # has tag, it should has value\n            if not value:\n                if self._argv:\n                    value = self._argv[0]\n                    self._argv = self._argv[1:]\n\n            if not value:\n                raise RuntimeError('Missing value for: %s' % option.name)\n\n            self._results[option.key] = option.to_python(value)\n            return True\n\n        return False", "response": "Parse the options with the argv\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef action(self, command):\n\n        if isinstance(command, Command):\n            self._command_list.append(command)\n            return command\n\n        # it is a function\n        func = command\n        args, varargs, keywords, defaults = inspect.getargspec(func)\n\n        if func.__doc__:\n            doclines = func.__doc__.splitlines()\n        else:\n            doclines = []\n        doclines = filter(lambda o: o.strip(), doclines)\n        doclines = list(map(lambda o: o.strip(), doclines))\n\n        params = {}\n        options = {}\n        usage = None\n\n        for line in doclines:\n            if line.startswith('usage:'):\n                usage = line[6:].strip()\n            elif line.startswith(':param '):\n                name, desc = line[7:].split(':', 1)\n                params[name.strip()] = desc.strip()\n            elif line.startswith(':option '):\n                name, desc = line[8:].split(':', 1)\n                options[name.strip()] = desc.strip()\n\n        desc = None\n        if doclines:\n            desc = doclines[0]\n\n        # use self.__class__ instead of Command for inherit\n        cmd = self.__class__(func.__name__, desc, usage=usage)\n\n        defaults = defaults or []\n        kwargs = dict(zip(*[reversed(i) for i in (args, defaults)]))\n\n        for arg in args:\n            desc = params.get(arg, None)\n            name = options.get(arg, None)\n            if arg in kwargs:\n                value = kwargs[arg]\n                if value is True:\n                    name = name or '--no-%s' % arg\n                    option = Option(name, desc)\n                elif value is False:\n                    name = name or '-%s, --%s' % (arg[0], arg)\n                    option = Option(name, desc)\n                else:\n                    name = name or '-%s, --%s [%s]' % (arg[0], arg, arg)\n                    option = Option(name, desc)\n                    option.default = value\n\n                cmd.option(option)\n            elif desc:\n                # if has description, it is a required option\n                name = name or '-%s, --%s <%s>' % (arg[0], arg, arg)\n                cmd.option(name, desc)\n            else:\n                # positional arguments\n                cmd._positional_list.append(arg)\n\n        cmd._command_func = func\n        self._command_list.append(cmd)\n        return command", "response": "Add a command to the list of available commands."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(self, argv=None):\n\n        if not argv:\n            argv = sys.argv\n        elif isinstance(argv, str):\n            argv = argv.split()\n\n        self._argv = argv[1:]\n        if not self._argv:\n            self.validate_options()\n            if self._command_func:\n                self._command_func(**self._results)\n                return True\n            return False\n\n        cmd = self._argv[0]\n\n        if not cmd.startswith('-'):\n            # parse subcommands\n            for command in self._command_list:\n                if isinstance(command, Command) and command._name == cmd:\n                    command._parent = self\n                    return command.parse(self._argv)\n\n        _positional_index = 0\n        while self._argv:\n            arg = self._argv[0]\n            self._argv = self._argv[1:]\n            if not self.parse_options(arg):\n                self._args_results.append(arg)\n                if len(self._positional_list) > _positional_index:\n                    # positional arguments\n                    key = self._positional_list[_positional_index]\n                    self._results[key] = arg\n                    _positional_index += 1\n\n        # validate\n        self.validate_options()\n\n        if self._parent and isinstance(self._parent, Command):\n            self._parent._args_results = self._args_results\n\n        if self._command_func:\n            self._command_func(**self._results)\n            return True\n        return False", "response": "Parse the command line arguments of the terminal and return a boolean indicating if the command was successful or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprints the program version.", "response": "def print_version(self):\n        \"\"\"\n        Print the program version.\n        \"\"\"\n\n        if not self._version:\n            return self\n\n        if not self._title:\n            print('  %s %s' % (self._name, self._version))\n            return self\n\n        print('  %s (%s %s)' % (self._title, self._name, self._version))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_help(self):\n\n        print('\\n  %s %s' % (self._title or self._name, self._version or ''))\n\n        if self._usage:\n            print('\\n  %s' % self._usage)\n        else:\n            cmd = self._name\n            if hasattr(self, '_parent') and isinstance(self._parent, Command):\n                cmd = '%s %s' % (self._parent._name, cmd)\n\n            if self._command_list:\n                usage = 'Usage: %s <command> [option]' % cmd\n            else:\n                usage = 'Usage: %s [option]' % cmd\n\n            pos = ' '.join(['<%s>' % name for name in self._positional_list])\n            print('\\n  %s %s' % (usage, pos))\n\n        arglen = max(len(o.name) for o in self._option_list)\n        arglen += 2\n\n        self.print_title('\\n  Options:\\n')\n        for o in self._option_list:\n            print('    %s %s' % (_pad(o.name, arglen), o.description or ''))\n        print('')\n\n        if self._command_list:\n            self.print_title('  Commands:\\n')\n            for cmd in self._command_list:\n                if isinstance(cmd, Command):\n                    name = _pad(cmd._name, arglen)\n                    desc = cmd._description or ''\n                    print('    %s %s' % (_pad(name, arglen), desc))\n\n            print('')\n\n        if self._help_footer:\n            print(self._help_footer)\n            print('')\n\n        return self", "response": "Print the help menu."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets device s chassis name.", "response": "def chassis_name(self, **kwargs):\n        \"\"\"Get device's chassis name/Model.\n\n        Args:\n            rbridge_id (str): The rbridge ID of the device\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `rbridge_id` is not specified.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.211', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.system.chassis_name(rbridge_id='225')\n            ...     assert output == 'VDX6740'\n        \"\"\"\n        namespace = \"urn:brocade.com:mgmt:brocade-rbridge\"\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        chassis_name = ' '\n        callback = kwargs.pop('callback', self._callback)\n        rid_args = dict(rbridge_id=rbridge_id, chassis_name=chassis_name)\n        rid = getattr(self._rbridge,\n                      'rbridge_id_switch_attributes_chassis_name')\n        config = rid(**rid_args)\n        output = callback(config, handler='get_config')\n        chassis_name = output.data.find('.//{%s}chassis-name' % namespace).text\n        return chassis_name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconfiguring device s Router ID.", "response": "def router_id(self, **kwargs):\n        \"\"\"Configures device's Router ID.\n\n        Args:\n            router_id (str): Router ID for the device.\n            rbridge_id (str): The rbridge ID of the device on which BGP will be\n                configured in a VCS fabric.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `router_id` is not specified.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.211', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.system.router_id(router_id='10.24.39.211',\n            ...     rbridge_id='225')\n            ...     dev.system.router_id() # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        router_id = kwargs.pop('router_id')\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        rid_args = dict(rbridge_id=rbridge_id, router_id=router_id)\n        config = self._rbridge.rbridge_id_ip_rtm_config_router_id(**rid_args)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconfiguring device s rbridge ID.", "response": "def rbridge_id(self, **kwargs):\n        \"\"\"Configures device's rbridge ID. Setting this property will need\n        a switch reboot\n\n        Args:\n            rbridge_id (str): The rbridge ID of the device on which BGP will be\n                configured in a VCS fabric.\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `rbridge_id` is not specified.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.211', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.system.rbridge_id(rbridge_id='225')\n            ...     output = dev.system.rbridge_id(rbridge_id='225', get=True)\n            ...     dev.system.rbridge_id() # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        is_get_config = kwargs.pop('get', False)\n        if not is_get_config:\n            rbridge_id = kwargs.pop('rbridge_id')\n        else:\n            rbridge_id = ''\n        callback = kwargs.pop('callback', self._callback)\n        rid_args = dict(rbridge_id=rbridge_id)\n        rid = getattr(self._rbridge,\n                      'rbridge_id_rbridge_id')\n        config = rid(**rid_args)\n        if is_get_config:\n            return callback(config, handler='get_config')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Port Channel Information Input Request Type Get Request Aggregator Id", "response": "def get_port_channel_detail_input_request_type_get_request_aggregator_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        input = ET.SubElement(get_port_channel_detail, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        aggregator_id = ET.SubElement(get_request, \"aggregator-id\")\n        aggregator_id.text = kwargs.pop('aggregator_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Port Channel Details input request type get next request last aggregator id", "response": "def get_port_channel_detail_input_request_type_get_next_request_last_aggregator_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        input = ET.SubElement(get_port_channel_detail, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        last_aggregator_id = ET.SubElement(get_next_request, \"last-aggregator-id\")\n        last_aggregator_id.text = kwargs.pop('last_aggregator_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_port_channel_detail_output_lacp_aggregator_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        aggregator_id = ET.SubElement(lacp, \"aggregator-id\")\n        aggregator_id.text = kwargs.pop('aggregator_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Channel Detail output LACP aggregator ID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_port_channel_detail_output_lacp_aggregator_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        aggregator_type = ET.SubElement(lacp, \"aggregator-type\")\n        aggregator_type.text = kwargs.pop('aggregator_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Channel Detail output LACP aggregator type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting Port Channel Detail output LACP and Isvlag.", "response": "def get_port_channel_detail_output_lacp_isvlag(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        isvlag = ET.SubElement(lacp, \"isvlag\")\n        isvlag.text = kwargs.pop('isvlag')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_port_channel_detail_output_lacp_aggregator_mode(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        aggregator_mode = ET.SubElement(lacp, \"aggregator-mode\")\n        aggregator_mode.text = kwargs.pop('aggregator_mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Channel Detail output LACP aggregator mode."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Port Channel Detail output LACP admin key.", "response": "def get_port_channel_detail_output_lacp_admin_key(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        admin_key = ET.SubElement(lacp, \"admin-key\")\n        admin_key.text = kwargs.pop('admin_key')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_port_channel_detail_output_lacp_oper_key(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        oper_key = ET.SubElement(lacp, \"oper-key\")\n        oper_key.text = kwargs.pop('oper_key')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Channel Detail output LACP Oper Key"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_port_channel_detail_output_lacp_actor_system_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        actor_system_id = ET.SubElement(lacp, \"actor-system-id\")\n        actor_system_id.text = kwargs.pop('actor_system_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Channel Detail output LACP actor system ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets Port Channel Detail output LACP Partner System ID.", "response": "def get_port_channel_detail_output_lacp_partner_system_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        partner_system_id = ET.SubElement(lacp, \"partner-system-id\")\n        partner_system_id.text = kwargs.pop('partner_system_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets Port Channel Detail output LACP system priority.", "response": "def get_port_channel_detail_output_lacp_system_priority(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        system_priority = ET.SubElement(lacp, \"system-priority\")\n        system_priority.text = kwargs.pop('system_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets Port Channel Detail output LACP Partner Oper Priority.", "response": "def get_port_channel_detail_output_lacp_partner_oper_priority(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        partner_oper_priority = ET.SubElement(lacp, \"partner-oper-priority\")\n        partner_oper_priority.text = kwargs.pop('partner_oper_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_port_channel_detail_output_lacp_rx_link_count(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        rx_link_count = ET.SubElement(lacp, \"rx-link-count\")\n        rx_link_count.text = kwargs.pop('rx_link_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Channel Detail output LACP and RX Link Count"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_port_channel_detail_output_lacp_tx_link_count(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        tx_link_count = ET.SubElement(lacp, \"tx-link-count\")\n        tx_link_count.text = kwargs.pop('tx_link_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Channel Detail output LACP Tx Link Count"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Port Channel Detail output LACP Individual Aggregation", "response": "def get_port_channel_detail_output_lacp_individual_agg(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        individual_agg = ET.SubElement(lacp, \"individual-agg\")\n        individual_agg.text = kwargs.pop('individual_agg')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget Port Channel Information Output LACP Ready Aggregation", "response": "def get_port_channel_detail_output_lacp_ready_agg(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        ready_agg = ET.SubElement(lacp, \"ready-agg\")\n        ready_agg.text = kwargs.pop('ready_agg')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_port_channel_detail_output_lacp_partner_oper_key(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        partner_oper_key = ET.SubElement(lacp, \"partner-oper-key\")\n        partner_oper_key.text = kwargs.pop('partner_oper_key')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Channel Detail output LACP Partner Oper Key"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_port_channel_detail_output_lacp_aggr_member_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        aggr_member = ET.SubElement(lacp, \"aggr-member\")\n        rbridge_id = ET.SubElement(aggr_member, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Channel Information Output LACP Aggr Member Nexus Interrupt Id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Port Channel Detail output LACP Aggr Member Interface Type", "response": "def get_port_channel_detail_output_lacp_aggr_member_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        aggr_member = ET.SubElement(lacp, \"aggr-member\")\n        interface_type = ET.SubElement(aggr_member, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets Port Channel Information Output LACP Aggr Member Interface Name", "response": "def get_port_channel_detail_output_lacp_aggr_member_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        aggr_member = ET.SubElement(lacp, \"aggr-member\")\n        interface_name = ET.SubElement(aggr_member, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget Port Channel Information Output LACP Aggr Member and Actor Port.", "response": "def get_port_channel_detail_output_lacp_aggr_member_actor_port(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        aggr_member = ET.SubElement(lacp, \"aggr-member\")\n        actor_port = ET.SubElement(aggr_member, \"actor-port\")\n        actor_port.text = kwargs.pop('actor_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_port_channel_detail_output_lacp_aggr_member_sync(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        aggr_member = ET.SubElement(lacp, \"aggr-member\")\n        sync = ET.SubElement(aggr_member, \"sync\")\n        sync.text = kwargs.pop('sync')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Channel Information Output LACP Aggr Member Sync"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_port_channel_detail_output_has_more(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        output = ET.SubElement(get_port_channel_detail, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Port Channel Details Output Has More Element"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_portchannel_info_by_intf_input_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        input = ET.SubElement(get_portchannel_info_by_intf, \"input\")\n        interface_type = ET.SubElement(input, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Portchannel info by interface type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget Portchannel info by interface name.", "response": "def get_portchannel_info_by_intf_input_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        input = ET.SubElement(get_portchannel_info_by_intf, \"input\")\n        interface_name = ET.SubElement(input, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting info by interface type for a specific interface type.", "response": "def get_portchannel_info_by_intf_output_lacp_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        interface_type = ET.SubElement(lacp, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget info by interface name.", "response": "def get_portchannel_info_by_intf_output_lacp_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        interface_name = ET.SubElement(lacp, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget info by interface and actor port.", "response": "def get_portchannel_info_by_intf_output_lacp_actor_port(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        actor_port = ET.SubElement(lacp, \"actor-port\")\n        actor_port.text = kwargs.pop('actor_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_portchannel_info_by_intf_output_lacp_admin_key(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        admin_key = ET.SubElement(lacp, \"admin-key\")\n        admin_key.text = kwargs.pop('admin_key')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Portchannel info by interface output LACP admin key."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget info by interface output LACP Oper Key", "response": "def get_portchannel_info_by_intf_output_lacp_oper_key(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        oper_key = ET.SubElement(lacp, \"oper-key\")\n        oper_key.text = kwargs.pop('oper_key')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_portchannel_info_by_intf_output_lacp_actor_system_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        actor_system_id = ET.SubElement(lacp, \"actor-system-id\")\n        actor_system_id.text = kwargs.pop('actor_system_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get info by interface output LACP actor system id."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting Portchannel info by interface output LACP partner system id.", "response": "def get_portchannel_info_by_intf_output_lacp_partner_system_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        partner_system_id = ET.SubElement(lacp, \"partner-system-id\")\n        partner_system_id.text = kwargs.pop('partner_system_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_portchannel_info_by_intf_output_lacp_system_priority(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        system_priority = ET.SubElement(lacp, \"system-priority\")\n        system_priority.text = kwargs.pop('system_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get info by interface output LACP system priority."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets info by interface output LACP Partner Oper Priority.", "response": "def get_portchannel_info_by_intf_output_lacp_partner_oper_priority(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        partner_oper_priority = ET.SubElement(lacp, \"partner-oper-priority\")\n        partner_oper_priority.text = kwargs.pop('partner_oper_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_portchannel_info_by_intf_output_lacp_actor_priority(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        actor_priority = ET.SubElement(lacp, \"actor-priority\")\n        actor_priority.text = kwargs.pop('actor_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get info by interface and LACP actor priority."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_portchannel_info_by_intf_output_lacp_receive_machine_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        receive_machine_state = ET.SubElement(lacp, \"receive-machine-state\")\n        receive_machine_state.text = kwargs.pop('receive_machine_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get info by interface output LACP receive machine state"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting info by interface output LACP periodic transmission machine state.", "response": "def get_portchannel_info_by_intf_output_lacp_periodic_transmission_machine_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        periodic_transmission_machine_state = ET.SubElement(lacp, \"periodic-transmission-machine-state\")\n        periodic_transmission_machine_state.text = kwargs.pop('periodic_transmission_machine_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets Portchannel info by interface output LACP mux machine state.", "response": "def get_portchannel_info_by_intf_output_lacp_mux_machine_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        mux_machine_state = ET.SubElement(lacp, \"mux-machine-state\")\n        mux_machine_state.text = kwargs.pop('mux_machine_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_portchannel_info_by_intf_output_lacp_admin_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        admin_state = ET.SubElement(lacp, \"admin-state\")\n        admin_state.text = kwargs.pop('admin_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Portchannel info by interface output LACP admin state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting info by interface output LACP Oper State", "response": "def get_portchannel_info_by_intf_output_lacp_oper_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        oper_state = ET.SubElement(lacp, \"oper-state\")\n        oper_state.text = kwargs.pop('oper_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_portchannel_info_by_intf_output_lacp_partner_oper_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        partner_oper_state = ET.SubElement(lacp, \"partner-oper-state\")\n        partner_oper_state.text = kwargs.pop('partner_oper_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get info by interface output LACP Partner Oper State"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets PortChannel Info By Interface output LACP Partner Oper Port.", "response": "def get_portchannel_info_by_intf_output_lacp_partner_oper_port(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        partner_oper_port = ET.SubElement(lacp, \"partner-oper-port\")\n        partner_oper_port.text = kwargs.pop('partner_oper_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets info by interface output LACP actor chip number.", "response": "def get_portchannel_info_by_intf_output_lacp_actor_chip_number(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        actor_chip_number = ET.SubElement(lacp, \"actor-chip-number\")\n        actor_chip_number.text = kwargs.pop('actor_chip_number')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_portchannel_info_by_intf_output_lacp_actor_max_deskew(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        actor_max_deskew = ET.SubElement(lacp, \"actor-max-deskew\")\n        actor_max_deskew.text = kwargs.pop('actor_max_deskew')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get info by interface output LACP actor max deskew."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_portchannel_info_by_intf_output_lacp_partner_chip_number(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        partner_chip_number = ET.SubElement(lacp, \"partner-chip-number\")\n        partner_chip_number.text = kwargs.pop('partner_chip_number')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Portchannel info by interface output LACP partner chip number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_portchannel_info_by_intf_output_lacp_partner_max_deskew(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        partner_max_deskew = ET.SubElement(lacp, \"partner-max-deskew\")\n        partner_max_deskew.text = kwargs.pop('partner_max_deskew')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get info by interface output LACP Partner Max Deskew"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets info by interface output LACP actor BRCD state.", "response": "def get_portchannel_info_by_intf_output_lacp_actor_brcd_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        actor_brcd_state = ET.SubElement(lacp, \"actor-brcd-state\")\n        actor_brcd_state.text = kwargs.pop('actor_brcd_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_portchannel_info_by_intf_output_lacp_partner_brcd_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_portchannel_info_by_intf = ET.Element(\"get_portchannel_info_by_intf\")\n        config = get_portchannel_info_by_intf\n        output = ET.SubElement(get_portchannel_info_by_intf, \"output\")\n        lacp = ET.SubElement(output, \"lacp\")\n        partner_brcd_state = ET.SubElement(lacp, \"partner-brcd-state\")\n        partner_brcd_state.text = kwargs.pop('partner_brcd_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get info by interface output LACP partner BRCD state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef port_channel_redundancy_group_group_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_channel_redundancy_group = ET.SubElement(config, \"port-channel-redundancy-group\", xmlns=\"urn:brocade.com:mgmt:brocade-lag\")\n        group_id = ET.SubElement(port_channel_redundancy_group, \"group-id\")\n        group_id.text = kwargs.pop('group_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the ID of the port channel redundancy group"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the name of the port channel", "response": "def port_channel_redundancy_group_port_channel_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_channel_redundancy_group = ET.SubElement(config, \"port-channel-redundancy-group\", xmlns=\"urn:brocade.com:mgmt:brocade-lag\")\n        group_id_key = ET.SubElement(port_channel_redundancy_group, \"group-id\")\n        group_id_key.text = kwargs.pop('group_id')\n        port_channel = ET.SubElement(port_channel_redundancy_group, \"port-channel\")\n        name = ET.SubElement(port_channel, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef port_channel_redundancy_group_port_channel_port_channel_active(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_channel_redundancy_group = ET.SubElement(config, \"port-channel-redundancy-group\", xmlns=\"urn:brocade.com:mgmt:brocade-lag\")\n        group_id_key = ET.SubElement(port_channel_redundancy_group, \"group-id\")\n        group_id_key.text = kwargs.pop('group_id')\n        port_channel = ET.SubElement(port_channel_redundancy_group, \"port-channel\")\n        name_key = ET.SubElement(port_channel, \"name\")\n        name_key.text = kwargs.pop('name')\n        port_channel_active = ET.SubElement(port_channel, \"port-channel-active\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set active status of the port channel"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nactivate the port - channel - redundancy - group", "response": "def port_channel_redundancy_group_activate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_channel_redundancy_group = ET.SubElement(config, \"port-channel-redundancy-group\", xmlns=\"urn:brocade.com:mgmt:brocade-lag\")\n        group_id_key = ET.SubElement(port_channel_redundancy_group, \"group-id\")\n        group_id_key.text = kwargs.pop('group_id')\n        activate = ET.SubElement(port_channel_redundancy_group, \"activate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconfigure Hidden Threshold Monitor hidden threshold monitor SFP and apply", "response": "def threshold_monitor_hidden_threshold_monitor_sfp_apply(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        sfp = ET.SubElement(threshold_monitor, \"sfp\")\n        apply = ET.SubElement(sfp, \"apply\")\n        apply.text = kwargs.pop('apply')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing threshold monitor hidden threshold monitor sfp and pause", "response": "def threshold_monitor_hidden_threshold_monitor_sfp_pause(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        sfp = ET.SubElement(threshold_monitor, \"sfp\")\n        pause = ET.SubElement(sfp, \"pause\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef threshold_monitor_hidden_threshold_monitor_sfp_policy_policy_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        sfp = ET.SubElement(threshold_monitor, \"sfp\")\n        policy = ET.SubElement(sfp, \"policy\")\n        policy_name = ET.SubElement(policy, \"policy_name\")\n        policy_name.text = kwargs.pop('policy_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set policy_name of threshold monitor hidden SFP policy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize threshold monitor hidden threshold monitor SFP policy and area type.", "response": "def threshold_monitor_hidden_threshold_monitor_sfp_policy_area_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        sfp = ET.SubElement(threshold_monitor, \"sfp\")\n        policy = ET.SubElement(sfp, \"policy\")\n        policy_name_key = ET.SubElement(policy, \"policy_name\")\n        policy_name_key.text = kwargs.pop('policy_name')\n        area = ET.SubElement(policy, \"area\")\n        area_value_key = ET.SubElement(area, \"area_value\")\n        area_value_key.text = kwargs.pop('area_value')\n        type = ET.SubElement(area, \"type\")\n        type.text = kwargs.pop('type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef threshold_monitor_hidden_threshold_monitor_sfp_policy_area_threshold_high_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        sfp = ET.SubElement(threshold_monitor, \"sfp\")\n        policy = ET.SubElement(sfp, \"policy\")\n        policy_name_key = ET.SubElement(policy, \"policy_name\")\n        policy_name_key.text = kwargs.pop('policy_name')\n        area = ET.SubElement(policy, \"area\")\n        type_key = ET.SubElement(area, \"type\")\n        type_key.text = kwargs.pop('type')\n        area_value_key = ET.SubElement(area, \"area_value\")\n        area_value_key.text = kwargs.pop('area_value')\n        threshold = ET.SubElement(area, \"threshold\")\n        high_threshold = ET.SubElement(threshold, \"high-threshold\")\n        high_threshold.text = kwargs.pop('high_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize threshold monitor hidden threshold monitor SFP policy area threshold and high threshold"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes threshold monitor hidden threshold monitor Sfp policy area alert above and below highthresh actions.", "response": "def threshold_monitor_hidden_threshold_monitor_sfp_policy_area_alert_above_above_highthresh_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        sfp = ET.SubElement(threshold_monitor, \"sfp\")\n        policy = ET.SubElement(sfp, \"policy\")\n        policy_name_key = ET.SubElement(policy, \"policy_name\")\n        policy_name_key.text = kwargs.pop('policy_name')\n        area = ET.SubElement(policy, \"area\")\n        type_key = ET.SubElement(area, \"type\")\n        type_key.text = kwargs.pop('type')\n        area_value_key = ET.SubElement(area, \"area_value\")\n        area_value_key.text = kwargs.pop('area_value')\n        alert = ET.SubElement(area, \"alert\")\n        above = ET.SubElement(alert, \"above\")\n        above_highthresh_action = ET.SubElement(above, \"above-highthresh-action\")\n        above_highthresh_action.text = kwargs.pop('above_highthresh_action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef threshold_monitor_hidden_threshold_monitor_sfp_policy_area_alert_below_below_highthresh_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        sfp = ET.SubElement(threshold_monitor, \"sfp\")\n        policy = ET.SubElement(sfp, \"policy\")\n        policy_name_key = ET.SubElement(policy, \"policy_name\")\n        policy_name_key.text = kwargs.pop('policy_name')\n        area = ET.SubElement(policy, \"area\")\n        type_key = ET.SubElement(area, \"type\")\n        type_key.text = kwargs.pop('type')\n        area_value_key = ET.SubElement(area, \"area_value\")\n        area_value_key.text = kwargs.pop('area_value')\n        alert = ET.SubElement(area, \"alert\")\n        below = ET.SubElement(alert, \"below\")\n        below_highthresh_action = ET.SubElement(below, \"below-highthresh-action\")\n        below_highthresh_action.text = kwargs.pop('below_highthresh_action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize threshold monitor hidden threshold monitor Sfp policy area alert below highthresh action."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef threshold_monitor_hidden_threshold_monitor_security_apply(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        security = ET.SubElement(threshold_monitor, \"security\")\n        apply = ET.SubElement(security, \"apply\")\n        apply.text = kwargs.pop('apply')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set apply = True to apply the security of the threshold monitor hidden threshold monitor"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef threshold_monitor_hidden_threshold_monitor_security_pause(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        security = ET.SubElement(threshold_monitor, \"security\")\n        pause = ET.SubElement(security, \"pause\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Threshold Monitor Hidden Section 7. 1. 4. 1"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef threshold_monitor_hidden_threshold_monitor_security_policy_sec_policy_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        security = ET.SubElement(threshold_monitor, \"security\")\n        policy = ET.SubElement(security, \"policy\")\n        sec_policy_name = ET.SubElement(policy, \"sec_policy_name\")\n        sec_policy_name.text = kwargs.pop('sec_policy_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set security policy name in threshold monitor hidden section"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets value of sec_area_value in threshold monitor hidden security policy area", "response": "def threshold_monitor_hidden_threshold_monitor_security_policy_area_sec_area_value(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        security = ET.SubElement(threshold_monitor, \"security\")\n        policy = ET.SubElement(security, \"policy\")\n        sec_policy_name_key = ET.SubElement(policy, \"sec_policy_name\")\n        sec_policy_name_key.text = kwargs.pop('sec_policy_name')\n        area = ET.SubElement(policy, \"area\")\n        sec_area_value = ET.SubElement(area, \"sec_area_value\")\n        sec_area_value.text = kwargs.pop('sec_area_value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef threshold_monitor_hidden_threshold_monitor_security_policy_area_timebase(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        security = ET.SubElement(threshold_monitor, \"security\")\n        policy = ET.SubElement(security, \"policy\")\n        sec_policy_name_key = ET.SubElement(policy, \"sec_policy_name\")\n        sec_policy_name_key.text = kwargs.pop('sec_policy_name')\n        area = ET.SubElement(policy, \"area\")\n        sec_area_value_key = ET.SubElement(area, \"sec_area_value\")\n        sec_area_value_key.text = kwargs.pop('sec_area_value')\n        timebase = ET.SubElement(area, \"timebase\")\n        timebase.text = kwargs.pop('timebase')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize threshold monitor hidden security policy area and timebase"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing threshold monitor hidden security policy area threshold and high threshold", "response": "def threshold_monitor_hidden_threshold_monitor_security_policy_area_threshold_sec_high_threshold(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        security = ET.SubElement(threshold_monitor, \"security\")\n        policy = ET.SubElement(security, \"policy\")\n        sec_policy_name_key = ET.SubElement(policy, \"sec_policy_name\")\n        sec_policy_name_key.text = kwargs.pop('sec_policy_name')\n        area = ET.SubElement(policy, \"area\")\n        sec_area_value_key = ET.SubElement(area, \"sec_area_value\")\n        sec_area_value_key.text = kwargs.pop('sec_area_value')\n        threshold = ET.SubElement(area, \"threshold\")\n        sec_high_threshold = ET.SubElement(threshold, \"sec-high-threshold\")\n        sec_high_threshold.text = kwargs.pop('sec_high_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing threshold monitor hidden security policy area alert above sec - above - highthresh - action", "response": "def threshold_monitor_hidden_threshold_monitor_security_policy_area_alert_above_sec_above_highthresh_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        security = ET.SubElement(threshold_monitor, \"security\")\n        policy = ET.SubElement(security, \"policy\")\n        sec_policy_name_key = ET.SubElement(policy, \"sec_policy_name\")\n        sec_policy_name_key.text = kwargs.pop('sec_policy_name')\n        area = ET.SubElement(policy, \"area\")\n        sec_area_value_key = ET.SubElement(area, \"sec_area_value\")\n        sec_area_value_key.text = kwargs.pop('sec_area_value')\n        alert = ET.SubElement(area, \"alert\")\n        above = ET.SubElement(alert, \"above\")\n        sec_above_highthresh_action = ET.SubElement(above, \"sec-above-highthresh-action\")\n        sec_above_highthresh_action.text = kwargs.pop('sec_above_highthresh_action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize threshold monitor hidden security policy area alert below sec - below - highthresh - action", "response": "def threshold_monitor_hidden_threshold_monitor_security_policy_area_alert_below_sec_below_highthresh_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        security = ET.SubElement(threshold_monitor, \"security\")\n        policy = ET.SubElement(security, \"policy\")\n        sec_policy_name_key = ET.SubElement(policy, \"sec_policy_name\")\n        sec_policy_name_key.text = kwargs.pop('sec_policy_name')\n        area = ET.SubElement(policy, \"area\")\n        sec_area_value_key = ET.SubElement(area, \"sec_area_value\")\n        sec_area_value_key.text = kwargs.pop('sec_area_value')\n        alert = ET.SubElement(area, \"alert\")\n        below = ET.SubElement(alert, \"below\")\n        sec_below_highthresh_action = ET.SubElement(below, \"sec-below-highthresh-action\")\n        sec_below_highthresh_action.text = kwargs.pop('sec_below_highthresh_action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nthresholds monitor hidden threshold monitor CPU poll", "response": "def threshold_monitor_hidden_threshold_monitor_Cpu_poll(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        Cpu = ET.SubElement(threshold_monitor, \"Cpu\")\n        poll = ET.SubElement(Cpu, \"poll\")\n        poll.text = kwargs.pop('poll')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nthresholding monitor hidden threshold monitor CPU retry", "response": "def threshold_monitor_hidden_threshold_monitor_Cpu_retry(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        Cpu = ET.SubElement(threshold_monitor, \"Cpu\")\n        retry = ET.SubElement(Cpu, \"retry\")\n        retry.text = kwargs.pop('retry')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset threshold monitor hidden threshold monitor CPU limit", "response": "def threshold_monitor_hidden_threshold_monitor_Cpu_limit(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        Cpu = ET.SubElement(threshold_monitor, \"Cpu\")\n        limit = ET.SubElement(Cpu, \"limit\")\n        limit.text = kwargs.pop('limit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nthreshold monitor hidden threshold monitor CPU actions", "response": "def threshold_monitor_hidden_threshold_monitor_Cpu_actions(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        Cpu = ET.SubElement(threshold_monitor, \"Cpu\")\n        actions = ET.SubElement(Cpu, \"actions\")\n        actions.text = kwargs.pop('actions')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef threshold_monitor_hidden_threshold_monitor_Memory_poll(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        Memory = ET.SubElement(threshold_monitor, \"Memory\")\n        poll = ET.SubElement(Memory, \"poll\")\n        poll.text = kwargs.pop('poll')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Threshold Monitor Hidden Threshold Monitor Memory Poll"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nthresholding Monitor Hidden Threshold Monitor Memory Retry", "response": "def threshold_monitor_hidden_threshold_monitor_Memory_retry(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        Memory = ET.SubElement(threshold_monitor, \"Memory\")\n        retry = ET.SubElement(Memory, \"retry\")\n        retry.text = kwargs.pop('retry')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef threshold_monitor_hidden_threshold_monitor_Memory_limit(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        Memory = ET.SubElement(threshold_monitor, \"Memory\")\n        limit = ET.SubElement(Memory, \"limit\")\n        limit.text = kwargs.pop('limit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Threshold monitor hidden threshold monitor Memory limit"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nthresholds monitor hidden threshold monitor Memory high limit", "response": "def threshold_monitor_hidden_threshold_monitor_Memory_high_limit(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        Memory = ET.SubElement(threshold_monitor, \"Memory\")\n        high_limit = ET.SubElement(Memory, \"high-limit\")\n        high_limit.text = kwargs.pop('high_limit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef threshold_monitor_hidden_threshold_monitor_Memory_low_limit(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        Memory = ET.SubElement(threshold_monitor, \"Memory\")\n        low_limit = ET.SubElement(Memory, \"low-limit\")\n        low_limit.text = kwargs.pop('low_limit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Threshold monitor hidden threshold monitor Memory low limit"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nthreshold monitor hidden threshold monitor Memory actions", "response": "def threshold_monitor_hidden_threshold_monitor_Memory_actions(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        Memory = ET.SubElement(threshold_monitor, \"Memory\")\n        actions = ET.SubElement(Memory, \"actions\")\n        actions.text = kwargs.pop('actions')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef threshold_monitor_hidden_threshold_monitor_interface_apply(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        interface = ET.SubElement(threshold_monitor, \"interface\")\n        apply = ET.SubElement(interface, \"apply\")\n        apply.text = kwargs.pop('apply')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Add threshold monitor hidden threshold monitor interface to hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes threshold monitor hidden threshold monitor interface and pause", "response": "def threshold_monitor_hidden_threshold_monitor_interface_pause(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        interface = ET.SubElement(threshold_monitor, \"interface\")\n        pause = ET.SubElement(interface, \"pause\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef threshold_monitor_hidden_threshold_monitor_interface_policy_policy_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        interface = ET.SubElement(threshold_monitor, \"interface\")\n        policy = ET.SubElement(interface, \"policy\")\n        policy_name = ET.SubElement(policy, \"policy_name\")\n        policy_name.text = kwargs.pop('policy_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set policy_name of threshold monitor hidden threshold monitor interface"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef threshold_monitor_hidden_threshold_monitor_interface_policy_area_area_value(self, **kwargs):\n        config = ET.Element(\"config\")\n        threshold_monitor_hidden = ET.SubElement(config, \"threshold-monitor-hidden\", xmlns=\"urn:brocade.com:mgmt:brocade-threshold-monitor\")\n        threshold_monitor = ET.SubElement(threshold_monitor_hidden, \"threshold-monitor\")\n        interface = ET.SubElement(threshold_monitor, \"interface\")\n        policy = ET.SubElement(interface, \"policy\")\n        policy_name_key = ET.SubElement(policy, \"policy_name\")\n        policy_name_key.text = kwargs.pop('policy_name')\n        area = ET.SubElement(policy, \"area\")\n        type_key = ET.SubElement(area, \"type\")\n        type_key.text = kwargs.pop('type')\n        area_value = ET.SubElement(area, \"area_value\")\n        area_value.text = kwargs.pop('area_value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set value of threshold monitor hidden threshold monitor interface policy area value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add(self, new_hw_map):\n        new_route = new_hw_map.route\n        if new_route in self.raw_maps:\n            raise KeyError(\"HW Map already exists: {0:s}\".format(new_hw_map.route))\n\n        common_addresses = set(self).intersection(new_hw_map)\n        if common_addresses:\n            raise ValueError(\"An address in {0:s} already exists in the manager\".format(new_route))\n        # all ok, add it all\n        self.raw_maps[new_route] = new_hw_map\n        self.update(new_hw_map)", "response": "Add the given HW map to the manager."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef subtract(self, route):\n        for address in self.raw_maps.pop(route, NullHardwareMap()).iterkeys():\n            self.pop(address, NullHardwareNode())", "response": "Remove the route entirely."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwatch for filesystem changes and compiles SCSS to CSS ystal", "response": "def watch(source_path, dest_path):\n    \"\"\"Watches for filesystem changes and compiles SCSS to CSS\n\n    This is an async function.\n\n    :param str source_path: The source directory to watch. All .scss files are\n                            monitored.\n    :param str dest_path: The destination directory where the resulting CSS\n                          files should go. The filename will be identical to\n                          the original, except the extension will be `.css`.\n\n    \"\"\"\n    # Setup Watchdog\n    handler = FileSystemEvents(source_path, dest_path)\n\n    # Always run initial compile\n    handler.compile_scss()\n\n    observer = Observer(timeout=5000)\n    observer.schedule(handler, path=source_path, recursive=True)\n    observer.start()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the state of the operational LLDP neighbors.", "response": "def neighbors(self, **kwargs):\n\n        \"\"\"list[dict]: A list of dictionary items describing the operational\n        state of LLDP.\n        \"\"\"\n        urn = \"{urn:brocade.com:mgmt:brocade-lldp-ext}\"\n\n        result = []\n        has_more = ''\n        last_ifindex = ''\n        rbridge_id = None\n        if 'rbridge_id' in kwargs:\n            rbridge_id = kwargs.pop('rbridge_id')\n        while (has_more == '') or (has_more == 'true'):\n            request_lldp = self.get_lldp_neighbors_request(last_ifindex,\n                                                           rbridge_id)\n            lldp_result = self._callback(request_lldp, 'get')\n            has_more = lldp_result.find('%shas-more' % urn).text\n\n            for item in lldp_result.findall('%slldp-neighbor-detail' % urn):\n                local_int_name = item.find('%slocal-interface-name' % urn).text\n                local_int_mac = item.find('%slocal-interface-mac' % urn).text\n                last_ifindex = item.find(\n                    '%slocal-interface-ifindex' % urn).text\n                remote_int_name = item.find(\n                    '%sremote-interface-name' % urn).text\n                remote_int_mac = item.find('%sremote-interface-mac' % urn).text\n                remote_chas_id = item.find('%sremote-chassis-id' % urn).text\n                try:\n                    remote_sys_name = item.find(\n                        '%sremote-system-name' % urn).text\n                except AttributeError:\n                    remote_sys_name = ''\n                try:\n                    remote_sys_desc = item.find('%sremote-system-description' %\n                                                urn).text\n                except AttributeError:\n                    remote_sys_desc = ''\n                try:\n                    remote_mgmt_addr = item.find(\n                        '%sremote-management-address' %\n                        urn).text\n                except AttributeError:\n                    remote_mgmt_addr = ''\n                if 'Fo ' in local_int_name:\n                    local_int_name = local_int_name.replace(\n                        'Fo ',\n                        'FortyGigabitEthernet '\n                    )\n                if 'Te ' in local_int_name:\n                    local_int_name = local_int_name.replace(\n                        'Te ',\n                        'TenGigabitEthernet '\n                    )\n\n                item_results = {'local-int-name': local_int_name,\n                                'local-int-mac': local_int_mac,\n                                'remote-int-name': remote_int_name,\n                                'remote-int-mac': remote_int_mac,\n                                'remote-chassis-id': remote_chas_id,\n                                'remote-system-name': remote_sys_name,\n                                'remote-system-description': remote_sys_desc,\n                                'remote-management-address': remote_mgmt_addr}\n                result.append(item_results)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets description of the event handler list", "response": "def event_handler_event_handler_list_description(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        event_handler = ET.SubElement(config, \"event-handler\", xmlns=\"urn:brocade.com:mgmt:brocade-event-handler\")\n        event_handler_list = ET.SubElement(event_handler, \"event-handler-list\")\n        name_key = ET.SubElement(event_handler_list, \"name\")\n        name_key.text = kwargs.pop('name')\n        description = ET.SubElement(event_handler_list, \"description\")\n        description.text = kwargs.pop('description')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the system priority of the current resource.", "response": "def lacp_system_priority(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        lacp = ET.SubElement(config, \"lacp\", xmlns=\"urn:brocade.com:mgmt:brocade-lacp\")\n        system_priority = ET.SubElement(lacp, \"system-priority\")\n        system_priority.text = kwargs.pop('system_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisabling the vlag - commit - mode of the current resource", "response": "def vlag_commit_mode_disable(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vlag_commit_mode = ET.SubElement(config, \"vlag-commit-mode\", xmlns=\"urn:brocade.com:mgmt:brocade-lacp\")\n        disable = ET.SubElement(vlag_commit_mode, \"disable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck a password and returns a response", "response": "def simple_password(request):\n    \"\"\"\n    Checks a password\n    \"\"\"\n    if request.method == \"POST\":\n        form = PasswordForm(data=request.POST)\n        if form.is_valid():\n            # TODO: set session with better param\n            request.session[\"simple_auth\"] = True\n            return redirect(form.cleaned_data[\"url\"] or \"/\")\n    else:\n        form = PasswordForm()\n    return render(request, \"simple_auth/password_form.html\",\n                  {\"form\": form})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a long description of the project README and latest changes.", "response": "def long_description():\n    \"\"\" Collates project README and latest changes. \"\"\"\n    changes = latest_changes()\n    changes[0] = \"`Changes for v{}\".format(changes[0][1:])\n    changes[1] = '-' * len(changes[0])\n    return \"\\n\\n\\n\".join([\n        read_file('README.rst'),\n        '\\n'.join(changes),\n        \"`Full changelog <{}/en/develop/changelog.html#changelog>`_.\".format(\n            DOCUMENTATION_URL)])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhiding Virtual IP Holder Chassis Virtual IP", "response": "def hide_virtual_ip_holder_chassis_virtual_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_virtual_ip_holder = ET.SubElement(config, \"hide-virtual-ip-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-chassis\")\n        chassis = ET.SubElement(hide_virtual_ip_holder, \"chassis\")\n        virtual_ip = ET.SubElement(chassis, \"virtual-ip\")\n        virtual_ip.text = kwargs.pop('virtual_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hide_virtual_ip_holder_chassis_virtual_ipv6(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_virtual_ip_holder = ET.SubElement(config, \"hide-virtual-ip-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-chassis\")\n        chassis = ET.SubElement(hide_virtual_ip_holder, \"chassis\")\n        virtual_ipv6 = ET.SubElement(chassis, \"virtual-ipv6\")\n        virtual_ipv6.text = kwargs.pop('virtual_ipv6')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Hide Virtual IP Holder on Chassis Virtual IPv6"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hide_virtual_ip_holder_chassis_oper_address_virtual_oper_Vip_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_virtual_ip_holder = ET.SubElement(config, \"hide-virtual-ip-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-chassis\")\n        chassis = ET.SubElement(hide_virtual_ip_holder, \"chassis\")\n        oper_address = ET.SubElement(chassis, \"oper-address\")\n        virtual_oper_Vip_address = ET.SubElement(oper_address, \"virtual-oper-Vip-address\")\n        virtual_oper_Vip_address.text = kwargs.pop('virtual_oper_Vip_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Hide Virtual IP Holder Chassis Oper - Address Virtual - Oper - Vip - Address"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef firmware_autoupgrade_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware = ET.SubElement(config, \"firmware\", xmlns=\"urn:brocade.com:mgmt:brocade-firmware\")\n        autoupgrade = ET.SubElement(firmware, \"autoupgrade\")\n        enable = ET.SubElement(autoupgrade, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        enable"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef firmware_autoupgrade_params_username(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware = ET.SubElement(config, \"firmware\", xmlns=\"urn:brocade.com:mgmt:brocade-firmware\")\n        autoupgrade_params = ET.SubElement(firmware, \"autoupgrade-params\")\n        username = ET.SubElement(autoupgrade_params, \"username\")\n        username.text = kwargs.pop('username')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        username"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef openflow_controller_controller_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        openflow_controller = ET.SubElement(config, \"openflow-controller\", xmlns=\"urn:brocade.com:mgmt:brocade-openflow\")\n        controller_name = ET.SubElement(openflow_controller, \"controller-name\")\n        controller_name.text = kwargs.pop('controller_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the controller"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the configuration of the openflow controller connection address controller address", "response": "def openflow_controller_connection_address_controller_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        openflow_controller = ET.SubElement(config, \"openflow-controller\", xmlns=\"urn:brocade.com:mgmt:brocade-openflow\")\n        controller_name_key = ET.SubElement(openflow_controller, \"controller-name\")\n        controller_name_key.text = kwargs.pop('controller_name')\n        connection_address = ET.SubElement(openflow_controller, \"connection-address\")\n        controller_address = ET.SubElement(connection_address, \"controller-address\")\n        controller_address.text = kwargs.pop('controller_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef openflow_controller_connection_address_connection_method(self, **kwargs):\n        config = ET.Element(\"config\")\n        openflow_controller = ET.SubElement(config, \"openflow-controller\", xmlns=\"urn:brocade.com:mgmt:brocade-openflow\")\n        controller_name_key = ET.SubElement(openflow_controller, \"controller-name\")\n        controller_name_key.text = kwargs.pop('controller_name')\n        connection_address = ET.SubElement(openflow_controller, \"connection-address\")\n        connection_method = ET.SubElement(connection_address, \"connection-method\")\n        connection_method.text = kwargs.pop('connection_method')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the openflow controller connection address and connection method"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef openflow_controller_connection_address_connection_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        openflow_controller = ET.SubElement(config, \"openflow-controller\", xmlns=\"urn:brocade.com:mgmt:brocade-openflow\")\n        controller_name_key = ET.SubElement(openflow_controller, \"controller-name\")\n        controller_name_key.text = kwargs.pop('controller_name')\n        connection_address = ET.SubElement(openflow_controller, \"connection-address\")\n        connection_port = ET.SubElement(connection_address, \"connection-port\")\n        connection_port.text = kwargs.pop('connection_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the openflow controller connection address and connection port"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_vlan_int(self, vlan_id):\n        config = ET.Element('config')\n        vlinterface = ET.SubElement(config, 'interface-vlan',\n                                    xmlns=(\"urn:brocade.com:mgmt:\"\n                                           \"brocade-interface\"))\n        interface = ET.SubElement(vlinterface, 'interface')\n        vlan = ET.SubElement(interface, 'vlan')\n        name = ET.SubElement(vlan, 'name')\n        name.text = vlan_id\n        try:\n            self._callback(config)\n            return True\n        # TODO add logging and narrow exception window.\n        except Exception as error:\n            logging.error(error)\n            return False", "response": "Add VLAN Interface to the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef disable_switchport(self, inter_type, inter):\n        config = ET.Element('config')\n        interface = ET.SubElement(config, 'interface',\n                                  xmlns=(\"urn:brocade.com:mgmt:\"\n                                         \"brocade-interface\"))\n        int_type = ET.SubElement(interface, inter_type)\n        name = ET.SubElement(int_type, 'name')\n        name.text = inter\n        ET.SubElement(int_type, 'switchport-basic', operation='delete')\n        try:\n            self._callback(config)\n            return True\n        # TODO add logging and narrow exception window.\n        except Exception as error:\n            logging.error(error)\n            return False", "response": "Change an interface's operation to L3.\n\n        Args:\n            inter_type: The type of interface you want to configure. Ex.\n                tengigabitethernet, gigabitethernet, fortygigabitethernet.\n            inter: The ID for the interface you want to configure. Ex. 1/0/1\n\n        Returns:\n            True if command completes successfully or False if not.\n\n        Raises:\n            None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef access_vlan(self, inter_type, inter, vlan_id):\n        config = ET.Element('config')\n        interface = ET.SubElement(config, 'interface',\n                                  xmlns=(\"urn:brocade.com:mgmt:\"\n                                         \"brocade-interface\"))\n        int_type = ET.SubElement(interface, inter_type)\n        name = ET.SubElement(int_type, 'name')\n        name.text = inter\n        switchport = ET.SubElement(int_type, 'switchport')\n        access = ET.SubElement(switchport, 'access')\n        accessvlan = ET.SubElement(access, 'accessvlan')\n        accessvlan.text = vlan_id\n        try:\n            self._callback(config)\n            return True\n        # TODO add logging and narrow exception window.\n        except Exception as error:\n            logging.error(error)\n            return False", "response": "Add a new L2 Interface to a specific VLAN."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_ip(self, inter_type, inter, ip_addr):\n        config = ET.Element('config')\n        interface = ET.SubElement(config, 'interface',\n                                  xmlns=(\"urn:brocade.com:mgmt:\"\n                                         \"brocade-interface\"))\n        intert = ET.SubElement(interface, inter_type)\n        name = ET.SubElement(intert, 'name')\n        name.text = inter\n        ipel = ET.SubElement(intert, 'ip')\n        ip_config = ET.SubElement(\n            ipel, 'ip-config',\n            xmlns=\"urn:brocade.com:mgmt:brocade-ip-config\"\n        )\n        address = ET.SubElement(ip_config, 'address')\n        ipaddr = ET.SubElement(address, 'address')\n        ipaddr.text = ip_addr\n        try:\n            self._callback(config)\n            return True\n        # TODO add logging and narrow exception window.\n        except Exception as error:\n            logging.error(error)\n            return False", "response": "Set the IP address of a specific interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_port_channel(self, **kwargs):\n        port_int = kwargs.pop('port_int')\n        callback = kwargs.pop('callback', self._callback)\n\n        if re.search('^[0-9]{1,4}$', port_int) is None:\n            raise ValueError('%s must be in the format of x for port channel '\n                             'interfaces.' % repr(port_int))\n\n        port_channel = getattr(self._interface, 'interface_port_channel_name')\n        port_channel_args = dict(name=port_int)\n\n        config = port_channel(**port_channel_args)\n\n        delete_channel = config.find('.//*port-channel')\n        delete_channel.set('operation', 'delete')\n\n        return callback(config)", "response": "Remove a port channel interface."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the IP Address on an Interface.", "response": "def ip_address(self, **kwargs):\n        \"\"\"\n        Set IP Address on an Interface.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                 tengigabitethernet etc).\n            name (str): Name of interface id.\n                 (For interface: 1/0/5, 1/0/10 etc).\n            ip_addr (str): IPv4/IPv6 Virtual IP Address..\n                Ex: 10.10.10.1/24 or 2001:db8::/48\n            delete (bool): True is the IP address is added and False if its to\n                be deleted (True, False). Default value will be False if not\n                specified.\n            rbridge_id (str): rbridge-id for device. Only required when type is\n                `ve`.\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                 method.  The only parameter passed to `callback` will be the\n                 ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `int_type`, `name`, or `ip_addr` is not passed.\n            ValueError: if `int_type`, `name`, or `ip_addr` are invalid.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...    conn = (switch, '22')\n            ...    with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...        int_type = 'tengigabitethernet'\n            ...        name = '225/0/4'\n            ...        ip_addr = '20.10.10.1/24'\n            ...        output = dev.interface.disable_switchport(inter_type=\n            ...        int_type, inter=name)\n            ...        output = dev.interface.ip_address(int_type=int_type,\n            ...        name=name, ip_addr=ip_addr)\n            ...        output = dev.interface.ip_address(int_type=int_type,\n            ...        name=name, ip_addr=ip_addr, delete=True)\n            ...        output = dev.interface.add_vlan_int('86')\n            ...        output = dev.interface.ip_address(int_type='ve',\n            ...        name='86', ip_addr=ip_addr, rbridge_id='225')\n            ...        output = dev.interface.ip_address(int_type='ve',\n            ...        name='86', ip_addr=ip_addr, delete=True,\n            ...        rbridge_id='225')\n            ...        output = dev.interface.ip_address(int_type='loopback',\n            ...        name='225', ip_addr='10.225.225.225/32',\n            ...        rbridge_id='225')\n            ...        output = dev.interface.ip_address(int_type='loopback',\n            ...        name='225', ip_addr='10.225.225.225/32', delete=True,\n            ...        rbridge_id='225')\n            ...        ip_addr = 'fc00:1:3:1ad3:0:0:23:a/64'\n            ...        output = dev.interface.ip_address(int_type=int_type,\n            ...        name=name, ip_addr=ip_addr)\n            ...        output = dev.interface.ip_address(int_type=int_type,\n            ...        name=name, ip_addr=ip_addr, delete=True)\n            ...        output = dev.interface.ip_address(int_type='ve',\n            ...        name='86', ip_addr=ip_addr, rbridge_id='225')\n            ...        output = dev.interface.ip_address(int_type='ve',\n            ...        name='86', ip_addr=ip_addr, delete=True,\n            ...        rbridge_id='225')\n        \"\"\"\n\n        int_type = str(kwargs.pop('int_type').lower())\n        name = str(kwargs.pop('name'))\n        ip_addr = str(kwargs.pop('ip_addr'))\n        delete = kwargs.pop('delete', False)\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['gigabitethernet', 'tengigabitethernet', 've',\n                           'fortygigabitethernet', 'hundredgigabitethernet',\n                           'loopback']\n\n        if int_type not in valid_int_types:\n            raise ValueError('int_type must be one of: %s' %\n                             repr(valid_int_types))\n\n        ipaddress = ip_interface(unicode(ip_addr))\n        ip_args = dict(name=name, address=ip_addr)\n        method_name = None\n        method_class = self._interface\n        if ipaddress.version == 4:\n            method_name = 'interface_%s_ip_ip_config_address_' \\\n                          'address' % int_type\n        elif ipaddress.version == 6:\n            method_name = 'interface_%s_ipv6_ipv6_config_address_ipv6_' \\\n                          'address_address' % int_type\n\n        if int_type == 've':\n            method_name = \"rbridge_id_%s\" % method_name\n            method_class = self._rbridge\n            ip_args['rbridge_id'] = rbridge_id\n            if not pynos.utilities.valid_vlan_id(name):\n                raise InvalidVlanId(\"`name` must be between `1` and `8191`\")\n        elif int_type == 'loopback':\n            method_name = 'rbridge_id_interface_loopback_ip_ip_config_' \\\n                          'address_address'\n            if ipaddress.version == 6:\n                method_name = 'rbridge_id_interface_loopback_ipv6_ipv6_' \\\n                              'config_address_ipv6_address_address'\n            method_class = self._rbridge\n            ip_args['rbridge_id'] = rbridge_id\n            ip_args['id'] = name\n        elif not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces.')\n\n        ip_address_attr = getattr(method_class, method_name)\n        config = ip_address_attr(**ip_args)\n        if delete:\n            config.find('.//*address').set('operation', 'delete')\n        try:\n            if kwargs.pop('get', False):\n                return callback(config, handler='get_config')\n            else:\n                return callback(config)\n        # TODO Setting IP on port channel is not done yet.\n        except AttributeError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget IP Addresses already set on an Interface.", "response": "def get_ip_addresses(self, **kwargs):\n        \"\"\"\n        Get IP Addresses already set on an Interface.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                 tengigabitethernet etc).\n            name (str): Name of interface id.\n                 (For interface: 1/0/5, 1/0/10 etc).\n            version (int): 4 or 6 to represent IPv4 or IPv6 address\n            callback (function): A function executed upon completion of the\n                 method.  The only parameter passed to `callback` will be the\n                 ``ElementTree`` `config`.\n\n        Returns:\n            List of 0 or more IPs configure on the specified interface.\n\n        Raises:\n            KeyError: if `int_type` or `name` is not passed.\n            ValueError: if `int_type` or `name` are invalid.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...    conn = (switch, '22')\n            ...    with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...        int_type = 'tengigabitethernet'\n            ...        name = '225/0/4'\n            ...        ip_addr = '20.10.10.1/24'\n            ...        version = 4\n            ...        output = dev.interface.disable_switchport(inter_type=\n            ...        int_type, inter=name)\n            ...        output = dev.interface.ip_address(int_type=int_type,\n            ...        name=name, ip_addr=ip_addr)\n            ...        result = dev.interface.get_ip_addresses(\n            ...        int_type=int_type, name=name, version=version)\n            ...        assert len(result) >= 1\n            ...        output = dev.interface.ip_address(int_type=int_type,\n            ...        name=name, ip_addr=ip_addr, delete=True)\n            ...        ip_addr = 'fc00:1:3:1ad3:0:0:23:a/64'\n            ...        version = 6\n            ...        output = dev.interface.ip_address(int_type=int_type,\n            ...        name=name, ip_addr=ip_addr)\n            ...        result = dev.interface.get_ip_addresses(\n            ...        int_type=int_type, name=name, version=version)\n            ...        assert len(result) >= 1\n            ...        output = dev.interface.ip_address(int_type=int_type,\n            ...        name=name, ip_addr=ip_addr, delete=True)\n        \"\"\"\n\n        int_type = str(kwargs.pop('int_type').lower())\n        name = str(kwargs.pop('name'))\n        version = int(kwargs.pop('version'))\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['gigabitethernet', 'tengigabitethernet',\n                           'fortygigabitethernet', 'hundredgigabitethernet']\n        if int_type not in valid_int_types:\n            raise ValueError('int_type must be one of: %s' %\n                             repr(valid_int_types))\n        method_name = None\n        method_class = self._interface\n        if version == 4:\n            method_name = 'interface_%s_ip_ip_config_address_' \\\n                          'address' % int_type\n        elif version == 6:\n            method_name = 'interface_%s_ipv6_ipv6_config_address_ipv6_' \\\n                          'address_address' % int_type\n\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces.')\n        ip_args = dict(name=name, address='')\n        ip_address_attr = getattr(method_class, method_name)\n        config = ip_address_attr(**ip_args)\n\n        output = callback(config, handler='get_config')\n        result = []\n        if version == 4:\n            for item in output.data.findall(\n                    './/{*}address/{*}address'):\n                result.append(item.text)\n\n        elif version == 6:\n            for item in output.data.findall(\n                    './/{*}address/{*}ipv6-address/{'\n                    '*}address'):\n                result.append(item.text)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the description of the internal network interface.", "response": "def description(self, **kwargs):\n        \"\"\"Set interface description.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, etc)\n            name (str): Name of interface. (1/0/5, 1/0/10, etc)\n            desc (str): The description of the interface.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `int_type`, `name`, or `desc` is not specified.\n            ValueError: if `name`, `int_type`, or `desc` is not a valid\n                value.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.description(\n            ...         int_type='tengigabitethernet',\n            ...         name='225/0/38',\n            ...         desc='test')\n            ...         dev.interface.description()\n            ...         # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        int_type = str(kwargs.pop('int_type').lower())\n        name = str(kwargs.pop('name'))\n        desc = str(kwargs.pop('desc'))\n        callback = kwargs.pop('callback', self._callback)\n\n        int_types = [\n            'gigabitethernet',\n            'tengigabitethernet',\n            'fortygigabitethernet',\n            'hundredgigabitethernet',\n            'port_channel',\n            'vlan'\n        ]\n\n        if int_type not in int_types:\n            raise ValueError(\"`int_type` must be one of: %s\" % repr(int_types))\n\n        desc_args = dict(name=name, description=desc)\n\n        if int_type == \"vlan\":\n            if not pynos.utilities.valid_vlan_id(name):\n                raise InvalidVlanId(\"`name` must be between `1` and `8191`\")\n\n            config = self._interface.interface_vlan_interface_vlan_description(\n                **desc_args\n            )\n        else:\n            if not pynos.utilities.valid_interface(int_type, name):\n                raise ValueError('`name` must be in the format of x/y/z for '\n                                 'physical interfaces or x for port channel.')\n\n            config = getattr(\n                self._interface,\n                'interface_%s_description' % int_type\n            )(**desc_args)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef private_vlan_type(self, **kwargs):\n        name = kwargs.pop('name')\n        pvlan_type = kwargs.pop('pvlan_type')\n        callback = kwargs.pop('callback', self._callback)\n        allowed_pvlan_types = ['isolated', 'primary', 'community']\n\n        if not pynos.utilities.valid_vlan_id(name):\n            raise InvalidVlanId(\"Incorrect name value.\")\n\n        if pvlan_type not in allowed_pvlan_types:\n            raise ValueError(\"Incorrect pvlan_type\")\n\n        pvlan_args = dict(name=name, pvlan_type_leaf=pvlan_type)\n        pvlan_type = getattr(self._interface,\n                             'interface_vlan_interface_vlan_'\n                             'private_vlan_pvlan_type_leaf')\n        config = pvlan_type(**pvlan_args)\n        return callback(config)", "response": "Set the PVLAN type of the current node."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a secondary PVLAN to a primary PVLAN.", "response": "def vlan_pvlan_association_add(self, **kwargs):\n        \"\"\"Add a secondary PVLAN to a primary PVLAN.\n\n        Args:\n            name (str): VLAN number (1-4094).\n            sec_vlan (str): The secondary PVLAN.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `name` or `sec_vlan` is not specified.\n            ValueError: if `name` or `sec_vlan` is invalid.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> int_type = 'tengigabitethernet'\n            >>> name = '20'\n            >>> sec_vlan = '30'\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.private_vlan_type(name=name,\n            ...         pvlan_type='primary')\n            ...         output = dev.interface.private_vlan_type(name=sec_vlan,\n            ...         pvlan_type='isolated')\n            ...         output = dev.interface.vlan_pvlan_association_add(\n            ...         name=name, sec_vlan=sec_vlan)\n            ...         dev.interface.vlan_pvlan_association_add()\n            ...         # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        name = kwargs.pop('name')\n        sec_vlan = kwargs.pop('sec_vlan')\n        callback = kwargs.pop('callback', self._callback)\n\n        if not pynos.utilities.valid_vlan_id(name):\n            raise InvalidVlanId(\"Incorrect name value.\")\n        if not pynos.utilities.valid_vlan_id(sec_vlan):\n            raise InvalidVlanId(\"`sec_vlan` must be between `1` and `8191`.\")\n\n        pvlan_args = dict(name=name, sec_assoc_add=sec_vlan)\n        pvlan_assoc = getattr(self._interface,\n                              'interface_vlan_interface_vlan_'\n                              'private_vlan_association_sec_assoc_add')\n        config = pvlan_assoc(**pvlan_args)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset interface PVLAN association.", "response": "def pvlan_host_association(self, **kwargs):\n        \"\"\"Set interface PVLAN association.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, etc)\n            name (str): Name of interface. (1/0/5, 1/0/10, etc)\n            pri_vlan (str): The primary PVLAN.\n            sec_vlan (str): The secondary PVLAN.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `int_type`, `name`, `pri_vlan`, or `sec_vlan` is not\n                specified.\n            ValueError: if `int_type`, `name`, `pri_vlan`, or `sec_vlan`\n                is invalid.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> int_type = 'tengigabitethernet'\n            >>> name = '225/0/38'\n            >>> pri_vlan = '75'\n            >>> sec_vlan = '100'\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.private_vlan_type(name=pri_vlan,\n            ...         pvlan_type='primary')\n            ...         output = dev.interface.private_vlan_type(name=sec_vlan,\n            ...         pvlan_type='isolated')\n            ...         output = dev.interface.vlan_pvlan_association_add(\n            ...         name=pri_vlan, sec_vlan=sec_vlan)\n            ...         output = dev.interface.enable_switchport(int_type,\n            ...         name)\n            ...         output = dev.interface.private_vlan_mode(\n            ...         int_type=int_type, name=name, mode='host')\n            ...         output = dev.interface.pvlan_host_association(\n            ...         int_type=int_type, name=name, pri_vlan=pri_vlan,\n            ...         sec_vlan=sec_vlan)\n            ...         dev.interface.pvlan_host_association()\n            ...         # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        pri_vlan = kwargs.pop('pri_vlan')\n        sec_vlan = kwargs.pop('sec_vlan')\n        callback = kwargs.pop('callback', self._callback)\n\n        int_types = ['gigabitethernet', 'tengigabitethernet',\n                     'fortygigabitethernet', 'hundredgigabitethernet',\n                     'port_channel']\n\n        if int_type not in int_types:\n            raise ValueError(\"Incorrect int_type value.\")\n\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n\n        if not pynos.utilities.valid_vlan_id(pri_vlan):\n            raise InvalidVlanId(\"`sec_vlan` must be between `1` and `4095`.\")\n        if not pynos.utilities.valid_vlan_id(sec_vlan):\n            raise InvalidVlanId(\"`sec_vlan` must be between `1` and `4095`.\")\n\n        pvlan_args = dict(name=name, host_pri_pvlan=pri_vlan)\n\n        associate_pvlan = getattr(self._interface,\n                                  'interface_%s_switchport_private_vlan_'\n                                  'host_association_host_pri_pvlan' %\n                                  int_type)\n        config = associate_pvlan(**pvlan_args)\n        sec_assoc = config.find('.//*host-association')\n        sec_assoc = ET.SubElement(sec_assoc, 'host-sec-pvlan')\n        sec_assoc.text = sec_vlan\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmodify allowed VLANs on Trunk", "response": "def trunk_allowed_vlan(self, **kwargs):\n        \"\"\"Modify allowed VLANs on Trunk (add, remove, none, all).\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, etc)\n            name (str): Name of interface. (1/0/5, 1/0/10, etc)\n            action (str): Action to take on trunk. (add, remove, none, all)\n            get (bool): Get config instead of editing config. (True, False)\n            vlan (str): vlan id for action. Only valid for add and remove.\n            ctag (str): ctag range. Only valid for add and remove.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `int_type`, `name`, or `mode` is not specified.\n            ValueError: if `int_type`, `name`, or `mode` is invalid.\n\n        Examples:\n            >>> # Skip due to current dev work\n            >>> # TODO: Reenable after dev work\n            >>> def test_trunk_allowed_vlan():\n            ...     import pynos.device\n            ...     switches = ['10.24.39.212', '10.24.39.202']\n            ...     auth = ('admin', 'password')\n            ...     int_type = 'tengigabitethernet'\n            ...     name = '226/0/4'\n            ...     for switch in switches:\n            ...         conn = (switch, '22')\n            ...         with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...             output = dev.interface.enable_switchport(int_type,\n            ...             name)\n            ...             output = dev.interface.trunk_mode(name=name,\n            ...             int_type=int_type, mode='trunk')\n            ...             output = dev.interface.add_vlan_int('25')\n            ...             output = dev.interface.add_vlan_int('8000')\n            ...             output = dev.interface.trunk_allowed_vlan(\n            ...             int_type=int_type, name=name, action='add',\n            ...             ctag='25', vlan='8000')\n            ...             dev.interface.private_vlan_mode()\n            ...             # doctest: +IGNORE_EXCEPTION_DETAIL\n            >>> test_trunk_allowed_vlan() # doctest: +SKIP\n        \"\"\"\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        action = kwargs.pop('action')\n        ctag = kwargs.pop('ctag', None)\n        vlan = kwargs.pop('vlan', None)\n        callback = kwargs.pop('callback', self._callback)\n\n        int_types = ['gigabitethernet', 'tengigabitethernet',\n                     'fortygigabitethernet', 'hundredgigabitethernet',\n                     'port_channel']\n        valid_actions = ['add', 'remove', 'none', 'all']\n\n        if int_type not in int_types:\n            raise ValueError(\"`int_type` must be one of: %s\" %\n                             repr(int_types))\n\n        if action not in valid_actions:\n            raise ValueError('%s must be one of: %s' % (action, valid_actions))\n\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n\n        allowed_vlan_args = dict(name=name,\n                                 add=vlan,\n                                 remove=vlan,\n                                 trunk_vlan_id=vlan,\n                                 trunk_ctag_range=ctag)\n\n        ctag_actions = ['add', 'remove']\n\n        if ctag and not vlan:\n            raise ValueError('vlan must be set when ctag is set ')\n\n        if ctag and action not in ctag_actions:\n            raise ValueError('%s must be in %s when %s is set '\n                             % (repr(action),\n                                repr(ctag_actions),\n                                repr(ctag)))\n\n        if not ctag:\n            allowed_vlan = getattr(self._interface,\n                                   'interface_%s_switchport_trunk_'\n                                   'allowed_vlan_%s' %\n                                   (int_type, action))\n        else:\n            allowed_vlan = getattr(self._interface,\n                                   'interface_%s_switchport_trunk_trunk_vlan_'\n                                   'classification_allowed_vlan_%s_trunk_'\n                                   'ctag_range'\n                                   % ((int_type, action)))\n        config = allowed_vlan(**allowed_vlan_args)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the PVLAN mode of the specified nic in the current node.", "response": "def private_vlan_mode(self, **kwargs):\n        \"\"\"Set PVLAN mode (promiscuous, host, trunk).\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, etc)\n            name (str): Name of interface. (1/0/5, 1/0/10, etc)\n            mode (str): The switchport PVLAN mode.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `int_type`, `name`, or `mode` is not specified.\n            ValueError: if `int_type`, `name`, or `mode` is invalid.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> int_type = 'tengigabitethernet'\n            >>> name = '225/0/38'\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.enable_switchport(int_type,\n            ...         name)\n            ...         output = dev.interface.private_vlan_mode(\n            ...         int_type=int_type, name=name, mode='trunk_host')\n            ...         dev.interface.private_vlan_mode()\n            ...         # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        mode = kwargs.pop('mode').lower()\n        callback = kwargs.pop('callback', self._callback)\n\n        int_types = ['gigabitethernet', 'tengigabitethernet',\n                     'fortygigabitethernet', 'hundredgigabitethernet',\n                     'port_channel']\n        valid_modes = ['host', 'promiscuous', 'trunk_host',\n                       'trunk_basic', 'trunk_promiscuous']\n\n        if int_type not in int_types:\n            raise ValueError(\"Incorrect int_type value.\")\n\n        if mode not in valid_modes:\n            raise ValueError('%s must be one of: %s' % (mode, valid_modes))\n\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n\n        pvlan_args = dict(name=name)\n\n        if 'trunk' in mode:\n            pvlan_mode = getattr(self._interface,\n                                 'interface_%s_switchport_mode_'\n                                 'private_vlan_private_vlan_trunk_%s' %\n                                 (int_type, mode))\n        else:\n            pvlan_mode = getattr(self._interface,\n                                 'interface_%s_switchport_mode_'\n                                 'private_vlan_%s' % (int_type, mode))\n        config = pvlan_mode(**pvlan_args)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef spanning_tree_state(self, **kwargs):\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        enabled = kwargs.pop('enabled')\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['gigabitethernet', 'tengigabitethernet',\n                           'fortygigabitethernet', 'hundredgigabitethernet',\n                           'port_channel', 'vlan']\n\n        if int_type not in valid_int_types:\n            raise ValueError('int_type must be one of: %s' %\n                             repr(valid_int_types))\n\n        if not isinstance(enabled, bool):\n            raise ValueError('%s must be `True` or `False`.' % repr(enabled))\n\n        if int_type == 'vlan':\n            if not pynos.utilities.valid_vlan_id(name):\n                raise InvalidVlanId('%s must be between 0 to 8191.' % int_type)\n\n            state_args = dict(name=name)\n            spanning_tree_state = getattr(self._interface,\n                                          'interface_%s_interface_%s_spanning_'\n                                          'tree_stp_shutdown' % (int_type,\n                                                                 int_type))\n\n        else:\n            if not pynos.utilities.valid_interface(int_type, name):\n                raise ValueError('`name` must be in the format of x/y/z for '\n                                 'physical interfaces or x for port channel.')\n\n            state_args = dict(name=name)\n            spanning_tree_state = getattr(self._interface,\n                                          'interface_%s_spanning_tree_'\n                                          'shutdown' % int_type)\n\n        config = spanning_tree_state(**state_args)\n\n        if enabled:\n            if int_type == 'vlan':\n                shutdown = config.find('.//*stp-shutdown')\n            else:\n                shutdown = config.find('.//*shutdown')\n            shutdown.set('operation', 'delete')\n        try:\n            return callback(config)\n        # TODO: Catch existing 'no shut'\n        # This is in place because if the interface spanning tree is already\n        # up,`ncclient` will raise an error if you try to admin up the\n        # interface again.\n        # TODO: add logic to shutdown STP at protocol level too.\n        except AttributeError:\n            return None", "response": "Set the Spanning Tree state of the specified object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntag the native VLAN on the specified Television Adapter.", "response": "def tag_native_vlan(self, **kwargs):\n        \"\"\"Set tagging of native VLAN on trunk.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, etc)\n            name (str): Name of interface. (1/0/5, 1/0/10, etc)\n            mode (str): Trunk port mode (trunk, trunk-no-default-native).\n            enabled (bool): Is tagging of the VLAN enabled on trunks?\n                (True, False)\n            callback (function): A function executed upon completion oj the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `int_type`, `name`, or `state` is not specified.\n            ValueError: if `int_type`, `name`, or `state` is not valid.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.trunk_mode(\n            ...         int_type='tengigabitethernet',\n            ...         name='225/0/38', mode='trunk')\n            ...         output = dev.interface.tag_native_vlan(name='225/0/38',\n            ...         int_type='tengigabitethernet')\n            ...         output = dev.interface.tag_native_vlan(\n            ...         int_type='tengigabitethernet',\n            ...         name='225/0/38', enabled=False)\n            ...         dev.interface.tag_native_vlan()\n            ...         # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        enabled = kwargs.pop('enabled', True)\n        callback = kwargs.pop('callback', self._callback)\n\n        int_types = ['gigabitethernet', 'tengigabitethernet',\n                     'fortygigabitethernet', 'hundredgigabitethernet',\n                     'port_channel']\n\n        if int_type not in int_types:\n            raise ValueError(\"Incorrect int_type value.\")\n\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n\n        if not isinstance(enabled, bool):\n            raise ValueError(\"Invalid state.\")\n\n        tag_args = dict(name=name)\n        tag_native_vlan = getattr(self._interface, 'interface_%s_switchport_'\n                                  'trunk_tag_native_vlan' % int_type)\n        config = tag_native_vlan(**tag_args)\n        if not enabled:\n            untag = config.find('.//*native-vlan')\n            untag.set('operation', 'delete')\n\n        try:\n            return callback(config)\n        # TODO: Catch existing 'no switchport tag native-vlan'\n        except AttributeError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mtu(self, **kwargs):\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        mtu = kwargs.pop('mtu')\n        callback = kwargs.pop('callback', self._callback)\n\n        int_types = [\n            'gigabitethernet',\n            'tengigabitethernet',\n            'fortygigabitethernet',\n            'hundredgigabitethernet',\n            'port_channel'\n        ]\n\n        if int_type not in int_types:\n            raise ValueError(\"Incorrect int_type value.\")\n\n        minimum_mtu = 1522\n        maximum_mtu = 9216\n        if int(mtu) < minimum_mtu or int(mtu) > maximum_mtu:\n            raise ValueError(\"Incorrect mtu value 1522-9216\")\n\n        mtu_args = dict(name=name, mtu=mtu)\n\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n\n        config = getattr(\n            self._interface,\n            'interface_%s_mtu' % int_type\n        )(**mtu_args)\n        return callback(config)", "response": "Set the MTU of the specified internal entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting fabric ISL state.", "response": "def fabric_isl(self, **kwargs):\n        \"\"\"Set fabric ISL state.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, etc)\n            name (str): Name of interface. (1/0/5, 1/0/10, etc)\n            enabled (bool): Is fabric ISL state enabled? (True, False)\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `int_type`, `name`, or `state` is not specified.\n            ValueError: if `int_type`, `name`, or `state` is not a valid value.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.fabric_isl(\n            ...         int_type='tengigabitethernet',\n            ...         name='225/0/40',\n            ...         enabled=False)\n            ...         dev.interface.fabric_isl()\n            ...         # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        int_type = str(kwargs.pop('int_type').lower())\n        name = str(kwargs.pop('name'))\n        enabled = kwargs.pop('enabled', True)\n        callback = kwargs.pop('callback', self._callback)\n\n        int_types = [\n            'tengigabitethernet',\n            'fortygigabitethernet',\n            'hundredgigabitethernet'\n        ]\n\n        if int_type not in int_types:\n            raise ValueError(\"`int_type` must be one of: %s\" %\n                             repr(int_types))\n\n        if not isinstance(enabled, bool):\n            raise ValueError('`enabled` must be `True` or `False`.')\n\n        fabric_isl_args = dict(name=name)\n\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError(\"`name` must match `^[0-9]{1,3}/[0-9]{1,3}/[0-9]\"\n                             \"{1,3}$`\")\n\n        config = getattr(\n            self._interface,\n            'interface_%s_fabric_fabric_isl_fabric_isl_enable' % int_type\n        )(**fabric_isl_args)\n\n        if not enabled:\n            fabric_isl = config.find('.//*fabric-isl')\n            fabric_isl.set('operation', 'delete')\n\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        else:\n            return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef v6_nd_suppress_ra(self, **kwargs):\n        int_type = str(kwargs.pop('int_type').lower())\n        name = str(kwargs.pop('name'))\n        callback = kwargs.pop('callback', self._callback)\n\n        int_types = [\n            'gigabitethernet',\n            'tengigabitethernet',\n            'fortygigabitethernet',\n            'hundredgigabitethernet',\n            've'\n        ]\n\n        if int_type not in int_types:\n            raise ValueError(\"`int_type` must be one of: %s\" % repr(int_types))\n\n        if int_type == \"ve\":\n            if not pynos.utilities.valid_vlan_id(name):\n                raise ValueError(\"`name` must be between `1` and `8191`\")\n\n            rbridge_id = kwargs.pop('rbridge_id', \"1\")\n\n            nd_suppress_args = dict(name=name, rbridge_id=rbridge_id)\n            nd_suppress = getattr(self._rbridge,\n                                  'rbridge_id_interface_ve_ipv6_'\n                                  'ipv6_nd_ra_ipv6_intf_cmds_'\n                                  'nd_suppress_ra_suppress_ra_all')\n            config = nd_suppress(**nd_suppress_args)\n        else:\n            if not pynos.utilities.valid_interface(int_type, name):\n                raise ValueError(\"`name` must match \"\n                                 \"`^[0-9]{1,3}/[0-9]{1,3}/[0-9]{1,3}$`\")\n\n            nd_suppress_args = dict(name=name)\n            nd_suppress = getattr(self._interface,\n                                  'interface_%s_ipv6_ipv6_nd_ra_'\n                                  'ipv6_intf_cmds_nd_suppress_ra_'\n                                  'suppress_ra_all' % int_type)\n            config = nd_suppress(**nd_suppress_args)\n        return callback(config)", "response": "Disable IPv6 Router Advertisements for an arbitrary internal entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef vrrp_vip(self, **kwargs):\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        vrid = kwargs.pop('vrid')\n        vip = kwargs.pop('vip')\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['gigabitethernet', 'tengigabitethernet',\n                           'fortygigabitethernet', 'hundredgigabitethernet',\n                           'port_channel', 've']\n        ipaddress = ip_interface(unicode(vip))\n        vrrp_vip = None\n        vrrp_args = dict(name=name,\n                         vrid=vrid,\n                         virtual_ipaddr=str(ipaddress.ip))\n        method_class = self._interface\n\n        if int_type not in valid_int_types:\n            raise ValueError('`int_type` must be one of: %s' %\n                             repr(valid_int_types))\n\n        if ipaddress.version == 4:\n            vrrp_args['version'] = '3'\n            method_name = 'interface_%s_vrrp_virtual_ip_virtual_' \\\n                          'ipaddr' % int_type\n        elif ipaddress.version == 6:\n            method_name = 'interface_%s_ipv6_vrrpv3_group_virtual_ip_' \\\n                          'virtual_ipaddr' % int_type\n\n        if int_type == 've':\n            method_name = 'rbridge_id_%s' % method_name\n            if ipaddress.version == 6:\n                method_name = method_name.replace('group_', '')\n            method_class = self._rbridge\n            vrrp_args['rbridge_id'] = rbridge_id\n            if not pynos.utilities.valid_vlan_id(name):\n                raise InvalidVlanId(\"`name` must be between `1` and `8191`\")\n        elif not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n\n        vrrp_vip = getattr(method_class, method_name)\n        config = vrrp_vip(**vrrp_args)\n        return callback(config)", "response": "Set VRRP VIP.\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, etc).\n            name (str): Name of interface. (1/0/5, 1/0/10, etc).\n            vrid (str): VRRPv3 ID.\n            vip (str): IPv4/IPv6 Virtual IP Address.\n            rbridge_id (str): rbridge-id for device. Only required when type is\n                `ve`.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n        Returns:\n            Return value of `callback`.\n        Raises:\n            KeyError: if `int_type`, `name`, `vrid`, or `vip` is not passed.\n            ValueError: if `int_type`, `name`, `vrid`, or `vip` is invalid.\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.anycast_mac(rbridge_id='225',\n            ...         mac='aabb.ccdd.eeff', delete=True)\n            ...         output = dev.services.vrrp(ip_version='6',\n            ...         enabled=True, rbridge_id='225')\n            ...         output = dev.services.vrrp(enabled=True,\n            ...         rbridge_id='225')\n            ...         output = dev.interface.set_ip('tengigabitethernet',\n            ...         '225/0/18', '10.1.1.2/24')\n            ...         output = dev.interface.ip_address(name='225/0/18',\n            ...         int_type='tengigabitethernet',\n            ...         ip_addr='2001:4818:f000:1ab:cafe:beef:1000:2/64')\n            ...         dev.interface.vrrp_vip(int_type='tengigabitethernet',\n            ...         name='225/0/18', vrid='1', vip='10.1.1.1/24')\n            ...         dev.interface.vrrp_vip(int_type='tengigabitethernet',\n            ...         name='225/0/18', vrid='1',\n            ...         vip='fe80::cafe:beef:1000:1/64')\n            ...         dev.interface.vrrp_vip(int_type='tengigabitethernet',\n            ...         name='225/0/18', vrid='1',\n            ...         vip='2001:4818:f000:1ab:cafe:beef:1000:1/64')\n            ...         output = dev.interface.add_vlan_int('89')\n            ...         output = dev.interface.ip_address(name='89',\n            ...         int_type='ve', ip_addr='172.16.1.1/24',\n            ...         rbridge_id='225')\n            ...         output = dev.interface.ip_address(name='89',\n            ...         int_type='ve', rbridge_id='225',\n            ...         ip_addr='2002:4818:f000:1ab:cafe:beef:1000:2/64')\n            ...         dev.interface.vrrp_vip(int_type='ve', name='89',\n            ...         vrid='1', vip='172.16.1.2/24', rbridge_id='225')\n            ...         dev.interface.vrrp_vip(int_type='ve', name='89',\n            ...         vrid='1', vip='fe80::dafe:beef:1000:1/64',\n            ...         rbridge_id='225')\n            ...         dev.interface.vrrp_vip(int_type='ve', name='89',\n            ...         vrid='1', vip='2002:4818:f000:1ab:cafe:beef:1000:1/64',\n            ...         rbridge_id='225')\n            ...         output = dev.services.vrrp(ip_version='6',\n            ...         enabled=False, rbridge_id='225')\n            ...         output = dev.services.vrrp(enabled=False,\n            ...         rbridge_id='225')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets VRRP priority. Args: int_type (str): Type of interface. (gigabitethernet, tengigabitethernet, etc). name (str): Name of interface. (1/0/5, 1/0/10, etc). vrid (str): VRRPv3 ID. priority (str): VRRP Priority. ip_version (str): Version of IP (4, 6). callback (function): A function executed upon completion of the method. The only parameter passed to `callback` will be the ``ElementTree`` `config`. Returns: Return value of `callback`. Raises: KeyError: if `int_type`, `name`, `vrid`, `priority`, or `ip_version` is not passed. ValueError: if `int_type`, `name`, `vrid`, `priority`, or `ip_version` is invalid. Examples: >>> import pynos.device >>> switches = ['10.24.39.211', '10.24.39.203'] >>> auth = ('admin', 'password') >>> for switch in switches: ... conn = (switch, '22') ... with pynos.device.Device(conn=conn, auth=auth) as dev: ... output = dev.interface.anycast_mac(rbridge_id='225', ... mac='aabb.ccdd.eeff', delete=True) ... output = dev.services.vrrp(ip_version='6', ... enabled=True, rbridge_id='225') ... output = dev.services.vrrp(enabled=True, ... rbridge_id='225') ... output = dev.interface.set_ip('tengigabitethernet', ... '225/0/18', '10.1.1.2/24') ... output = dev.interface.ip_address(name='225/0/18', ... int_type='tengigabitethernet', ... ip_addr='2001:4818:f000:1ab:cafe:beef:1000:2/64') ... dev.interface.vrrp_vip(int_type='tengigabitethernet', ... name='225/0/18', vrid='1', vip='10.1.1.1/24') ... dev.interface.vrrp_vip(int_type='tengigabitethernet', ... name='225/0/18', vrid='1', ... vip='fe80::cafe:beef:1000:1/64') ... dev.interface.vrrp_vip(int_type='tengigabitethernet', ... name='225/0/18', vrid='1', ... vip='2001:4818:f000:1ab:cafe:beef:1000:1/64') ... dev.interface.vrrp_priority( ... int_type='tengigabitethernet', ... name='225/0/18', vrid='1', ip_version='4', ... priority='66') ... dev.interface.vrrp_priority( ... int_type='tengigabitethernet', ... name='225/0/18', vrid='1', ip_version='6', ... priority='77') ... output = dev.interface.add_vlan_int('88') ... output = dev.interface.ip_address(int_type='ve', ... name='88', ip_addr='172.16.10.1/24', rbridge_id='225') ... output = dev.interface.ip_address(int_type='ve', ... name='88', rbridge_id='225', ... ip_addr='2003:4818:f000:1ab:cafe:beef:1000:2/64') ... dev.interface.vrrp_vip(int_type='ve', name='88', ... vrid='1', vip='172.16.10.2/24', rbridge_id='225') ... dev.interface.vrrp_vip(int_type='ve', name='88', ... rbridge_id='225', vrid='1', ... vip='fe80::dafe:beef:1000:1/64') ... dev.interface.vrrp_vip(int_type='ve', rbridge_id='225', ... name='88', vrid='1', ... vip='2003:4818:f000:1ab:cafe:beef:1000:1/64') ... dev.interface.vrrp_priority(int_type='ve', name='88', ... rbridge_id='225', vrid='1', ip_version='4', ... priority='66') ... dev.interface.vrrp_priority(int_type='ve', name='88', ... rbridge_id='225', vrid='1', ip_version='6', ... priority='77') ... output = dev.services.vrrp(ip_version='6', ... enabled=False, rbridge_id='225') ... output = dev.services.vrrp(enabled=False, ... rbridge_id='225')", "response": "def vrrp_priority(self, **kwargs):\n        \"\"\"Set VRRP priority.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, etc).\n            name (str): Name of interface. (1/0/5, 1/0/10, etc).\n            vrid (str): VRRPv3 ID.\n            priority (str): VRRP Priority.\n            ip_version (str): Version of IP (4, 6).\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `int_type`, `name`, `vrid`, `priority`, or\n                `ip_version` is not passed.\n            ValueError: if `int_type`, `name`, `vrid`, `priority`, or\n                `ip_version` is invalid.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.anycast_mac(rbridge_id='225',\n            ...         mac='aabb.ccdd.eeff', delete=True)\n            ...         output = dev.services.vrrp(ip_version='6',\n            ...         enabled=True, rbridge_id='225')\n            ...         output = dev.services.vrrp(enabled=True,\n            ...         rbridge_id='225')\n            ...         output = dev.interface.set_ip('tengigabitethernet',\n            ...         '225/0/18', '10.1.1.2/24')\n            ...         output = dev.interface.ip_address(name='225/0/18',\n            ...         int_type='tengigabitethernet',\n            ...         ip_addr='2001:4818:f000:1ab:cafe:beef:1000:2/64')\n            ...         dev.interface.vrrp_vip(int_type='tengigabitethernet',\n            ...         name='225/0/18', vrid='1', vip='10.1.1.1/24')\n            ...         dev.interface.vrrp_vip(int_type='tengigabitethernet',\n            ...         name='225/0/18', vrid='1',\n            ...         vip='fe80::cafe:beef:1000:1/64')\n            ...         dev.interface.vrrp_vip(int_type='tengigabitethernet',\n            ...         name='225/0/18', vrid='1',\n            ...         vip='2001:4818:f000:1ab:cafe:beef:1000:1/64')\n            ...         dev.interface.vrrp_priority(\n            ...         int_type='tengigabitethernet',\n            ...         name='225/0/18', vrid='1', ip_version='4',\n            ...         priority='66')\n            ...         dev.interface.vrrp_priority(\n            ...         int_type='tengigabitethernet',\n            ...         name='225/0/18', vrid='1', ip_version='6',\n            ...         priority='77')\n            ...         output = dev.interface.add_vlan_int('88')\n            ...         output = dev.interface.ip_address(int_type='ve',\n            ...         name='88', ip_addr='172.16.10.1/24', rbridge_id='225')\n            ...         output = dev.interface.ip_address(int_type='ve',\n            ...         name='88', rbridge_id='225',\n            ...         ip_addr='2003:4818:f000:1ab:cafe:beef:1000:2/64')\n            ...         dev.interface.vrrp_vip(int_type='ve', name='88',\n            ...         vrid='1', vip='172.16.10.2/24', rbridge_id='225')\n            ...         dev.interface.vrrp_vip(int_type='ve', name='88',\n            ...         rbridge_id='225', vrid='1',\n            ...         vip='fe80::dafe:beef:1000:1/64')\n            ...         dev.interface.vrrp_vip(int_type='ve', rbridge_id='225',\n            ...         name='88', vrid='1',\n            ...         vip='2003:4818:f000:1ab:cafe:beef:1000:1/64')\n            ...         dev.interface.vrrp_priority(int_type='ve', name='88',\n            ...         rbridge_id='225', vrid='1', ip_version='4',\n            ...         priority='66')\n            ...         dev.interface.vrrp_priority(int_type='ve', name='88',\n            ...         rbridge_id='225', vrid='1', ip_version='6',\n            ...         priority='77')\n            ...         output = dev.services.vrrp(ip_version='6',\n            ...         enabled=False, rbridge_id='225')\n            ...         output = dev.services.vrrp(enabled=False,\n            ...         rbridge_id='225')\n        \"\"\"\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        vrid = kwargs.pop('vrid')\n        priority = kwargs.pop('priority')\n        ip_version = int(kwargs.pop('ip_version'))\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['gigabitethernet', 'tengigabitethernet',\n                           'fortygigabitethernet', 'hundredgigabitethernet',\n                           'port_channel', 've']\n        vrrp_args = dict(name=name, vrid=vrid, priority=priority)\n        vrrp_priority = None\n        method_name = None\n        method_class = self._interface\n\n        if int_type not in valid_int_types:\n            raise ValueError('`int_type` must be one of: %s' %\n                             repr(valid_int_types))\n\n        if ip_version == 4:\n            vrrp_args['version'] = '3'\n            method_name = 'interface_%s_vrrp_priority' % int_type\n        elif ip_version == 6:\n            method_name = 'interface_%s_ipv6_vrrpv3_group_priority' % int_type\n\n        if int_type == 've':\n            method_name = \"rbridge_id_%s\" % method_name\n            if ip_version == 6:\n                method_name = method_name.replace('group_', '')\n            method_class = self._rbridge\n            vrrp_args['rbridge_id'] = rbridge_id\n            if not pynos.utilities.valid_vlan_id(name):\n                raise InvalidVlanId(\"`name` must be between `1` and `8191`\")\n        elif not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n\n        vrrp_priority = getattr(method_class, method_name)\n        config = vrrp_priority(**vrrp_args)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef proxy_arp(self, **kwargs):\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        enabled = kwargs.pop('enabled', True)\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['gigabitethernet', 'tengigabitethernet',\n                           'fortygigabitethernet', 'hundredgigabitethernet',\n                           'port_channel', 've']\n\n        if int_type not in valid_int_types:\n            raise ValueError('`int_type` must be one of: %s' %\n                             repr(valid_int_types))\n        if not isinstance(enabled, bool):\n            raise ValueError('`enabled` must be `True` or `False`.')\n\n        method_name = 'interface_%s_ip_ip_config_proxy_arp' % int_type\n        method_class = self._interface\n        proxy_arp_args = dict(name=name)\n        if int_type == 've':\n            method_name = \"rbridge_id_%s\" % method_name\n            method_class = self._rbridge\n            proxy_arp_args['rbridge_id'] = rbridge_id\n            if not pynos.utilities.valid_vlan_id(name):\n                raise InvalidVlanId(\"`name` must be between `1` and `8191`\")\n        elif not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'phyiscal interfaces or x for port channel.')\n\n        proxy_arp = getattr(method_class, method_name)\n        config = proxy_arp(**proxy_arp_args)\n        if not enabled:\n            config.find('.//*proxy-arp').set('operation', 'delete')\n        try:\n            return callback(config)\n        # TODO: Catch existing 'no proxy arp'\n        # This is in place because if proxy arp is already disabled,\n        # `ncclient` will raise an error if you try to disable it again.\n        except AttributeError:\n            return None", "response": "Set interface administrative state."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the minimum number of links in a port - channel group.", "response": "def port_channel_minimum_links(self, **kwargs):\n        \"\"\"Set minimum number of links in a port channel.\n\n        Args:\n            name (str): Port-channel number. (1, 5, etc)\n            minimum_links (str): Minimum number of links in channel group.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `name` or `minimum_links` is not specified.\n            ValueError: if `name` is not a valid value.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.port_channel_minimum_links(\n            ...         name='1', minimum_links='2')\n            ...         dev.interface.port_channel_minimum_links()\n            ...         # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        name = str(kwargs.pop('name'))\n        minimum_links = str(kwargs.pop('minimum_links'))\n        callback = kwargs.pop('callback', self._callback)\n\n        min_links_args = dict(name=name, minimum_links=minimum_links)\n\n        if not pynos.utilities.valid_interface('port_channel', name):\n            raise ValueError(\"`name` must match `^[0-9]{1,3}${1,3}$`\")\n\n        config = getattr(\n            self._interface,\n            'interface_port_channel_minimum_links'\n        )(**min_links_args)\n\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef channel_group(self, **kwargs):\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        channel_type = kwargs.pop('channel_type')\n        port_int = kwargs.pop('port_int')\n        mode = kwargs.pop('mode')\n        delete = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n\n        int_types = [\n            'gigabitethernet',\n            'tengigabitethernet',\n            'fortygigabitethernet',\n            'hundredgigabitethernet'\n        ]\n\n        if int_type not in int_types:\n            raise ValueError(\"`int_type` must be one of: %s\" % repr(int_types))\n\n        valid_modes = ['active', 'on', 'passive']\n\n        if mode not in valid_modes:\n            raise ValueError(\"`mode` must be one of: %s\" % repr(valid_modes))\n\n        valid_types = ['brocade', 'standard']\n\n        if channel_type not in valid_types:\n            raise ValueError(\"`channel_type` must be one of: %s\" %\n                             repr(valid_types))\n\n        if not pynos.utilities.valid_interface('port_channel', port_int):\n            raise ValueError(\"incorrect port_int value.\")\n\n        channel_group_args = dict(name=name, mode=mode)\n\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError(\"incorrect name value.\")\n\n        config = getattr(\n            self._interface,\n            'interface_%s_channel_group_mode' % int_type\n        )(**channel_group_args)\n\n        channel_group = config.find('.//*channel-group')\n        if delete is True:\n            channel_group.set('operation', 'delete')\n        else:\n            ET.SubElement(channel_group, 'port-int').text = port_int\n            ET.SubElement(channel_group, 'type').text = channel_type\n\n        return callback(config)", "response": "set channel group mode."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nignore VLAG Split. Args: name (str): Port-channel number. (1, 5, etc) enabled (bool): Is ignore split enabled? (True, False) callback (function): A function executed upon completion of the method. The only parameter passed to `callback` will be the ``ElementTree`` `config`. Returns: Return value of `callback`. Raises: KeyError: if `name` or `enable` is not specified. ValueError: if `name` is not a valid value. Examples: >>> import pynos.device >>> switches = ['10.24.39.211', '10.24.39.203'] >>> auth = ('admin', 'password') >>> for switch in switches: ... conn = (switch, '22') ... with pynos.device.Device(conn=conn, auth=auth) as dev: ... output = dev.interface.port_channel_vlag_ignore_split( ... name='1', enabled=True) ... dev.interface.port_channel_vlag_ignore_split() ... # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): KeyError", "response": "def port_channel_vlag_ignore_split(self, **kwargs):\n        \"\"\"Ignore VLAG Split.\n\n        Args:\n            name (str): Port-channel number. (1, 5, etc)\n            enabled (bool): Is ignore split enabled? (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `name` or `enable` is not specified.\n            ValueError: if `name` is not a valid value.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.port_channel_vlag_ignore_split(\n            ...         name='1', enabled=True)\n            ...         dev.interface.port_channel_vlag_ignore_split()\n            ...         # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        name = str(kwargs.pop('name'))\n        enabled = bool(kwargs.pop('enabled', True))\n        callback = kwargs.pop('callback', self._callback)\n\n        vlag_ignore_args = dict(name=name)\n\n        if not pynos.utilities.valid_interface('port_channel', name):\n            raise ValueError(\"`name` must match x\")\n\n        config = getattr(\n            self._interface,\n            'interface_port_channel_vlag_ignore_split'\n        )(**vlag_ignore_args)\n\n        if not enabled:\n            ignore_split = config.find('.//*ignore-split')\n            ignore_split.set('operation', 'delete')\n\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets trunk mode (trunk, trunk-no-default-vlan). Args: int_type (str): Type of interface. (gigabitethernet, tengigabitethernet, etc) name (str): Name of interface. (1/0/5, 1/0/10, etc) mode (str): Trunk port mode (trunk, trunk-no-default-native). callback (function): A function executed upon completion oj the method. The only parameter passed to `callback` will be the ``ElementTree`` `config`. Returns: Return value of `callback`. Raises: KeyError: if `int_type`, `name`, or `mode` is not specified. ValueError: if `int_type`, `name`, or `mode` is not valid. Examples: >>> import pynos.device >>> switches = ['10.24.39.211', '10.24.39.203'] >>> auth = ('admin', 'password') >>> for switch in switches: ... conn = (switch, '22') ... with pynos.device.Device(conn=conn, auth=auth) as dev: ... output = dev.interface.trunk_mode(name='225/0/38', ... int_type='tengigabitethernet', mode='trunk') ... dev.interface.trunk_mode() ... # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): KeyError", "response": "def trunk_mode(self, **kwargs):\n        \"\"\"Set trunk mode (trunk, trunk-no-default-vlan).\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, etc)\n            name (str): Name of interface. (1/0/5, 1/0/10, etc)\n            mode (str): Trunk port mode (trunk, trunk-no-default-native).\n            callback (function): A function executed upon completion oj the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `int_type`, `name`, or `mode` is not specified.\n            ValueError: if `int_type`, `name`, or `mode` is not valid.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.trunk_mode(name='225/0/38',\n            ...         int_type='tengigabitethernet', mode='trunk')\n            ...         dev.interface.trunk_mode()\n            ...         # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        mode = kwargs.pop('mode').lower()\n        get = kwargs.pop('get', False)\n        callback = kwargs.pop('callback', self._callback)\n        int_types = ['gigabitethernet', 'tengigabitethernet',\n                     'fortygigabitethernet', 'hundredgigabitethernet',\n                     'port_channel']\n\n        if int_type not in int_types:\n            raise ValueError(\"Incorrect int_type value.\")\n\n        valid_modes = ['trunk', 'trunk-no-default-native']\n        if mode not in valid_modes:\n            raise ValueError(\"Incorrect mode value\")\n\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n\n        mode_args = dict(name=name, vlan_mode=mode)\n        switchport_mode = getattr(self._interface, 'interface_%s_switchport_'\n                                                   'mode_vlan_mode' % int_type)\n        config = switchport_mode(**mode_args)\n        if get:\n            return callback(config, handler='get_config')\n        config = switchport_mode(**mode_args)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef transport_service(self, **kwargs):\n        vlan = kwargs.pop('vlan')\n        service_id = kwargs.pop('service_id')\n        callback = kwargs.pop('callback', self._callback)\n\n        if not pynos.utilities.valid_vlan_id(vlan, extended=True):\n            raise InvalidVlanId(\"vlan must be between `1` and `8191`\")\n\n        service_args = dict(name=vlan, transport_service=service_id)\n        transport_service = getattr(self._interface,\n                                    'interface_vlan_interface_vlan_'\n                                    'transport_service')\n        config = transport_service(**service_args)\n        return callback(config)", "response": "Configure the VLAN Transport Service."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lacp_timeout(self, **kwargs):\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        timeout = kwargs.pop('timeout')\n        callback = kwargs.pop('callback', self._callback)\n\n        int_types = [\n            'gigabitethernet',\n            'tengigabitethernet',\n            'fortygigabitethernet',\n            'hundredgigabitethernet'\n        ]\n\n        if int_type not in int_types:\n            raise ValueError(\"Incorrect int_type value.\")\n\n        valid_timeouts = ['long', 'short']\n        if timeout not in valid_timeouts:\n            raise ValueError(\"Incorrect timeout value\")\n\n        timeout_args = dict(name=name, timeout=timeout)\n\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError(\"Incorrect name value.\")\n\n        config = getattr(\n            self._interface,\n            'interface_%s_lacp_timeout' % int_type\n        )(**timeout_args)\n        return callback(config)", "response": "Set the timeout of an element tree in the specified lacp."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets interface switchport status.", "response": "def switchport(self, **kwargs):\n        \"\"\"Set interface switchport status.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, etc)\n            name (str): Name of interface. (1/0/5, 1/0/10, etc)\n            enabled (bool): Is the interface enabled? (True, False)\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `int_type` or `name` is not specified.\n            ValueError: if `name` or `int_type` is not a valid\n                value.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.switchport(name='225/0/19',\n            ...         int_type='tengigabitethernet')\n            ...         output = dev.interface.switchport(name='225/0/19',\n            ...         int_type='tengigabitethernet', enabled=False)\n            ...         dev.interface.switchport()\n            ...         # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        enabled = kwargs.pop('enabled', True)\n        callback = kwargs.pop('callback', self._callback)\n        int_types = ['gigabitethernet', 'tengigabitethernet',\n                     'fortygigabitethernet', 'hundredgigabitethernet',\n                     'port_channel', 'vlan']\n\n        if int_type not in int_types:\n            raise ValueError(\"`int_type` must be one of: %s\" % repr(int_types))\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n\n        switchport_args = dict(name=name)\n        switchport = getattr(self._interface,\n                             'interface_%s_switchport_basic_basic' % int_type)\n\n        config = switchport(**switchport_args)\n        if not enabled:\n            config.find('.//*switchport-basic').set('operation', 'delete')\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        else:\n            return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset access VLAN on a port.", "response": "def acc_vlan(self, **kwargs):\n        \"\"\"Set access VLAN on a port.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, etc)\n            name (str): Name of interface. (1/0/5, 1/0/10, etc)\n            vlan (str): VLAN ID to set as the access VLAN.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `int_type`, `name`, or `vlan` is not specified.\n            ValueError: if `int_type`, `name`, or `vlan` is not valid.\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> int_type = 'tengigabitethernet'\n            >>> name = '225/0/30'\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.add_vlan_int('736')\n            ...         output = dev.interface.enable_switchport(int_type,\n            ...         name)\n            ...         output = dev.interface.acc_vlan(int_type=int_type,\n            ...         name=name, vlan='736')\n            ...         dev.interface.acc_vlan()\n            ...         # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        int_type = kwargs.pop('int_type')\n        name = kwargs.pop('name')\n        vlan = kwargs.pop('vlan')\n        callback = kwargs.pop('callback', self._callback)\n        int_types = ['gigabitethernet', 'tengigabitethernet',\n                     'fortygigabitethernet', 'hundredgigabitethernet',\n                     'port_channel']\n\n        if int_type not in int_types:\n            raise ValueError(\"`int_type` must be one of: %s\" % repr(int_types))\n        if not pynos.utilities.valid_vlan_id(vlan):\n            raise InvalidVlanId(\"`name` must be between `1` and `4096`\")\n        if not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n\n        vlan_args = dict(name=name, accessvlan=vlan)\n        access_vlan = getattr(self._interface,\n                              'interface_%s_switchport_access_accessvlan' %\n                              int_type)\n        config = access_vlan(**vlan_args)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef interfaces(self):\n        urn = \"{urn:brocade.com:mgmt:brocade-interface-ext}\"\n        int_ns = 'urn:brocade.com:mgmt:brocade-interface-ext'\n\n        result = []\n        has_more = ''\n        last_interface_name = ''\n        last_interface_type = ''\n\n        while (has_more == '') or (has_more == 'true'):\n            request_interface = self.get_interface_detail_request(\n                last_interface_name, last_interface_type)\n            interface_result = self._callback(request_interface, 'get')\n            has_more = interface_result.find('%shas-more' % urn).text\n\n            for item in interface_result.findall('%sinterface' % urn):\n                interface_type = item.find('%sinterface-type' % urn).text\n                interface_name = item.find('%sinterface-name' % urn).text\n                last_interface_type = interface_type\n                last_interface_name = interface_name\n                if \"gigabitethernet\" in interface_type:\n                    interface_role = item.find('%sport-role' % urn).text\n                    if_name = item.find('%sif-name' % urn).text\n                    interface_state = item.find('%sif-state' % urn).text\n                    interface_proto_state = item.find('%sline-protocol-state' %\n                                                      urn).text\n                    interface_mac = item.find(\n                        '%scurrent-hardware-address' % urn).text\n\n                    item_results = {'interface-type': interface_type,\n                                    'interface-name': interface_name,\n                                    'interface-role': interface_role,\n                                    'if-name': if_name,\n                                    'interface-state': interface_state,\n                                    'interface-proto-state':\n                                        interface_proto_state,\n                                    'interface-mac': interface_mac}\n                    result.append(item_results)\n        # Loopback interfaces. Probably for other non-physical interfaces, too.\n        ip_result = []\n        request_interface = ET.Element('get-ip-interface', xmlns=int_ns)\n        interface_result = self._callback(request_interface, 'get')\n        for interface in interface_result.findall('%sinterface' % urn):\n            int_type = interface.find('%sinterface-type' % urn).text\n            int_name = interface.find('%sinterface-name' % urn).text\n            if int_type == 'unknown':\n                continue\n\n            int_state = interface.find('%sif-state' % urn).text\n            int_proto_state = interface.find('%sline-protocol-state' %\n                                             urn).text\n            ip_address = interface.find('.//%sipv4' % urn).text\n            results = {'interface-type': int_type,\n                       'interface-name': int_name,\n                       'interface-role': None,\n                       'if-name': None,\n                       'interface-state': int_state,\n                       'interface-proto-state': int_proto_state,\n                       'interface-mac': None,\n                       'ip-address': ip_address}\n            x = next((x for x in result if int_type == x['interface-type'] and\n                      int_name == x['interface-name']), None)\n            if x is not None:\n                results.update(x)\n            ip_result.append(results)\n        return ip_result", "response": "Get the state of the physical interfaces."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_interface_detail_request(last_interface_name,\n                                     last_interface_type):\n        \"\"\" Creates a new Netconf request based on the last received\n        interface name and type when the hasMore flag is true\n        \"\"\"\n\n        request_interface = ET.Element(\n            'get-interface-detail',\n            xmlns=\"urn:brocade.com:mgmt:brocade-interface-ext\"\n        )\n        if last_interface_name != '':\n            last_received_int = ET.SubElement(request_interface,\n                                              \"last-rcvd-interface\")\n            last_int_type_el = ET.SubElement(last_received_int,\n                                             \"interface-type\")\n            last_int_type_el.text = last_interface_type\n            last_int_name_el = ET.SubElement(last_received_int,\n                                             \"interface-name\")\n            last_int_name_el.text = last_interface_name\n        return request_interface", "response": "Creates a Netconf request based on the last received interface name and type"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef interface_detail(self):\n        urn = \"{urn:brocade.com:mgmt:brocade-interface-ext}\"\n\n        result = []\n        has_more = ''\n        last_interface_name = ''\n        last_interface_type = ''\n\n        while (has_more == '') or (has_more == 'true'):\n            request_interface = self.get_interface_detail_request(\n                last_interface_name, last_interface_type)\n            interface_result = self._callback(request_interface, 'get')\n            has_more = interface_result.find('%shas-more' % urn).text\n\n            for item in interface_result.findall('%sinterface' % urn):\n                interface_type = item.find('%sinterface-type' % urn).text\n                interface_name = item.find('%sinterface-name' % urn).text\n                last_interface_type = interface_type\n                last_interface_name = interface_name\n                if \"gigabitethernet\" in interface_type or\\\n                   \"port-channel\" in interface_type:\n                    if \"gigabitethernet\" in interface_type:\n                        interface_role = item.find('%sport-role' % urn).text\n                    else:\n                        interface_role = \"None\"\n                    if_name = item.find('%sif-name' % urn).text\n                    interface_state = item.find('%sif-state' % urn).text\n                    interface_proto_state = item.find('%sline-protocol-state' %\n                                                      urn).text\n                    interface_mac = item.find(\n                        '%scurrent-hardware-address' % urn).text\n                    item_results = {'interface-type': interface_type,\n                                    'interface-name': interface_name,\n                                    'interface-role': interface_role,\n                                    'if-name': if_name,\n                                    'interface-state': interface_state,\n                                    'interface-proto-state':\n                                        interface_proto_state,\n                                    'interface-mac': interface_mac}\n                result.append(item_results)\n\n        return result", "response": "Get the details of the Physical Interfaces of all rbridges."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the list of details of list of dictionary items describing the details of switch port", "response": "def switchport_list(self):\n        \"\"\"list[dict]:A list of dictionary items describing the details\n         of list of dictionary items describing the details of switch port\"\"\"\n        urn = \"{urn:brocade.com:mgmt:brocade-interface-ext}\"\n        result = []\n        request_interface = self.get_interface_switchport_request()\n        interface_result = self._callback(request_interface, 'get')\n        for interface in interface_result.findall('%sswitchport' % urn):\n            vlans = []\n            interface_type = self.get_node_value(interface, '%sinterface-type',\n                                                 urn)\n            interface_name = self.get_node_value(interface, '%sinterface-name',\n                                                 urn)\n            mode = self.get_node_value(interface, '%smode', urn)\n            intf = interface.find('%sactive-vlans' % urn)\n            for vlan_node in intf.findall('%svlanid' % urn):\n                vlan = vlan_node.text\n                vlans.append(vlan)\n            results = {'vlan-id': vlans,\n                       'mode': mode,\n                       'interface-name': interface_name,\n                       'interface_type': interface_type}\n            result.append(results)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the list of vlans of the current node", "response": "def vlans(self):\n        \"\"\"list[dict]: A list of dictionary items describing the details of\n        vlan interfaces.\n        This method fetches the VLAN interfaces\n        Examples:\n            >>> import pynos.device\n            >>> switch = '10.24.39.202'\n            >>> auth = ('admin', 'password')\n            >>> conn = (switch, '22')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.interface.add_vlan_int('736')\n            ...     interfaces = dev.interface.vlans\n            ...     is_vlan_interface_present = False\n            ...     for interface in interfaces:\n            ...         if interface['vlan-id'] == '736':\n            ...             is_vlan_interface_present = True\n            ...             break\n            ...     dev.interface.del_vlan_int('736')\n            ...     assert is_vlan_interface_present\n            True\n        \"\"\"\n        urn = \"{urn:brocade.com:mgmt:brocade-interface-ext}\"\n\n        result = []\n        has_more = ''\n        last_vlan_id = ''\n        while (has_more == '') or (has_more == 'true'):\n            request_interface = self.get_vlan_brief_request(last_vlan_id)\n            interface_result = self._callback(request_interface, 'get')\n            has_more = self.get_node_value(interface_result, '%shas-more', urn)\n            last_vlan_id = self.get_node_value(\n                interface_result, '%slast-vlan-id', urn)\n            for interface in interface_result.findall('%svlan' % urn):\n                vlan_id = self.get_node_value(interface, '%svlan-id', urn)\n                vlan_type = self.get_node_value(interface, '%svlan-type', urn)\n                vlan_name = self.get_node_value(interface, '%svlan-name', urn)\n                vlan_state = self.get_node_value(\n                    interface, '%svlan-state', urn)\n                ports = []\n                for intf in interface.findall('%sinterface' % urn):\n                    interface_type = self.get_node_value(\n                        intf, '%sinterface-type', urn)\n                    interface_name = self.get_node_value(\n                        intf, '%sinterface-name', urn)\n                    tag = self.get_node_value(intf, '%stag', urn)\n                    port_results = {'interface-type': interface_type,\n                                    'interface-name': interface_name,\n                                    'tag': tag}\n                    ports.append(port_results)\n                results = {'interface-name': vlan_name,\n                           'vlan-state': vlan_state,\n                           'vlan-id': vlan_id,\n                           'vlan-type': vlan_type,\n                           'interface': ports}\n                result.append(results)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new Netconf request based on the last received vlan id", "response": "def get_vlan_brief_request(last_vlan_id):\n        \"\"\" Creates a new Netconf request based on the last received\n        vlan id when the hasMore flag is true\n        \"\"\"\n\n        request_interface = ET.Element(\n            'get-vlan-brief',\n            xmlns=\"urn:brocade.com:mgmt:brocade-interface-ext\"\n        )\n        if last_vlan_id != '':\n            last_received_int_el = ET.SubElement(request_interface,\n                                                 \"last-rcvd-vlan-id\")\n            last_received_int_el.text = last_vlan_id\n        return request_interface"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting of items of port channels.", "response": "def port_channels(self):\n        \"\"\"list[dict]: A list of dictionary items of port channels.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.202']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.interface.channel_group(name='226/0/1',\n            ...         int_type='tengigabitethernet',\n            ...         port_int='1', channel_type='standard', mode='active')\n            ...         result = dev.interface.port_channels\n            ...         is_port_channel_exist = False\n            ...         for port_chann in result:\n            ...             if port_chann['interface-name']=='port-channel-1':\n            ...                 for interfaces in port_chann['interfaces']:\n            ...                     for keys, values in interfaces.items():\n            ...                         if '226/0/1' in values:\n            ...                             is_port_channel_exist = True\n            ...                             break\n            ...         output = dev.interface.remove_port_channel(\n            ...         port_int='1')\n            ...         assert is_port_channel_exist\n        \"\"\"\n        pc_urn = \"{urn:brocade.com:mgmt:brocade-lag}\"\n        result = []\n        has_more = ''\n        last_aggregator_id = ''\n        while (has_more == '') or (has_more == 'true'):\n            request_port_channel = self.get_port_chann_detail_request(\n                last_aggregator_id)\n            port_channel_result = self._callback(request_port_channel, 'get')\n            has_more = self.get_node_value(port_channel_result,\n                                           '%shas-more', pc_urn)\n            if has_more == 'true':\n                for x in port_channel_result.findall('%slacp' % pc_urn):\n                    last_aggregator_id = self.get_node_value(x,\n                                                             '%saggregator-id',\n                                                             pc_urn)\n\n            for item in port_channel_result.findall('%slacp' % pc_urn):\n                interface_list = []\n                aggregator_id = self.get_node_value(\n                    item, '%saggregator-id', pc_urn)\n                aggregator_type = self.get_node_value(\n                    item, '%saggregator-type', pc_urn)\n                is_vlag = self.get_node_value(item, '%sisvlag', pc_urn)\n                aggregator_mode = self.get_node_value(\n                    item, '%saggregator-mode', pc_urn)\n                system_priority = self.get_node_value(\n                    item, '%ssystem-priority', pc_urn)\n                actor_system_id = self.get_node_value(\n                    item, '%sactor-system-id', pc_urn)\n                partner_oper_priority = self.get_node_value(\n                    item, '%spartner-oper-priority', pc_urn)\n                partner_system_id = self.get_node_value(\n                    item, '%spartner-system-id', pc_urn)\n                admin_key = self.get_node_value(\n                    item, '%sadmin-key', pc_urn)\n                oper_key = self.get_node_value(item, '%soper-key', pc_urn)\n                partner_oper_key = self.get_node_value(\n                    item, '%spartner-oper-key', pc_urn)\n                rx_link_count = self.get_node_value(\n                    item, '%srx-link-count', pc_urn)\n                tx_link_count = self.get_node_value(\n                    item, '%stx-link-count', pc_urn)\n                individual_agg = self.get_node_value(\n                    item, '%sindividual-agg', pc_urn)\n                ready_agg = self.get_node_value(\n                    item, '%sready-agg', pc_urn)\n                for item1 in item.findall('%saggr-member' % pc_urn):\n                    rbridge_id = self.get_node_value(\n                        item1, '%srbridge-id', pc_urn)\n                    int_type = self.get_node_value(\n                        item1, '%sinterface-type', pc_urn)\n                    int_name = self.get_node_value(\n                        item1, '%sinterface-name', pc_urn)\n                    actor_port = self.get_node_value(\n                        item1, '%sactor-port', pc_urn)\n                    sync = self.get_node_value(item1, '%ssync', pc_urn)\n                    port_channel_interface = {'rbridge-id': rbridge_id,\n                                              'interface-type': int_type,\n                                              'interface-name': int_name,\n                                              'actor_port': actor_port,\n                                              'sync': sync}\n                    interface_list.append(port_channel_interface)\n                results = {'interface-name': 'port-channel-' + aggregator_id,\n                           'interfaces': interface_list,\n                           'aggregator_id': aggregator_id,\n                           'aggregator_type': aggregator_type,\n                           'is_vlag': is_vlag,\n                           'aggregator_mode': aggregator_mode,\n                           'system_priority': system_priority,\n                           'actor_system_id': actor_system_id,\n                           'partner-oper-priority': partner_oper_priority,\n                           'partner-system-id': partner_system_id,\n                           'admin-key': admin_key,\n                           'oper-key': oper_key,\n                           'partner-oper-key': partner_oper_key,\n                           'rx-link-count': rx_link_count,\n                           'tx-link-count': tx_link_count,\n                           'individual-agg': individual_agg,\n                           'ready-agg': ready_agg}\n\n                result.append(results)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_port_chann_detail_request(last_aggregator_id):\n\n        port_channel_ns = 'urn:brocade.com:mgmt:brocade-lag'\n        request_port_channel = ET.Element('get-port-channel-detail',\n                                          xmlns=port_channel_ns)\n\n        if last_aggregator_id != '':\n            last_received_port_chann_el = ET.SubElement(request_port_channel,\n                                                        \"last-aggregator-id\")\n            last_received_port_chann_el.text = last_aggregator_id\n        return request_port_channel", "response": "Creates a new Netconf request based on the last received port - chann - detail aggregator id"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef vrrpe_spf_basic(self, **kwargs):\n\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name')\n        vrid = kwargs.pop('vrid')\n        enable = kwargs.pop('enable', True)\n        get = kwargs.pop('get', False)\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['gigabitethernet', 'tengigabitethernet',\n                           'fortygigabitethernet', 'hundredgigabitethernet',\n                           'port_channel', 've']\n        vrrpe_args = dict(name=name, vrid=vrid)\n        method_class = self._interface\n        if get:\n            enable = None\n        if int_type not in valid_int_types:\n            raise ValueError('`int_type` must be one of: %s' %\n                             repr(valid_int_types))\n        method_name = 'interface_%s_vrrpe_short_path_forwarding_basic' % \\\n                      int_type\n        if int_type == 've':\n            method_name = 'rbridge_id_%s' % method_name\n            method_class = self._rbridge\n            vrrpe_args['rbridge_id'] = rbridge_id\n            if not pynos.utilities.valid_vlan_id(name):\n                raise InvalidVlanId(\"`name` must be between `1` and `8191`\")\n        elif not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n        vrrpe_spf_basic = getattr(method_class, method_name)\n        config = vrrpe_spf_basic(**vrrpe_args)\n        if get:\n            return callback(config, handler='get_config')\n        if not enable:\n            config.find('.//*short-path-forwarding').set('operation', 'delete')\n        return callback(config)", "response": "Set vrrpe short path forwarding to default."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef vrrpe_vip(self, **kwargs):\n\n        int_type = kwargs.pop('int_type').lower()\n        name = kwargs.pop('name',)\n        vip = kwargs.pop('vip', '')\n        get = kwargs.pop('get', False)\n        delete = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['gigabitethernet', 'tengigabitethernet',\n                           'fortygigabitethernet', 'hundredgigabitethernet',\n                           'port_channel', 've']\n\n        if vip != '':\n            ipaddress = ip_interface(unicode(vip))\n            version = ipaddress.version\n        else:\n            version = 4\n\n        if int_type not in valid_int_types:\n            raise ValueError('`int_type` must be one of: %s' %\n                             repr(valid_int_types))\n        if delete:\n            vrid = kwargs.pop('vrid')\n            rbridge_id = kwargs.pop('rbridge_id', '1')\n            vrrpe_args = dict(rbridge_id=rbridge_id, name=name,\n                              vrid=vrid, virtual_ipaddr=vip)\n        elif get:\n            rbridge_id = kwargs.pop('rbridge_id', '1')\n            vrrpe_args = dict(name=name, vrid='', virtual_ipaddr='')\n        else:\n            vrid = kwargs.pop('vrid')\n            ipaddress = ip_interface(unicode(vip))\n            if int_type == 've':\n                rbridge_id = kwargs.pop('rbridge_id', '1')\n            vrrpe_args = dict(name=name, vrid=vrid,\n                              virtual_ipaddr=str(ipaddress.ip))\n        method_name = None\n        method_class = self._interface\n        if version == 4:\n            vrrpe_args['version'] = '3'\n            method_name = 'interface_%s_vrrpe_virtual_ip_virtual_' \\\n                          'ipaddr' % int_type\n        elif version == 6:\n            method_name = 'interface_%s_ipv6_vrrpv3e_group_virtual_ip_' \\\n                          'virtual_ipaddr' % int_type\n\n        if int_type == 've':\n            method_name = 'rbridge_id_%s' % method_name\n            if version == 6:\n                method_name = method_name.replace('group_', '')\n            method_class = self._rbridge\n            vrrpe_args['rbridge_id'] = rbridge_id\n            if not pynos.utilities.valid_vlan_id(name):\n                raise InvalidVlanId(\"`name` must be between `1` and `8191`\")\n        elif not pynos.utilities.valid_interface(int_type, name):\n            raise ValueError('`name` must be in the format of x/y/z for '\n                             'physical interfaces or x for port channel.')\n\n        vrrpe_vip = getattr(method_class, method_name)\n        config = vrrpe_vip(**vrrpe_args)\n        result = []\n\n        if delete:\n            config.find('.//*virtual-ip').set('operation', 'delete')\n        if get:\n            output = callback(config, handler='get_config')\n            for item in output.data.findall('.//{*}vrrpe'):\n                vrid = item.find('.//{*}vrid').text\n                if item.find('.//{*}virtual-ipaddr') is not None:\n                    vip = item.find('.//{*}virtual-ipaddr').text\n                else:\n                    vip = ''\n                tmp = {\"vrid\": vrid,\n                       \"vip\": vip}\n                result.append(tmp)\n        else:\n            result = callback(config)\n\n        return result", "response": "Set vrrpe VIP.\n\n        Args:\n            int_type (str): Type of interface. (gigabitethernet,\n                tengigabitethernet, ve, etc).\n            name (str): Name of interface. (1/0/5, 1/0/10, VE name etc).\n            vrid (str): vrrpev3 ID.\n            get (bool): Get config instead of editing config. (True, False)\n            delete (bool): True, the VIP address is added and False if its to\n                be deleted (True, False). Default value will be False if not\n                specified.\n            vip (str): IPv4/IPv6 Virtual IP Address.\n            rbridge_id (str): rbridge-id for device. Only required when type is\n                `ve`.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Raises:\n            KeyError: if `int_type`, `name`, `vrid`, or `vip` is not passed.\n            ValueError: if `int_type`, `name`, `vrid`, or `vip` is invalid.\n\n        Returns:\n            Return value of `callback`.\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output =dev.interface.vrrpe_vip(int_type='ve',\n            ...         name='89', rbridge_id = '1',\n            ...         vrid='11', vip='10.0.1.10')\n            ...         output = dev.interface.vrrpe_vip(get=True,\n            ...         int_type='ve', name='89', rbridge_id = '1')\n            ...         output =dev.interface.vrrpe_vip(delete=True,\n            ...         int_type='ve', name='89', rbridge_id = '1',vrid='1',\n            ...         vip='10.0.0.10')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the state of ve interfaces along with the ip address associations.", "response": "def ve_interfaces(self, **kwargs):\n        \"\"\"list[dict]: A list of dictionary items describing the operational\n        state of ve interfaces along with the ip address associations.\n\n        Args:\n            rbridge_id (str): rbridge-id for device.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            None\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.211', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.interface.ve_interfaces()\n            ...     output = dev.interface.ve_interfaces(rbridge_id='1')\n        \"\"\"\n\n        urn = \"{urn:brocade.com:mgmt:brocade-interface-ext}\"\n\n        rbridge_id = kwargs.pop('rbridge_id', None)\n        ip_result = []\n        request_interface = self._get_intf_rb_id(rbridge_id=rbridge_id)\n        interface_result = self._callback(request_interface, 'get')\n        for interface in interface_result.findall('%sinterface' % urn):\n            int_type = interface.find('%sinterface-type' % urn).text\n            int_name = interface.find('%sinterface-name' % urn).text\n            int_state = interface.find('%sif-state' % urn).text\n            int_proto_state = interface.find('%sline-protocol-state' %\n                                             urn).text\n            ip_address = interface.find('.//%sipv4' % urn).text\n            if_name = interface.find('%sif-name' % urn).text\n            results = {'interface-type': int_type,\n                       'interface-name': int_name,\n                       'if-name': if_name,\n                       'interface-state': int_state,\n                       'interface-proto-state': int_proto_state,\n                       'ip-address': ip_address}\n            ip_result.append(results)\n        return ip_result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new Netconf request based on the rbridge_id specifed", "response": "def _get_intf_rb_id(rbridge_id):\n        \"\"\" Creates a new Netconf request based on the rbridge_id specifed\n        \"\"\"\n\n        intf_rb_id = ET.Element(\n            'get-ip-interface',\n            xmlns=\"urn:brocade.com:mgmt:brocade-interface-ext\"\n        )\n        if rbridge_id is not None:\n            rbridge_el = ET.SubElement(intf_rb_id, \"rbridge-id\")\n            rbridge_el.text = rbridge_id\n\n        return intf_rb_id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef conversational_mac(self, **kwargs):\n\n        callback = kwargs.pop('callback', self._callback)\n        mac_learning = getattr(self._mac_address_table,\n                               'mac_address_table_learning_mode')\n\n        config = mac_learning(learning_mode='conversational')\n        if kwargs.pop('get', False):\n            output = callback(config, handler='get_config')\n            item = output.data.find('.//{*}learning-mode')\n            if item is not None:\n                return True\n        if kwargs.pop('delete', False):\n            config.find('.//*learning-mode').set('operation', 'delete')\n        return callback(config)", "response": "Enable conversational mac learning on vdx switches\n            is a bit more efficient."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconfigure Name of Overlay Gateway on vdx switches returning the name of the Overlay Gateway on vdx switches.", "response": "def overlay_gateway_name(self, **kwargs):\n        \"\"\"Configure Name of Overlay Gateway on vdx switches\n\n        Args:\n            gw_name: Name of Overlay Gateway\n            get (bool): Get config instead of editing config. (True, False)\n            delete (bool): True, delete the overlay gateway config.\n                           (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `gw_name` is not passed.\n            ValueError: if `gw_name` is invalid.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.211', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.interface.overlay_gateway_name(gw_name='Leaf')\n            ...     output = dev.interface.overlay_gateway_name(get=True)\n            ...     output = dev.interface.overlay_gateway_name(gw_name='Leaf',\n            ...              delete=True)\n        \"\"\"\n\n        callback = kwargs.pop('callback', self._callback)\n        get_config = kwargs.pop('get', False)\n        if not get_config:\n            gw_name = kwargs.pop('gw_name')\n            overlay_gw = getattr(self._tunnels, 'overlay_gateway_name')\n            config = overlay_gw(name=gw_name)\n\n        if get_config:\n            overlay_gw = getattr(self._tunnels, 'overlay_gateway_name')\n            config = overlay_gw(name='')\n            output = callback(config, handler='get_config')\n            if output.data.find('.//{*}name') is not None:\n                gwname = output.data.find('.//{*}name').text\n                return gwname\n            else:\n                return None\n\n        if kwargs.pop('delete', False):\n            config.find('.//overlay-gateway').set('operation', 'delete')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nactivate the Overlay Gateway Instance on VDX switches.", "response": "def overlay_gateway_activate(self, **kwargs):\n        \"\"\"Activates the Overlay Gateway Instance on VDX switches\n\n        Args:\n            gw_name: Name of Overlay Gateway\n            get (bool): Get config instead of editing config. (True, False)\n            delete (bool): True, delete the activate config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `gw_name` is not passed.\n            ValueError: if `gw_name` is invalid.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.211', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.interface.overlay_gateway_activate(\n            ...     gw_name='Leaf')\n            ...     output = dev.interface.overlay_gateway_activate(\n            ...     get=True)\n            ...     output = dev.interface.overlay_gateway_activate(\n            ...     gw_name='Leaf', delete=True)\n        \"\"\"\n\n        callback = kwargs.pop('callback', self._callback)\n        get_config = kwargs.pop('get', False)\n        if not get_config:\n            gw_name = kwargs.pop('gw_name')\n            overlay_gw = getattr(self._tunnels, 'overlay_gateway_activate')\n            config = overlay_gw(name=gw_name)\n\n        if get_config:\n            overlay_gw = getattr(self._tunnels, 'overlay_gateway_activate')\n            config = overlay_gw(name='')\n            output = callback(config, handler='get_config')\n            if output.data.find('.//{*}name') is not None:\n                if output.data.find('.//{*}activate') is not None:\n                    return True\n                else:\n                    return None\n            else:\n                return None\n\n        if kwargs.pop('delete', False):\n            config.find('.//activate').set('operation', 'delete')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef overlay_gateway_type(self, **kwargs):\n\n        callback = kwargs.pop('callback', self._callback)\n        get_config = kwargs.pop('get', False)\n        if not get_config:\n            gw_name = kwargs.pop('gw_name')\n            gw_type = kwargs.pop('gw_type')\n            gw_args = dict(name=gw_name, gw_type=gw_type)\n            overlay_gw = getattr(self._tunnels, 'overlay_gateway_gw_type')\n            config = overlay_gw(**gw_args)\n\n        if get_config:\n            overlay_gw = getattr(self._tunnels, 'overlay_gateway_gw_type')\n            config = overlay_gw(name='', gw_type='')\n            output = callback(config, handler='get_config')\n            if output.data.find('.//{*}name') is not None:\n                gwtype = output.data.find('.//{*}gw-type').text\n                return gwtype\n            else:\n                return None\n\n        return callback(config)", "response": "Configure Overlay Gateway Type on vdx switches"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef overlay_gateway_loopback_id(self, **kwargs):\n\n        callback = kwargs.pop('callback', self._callback)\n        get_config = kwargs.pop('get', False)\n        if not get_config:\n            gw_name = kwargs.pop('gw_name')\n            loopback_id = kwargs.pop('loopback_id')\n            gw_args = dict(name=gw_name, loopback_id=loopback_id)\n            overlay_gw = getattr(self._tunnels, 'overlay_gateway_ip_'\n                                 'interface_loopback_loopback_id')\n            config = overlay_gw(**gw_args)\n\n        if get_config:\n            overlay_gw = getattr(self._tunnels, 'overlay_gateway_ip_'\n                                 'interface_loopback_loopback_id')\n            config = overlay_gw(name='', loopback_id='')\n            output = callback(config, handler='get_config')\n            if output.data.find('.//{*}name') is not None:\n                if output.data.find('.//{*}loopback-id') is not None:\n                    ip_intf = output.data.find('.//{*}loopback-id').text\n                    return ip_intf\n                else:\n                    return None\n            else:\n                return None\n\n        if kwargs.pop('delete', False):\n            config.find('.//loopback-id').set('operation', 'delete')\n\n        return callback(config)", "response": "Configure Overlay Gateway loopback interface."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconfigure Overlay Gateway attach rbridge id.", "response": "def overlay_gateway_attach_rbridge_id(self, **kwargs):\n        \"\"\"Configure Overlay Gateway attach rbridge id\n\n        Args:\n            gw_name: Name of Overlay Gateway  <WORD:1-32>\n            rbridge_id:  Single or range of rbridge id to be added/removed\n            get (bool): Get config instead of editing config. (True, False)\n            delete (bool): True, delete the attached rbridge list\n                           (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `gw_name`, 'rbridge_id' is not passed.\n            ValueError: if `gw_name`, 'rbridge_id' is invalid.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.211', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.interface.overlay_gateway_attach_rbridge_id(\n            ...     gw_name='Leaf', rbridge_id='10')\n            ...     output = dev.interface.overlay_gateway_attach_rbridge_id(\n            ...     get=True)\n            ...     output = dev.interface.overlay_gateway_attach_rbridge_id(\n            ...     gw_name='Leaf', rbridge_id='1-2', delete=True)\n        \"\"\"\n\n        callback = kwargs.pop('callback', self._callback)\n        get_config = kwargs.pop('get', False)\n        delete = kwargs.pop('delete', False)\n        if not get_config:\n            gw_name = kwargs.pop('gw_name')\n            rbridge_id = kwargs.pop('rbridge_id')\n            if delete is True:\n                gw_args = dict(name=gw_name, rb_remove=rbridge_id)\n                overlay_gw = getattr(self._tunnels, 'overlay_gateway_'\n                                     'attach_rbridge_id_rb_remove')\n                config = overlay_gw(**gw_args)\n            else:\n                gw_args = dict(name=gw_name, rb_add=rbridge_id)\n                overlay_gw = getattr(self._tunnels, 'overlay_gateway_'\n                                     'attach_rbridge_id_rb_add')\n                config = overlay_gw(**gw_args)\n\n        if get_config:\n            overlay_gw = getattr(self._tunnels, 'overlay_gateway_'\n                                 'attach_rbridge_id_rb_add')\n            config = overlay_gw(name='', rb_add='')\n            output = callback(config, handler='get_config')\n            if output.data.find('.//{*}name') is not None:\n                if output.data.find('.//{*}attach') is not None:\n                    output.data.find('.//{*}name').text\n                    rb_id = output.data.find('.//{*}rb-add').text\n                    return rb_id\n                else:\n                    return None\n            else:\n                return None\n\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ipv6_link_local(self, **kwargs):\n\n        int_type = kwargs.pop('int_type').lower()\n        ve_name = kwargs.pop('name')\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        valid_int_types = ['loopback', 've']\n        if int_type not in valid_int_types:\n            raise ValueError('`int_type` must be one of: %s' %\n                             repr(valid_int_types))\n        link_args = dict(name=ve_name, rbridge_id=rbridge_id,\n                         int_type=int_type)\n        method_name = 'rbridge_id_interface_%s_ipv6_ipv6_config_address_' \\\n                      'use_link_local_only' % int_type\n        method_class = self._rbridge\n        v6_link_local = getattr(method_class, method_name)\n        config = v6_link_local(**link_args)\n\n        if kwargs.pop('get', False):\n            output = callback(config, handler='get_config')\n            item = output.data.find('.//{*}use-link-local-only')\n            if item is not None:\n                return True\n        if kwargs.pop('delete', False):\n            config.find('.//*use-link-local-only').set('operation', 'delete')\n        return callback(config)", "response": "Configure ipv6 link local address on interfaces on vdx switches."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_ve(self, **kwargs):\n\n        ve_name = kwargs.pop('ve_name', '')\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        enable = kwargs.pop('enable', True)\n        get = kwargs.pop('get', False)\n        callback = kwargs.pop('callback', self._callback)\n        ve_args = dict(name=ve_name, rbridge_id=rbridge_id)\n        if get:\n            enable = None\n        method_class = self._rbridge\n        method_name = 'rbridge_id_interface_ve_name'\n        create_ve = getattr(method_class, method_name)\n        config = create_ve(**ve_args)\n        if get:\n            return callback(config, handler='get_config')\n        if not enable:\n            config.find('.//*ve').set('operation', 'delete')\n        return callback(config)", "response": "Function to add a new Ve interface to the BGP hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nactivates the Automatic Migration of Port Profiles on a port.", "response": "def port_profile_port(self,inter_type, inter,enable=True):\n        \"\"\"\n        Activates the Automatic Migration of Port Profiles (AMPP) port-profile configuration mode on a port.\n        Args:\n          inter_type: The type of interface you want to configure. Ex.\n                tengigabitethernet, gigabitethernet, fortygigabitethernet.\n          inter: The ID for the interface you want to configure. Ex. 1/0/1\n          enable: (bool) Enables port_profile mdode by default. If set to False\n                    disables the port-profile mode.\n        Returns:\n            True if command completes successfully or False if not.\n\n        Raises:\n            None\n        \"\"\"\n\n        config = ET.Element(\"config\")\n        interface = ET.SubElement(config, \"interface\", xmlns=\"urn:brocade.com:mgmt:brocade-interface\")\n        tengigabitethernet = ET.SubElement(interface, inter_type)\n        name_key = ET.SubElement(tengigabitethernet, \"name\")\n        name_key.text = inter\n\n        if enable:\n            port_profile_port = ET.SubElement(tengigabitethernet, \"port-profile-port\",\n                                              xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        else:\n            port_profile_port = ET.SubElement(tengigabitethernet, \"port-profile-port\",\n                                              xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\",\n                                              operation='delete')\n        try:\n            if enable:\n                self._callback(config)\n                return True\n            else:\n                self._callback(config)\n                return True\n        except Exception as e:\n            logging.error(e)\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mld_snooping_ipv6_pim_snooping_pimv6_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        mld_snooping = ET.SubElement(config, \"mld-snooping\", xmlns=\"urn:brocade.com:mgmt:brocade-mld-snooping\")\n        ipv6 = ET.SubElement(mld_snooping, \"ipv6\")\n        pim = ET.SubElement(ipv6, \"pim\")\n        snooping = ET.SubElement(pim, \"snooping\")\n        pimv6_enable = ET.SubElement(snooping, \"pimv6-enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable IPv6 PIM snooping on the master log."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mld_snooping_ipv6_mld_snooping_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        mld_snooping = ET.SubElement(config, \"mld-snooping\", xmlns=\"urn:brocade.com:mgmt:brocade-mld-snooping\")\n        ipv6 = ET.SubElement(mld_snooping, \"ipv6\")\n        mld = ET.SubElement(ipv6, \"mld\")\n        snooping = ET.SubElement(mld, \"snooping\")\n        enable = ET.SubElement(snooping, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable or disable MLD snooping for a specific IP6"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def post_list(cls, sender, db, instances):\n        '''\n        Hook to capture the results of a list query.\n        Useful when wanting to know when certain documents have come up in a query.\n        Implement in resource subclasses to provide domain-specific behavior\n        '''\n        serialized_objects = await asyncio.gather(*[obj.serialize() for obj in instances])\n        await cls.emit(db, 'resource_get_list', serialized_objects)", "response": "Hook to capture the results of a list query."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncorresponding to GET request without a resource identifier fetching documents from the database", "response": "async def list(self, *args, **kwargs):\n        '''\n        Corresponds to GET request without a resource identifier, fetching documents from the database\n        '''\n        limit = int(kwargs.pop('limit', self.limit))\n        limit = 1000 if limit == 0 else limit  # lets not go crazy here\n        offset = int(kwargs.pop('offset', self.offset))\n        projection = None\n        # perform full text search or standard filtering\n        if self._meta.fts_operator in kwargs.keys():\n            filters = {\n                '$text': {'$search': kwargs[self._meta.fts_operator]}\n            }\n            projection = {'score': {'$meta': 'textScore'}}\n            sort = [('score', {'$meta': 'textScore'}, )]\n        else:\n            # build filters from query parameters\n            filters = self.build_filters(**kwargs)\n            # add custom query defined in resource meta, if exists\n            if isinstance(self._meta.query, dict):\n                filters.update(self._meta.query)\n            # build sorts from query parameters\n            sort = self.build_sort(**kwargs)\n            if isinstance(self._meta.sort, list):\n                sort.extend(self._meta.sort)\n        cursor = self._meta.object_class.get_cursor(db=self.db, query=filters, projection=projection, sort=sort)\n        cursor.skip(offset)\n        cursor.limit(limit)\n        total_count = await self._meta.object_class.count(db=self.db, filters=filters)\n        object_list = await self._meta.object_class.find(cursor)\n        # serialize results\n        serialized_objects = await asyncio.gather(*[obj.serialize() for obj in object_list])\n        # signal post list\n        asyncio.ensure_future(resource_post_list.send(\n            sender=self._meta.object_class,\n            db=self.db,\n            instances=object_list)\n        )\n        return {\n            'meta': {\n                'total_count': total_count,\n                'limit': limit,\n                'offset': offset\n            },\n            'objects': serialized_objects\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def detail(self, **kwargs):\n        '''\n        Corresponds to GET request with a resource unique identifier, fetching a single document from the database\n        '''\n        try:\n            pk = self.pk_type(kwargs.get('pk'))\n            obj = await self._meta.object_class.find_one(self.db, {self.pk: pk})\n            if obj:\n                return await obj.serialize()\n            raise NotFound('Object matching the given {} with value {} was not found'.format(self.pk, str(pk)))\n        except InvalidId:\n            raise NotFound('Invalid ID')", "response": "Corresponds to GET request with a resource unique identifier fetching a single document from the database"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def create(self, **kwargs):\n        '''\n        Corresponds to POST request without a resource identifier, inserting a document into the database\n        '''\n        try:\n            # create model\n            obj = self._meta.object_class()\n            # deserialize data from request body\n            self.data.update(kwargs)\n            await obj.deserialize(self.data)\n            # create document in DB\n            await obj.insert(db=self.db)\n            # serialize object for response\n            return await obj.serialize()\n        except Exception as ex:\n            logger.exception(ex)\n            raise BadRequest(ex)", "response": "Corresponds to POST request without a resource identifier inserting a document into the database returning the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def modify(self, **kwargs):\n        '''\n        Corresponds to PATCH request with a resource identifier, modifying a single document in the database\n        '''\n        try:\n            pk = self.pk_type(kwargs['pk'])\n            # modify is a class method on MongoCollectionMixin\n            result = await self._meta.object_class.modify(self.db, key=pk, data=self.data)\n            if result is None:\n                raise NotFound('Object matching the given {} was not found'.format(self.pk))\n            return await result.serialize()\n        except Exception as ex:\n            logger.exception(ex)\n            raise BadRequest(ex)", "response": "Corresponds to PATCH request with a resource identifier modifying a single document in the database"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncorresponding to PUT request with a resource identifier updating a single document in the database", "response": "async def update(self, **kwargs):\n        '''\n        Corresponds to PUT request with a resource identifier, updating a single document in the database\n        '''\n        try:\n            self.data[self.pk] = self.pk_type(kwargs['pk'])\n            updated_obj = await self._meta.object_class().update(self.db, data=self.data)\n            if updated_obj is None:\n                raise NotFound('Object matching the given {} was not found'.format(self.pk))\n            return await updated_obj.serialize()\n        except Exception as ex:\n            logger.exception(ex)\n            raise BadRequest(ex)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def delete(self, *args, **kwargs):\n        '''\n        Corresponds to DELETE request with a resource identifier, deleting a single document from the database\n        '''\n        pk = self.pk_type(kwargs['pk'])\n        result = await self._meta.object_class.delete_entries(db=self.db, query={self.pk: pk})\n        if result.acknowledged:\n            if result.deleted_count == 0:\n                raise NotFound()\n        else:\n            raise BadRequest('Failed to delete object')", "response": "Corresponds to DELETE request with a resource identifier deleting a single document from the database"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbreak url parameters and turn into filters", "response": "def build_filters(self, **kwargs):\n        ''' Break url parameters and turn into filters '''\n        filters = {}\n        for param, value in kwargs.items():\n            # break each url parameter to key + operator (if exists)\n            pl = dict(enumerate(param.split('__')))\n            key = pl[0]\n            operator = pl.get(1, None)\n            if key in self._meta.object_class.fields():\n                field = self._meta.object_class._fields[key]\n                if field.is_composite: # composite keys require additional handling\n                    # currently covering cases for dbref and list\n                    if isinstance(field, DBRefField):\n                        key, value = self.process_dbref_filter(key, value)\n                    elif isinstance(value, list) and operator == 'in':\n                        value = [convert_value(v) for v in value]\n                else:\n                    value = convert_value(value)\n                # assign operator, if applicable\n                filters[key] = {'${}'.format(operator): value} if operator else value\n            elif key == 'created':  # special case where we map `created` key to mongo's _id which also contains a creation timestamp\n                dt = parser.parse(convert_value(value))\n                dummy_id = ObjectId.from_datetime(dt)\n                filters['_id'] = {'${}'.format(operator): dummy_id} if operator else dummy_id\n        return filters"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_sort(self, **kwargs):\n        ''' Break url parameters and turn into sort arguments '''\n        sort = []\n        order = kwargs.get('order_by', None)\n        if order:\n            if type(order) is list:\n                order = order[0]\n            if order[:1] == '-':\n                sort.append((order[1:], -1))\n            else:\n                sort.append((order, 1))\n        return sort", "response": "Break url parameters and turn into sort arguments"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def serialize(self, native=False):\n        '''\n        Returns a serialized from of the model taking into account projection rules and ``@serialize`` decorated methods.\n        \n        :param native:\n            Deternines if data is serialized to Python native types or primitive form. Defaults to ``False``\n        '''\n        data = {}\n        # iterate through all fields\n        for field_name, field in self._fields.items():\n            # serialize field data\n            raw_data = self._data.get(field_name)\n            # add field's data to model data based on projection settings\n            if field._projection != None:  # noqa E711\n                field_data = await field.serialize(raw_data, native)\n                if field_data:\n                    data[field_name] = field_data\n                elif field._projection == True: # noqa E711\n                    data[field_name] = None\n\n        # iterate through all export methods\n        for name, func in self._serialize_methods.items():\n            data[name] = await func(self)\n        return data", "response": "Returns a serialized from of the model taking into account projection rules and decorated methods."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def deserialize(self, data: dict, silent=True):\n        '''\n        Deserializes a Python ``dict`` into the model by assigning values to their respective fields.\n        Ignores data attributes that do not match one of the Model's fields.\n        Ignores data attributes who's matching fields are declared with the ``readonly`` attribute\n        Validates the data after import.\n        Override in sub classes to modify or add to deserialization behavior\n\n        :param data:\n            Python dictionary with data\n        :type data:\n            ``dict``\n        :param silent:\n            Determines if an exception is thrown if illegal fields are passed. Such fields can be non existent or readonly. Default is True\n        :type silent:\n            ``bool``\n        '''\n        self.import_data(self. _deserialize(data))\n        self.validate()", "response": "Deserializes a Python dict into the model by assigning values to their respective fields."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _deserialize(self, data: dict, silent=True) -> dict:\n        ''' Internal deserialize method for sifting out unacceptable data for the model '''\n        deserialized_data = {}\n        for name, field in self._fields.items():\n            if field._readonly is False and name in data:\n                deserialized_data[name] = data.get(name)\n        return deserialized_data", "response": "Internal deserialize method for sifting out unacceptable data for the model"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef import_data(self, data: dict):\n        '''\n        Imports data into model and converts to python form.\n        Model fields and container of model fields retain their model class structure.\n        Merges with existing if data is partial\n        '''\n        if not isinstance(data, dict):\n            raise ValueError('Cannot import data not as dict')\n        self._data.update(data)\n\n        for name, field in self._fields.items():\n            self._data[name] = field._import(self._data.get(name)) or field.default", "response": "Imports data into model and converts to python form."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(create_app, config, description=None, args=None, namespace=None, options=None):\n    import argparse\n\n    class HelpFormatter(\n        # argparse.RawTextHelpFormatter,\n        argparse.RawDescriptionHelpFormatter,\n        # argparse.ArgumentDefaultsHelpFormatter,\n        # argparse.HelpFormatter,\n        ):\n        pass\n\n    # Get configurations data if\n    envName = getattr(config, 'ENV', None)\n    envMap = getattr(config, 'envMap', None)\n    envHelp = getattr(config, 'envHelp', {})\n    envSelectVar = getattr(config, 'envSelectVar', None)\n    configurations = getattr(config, 'configurations', None)\n    envSelectable = callable(getattr(config, 'select', None))\n    envPrintable = config.__str__ is not object.__str__\n\n    parser = argparse.ArgumentParser(\n        description = description or getattr(config, 'description',\n            'runs Flask-based web application using Python WSGI reference server'),\n        epilog = ''.join((\n            '\\n\\noptional environment variables:\\n{}'.format(\n                '\\n'.join(sorted('  {:<20}  {}'.format(envMap[key], envHelp.get(key, ''))\n                for key in envMap))) if envMap else '',\n            '\\n\\navailable environment configurations (*: active):\\n{}'.format(\n                '\\n'.join('{} {}'.format(\n                    '*' if envName in c.names else ' ',\n                    ' | '.join(c.names)\n                ) for c in configurations)) if configurations else '',\n        )),\n        formatter_class = HelpFormatter)\n\n    parser.add_argument('-b', '--bind', metavar='[HOST|:PORT]', default='127.0.0.1:5000',\n        help = 'bind to HOST:PORT (default: 127.0.0.1:5000)')\n\n    debug = config.DEBUG\n    debugMsg = ' (default in {})'.format(config.ENV)\n    debugTrueMsg = debugMsg if debug else ''\n    debugFalseMsg = debugMsg if not debug else ''\n\n    parser.add_argument('-r', '--reload', action='store_true', default=debug,\n        help = 'reload server on code change' + debugTrueMsg)\n    parser.add_argument('-R', '--no-reload', action='store_false', dest='reload',\n        help = 'do not reload server on code change' + debugFalseMsg)\n\n    parser.add_argument('-d', '--debug', action='store_true', default=debug,\n        help = 'show debugger on exception' + debugTrueMsg)\n    parser.add_argument('-D', '--no-debug', action='store_false', dest='debug',\n        help = 'do not show debugger on exception' + debugFalseMsg)\n\n    if envSelectable:\n        parser.add_argument('-e', '--env', default=config.ENV,\n            help = 'select environment config (default: {})'.format(config.ENV))\n\n    if envPrintable:\n        if envSelectable:\n            parser.add_argument('-E', '--show-env', nargs='?', const=True,\n                help = 'show environment config and exit ({}default: {})'\n                    .format('*: all, ' if configurations else '', config.ENV))\n        else:\n            parser.add_argument('-E', '--show-env', action='store_true',\n                help = 'show environment config and exit')\n\n    parser.add_argument('-g', '--gen-key', action='store_true',\n        help = 'generate a good secret key and exit')\n\n\n    args = parser.parse_args(args, namespace)\n\n    if args.gen_key:\n        # See http://flask.pocoo.org/docs/0.10/quickstart/#sessions\n        import os\n        key = os.urandom(24)\n        return print(key)\n        # return print('{0}\\n{0!r}'.format(key))\n\n    if envSelectable and args.env:\n        config = config.select(args.env)\n\n    if envPrintable and args.show_env:\n        if configurations and args.show_env == '*':\n            print('\\n\\n'.join('# {}\\n{}'.format(' | '.join(c.names), c) for c in configurations))\n        elif args.show_env is True:\n            print(config)\n        else:\n            print(config.select(args.show_env))\n\n        return\n\n    host, port = (args.bind + ':').split(':')[:2]\n    host = host or '127.0.0.1'\n    port = int(port) if port else 5000\n\n    return create_app(config).run(host, port, args.debug, use_reloader=args.reload, **(options or {}))", "response": "Parses commandline options updates config creates and runs the application using Python WSGI reference server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef police_priority_map_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name = ET.SubElement(police_priority_map, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the police - priority map."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef police_priority_map_conform_map_pri0_conform(self, **kwargs):\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        conform = ET.SubElement(police_priority_map, \"conform\")\n        map_pri0_conform = ET.SubElement(conform, \"map-pri0-conform\")\n        map_pri0_conform.text = kwargs.pop('map_pri0_conform')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a police - priority map that conforms to a priority map pri0."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the configuration of a police - priority map conforming map pri1 conform", "response": "def police_priority_map_conform_map_pri1_conform(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        conform = ET.SubElement(police_priority_map, \"conform\")\n        map_pri1_conform = ET.SubElement(conform, \"map-pri1-conform\")\n        map_pri1_conform.text = kwargs.pop('map_pri1_conform')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef police_priority_map_conform_map_pri2_conform(self, **kwargs):\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        conform = ET.SubElement(police_priority_map, \"conform\")\n        map_pri2_conform = ET.SubElement(conform, \"map-pri2-conform\")\n        map_pri2_conform.text = kwargs.pop('map_pri2_conform')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a police - priority map conforming map pri2 conform"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the configuration of a police - priority map conforming map pri3 conform", "response": "def police_priority_map_conform_map_pri3_conform(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        conform = ET.SubElement(police_priority_map, \"conform\")\n        map_pri3_conform = ET.SubElement(conform, \"map-pri3-conform\")\n        map_pri3_conform.text = kwargs.pop('map_pri3_conform')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the configuration of a police - priority map conforming map pri4 conform", "response": "def police_priority_map_conform_map_pri4_conform(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        conform = ET.SubElement(police_priority_map, \"conform\")\n        map_pri4_conform = ET.SubElement(conform, \"map-pri4-conform\")\n        map_pri4_conform.text = kwargs.pop('map_pri4_conform')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef police_priority_map_conform_map_pri5_conform(self, **kwargs):\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        conform = ET.SubElement(police_priority_map, \"conform\")\n        map_pri5_conform = ET.SubElement(conform, \"map-pri5-conform\")\n        map_pri5_conform.text = kwargs.pop('map_pri5_conform')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a police - priority map conforming map pri5 conform"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef police_priority_map_conform_map_pri6_conform(self, **kwargs):\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        conform = ET.SubElement(police_priority_map, \"conform\")\n        map_pri6_conform = ET.SubElement(conform, \"map-pri6-conform\")\n        map_pri6_conform.text = kwargs.pop('map_pri6_conform')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a police - priority map conform map pri6 conform"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the configuration of a police - priority map conforming map pri7 conform", "response": "def police_priority_map_conform_map_pri7_conform(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        conform = ET.SubElement(police_priority_map, \"conform\")\n        map_pri7_conform = ET.SubElement(conform, \"map-pri7-conform\")\n        map_pri7_conform.text = kwargs.pop('map_pri7_conform')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the config element for the police - priority map exceed map pri0 - exceed", "response": "def police_priority_map_exceed_map_pri0_exceed(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        exceed = ET.SubElement(police_priority_map, \"exceed\")\n        map_pri0_exceed = ET.SubElement(exceed, \"map-pri0-exceed\")\n        map_pri0_exceed.text = kwargs.pop('map_pri0_exceed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef police_priority_map_exceed_map_pri1_exceed(self, **kwargs):\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        exceed = ET.SubElement(police_priority_map, \"exceed\")\n        map_pri1_exceed = ET.SubElement(exceed, \"map-pri1-exceed\")\n        map_pri1_exceed.text = kwargs.pop('map_pri1_exceed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config element for the police - priority map exceed map pri1 - exceed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef police_priority_map_exceed_map_pri2_exceed(self, **kwargs):\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        exceed = ET.SubElement(police_priority_map, \"exceed\")\n        map_pri2_exceed = ET.SubElement(exceed, \"map-pri2-exceed\")\n        map_pri2_exceed.text = kwargs.pop('map_pri2_exceed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config element for the police - priority map exceed map pri2 exceed"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the configuration of a police - priority map exceed map pri3 exceed.", "response": "def police_priority_map_exceed_map_pri3_exceed(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        exceed = ET.SubElement(police_priority_map, \"exceed\")\n        map_pri3_exceed = ET.SubElement(exceed, \"map-pri3-exceed\")\n        map_pri3_exceed.text = kwargs.pop('map_pri3_exceed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef police_priority_map_exceed_map_pri4_exceed(self, **kwargs):\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        exceed = ET.SubElement(police_priority_map, \"exceed\")\n        map_pri4_exceed = ET.SubElement(exceed, \"map-pri4-exceed\")\n        map_pri4_exceed.text = kwargs.pop('map_pri4_exceed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config element for the police - priority map exceed map pri4 exceed"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef police_priority_map_exceed_map_pri5_exceed(self, **kwargs):\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        exceed = ET.SubElement(police_priority_map, \"exceed\")\n        map_pri5_exceed = ET.SubElement(exceed, \"map-pri5-exceed\")\n        map_pri5_exceed.text = kwargs.pop('map_pri5_exceed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config element for the police - priority - map exceed map pri5 - exceed"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the config element for the police - priority - map exceed map pri6 - exceed", "response": "def police_priority_map_exceed_map_pri6_exceed(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        exceed = ET.SubElement(police_priority_map, \"exceed\")\n        map_pri6_exceed = ET.SubElement(exceed, \"map-pri6-exceed\")\n        map_pri6_exceed.text = kwargs.pop('map_pri6_exceed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef police_priority_map_exceed_map_pri7_exceed(self, **kwargs):\n        config = ET.Element(\"config\")\n        police_priority_map = ET.SubElement(config, \"police-priority-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(police_priority_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        exceed = ET.SubElement(police_priority_map, \"exceed\")\n        map_pri7_exceed = ET.SubElement(exceed, \"map-pri7-exceed\")\n        map_pri7_exceed.text = kwargs.pop('map_pri7_exceed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a police - priority map exceed map pri7 - exceed"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef class_map_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        class_map = ET.SubElement(config, \"class-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name = ET.SubElement(class_map, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the class map"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a new class map match access group and access group name", "response": "def class_map_match_access_group_access_group_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        class_map = ET.SubElement(config, \"class-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        name_key = ET.SubElement(class_map, \"name\")\n        name_key.text = kwargs.pop('name')\n        match = ET.SubElement(class_map, \"match\")\n        access_group = ET.SubElement(match, \"access-group\")\n        access_group_name = ET.SubElement(access_group, \"access-group-name\")\n        access_group_name.text = kwargs.pop('access_group_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the name of the PO.", "response": "def policy_map_po_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        policy_map = ET.SubElement(config, \"policy-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        po_name = ET.SubElement(policy_map, \"po-name\")\n        po_name.text = kwargs.pop('po_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef policy_map_clss_cl_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        policy_map = ET.SubElement(config, \"policy-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        po_name_key = ET.SubElement(policy_map, \"po-name\")\n        po_name_key.text = kwargs.pop('po_name')\n        clss = ET.SubElement(policy_map, \"class\")\n        cl_name = ET.SubElement(clss, \"cl-name\")\n        cl_name.text = kwargs.pop('cl_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current NIC policy map class and cl_name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the info of a specific resource from the policy map class set and DSCP", "response": "def policy_map_clss_set_set_dscp_dscp(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        policy_map = ET.SubElement(config, \"policy-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        po_name_key = ET.SubElement(policy_map, \"po-name\")\n        po_name_key.text = kwargs.pop('po_name')\n        clss = ET.SubElement(policy_map, \"class\")\n        cl_name_key = ET.SubElement(clss, \"cl-name\")\n        cl_name_key.text = kwargs.pop('cl_name')\n        set = ET.SubElement(clss, \"set\")\n        set_dscp = ET.SubElement(set, \"set_dscp\")\n        dscp = ET.SubElement(set_dscp, \"dscp\")\n        dscp.text = kwargs.pop('dscp')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the info of a specific resource from the policy map class span and session", "response": "def policy_map_clss_span_session(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        policy_map = ET.SubElement(config, \"policy-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        po_name_key = ET.SubElement(policy_map, \"po-name\")\n        po_name_key.text = kwargs.pop('po_name')\n        clss = ET.SubElement(policy_map, \"class\")\n        cl_name_key = ET.SubElement(clss, \"cl-name\")\n        cl_name_key.text = kwargs.pop('cl_name')\n        span = ET.SubElement(clss, \"span\")\n        session = ET.SubElement(span, \"session\")\n        session.text = kwargs.pop('session')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef policy_map_clss_map_dscp_mutation(self, **kwargs):\n        config = ET.Element(\"config\")\n        policy_map = ET.SubElement(config, \"policy-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        po_name_key = ET.SubElement(policy_map, \"po-name\")\n        po_name_key.text = kwargs.pop('po_name')\n        clss = ET.SubElement(policy_map, \"class\")\n        cl_name_key = ET.SubElement(clss, \"cl-name\")\n        cl_name_key.text = kwargs.pop('cl_name')\n        map = ET.SubElement(clss, \"map\")\n        dscp_mutation = ET.SubElement(map, \"dscp-mutation\")\n        dscp_mutation.text = kwargs.pop('dscp_mutation')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the info of a specific resource from a policy map class map and dscp mutation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the config of a resource map", "response": "def policy_map_clss_shape_shaping_rate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        policy_map = ET.SubElement(config, \"policy-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        po_name_key = ET.SubElement(policy_map, \"po-name\")\n        po_name_key.text = kwargs.pop('po_name')\n        clss = ET.SubElement(policy_map, \"class\")\n        cl_name_key = ET.SubElement(clss, \"cl-name\")\n        cl_name_key.text = kwargs.pop('cl_name')\n        shape = ET.SubElement(clss, \"shape\")\n        shaping_rate = ET.SubElement(shape, \"shaping_rate\")\n        shaping_rate.text = kwargs.pop('shaping_rate')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the current state of the hierarchy from the priority mapping table and import.", "response": "def policy_map_clss_priority_mapping_table_imprt_cee(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        policy_map = ET.SubElement(config, \"policy-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        po_name_key = ET.SubElement(policy_map, \"po-name\")\n        po_name_key.text = kwargs.pop('po_name')\n        clss = ET.SubElement(policy_map, \"class\")\n        cl_name_key = ET.SubElement(clss, \"cl-name\")\n        cl_name_key.text = kwargs.pop('cl_name')\n        priority_mapping_table = ET.SubElement(clss, \"priority-mapping-table\")\n        imprt = ET.SubElement(priority_mapping_table, \"import\")\n        cee = ET.SubElement(imprt, \"cee\")\n        cee.text = kwargs.pop('cee')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef system_qos_qos_service_policy_direction(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_qos = ET.SubElement(config, \"system-qos\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        qos = ET.SubElement(system_qos, \"qos\")\n        service_policy = ET.SubElement(qos, \"service-policy\")\n        policy_map_name_key = ET.SubElement(service_policy, \"policy-map-name\")\n        policy_map_name_key.text = kwargs.pop('policy_map_name')\n        direction = ET.SubElement(service_policy, \"direction\")\n        direction.text = kwargs.pop('direction')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a system QoS service policy direction"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a new system QoS service policy map name.", "response": "def system_qos_qos_service_policy_policy_map_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_qos = ET.SubElement(config, \"system-qos\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        qos = ET.SubElement(system_qos, \"qos\")\n        service_policy = ET.SubElement(qos, \"service-policy\")\n        direction_key = ET.SubElement(service_policy, \"direction\")\n        direction_key.text = kwargs.pop('direction')\n        policy_map_name = ET.SubElement(service_policy, \"policy-map-name\")\n        policy_map_name.text = kwargs.pop('policy_map_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef system_qos_qos_service_policy_attach_rbridge_id_add_rb_add_range(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_qos = ET.SubElement(config, \"system-qos\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        qos = ET.SubElement(system_qos, \"qos\")\n        service_policy = ET.SubElement(qos, \"service-policy\")\n        direction_key = ET.SubElement(service_policy, \"direction\")\n        direction_key.text = kwargs.pop('direction')\n        policy_map_name_key = ET.SubElement(service_policy, \"policy-map-name\")\n        policy_map_name_key.text = kwargs.pop('policy_map_name')\n        attach = ET.SubElement(service_policy, \"attach\")\n        rbridge_id = ET.SubElement(attach, \"rbridge-id\")\n        add = ET.SubElement(rbridge_id, \"add\")\n        rb_add_range = ET.SubElement(add, \"rb-add-range\")\n        rb_add_range.text = kwargs.pop('rb_add_range')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new system QoS service policy attach rbridge - id and rb - add - range."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef system_qos_qos_service_policy_attach_rbridge_id_remove_rb_remove_range(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_qos = ET.SubElement(config, \"system-qos\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        qos = ET.SubElement(system_qos, \"qos\")\n        service_policy = ET.SubElement(qos, \"service-policy\")\n        direction_key = ET.SubElement(service_policy, \"direction\")\n        direction_key.text = kwargs.pop('direction')\n        policy_map_name_key = ET.SubElement(service_policy, \"policy-map-name\")\n        policy_map_name_key.text = kwargs.pop('policy_map_name')\n        attach = ET.SubElement(service_policy, \"attach\")\n        rbridge_id = ET.SubElement(attach, \"rbridge-id\")\n        remove = ET.SubElement(rbridge_id, \"remove\")\n        rb_remove_range = ET.SubElement(remove, \"rb-remove-range\")\n        rb_remove_range.text = kwargs.pop('rb_remove_range')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new system QoS set for a resource."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef qos_map_dscp_mutation_dscp_mutation_map_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        dscp_mutation = ET.SubElement(map, \"dscp-mutation\")\n        dscp_mutation_map_name = ET.SubElement(dscp_mutation, \"dscp-mutation-map-name\")\n        dscp_mutation_map_name.text = kwargs.pop('dscp_mutation_map_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the DSCP Mutation map"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef qos_map_dscp_mutation_mark_dscp_in_values(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        dscp_mutation = ET.SubElement(map, \"dscp-mutation\")\n        dscp_mutation_map_name_key = ET.SubElement(dscp_mutation, \"dscp-mutation-map-name\")\n        dscp_mutation_map_name_key.text = kwargs.pop('dscp_mutation_map_name')\n        mark = ET.SubElement(dscp_mutation, \"mark\")\n        dscp_in_values = ET.SubElement(mark, \"dscp-in-values\")\n        dscp_in_values.text = kwargs.pop('dscp_in_values')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get QoS Map DSCP Mutator Mark DSCP In Values"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget QoS Map DSCP Mutation Mark To", "response": "def qos_map_dscp_mutation_mark_to(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        dscp_mutation = ET.SubElement(map, \"dscp-mutation\")\n        dscp_mutation_map_name_key = ET.SubElement(dscp_mutation, \"dscp-mutation-map-name\")\n        dscp_mutation_map_name_key.text = kwargs.pop('dscp_mutation_map_name')\n        mark = ET.SubElement(dscp_mutation, \"mark\")\n        dscp_in_values_key = ET.SubElement(mark, \"dscp-in-values\")\n        dscp_in_values_key.text = kwargs.pop('dscp_in_values')\n        to = ET.SubElement(mark, \"to\")\n        to.text = kwargs.pop('to')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef qos_map_dscp_traffic_class_dscp_traffic_class_map_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        dscp_traffic_class = ET.SubElement(map, \"dscp-traffic-class\")\n        dscp_traffic_class_map_name = ET.SubElement(dscp_traffic_class, \"dscp-traffic-class-map-name\")\n        dscp_traffic_class_map_name.text = kwargs.pop('dscp_traffic_class_map_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the DSCP Traffic Class map"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef qos_map_dscp_traffic_class_mark_dscp_in_values(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        dscp_traffic_class = ET.SubElement(map, \"dscp-traffic-class\")\n        dscp_traffic_class_map_name_key = ET.SubElement(dscp_traffic_class, \"dscp-traffic-class-map-name\")\n        dscp_traffic_class_map_name_key.text = kwargs.pop('dscp_traffic_class_map_name')\n        mark = ET.SubElement(dscp_traffic_class, \"mark\")\n        dscp_in_values = ET.SubElement(mark, \"dscp-in-values\")\n        dscp_in_values.text = kwargs.pop('dscp_in_values')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get QoS Map DSCP Class Mark DSCP In Values"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets QoS Map DSCP Traffic Class Mark To", "response": "def qos_map_dscp_traffic_class_mark_to(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        dscp_traffic_class = ET.SubElement(map, \"dscp-traffic-class\")\n        dscp_traffic_class_map_name_key = ET.SubElement(dscp_traffic_class, \"dscp-traffic-class-map-name\")\n        dscp_traffic_class_map_name_key.text = kwargs.pop('dscp_traffic_class_map_name')\n        mark = ET.SubElement(dscp_traffic_class, \"mark\")\n        dscp_in_values_key = ET.SubElement(mark, \"dscp-in-values\")\n        dscp_in_values_key.text = kwargs.pop('dscp_in_values')\n        to = ET.SubElement(mark, \"to\")\n        to.text = kwargs.pop('to')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the name of the DSCS - COS map", "response": "def qos_map_dscp_cos_dscp_cos_map_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        dscp_cos = ET.SubElement(map, \"dscp-cos\")\n        dscp_cos_map_name = ET.SubElement(dscp_cos, \"dscp-cos-map-name\")\n        dscp_cos_map_name.text = kwargs.pop('dscp_cos_map_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting QoS map and mark DSCP - IN values", "response": "def qos_map_dscp_cos_mark_dscp_in_values(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        dscp_cos = ET.SubElement(map, \"dscp-cos\")\n        dscp_cos_map_name_key = ET.SubElement(dscp_cos, \"dscp-cos-map-name\")\n        dscp_cos_map_name_key.text = kwargs.pop('dscp_cos_map_name')\n        mark = ET.SubElement(dscp_cos, \"mark\")\n        dscp_in_values = ET.SubElement(mark, \"dscp-in-values\")\n        dscp_in_values.text = kwargs.pop('dscp_in_values')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets QoS map and DSCP - COS mark to", "response": "def qos_map_dscp_cos_mark_to(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        dscp_cos = ET.SubElement(map, \"dscp-cos\")\n        dscp_cos_map_name_key = ET.SubElement(dscp_cos, \"dscp-cos-map-name\")\n        dscp_cos_map_name_key.text = kwargs.pop('dscp_cos_map_name')\n        mark = ET.SubElement(dscp_cos, \"mark\")\n        dscp_in_values_key = ET.SubElement(mark, \"dscp-in-values\")\n        dscp_in_values_key.text = kwargs.pop('dscp_in_values')\n        to = ET.SubElement(mark, \"to\")\n        to.text = kwargs.pop('to')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef qos_map_cos_mutation_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_mutation = ET.SubElement(map, \"cos-mutation\")\n        name = ET.SubElement(cos_mutation, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the Cos Mutation map"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a new NIC from QoS Map and Cos Mutation cos0.", "response": "def qos_map_cos_mutation_cos0(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_mutation = ET.SubElement(map, \"cos-mutation\")\n        name_key = ET.SubElement(cos_mutation, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos0 = ET.SubElement(cos_mutation, \"cos0\")\n        cos0.text = kwargs.pop('cos0')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qos_map_cos_mutation_cos1(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_mutation = ET.SubElement(map, \"cos-mutation\")\n        name_key = ET.SubElement(cos_mutation, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos1 = ET.SubElement(cos_mutation, \"cos1\")\n        cos1.text = kwargs.pop('cos1')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the related resources from QoS Map and Cos Mutation"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the related resources from QoS Map and Cos Mutation", "response": "def qos_map_cos_mutation_cos2(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_mutation = ET.SubElement(map, \"cos-mutation\")\n        name_key = ET.SubElement(cos_mutation, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos2 = ET.SubElement(cos_mutation, \"cos2\")\n        cos2.text = kwargs.pop('cos2')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a new NIC from QoS Map and Cos Mutation cos3", "response": "def qos_map_cos_mutation_cos3(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_mutation = ET.SubElement(map, \"cos-mutation\")\n        name_key = ET.SubElement(cos_mutation, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos3 = ET.SubElement(cos_mutation, \"cos3\")\n        cos3.text = kwargs.pop('cos3')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef qos_map_cos_mutation_cos4(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_mutation = ET.SubElement(map, \"cos-mutation\")\n        name_key = ET.SubElement(cos_mutation, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos4 = ET.SubElement(cos_mutation, \"cos4\")\n        cos4.text = kwargs.pop('cos4')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new NIC from QoS Map and Cos Mutation and Cos 4."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qos_map_cos_mutation_cos5(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_mutation = ET.SubElement(map, \"cos-mutation\")\n        name_key = ET.SubElement(cos_mutation, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos5 = ET.SubElement(cos_mutation, \"cos5\")\n        cos5.text = kwargs.pop('cos5')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new NIC from QoS Map and Cos Mutation cos5"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef qos_map_cos_mutation_cos6(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_mutation = ET.SubElement(map, \"cos-mutation\")\n        name_key = ET.SubElement(cos_mutation, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos6 = ET.SubElement(cos_mutation, \"cos6\")\n        cos6.text = kwargs.pop('cos6')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new NIC from QoS Map and Cos Mutation cos6"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef qos_map_cos_mutation_cos7(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_mutation = ET.SubElement(map, \"cos-mutation\")\n        name_key = ET.SubElement(cos_mutation, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos7 = ET.SubElement(cos_mutation, \"cos7\")\n        cos7.text = kwargs.pop('cos7')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new NIC from QoS Map and Cos Mutation cos 7"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef qos_map_cos_traffic_class_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_traffic_class = ET.SubElement(map, \"cos-traffic-class\")\n        name = ET.SubElement(cos_traffic_class, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the Cos Traffic Class in QoS Map"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qos_map_cos_traffic_class_cos0(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_traffic_class = ET.SubElement(map, \"cos-traffic-class\")\n        name_key = ET.SubElement(cos_traffic_class, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos0 = ET.SubElement(cos_traffic_class, \"cos0\")\n        cos0.text = kwargs.pop('cos0')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new NIC from QoS Map and Cos Traffic Class"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a new NIC from QoS Map and Cos Traffic Class", "response": "def qos_map_cos_traffic_class_cos1(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_traffic_class = ET.SubElement(map, \"cos-traffic-class\")\n        name_key = ET.SubElement(cos_traffic_class, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos1 = ET.SubElement(cos_traffic_class, \"cos1\")\n        cos1.text = kwargs.pop('cos1')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qos_map_cos_traffic_class_cos2(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_traffic_class = ET.SubElement(map, \"cos-traffic-class\")\n        name_key = ET.SubElement(cos_traffic_class, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos2 = ET.SubElement(cos_traffic_class, \"cos2\")\n        cos2.text = kwargs.pop('cos2')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NCBI NIC metadata from QoS Map and COS 2"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef qos_map_cos_traffic_class_cos3(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_traffic_class = ET.SubElement(map, \"cos-traffic-class\")\n        name_key = ET.SubElement(cos_traffic_class, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos3 = ET.SubElement(cos_traffic_class, \"cos3\")\n        cos3.text = kwargs.pop('cos3')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new NIC from QoS Map and Cos Traffic Class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qos_map_cos_traffic_class_cos4(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_traffic_class = ET.SubElement(map, \"cos-traffic-class\")\n        name_key = ET.SubElement(cos_traffic_class, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos4 = ET.SubElement(cos_traffic_class, \"cos4\")\n        cos4.text = kwargs.pop('cos4')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new NIC from QoS Map and Cos Traffic Class and cos 4"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qos_map_cos_traffic_class_cos5(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_traffic_class = ET.SubElement(map, \"cos-traffic-class\")\n        name_key = ET.SubElement(cos_traffic_class, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos5 = ET.SubElement(cos_traffic_class, \"cos5\")\n        cos5.text = kwargs.pop('cos5')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NCBI NIC metadata from QoS Map and COS 5"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets NCBI NIC metadata from QoS Map and COS 6", "response": "def qos_map_cos_traffic_class_cos6(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_traffic_class = ET.SubElement(map, \"cos-traffic-class\")\n        name_key = ET.SubElement(cos_traffic_class, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos6 = ET.SubElement(cos_traffic_class, \"cos6\")\n        cos6.text = kwargs.pop('cos6')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef qos_map_cos_traffic_class_cos7(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_traffic_class = ET.SubElement(map, \"cos-traffic-class\")\n        name_key = ET.SubElement(cos_traffic_class, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos7 = ET.SubElement(cos_traffic_class, \"cos7\")\n        cos7.text = kwargs.pop('cos7')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NCBI NIC metadata from QoS Map and COS 7"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a new ID for the related resources", "response": "def qos_red_profile_profile_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        red_profile = ET.SubElement(qos, \"red-profile\")\n        profile_id = ET.SubElement(red_profile, \"profile-id\")\n        profile_id.text = kwargs.pop('profile_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qos_red_profile_min_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        red_profile = ET.SubElement(qos, \"red-profile\")\n        profile_id_key = ET.SubElement(red_profile, \"profile-id\")\n        profile_id_key.text = kwargs.pop('profile_id')\n        min_threshold = ET.SubElement(red_profile, \"min-threshold\")\n        min_threshold.text = kwargs.pop('min_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the minimum threshold of a set of resources for a given profile"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a new config element for the resource set max_threshold", "response": "def qos_red_profile_max_threshold(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        red_profile = ET.SubElement(qos, \"red-profile\")\n        profile_id_key = ET.SubElement(red_profile, \"profile-id\")\n        profile_id_key.text = kwargs.pop('profile_id')\n        max_threshold = ET.SubElement(red_profile, \"max-threshold\")\n        max_threshold.text = kwargs.pop('max_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qos_red_profile_drop_probability(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        red_profile = ET.SubElement(qos, \"red-profile\")\n        profile_id_key = ET.SubElement(red_profile, \"profile-id\")\n        profile_id_key.text = kwargs.pop('profile_id')\n        drop_probability = ET.SubElement(red_profile, \"drop-probability\")\n        drop_probability.text = kwargs.pop('drop_probability')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the related resources from QoS Red Profile and Drop Probability"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qos_queue_multicast_scheduler_dwrr_dwrr_traffic_class0(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        queue = ET.SubElement(qos, \"queue\")\n        multicast = ET.SubElement(queue, \"multicast\")\n        scheduler = ET.SubElement(multicast, \"scheduler\")\n        dwrr = ET.SubElement(scheduler, \"dwrr\")\n        dwrr_traffic_class0 = ET.SubElement(dwrr, \"dwrr-traffic-class0\")\n        dwrr_traffic_class0.text = kwargs.pop('dwrr_traffic_class0')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get related resources from QoS queues multicast scheduler and dwrr traffic class 0."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the info of a specific resource from QoS queue scheduler strict priority number.", "response": "def qos_queue_scheduler_strict_priority_priority_number(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        queue = ET.SubElement(qos, \"queue\")\n        scheduler = ET.SubElement(queue, \"scheduler\")\n        strict_priority = ET.SubElement(scheduler, \"strict-priority\")\n        priority_number = ET.SubElement(strict_priority, \"priority-number\")\n        priority_number.text = kwargs.pop('priority_number')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the configuration of the affinity system for QoS queues and scheduler strict priority.", "response": "def qos_queue_scheduler_strict_priority_scheduler_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        queue = ET.SubElement(qos, \"queue\")\n        scheduler = ET.SubElement(queue, \"scheduler\")\n        strict_priority = ET.SubElement(scheduler, \"strict-priority\")\n        scheduler_type = ET.SubElement(strict_priority, \"scheduler-type\")\n        scheduler_type.text = kwargs.pop('scheduler_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a new resource from the QoS queue scheduler strict priority and dwrr traffic class 0.", "response": "def qos_queue_scheduler_strict_priority_dwrr_traffic_class0(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        queue = ET.SubElement(qos, \"queue\")\n        scheduler = ET.SubElement(queue, \"scheduler\")\n        strict_priority = ET.SubElement(scheduler, \"strict-priority\")\n        dwrr_traffic_class0 = ET.SubElement(strict_priority, \"dwrr-traffic-class0\")\n        dwrr_traffic_class0.text = kwargs.pop('dwrr_traffic_class0')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qos_queue_scheduler_strict_priority_dwrr_traffic_class1(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        queue = ET.SubElement(qos, \"queue\")\n        scheduler = ET.SubElement(queue, \"scheduler\")\n        strict_priority = ET.SubElement(scheduler, \"strict-priority\")\n        dwrr_traffic_class1 = ET.SubElement(strict_priority, \"dwrr-traffic-class1\")\n        dwrr_traffic_class1.text = kwargs.pop('dwrr_traffic_class1')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the info of a resource from the QoS queue scheduler strict priority and DWRR Traffic Class 1."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qos_queue_scheduler_strict_priority_dwrr_traffic_class2(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        queue = ET.SubElement(qos, \"queue\")\n        scheduler = ET.SubElement(queue, \"scheduler\")\n        strict_priority = ET.SubElement(scheduler, \"strict-priority\")\n        dwrr_traffic_class2 = ET.SubElement(strict_priority, \"dwrr-traffic-class2\")\n        dwrr_traffic_class2.text = kwargs.pop('dwrr_traffic_class2')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the resource cache."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef qos_queue_scheduler_strict_priority_dwrr_traffic_class3(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        queue = ET.SubElement(qos, \"queue\")\n        scheduler = ET.SubElement(queue, \"scheduler\")\n        strict_priority = ET.SubElement(scheduler, \"strict-priority\")\n        dwrr_traffic_class3 = ET.SubElement(strict_priority, \"dwrr-traffic-class3\")\n        dwrr_traffic_class3.text = kwargs.pop('dwrr_traffic_class3')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new QoS queue scheduler strict priority DWRR Traffic Class 3."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef qos_queue_scheduler_strict_priority_dwrr_traffic_class4(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        queue = ET.SubElement(qos, \"queue\")\n        scheduler = ET.SubElement(queue, \"scheduler\")\n        strict_priority = ET.SubElement(scheduler, \"strict-priority\")\n        dwrr_traffic_class4 = ET.SubElement(strict_priority, \"dwrr-traffic-class4\")\n        dwrr_traffic_class4.text = kwargs.pop('dwrr_traffic_class4')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new QoS queue scheduler strict priority and dwrr traffic class 4."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef qos_queue_scheduler_strict_priority_dwrr_traffic_class5(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        queue = ET.SubElement(qos, \"queue\")\n        scheduler = ET.SubElement(queue, \"scheduler\")\n        strict_priority = ET.SubElement(scheduler, \"strict-priority\")\n        dwrr_traffic_class5 = ET.SubElement(strict_priority, \"dwrr-traffic-class5\")\n        dwrr_traffic_class5.text = kwargs.pop('dwrr_traffic_class5')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new QoS queue scheduler strict priority and dwrr traffic class 5"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef qos_queue_scheduler_strict_priority_dwrr_traffic_class6(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        queue = ET.SubElement(qos, \"queue\")\n        scheduler = ET.SubElement(queue, \"scheduler\")\n        strict_priority = ET.SubElement(scheduler, \"strict-priority\")\n        dwrr_traffic_class6 = ET.SubElement(strict_priority, \"dwrr-traffic-class6\")\n        dwrr_traffic_class6.text = kwargs.pop('dwrr_traffic_class6')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new QoS queue scheduler strict priority DWRR Traffic Class 6"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef qos_queue_scheduler_strict_priority_dwrr_traffic_class_last(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        queue = ET.SubElement(qos, \"queue\")\n        scheduler = ET.SubElement(queue, \"scheduler\")\n        strict_priority = ET.SubElement(scheduler, \"strict-priority\")\n        dwrr_traffic_class_last = ET.SubElement(strict_priority, \"dwrr-traffic-class-last\")\n        dwrr_traffic_class_last.text = kwargs.pop('dwrr_traffic_class_last')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the last DWRR Traffic Class in the QoS Queue Scheduler strict priority ET."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qos_rcv_queue_multicast_threshold_traffic_class0(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        rcv_queue = ET.SubElement(qos, \"rcv-queue\")\n        multicast = ET.SubElement(rcv_queue, \"multicast\")\n        threshold = ET.SubElement(multicast, \"threshold\")\n        traffic_class0 = ET.SubElement(threshold, \"traffic-class0\")\n        traffic_class0.text = kwargs.pop('traffic_class0')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get related resources from QoS Receive Multicast Threshold and Traffic Class 0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the current Nagios Multicast Threshold and Traffic Class 1", "response": "def qos_rcv_queue_multicast_threshold_traffic_class1(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        rcv_queue = ET.SubElement(qos, \"rcv-queue\")\n        multicast = ET.SubElement(rcv_queue, \"multicast\")\n        threshold = ET.SubElement(multicast, \"threshold\")\n        traffic_class1 = ET.SubElement(threshold, \"traffic-class1\")\n        traffic_class1.text = kwargs.pop('traffic_class1')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting related resources from QoS Receive Multicast Threshold and Traffic Class 2", "response": "def qos_rcv_queue_multicast_threshold_traffic_class2(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        rcv_queue = ET.SubElement(qos, \"rcv-queue\")\n        multicast = ET.SubElement(rcv_queue, \"multicast\")\n        threshold = ET.SubElement(multicast, \"threshold\")\n        traffic_class2 = ET.SubElement(threshold, \"traffic-class2\")\n        traffic_class2.text = kwargs.pop('traffic_class2')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget related resources from QoS Receive Multicast Threshold and Traffic Class 3", "response": "def qos_rcv_queue_multicast_threshold_traffic_class3(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        rcv_queue = ET.SubElement(qos, \"rcv-queue\")\n        multicast = ET.SubElement(rcv_queue, \"multicast\")\n        threshold = ET.SubElement(multicast, \"threshold\")\n        traffic_class3 = ET.SubElement(threshold, \"traffic-class3\")\n        traffic_class3.text = kwargs.pop('traffic_class3')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget related resources from QoS Receive Multicast Threshold and Traffic Class 4", "response": "def qos_rcv_queue_multicast_threshold_traffic_class4(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        rcv_queue = ET.SubElement(qos, \"rcv-queue\")\n        multicast = ET.SubElement(rcv_queue, \"multicast\")\n        threshold = ET.SubElement(multicast, \"threshold\")\n        traffic_class4 = ET.SubElement(threshold, \"traffic-class4\")\n        traffic_class4.text = kwargs.pop('traffic_class4')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef qos_rcv_queue_multicast_threshold_traffic_class5(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        rcv_queue = ET.SubElement(qos, \"rcv-queue\")\n        multicast = ET.SubElement(rcv_queue, \"multicast\")\n        threshold = ET.SubElement(multicast, \"threshold\")\n        traffic_class5 = ET.SubElement(threshold, \"traffic-class5\")\n        traffic_class5.text = kwargs.pop('traffic_class5')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get related resources from QoS Receive Multicast Threshold and Traffic Class 5"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef qos_rcv_queue_multicast_threshold_traffic_class6(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        rcv_queue = ET.SubElement(qos, \"rcv-queue\")\n        multicast = ET.SubElement(rcv_queue, \"multicast\")\n        threshold = ET.SubElement(multicast, \"threshold\")\n        traffic_class6 = ET.SubElement(threshold, \"traffic-class6\")\n        traffic_class6.text = kwargs.pop('traffic_class6')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get related resources from QoS Receive Multicast Threshold and Traffic Class 6"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets related resources from QoS Receive Multicast Threshold and Traffic Class 7", "response": "def qos_rcv_queue_multicast_threshold_traffic_class7(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        rcv_queue = ET.SubElement(qos, \"rcv-queue\")\n        multicast = ET.SubElement(rcv_queue, \"multicast\")\n        threshold = ET.SubElement(multicast, \"threshold\")\n        traffic_class7 = ET.SubElement(threshold, \"traffic-class7\")\n        traffic_class7.text = kwargs.pop('traffic_class7')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qos_rcv_queue_multicast_rate_limit_limit(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        rcv_queue = ET.SubElement(qos, \"rcv-queue\")\n        multicast = ET.SubElement(rcv_queue, \"multicast\")\n        rate_limit = ET.SubElement(multicast, \"rate-limit\")\n        limit = ET.SubElement(rate_limit, \"limit\")\n        limit.text = kwargs.pop('limit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the related resources from the QoS multicast rate limit and limit."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef qos_rcv_queue_multicast_rate_limit_burst(self, **kwargs):\n        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        rcv_queue = ET.SubElement(qos, \"rcv-queue\")\n        multicast = ET.SubElement(rcv_queue, \"multicast\")\n        rate_limit = ET.SubElement(multicast, \"rate-limit\")\n        burst = ET.SubElement(rate_limit, \"burst\")\n        burst.text = kwargs.pop('burst')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the related resources from the QoS multicast rate limit and burst"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nas_server_ip_server_ip(self, **kwargs):\n        config = ET.Element(\"config\")\n        nas = ET.SubElement(config, \"nas\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        server_ip = ET.SubElement(nas, \"server-ip\")\n        server_ip = ET.SubElement(server_ip, \"server-ip\")\n        server_ip.text = kwargs.pop('server_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NAS server IP"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nas_server_ip_vrf_vrf_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        nas = ET.SubElement(config, \"nas\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        server_ip = ET.SubElement(nas, \"server-ip\")\n        server_ip_key = ET.SubElement(server_ip, \"server-ip\")\n        server_ip_key.text = kwargs.pop('server_ip')\n        vrf = ET.SubElement(server_ip, \"vrf\")\n        vrf_name = ET.SubElement(vrf, \"vrf-name\")\n        vrf_name.text = kwargs.pop('vrf_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NAS server IP VRF and VRF Name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nas_server_ip_vlan_vlan_number(self, **kwargs):\n        config = ET.Element(\"config\")\n        nas = ET.SubElement(config, \"nas\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        server_ip = ET.SubElement(nas, \"server-ip\")\n        server_ip_key = ET.SubElement(server_ip, \"server-ip\")\n        server_ip_key.text = kwargs.pop('server_ip')\n        vlan = ET.SubElement(server_ip, \"vlan\")\n        vlan_number = ET.SubElement(vlan, \"vlan-number\")\n        vlan_number.text = kwargs.pop('vlan_number')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NAS server IP and VLAN number."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the name of the resource in the ip - access - list standard", "response": "def ip_acl_ip_access_list_standard_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip_acl = ET.SubElement(config, \"ip-acl\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-access-list\")\n        ip = ET.SubElement(ip_acl, \"ip\")\n        access_list = ET.SubElement(ip, \"access-list\")\n        standard = ET.SubElement(access_list, \"standard\")\n        name = ET.SubElement(standard, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ip_acl_ip_access_list_standard_hide_ip_acl_std_seq_seq_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip_acl = ET.SubElement(config, \"ip-acl\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-access-list\")\n        ip = ET.SubElement(ip_acl, \"ip\")\n        access_list = ET.SubElement(ip, \"access-list\")\n        standard = ET.SubElement(access_list, \"standard\")\n        name_key = ET.SubElement(standard, \"name\")\n        name_key.text = kwargs.pop('name')\n        hide_ip_acl_std = ET.SubElement(standard, \"hide-ip-acl-std\")\n        seq = ET.SubElement(hide_ip_acl_std, \"seq\")\n        seq_id = ET.SubElement(seq, \"seq-id\")\n        seq_id.text = kwargs.pop('seq_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the ip_acl_ip_access_list_standard"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ip_acl_ip_access_list_standard_hide_ip_acl_std_seq_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip_acl = ET.SubElement(config, \"ip-acl\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-access-list\")\n        ip = ET.SubElement(ip_acl, \"ip\")\n        access_list = ET.SubElement(ip, \"access-list\")\n        standard = ET.SubElement(access_list, \"standard\")\n        name_key = ET.SubElement(standard, \"name\")\n        name_key.text = kwargs.pop('name')\n        hide_ip_acl_std = ET.SubElement(standard, \"hide-ip-acl-std\")\n        seq = ET.SubElement(hide_ip_acl_std, \"seq\")\n        seq_id_key = ET.SubElement(seq, \"seq-id\")\n        seq_id_key.text = kwargs.pop('seq_id')\n        action = ET.SubElement(seq, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the ip_acl_ip_access_list_standard hidden - ip - acl - standard seq - action"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ip_acl_ip_access_list_extended_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip_acl = ET.SubElement(config, \"ip-acl\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-access-list\")\n        ip = ET.SubElement(ip_acl, \"ip\")\n        access_list = ET.SubElement(ip, \"access-list\")\n        extended = ET.SubElement(access_list, \"extended\")\n        name = ET.SubElement(extended, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the extended name of the ip_access_list"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the configuration of the ip_acl_ip_access_list extended section of the ip - access - list", "response": "def ip_acl_ip_access_list_extended_hide_ip_acl_ext_seq_seq_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ip_acl = ET.SubElement(config, \"ip-acl\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-access-list\")\n        ip = ET.SubElement(ip_acl, \"ip\")\n        access_list = ET.SubElement(ip, \"access-list\")\n        extended = ET.SubElement(access_list, \"extended\")\n        name_key = ET.SubElement(extended, \"name\")\n        name_key.text = kwargs.pop('name')\n        hide_ip_acl_ext = ET.SubElement(extended, \"hide-ip-acl-ext\")\n        seq = ET.SubElement(hide_ip_acl_ext, \"seq\")\n        seq_id = ET.SubElement(seq, \"seq-id\")\n        seq_id.text = kwargs.pop('seq_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ip_acl_ip_access_list_extended_hide_ip_acl_ext_seq_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        ip_acl = ET.SubElement(config, \"ip-acl\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-access-list\")\n        ip = ET.SubElement(ip_acl, \"ip\")\n        access_list = ET.SubElement(ip, \"access-list\")\n        extended = ET.SubElement(access_list, \"extended\")\n        name_key = ET.SubElement(extended, \"name\")\n        name_key.text = kwargs.pop('name')\n        hide_ip_acl_ext = ET.SubElement(extended, \"hide-ip-acl-ext\")\n        seq = ET.SubElement(hide_ip_acl_ext, \"seq\")\n        seq_id_key = ET.SubElement(seq, \"seq-id\")\n        seq_id_key.text = kwargs.pop('seq_id')\n        action = ET.SubElement(seq, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the ip_acl_ip_access_list extended hidden - ip - acl - extended seq - id action"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconfigures maintenance mode on the device.", "response": "def maintenance_mode(self, **kwargs):\n        \"\"\"Configures maintenance mode on the device\n\n        Args:\n            rbridge_id (str): The rbridge ID of the device on which\n            Maintenance mode\n                will be configured in a VCS fabric.\n\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `rbridge_id` is not specified.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.202', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.system.maintenance_mode(rbridge_id='226')\n            ...     output = dev.system.maintenance_mode(rbridge_id='226',\n            ...     get=True)\n            ...     assert output == True\n            ...     output = dev.system.maintenance_mode(rbridge_id='226',\n            ...     delete=True)\n            ...     output = dev.system.maintenance_mode(rbridge_id='226',\n            ...     get=True)\n            ...     assert output == False\n        \"\"\"\n        is_get_config = kwargs.pop('get', False)\n        delete = kwargs.pop('delete', False)\n        rbridge_id = kwargs.pop('rbridge_id')\n        callback = kwargs.pop('callback', self._callback)\n        rid_args = dict(rbridge_id=rbridge_id)\n        rid = getattr(self._rbridge,\n                      'rbridge_id_system_mode_maintenance')\n        config = rid(**rid_args)\n        if is_get_config:\n            maint_mode = callback(config, handler='get_config')\n            mode = maint_mode.data_xml\n            root = ET.fromstring(mode)\n            namespace = 'urn:brocade.com:mgmt:brocade-rbridge'\n            for rbridge_id_node in root.findall('{%s}rbridge-id' % namespace):\n                system_mode = rbridge_id_node.find(\n                    '{%s}system-mode' % namespace)\n                if system_mode is not None:\n                    return True\n                else:\n                    return False\n        if delete:\n            config.find('.//*maintenance').set('operation', 'delete')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the related log entry from the logging element.", "response": "def logging_raslog_message_msgId_msgId(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        raslog = ET.SubElement(logging, \"raslog\")\n        message = ET.SubElement(raslog, \"message\")\n        msgId = ET.SubElement(message, \"msgId\")\n        msgId = ET.SubElement(msgId, \"msgId\")\n        msgId.text = kwargs.pop('msgId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef logging_raslog_message_msgId_suppress(self, **kwargs):\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        raslog = ET.SubElement(logging, \"raslog\")\n        message = ET.SubElement(raslog, \"message\")\n        msgId = ET.SubElement(message, \"msgId\")\n        msgId_key = ET.SubElement(msgId, \"msgId\")\n        msgId_key.text = kwargs.pop('msgId')\n        suppress = ET.SubElement(msgId, \"suppress\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Suppress logging message with msgId key."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the related log entry from the raslog module and modId.", "response": "def logging_raslog_module_modId_modId(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        raslog = ET.SubElement(logging, \"raslog\")\n        module = ET.SubElement(raslog, \"module\")\n        modId = ET.SubElement(module, \"modId\")\n        modId = ET.SubElement(modId, \"modId\")\n        modId.text = kwargs.pop('modId')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef logging_raslog_console(self, **kwargs):\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        raslog = ET.SubElement(logging, \"raslog\")\n        console = ET.SubElement(raslog, \"console\")\n        console.text = kwargs.pop('console')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        logging raslog and console"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef logging_auditlog_clss_clss(self, **kwargs):\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        auditlog = ET.SubElement(logging, \"auditlog\")\n        clss = ET.SubElement(auditlog, \"class\")\n        clss = ET.SubElement(clss, \"class\")\n        clss.text = kwargs.pop('clss')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current auditlog class and class from the logging element."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef logging_syslog_facility_local(self, **kwargs):\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        syslog_facility = ET.SubElement(logging, \"syslog-facility\")\n        local = ET.SubElement(syslog_facility, \"local\")\n        local.text = kwargs.pop('local')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Syslog facility for local"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the current syslog client and localip", "response": "def logging_syslog_client_localip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        syslog_client = ET.SubElement(logging, \"syslog-client\")\n        localip = ET.SubElement(syslog_client, \"localip\")\n        localip.text = kwargs.pop('localip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef system_switch_attributes_rbridge_id_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        system = ET.SubElement(config, \"system\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        switch_attributes = ET.SubElement(system, \"switch-attributes\")\n        rbridge_id = ET.SubElement(switch_attributes, \"rbridge-id\")\n        rbridge_id = ET.SubElement(rbridge_id, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get system switch attributes rbridge - id and rbridge - id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the configuration of a system switch attributes rbridge - id chassis - name.", "response": "def system_switch_attributes_rbridge_id_chassis_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system = ET.SubElement(config, \"system\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        switch_attributes = ET.SubElement(system, \"switch-attributes\")\n        rbridge_id = ET.SubElement(switch_attributes, \"rbridge-id\")\n        rbridge_id_key = ET.SubElement(rbridge_id, \"rbridge-id\")\n        rbridge_id_key.text = kwargs.pop('rbridge_id')\n        chassis_name = ET.SubElement(rbridge_id, \"chassis-name\")\n        chassis_name.text = kwargs.pop('chassis_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the configuration of a resource switch attributes rbridge - id and host - name.", "response": "def system_switch_attributes_rbridge_id_host_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system = ET.SubElement(config, \"system\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        switch_attributes = ET.SubElement(system, \"switch-attributes\")\n        rbridge_id = ET.SubElement(switch_attributes, \"rbridge-id\")\n        rbridge_id_key = ET.SubElement(rbridge_id, \"rbridge-id\")\n        rbridge_id_key.text = kwargs.pop('rbridge_id')\n        host_name = ET.SubElement(rbridge_id, \"host-name\")\n        host_name.text = kwargs.pop('host_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef system_switch_attributes_chassis_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        system = ET.SubElement(config, \"system\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        switch_attributes = ET.SubElement(system, \"switch-attributes\")\n        chassis_name = ET.SubElement(switch_attributes, \"chassis-name\")\n        chassis_name.text = kwargs.pop('chassis_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Chassis Name from system switch attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef system_switch_attributes_host_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        system = ET.SubElement(config, \"system\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        switch_attributes = ET.SubElement(system, \"switch-attributes\")\n        host_name = ET.SubElement(switch_attributes, \"host-name\")\n        host_name.text = kwargs.pop('host_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the system switch attributes host_name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bna_config_cmd_input_src(self, **kwargs):\n        config = ET.Element(\"config\")\n        bna_config_cmd = ET.Element(\"bna_config_cmd\")\n        config = bna_config_cmd\n        input = ET.SubElement(bna_config_cmd, \"input\")\n        src = ET.SubElement(input, \"src\")\n        src.text = kwargs.pop('src')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize BNA Channel Channel"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds BNA config command input and destination to the config element.", "response": "def bna_config_cmd_input_dest(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        bna_config_cmd = ET.Element(\"bna_config_cmd\")\n        config = bna_config_cmd\n        input = ET.SubElement(bna_config_cmd, \"input\")\n        dest = ET.SubElement(input, \"dest\")\n        dest.text = kwargs.pop('dest')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bna_config_cmd_output_session_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        bna_config_cmd = ET.Element(\"bna_config_cmd\")\n        config = bna_config_cmd\n        output = ET.SubElement(bna_config_cmd, \"output\")\n        session_id = ET.SubElement(output, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get BNA config command output session id"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bna_config_cmd_output_status(self, **kwargs):\n        config = ET.Element(\"config\")\n        bna_config_cmd = ET.Element(\"bna_config_cmd\")\n        config = bna_config_cmd\n        output = ET.SubElement(bna_config_cmd, \"output\")\n        status = ET.SubElement(output, \"status\")\n        status.text = kwargs.pop('status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get BNA config command output status"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bna_config_cmd_output_status_string(self, **kwargs):\n        config = ET.Element(\"config\")\n        bna_config_cmd = ET.Element(\"bna_config_cmd\")\n        config = bna_config_cmd\n        output = ET.SubElement(bna_config_cmd, \"output\")\n        status_string = ET.SubElement(output, \"status-string\")\n        status_string.text = kwargs.pop('status_string')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get BNA config command output status string"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bna_config_cmd_status_input_session_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        bna_config_cmd_status = ET.Element(\"bna_config_cmd_status\")\n        config = bna_config_cmd_status\n        input = ET.SubElement(bna_config_cmd_status, \"input\")\n        session_id = ET.SubElement(input, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get BNA config command status input session id"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bna_config_cmd_status_output_status(self, **kwargs):\n        config = ET.Element(\"config\")\n        bna_config_cmd_status = ET.Element(\"bna_config_cmd_status\")\n        config = bna_config_cmd_status\n        output = ET.SubElement(bna_config_cmd_status, \"output\")\n        status = ET.SubElement(output, \"status\")\n        status.text = kwargs.pop('status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set status of BNA config command status output status"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bna_config_cmd_status_output_status_string(self, **kwargs):\n        config = ET.Element(\"config\")\n        bna_config_cmd_status = ET.Element(\"bna_config_cmd_status\")\n        config = bna_config_cmd_status\n        output = ET.SubElement(bna_config_cmd_status, \"output\")\n        status_string = ET.SubElement(output, \"status-string\")\n        status_string.text = kwargs.pop('status_string')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get BNA config command status output status string"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef support_autoupload_param_directory(self, **kwargs):\n        config = ET.Element(\"config\")\n        support = ET.SubElement(config, \"support\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        autoupload_param = ET.SubElement(support, \"autoupload-param\")\n        directory = ET.SubElement(autoupload_param, \"directory\")\n        directory.text = kwargs.pop('directory')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        directory"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef support_autoupload_param_protocol(self, **kwargs):\n        config = ET.Element(\"config\")\n        support = ET.SubElement(config, \"support\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        autoupload_param = ET.SubElement(support, \"autoupload-param\")\n        protocol = ET.SubElement(autoupload_param, \"protocol\")\n        protocol.text = kwargs.pop('protocol')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        autoupload parameter protocol"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef support_autoupload_param_password(self, **kwargs):\n        config = ET.Element(\"config\")\n        support = ET.SubElement(config, \"support\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        autoupload_param = ET.SubElement(support, \"autoupload-param\")\n        password = ET.SubElement(autoupload_param, \"password\")\n        password.text = kwargs.pop('password')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        password"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting support parameter hostip", "response": "def support_support_param_hostip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        support = ET.SubElement(config, \"support\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        support_param = ET.SubElement(support, \"support-param\")\n        hostip = ET.SubElement(support_param, \"hostip\")\n        hostip.text = kwargs.pop('hostip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef support_support_param_directory(self, **kwargs):\n        config = ET.Element(\"config\")\n        support = ET.SubElement(config, \"support\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        support_param = ET.SubElement(support, \"support-param\")\n        directory = ET.SubElement(support_param, \"directory\")\n        directory.text = kwargs.pop('directory')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get support - param directory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget support parameter protocol", "response": "def support_support_param_protocol(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        support = ET.SubElement(config, \"support\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        support_param = ET.SubElement(support, \"support-param\")\n        protocol = ET.SubElement(support_param, \"protocol\")\n        protocol.text = kwargs.pop('protocol')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting password of the current system in support - param", "response": "def support_support_param_password(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        support = ET.SubElement(config, \"support\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        support_param = ET.SubElement(support, \"support-param\")\n        password = ET.SubElement(support_param, \"password\")\n        password.text = kwargs.pop('password')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef support_autoupload_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        support = ET.SubElement(config, \"support\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        autoupload = ET.SubElement(support, \"autoupload\")\n        enable = ET.SubElement(autoupload, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        enable"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hide_intf_loopback_holder_interface_loopback_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_intf_loopback_holder = ET.SubElement(config, \"hide-intf-loopback-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-intf-loopback\")\n        interface = ET.SubElement(hide_intf_loopback_holder, \"interface\")\n        loopback = ET.SubElement(interface, \"loopback\")\n        id = ET.SubElement(loopback, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Hide the interface and loopback ID of the current entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hide_intf_loopback_holder_interface_loopback_vrf_forwarding(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_intf_loopback_holder = ET.SubElement(config, \"hide-intf-loopback-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-intf-loopback\")\n        interface = ET.SubElement(hide_intf_loopback_holder, \"interface\")\n        loopback = ET.SubElement(interface, \"loopback\")\n        id_key = ET.SubElement(loopback, \"id\")\n        id_key.text = kwargs.pop('id')\n        vrf = ET.SubElement(loopback, \"vrf\")\n        forwarding = ET.SubElement(vrf, \"forwarding\")\n        forwarding.text = kwargs.pop('forwarding')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Hide Interface Loopback Holder for VRF and forwarding"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhide the interface - loopback - holder interface - loopback - intf - shutdown", "response": "def hide_intf_loopback_holder_interface_loopback_intf_loopback_shutdown(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_intf_loopback_holder = ET.SubElement(config, \"hide-intf-loopback-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-intf-loopback\")\n        interface = ET.SubElement(hide_intf_loopback_holder, \"interface\")\n        loopback = ET.SubElement(interface, \"loopback\")\n        id_key = ET.SubElement(loopback, \"id\")\n        id_key.text = kwargs.pop('id')\n        intf_loopback = ET.SubElement(loopback, \"intf-loopback\")\n        shutdown = ET.SubElement(intf_loopback, \"shutdown\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhide the interface and loopback IP config for the current entry", "response": "def hide_intf_loopback_holder_interface_loopback_ip_ip_config_address_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_intf_loopback_holder = ET.SubElement(config, \"hide-intf-loopback-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-intf-loopback\")\n        interface = ET.SubElement(hide_intf_loopback_holder, \"interface\")\n        loopback = ET.SubElement(interface, \"loopback\")\n        id_key = ET.SubElement(loopback, \"id\")\n        id_key.text = kwargs.pop('id')\n        ip = ET.SubElement(loopback, \"ip\", xmlns=\"urn:brocade.com:mgmt:brocade-ip-config\")\n        ip_config = ET.SubElement(ip, \"ip-config\")\n        address = ET.SubElement(ip_config, \"address\")\n        address = ET.SubElement(address, \"address\")\n        address.text = kwargs.pop('address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the config element for the interface and loopback", "response": "def hide_intf_loopback_holder_interface_loopback_ipv6_ipv6_config_address_link_local_config_link_local_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hide_intf_loopback_holder = ET.SubElement(config, \"hide-intf-loopback-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-intf-loopback\")\n        interface = ET.SubElement(hide_intf_loopback_holder, \"interface\")\n        loopback = ET.SubElement(interface, \"loopback\")\n        id_key = ET.SubElement(loopback, \"id\")\n        id_key.text = kwargs.pop('id')\n        ipv6 = ET.SubElement(loopback, \"ipv6\", xmlns=\"urn:brocade.com:mgmt:brocade-ipv6-config\")\n        ipv6_config = ET.SubElement(ipv6, \"ipv6-config\")\n        address = ET.SubElement(ipv6_config, \"address\")\n        link_local_config = ET.SubElement(address, \"link-local-config\")\n        link_local_address = ET.SubElement(link_local_config, \"link-local-address\")\n        link_local_address.text = kwargs.pop('link_local_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hide_intf_loopback_holder_interface_loopback_ipv6_ipv6_config_address_ipv6_address_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        hide_intf_loopback_holder = ET.SubElement(config, \"hide-intf-loopback-holder\", xmlns=\"urn:brocade.com:mgmt:brocade-intf-loopback\")\n        interface = ET.SubElement(hide_intf_loopback_holder, \"interface\")\n        loopback = ET.SubElement(interface, \"loopback\")\n        id_key = ET.SubElement(loopback, \"id\")\n        id_key.text = kwargs.pop('id')\n        ipv6 = ET.SubElement(loopback, \"ipv6\", xmlns=\"urn:brocade.com:mgmt:brocade-ipv6-config\")\n        ipv6_config = ET.SubElement(ipv6, \"ipv6-config\")\n        address = ET.SubElement(ipv6_config, \"address\")\n        ipv6_address = ET.SubElement(address, \"ipv6-address\")\n        address = ET.SubElement(ipv6_address, \"address\")\n        address.text = kwargs.pop('address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Load the config of the interface and loopback ipv6 config address and ipv6 address address."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mac_table(self):\n        table = []\n        namespace = 'urn:brocade.com:mgmt:brocade-mac-address-table'\n        request_mac_table = ET.Element('get-mac-address-table',\n                                       xmlns=namespace)\n        result = self._callback(request_mac_table, handler='get')\n        for entry in result.findall('{%s}mac-address-table' % namespace):\n            address = entry.find('{%s}mac-address' % namespace).text\n            vlan = entry.find('{%s}vlanid' % namespace).text\n            mac_type = entry.find('{%s}mac-type' % namespace).text\n            state = entry.find('{%s}mac-state' % namespace).text\n            interface = entry.find('{%s}forwarding-interface' % namespace)\n            interface_type = interface.find('{%s}interface-type' %\n                                            namespace).text\n            interface_name = interface.find('{%s}interface-name' %\n                                            namespace).text\n            interface = '%s%s' % (interface_type, interface_name)\n\n            table.append(dict(mac_address=address, interface=interface,\n                              state=state, vlan=vlan,\n                              type=mac_type))\n\n        return table", "response": "Get the MAC table of the device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn firmware version. Args: None Returns: Dictionary Raises: None", "response": "def firmware_version(self):\n        \"\"\"\n        Returns firmware version.\n\n        Args:\n            None\n\n        Returns:\n            Dictionary\n\n        Raises:\n            None\n        \"\"\"\n        namespace = \"urn:brocade.com:mgmt:brocade-firmware-ext\"\n\n        request_ver = ET.Element(\"show-firmware-version\", xmlns=namespace)\n\n        ver = self._callback(request_ver, handler='get')\n        return ver.find('.//*{%s}os-version' % namespace).text"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reconnect(self):\n        if self._auth_method is \"userpass\":\n            self._mgr = manager.connect(host=self._conn[0],\n                                        port=self._conn[1],\n                                        username=self._auth[0],\n                                        password=self._auth[1],\n                                        hostkey_verify=self._hostkey_verify)\n        elif self._auth_method is \"key\":\n            self._mgr = manager.connect(host=self._conn[0],\n                                        port=self._conn[1],\n                                        username=self._auth[0],\n                                        key_filename=self._auth_key,\n                                        hostkey_verify=self._hostkey_verify)\n        else:\n            raise ValueError(\"auth_method incorrect value.\")\n        self._mgr.timeout = 600\n\n        return True", "response": "Reconnects session with device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_interface_by_mac(self, **kwargs):\n        mac = kwargs.pop('mac_address')\n        results = [x for x in self.mac_table if x['mac_address'] == mac]\n        return results", "response": "Find the interface through which a MAC can be reached."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prompt(name, default=None):\n\n    prompt = name + (default and ' [%s]' % default or '')\n    prompt += name.endswith('?') and ' ' or ': '\n    while True:\n        try:\n            rv = raw_input(prompt)\n        except NameError:\n            rv = input(prompt)\n        if rv:\n            return rv\n        if default is not None:\n            return default", "response": "Get user input from command line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef password(name, default=None):\n\n    prompt = name + (default and ' [%s]' % default or '')\n    prompt += name.endswith('?') and ' ' or ': '\n    while True:\n        rv = getpass.getpass(prompt)\n        if rv:\n            return rv\n        if default is not None:\n            return default", "response": "Prompt user for password."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprompting user for user input from command line.", "response": "def choose(name, choices, default=None, resolve=None, no_choice=('none',)):\n    \"\"\"\n    Grabs user input from command line from set of provided choices.\n\n    :param name: prompt text\n    :param choices: list or tuple of available choices. Choices may be\n                    single strings or (key, value) tuples.\n    :param default: default value if no input provided.\n    :param no_choice: acceptable list of strings for \"null choice\"\n    \"\"\"\n\n    if not resolve:\n        resolve = lambda o: o.lower()\n\n    _choices = []\n    options = []\n\n    for choice in choices:\n        if isinstance(choice, string_type):\n            options.append(choice)\n        else:\n            options.append(\"%s [%s]\" % (choice[1], choice[0]))\n            choice = choice[0]\n        _choices.append(choice)\n\n    while True:\n        rv = prompt(name + '? - (%s)' % ', '.join(options), default)\n        if not rv:\n            return default\n        rv = resolve(rv)\n        if rv in no_choice:\n            return None\n        if rv in _choices:\n            return rv"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsolve a puzzle constrained by board dimensions and pieces.", "response": "def solve(ctx, length, height, silent, profile, **pieces):\n    \"\"\" Solve a puzzle constrained by board dimensions and pieces. \"\"\"\n    # Check that at least one piece is provided.\n    if not sum(pieces.values()):\n        context = click.get_current_context()\n        raise BadParameter('No piece provided.', ctx=context, param_hint=[\n            '--{}'.format(label) for label in PIECE_LABELS])\n\n    # Setup the optionnal profiler.\n    profiler = BProfile('solver-profile.png', enabled=profile)\n\n    solver = SolverContext(length, height, **pieces)\n    logger.info(repr(solver))\n\n    logger.info('Searching positions...')\n    with profiler:\n        start = time.time()\n        for result in solver.solve():\n            if not silent:\n                click.echo(u'{}'.format(result))\n        processing_time = time.time() - start\n\n    logger.info('{} results found in {:.2f} seconds.'.format(\n        solver.result_counter, processing_time))\n\n    if profile:\n        logger.info('Execution profile saved at {}'.format(\n            profiler.output_path))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef benchmark():\n    # Use all cores but one on multi-core CPUs.\n    pool_size = multiprocessing.cpu_count() - 1\n    if pool_size < 1:\n        pool_size = 1\n\n    # Start a pool of workers. Only allow 1 task per child, to force flushing\n    # of solver's internal caches.\n    pool = multiprocessing.Pool(processes=pool_size, maxtasksperchild=1)\n    results = pool.imap_unordered(run_scenario, Benchmark.scenarii)\n    pool.close()\n    pool.join()\n\n    # Update CSV database with the new results.\n    benchmark = Benchmark()\n    benchmark.load_csv()\n    benchmark.add(results)\n    benchmark.save_csv()", "response": "Run a benchmarking suite and measure time taken by the solver."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert(self, value, param, ctx):\n        value = super(PositiveInt, self).convert(value, param, ctx)\n        if value < 0:\n            self.fail('%s is not positive' % value, param, ctx)\n        if not self.allow_zero and not value:\n            self.fail('%s is not greater than 0' % value, param, ctx)\n        return value", "response": "Reuse standard integer validator but add checks on sign and zero."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the config element for the resource store preprovisioning the rbridge - id.", "response": "def preprovision_rbridge_id_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        preprovision = ET.SubElement(config, \"preprovision\", xmlns=\"urn:brocade.com:mgmt:brocade-preprovision\")\n        rbridge_id = ET.SubElement(preprovision, \"rbridge-id\")\n        wwn_key = ET.SubElement(rbridge_id, \"wwn\")\n        wwn_key.text = kwargs.pop('wwn')\n        rbridge_id = ET.SubElement(rbridge_id, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the config element for the resource cache preprovisioning rbridge - id and WWN.", "response": "def preprovision_rbridge_id_wwn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        preprovision = ET.SubElement(config, \"preprovision\", xmlns=\"urn:brocade.com:mgmt:brocade-preprovision\")\n        rbridge_id = ET.SubElement(preprovision, \"rbridge-id\")\n        rbridge_id_key = ET.SubElement(rbridge_id, \"rbridge-id\")\n        rbridge_id_key.text = kwargs.pop('rbridge_id')\n        wwn = ET.SubElement(rbridge_id, \"wwn\")\n        wwn.text = kwargs.pop('wwn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshow bare metal state output for a specific resource.", "response": "def show_bare_metal_state_output_bare_metal_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_bare_metal_state = ET.Element(\"show_bare_metal_state\")\n        config = show_bare_metal_state\n        output = ET.SubElement(show_bare_metal_state, \"output\")\n        bare_metal_state = ET.SubElement(output, \"bare-metal-state\")\n        bare_metal_state.text = kwargs.pop('bare_metal_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef redundancy_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        redundancy = ET.Element(\"redundancy\")\n        config = redundancy\n        input = ET.SubElement(redundancy, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Redundancy input rbridge - id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting rd status of the resource in the redundancy output.", "response": "def redundancy_output_rd_status(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        redundancy = ET.Element(\"redundancy\")\n        config = redundancy\n        output = ET.SubElement(redundancy, \"output\")\n        rd_status = ET.SubElement(output, \"rd_status\")\n        rd_status.text = kwargs.pop('rd_status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef redundancy_output_rd_mesg(self, **kwargs):\n        config = ET.Element(\"config\")\n        redundancy = ET.Element(\"redundancy\")\n        config = redundancy\n        output = ET.SubElement(redundancy, \"output\")\n        rd_mesg = ET.SubElement(output, \"rd_mesg\")\n        rd_mesg.text = kwargs.pop('rd_mesg')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Redundancy Entry from Redundancy Entry Output"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the application with the edits and the blueprints.", "response": "def init_app(self, app):\n        \"\"\"\n            Register the Jinja extension, load edits from \n            app.config['EDITS_PATH'] and register blueprints.\n\n            :param app:\n                Flask application instance\n        \"\"\"\n        app.config.setdefault('EDITS_URL', '/edits')\n        app.config.setdefault('EDITS_PREVIEW', True)\n        app.config.setdefault('EDITS_SUMMERNOTE', False)\n\n        if 'EDITS_PATH' not in app.config:\n            raise Exception('EDITS_PATH not set in app configuration.')\n\n        if os.path.isfile(app.config['EDITS_PATH']):\n            with open(app.config['EDITS_PATH']) as f:\n                _db = json.loads(f.read(), object_pairs_hook=OrderedDict)\n        else:\n            _db = OrderedDict()\n\n        app.jinja_env.add_extension('flask.ext.edits.EditableExtension')\n        app.jinja_env.edits = _db\n        app.jinja_env.edits_preview = app.config['EDITS_PREVIEW']\n        app.jinja_env.edits_cache = copy_cache(app.jinja_env.cache)\n\n        if app.config['EDITS_PREVIEW']:\n            app.jinja_env.cache = None\n\n        app.register_blueprint(edits, url_prefix=app.config['EDITS_URL'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nenable or disable VRRP.", "response": "def vrrp(self, **kwargs):\n        \"\"\"Enable or Disable VRRP.\n\n        Args:\n            ip_version (str): The IP version ('4' or '6') for which VRRP should\n                be enabled/disabled.  Default: `4`.\n            enabled (bool): If VRRP should be enabled or disabled.  Default:\n                ``True``.\n            rbridge_id (str): The rbridge ID of the device on which VRRP will\n                be enabled/disabled.  Default: `1`.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            None\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.bgp.local_asn(rbridge_id='225')\n            ...         output = dev.bgp.local_asn(rbridge_id='225',\n            ...         enabled=False)\n            ...         output = dev.bgp.local_asn(rbridge_id='225',\n            ...         ip_version='6')\n            ...         output = dev.bgp.local_asn(rbridge_id='225',\n            ...         enabled=False, ip_version='6')\n            ...         dev.services.vrrp() # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        ip_version = kwargs.pop('ip_version', '4')\n        enabled = kwargs.pop('enabled', True)\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        vrrp_args = dict(rbridge_id=rbridge_id)\n        vrrp_method = 'rbridge_id_protocol_hide_vrrp_holder_vrrp'\n        if ip_version == '6':\n            vrrp_method = 'rbridge_id_ipv6_proto_vrrpv3_vrrp'\n        vrrp = getattr(self._rbridge, vrrp_method)\n        config = vrrp(**vrrp_args)\n        if not enabled:\n            config.find('.//*vrrp').set('operation', 'delete')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nenabling or disable Vrrpe.", "response": "def vrrpe(self, **kwargs):\n        \"\"\"Enable or Disable Vrrpe.\n        Args:\n            ip_version (str): The IP version ('4' or '6') for which vrrpe\n                should be enabled/disabled.  Default: `4`.\n            enable (bool): If vrrpe should be enabled or disabled.  Default:\n                ``True``.\n            get (bool): Get config instead of editing config. (True, False)\n            rbridge_id (str): The rbridge ID of the device on which vrrpe will\n                be enabled/disabled.  Default: `1`.\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            None\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         dev.services.vrrpe(rbridge_id='25',enable=False)\n            ...         dev.services.vrrpe(rbridge_id='25',enable=True)\n            ...         dev.services.vrrpe()\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        ip_version = kwargs.pop('ip_version', '4')\n        enable = kwargs.pop('enable', True)\n        get = kwargs.pop('get', False)\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        if get:\n            enable = None\n        vrrpe_args = dict(rbridge_id=rbridge_id)\n        vrrpe_method = 'rbridge_id_protocol_hide_vrrp_holder_vrrp_extended'\n        if ip_version == '6':\n            vrrpe_method = 'rbridge_id_ipv6_proto_vrrpv3_vrrp_extended'\n        vrrpe = getattr(self._rbridge, vrrpe_method)\n        config = vrrpe(**vrrpe_args)\n        if get:\n            return callback(config, handler='get_config')\n        if not enable:\n            config.find('.//*vrrp-extended').set('operation', 'delete')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_scenario(params):\n    solver = SolverContext(**params)\n    start = time.time()\n    count = sum(1 for _ in solver.solve())\n    execution_time = time.time() - start\n    params.update({\n        'solutions': count,\n        'execution_time': execution_time})\n    return params", "response": "Run one scenario and returns execution time and number of solutions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading old benchmark results from CSV file.", "response": "def load_csv(self):\n        \"\"\" Load old benchmark results from CSV. \"\"\"\n        if path.exists(self.csv_filepath):\n            self.results = self.results.append(\n                pandas.read_csv(self.csv_filepath))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds new benchmark results.", "response": "def add(self, new_results):\n        \"\"\" Add new benchmark results. \"\"\"\n        for result in new_results:\n            result.update(self.context)\n            self.results = self.results.append(result, ignore_index=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_csv(self):\n        # Sort results so we can start to see patterns right in the raw CSV.\n        self.results.sort_values(by=self.column_ids, inplace=True)\n        # Gotcha: integers seems to be promoted to float64 because of\n        # reindexation. See: https://pandas.pydata.org/pandas-docs/stable\n        # /gotchas.html#na-type-promotions\n        self.results.reindex(columns=self.column_ids).to_csv(\n            self.csv_filepath, index=False)", "response": "Dump all results to CSV."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nqueen_graph(self):\n        # Filters out boards with pieces other than queens.\n        nqueens = self.results\n        for piece_label in set(PIECE_LABELS).difference(['queen']):\n            nqueens = nqueens[nqueens[piece_label].map(pandas.isnull)]\n\n        # Filters out non-square boards whose dimension are not aligned to the\n        # number of queens.\n        nqueens = nqueens[nqueens['length'] == nqueens['queen']]\n        nqueens = nqueens[nqueens['height'] == nqueens['queen']]\n\n        # Filters out results not obtained from this system.\n        for label, value in self.context.items():\n            if not value:\n                nqueens = nqueens[nqueens[label].map(pandas.isnull)]\n            else:\n                nqueens = nqueens[nqueens[label] == value]\n\n        plot = seaborn.factorplot(\n            x='queen',\n            y='execution_time',\n            data=nqueens.sort(columns='queen'),\n            estimator=median,\n            kind='bar',\n            palette='BuGn_d',\n            aspect=1.5)\n        plot.set_xlabels('Number of queens')\n        plot.set_ylabels('Solving time in seconds (log scale)')\n        plot.fig.get_axes()[0].set_yscale('log')\n\n        plot.savefig('nqueens-performances.png')", "response": "Graph the n - queens problem for the current version and context."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef neighbor(self, **kwargs):\n        ip_addr = ip_interface(unicode(kwargs.pop('ip_addr')))\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        delete = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        remote_as = kwargs.pop('remote_as', None)\n        get_config = kwargs.pop('get', False)\n        if not get_config and remote_as is None:\n            raise ValueError('When configuring a neighbor, you must specify '\n                             'its remote-as.')\n        neighbor_args = dict(router_bgp_neighbor_address=str(ip_addr.ip),\n                             remote_as=remote_as,\n                             rbridge_id=rbridge_id)\n        if ip_addr.version == 6:\n            neighbor_args['router_bgp_neighbor_ipv6_address'] = str(ip_addr.ip)\n\n        neighbor, ip_addr_path = self._unicast_xml(ip_addr.version)\n        config = neighbor(**neighbor_args)\n        if ip_addr.version == 6 and not delete:\n            config = self._build_ipv6(ip_addr, config, rbridge_id)\n\n        if delete and config.find(ip_addr_path) is not None:\n            if ip_addr.version == 4:\n                config.find(ip_addr_path).set('operation', 'delete')\n                config.find('.//*router-bgp-neighbor-address').set('operation',\n                                                                   'delete')\n            elif ip_addr.version == 6:\n                config.find(ip_addr_path).set('operation', 'delete')\n                config.find('.//*router-bgp-neighbor-ipv6-address').set(\n                    'operation', 'delete')\n        if get_config:\n            return callback(config, handler='get_config')\n        return callback(config)", "response": "Experimental neighbor method.\n\n        Args:\n            ip_addr (str): IP Address of BGP neighbor.\n            remote_as (str): Remote ASN of BGP neighbor.\n            rbridge_id (str): The rbridge ID of the device on which BGP will be\n                configured in a VCS fabric.\n            afis (list): A list of AFIs to configure.  Do not include IPv4 or\n                IPv6 unicast as these are inferred from the `ip_addr`\n                parameter.\n            delete (bool): Deletes the neighbor if `delete` is ``True``.\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `remote_as` or `ip_addr` is not specified.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.203', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.bgp.local_asn(local_as='65535',\n            ...     rbridge_id='225')\n            ...     output = dev.bgp.neighbor(ip_addr='10.10.10.10',\n            ...     remote_as='65535', rbridge_id='225')\n            ...     output = dev.bgp.neighbor(remote_as='65535',\n            ...     rbridge_id='225',\n            ...     ip_addr='2001:4818:f000:1ab:cafe:beef:1000:1')\n            ...     output = dev.bgp.neighbor(ip_addr='10.10.10.10',\n            ...     delete=True, rbridge_id='225', remote_as='65535')\n            ...     output = dev.bgp.neighbor(remote_as='65535',\n            ...     rbridge_id='225', delete=True,\n            ...     ip_addr='2001:4818:f000:1ab:cafe:beef:1000:1')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef evpn_afi(self, **kwargs):\n        callback = kwargs.pop('callback', self._callback)\n        config = ET.Element(\"config\")\n        rbridge_id = ET.SubElement(config, \"rbridge-id\",\n                                   xmlns=\"urn:brocade.com:mgmt:\"\n                                         \"brocade-rbridge\")\n        rbridge_id_key = ET.SubElement(rbridge_id, \"rbridge-id\")\n        rbridge_id_key.text = kwargs.pop('rbridge_id')\n        router = ET.SubElement(rbridge_id, \"router\")\n        router_bgp = ET.SubElement(router, \"router-bgp\",\n                                   xmlns=\"urn:brocade.com:mgmt:brocade-bgp\")\n        address_family = ET.SubElement(router_bgp, \"address-family\")\n        l2vpn = ET.SubElement(address_family, \"l2vpn\")\n        ET.SubElement(l2vpn, \"evpn\")\n\n        if kwargs.pop('delete', False):\n            config.find('.//*l2vpn').set('operation', 'delete')\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        return callback(config)", "response": "Enables or disables the EVPN AFI. This method is used to enable or disable the EVPN AFI."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef evpn_afi_peer_activate(self, **kwargs):\n        peer_ip = kwargs.pop('peer_ip')\n        callback = kwargs.pop('callback', self._callback)\n        evpn_activate = getattr(self._rbridge,\n                                'rbridge_id_router_router_bgp_address_family_'\n                                'l2vpn_evpn_neighbor_evpn_neighbor_ipv4_'\n                                'activate')\n        args = dict(evpn_neighbor_ipv4_address=peer_ip, ip_addr=peer_ip,\n                    rbridge_id=kwargs.pop('rbridge_id'),\n                    afi='evpn')\n        evpn_activate = evpn_activate(**args)\n        if kwargs.pop('delete', False):\n            evpn_activate.find('.//*activate').set('operation', 'delete')\n        if kwargs.pop('get', False):\n            return callback(evpn_activate, handler='get_config')\n        return callback(evpn_activate)", "response": "Activate EVPN AFI for a peer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bfd(self, **kwargs):\n        kwargs['min_tx'] = kwargs.pop('tx')\n        kwargs['min_rx'] = kwargs.pop('rx')\n        kwargs['delete'] = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        bfd_tx = self._bfd_tx(**kwargs)\n        bfd_rx = self._bfd_rx(**kwargs)\n        bfd_multiplier = self._bfd_multiplier(**kwargs)\n        if kwargs.pop('get', False):\n            return self._get_bfd(bfd_tx, bfd_rx, bfd_multiplier)\n        config = pynos.utilities.merge_xml(bfd_tx, bfd_rx)\n        config = pynos.utilities.merge_xml(config, bfd_multiplier)\n        return callback(config)", "response": "Configure BFD for BGP globally."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _bfd_rx(self, **kwargs):\n        method_name = 'rbridge_id_router_router_bgp_router_bgp_attributes_' \\\n                      'bfd_interval_min_rx'\n        bfd_rx = getattr(self._rbridge, method_name)\n        config = bfd_rx(**kwargs)\n        if kwargs['delete']:\n            tag = 'min-rx'\n            config.find('.//*%s' % tag).set('operation', 'delete')\n            pass\n        return config", "response": "Return the BFD minimum receive interval XML."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _bfd_multiplier(self, **kwargs):\n        method_name = 'rbridge_id_router_router_bgp_router_bgp_attributes_' \\\n                      'bfd_interval_multiplier'\n        bfd_multiplier = getattr(self._rbridge, method_name)\n        config = bfd_multiplier(**kwargs)\n        if kwargs['delete']:\n            tag = 'multiplier'\n            config.find('.//*%s' % tag).set('operation', 'delete')\n        return config", "response": "Return the BFD multiplier XML."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconfigures next hop unchanged for an EVPN neighbor.", "response": "def evpn_next_hop_unchanged(self, **kwargs):\n        \"\"\"Configure next hop unchanged for an EVPN neighbor.\n\n        You probably don't want this method.  You probably want to configure\n        an EVPN neighbor using `BGP.neighbor`.  That will configure next-hop\n        unchanged automatically.\n\n        Args:\n            ip_addr (str): IP Address of BGP neighbor.\n            rbridge_id (str): The rbridge ID of the device on which BGP will be\n                configured in a VCS fabric.\n            delete (bool): Deletes the neighbor if `delete` is ``True``.\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            None\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.203', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.bgp.local_asn(local_as='65535',\n            ...     rbridge_id='225')\n            ...     output = dev.bgp.neighbor(ip_addr='10.10.10.10',\n            ...     remote_as='65535', rbridge_id='225')\n            ...     output = dev.bgp.evpn_next_hop_unchanged(rbridge_id='225',\n            ...     ip_addr='10.10.10.10')\n            ...     output = dev.bgp.evpn_next_hop_unchanged(rbridge_id='225',\n            ...     ip_addr='10.10.10.10', get=True)\n            ...     output = dev.bgp.evpn_next_hop_unchanged(rbridge_id='225',\n            ...     ip_addr='10.10.10.10', delete=True)\n        \"\"\"\n        callback = kwargs.pop('callback', self._callback)\n        args = dict(rbridge_id=kwargs.pop('rbridge_id', '1'),\n                    evpn_neighbor_ipv4_address=kwargs.pop('ip_addr'))\n        next_hop_unchanged = getattr(self._rbridge,\n                                     'rbridge_id_router_router_bgp_address_'\n                                     'family_l2vpn_evpn_neighbor_evpn_'\n                                     'neighbor_ipv4_next_hop_unchanged')\n        config = next_hop_unchanged(**args)\n        if kwargs.pop('delete', False):\n            config.find('.//*next-hop-unchanged').set('operation', 'delete')\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef peer_bfd_timers(self, **kwargs):\n        kwargs['min_tx'] = kwargs.pop('tx')\n        kwargs['min_rx'] = kwargs.pop('rx')\n        kwargs['router_bgp_neighbor_address'] = kwargs.pop('peer_ip')\n        kwargs['delete'] = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        bfd_tx = self._peer_bfd_tx(**kwargs)\n        bfd_rx = self._peer_bfd_rx(**kwargs)\n        bfd_multiplier = self._peer_bfd_multiplier(**kwargs)\n        if kwargs.pop('get', False):\n            return self._peer_get_bfd(bfd_tx, bfd_rx, bfd_multiplier)\n        config = pynos.utilities.merge_xml(bfd_tx, bfd_rx)\n        config = pynos.utilities.merge_xml(config, bfd_multiplier)\n        return callback(config)", "response": "Configure BFD for BGP globally."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nenables BFD for each specified peer.", "response": "def enable_peer_bfd(self, **kwargs):\n        \"\"\"BFD enable for each specified peer.\n\n        Args:\n            rbridge_id (str): Rbridge to configure.  (1, 225, etc)\n            peer_ip (str): Peer IPv4 address for BFD setting.\n            delete (bool): True if BFD configuration should be deleted.\n                Default value will be False if not specified.\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                 method.  The only parameter passed to `callback` will be the\n                 ``ElementTree`` `config`.\n        Returns:\n            XML to be passed to the switch.\n\n        Raises:\n            None\n\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.230']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...    conn = (switch, '22')\n            ...    with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...        output = dev.bgp.neighbor(ip_addr='10.10.10.20',\n            ...        remote_as='65535', rbridge_id='230')\n            ...        output = dev.bgp.enable_peer_bfd(peer_ip='10.10.10.20',\n            ...        rbridge_id='230')\n            ...        output = dev.bgp.enable_peer_bfd(peer_ip='10.10.10.20',\n            ...        rbridge_id='230',get=True)\n            ...        output = dev.bgp.enable_peer_bfd(peer_ip='10.10.10.20',\n            ...        rbridge_id='230', delete=True)\n            ...        output = dev.bgp.neighbor(ip_addr='10.10.10.20',\n            ...        delete=True, rbridge_id='230', remote_as='65535')\n        \"\"\"\n        method_name = 'rbridge_id_router_router_bgp_router_bgp_attributes_' \\\n                      'neighbor_neighbor_ips_neighbor_addr_bfd_bfd_enable'\n        bfd_enable = getattr(self._rbridge, method_name)\n        kwargs['router_bgp_neighbor_address'] = kwargs.pop('peer_ip')\n        callback = kwargs.pop('callback', self._callback)\n        config = bfd_enable(**kwargs)\n        if kwargs.pop('delete', False):\n            tag = 'bfd-enable'\n            config.find('.//*%s' % tag).set('operation', 'delete')\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        else:\n            return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _peer_bfd_tx(self, **kwargs):\n        method_name = 'rbridge_id_router_router_bgp_router_bgp_attributes_' \\\n                      'neighbor_neighbor_ips_neighbor_addr_bfd_interval_min_tx'\n        bfd_tx = getattr(self._rbridge, method_name)\n        config = bfd_tx(**kwargs)\n        if kwargs['delete']:\n            tag = 'min-tx'\n            config.find('.//*%s' % tag).set('operation', 'delete')\n        return config", "response": "Return the BFD minimum transmit interval XML."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _peer_get_bfd(self, tx, rx, multiplier):\n        tx = self._callback(tx, handler='get_config')\n        rx = self._callback(rx, handler='get_config')\n        multiplier = self._callback(multiplier, handler='get_config')\n        tx = pynos.utilities.return_xml(str(tx))\n        rx = pynos.utilities.return_xml(str(rx))\n        multiplier = pynos.utilities.return_xml(str(multiplier))\n        config = pynos.utilities.merge_xml(tx, rx)\n        return pynos.utilities.merge_xml(config, multiplier)", "response": "Get and merge the bfd config from global BGP."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd VNIs to the EVPN Instance.", "response": "def vni_add(self, **kwargs):\n        \"\"\"Add VNIs to the EVPN Instance\n        Args:\n            rbridge_id (str): rbridge-id for device.\n            evpn_instance (str): Name of the evpn instance.\n            vni (str): vnis to the evpn instance\n            get (bool): Get config instead of editing config. (True, False)\n            delete (bool): True, delete the vni configuration\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `rbridge_id`,`evpn_instance`, 'vni' is not passed.\n            ValueError: if `rbridge_id`, `evpn_instance`, 'vni' is invalid.\n        Examples:\n            >>> import pynos.device\n            >>> switches = ['10.24.39.211', '10.24.39.203']\n            >>> auth = ('admin', 'password')\n            >>> for switch in switches:\n            ...     conn = (switch, '22')\n            ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...         output = dev.bgp.vni_add(rbridge_id='2',\n            ...         evpn_instance=\"leaf1\", vni='10')\n            ...         output = dev.bgp.vni_add(rbridge_id='2',\n            ...         evpn_instance=\"leaf1\", vni='10', delete=True)\n            ...         output = dev.bgp.vni_add(rbridge_id='2',\n            ...         evpn_instance=\"leaf1\", vni='10', delete=True)\n            ...         output = dev.bgp.vni_add(rbridge_id='2',\n            ...         get=True)\n\n        \"\"\"\n        rbridge_id = kwargs['rbridge_id']\n        get_config = kwargs.pop('get', False)\n        delete = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        result = []\n\n        method_class = self._rbridge\n        if not get_config:\n            evpn_instance = kwargs['evpn_instance']\n            vni = kwargs['vni']\n            if not delete:\n                method_name = 'rbridge_id_evpn_instance_vni_vni_add_add'\n                vni_add = getattr(method_class, method_name)\n                vni_args = dict(rbridge_id=rbridge_id,\n                                instance_name=evpn_instance,\n                                add=vni)\n                config = vni_add(**vni_args)\n            else:\n                method_name = 'rbridge_id_evpn_instance_vni_vni_add_remove'\n                vni_add = getattr(method_class, method_name)\n                vni_args = dict(rbridge_id=rbridge_id,\n                                instance_name=evpn_instance,\n                                remove=vni)\n                config = vni_add(**vni_args)\n                config.find('.//*vni-add').set('operation', 'delete')\n            result = callback(config)\n\n        elif get_config:\n            evpn_instance = kwargs.pop('evpn_instance', '')\n            method_name = 'rbridge_id_evpn_instance_vni_vni_add_add'\n            vni_add = getattr(method_class, method_name)\n            vni_args = dict(rbridge_id=rbridge_id, instance_name=evpn_instance,\n                            add='')\n            config = vni_add(**vni_args)\n            evpninstance = ''\n            evpn_vni = ''\n            output = callback(config, handler='get_config')\n            for item in output.data.findall('.//{*}evpn-instance'):\n                if item.find('.//{*}instance-name') is not None:\n                    evpninstance = item.find('.//{*}instance-name').text\n\n                if item.find('.//{*}add') is not None:\n                    evpn_vni = item.find('.//{*}add').text\n            tmp = {'rbridge_id': rbridge_id, 'evpn_instance': evpninstance,\n                   'vni': evpn_vni}\n            result.append(tmp)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset BGP max paths property on BGP module.", "response": "def vrf_max_paths(self, **kwargs):\n        \"\"\"Set BGP max paths property on VRF address family.\n\n        Args:\n            vrf (str): The VRF for this BGP process.\n            rbridge_id (str): The rbridge ID of the device on which BGP will be\n                configured in a VCS fabric.\n            paths (str): Number of paths for BGP ECMP (default: 8).\n            afi (str): Address family to configure. (ipv4, ipv6)\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            ``AttributeError``: When `afi` is not one of ['ipv4', 'ipv6']\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.211', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.bgp.vrf_max_paths(paths='8',\n            ...     rbridge_id='225')\n            ...     output = dev.bgp.vrf_max_paths(\n            ...     rbridge_id='225', get=True)\n            ...     output = dev.bgp.vrf_max_paths(paths='8',\n            ...     rbridge_id='225', delete=True)\n            ...     output = dev.bgp.vrf_max_paths(paths='8', afi='ipv6',\n            ...     rbridge_id='225')\n            ...     output = dev.bgp.vrf_max_paths(afi='ipv6',\n            ...     rbridge_id='225', get=True)\n            ...     output = dev.bgp.vrf_max_paths(paths='8', afi='ipv6',\n            ...     rbridge_id='225', delete=True)\n            ...     output = dev.bgp.vrf_max_paths(paths='8', afi='ipv5',\n            ...     rbridge_id='225') # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            AttributeError\n        \"\"\"\n        afi = kwargs.pop('afi', 'ipv4')\n        vrf = kwargs.pop('vrf', 'default')\n        get_config = kwargs.pop('get', False)\n        callback = kwargs.pop('callback', self._callback)\n        if afi not in ['ipv4', 'ipv6']:\n            raise AttributeError('Invalid AFI.')\n        if \"ipv4\" in afi:\n            if not get_config:\n                args = dict(af_vrf_name=vrf,\n                            rbridge_id=kwargs.pop('rbridge_id', '1'),\n                            load_sharing_value=kwargs.pop('paths', '8'))\n            else:\n                args = dict(af_vrf_name=vrf,\n                            rbridge_id=kwargs.pop('rbridge_id', '1'),\n                            load_sharing_value='')\n            max_paths = getattr(self._rbridge,\n                                'rbridge_id_router_router_bgp_address_family_'\n                                'ipv4_ipv4_unicast_af_vrf_maximum_paths_'\n                                'load_sharing_value')\n        elif \"ipv6\" in afi:\n            if not get_config:\n                args = dict(af_ipv6_vrf_name=vrf,\n                            rbridge_id=kwargs.pop('rbridge_id', '1'),\n                            load_sharing_value=kwargs.pop('paths', '8'))\n            else:\n                args = dict(af_ipv6_vrf_name=vrf,\n                            rbridge_id=kwargs.pop('rbridge_id', '1'),\n                            load_sharing_value='')\n            max_paths = getattr(self._rbridge,\n                                'rbridge_id_router_router_bgp_address_family_'\n                                'ipv6_ipv6_unicast_af_ipv6_vrf_maximum_paths_'\n                                'load_sharing_value')\n\n        config = max_paths(**args)\n        if get_config:\n            output = callback(config, handler='get_config')\n            if output.data.find('.//{*}load-sharing-value') is not None:\n                max_path = output.data.find('.//{*}load-sharing-value').text\n                result = {\"vrf\": vrf,\n                          \"max_path\": max_path}\n                return result\n            else:\n                return None\n        if kwargs.pop('delete', False):\n            config.find('.//*load-sharing-value').set('operation', 'delete')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating default address family for BGP.", "response": "def default_vrf_unicast_address_family(self, **kwargs):\n        \"\"\"Create default address family (ipv4/ipv6) under router bgp.\n\n        Args:\n            afi (str): Address family to configure. (ipv4, ipv6)\n            rbridge_id (str): The rbridge ID of the device on which BGP will be\n                              configured in a VCS fabric.\n            delete (bool): Deletes the redistribute connected under default vrf\n                if `delete` is ``True``.\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            KeyError: if `afi' is not expected\n            AttributeError: if 'afi' is not in ipv4,ipv6.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.211', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     device.bgp.default_vrf_unicast_address_family(delete=True,\n            ...     rbridge_id='4')\n            ...     device.bgp.default_vrf_unicast_address_family(get=True,\n            ...     rbridge_id='4')\n            ...     device.bgp.default_vrf_unicast_address_family(\n            ...     rbridge_id='4', afi='ipv6')\n        \"\"\"\n        afi = kwargs.pop('afi', 'ipv4')\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        delete = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        if afi not in ['ipv4', 'ipv6']:\n            raise AttributeError('Invalid AFI.')\n\n        addr_family = getattr(self._rbridge,\n                              'rbridge_id_router_router_bgp_address_family'\n                              '_{0}_{0}_unicast_default_vrf_default_vrf_'\n                              'selected'.format(afi))\n        neighbor_args = dict(rbridge_id=rbridge_id)\n\n        config = addr_family(**neighbor_args)\n\n        result = False\n        if kwargs.pop('get', False):\n            output = callback(config, handler='get_config')\n            if output.data.findall('.//{*}default-vrf-selected') != []:\n                result = True\n        elif delete:\n            config.find('.//*af-vrf').set('operation', 'delete')\n            result = callback(config)\n        else:\n            result = callback(config)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef default_vrf_max_paths(self, **kwargs):\n        afi = kwargs.pop('afi', 'ipv4')\n        callback = kwargs.pop('callback', self._callback)\n        get_config = kwargs.pop('get', False)\n        if afi not in ['ipv4', 'ipv6']:\n            raise AttributeError('Invalid AFI.')\n        if not get_config:\n            args = dict(rbridge_id=kwargs.pop('rbridge_id', '1'),\n                        load_sharing_value=kwargs.pop('paths', '8'))\n        else:\n            args = dict(rbridge_id=kwargs.pop('rbridge_id', '1'),\n                        load_sharing_value='')\n        max_paths = getattr(self._rbridge,\n                            'rbridge_id_router_router_bgp_address_family_'\n                            '{0}_{0}_unicast_default_vrf_af_common_cmds_'\n                            'holder_maximum_paths_load_'\n                            'sharing_value'.format(afi))\n\n        config = max_paths(**args)\n        if get_config:\n            output = callback(config, handler='get_config')\n            if output.data.find('.//{*}load-sharing-value') is not None:\n                max_path = output.data.find('.//{*}load-sharing-value').text\n                result = {\"max_path\": max_path}\n                return result\n            else:\n                return None\n        if kwargs.pop('delete', False):\n            config.find('.//*load-sharing-value').set('operation', 'delete')\n        return callback(config)", "response": "Set BGP max paths property on default VRF address family."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hardware_connector_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        connector = ET.SubElement(hardware, \"connector\")\n        name = ET.SubElement(connector, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hardware_connector_sfp_breakout(self, **kwargs):\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        connector = ET.SubElement(hardware, \"connector\")\n        name_key = ET.SubElement(connector, \"name\")\n        name_key.text = kwargs.pop('name')\n        sfp = ET.SubElement(connector, \"sfp\")\n        breakout = ET.SubElement(sfp, \"breakout\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get hardware connector sfp breakout"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hardware_port_group_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        port_group = ET.SubElement(hardware, \"port-group\")\n        name = ET.SubElement(port_group, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set name of the hardware port group"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget hardware port group mode and performance", "response": "def hardware_port_group_mode_performance(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        port_group = ET.SubElement(hardware, \"port-group\")\n        name_key = ET.SubElement(port_group, \"name\")\n        name_key.text = kwargs.pop('name')\n        mode = ET.SubElement(port_group, \"mode\")\n        performance = ET.SubElement(mode, \"performance\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hardware_port_group_mode_portgroup_speed(self, **kwargs):\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        port_group = ET.SubElement(hardware, \"port-group\")\n        name_key = ET.SubElement(port_group, \"name\")\n        name_key.text = kwargs.pop('name')\n        mode = ET.SubElement(port_group, \"mode\")\n        portgroup_speed = ET.SubElement(mode, \"portgroup-speed\")\n        portgroup_speed.text = kwargs.pop('portgroup_speed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a hardware port group mode and portgroup speed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hardware_port_group_mode_support_performance(self, **kwargs):\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        port_group = ET.SubElement(hardware, \"port-group\")\n        name_key = ET.SubElement(port_group, \"name\")\n        name_key.text = kwargs.pop('name')\n        mode = ET.SubElement(port_group, \"mode\")\n        support_performance = ET.SubElement(mode, \"support_performance\")\n        support_performance.text = kwargs.pop('support_performance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get hardware port group mode support performance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hardware_port_group_mode_support_multispeed(self, **kwargs):\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        port_group = ET.SubElement(hardware, \"port-group\")\n        name_key = ET.SubElement(port_group, \"name\")\n        name_key.text = kwargs.pop('name')\n        mode = ET.SubElement(port_group, \"mode\")\n        support_multispeed = ET.SubElement(mode, \"support_multispeed\")\n        support_multispeed.text = kwargs.pop('support_multispeed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get hardware port group mode and support multispeed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hardware_connector_group_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        connector_group = ET.SubElement(hardware, \"connector-group\")\n        id = ET.SubElement(connector_group, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get ID of the hardware connector group"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the current system connector group speed", "response": "def hardware_connector_group_speed(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        connector_group = ET.SubElement(hardware, \"connector-group\")\n        id_key = ET.SubElement(connector_group, \"id\")\n        id_key.text = kwargs.pop('id')\n        speed = ET.SubElement(connector_group, \"speed\")\n        speed.text = kwargs.pop('speed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hardware_flexport_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        flexport = ET.SubElement(hardware, \"flexport\")\n        id = ET.SubElement(flexport, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the ID of the Hardware Cache entry"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hardware_flexport_flexport_type_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        flexport = ET.SubElement(hardware, \"flexport\")\n        id_key = ET.SubElement(flexport, \"id\")\n        id_key.text = kwargs.pop('id')\n        flexport_type = ET.SubElement(flexport, \"flexport_type\")\n        type = ET.SubElement(flexport_type, \"type\")\n        type.text = kwargs.pop('type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a hardware flexport type"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the configuration of a hardware flexport type and instance", "response": "def hardware_flexport_flexport_type_instance(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        flexport = ET.SubElement(hardware, \"flexport\")\n        id_key = ET.SubElement(flexport, \"id\")\n        id_key.text = kwargs.pop('id')\n        flexport_type = ET.SubElement(flexport, \"flexport_type\")\n        instance = ET.SubElement(flexport_type, \"instance\")\n        instance.text = kwargs.pop('instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the configuration of a hardware flexport type skip_deconfig", "response": "def hardware_flexport_flexport_type_skip_deconfig(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        flexport = ET.SubElement(hardware, \"flexport\")\n        id_key = ET.SubElement(flexport, \"id\")\n        id_key.text = kwargs.pop('id')\n        flexport_type = ET.SubElement(flexport, \"flexport_type\")\n        skip_deconfig = ET.SubElement(flexport_type, \"skip_deconfig\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting KAP custom profile name", "response": "def hardware_custom_profile_kap_custom_profile_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        custom_profile = ET.SubElement(hardware, \"custom-profile\")\n        kap_custom_profile = ET.SubElement(custom_profile, \"kap-custom-profile\")\n        name = ET.SubElement(kap_custom_profile, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hardware_custom_profile_kap_custom_profile_lacp_lacp_hello_interval(self, **kwargs):\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        custom_profile = ET.SubElement(hardware, \"custom-profile\")\n        kap_custom_profile = ET.SubElement(custom_profile, \"kap-custom-profile\")\n        name_key = ET.SubElement(kap_custom_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        lacp = ET.SubElement(kap_custom_profile, \"lacp\")\n        lacp_hello_interval = ET.SubElement(lacp, \"lacp_hello_interval\")\n        lacp_hello_interval.text = kwargs.pop('lacp_hello_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new hardware custom profile and configure it for Kap"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the value of xstp_hello_interval in seconds for kap_custom_profile_xstp_hello_interval", "response": "def hardware_custom_profile_kap_custom_profile_xstp_xstp_hello_interval(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        custom_profile = ET.SubElement(hardware, \"custom-profile\")\n        kap_custom_profile = ET.SubElement(custom_profile, \"kap-custom-profile\")\n        name_key = ET.SubElement(kap_custom_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        xstp = ET.SubElement(kap_custom_profile, \"xstp\")\n        xstp_hello_interval = ET.SubElement(xstp, \"xstp_hello_interval\")\n        xstp_hello_interval.text = kwargs.pop('xstp_hello_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hardware_custom_profile_kap_custom_profile_rpvst_rpvst_hello_interval(self, **kwargs):\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        custom_profile = ET.SubElement(hardware, \"custom-profile\")\n        kap_custom_profile = ET.SubElement(custom_profile, \"kap-custom-profile\")\n        name_key = ET.SubElement(kap_custom_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        rpvst = ET.SubElement(kap_custom_profile, \"rpvst\")\n        rpvst_hello_interval = ET.SubElement(rpvst, \"rpvst_hello_interval\")\n        rpvst_hello_interval.text = kwargs.pop('rpvst_hello_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of a kap custom profile"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the configuration of a Kap custom profile", "response": "def hardware_custom_profile_kap_custom_profile_udld_udld_hello_interval(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        custom_profile = ET.SubElement(hardware, \"custom-profile\")\n        kap_custom_profile = ET.SubElement(custom_profile, \"kap-custom-profile\")\n        name_key = ET.SubElement(kap_custom_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        udld = ET.SubElement(kap_custom_profile, \"udld\")\n        udld_hello_interval = ET.SubElement(udld, \"udld_hello_interval\")\n        udld_hello_interval.text = kwargs.pop('udld_hello_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconfiguring hardware custom profile kap - custom - profile bfd - vxlan - hello - interval", "response": "def hardware_custom_profile_kap_custom_profile_bfd_vxlan_bfd_vxlan_hello_interval(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        custom_profile = ET.SubElement(hardware, \"custom-profile\")\n        kap_custom_profile = ET.SubElement(custom_profile, \"kap-custom-profile\")\n        name_key = ET.SubElement(kap_custom_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        bfd_vxlan = ET.SubElement(kap_custom_profile, \"bfd-vxlan\")\n        bfd_vxlan_hello_interval = ET.SubElement(bfd_vxlan, \"bfd_vxlan_hello_interval\")\n        bfd_vxlan_hello_interval.text = kwargs.pop('bfd_vxlan_hello_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconfigures KAP custom profile for Kap", "response": "def hardware_custom_profile_kap_custom_profile_bfd_l3_bfd_l3_hello_interval(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        custom_profile = ET.SubElement(hardware, \"custom-profile\")\n        kap_custom_profile = ET.SubElement(custom_profile, \"kap-custom-profile\")\n        name_key = ET.SubElement(kap_custom_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        bfd_l3 = ET.SubElement(kap_custom_profile, \"bfd-l3\")\n        bfd_l3_hello_interval = ET.SubElement(bfd_l3, \"bfd_l3_hello_interval\")\n        bfd_l3_hello_interval.text = kwargs.pop('bfd_l3_hello_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets Kap custom profile from hardware", "response": "def hardware_custom_profile_kap_custom_profile_fcoe_fcoe_hello_interval(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        hardware = ET.SubElement(config, \"hardware\", xmlns=\"urn:brocade.com:mgmt:brocade-hardware\")\n        custom_profile = ET.SubElement(hardware, \"custom-profile\")\n        kap_custom_profile = ET.SubElement(custom_profile, \"kap-custom-profile\")\n        name_key = ET.SubElement(kap_custom_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        fcoe = ET.SubElement(kap_custom_profile, \"fcoe\")\n        fcoe_hello_interval = ET.SubElement(fcoe, \"fcoe_hello_interval\")\n        fcoe_hello_interval.text = kwargs.pop('fcoe_hello_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets FLEXPORTS output for a specific Port ID", "response": "def get_flexports_output_flexport_list_port_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_flexports = ET.Element(\"get_flexports\")\n        config = get_flexports\n        output = ET.SubElement(get_flexports, \"output\")\n        flexport_list = ET.SubElement(output, \"flexport-list\")\n        port_id = ET.SubElement(flexport_list, \"port-id\")\n        port_id.text = kwargs.pop('port_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _subcommand(group, *args, **kwargs):\n    def decorator(f):\n        if 'help' not in kwargs:\n            kwargs['help'] = f.__doc__\n        _parser_class = group._subparsers._parser_class\n        if 'parser' in kwargs:\n            # use a copy of the given parser\n            group._subparsers._parser_class = _CopiedArgumentParser\n        if 'parents' in kwargs:\n            if not hasattr(f, '_argnames'):  # pragma: no cover\n                f._argnames = []\n            for p in kwargs['parents']:\n                f._argnames += p._argnames if hasattr(p, '_argnames') else []\n            kwargs['parents'] = [p.parser for p in kwargs['parents']]\n        if args == ():\n            f.parser = group._subparsers.add_parser(f.__name__, **kwargs)\n        else:\n            f.parser = group._subparsers.add_parser(*args, **kwargs)\n        f.parser.set_defaults(**{'_func_' + group.__name__: f})\n        f.climax = 'parser' not in kwargs\n        group._subparsers._parser_class = _parser_class\n        for arg in getattr(f, '_arguments', []):\n            f.parser.add_argument(*arg[0], **arg[1])\n        return f\n    return decorator", "response": "Decorator to define a subcommand. This decorator is used for the group s command decorator."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_dest(*args, **kwargs):  # pragma: no cover\n    prefix_chars = kwargs.get('prefix_chars', '-')\n    # determine short and long option strings\n    option_strings = []\n    long_option_strings = []\n\n    for option_string in args:\n        # strings starting with two prefix characters are long options\n        option_strings.append(option_string)\n        if option_string[0] in prefix_chars:\n            if len(option_string) > 1:\n                if option_string[1] in prefix_chars:\n                    long_option_strings.append(option_string)\n\n    # infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'\n    dest = kwargs.get('dest', None)\n    if dest is None:\n        if long_option_strings:\n            dest_option_string = long_option_strings[0]\n        else:\n            dest_option_string = option_strings[0]\n        dest = dest_option_string.lstrip(prefix_chars)\n        if not dest:\n            msg = _('dest= is required for options like %r')\n            raise ValueError(msg % option_string)\n        dest = dest.replace('-', '_')\n\n    # return the updated dest name\n    return dest", "response": "This function is used to infer the destination name from the argument names."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the name of the webui schematics panels panel.", "response": "def webui_schematics_panels_panel_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        schematics = ET.SubElement(webui, \"schematics\")\n        panels = ET.SubElement(schematics, \"panels\")\n        panel = ET.SubElement(panels, \"panel\")\n        name = ET.SubElement(panel, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef webui_schematics_panels_panel_properties_height(self, **kwargs):\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        schematics = ET.SubElement(webui, \"schematics\")\n        panels = ET.SubElement(schematics, \"panels\")\n        panel = ET.SubElement(panels, \"panel\")\n        name_key = ET.SubElement(panel, \"name\")\n        name_key.text = kwargs.pop('name')\n        properties = ET.SubElement(panel, \"properties\")\n        height = ET.SubElement(properties, \"height\")\n        height.text = kwargs.pop('height')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a webui schematics panels panel properties height."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef webui_schematics_panels_panel_components_component_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        schematics = ET.SubElement(webui, \"schematics\")\n        panels = ET.SubElement(schematics, \"panels\")\n        panel = ET.SubElement(panels, \"panel\")\n        name_key = ET.SubElement(panel, \"name\")\n        name_key.text = kwargs.pop('name')\n        components = ET.SubElement(panel, \"components\")\n        component = ET.SubElement(components, \"component\")\n        id = ET.SubElement(component, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the ID of the most recent available webui component."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef webui_schematics_panels_panel_components_component_properties_top(self, **kwargs):\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        schematics = ET.SubElement(webui, \"schematics\")\n        panels = ET.SubElement(schematics, \"panels\")\n        panel = ET.SubElement(panels, \"panel\")\n        name_key = ET.SubElement(panel, \"name\")\n        name_key.text = kwargs.pop('name')\n        components = ET.SubElement(panel, \"components\")\n        component = ET.SubElement(components, \"component\")\n        id_key = ET.SubElement(component, \"id\")\n        id_key.text = kwargs.pop('id')\n        properties = ET.SubElement(component, \"properties\")\n        top = ET.SubElement(properties, \"top\")\n        top.text = kwargs.pop('top')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a webui schematics panels component properties and top."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef webui_schematics_assets_asset_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        schematics = ET.SubElement(webui, \"schematics\")\n        assets = ET.SubElement(schematics, \"assets\")\n        asset = ET.SubElement(assets, \"asset\")\n        name = ET.SubElement(asset, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the asset for the schematics and assets."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef webui_schematics_assets_asset_asset_type_image_base_64_image(self, **kwargs):\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        schematics = ET.SubElement(webui, \"schematics\")\n        assets = ET.SubElement(schematics, \"assets\")\n        asset = ET.SubElement(assets, \"asset\")\n        name_key = ET.SubElement(asset, \"name\")\n        name_key.text = kwargs.pop('name')\n        asset_type = ET.SubElement(asset, \"asset-type\")\n        image = ET.SubElement(asset_type, \"image\")\n        base_64_image = ET.SubElement(image, \"base-64-image\")\n        base_64_image.text = kwargs.pop('base_64_image')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a webui schematics assets asset type image base - 64 - image"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the configuration of the webui data stores user profile and username.", "response": "def webui_data_stores_user_profile_username(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        data_stores = ET.SubElement(webui, \"data-stores\")\n        user_profile = ET.SubElement(data_stores, \"user-profile\")\n        username = ET.SubElement(user_profile, \"username\")\n        username.text = kwargs.pop('username')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef webui_data_stores_user_profile_saved_query_key(self, **kwargs):\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        data_stores = ET.SubElement(webui, \"data-stores\")\n        user_profile = ET.SubElement(data_stores, \"user-profile\")\n        username_key = ET.SubElement(user_profile, \"username\")\n        username_key.text = kwargs.pop('username')\n        saved_query = ET.SubElement(user_profile, \"saved-query\")\n        key = ET.SubElement(saved_query, \"key\")\n        key.text = kwargs.pop('key')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the key for the user profile saved query in the webui data stores section."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef webui_data_stores_user_profile_saved_query_value(self, **kwargs):\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        data_stores = ET.SubElement(webui, \"data-stores\")\n        user_profile = ET.SubElement(data_stores, \"user-profile\")\n        username_key = ET.SubElement(user_profile, \"username\")\n        username_key.text = kwargs.pop('username')\n        saved_query = ET.SubElement(user_profile, \"saved-query\")\n        key_key = ET.SubElement(saved_query, \"key\")\n        key_key.text = kwargs.pop('key')\n        value = ET.SubElement(saved_query, \"value\")\n        value.text = kwargs.pop('value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the value of the saved query key for a user profile."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef webui_data_stores_data_store_key(self, **kwargs):\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        data_stores = ET.SubElement(webui, \"data-stores\")\n        data_store = ET.SubElement(data_stores, \"data-store\")\n        key = ET.SubElement(data_store, \"key\")\n        key.text = kwargs.pop('key')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the key for the webui data stores data store"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef webui_data_stores_data_store_value(self, **kwargs):\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        data_stores = ET.SubElement(webui, \"data-stores\")\n        data_store = ET.SubElement(data_stores, \"data-store\")\n        key_key = ET.SubElement(data_store, \"key\")\n        key_key.text = kwargs.pop('key')\n        value = ET.SubElement(data_store, \"value\")\n        value.text = kwargs.pop('value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the value of the webui data - stores data - store key."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the key for the webui data stores saved query key.", "response": "def webui_data_stores_saved_query_key(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        webui = ET.SubElement(config, \"webui\", xmlns=\"http://tail-f.com/ns/webui\")\n        data_stores = ET.SubElement(webui, \"data-stores\")\n        saved_query = ET.SubElement(data_stores, \"saved-query\")\n        key = ET.SubElement(saved_query, \"key\")\n        key.text = kwargs.pop('key')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\noverriding the create method to add the user s id to the request data", "response": "async def create(self, **kwargs):\n        ''' Override the create method to add the user's id to the request data '''\n        return await super(EntryResource, self).create(user=self.request['user'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nenables or disables Spanning Tree Autoupload.", "response": "def enable_support_autoupload(self, **kwargs):\n        \"\"\"Set Spanning Tree state.\n\n        Args:\n            enabled (bool): Is Autoupload enabled? (True, False).\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n        Examples:\n                >>> import pynos.device\n                >>> switches = ['10.24.39.211', '10.24.39.203']\n                >>> auth = ('admin', 'password')\n                >>> for switch in switches:\n                ...     conn = (switch, '22')\n                ...     with pynos.device.Device(conn=conn, auth=auth) as dev:\n                ...         enabled = True\n                ...         output = dev.ras.enable_support_autoupload(\n                ...         enabled=enabled)\n                ...         enabled = False\n                ...         output = dev.ras.enable_support_autoupload(\n                ...         enabled=enabled)\n        \"\"\"\n        enabled = kwargs.pop('enabled')\n        callback = kwargs.pop('callback', self._callback)\n\n        if not isinstance(enabled, bool):\n            raise ValueError('%s must be `True` or `False`.' % repr(enabled))\n\n        state_args = dict()\n        autoupload_state = getattr(self._ras, 'support_autoupload_enable')\n        config = autoupload_state(**state_args)\n        if not enabled:\n            shutdown = config.find('.//*enable')\n            shutdown.set('operation', 'delete')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef igmp_snooping_ip_igmp_snooping_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        igmp_snooping = ET.SubElement(config, \"igmp-snooping\", xmlns=\"urn:brocade.com:mgmt:brocade-igmp-snooping\")\n        ip = ET.SubElement(igmp_snooping, \"ip\")\n        igmp = ET.SubElement(ip, \"igmp\")\n        snooping = ET.SubElement(igmp, \"snooping\")\n        enable = ET.SubElement(snooping, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enables or disables IGMP snooping for the current ip."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the related resource from the VLAN classifier rule ruleid", "response": "def vlan_classifier_rule_ruleid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vlan = ET.SubElement(config, \"vlan\", xmlns=\"urn:brocade.com:mgmt:brocade-vlan\")\n        classifier = ET.SubElement(vlan, \"classifier\")\n        rule = ET.SubElement(classifier, \"rule\")\n        ruleid = ET.SubElement(rule, \"ruleid\")\n        ruleid.text = kwargs.pop('ruleid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a new entry in the hierarchy for a specific rule type and MAC address.", "response": "def vlan_classifier_rule_class_type_mac_mac_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vlan = ET.SubElement(config, \"vlan\", xmlns=\"urn:brocade.com:mgmt:brocade-vlan\")\n        classifier = ET.SubElement(vlan, \"classifier\")\n        rule = ET.SubElement(classifier, \"rule\")\n        ruleid_key = ET.SubElement(rule, \"ruleid\")\n        ruleid_key.text = kwargs.pop('ruleid')\n        class_type = ET.SubElement(rule, \"class-type\")\n        mac = ET.SubElement(class_type, \"mac\")\n        mac = ET.SubElement(mac, \"mac\")\n        address = ET.SubElement(mac, \"address\")\n        address.text = kwargs.pop('address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a new entry in the VLAN Classifier Rule Class Type and Protocol Value.", "response": "def vlan_classifier_rule_class_type_proto_proto_proto_val(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vlan = ET.SubElement(config, \"vlan\", xmlns=\"urn:brocade.com:mgmt:brocade-vlan\")\n        classifier = ET.SubElement(vlan, \"classifier\")\n        rule = ET.SubElement(classifier, \"rule\")\n        ruleid_key = ET.SubElement(rule, \"ruleid\")\n        ruleid_key.text = kwargs.pop('ruleid')\n        class_type = ET.SubElement(rule, \"class-type\")\n        proto = ET.SubElement(class_type, \"proto\")\n        proto = ET.SubElement(proto, \"proto\")\n        proto_val = ET.SubElement(proto, \"proto-val\")\n        proto_val.text = kwargs.pop('proto_val')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a new cache entry for a VLAN classifier group group.", "response": "def vlan_classifier_group_groupid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vlan = ET.SubElement(config, \"vlan\", xmlns=\"urn:brocade.com:mgmt:brocade-vlan\")\n        classifier = ET.SubElement(vlan, \"classifier\")\n        group = ET.SubElement(classifier, \"group\")\n        oper_key = ET.SubElement(group, \"oper\")\n        oper_key.text = kwargs.pop('oper')\n        rule_name_key = ET.SubElement(group, \"rule-name\")\n        rule_name_key.text = kwargs.pop('rule_name')\n        ruleid_key = ET.SubElement(group, \"ruleid\")\n        ruleid_key.text = kwargs.pop('ruleid')\n        groupid = ET.SubElement(group, \"groupid\")\n        groupid.text = kwargs.pop('groupid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vlan_classifier_group_oper(self, **kwargs):\n        config = ET.Element(\"config\")\n        vlan = ET.SubElement(config, \"vlan\", xmlns=\"urn:brocade.com:mgmt:brocade-vlan\")\n        classifier = ET.SubElement(vlan, \"classifier\")\n        group = ET.SubElement(classifier, \"group\")\n        groupid_key = ET.SubElement(group, \"groupid\")\n        groupid_key.text = kwargs.pop('groupid')\n        rule_name_key = ET.SubElement(group, \"rule-name\")\n        rule_name_key.text = kwargs.pop('rule_name')\n        ruleid_key = ET.SubElement(group, \"ruleid\")\n        ruleid_key.text = kwargs.pop('ruleid')\n        oper = ET.SubElement(group, \"oper\")\n        oper.text = kwargs.pop('oper')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current state of the group based on the operation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the name of the rule in the group of a VLAN classifier.", "response": "def vlan_classifier_group_rule_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vlan = ET.SubElement(config, \"vlan\", xmlns=\"urn:brocade.com:mgmt:brocade-vlan\")\n        classifier = ET.SubElement(vlan, \"classifier\")\n        group = ET.SubElement(classifier, \"group\")\n        groupid_key = ET.SubElement(group, \"groupid\")\n        groupid_key.text = kwargs.pop('groupid')\n        oper_key = ET.SubElement(group, \"oper\")\n        oper_key.text = kwargs.pop('oper')\n        ruleid_key = ET.SubElement(group, \"ruleid\")\n        ruleid_key.text = kwargs.pop('ruleid')\n        rule_name = ET.SubElement(group, \"rule-name\")\n        rule_name.text = kwargs.pop('rule_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the related object from the vlan classifier group ruleid.", "response": "def vlan_classifier_group_ruleid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vlan = ET.SubElement(config, \"vlan\", xmlns=\"urn:brocade.com:mgmt:brocade-vlan\")\n        classifier = ET.SubElement(vlan, \"classifier\")\n        group = ET.SubElement(classifier, \"group\")\n        groupid_key = ET.SubElement(group, \"groupid\")\n        groupid_key.text = kwargs.pop('groupid')\n        oper_key = ET.SubElement(group, \"oper\")\n        oper_key.text = kwargs.pop('oper')\n        rule_name_key = ET.SubElement(group, \"rule-name\")\n        rule_name_key.text = kwargs.pop('rule_name')\n        ruleid = ET.SubElement(group, \"ruleid\")\n        ruleid.text = kwargs.pop('ruleid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vlan_dot1q_tag_native(self, **kwargs):\n        config = ET.Element(\"config\")\n        vlan = ET.SubElement(config, \"vlan\", xmlns=\"urn:brocade.com:mgmt:brocade-vlan\")\n        dot1q = ET.SubElement(vlan, \"dot1q\")\n        tag = ET.SubElement(dot1q, \"tag\")\n        native = ET.SubElement(tag, \"native\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current version of the tag for the dot1q entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def consume_events(self):\n        ''' begin listening to messages that were entered after starting'''\n        # begin by making sure the channel is created\n        await self.create_channel()\n        # get cursor method\n        def create_cursor():\n            now = datetime.datetime.utcnow()\n            dummy_id = ObjectId.from_datetime(now)\n            return self._collection.find({'_id': {'$gte': dummy_id}}, cursor_type=CursorType.TAILABLE_AWAIT)\n        # get cursor and start the loop\n        cursor = create_cursor()\n        while self.active:\n            if cursor.alive:\n                if (await cursor.fetch_next):\n                    message = cursor.next_object()\n                    event = message['key']\n                    data = message['data']\n                    logger.debug('event: %s - %s', event, data)\n                    for sub in self._subscribers[event]:\n                        await sub.deliver({'type': 'event', 'payload': {'name': event, 'data': data}})\n            else:\n                await asyncio.sleep(0.1)\n                cursor = create_cursor()", "response": "listen to messages that were entered after starting"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting VLAN Birthday input request type get request vlan id", "response": "def get_vlan_brief_input_request_type_get_request_vlan_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        input = ET.SubElement(get_vlan_brief, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        vlan_id = ET.SubElement(get_request, \"vlan-id\")\n        vlan_id.text = kwargs.pop('vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets Next Request for VLAN level", "response": "def get_vlan_brief_input_request_type_get_next_request_last_rcvd_vlan_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        input = ET.SubElement(get_vlan_brief, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        last_rcvd_vlan_id = ET.SubElement(get_next_request, \"last-rcvd-vlan-id\")\n        last_rcvd_vlan_id.text = kwargs.pop('last_rcvd_vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets VLAN Brief output configured vlans count.", "response": "def get_vlan_brief_output_configured_vlans_count(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        configured_vlans_count = ET.SubElement(output, \"configured-vlans-count\")\n        configured_vlans_count.text = kwargs.pop('configured_vlans_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget VLAN Brief output of provisioning vlans count.", "response": "def get_vlan_brief_output_provisioned_vlans_count(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        provisioned_vlans_count = ET.SubElement(output, \"provisioned-vlans-count\")\n        provisioned_vlans_count.text = kwargs.pop('provisioned_vlans_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget VLAN Brief output unprovisioned vlans count.", "response": "def get_vlan_brief_output_unprovisioned_vlans_count(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        unprovisioned_vlans_count = ET.SubElement(output, \"unprovisioned-vlans-count\")\n        unprovisioned_vlans_count.text = kwargs.pop('unprovisioned_vlans_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_vlan_brief_output_vlan_vlan_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        vlan = ET.SubElement(output, \"vlan\")\n        vlan_id = ET.SubElement(vlan, \"vlan-id\")\n        vlan_id.text = kwargs.pop('vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VLAN Bold output VLAN ID"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_vlan_brief_output_vlan_vlan_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        vlan = ET.SubElement(output, \"vlan\")\n        vlan_id_key = ET.SubElement(vlan, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        vlan_type = ET.SubElement(vlan, \"vlan-type\")\n        vlan_type.text = kwargs.pop('vlan_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VLAN Bold output VLAN Type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vlan_brief_output_vlan_vlan_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        vlan = ET.SubElement(output, \"vlan\")\n        vlan_id_key = ET.SubElement(vlan, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        vlan_name = ET.SubElement(vlan, \"vlan-name\")\n        vlan_name.text = kwargs.pop('vlan_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VLAN Bold output VLAN Name"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting VLAN Birthday output VLAN State", "response": "def get_vlan_brief_output_vlan_vlan_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        vlan = ET.SubElement(output, \"vlan\")\n        vlan_id_key = ET.SubElement(vlan, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        vlan_state = ET.SubElement(vlan, \"vlan-state\")\n        vlan_state.text = kwargs.pop('vlan_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget VLAN Birthday output VLAN interface type.", "response": "def get_vlan_brief_output_vlan_interface_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        vlan = ET.SubElement(output, \"vlan\")\n        vlan_id_key = ET.SubElement(vlan, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        interface = ET.SubElement(vlan, \"interface\")\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        interface_type = ET.SubElement(interface, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vlan_brief_output_vlan_interface_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        vlan = ET.SubElement(output, \"vlan\")\n        vlan_id_key = ET.SubElement(vlan, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        interface = ET.SubElement(vlan, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name = ET.SubElement(interface, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VLAN Birthday output VLAN interface name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vlan_brief_output_vlan_interface_tag(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        vlan = ET.SubElement(output, \"vlan\")\n        vlan_id_key = ET.SubElement(vlan, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        interface = ET.SubElement(vlan, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        tag = ET.SubElement(interface, \"tag\")\n        tag.text = kwargs.pop('tag')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VLAN Birthday output VLAN interface tag."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_vlan_brief_output_vlan_interface_classification_classification_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        vlan = ET.SubElement(output, \"vlan\")\n        vlan_id_key = ET.SubElement(vlan, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        interface = ET.SubElement(vlan, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        classification = ET.SubElement(interface, \"classification\")\n        classification_value_key = ET.SubElement(classification, \"classification-value\")\n        classification_value_key.text = kwargs.pop('classification_value')\n        classification_type = ET.SubElement(classification, \"classification-type\")\n        classification_type.text = kwargs.pop('classification_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VLAN Birthday output VLAN interface classification type"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_vlan_brief_output_vlan_interface_classification_classification_value(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        vlan = ET.SubElement(output, \"vlan\")\n        vlan_id_key = ET.SubElement(vlan, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        interface = ET.SubElement(vlan, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        classification = ET.SubElement(interface, \"classification\")\n        classification_type_key = ET.SubElement(classification, \"classification-type\")\n        classification_type_key.text = kwargs.pop('classification_type')\n        classification_value = ET.SubElement(classification, \"classification-value\")\n        classification_value.text = kwargs.pop('classification_value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VLAN Birthday output VLAN interface classification value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vlan_brief_output_last_vlan_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        last_vlan_id = ET.SubElement(output, \"last-vlan-id\")\n        last_vlan_id.text = kwargs.pop('last_vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VLAN Birthday output last vlan id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting VLAN Birthday output has - more.", "response": "def get_vlan_brief_output_has_more(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vlan_brief = ET.Element(\"get_vlan_brief\")\n        config = get_vlan_brief\n        output = ET.SubElement(get_vlan_brief, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting switchport output switchport interface type.", "response": "def get_interface_switchport_output_switchport_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_switchport = ET.Element(\"get_interface_switchport\")\n        config = get_interface_switchport\n        output = ET.SubElement(get_interface_switchport, \"output\")\n        switchport = ET.SubElement(output, \"switchport\")\n        interface_name_key = ET.SubElement(switchport, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        interface_type = ET.SubElement(switchport, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets switchport output switchport interface name", "response": "def get_interface_switchport_output_switchport_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_switchport = ET.Element(\"get_interface_switchport\")\n        config = get_interface_switchport\n        output = ET.SubElement(get_interface_switchport, \"output\")\n        switchport = ET.SubElement(output, \"switchport\")\n        interface_type_key = ET.SubElement(switchport, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name = ET.SubElement(switchport, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_interface_switchport_output_switchport_mode(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_switchport = ET.Element(\"get_interface_switchport\")\n        config = get_interface_switchport\n        output = ET.SubElement(get_interface_switchport, \"output\")\n        switchport = ET.SubElement(output, \"switchport\")\n        interface_type_key = ET.SubElement(switchport, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(switchport, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        mode = ET.SubElement(switchport, \"mode\")\n        mode.text = kwargs.pop('mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Switchport output switchport mode."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting Interface Switchport output switchport fcoe - port enabled.", "response": "def get_interface_switchport_output_switchport_fcoe_port_enabled(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_switchport = ET.Element(\"get_interface_switchport\")\n        config = get_interface_switchport\n        output = ET.SubElement(get_interface_switchport, \"output\")\n        switchport = ET.SubElement(output, \"switchport\")\n        interface_type_key = ET.SubElement(switchport, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(switchport, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        fcoe_port_enabled = ET.SubElement(switchport, \"fcoe-port-enabled\")\n        fcoe_port_enabled.text = kwargs.pop('fcoe_port_enabled')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting switchport output switchport ingress filter enabled status.", "response": "def get_interface_switchport_output_switchport_ingress_filter_enabled(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_switchport = ET.Element(\"get_interface_switchport\")\n        config = get_interface_switchport\n        output = ET.SubElement(get_interface_switchport, \"output\")\n        switchport = ET.SubElement(output, \"switchport\")\n        interface_type_key = ET.SubElement(switchport, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(switchport, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ingress_filter_enabled = ET.SubElement(switchport, \"ingress-filter-enabled\")\n        ingress_filter_enabled.text = kwargs.pop('ingress_filter_enabled')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_interface_switchport_output_switchport_acceptable_frame_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_switchport = ET.Element(\"get_interface_switchport\")\n        config = get_interface_switchport\n        output = ET.SubElement(get_interface_switchport, \"output\")\n        switchport = ET.SubElement(output, \"switchport\")\n        interface_type_key = ET.SubElement(switchport, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(switchport, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        acceptable_frame_type = ET.SubElement(switchport, \"acceptable-frame-type\")\n        acceptable_frame_type.text = kwargs.pop('acceptable_frame_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Switchport output switchport acceptable frame type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting Interface Switchport output switchport default vlan.", "response": "def get_interface_switchport_output_switchport_default_vlan(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_switchport = ET.Element(\"get_interface_switchport\")\n        config = get_interface_switchport\n        output = ET.SubElement(get_interface_switchport, \"output\")\n        switchport = ET.SubElement(output, \"switchport\")\n        interface_type_key = ET.SubElement(switchport, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(switchport, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        default_vlan = ET.SubElement(switchport, \"default-vlan\")\n        default_vlan.text = kwargs.pop('default_vlan')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget IP Interface input request type get request interface type", "response": "def get_ip_interface_input_request_type_get_request_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        input = ET.SubElement(get_ip_interface, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        interface_type = ET.SubElement(get_request, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ip_interface_input_request_type_get_request_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        input = ET.SubElement(get_ip_interface, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        interface_name = ET.SubElement(get_request, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get IP Interface input request type and get request interface name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_ip_interface_input_request_type_get_request_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        input = ET.SubElement(get_ip_interface, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        rbridge_id = ET.SubElement(get_request, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get IP Interface input request type get request rbridge id"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_ip_interface_output_interface_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        output = ET.SubElement(get_ip_interface, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        interface_type = ET.SubElement(interface, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the IP interface output interface type."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ip_interface_output_interface_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        output = ET.SubElement(get_ip_interface, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name = ET.SubElement(interface, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the IP interface output interface name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the IP interface output for a specific interface if name.", "response": "def get_ip_interface_output_interface_if_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        output = ET.SubElement(get_ip_interface, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        if_name = ET.SubElement(interface, \"if-name\")\n        if_name.text = kwargs.pop('if_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the IP interface output and return the config.", "response": "def get_ip_interface_output_interface_ip_address_ipv4(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        output = ET.SubElement(get_ip_interface, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ip_address = ET.SubElement(interface, \"ip-address\")\n        ipv4 = ET.SubElement(ip_address, \"ipv4\")\n        ipv4.text = kwargs.pop('ipv4')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the IP interface output and interface ip - address broadcast.", "response": "def get_ip_interface_output_interface_ip_address_broadcast(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        output = ET.SubElement(get_ip_interface, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ip_address = ET.SubElement(interface, \"ip-address\")\n        ipv4_key = ET.SubElement(ip_address, \"ipv4\")\n        ipv4_key.text = kwargs.pop('ipv4')\n        broadcast = ET.SubElement(ip_address, \"broadcast\")\n        broadcast.text = kwargs.pop('broadcast')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_ip_interface_output_interface_if_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        output = ET.SubElement(get_ip_interface, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        if_state = ET.SubElement(interface, \"if-state\")\n        if_state.text = kwargs.pop('if_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the IP interface output for a specific if state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting IP interface output interface line protocol state", "response": "def get_ip_interface_output_interface_line_protocol_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        output = ET.SubElement(get_ip_interface, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        line_protocol_state = ET.SubElement(interface, \"line-protocol-state\")\n        line_protocol_state.text = kwargs.pop('line_protocol_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ip_interface_output_interface_proxy_arp(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        output = ET.SubElement(get_ip_interface, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        proxy_arp = ET.SubElement(interface, \"proxy-arp\")\n        proxy_arp.text = kwargs.pop('proxy_arp')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get IP interface output interface and proxy ARP."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the IP interface output interface VRF.", "response": "def get_ip_interface_output_interface_vrf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        output = ET.SubElement(get_ip_interface, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        vrf = ET.SubElement(interface, \"vrf\")\n        vrf.text = kwargs.pop('vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the IP interface output has - more.", "response": "def get_ip_interface_output_has_more(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_ip_interface = ET.Element(\"get_ip_interface\")\n        config = get_ip_interface\n        output = ET.SubElement(get_ip_interface, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting Interface Information for a specific resource.", "response": "def get_interface_detail_input_request_type_get_request_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        input = ET.SubElement(get_interface_detail, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        interface_type = ET.SubElement(get_request, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Interface Information for Classes and Request Types", "response": "def get_interface_detail_input_request_type_get_request_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        input = ET.SubElement(get_interface_detail, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        interface_name = ET.SubElement(get_request, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Interface Information for Classes and Request Types.", "response": "def get_interface_detail_input_request_type_get_next_request_last_rcvd_interface_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        input = ET.SubElement(get_interface_detail, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        last_rcvd_interface = ET.SubElement(get_next_request, \"last-rcvd-interface\")\n        interface_type = ET.SubElement(last_rcvd_interface, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Interface Information for Classes and Request Types.", "response": "def get_interface_detail_input_request_type_get_next_request_last_rcvd_interface_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        input = ET.SubElement(get_interface_detail, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        last_rcvd_interface = ET.SubElement(get_next_request, \"last-rcvd-interface\")\n        interface_name = ET.SubElement(last_rcvd_interface, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_interface_detail_output_interface_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        interface_type = ET.SubElement(interface, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Detail Output Interface Type"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets Interface Detail Output Interface Name", "response": "def get_interface_detail_output_interface_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name = ET.SubElement(interface, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget Interface Detail Output Interface Ifindex", "response": "def get_interface_detail_output_interface_ifindex(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ifindex = ET.SubElement(interface, \"ifindex\")\n        ifindex.text = kwargs.pop('ifindex')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_interface_detail_output_interface_mtu(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        mtu = ET.SubElement(interface, \"mtu\")\n        mtu.text = kwargs.pop('mtu')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Detail Output Method"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets Interface Detail Output Interface IP MTU", "response": "def get_interface_detail_output_interface_ip_mtu(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ip_mtu = ET.SubElement(interface, \"ip-mtu\")\n        ip_mtu.text = kwargs.pop('ip_mtu')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget Interface Detail Output Interface If Name", "response": "def get_interface_detail_output_interface_if_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        if_name = ET.SubElement(interface, \"if-name\")\n        if_name.text = kwargs.pop('if_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_interface_detail_output_interface_if_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        if_state = ET.SubElement(interface, \"if-state\")\n        if_state.text = kwargs.pop('if_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Information from Get Interface detail output."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_interface_detail_output_interface_line_protocol_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        line_protocol_state = ET.SubElement(interface, \"line-protocol-state\")\n        line_protocol_state.text = kwargs.pop('line_protocol_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Information from Get Interface Details"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Interface Information from Get Interface Detail output of Line Protocol State Info", "response": "def get_interface_detail_output_interface_line_protocol_state_info(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        line_protocol_state_info = ET.SubElement(interface, \"line-protocol-state-info\")\n        line_protocol_state_info.text = kwargs.pop('line_protocol_state_info')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_interface_detail_output_interface_line_protocol_exception_info(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        line_protocol_exception_info = ET.SubElement(interface, \"line-protocol-exception-info\")\n        line_protocol_exception_info.text = kwargs.pop('line_protocol_exception_info')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Information from Get Interface Detail output of Line Protocol Exception Info"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_interface_detail_output_interface_hardware_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        hardware_type = ET.SubElement(interface, \"hardware-type\")\n        hardware_type.text = kwargs.pop('hardware_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Detail Output Interface Hardware Type"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting Interface Information from Get Interface Detail output of Get Interface", "response": "def get_interface_detail_output_interface_logical_hardware_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        logical_hardware_address = ET.SubElement(interface, \"logical-hardware-address\")\n        logical_hardware_address.text = kwargs.pop('logical_hardware_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget Interface Information from Get Interface Details", "response": "def get_interface_detail_output_interface_current_hardware_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        current_hardware_address = ET.SubElement(interface, \"current-hardware-address\")\n        current_hardware_address.text = kwargs.pop('current_hardware_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_interface_detail_output_interface_media_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        media_type = ET.SubElement(interface, \"media-type\")\n        media_type.text = kwargs.pop('media_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Detail Output Interface Media Type"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets Interface Detail output of Get Interface and Wavelength", "response": "def get_interface_detail_output_interface_wavelength(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        wavelength = ET.SubElement(interface, \"wavelength\")\n        wavelength.text = kwargs.pop('wavelength')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_interface_detail_output_interface_if_description(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        if_description = ET.SubElement(interface, \"if-description\")\n        if_description.text = kwargs.pop('if_description')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Detail Output Interface If Description"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Interface Information from Get Interface Detail output of Resource Entry.", "response": "def get_interface_detail_output_interface_actual_line_speed(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        actual_line_speed = ET.SubElement(interface, \"actual-line-speed\")\n        actual_line_speed.text = kwargs.pop('actual_line_speed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets Interface Information from Get Interface Detail output of Any Resource.", "response": "def get_interface_detail_output_interface_configured_line_speed(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        configured_line_speed = ET.SubElement(interface, \"configured-line-speed\")\n        configured_line_speed.text = kwargs.pop('configured_line_speed')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting Interface Information from Line Duplex State", "response": "def get_interface_detail_output_interface_line_duplex_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        line_duplex_state = ET.SubElement(interface, \"line-duplex-state\")\n        line_duplex_state.text = kwargs.pop('line_duplex_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets Interface Detail Output Interface Flow Control", "response": "def get_interface_detail_output_interface_flow_control(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        flow_control = ET.SubElement(interface, \"flow-control\")\n        flow_control.text = kwargs.pop('flow_control')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget Interface Detail Output Interface queuing Strategy", "response": "def get_interface_detail_output_interface_queuing_strategy(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        queuing_strategy = ET.SubElement(interface, \"queuing-strategy\")\n        queuing_strategy.text = kwargs.pop('queuing_strategy')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget Interface Information from Get Interface Detail output.", "response": "def get_interface_detail_output_interface_port_role(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        port_role = ET.SubElement(interface, \"port-role\")\n        port_role.text = kwargs.pop('port_role')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_interface_detail_output_interface_port_mode(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        port_mode = ET.SubElement(interface, \"port-mode\")\n        port_mode.text = kwargs.pop('port_mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Detail Output Interface Port Mode"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_interface_detail_output_interface_ifHCInOctets(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ifHCInOctets = ET.SubElement(interface, \"ifHCInOctets\")\n        ifHCInOctets.text = kwargs.pop('ifHCInOctets')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Information from Get Interface Detail output."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets Interface Information from Get Interface Detail output.", "response": "def get_interface_detail_output_interface_ifHCInUcastPkts(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ifHCInUcastPkts = ET.SubElement(interface, \"ifHCInUcastPkts\")\n        ifHCInUcastPkts.text = kwargs.pop('ifHCInUcastPkts')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_interface_detail_output_interface_ifHCInMulticastPkts(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ifHCInMulticastPkts = ET.SubElement(interface, \"ifHCInMulticastPkts\")\n        ifHCInMulticastPkts.text = kwargs.pop('ifHCInMulticastPkts')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Information from Get Interface Detail output."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Interface Information from Get Interface Detail output.", "response": "def get_interface_detail_output_interface_ifHCInBroadcastPkts(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ifHCInBroadcastPkts = ET.SubElement(interface, \"ifHCInBroadcastPkts\")\n        ifHCInBroadcastPkts.text = kwargs.pop('ifHCInBroadcastPkts')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting Interface Information from Get Interface Detail output.", "response": "def get_interface_detail_output_interface_ifHCInErrors(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ifHCInErrors = ET.SubElement(interface, \"ifHCInErrors\")\n        ifHCInErrors.text = kwargs.pop('ifHCInErrors')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget Interface Information from Get Interface Detail output of IfHC Out Octets", "response": "def get_interface_detail_output_interface_ifHCOutOctets(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ifHCOutOctets = ET.SubElement(interface, \"ifHCOutOctets\")\n        ifHCOutOctets.text = kwargs.pop('ifHCOutOctets')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_interface_detail_output_interface_ifHCOutUcastPkts(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ifHCOutUcastPkts = ET.SubElement(interface, \"ifHCOutUcastPkts\")\n        ifHCOutUcastPkts.text = kwargs.pop('ifHCOutUcastPkts')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Information from Get Interface Detail output of IfHC Out Ucast PKT TPs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_interface_detail_output_interface_ifHCOutMulticastPkts(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ifHCOutMulticastPkts = ET.SubElement(interface, \"ifHCOutMulticastPkts\")\n        ifHCOutMulticastPkts.text = kwargs.pop('ifHCOutMulticastPkts')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Information from Get Interface Detail output interface ifHCOutMulticastPkts."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_interface_detail_output_interface_ifHCOutBroadcastPkts(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ifHCOutBroadcastPkts = ET.SubElement(interface, \"ifHCOutBroadcastPkts\")\n        ifHCOutBroadcastPkts.text = kwargs.pop('ifHCOutBroadcastPkts')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Information from Get Interface Detail output interface ifHCOutBroadcastPkts is set to 1."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets Interface Information from Get Interface Detail output of IfHC Out Errors", "response": "def get_interface_detail_output_interface_ifHCOutErrors(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ifHCOutErrors = ET.SubElement(interface, \"ifHCOutErrors\")\n        ifHCOutErrors.text = kwargs.pop('ifHCOutErrors')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_interface_detail_output_has_more(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_interface_detail = ET.Element(\"get_interface_detail\")\n        config = get_interface_detail\n        output = ET.SubElement(get_interface_detail, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Interface Detail output has - more."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets Media Detail input interface type.", "response": "def get_media_detail_input_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_media_detail = ET.Element(\"get_media_detail\")\n        config = get_media_detail\n        input = ET.SubElement(get_media_detail, \"input\")\n        interface_type = ET.SubElement(input, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting Media Detail input interface name.", "response": "def get_media_detail_input_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_media_detail = ET.Element(\"get_media_detail\")\n        config = get_media_detail\n        input = ET.SubElement(get_media_detail, \"input\")\n        interface_name = ET.SubElement(input, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_media_detail_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_media_detail = ET.Element(\"get_media_detail\")\n        config = get_media_detail\n        input = ET.SubElement(get_media_detail, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Media Detail input rbridge - id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting Media Detail output interface type.", "response": "def get_media_detail_output_interface_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_media_detail = ET.Element(\"get_media_detail\")\n        config = get_media_detail\n        output = ET.SubElement(get_media_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        interface_type = ET.SubElement(interface, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_media_detail_output_interface_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_media_detail = ET.Element(\"get_media_detail\")\n        config = get_media_detail\n        output = ET.SubElement(get_media_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name = ET.SubElement(interface, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Media Detail output interface and interface name."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the related resource from the Media Detail XML output and interface.", "response": "def get_media_detail_output_interface_interface_identifier_gbic_gbc_vendor_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_media_detail = ET.Element(\"get_media_detail\")\n        config = get_media_detail\n        output = ET.SubElement(get_media_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        interface_identifier = ET.SubElement(interface, \"interface-identifier\")\n        gbic = ET.SubElement(interface_identifier, \"gbic\")\n        gbc = ET.SubElement(gbic, \"gbc\")\n        vendor_name = ET.SubElement(gbc, \"vendor-name\")\n        vendor_name.text = kwargs.pop('vendor_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_media_detail_output_interface_interface_identifier_cfp2_cfp2_distance(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_media_detail = ET.Element(\"get_media_detail\")\n        config = get_media_detail\n        output = ET.SubElement(get_media_detail, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        interface_identifier = ET.SubElement(interface, \"interface-identifier\")\n        cfp2 = ET.SubElement(interface_identifier, \"cfp2\")\n        cfp2 = ET.SubElement(cfp2, \"cfp2\")\n        distance = ET.SubElement(cfp2, \"distance\")\n        distance.text = kwargs.pop('distance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the information of a specific class from the CFP2."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef firmware_autoupgrade_params_pss(self, **kwargs):\n        config = ET.Element(\"config\")\n        firmware = ET.SubElement(config, \"firmware\", xmlns=\"urn:brocade.com:mgmt:brocade-firmware\")\n        autoupgrade_params = ET.SubElement(firmware, \"autoupgrade-params\")\n        pss = ET.SubElement(autoupgrade_params, \"pass\")\n        pss.text = kwargs.pop('pss')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        autoupgrade params PSS"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of the CORE - DAG entry for the current firmware.", "response": "def firmware_download_input_coldboot(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        firmware_download = ET.Element(\"firmware_download\")\n        config = firmware_download\n        input = ET.SubElement(firmware_download, \"input\")\n        coldboot = ET.SubElement(input, \"coldboot\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_system_monitor_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        input = ET.SubElement(show_system_monitor, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show System Monitor input rbridge - id."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nshows System Monitor output switch status and rbridge - id - out.", "response": "def show_system_monitor_output_switch_status_rbridge_id_out(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        output = ET.SubElement(show_system_monitor, \"output\")\n        switch_status = ET.SubElement(output, \"switch-status\")\n        rbridge_id_out = ET.SubElement(switch_status, \"rbridge-id-out\")\n        rbridge_id_out.text = kwargs.pop('rbridge_id_out')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_system_monitor_output_switch_status_switch_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        output = ET.SubElement(show_system_monitor, \"output\")\n        switch_status = ET.SubElement(output, \"switch-status\")\n        switch_name = ET.SubElement(switch_status, \"switch-name\")\n        switch_name.text = kwargs.pop('switch_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show System Monitor output switch status and switch name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_system_monitor_output_switch_status_switch_ip(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        output = ET.SubElement(show_system_monitor, \"output\")\n        switch_status = ET.SubElement(output, \"switch-status\")\n        switch_ip = ET.SubElement(switch_status, \"switch-ip\")\n        switch_ip.text = kwargs.pop('switch_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show System Monitor related attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshows System Monitor output switch status report time.", "response": "def show_system_monitor_output_switch_status_report_time(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        output = ET.SubElement(show_system_monitor, \"output\")\n        switch_status = ET.SubElement(output, \"switch-status\")\n        report_time = ET.SubElement(switch_status, \"report-time\")\n        report_time.text = kwargs.pop('report_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_system_monitor_output_switch_status_switch_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        output = ET.SubElement(show_system_monitor, \"output\")\n        switch_status = ET.SubElement(output, \"switch-status\")\n        switch_state = ET.SubElement(switch_status, \"switch-state\")\n        switch_state.text = kwargs.pop('switch_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show System Monitor output switch status switch state"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_system_monitor_output_switch_status_switch_state_reason(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        output = ET.SubElement(show_system_monitor, \"output\")\n        switch_status = ET.SubElement(output, \"switch-status\")\n        switch_state_reason = ET.SubElement(switch_status, \"switch-state-reason\")\n        switch_state_reason.text = kwargs.pop('switch_state_reason')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show System Monitor output switch status and switch state reason."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshows System Monitor output switch status component status component name", "response": "def show_system_monitor_output_switch_status_component_status_component_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        output = ET.SubElement(show_system_monitor, \"output\")\n        switch_status = ET.SubElement(output, \"switch-status\")\n        component_status = ET.SubElement(switch_status, \"component-status\")\n        component_name = ET.SubElement(component_status, \"component-name\")\n        component_name.text = kwargs.pop('component_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_system_monitor_output_switch_status_component_status_component_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        output = ET.SubElement(show_system_monitor, \"output\")\n        switch_status = ET.SubElement(output, \"switch-status\")\n        component_status = ET.SubElement(switch_status, \"component-status\")\n        component_state = ET.SubElement(component_status, \"component-state\")\n        component_state.text = kwargs.pop('component_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show System Monitor output switch status component status component state"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_system_monitor_output_switch_status_port_status_port_area(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        output = ET.SubElement(show_system_monitor, \"output\")\n        switch_status = ET.SubElement(output, \"switch-status\")\n        port_status = ET.SubElement(switch_status, \"port-status\")\n        port_area = ET.SubElement(port_status, \"port-area\")\n        port_area.text = kwargs.pop('port_area')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show System Monitor output switch status port status and port area."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows System Monitor output switch status port status and port name.", "response": "def show_system_monitor_output_switch_status_port_status_port_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        output = ET.SubElement(show_system_monitor, \"output\")\n        switch_status = ET.SubElement(output, \"switch-status\")\n        port_status = ET.SubElement(switch_status, \"port-status\")\n        port_name = ET.SubElement(port_status, \"port-name\")\n        port_name.text = kwargs.pop('port_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_system_monitor_output_switch_status_port_status_port_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_system_monitor = ET.Element(\"show_system_monitor\")\n        config = show_system_monitor\n        output = ET.SubElement(show_system_monitor, \"output\")\n        switch_status = ET.SubElement(output, \"switch-status\")\n        port_status = ET.SubElement(switch_status, \"port-status\")\n        port_state = ET.SubElement(port_status, \"port-state\")\n        port_state.text = kwargs.pop('port_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show System Monitor output switch status port status and port state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def add_member(self, db, user):\n        ''' Adds a new user to the list of room members, if memeber doesn't exist already '''\n\n        # use model's pk as query\n        query = {self.primary_key: self.pk}\n        # push review\n        result = await db[self.get_collection_name()].update_one(\n            filter=query,\n            update={'$addToSet': {'members': DBRefField(User).to_python(user)}},\n        )\n        return result", "response": "Adds a new user to the list of room members if it doesn t exist already"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting allow and non - profiledmacs from a port - profile", "response": "def port_profile_allow_nonprofiledmacs(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        allow = ET.SubElement(port_profile, \"allow\")\n        nonprofiledmacs = ET.SubElement(allow, \"nonprofiledmacs\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef port_profile_vlan_profile_switchport_basic_basic(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport_basic = ET.SubElement(vlan_profile, \"switchport-basic\")\n        basic = ET.SubElement(switchport_basic, \"basic\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current configuration of a switchport basic"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a new entry in the cache for a switchport mode and vlan mode", "response": "def port_profile_vlan_profile_switchport_mode_vlan_mode(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport = ET.SubElement(vlan_profile, \"switchport\")\n        mode = ET.SubElement(switchport, \"mode\")\n        vlan_mode = ET.SubElement(mode, \"vlan-mode\")\n        vlan_mode.text = kwargs.pop('vlan_mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a new entry in the NIC s VLAN profile switchport access vlan name", "response": "def port_profile_vlan_profile_switchport_access_vlan_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport = ET.SubElement(vlan_profile, \"switchport\")\n        access = ET.SubElement(switchport, \"access\")\n        vlan = ET.SubElement(access, \"vlan\")\n        name = ET.SubElement(vlan, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a new entry in the cache for a switchport access mac vlan classification access vlan id", "response": "def port_profile_vlan_profile_switchport_access_mac_vlan_classification_access_vlan_access_vlan_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport = ET.SubElement(vlan_profile, \"switchport\")\n        access_mac_vlan_classification = ET.SubElement(switchport, \"access-mac-vlan-classification\")\n        access = ET.SubElement(access_mac_vlan_classification, \"access\")\n        vlan = ET.SubElement(access, \"vlan\")\n        access_mac_address_key = ET.SubElement(vlan, \"access-mac-address\")\n        access_mac_address_key.text = kwargs.pop('access_mac_address')\n        access_vlan_id = ET.SubElement(vlan, \"access-vlan-id\")\n        access_vlan_id.text = kwargs.pop('access_vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef port_profile_vlan_profile_switchport_access_mac_vlan_classification_access_vlan_access_mac_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport = ET.SubElement(vlan_profile, \"switchport\")\n        access_mac_vlan_classification = ET.SubElement(switchport, \"access-mac-vlan-classification\")\n        access = ET.SubElement(access_mac_vlan_classification, \"access\")\n        vlan = ET.SubElement(access, \"vlan\")\n        access_vlan_id_key = ET.SubElement(vlan, \"access-vlan-id\")\n        access_vlan_id_key.text = kwargs.pop('access_vlan_id')\n        access_mac_address = ET.SubElement(vlan, \"access-mac-address\")\n        access_mac_address.text = kwargs.pop('access_mac_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new entry in the cache for a switchport access MAC VLAN classification and access MAC address."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef port_profile_vlan_profile_switchport_access_mac_group_vlan_classification_access_vlan_access_vlan_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport = ET.SubElement(vlan_profile, \"switchport\")\n        access_mac_group_vlan_classification = ET.SubElement(switchport, \"access-mac-group-vlan-classification\")\n        access = ET.SubElement(access_mac_group_vlan_classification, \"access\")\n        vlan = ET.SubElement(access, \"vlan\")\n        access_mac_group_key = ET.SubElement(vlan, \"access-mac-group\")\n        access_mac_group_key.text = kwargs.pop('access_mac_group')\n        access_vlan_id = ET.SubElement(vlan, \"access-vlan-id\")\n        access_vlan_id.text = kwargs.pop('access_vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new entry in the cache for a switchport vlan - profile switchport - access - mac - group - vlan - classification - access - vlan - id"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a new entry in the cache for a switchport vlan - profile switchport - access - mac - group vlan - classification access - vlan - access - mac - group", "response": "def port_profile_vlan_profile_switchport_access_mac_group_vlan_classification_access_vlan_access_mac_group(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport = ET.SubElement(vlan_profile, \"switchport\")\n        access_mac_group_vlan_classification = ET.SubElement(switchport, \"access-mac-group-vlan-classification\")\n        access = ET.SubElement(access_mac_group_vlan_classification, \"access\")\n        vlan = ET.SubElement(access, \"vlan\")\n        access_vlan_id_key = ET.SubElement(vlan, \"access-vlan-id\")\n        access_vlan_id_key.text = kwargs.pop('access_vlan_id')\n        access_mac_group = ET.SubElement(vlan, \"access-mac-group\")\n        access_mac_group.text = kwargs.pop('access_mac_group')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the config of a specific port profile vlan profile switchport trunk allowed vlan all", "response": "def port_profile_vlan_profile_switchport_trunk_allowed_vlan_all(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport = ET.SubElement(vlan_profile, \"switchport\")\n        trunk = ET.SubElement(switchport, \"trunk\")\n        allowed = ET.SubElement(trunk, \"allowed\")\n        vlan = ET.SubElement(allowed, \"vlan\")\n        all = ET.SubElement(vlan, \"all\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a new trunk - vlan - id to a switchport - trunk - vlan - classification - allowed - vlan - add - trunk - vlan - id", "response": "def port_profile_vlan_profile_switchport_trunk_trunk_vlan_classification_allowed_vlan_add_trunk_vlan_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport = ET.SubElement(vlan_profile, \"switchport\")\n        trunk = ET.SubElement(switchport, \"trunk\")\n        trunk_vlan_classification = ET.SubElement(trunk, \"trunk-vlan-classification\")\n        allowed = ET.SubElement(trunk_vlan_classification, \"allowed\")\n        vlan = ET.SubElement(allowed, \"vlan\")\n        add = ET.SubElement(vlan, \"add\")\n        trunk_ctag_id_key = ET.SubElement(add, \"trunk-ctag-id\")\n        trunk_ctag_id_key.text = kwargs.pop('trunk_ctag_id')\n        trunk_vlan_id = ET.SubElement(add, \"trunk-vlan-id\")\n        trunk_vlan_id.text = kwargs.pop('trunk_vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a new trunk - ctag to a switchport - trunk - vlan - classification allowed - vlan - add trunk - ctag - id", "response": "def port_profile_vlan_profile_switchport_trunk_trunk_vlan_classification_allowed_vlan_add_trunk_ctag_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport = ET.SubElement(vlan_profile, \"switchport\")\n        trunk = ET.SubElement(switchport, \"trunk\")\n        trunk_vlan_classification = ET.SubElement(trunk, \"trunk-vlan-classification\")\n        allowed = ET.SubElement(trunk_vlan_classification, \"allowed\")\n        vlan = ET.SubElement(allowed, \"vlan\")\n        add = ET.SubElement(vlan, \"add\")\n        trunk_vlan_id_key = ET.SubElement(add, \"trunk-vlan-id\")\n        trunk_vlan_id_key.text = kwargs.pop('trunk_vlan_id')\n        trunk_ctag_id = ET.SubElement(add, \"trunk-ctag-id\")\n        trunk_ctag_id.text = kwargs.pop('trunk_ctag_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef port_profile_vlan_profile_switchport_trunk_native_vlan_classification_native_vlan_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport = ET.SubElement(vlan_profile, \"switchport\")\n        trunk = ET.SubElement(switchport, \"trunk\")\n        native_vlan_classification = ET.SubElement(trunk, \"native-vlan-classification\")\n        native_vlan_id = ET.SubElement(native_vlan_classification, \"native-vlan-id\")\n        native_vlan_id.text = kwargs.pop('native_vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new entry in the NIC s switchport vlan - profile trunk native - vlan - classification native - vlan - id"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef port_profile_vlan_profile_switchport_trunk_native_vlan(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        vlan_profile = ET.SubElement(port_profile, \"vlan-profile\")\n        switchport = ET.SubElement(vlan_profile, \"switchport\")\n        trunk = ET.SubElement(switchport, \"trunk\")\n        native_vlan = ET.SubElement(trunk, \"native-vlan\")\n        native_vlan.text = kwargs.pop('native_vlan')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new entry in the VLAN profile switchport trunk and native_vlan"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef port_profile_fcoe_profile_fcoeport_fcoe_map_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        fcoe_profile = ET.SubElement(port_profile, \"fcoe-profile\")\n        fcoeport = ET.SubElement(fcoe_profile, \"fcoeport\")\n        fcoe_map_name = ET.SubElement(fcoeport, \"fcoe-map-name\")\n        fcoe_map_name.text = kwargs.pop('fcoe_map_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new FCoE profile and FCoE port - class"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a new config element for the port profile qos profile and cee", "response": "def port_profile_qos_profile_cee(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        qos_profile = ET.SubElement(port_profile, \"qos-profile\")\n        cee = ET.SubElement(qos_profile, \"cee\")\n        cee.text = kwargs.pop('cee')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a new config element for the port profile qos profile and cos.", "response": "def port_profile_qos_profile_qos_cos(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        qos_profile = ET.SubElement(port_profile, \"qos-profile\")\n        qos = ET.SubElement(qos_profile, \"qos\")\n        cos = ET.SubElement(qos, \"cos\")\n        cos.text = kwargs.pop('cos')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a new config element for the port - profile qos - profile qos - trust - cos.", "response": "def port_profile_qos_profile_qos_trust_trust_cos(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        qos_profile = ET.SubElement(port_profile, \"qos-profile\")\n        qos = ET.SubElement(qos_profile, \"qos\")\n        trust = ET.SubElement(qos, \"trust\")\n        trust_cos = ET.SubElement(trust, \"trust-cos\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef port_profile_qos_profile_qos_cos_mutation(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        qos_profile = ET.SubElement(port_profile, \"qos-profile\")\n        qos = ET.SubElement(qos_profile, \"qos\")\n        cos_mutation = ET.SubElement(qos, \"cos-mutation\")\n        cos_mutation.text = kwargs.pop('cos_mutation')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new NIC s QoS Profile and Cos Mutation"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a new config element for the port profile QoS Profile and COS Traffic Class.", "response": "def port_profile_qos_profile_qos_cos_traffic_class(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        qos_profile = ET.SubElement(port_profile, \"qos-profile\")\n        qos = ET.SubElement(qos_profile, \"qos\")\n        cos_traffic_class = ET.SubElement(qos, \"cos-traffic-class\")\n        cos_traffic_class.text = kwargs.pop('cos_traffic_class')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a new NIC from a QoS Profile QoS Flow Control Global Tx", "response": "def port_profile_qos_profile_qos_flowcontrol_flowcontrolglobal_tx(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        qos_profile = ET.SubElement(port_profile, \"qos-profile\")\n        qos = ET.SubElement(qos_profile, \"qos\")\n        flowcontrol = ET.SubElement(qos, \"flowcontrol\")\n        flowcontrolglobal = ET.SubElement(flowcontrol, \"flowcontrolglobal\")\n        tx = ET.SubElement(flowcontrolglobal, \"tx\")\n        tx.text = kwargs.pop('tx')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a new config element for the port - profile QoS Profile QoS FlowControl PFC and COS.", "response": "def port_profile_qos_profile_qos_flowcontrol_pfc_pfc_cos(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        qos_profile = ET.SubElement(port_profile, \"qos-profile\")\n        qos = ET.SubElement(qos_profile, \"qos\")\n        flowcontrol = ET.SubElement(qos, \"flowcontrol\")\n        pfc = ET.SubElement(flowcontrol, \"pfc\")\n        pfc_cos = ET.SubElement(pfc, \"pfc-cos\")\n        pfc_cos.text = kwargs.pop('pfc_cos')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef port_profile_qos_profile_qos_flowcontrol_pfc_pfc_tx(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        qos_profile = ET.SubElement(port_profile, \"qos-profile\")\n        qos = ET.SubElement(qos_profile, \"qos\")\n        flowcontrol = ET.SubElement(qos, \"flowcontrol\")\n        pfc = ET.SubElement(flowcontrol, \"pfc\")\n        pfc_cos_key = ET.SubElement(pfc, \"pfc-cos\")\n        pfc_cos_key.text = kwargs.pop('pfc_cos')\n        pfc_tx = ET.SubElement(pfc, \"pfc-tx\")\n        pfc_tx.text = kwargs.pop('pfc_tx')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new entry in the cache for a QoS Profile QoS FlowControl PFC and Tx."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef port_profile_security_profile_mac_access_group_access_group_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        security_profile = ET.SubElement(port_profile, \"security-profile\")\n        mac = ET.SubElement(security_profile, \"mac\")\n        access_group = ET.SubElement(mac, \"access-group\")\n        access_group_name = ET.SubElement(access_group, \"access-group-name\")\n        access_group_name.text = kwargs.pop('access_group_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new object of type Identity class based on the MAC and Access Group Name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a new resource from the port profile security profile ip access group and ipv4 access group name.", "response": "def port_profile_security_profile_ip_access_group_ipv4_access_group_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        security_profile = ET.SubElement(port_profile, \"security-profile\")\n        ip = ET.SubElement(security_profile, \"ip\")\n        access_group = ET.SubElement(ip, \"access-group\")\n        ipv4_access_group_name = ET.SubElement(access_group, \"ipv4-access-group-name\")\n        ipv4_access_group_name.text = kwargs.pop('ipv4_access_group_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a new config element for the port - profile security - profile ipv6 - access - group ipv6 - access - group_ipv6_access_group_name", "response": "def port_profile_security_profile_ipv6_access_group_ipv6_access_group_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        security_profile = ET.SubElement(port_profile, \"security-profile\")\n        ipv6 = ET.SubElement(security_profile, \"ipv6\")\n        access_group = ET.SubElement(ipv6, \"access-group\")\n        ipv6_access_group_name = ET.SubElement(access_group, \"ipv6-access-group-name\")\n        ipv6_access_group_name.text = kwargs.pop('ipv6_access_group_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting restrict - flooding - container to restrict - flooding", "response": "def port_profile_restrict_flooding_container_restrict_flooding(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile = ET.SubElement(config, \"port-profile\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        restrict_flooding_container = ET.SubElement(port_profile, \"restrict-flooding-container\")\n        restrict_flooding = ET.SubElement(restrict_flooding_container, \"restrict-flooding\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the name of the global port - profile", "response": "def port_profile_global_port_profile_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile_global = ET.SubElement(config, \"port-profile-global\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        port_profile = ET.SubElement(port_profile_global, \"port-profile\")\n        name = ET.SubElement(port_profile, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nactivates the global port - profile", "response": "def port_profile_global_port_profile_activate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile_global = ET.SubElement(config, \"port-profile-global\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        port_profile = ET.SubElement(port_profile_global, \"port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        activate = ET.SubElement(port_profile, \"activate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets global port - profile and static mac - address", "response": "def port_profile_global_port_profile_static_mac_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile_global = ET.SubElement(config, \"port-profile-global\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        port_profile = ET.SubElement(port_profile_global, \"port-profile\")\n        name_key = ET.SubElement(port_profile, \"name\")\n        name_key.text = kwargs.pop('name')\n        static = ET.SubElement(port_profile, \"static\")\n        mac_address = ET.SubElement(static, \"mac-address\")\n        mac_address.text = kwargs.pop('mac_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef port_profile_domain_port_profile_domain_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        port_profile_domain = ET.SubElement(config, \"port-profile-domain\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        port_profile_domain_name = ET.SubElement(port_profile_domain, \"port-profile-domain-name\")\n        port_profile_domain_name.text = kwargs.pop('port_profile_domain_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the port - profile - domain"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a new config element for the port profile domain profile name", "response": "def port_profile_domain_profile_profile_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        port_profile_domain = ET.SubElement(config, \"port-profile-domain\", xmlns=\"urn:brocade.com:mgmt:brocade-port-profile\")\n        port_profile_domain_name_key = ET.SubElement(port_profile_domain, \"port-profile-domain-name\")\n        port_profile_domain_name_key.text = kwargs.pop('port_profile_domain_name')\n        profile = ET.SubElement(port_profile_domain, \"profile\")\n        profile_name = ET.SubElement(profile, \"profile-name\")\n        profile_name.text = kwargs.pop('profile_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a MongoDB collection and all the declared indices in the model s Meta class.", "response": "async def create_collection(db, model_class: MongoCollectionMixin):\n    '''\n    Creates a MongoDB collection and all the declared indices in the model's ``Meta`` class\n\n    :param db:\n        A database handle\n    :type db:\n        motor.motor_asyncio.AsyncIOMotorClient\n    :param model_class:\n        The  model to create\n    :type model_class:\n        Subclass of ``Model`` mixed with ``MongoCollectionMixin``\n    '''\n    name = model_class.get_collection_name()\n    if name:\n        try:\n            # create collection\n            coll = await db.create_collection(name, **model_class._meta.creation_args)\n        except CollectionInvalid:  # collection already exists\n            coll = db[name]\n\n        # create indices\n        if hasattr(model_class._meta, 'indices') and isinstance(model_class._meta.indices, list):\n            for index in model_class._meta.indices:\n                try:\n                    index_kwargs = {\n                        'name': index.get('name', '_'.join([x[0] for x in index['fields']])),\n                        'unique': index.get('unique', False),\n                        'sparse': index.get('sparse', False),\n                        'expireAfterSeconds': index.get('expireAfterSeconds', None),\n                        'background': True\n\n                    }\n                    if 'partialFilterExpression' in index:\n                        index_kwargs['partialFilterExpression'] = index.get('partialFilterExpression', {})\n                    await db[name].create_index(\n                        index['fields'],\n                        **index_kwargs\n                    )\n                except OperationFailure as ex:\n                    pass  # index already exists ? TODO: do something with this\n        return coll\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def create_app_collections(db):\n    ''' load all models in app and create collections in db with specified indices'''\n    futures = []\n    for model_class in MongoCollectionMixin.__subclasses__():\n        if model_class._meta.concrete is True:\n            futures.append(create_collection(db, model_class))\n\n    await asyncio.gather(*futures)", "response": "load all models in app and create collections in db with specified indices"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the full name of the collection as declared by the ModelOptions class like so : namespace. name", "response": "def get_collection_name(cls):\n        '''\n        Gets the full name of the collection, as declared by the ModelOptions class like so:\n            namespace.name\n        If no namespace or name is provided, the class's lowercase name is used\n        '''\n        if hasattr(cls, '_meta'):\n            np = getattr(cls._meta, 'namespace', None)\n            cname = getattr(cls._meta, 'name', None)\n            if np:\n                return '{}.{}'.format(np, cname or cls.__name__.lower())\n        return cname or cls.__name__.lower()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete entries by given query.", "response": "async def delete_entries(cls, db, query):\n        ''' Delete documents by given query. '''\n        query = cls.process_query(query)\n        for i in cls.connection_retries():\n            try:\n                result = await db[cls.get_collection_name()].delete_many(query)\n                return result\n            except ConnectionFailure as ex:\n                exceed = await cls.check_reconnect_tries_and_wait(i, 'delete_entries')\n                if exceed:\n                    raise ex"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def delete(self, db):\n        ''' Delete document '''\n        for i in self.connection_retries():\n            try:\n                return await db[self.get_collection_name()].delete_one({self.primary_key: self.pk})\n            except ConnectionFailure as ex:\n                exceed = await self.check_reconnect_tries_and_wait(i, 'delete')\n                if exceed:\n                    raise ex", "response": "Delete the object from the database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_model(cls, data: dict, fields=None):\n        '''\n        Creates model instance from data (dict).\n        '''\n        if fields is None:\n            fields = set(cls._fields.keys())\n        else:\n            if not isinstance(fields, set):\n                fields = set(fields)\n        new_keys = set(data.keys()) - fields\n        if new_keys:\n            for new_key in new_keys:\n                del data[new_key]\n        return cls(data)", "response": "Creates a new instance of the class from data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prepare_data(self, data=None):\n        '''\n        Prepare data for persistency by exporting it to native form\n         and making sure we're not persisting with a null primary key.\n        '''\n        data = data or self.export_data(native=True)\n        # make sure we don't persist a null _id and let MongoDB auto-generate it\n        if '_id' in data and data['_id'] is None:\n            del data['_id']\n        return data", "response": "Prepare data for persistency by exporting it to native form\n         and making sure we don t persist a null _id"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave the object to the database.", "response": "async def save(self, db=None):\n        '''\n        If object has _id, then object will be created or fully rewritten.\n        If not, object will be inserted and _id will be assigned.\n        '''\n        self._db = db or self.db\n        data = self.prepare_data()\n        # validate object\n        self.validate()\n        # connect to DB to save the model\n        for i in self.connection_retries():\n            try:\n                created = False if '_id' in data else True\n                result = await self.db[self.get_collection_name()].insert_one(data)\n                self._id = result.inserted_id\n                # emit post save\n                asyncio.ensure_future(post_save.send(\n                    sender=self.__class__,\n                    db=self.db,\n                    instance=self,\n                    created=created)\n                )\n                break\n            except ConnectionFailure as ex:\n                exceed = await self.check_reconnect_tries_and_wait(i, 'save')\n                if exceed:\n                    raise ex"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def update(self, db=None, data=None):\n        '''\n        Update the entire document by replacing its content with new data, retaining its primary key\n        '''\n        db = db or self.db\n        if data:  # update model explicitely with a new data structure\n            # merge the current model's data with the new data\n            self.import_data(data)\n            # prepare data for database update\n            data = self.prepare_data()\n            # data = {x: ndata[x] for x in ndata if x in data or x == self.primary_key}\n        else:\n            data = self.export_data(native=True)\n\n        if self.primary_key not in data or data[self.primary_key] is None:\n            raise Exception('Missing object primary key')\n        query = {self.primary_key: self.pk}\n        for i in self.connection_retries():\n            try:\n                result = await db[self.get_collection_name()].find_one_and_replace(\n                    filter=query,\n                    replacement=data,\n                    return_document=ReturnDocument.AFTER\n                )\n                if result:\n                    updated_obj = self.create_model(result)\n                    updated_obj._db = db\n                    # emit post save\n                    asyncio.ensure_future(post_save.send(\n                        sender=self.__class__,\n                        db=db,\n                        instance=updated_obj,\n                        created=False)\n                    )\n                    return updated_obj\n\n                return None\n            except ConnectionFailure as ex:\n                exceed = await self.check_reconnect_tries_and_wait(i, 'update')\n                if exceed:\n                    raise ex", "response": "Update the entire document by replacing its content with new data retaining its primary key\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef snmp_server_context_context_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        context = ET.SubElement(snmp_server, \"context\")\n        context_name = ET.SubElement(context, \"context-name\")\n        context_name.text = kwargs.pop('context_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the context for the current server"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the configuration of the current NIC context VRF name", "response": "def snmp_server_context_vrf_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        context = ET.SubElement(snmp_server, \"context\")\n        context_name_key = ET.SubElement(context, \"context-name\")\n        context_name_key.text = kwargs.pop('context_name')\n        vrf_name = ET.SubElement(context, \"vrf-name\")\n        vrf_name.text = kwargs.pop('vrf_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef snmp_server_community_community(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        community = ET.SubElement(snmp_server, \"community\")\n        community = ET.SubElement(community, \"community\")\n        community.text = kwargs.pop('community')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of the OIDC community"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the current OID from the community group name.", "response": "def snmp_server_community_groupname(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        community = ET.SubElement(snmp_server, \"community\")\n        community_key = ET.SubElement(community, \"community\")\n        community_key.text = kwargs.pop('community')\n        groupname = ET.SubElement(community, \"groupname\")\n        groupname.text = kwargs.pop('groupname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef snmp_server_community_ipv4_acl(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        community = ET.SubElement(snmp_server, \"community\")\n        community_key = ET.SubElement(community, \"community\")\n        community_key.text = kwargs.pop('community')\n        ipv4_acl = ET.SubElement(community, \"ipv4-acl\")\n        ipv4_acl.text = kwargs.pop('ipv4_acl')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current state of the local cache community and ipv4 acl"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef snmp_server_community_ipv6_acl(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        community = ET.SubElement(snmp_server, \"community\")\n        community_key = ET.SubElement(community, \"community\")\n        community_key.text = kwargs.pop('community')\n        ipv6_acl = ET.SubElement(community, \"ipv6-acl\")\n        ipv6_acl.text = kwargs.pop('ipv6_acl')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current state of the local cache community and ipv6 acl"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef snmp_server_user_username(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        user = ET.SubElement(snmp_server, \"user\")\n        username = ET.SubElement(user, \"username\")\n        username.text = kwargs.pop('username')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the user name of the current node for the SNMP server"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the user and groupname of the current OID.", "response": "def snmp_server_user_groupname(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        user = ET.SubElement(snmp_server, \"user\")\n        username_key = ET.SubElement(user, \"username\")\n        username_key.text = kwargs.pop('username')\n        groupname = ET.SubElement(user, \"groupname\")\n        groupname.text = kwargs.pop('groupname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the configuration of the user authentication for the current node", "response": "def snmp_server_user_auth(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        user = ET.SubElement(snmp_server, \"user\")\n        username_key = ET.SubElement(user, \"username\")\n        username_key.text = kwargs.pop('username')\n        auth = ET.SubElement(user, \"auth\")\n        auth.text = kwargs.pop('auth')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef snmp_server_user_auth_password(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        user = ET.SubElement(snmp_server, \"user\")\n        username_key = ET.SubElement(user, \"username\")\n        username_key.text = kwargs.pop('username')\n        auth_password = ET.SubElement(user, \"auth-password\")\n        auth_password.text = kwargs.pop('auth_password')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the user and password of the current node for the SNMP server"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the configuration of the user - priv entry for the current node.", "response": "def snmp_server_user_priv(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        user = ET.SubElement(snmp_server, \"user\")\n        username_key = ET.SubElement(user, \"username\")\n        username_key.text = kwargs.pop('username')\n        priv = ET.SubElement(user, \"priv\")\n        priv.text = kwargs.pop('priv')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef snmp_server_user_priv_password(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        user = ET.SubElement(snmp_server, \"user\")\n        username_key = ET.SubElement(user, \"username\")\n        username_key.text = kwargs.pop('username')\n        priv_password = ET.SubElement(user, \"priv-password\")\n        priv_password.text = kwargs.pop('priv_password')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get user and priv - password from SNMP server"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the user - encrypted status of the current node", "response": "def snmp_server_user_encrypted(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        user = ET.SubElement(snmp_server, \"user\")\n        username_key = ET.SubElement(user, \"username\")\n        username_key.text = kwargs.pop('username')\n        encrypted = ET.SubElement(user, \"encrypted\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef snmp_server_user_ipv4_acl(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        user = ET.SubElement(snmp_server, \"user\")\n        username_key = ET.SubElement(user, \"username\")\n        username_key.text = kwargs.pop('username')\n        ipv4_acl = ET.SubElement(user, \"ipv4-acl\")\n        ipv4_acl.text = kwargs.pop('ipv4_acl')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a specific user in the SNMP server"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the config of a specific user in the SNMP server", "response": "def snmp_server_user_ipv6_acl(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        user = ET.SubElement(snmp_server, \"user\")\n        username_key = ET.SubElement(user, \"username\")\n        username_key.text = kwargs.pop('username')\n        ipv6_acl = ET.SubElement(user, \"ipv6-acl\")\n        ipv6_acl.text = kwargs.pop('ipv6_acl')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef snmp_server_v3host_hostip(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        v3host = ET.SubElement(snmp_server, \"v3host\")\n        username_key = ET.SubElement(v3host, \"username\")\n        username_key.text = kwargs.pop('username')\n        hostip = ET.SubElement(v3host, \"hostip\")\n        hostip.text = kwargs.pop('hostip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the available SNMP server for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the configuration of the available SNMP server for the current user.", "response": "def snmp_server_v3host_username(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        v3host = ET.SubElement(snmp_server, \"v3host\")\n        hostip_key = ET.SubElement(v3host, \"hostip\")\n        hostip_key.text = kwargs.pop('hostip')\n        username = ET.SubElement(v3host, \"username\")\n        username.text = kwargs.pop('username')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef snmp_server_v3host_udp_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        v3host = ET.SubElement(snmp_server, \"v3host\")\n        hostip_key = ET.SubElement(v3host, \"hostip\")\n        hostip_key.text = kwargs.pop('hostip')\n        username_key = ET.SubElement(v3host, \"username\")\n        username_key.text = kwargs.pop('username')\n        udp_port = ET.SubElement(v3host, \"udp-port\")\n        udp_port.text = kwargs.pop('udp_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the NX - SNMP V3host UDP port"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the configuration of the NX - SNMP V3 host notifytype", "response": "def snmp_server_v3host_notifytype(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        v3host = ET.SubElement(snmp_server, \"v3host\")\n        hostip_key = ET.SubElement(v3host, \"hostip\")\n        hostip_key.text = kwargs.pop('hostip')\n        username_key = ET.SubElement(v3host, \"username\")\n        username_key.text = kwargs.pop('username')\n        notifytype = ET.SubElement(v3host, \"notifytype\")\n        notifytype.text = kwargs.pop('notifytype')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef snmp_server_v3host_engineid(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        v3host = ET.SubElement(snmp_server, \"v3host\")\n        hostip_key = ET.SubElement(v3host, \"hostip\")\n        hostip_key.text = kwargs.pop('hostip')\n        username_key = ET.SubElement(v3host, \"username\")\n        username_key.text = kwargs.pop('username')\n        engineid = ET.SubElement(v3host, \"engineid\")\n        engineid.text = kwargs.pop('engineid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the available SNMP cache entries."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef snmp_server_v3host_severity_level(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        v3host = ET.SubElement(snmp_server, \"v3host\")\n        hostip_key = ET.SubElement(v3host, \"hostip\")\n        hostip_key.text = kwargs.pop('hostip')\n        username_key = ET.SubElement(v3host, \"username\")\n        username_key.text = kwargs.pop('username')\n        severity_level = ET.SubElement(v3host, \"severity-level\")\n        severity_level.text = kwargs.pop('severity_level')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the current snmp server v3host severity level"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef snmp_server_v3host_use_vrf(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        v3host = ET.SubElement(snmp_server, \"v3host\")\n        hostip_key = ET.SubElement(v3host, \"hostip\")\n        hostip_key.text = kwargs.pop('hostip')\n        username_key = ET.SubElement(v3host, \"username\")\n        username_key.text = kwargs.pop('username')\n        use_vrf = ET.SubElement(v3host, \"use-vrf\")\n        use_vrf.text = kwargs.pop('use_vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a single cache entry based on V3Host"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the configuration of a single entry in the SNMP server.", "response": "def snmp_server_v3host_source_interface_source_interface_type_loopback_loopback(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        v3host = ET.SubElement(snmp_server, \"v3host\")\n        hostip_key = ET.SubElement(v3host, \"hostip\")\n        hostip_key.text = kwargs.pop('hostip')\n        username_key = ET.SubElement(v3host, \"username\")\n        username_key.text = kwargs.pop('username')\n        source_interface = ET.SubElement(v3host, \"source-interface\")\n        source_interface_type = ET.SubElement(source_interface, \"source-interface-type\")\n        loopback = ET.SubElement(source_interface_type, \"loopback\")\n        loopback = ET.SubElement(loopback, \"loopback\")\n        loopback.text = kwargs.pop('loopback')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the configuration of the NX - SNMP host IP", "response": "def snmp_server_host_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        host = ET.SubElement(snmp_server, \"host\")\n        community_key = ET.SubElement(host, \"community\")\n        community_key.text = kwargs.pop('community')\n        ip = ET.SubElement(host, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the configuration of the NX - SNMP host_version", "response": "def snmp_server_host_version(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        host = ET.SubElement(snmp_server, \"host\")\n        ip_key = ET.SubElement(host, \"ip\")\n        ip_key.text = kwargs.pop('ip')\n        community_key = ET.SubElement(host, \"community\")\n        community_key.text = kwargs.pop('community')\n        version = ET.SubElement(host, \"version\")\n        version.text = kwargs.pop('version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef snmp_server_host_community(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        host = ET.SubElement(snmp_server, \"host\")\n        ip_key = ET.SubElement(host, \"ip\")\n        ip_key.text = kwargs.pop('ip')\n        community = ET.SubElement(host, \"community\")\n        community.text = kwargs.pop('community')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the details of the host - community entry in the SNMP server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the configuration of the NX - SNMP host - udp - port of the current subsystem.", "response": "def snmp_server_host_udp_port(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        host = ET.SubElement(snmp_server, \"host\")\n        ip_key = ET.SubElement(host, \"ip\")\n        ip_key.text = kwargs.pop('ip')\n        community_key = ET.SubElement(host, \"community\")\n        community_key.text = kwargs.pop('community')\n        udp_port = ET.SubElement(host, \"udp-port\")\n        udp_port.text = kwargs.pop('udp_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef snmp_server_host_severity_level(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        host = ET.SubElement(snmp_server, \"host\")\n        ip_key = ET.SubElement(host, \"ip\")\n        ip_key.text = kwargs.pop('ip')\n        community_key = ET.SubElement(host, \"community\")\n        community_key.text = kwargs.pop('community')\n        severity_level = ET.SubElement(host, \"severity-level\")\n        severity_level.text = kwargs.pop('severity_level')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the details of the host severity level of the current snmp server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef snmp_server_host_use_vrf(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        host = ET.SubElement(snmp_server, \"host\")\n        ip_key = ET.SubElement(host, \"ip\")\n        ip_key.text = kwargs.pop('ip')\n        community_key = ET.SubElement(host, \"community\")\n        community_key.text = kwargs.pop('community')\n        use_vrf = ET.SubElement(host, \"use-vrf\")\n        use_vrf.text = kwargs.pop('use_vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set use - vrf of the host element for the current snmp server"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of a specific object from the SNMP server host source interface type and loopback loopback.", "response": "def snmp_server_host_source_interface_source_interface_type_loopback_loopback(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        host = ET.SubElement(snmp_server, \"host\")\n        ip_key = ET.SubElement(host, \"ip\")\n        ip_key.text = kwargs.pop('ip')\n        community_key = ET.SubElement(host, \"community\")\n        community_key.text = kwargs.pop('community')\n        source_interface = ET.SubElement(host, \"source-interface\")\n        source_interface_type = ET.SubElement(source_interface, \"source-interface-type\")\n        loopback = ET.SubElement(source_interface_type, \"loopback\")\n        loopback = ET.SubElement(loopback, \"loopback\")\n        loopback.text = kwargs.pop('loopback')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef snmp_server_agtconfig_contact(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        agtconfig = ET.SubElement(snmp_server, \"agtconfig\")\n        contact = ET.SubElement(agtconfig, \"contact\")\n        contact.text = kwargs.pop('contact')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the OIDA server agtconfig"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef snmp_server_agtconfig_location(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        agtconfig = ET.SubElement(snmp_server, \"agtconfig\")\n        location = ET.SubElement(agtconfig, \"location\")\n        location.text = kwargs.pop('location')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the OIDA server agtconfig location"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of the OIDA SNMP server agtconfig sys - descr", "response": "def snmp_server_agtconfig_sys_descr(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        agtconfig = ET.SubElement(snmp_server, \"agtconfig\")\n        sys_descr = ET.SubElement(agtconfig, \"sys-descr\")\n        sys_descr.text = kwargs.pop('sys_descr')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef snmp_server_enable_trap_trap_flag(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        enable = ET.SubElement(snmp_server, \"enable\")\n        trap = ET.SubElement(enable, \"trap\")\n        trap_flag = ET.SubElement(trap, \"trap-flag\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable trap - flag for the current log - level"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndrops the local entry from the cache.", "response": "def snmp_server_engineID_drop_engineID_local(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        engineID_drop = ET.SubElement(snmp_server, \"engineID-drop\")\n        engineID = ET.SubElement(engineID_drop, \"engineID\")\n        local = ET.SubElement(engineID, \"local\")\n        local.text = kwargs.pop('local')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef snmp_server_view_viewname(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        view = ET.SubElement(snmp_server, \"view\")\n        mibtree_key = ET.SubElement(view, \"mibtree\")\n        mibtree_key.text = kwargs.pop('mibtree')\n        viewname = ET.SubElement(view, \"viewname\")\n        viewname.text = kwargs.pop('viewname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the viewname of the current mibtree key"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef snmp_server_view_mibtree(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        view = ET.SubElement(snmp_server, \"view\")\n        viewname_key = ET.SubElement(view, \"viewname\")\n        viewname_key.text = kwargs.pop('viewname')\n        mibtree = ET.SubElement(view, \"mibtree\")\n        mibtree.text = kwargs.pop('mibtree')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the current cache from the SNMP server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef snmp_server_view_mibtree_access(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        view = ET.SubElement(snmp_server, \"view\")\n        viewname_key = ET.SubElement(view, \"viewname\")\n        viewname_key.text = kwargs.pop('viewname')\n        mibtree_key = ET.SubElement(view, \"mibtree\")\n        mibtree_key.text = kwargs.pop('mibtree')\n        mibtree_access = ET.SubElement(view, \"mibtree-access\")\n        mibtree_access.text = kwargs.pop('mibtree_access')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the current cache from the SNMP server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef snmp_server_group_group_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        group = ET.SubElement(snmp_server, \"group\")\n        group_version_key = ET.SubElement(group, \"group-version\")\n        group_version_key.text = kwargs.pop('group_version')\n        group_name = ET.SubElement(group, \"group-name\")\n        group_name.text = kwargs.pop('group_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the group of the current cache"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the current state of the group", "response": "def snmp_server_group_group_version(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        group = ET.SubElement(snmp_server, \"group\")\n        group_name_key = ET.SubElement(group, \"group-name\")\n        group_name_key.text = kwargs.pop('group_name')\n        group_version = ET.SubElement(group, \"group-version\")\n        group_version.text = kwargs.pop('group_version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef snmp_server_group_group_auth_mode(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        group = ET.SubElement(snmp_server, \"group\")\n        group_name_key = ET.SubElement(group, \"group-name\")\n        group_name_key.text = kwargs.pop('group_name')\n        group_version_key = ET.SubElement(group, \"group-version\")\n        group_version_key.text = kwargs.pop('group_version')\n        group_auth_mode = ET.SubElement(group, \"group-auth-mode\")\n        group_auth_mode.text = kwargs.pop('group_auth_mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the OIDC group authentication mode"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the current state of the group read", "response": "def snmp_server_group_read(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        group = ET.SubElement(snmp_server, \"group\")\n        group_name_key = ET.SubElement(group, \"group-name\")\n        group_name_key.text = kwargs.pop('group_name')\n        group_version_key = ET.SubElement(group, \"group-version\")\n        group_version_key.text = kwargs.pop('group_version')\n        read = ET.SubElement(group, \"read\")\n        read.text = kwargs.pop('read')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the current state of the group for the group write", "response": "def snmp_server_group_write(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        group = ET.SubElement(snmp_server, \"group\")\n        group_name_key = ET.SubElement(group, \"group-name\")\n        group_name_key.text = kwargs.pop('group_name')\n        group_version_key = ET.SubElement(group, \"group-version\")\n        group_version_key.text = kwargs.pop('group_version')\n        write = ET.SubElement(group, \"write\")\n        write.text = kwargs.pop('write')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nnotify the group of the current log entry", "response": "def snmp_server_group_notify(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        group = ET.SubElement(snmp_server, \"group\")\n        group_name_key = ET.SubElement(group, \"group-name\")\n        group_name_key.text = kwargs.pop('group_name')\n        group_version_key = ET.SubElement(group, \"group-version\")\n        group_version_key.text = kwargs.pop('group_version')\n        notify = ET.SubElement(group, \"notify\")\n        notify.text = kwargs.pop('notify')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef snmp_server_mib_community_map_community(self, **kwargs):\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        mib = ET.SubElement(snmp_server, \"mib\")\n        community_map = ET.SubElement(mib, \"community-map\")\n        community = ET.SubElement(community_map, \"community\")\n        community.text = kwargs.pop('community')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the NX - MIB community map for the current cluster."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the current state of the CMB community map context.", "response": "def snmp_server_mib_community_map_context(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        snmp_server = ET.SubElement(config, \"snmp-server\", xmlns=\"urn:brocade.com:mgmt:brocade-snmp\")\n        mib = ET.SubElement(snmp_server, \"mib\")\n        community_map = ET.SubElement(mib, \"community-map\")\n        community_key = ET.SubElement(community_map, \"community\")\n        community_key.text = kwargs.pop('community')\n        context = ET.SubElement(community_map, \"context\")\n        context.text = kwargs.pop('context')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow NTP input rbridge - id.", "response": "def show_ntp_input_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_ntp = ET.Element(\"show_ntp\")\n        config = show_ntp\n        input = ET.SubElement(show_ntp, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_ntp_output_node_active_server_rbridge_id_out(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_ntp = ET.Element(\"show_ntp\")\n        config = show_ntp\n        output = ET.SubElement(show_ntp, \"output\")\n        node_active_server = ET.SubElement(output, \"node-active-server\")\n        rbridge_id_out = ET.SubElement(node_active_server, \"rbridge-id-out\")\n        rbridge_id_out.text = kwargs.pop('rbridge_id_out')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show NTP output node - active - server rbridge - id - out."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_ntp_output_node_active_server_ip4_6_or_local_ipv4_6_active_server(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_ntp = ET.Element(\"show_ntp\")\n        config = show_ntp\n        output = ET.SubElement(show_ntp, \"output\")\n        node_active_server = ET.SubElement(output, \"node-active-server\")\n        ip4_6_or_local = ET.SubElement(node_active_server, \"ip4-6-or-local\")\n        ipv4_6 = ET.SubElement(ip4_6_or_local, \"ipv4-6\")\n        active_server = ET.SubElement(ipv4_6, \"active-server\")\n        active_server.text = kwargs.pop('active_server')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show NTP active server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow NTP Entry Manager Node Active Server and Local LOCL.", "response": "def show_ntp_output_node_active_server_ip4_6_or_local_local_LOCL(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_ntp = ET.Element(\"show_ntp\")\n        config = show_ntp\n        output = ET.SubElement(show_ntp, \"output\")\n        node_active_server = ET.SubElement(output, \"node-active-server\")\n        ip4_6_or_local = ET.SubElement(node_active_server, \"ip4-6-or-local\")\n        local = ET.SubElement(ip4_6_or_local, \"local\")\n        LOCL = ET.SubElement(local, \"LOCL\")\n        LOCL.text = kwargs.pop('LOCL')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting NTP Authentication Key ID", "response": "def ntp_authentication_key_keyid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ntp = ET.SubElement(config, \"ntp\", xmlns=\"urn:brocade.com:mgmt:brocade-ntp\")\n        authentication_key = ET.SubElement(ntp, \"authentication-key\")\n        keyid = ET.SubElement(authentication_key, \"keyid\")\n        keyid.text = kwargs.pop('keyid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget NTP Authentication Key Encryption Type and MD5 Type for a specific key.", "response": "def ntp_authentication_key_encryption_type_md5_type_md5(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ntp = ET.SubElement(config, \"ntp\", xmlns=\"urn:brocade.com:mgmt:brocade-ntp\")\n        authentication_key = ET.SubElement(ntp, \"authentication-key\")\n        keyid_key = ET.SubElement(authentication_key, \"keyid\")\n        keyid_key.text = kwargs.pop('keyid')\n        encryption_type = ET.SubElement(authentication_key, \"encryption-type\")\n        md5_type = ET.SubElement(encryption_type, \"md5-type\")\n        md5 = ET.SubElement(md5_type, \"md5\")\n        md5.text = kwargs.pop('md5')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets NTP Authentication Key Encryption Type and SHA1 Type for a specific key.", "response": "def ntp_authentication_key_encryption_type_sha1_type_sha1(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ntp = ET.SubElement(config, \"ntp\", xmlns=\"urn:brocade.com:mgmt:brocade-ntp\")\n        authentication_key = ET.SubElement(ntp, \"authentication-key\")\n        keyid_key = ET.SubElement(authentication_key, \"keyid\")\n        keyid_key.text = kwargs.pop('keyid')\n        encryption_type = ET.SubElement(authentication_key, \"encryption-type\")\n        sha1_type = ET.SubElement(encryption_type, \"sha1-type\")\n        sha1 = ET.SubElement(sha1_type, \"sha1\")\n        sha1.text = kwargs.pop('sha1')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting NTP Authentication Key Encryption Level", "response": "def ntp_authentication_key_encryption_level(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ntp = ET.SubElement(config, \"ntp\", xmlns=\"urn:brocade.com:mgmt:brocade-ntp\")\n        authentication_key = ET.SubElement(ntp, \"authentication-key\")\n        keyid_key = ET.SubElement(authentication_key, \"keyid\")\n        keyid_key.text = kwargs.pop('keyid')\n        encryption_level = ET.SubElement(authentication_key, \"encryption-level\")\n        encryption_level.text = kwargs.pop('encryption_level')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting NTP source IP", "response": "def ntp_source_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ntp = ET.SubElement(config, \"ntp\", xmlns=\"urn:brocade.com:mgmt:brocade-ntp\")\n        source_ip = ET.SubElement(ntp, \"source-ip\")\n        source_ip.text = kwargs.pop('source_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_stp_brief_info_input_request_type_getnext_request_last_rcvd_instance_instance_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        input = ET.SubElement(get_stp_brief_info, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        getnext_request = ET.SubElement(request_type, \"getnext-request\")\n        last_rcvd_instance = ET.SubElement(getnext_request, \"last-rcvd-instance\")\n        instance_id = ET.SubElement(last_rcvd_instance, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Next Request Type of Get Next Request"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_brief_info_output_spanning_tree_info_stp_mode(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        stp_mode = ET.SubElement(spanning_tree_info, \"stp-mode\")\n        stp_mode.text = kwargs.pop('stp_mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPP level spanning tree info output."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_stp_stp_root_bridge_priority(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        stp = ET.SubElement(spanning_tree_mode, \"stp\")\n        stp = ET.SubElement(stp, \"stp\")\n        root_bridge = ET.SubElement(stp, \"root-bridge\")\n        priority = ET.SubElement(root_bridge, \"priority\")\n        priority.text = kwargs.pop('priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPP spanning tree info output spanning tree mode root bridge priority"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_stp_stp_port_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        stp = ET.SubElement(spanning_tree_mode, \"stp\")\n        stp = ET.SubElement(stp, \"stp\")\n        port = ET.SubElement(stp, \"port\")\n        interface_type = ET.SubElement(port, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT entry from Get SPT info output spanning tree mode SPT port interface type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_rstp_rstp_transmit_hold_count(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        rstp = ET.SubElement(spanning_tree_mode, \"rstp\")\n        rstp = ET.SubElement(rstp, \"rstp\")\n        transmit_hold_count = ET.SubElement(rstp, \"transmit-hold-count\")\n        transmit_hold_count.text = kwargs.pop('transmit_hold_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT info output spanning tree mode RSTP and transmit hold count."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets SPP Get SPP info output spanning tree mode rstp and migrate time.", "response": "def get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_rstp_rstp_migrate_time(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        rstp = ET.SubElement(spanning_tree_mode, \"rstp\")\n        rstp = ET.SubElement(rstp, \"rstp\")\n        migrate_time = ET.SubElement(rstp, \"migrate-time\")\n        migrate_time.text = kwargs.pop('migrate_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_mstp_mstp_transmit_hold_count(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        mstp = ET.SubElement(spanning_tree_mode, \"mstp\")\n        mstp = ET.SubElement(mstp, \"mstp\")\n        transmit_hold_count = ET.SubElement(mstp, \"transmit-hold-count\")\n        transmit_hold_count.text = kwargs.pop('transmit_hold_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPP Get SPP info output spanning tree mode MST and transmit hold count."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets SPP Get SPP info output spanning tree mode MST MORE TIME", "response": "def get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_mstp_mstp_migrate_time(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        mstp = ET.SubElement(spanning_tree_mode, \"mstp\")\n        mstp = ET.SubElement(mstp, \"mstp\")\n        migrate_time = ET.SubElement(mstp, \"migrate-time\")\n        migrate_time.text = kwargs.pop('migrate_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget SPKT output spanning tree info spanning tree mode PVSTP VLAN ID", "response": "def get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_pvstp_pvstp_vlan_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        pvstp = ET.SubElement(spanning_tree_mode, \"pvstp\")\n        pvstp = ET.SubElement(pvstp, \"pvstp\")\n        vlan_id = ET.SubElement(pvstp, \"vlan-id\")\n        vlan_id.text = kwargs.pop('vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_pvstp_pvstp_root_bridge_priority(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        pvstp = ET.SubElement(spanning_tree_mode, \"pvstp\")\n        pvstp = ET.SubElement(pvstp, \"pvstp\")\n        vlan_id_key = ET.SubElement(pvstp, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        root_bridge = ET.SubElement(pvstp, \"root-bridge\")\n        priority = ET.SubElement(root_bridge, \"priority\")\n        priority.text = kwargs.pop('priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPP version 2. 0. 1."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget SPP version 1. 0. 1.", "response": "def get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_pvstp_pvstp_transmit_hold_count(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        pvstp = ET.SubElement(spanning_tree_mode, \"pvstp\")\n        pvstp = ET.SubElement(pvstp, \"pvstp\")\n        vlan_id_key = ET.SubElement(pvstp, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        transmit_hold_count = ET.SubElement(pvstp, \"transmit-hold-count\")\n        transmit_hold_count.text = kwargs.pop('transmit_hold_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget SPP version 2. 0. 1.", "response": "def get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_pvstp_pvstp_port_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        pvstp = ET.SubElement(spanning_tree_mode, \"pvstp\")\n        pvstp = ET.SubElement(pvstp, \"pvstp\")\n        vlan_id_key = ET.SubElement(pvstp, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        port = ET.SubElement(pvstp, \"port\")\n        interface_type = ET.SubElement(port, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting SPP Brief Information of a specific resource.", "response": "def get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_rpvstp_rpvstp_vlan_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        rpvstp = ET.SubElement(spanning_tree_mode, \"rpvstp\")\n        rpvstp = ET.SubElement(rpvstp, \"rpvstp\")\n        vlan_id = ET.SubElement(rpvstp, \"vlan-id\")\n        vlan_id.text = kwargs.pop('vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_stp_brief_info_output_has_more(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT Bark Info output has - more."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting SPKT Bark info output last instance id.", "response": "def get_stp_brief_info_output_last_instance_instance_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        last_instance = ET.SubElement(output, \"last-instance\")\n        instance_id = ET.SubElement(last_instance, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget Next Request for a specific resource.", "response": "def get_stp_mst_detail_input_request_type_getnext_request_last_rcvd_instance_instance_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        input = ET.SubElement(get_stp_mst_detail, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        getnext_request = ET.SubElement(request_type, \"getnext-request\")\n        last_rcvd_instance = ET.SubElement(getnext_request, \"last-rcvd-instance\")\n        instance_id = ET.SubElement(last_rcvd_instance, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting SPT MST Entry output CIST and CIST root ID.", "response": "def get_stp_mst_detail_output_cist_cist_root_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        cist_root_id = ET.SubElement(cist, \"cist-root-id\")\n        cist_root_id.text = kwargs.pop('cist_root_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_stp_mst_detail_output_cist_cist_bridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        cist_bridge_id = ET.SubElement(cist, \"cist-bridge-id\")\n        cist_bridge_id.text = kwargs.pop('cist_bridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST Bridge ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_stp_mst_detail_output_cist_cist_reg_root_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        cist_reg_root_id = ET.SubElement(cist, \"cist-reg-root-id\")\n        cist_reg_root_id.text = kwargs.pop('cist_reg_root_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output for CIST cist reg root id"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_stp_mst_detail_output_cist_root_forward_delay(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        root_forward_delay = ET.SubElement(cist, \"root-forward-delay\")\n        root_forward_delay.text = kwargs.pop('root_forward_delay')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST root - forward - delay"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_stp_mst_detail_output_cist_hello_time(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        hello_time = ET.SubElement(cist, \"hello-time\")\n        hello_time.text = kwargs.pop('hello_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST hello time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget SPT MST Entry output CIST Max Age", "response": "def get_stp_mst_detail_output_cist_max_age(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        max_age = ET.SubElement(cist, \"max-age\")\n        max_age.text = kwargs.pop('max_age')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_stp_mst_detail_output_cist_max_hops(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        max_hops = ET.SubElement(cist, \"max-hops\")\n        max_hops.text = kwargs.pop('max_hops')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST Max Hops"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_stp_mst_detail_output_cist_migrate_time(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        migrate_time = ET.SubElement(cist, \"migrate-time\")\n        migrate_time.text = kwargs.pop('migrate_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST migrate time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting SPT MST Entry output CIST and PORT interface Type.", "response": "def get_stp_mst_detail_output_cist_port_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        interface_type = ET.SubElement(port, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_stp_mst_detail_output_cist_port_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        interface_name = ET.SubElement(port, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST and PORT."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget SPT MST Entry output CIST and PORT spanningtree enabled.", "response": "def get_stp_mst_detail_output_cist_port_spanningtree_enabled(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        spanningtree_enabled = ET.SubElement(port, \"spanningtree-enabled\")\n        spanningtree_enabled.text = kwargs.pop('spanningtree_enabled')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_stp_mst_detail_output_cist_port_if_index(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        if_index = ET.SubElement(port, \"if-index\")\n        if_index.text = kwargs.pop('if_index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST and PORT."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_stp_mst_detail_output_cist_port_interface_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        interface_id = ET.SubElement(port, \"interface-id\")\n        interface_id.text = kwargs.pop('interface_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST and PORT interface ID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_stp_mst_detail_output_cist_port_if_role(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        if_role = ET.SubElement(port, \"if-role\")\n        if_role.text = kwargs.pop('if_role')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST and PORT."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_stp_mst_detail_output_cist_port_if_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        if_state = ET.SubElement(port, \"if-state\")\n        if_state.text = kwargs.pop('if_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST and PORT."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_stp_mst_detail_output_cist_port_external_path_cost(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        external_path_cost = ET.SubElement(port, \"external-path-cost\")\n        external_path_cost.text = kwargs.pop('external_path_cost')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST and PORT external path cost."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets SPT MST Entry output CIST and PORT internal path Cost.", "response": "def get_stp_mst_detail_output_cist_port_internal_path_cost(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        internal_path_cost = ET.SubElement(port, \"internal-path-cost\")\n        internal_path_cost.text = kwargs.pop('internal_path_cost')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting SPT MST Entry output CIST and PORT configured path cost.", "response": "def get_stp_mst_detail_output_cist_port_configured_path_cost(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        configured_path_cost = ET.SubElement(port, \"configured-path-cost\")\n        configured_path_cost.text = kwargs.pop('configured_path_cost')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets SPT MST output CIST and PORT designated port ID.", "response": "def get_stp_mst_detail_output_cist_port_designated_port_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        designated_port_id = ET.SubElement(port, \"designated-port-id\")\n        designated_port_id.text = kwargs.pop('designated_port_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets SPT MST Entry output CIST and PORT - Port Priority.", "response": "def get_stp_mst_detail_output_cist_port_port_priority(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        port_priority = ET.SubElement(port, \"port-priority\")\n        port_priority.text = kwargs.pop('port_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting SPT MST Entry output CIST and PORT designated bridge ID.", "response": "def get_stp_mst_detail_output_cist_port_designated_bridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        designated_bridge_id = ET.SubElement(port, \"designated-bridge-id\")\n        designated_bridge_id.text = kwargs.pop('designated_bridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget SPT MST Entry output CIST and PORT - hello - time.", "response": "def get_stp_mst_detail_output_cist_port_port_hello_time(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        port_hello_time = ET.SubElement(port, \"port-hello-time\")\n        port_hello_time.text = kwargs.pop('port_hello_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_stp_mst_detail_output_cist_port_forward_transitions_count(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        forward_transitions_count = ET.SubElement(port, \"forward-transitions-count\")\n        forward_transitions_count.text = kwargs.pop('forward_transitions_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST and PORT forward transitions count."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_stp_mst_detail_output_cist_port_received_stp_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        received_stp_type = ET.SubElement(port, \"received-stp-type\")\n        received_stp_type.text = kwargs.pop('received_stp_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT entry from MST detail output CIST and PORT received SPT type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_mst_detail_output_cist_port_transmitted_stp_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        transmitted_stp_type = ET.SubElement(port, \"transmitted-stp-type\")\n        transmitted_stp_type.text = kwargs.pop('transmitted_stp_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT entry from MST detail output CIST and PORT transmitted SPT type."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets SPT MST Entry output CIST and PORT edge - PORT.", "response": "def get_stp_mst_detail_output_cist_port_edge_port(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        edge_port = ET.SubElement(port, \"edge-port\")\n        edge_port.text = kwargs.pop('edge_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_mst_detail_output_cist_port_auto_edge(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        auto_edge = ET.SubElement(port, \"auto-edge\")\n        auto_edge.text = kwargs.pop('auto_edge')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST and PORT auto - edge."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting SPT MST Entry output CIST and PORT admin edge.", "response": "def get_stp_mst_detail_output_cist_port_admin_edge(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        admin_edge = ET.SubElement(port, \"admin-edge\")\n        admin_edge.text = kwargs.pop('admin_edge')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget SPT MST Entry output CIST Port Edge Delay", "response": "def get_stp_mst_detail_output_cist_port_edge_delay(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        edge_delay = ET.SubElement(port, \"edge-delay\")\n        edge_delay.text = kwargs.pop('edge_delay')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget SPT MST Entry output CIST and PORT configured root guard.", "response": "def get_stp_mst_detail_output_cist_port_configured_root_guard(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        configured_root_guard = ET.SubElement(port, \"configured-root-guard\")\n        configured_root_guard.text = kwargs.pop('configured_root_guard')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_stp_mst_detail_output_cist_port_oper_root_guard(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        oper_root_guard = ET.SubElement(port, \"oper-root-guard\")\n        oper_root_guard.text = kwargs.pop('oper_root_guard')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST Port Oper - Root Guard."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_stp_mst_detail_output_cist_port_boundary_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        boundary_port = ET.SubElement(port, \"boundary-port\")\n        boundary_port.text = kwargs.pop('boundary_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST and Port boundary - Port."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_mst_detail_output_cist_port_oper_bpdu_guard(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        oper_bpdu_guard = ET.SubElement(port, \"oper-bpdu-guard\")\n        oper_bpdu_guard.text = kwargs.pop('oper_bpdu_guard')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST and PORT oper - BPDU guard."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_stp_mst_detail_output_cist_port_oper_bpdu_filter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        oper_bpdu_filter = ET.SubElement(port, \"oper-bpdu-filter\")\n        oper_bpdu_filter.text = kwargs.pop('oper_bpdu_filter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST Entry output CIST Port Oper BPDU Filter."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting SPT MST Entry output CIST and PORT link type.", "response": "def get_stp_mst_detail_output_cist_port_link_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        link_type = ET.SubElement(port, \"link-type\")\n        link_type.text = kwargs.pop('link_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget SPT MST Entry output CIST and PORT rx BPDU count.", "response": "def get_stp_mst_detail_output_cist_port_rx_bpdu_count(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        rx_bpdu_count = ET.SubElement(port, \"rx-bpdu-count\")\n        rx_bpdu_count.text = kwargs.pop('rx_bpdu_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting SPT MST Entry output CIST and PORT tx BPDU Count.", "response": "def get_stp_mst_detail_output_cist_port_tx_bpdu_count(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        cist = ET.SubElement(output, \"cist\")\n        port = ET.SubElement(cist, \"port\")\n        tx_bpdu_count = ET.SubElement(port, \"tx-bpdu-count\")\n        tx_bpdu_count.text = kwargs.pop('tx_bpdu_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_stp_mst_detail_output_msti_instance_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id = ET.SubElement(msti, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the SPT entry from MSTI XML output."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the SPT resource from MSTI root ID.", "response": "def get_stp_mst_detail_output_msti_msti_root_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        msti_root_id = ET.SubElement(msti, \"msti-root-id\")\n        msti_root_id.text = kwargs.pop('msti_root_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the SPT resource MSTI status output.", "response": "def get_stp_mst_detail_output_msti_msti_bridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        msti_bridge_id = ET.SubElement(msti, \"msti-bridge-id\")\n        msti_bridge_id.text = kwargs.pop('msti_bridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_stp_mst_detail_output_msti_msti_bridge_priority(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        msti_bridge_priority = ET.SubElement(msti, \"msti-bridge-priority\")\n        msti_bridge_priority.text = kwargs.pop('msti_bridge_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MSTI Master Protocol priority."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_stp_mst_detail_output_msti_port_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        interface_type = ET.SubElement(port, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MST - Detail output for a specific MSTI port and interface type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets MSTI output from MSTI port and interface name.", "response": "def get_stp_mst_detail_output_msti_port_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        interface_name = ET.SubElement(port, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets MST - Detail output MSTI port spanningtree enabled.", "response": "def get_stp_mst_detail_output_msti_port_spanningtree_enabled(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        spanningtree_enabled = ET.SubElement(port, \"spanningtree-enabled\")\n        spanningtree_enabled.text = kwargs.pop('spanningtree_enabled')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the SPT entry from MSTI output.", "response": "def get_stp_mst_detail_output_msti_port_if_index(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        if_index = ET.SubElement(port, \"if-index\")\n        if_index.text = kwargs.pop('if_index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_mst_detail_output_msti_port_interface_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        interface_id = ET.SubElement(port, \"interface-id\")\n        interface_id.text = kwargs.pop('interface_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MSTI output MSTI port and interface ID."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_stp_mst_detail_output_msti_port_if_role(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        if_role = ET.SubElement(port, \"if-role\")\n        if_role.text = kwargs.pop('if_role')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MSTI output from MSTI port and if role."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_stp_mst_detail_output_msti_port_if_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        if_state = ET.SubElement(port, \"if-state\")\n        if_state.text = kwargs.pop('if_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MSTI output from MSTI port if state"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_stp_mst_detail_output_msti_port_external_path_cost(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        external_path_cost = ET.SubElement(port, \"external-path-cost\")\n        external_path_cost.text = kwargs.pop('external_path_cost')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT entry MSTI output MSTI port external path cost."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_stp_mst_detail_output_msti_port_internal_path_cost(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        internal_path_cost = ET.SubElement(port, \"internal-path-cost\")\n        internal_path_cost.text = kwargs.pop('internal_path_cost')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT entry from MSTI output."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting SPT entry MSTI output MSTI port configured path cost.", "response": "def get_stp_mst_detail_output_msti_port_configured_path_cost(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        configured_path_cost = ET.SubElement(port, \"configured-path-cost\")\n        configured_path_cost.text = kwargs.pop('configured_path_cost')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_stp_mst_detail_output_msti_port_designated_port_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        designated_port_id = ET.SubElement(port, \"designated-port-id\")\n        designated_port_id.text = kwargs.pop('designated_port_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MSTI port designated port ID"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget SPT entry MSTI output MSTI port and priority.", "response": "def get_stp_mst_detail_output_msti_port_port_priority(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        port_priority = ET.SubElement(port, \"port-priority\")\n        port_priority.text = kwargs.pop('port_priority')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_stp_mst_detail_output_msti_port_designated_bridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        designated_bridge_id = ET.SubElement(port, \"designated-bridge-id\")\n        designated_bridge_id.text = kwargs.pop('designated_bridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MST - Detail output for a specific port designated bridge."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_stp_mst_detail_output_msti_port_port_hello_time(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        port_hello_time = ET.SubElement(port, \"port-hello-time\")\n        port_hello_time.text = kwargs.pop('port_hello_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MSTI Port - Hello Time"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_stp_mst_detail_output_msti_port_forward_transitions_count(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        forward_transitions_count = ET.SubElement(port, \"forward-transitions-count\")\n        forward_transitions_count.text = kwargs.pop('forward_transitions_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MSTI status output MSTI port and forward transitions count."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget SPT entry from MSTI output.", "response": "def get_stp_mst_detail_output_msti_port_received_stp_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        received_stp_type = ET.SubElement(port, \"received-stp-type\")\n        received_stp_type.text = kwargs.pop('received_stp_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_stp_mst_detail_output_msti_port_transmitted_stp_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        transmitted_stp_type = ET.SubElement(port, \"transmitted-stp-type\")\n        transmitted_stp_type.text = kwargs.pop('transmitted_stp_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT entry from MSTI output."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_stp_mst_detail_output_msti_port_edge_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        edge_port = ET.SubElement(port, \"edge-port\")\n        edge_port.text = kwargs.pop('edge_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the SPT entry from MSTI output."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_mst_detail_output_msti_port_auto_edge(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        auto_edge = ET.SubElement(port, \"auto-edge\")\n        auto_edge.text = kwargs.pop('auto_edge')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MST - Detail output MSTI port and auto - edge."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_stp_mst_detail_output_msti_port_admin_edge(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        admin_edge = ET.SubElement(port, \"admin-edge\")\n        admin_edge.text = kwargs.pop('admin_edge')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MST - Detail output MSTI port and admin edge."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget SPT entry MSTI output MSTI port and edge delay.", "response": "def get_stp_mst_detail_output_msti_port_edge_delay(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        edge_delay = ET.SubElement(port, \"edge-delay\")\n        edge_delay.text = kwargs.pop('edge_delay')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_mst_detail_output_msti_port_configured_root_guard(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        configured_root_guard = ET.SubElement(port, \"configured-root-guard\")\n        configured_root_guard.text = kwargs.pop('configured_root_guard')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST detail output MSTI port configured root guard."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting SPT entry MSTI output.", "response": "def get_stp_mst_detail_output_msti_port_oper_root_guard(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        oper_root_guard = ET.SubElement(port, \"oper-root-guard\")\n        oper_root_guard.text = kwargs.pop('oper_root_guard')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_mst_detail_output_msti_port_boundary_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        boundary_port = ET.SubElement(port, \"boundary-port\")\n        boundary_port.text = kwargs.pop('boundary_port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST detail output MSTI port boundary_port"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget SPT MST detail output MSTI port and oper BPDU guard.", "response": "def get_stp_mst_detail_output_msti_port_oper_bpdu_guard(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        oper_bpdu_guard = ET.SubElement(port, \"oper-bpdu-guard\")\n        oper_bpdu_guard.text = kwargs.pop('oper_bpdu_guard')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting SPT MST detail output MSTI port AND OP_BPDU filter.", "response": "def get_stp_mst_detail_output_msti_port_oper_bpdu_filter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        oper_bpdu_filter = ET.SubElement(port, \"oper-bpdu-filter\")\n        oper_bpdu_filter.text = kwargs.pop('oper_bpdu_filter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_stp_mst_detail_output_msti_port_link_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        link_type = ET.SubElement(port, \"link-type\")\n        link_type.text = kwargs.pop('link_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the SPT entry from MSTI output."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_stp_mst_detail_output_msti_port_rx_bpdu_count(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        rx_bpdu_count = ET.SubElement(port, \"rx-bpdu-count\")\n        rx_bpdu_count.text = kwargs.pop('rx_bpdu_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST detail output MSTI port and rx BPDU count."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_mst_detail_output_msti_port_tx_bpdu_count(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        tx_bpdu_count = ET.SubElement(port, \"tx-bpdu-count\")\n        tx_bpdu_count.text = kwargs.pop('tx_bpdu_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get SPT MST detail output MSTI port and TX BPDU count."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget SPT MST Entry output has - more.", "response": "def get_stp_mst_detail_output_has_more(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stp_mst_detail_output_last_instance_instance_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        last_instance = ET.SubElement(output, \"last-instance\")\n        instance_id = ET.SubElement(last_instance, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the SPT entry from MST detail XML output."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_once(func):\n    ''' Decorator for making sure a method can only be executed once '''\n    def wrapper(*args, **kwargs):\n        if not wrapper.has_run:\n            wrapper.has_run = True\n            return func(*args, **kwargs)\n    wrapper.has_run = False\n    return wrapper", "response": "Decorator for making sure a method can only be executed once"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef openflow_controller_connection_address_active_controller_vrf(self, **kwargs):\n        config = ET.Element(\"config\")\n        openflow_controller = ET.SubElement(config, \"openflow-controller\", xmlns=\"urn:brocade.com:mgmt:brocade-openflow\")\n        controller_name_key = ET.SubElement(openflow_controller, \"controller-name\")\n        controller_name_key.text = kwargs.pop('controller_name')\n        connection_address = ET.SubElement(openflow_controller, \"connection-address\")\n        active_controller_vrf = ET.SubElement(connection_address, \"active-controller-vrf\")\n        active_controller_vrf.text = kwargs.pop('active_controller_vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a resource from the openflow controller connection address active controller VRF"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bp_rate_limit_heavy_bp_rate_limit_slot_bp_rate_limit_slot_num(self, **kwargs):\n        config = ET.Element(\"config\")\n        bp_rate_limit = ET.SubElement(config, \"bp-rate-limit\", xmlns=\"urn:brocade.com:mgmt:brocade-bprate-limit\")\n        heavy = ET.SubElement(bp_rate_limit, \"heavy\")\n        bp_rate_limit_slot = ET.SubElement(heavy, \"bp-rate-limit-slot\")\n        bp_rate_limit_slot_num = ET.SubElement(bp_rate_limit_slot, \"bp-rate-limit-slot-num\")\n        bp_rate_limit_slot_num.text = kwargs.pop('bp_rate_limit_slot_num')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize BP rate limit heavy and bp rate limit slot num"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading firmware to device", "response": "def download(self, protocol, host, user, password,\n                 file_name, rbridge='all'):\n        \"\"\"\n        Download firmware to device\n        \"\"\"\n        urn = \"{urn:brocade.com:mgmt:brocade-firmware}\"\n        request_fwdl = self.get_firmware_download_request(protocol, host,\n                                                          user, password,\n                                                          file_name, rbridge)\n        response = self._callback(request_fwdl, 'get')\n        fwdl_result = None\n        for item in response.findall('%scluster-output' % urn):\n            fwdl_result = item.find('%sfwdl-msg' % urn).text\n        if not fwdl_result:\n            fwdl_result = response.find('%sfwdl-cmd-msg' % urn).text\n        return fwdl_result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register(self, resource, endpoint):\n        '''\n        This methods registers a resource with the router and connects all receivers to their respective signals\n\n        :param resource:\n            The resource class to register\n        :type resource:\n            A subclass of ``Resource`` class\n        :param endpoint:\n            the name of the resource's endpoint as it appears in the URL\n        :type endpoint:\n            str\n        '''\n        if not issubclass(resource, Resource):\n            raise ValueError('Not and instance of ``Resource`` subclass')\n        # register resource\n        self._registry[endpoint] = resource\n        # connect signal receivers\n        resource.connect_signal_receivers()", "response": "This method registers a resource with the router and connects all receivers to their respective signals"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef urls_old(self, protocol=Resource.Protocol.http):\n        '''\n        Iterate through all resources registered with this router\n        and create a list endpoint and a detail endpoint for each one.\n        Uses the router name as prefix and endpoint name of the resource when registered, to assemble the url pattern.\n        Uses the constructor-passed url method or class for generating urls\n        '''\n        url_patterns = []\n        for endpoint, resource_class in self._registry.items():\n            setattr(resource_class, 'api_name', self.name)\n            setattr(resource_class, 'resource_name', endpoint)\n            # append any nested resources the resource may have\n            nested = []\n            for route in resource_class.nested_routes('/%s/%s/' % (self.name, endpoint)):\n                route = route._replace(handler=resource_class.wrap_handler(route.handler, protocol))\n                nested.append(route)\n\n            url_patterns.extend(nested)\n            # append resource as list\n            url_patterns.append(Route(\n                path='/%s/%s/' % (self.name, endpoint),\n                handler=resource_class.as_list(protocol),\n                methods=resource_class.route_methods(),\n                name='{}_{}_list'.format(self.name, endpoint).replace('/', '_')\n            ))\n            # append resource as detail\n            url_patterns.append(Route(\n                path='/%s/%s/%s/' % (self.name, endpoint, resource_class.route_param('pk')),\n                handler=resource_class.as_detail(protocol),\n                methods=resource_class.route_methods(),\n                name='{}_{}_detail'.format(self.name, endpoint).replace('/', '_')\n            ))\n        return url_patterns", "response": "Generate a list of all urls that are not part of the current router."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndispatches an incoming request and passes it to the relevant resource handler. Returns the response.", "response": "async def dispatch(self, app, payload):\n        '''\n        Dispatches an incoming request and passes it to the relevant resource\n        returning the response.\n\n        :param app:\n            Application handler. must be passed as part of the request\n\n        :param payload:\n            The request payload, contains all the parameters of the request\n        '''\n        handler = None\n        params = {}\n        # parse request url, separating query params if any\n        url = urlparse(payload['href'])\n        path = url.path\n        params.update(dict(parse_qsl(url.query)))\n        params.update(payload.get('args', {}))\n        # find the matching url , getting handler and arguments\n        for route in self.urls(True, Resource.Protocol.websocket):\n            match = re.match(route.path, path)\n            if match:\n                handler = route.handler\n                params.update(match.groupdict())\n                break\n        if handler:\n            request = Request(\n                app=app,\n                key=payload.get('key', None),\n                method=payload.get('method', 'GET'),\n                url=path,\n                args=params,\n                headers=payload.get('headers', None),\n                body=payload.get('body', {})\n            )\n            response = await handler(request)\n            return response\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_fabric_trunk_info_input_rbridge_id_or_all_all_all(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_fabric_trunk_info = ET.Element(\"show_fabric_trunk_info\")\n        config = show_fabric_trunk_info\n        input = ET.SubElement(show_fabric_trunk_info, \"input\")\n        rbridge_id_or_all = ET.SubElement(input, \"rbridge-id-or-all\")\n        all = ET.SubElement(rbridge_id_or_all, \"all\")\n        all = ET.SubElement(all, \"all\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Fabric Trunk Info input rbridge - id or all - all all."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a vCenter to the switch.", "response": "def add_vcenter(self, **kwargs):\n        \"\"\"\n        Add vCenter on the switch\n\n        Args:\n            id(str) : Name of an established vCenter\n            url (bool) : vCenter URL\n            username (str): Username of the vCenter\n            password (str): Password of the vCenter\n            callback (function): A function executed upon completion of the\n                 method.\n\n        Returns:\n           Return value of `callback`.\n\n        Raises:\n            None\n        \"\"\"\n        config = ET.Element(\"config\")\n        vcenter = ET.SubElement(config, \"vcenter\",\n                                xmlns=\"urn:brocade.com:mgmt:brocade-vswitch\")\n        id = ET.SubElement(vcenter, \"id\")\n        id.text = kwargs.pop('id')\n        credentials = ET.SubElement(vcenter, \"credentials\")\n        url = ET.SubElement(credentials, \"url\")\n        url.text = kwargs.pop('url')\n        username = ET.SubElement(credentials, \"username\")\n        username.text = kwargs.pop('username')\n        password = ET.SubElement(credentials, \"password\")\n        password.text = kwargs.pop('password')\n\n        try:\n            self._callback(config)\n            return True\n\n        except Exception as error:\n            logging.error(error)\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef activate_vcenter(self, **kwargs):\n        name = kwargs.pop('name')\n        activate = kwargs.pop('activate', True)\n        vcenter_args = dict(id=name)\n        method_class = self._brocade_vswitch\n        if activate:\n            method_name = 'vcenter_activate'\n            vcenter_attr = getattr(method_class, method_name)\n            config = vcenter_attr(**vcenter_args)\n            output = self._callback(config)\n            print output\n            return output\n        else:\n            pass", "response": "Activate vCenter on the switch."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting vCenter hosts on the switch", "response": "def get_vcenter(self, **kwargs):\n        \"\"\"\n        Get vCenter hosts on the switch\n\n        Args:\n\n            callback (function): A function executed upon completion of the\n                 method.\n\n        Returns:\n           Returns a list of vcenters\n\n        Raises:\n            None\n        \"\"\"\n        config = ET.Element(\"config\")\n        urn = \"urn:brocade.com:mgmt:brocade-vswitch\"\n        ET.SubElement(config, \"vcenter\", xmlns=urn)\n        output = self._callback(config, handler='get_config')\n        result = []\n        element = ET.fromstring(str(output))\n        for vcenter in element.iter('{%s}vcenter'%urn):\n            vc = {}\n            vc['name'] = vcenter.find('{%s}id' % urn).text\n            vc['url'] = (vcenter.find('{%s}credentials' % urn)).find('{%s}url' % urn).text\n            isactive = vcenter.find('{%s}activate' %urn)\n            if isactive is None:\n                vc['isactive'] = False\n            else:\n                vc['isactive'] = True\n            result.append(vc)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef netconf_config_change_changed_by_server_or_user_server_server(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_config_change = ET.SubElement(config, \"netconf-config-change\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        changed_by = ET.SubElement(netconf_config_change, \"changed-by\")\n        server_or_user = ET.SubElement(changed_by, \"server-or-user\")\n        server = ET.SubElement(server_or_user, \"server\")\n        server = ET.SubElement(server, \"server\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config for the cluster config change changed by server or user."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the config of a Netconf config change changed by server or user by username.", "response": "def netconf_config_change_changed_by_server_or_user_by_user_username(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_config_change = ET.SubElement(config, \"netconf-config-change\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        changed_by = ET.SubElement(netconf_config_change, \"changed-by\")\n        server_or_user = ET.SubElement(changed_by, \"server-or-user\")\n        by_user = ET.SubElement(server_or_user, \"by-user\")\n        username = ET.SubElement(by_user, \"username\")\n        username.text = kwargs.pop('username')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef netconf_config_change_changed_by_server_or_user_by_user_session_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_config_change = ET.SubElement(config, \"netconf-config-change\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        changed_by = ET.SubElement(netconf_config_change, \"changed-by\")\n        server_or_user = ET.SubElement(changed_by, \"server-or-user\")\n        by_user = ET.SubElement(server_or_user, \"by-user\")\n        session_id = ET.SubElement(by_user, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf config change changed by server or user by user session id."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the config of a netconf - config - change changed by server or user by source host.", "response": "def netconf_config_change_changed_by_server_or_user_by_user_source_host(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_config_change = ET.SubElement(config, \"netconf-config-change\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        changed_by = ET.SubElement(netconf_config_change, \"changed-by\")\n        server_or_user = ET.SubElement(changed_by, \"server-or-user\")\n        by_user = ET.SubElement(server_or_user, \"by-user\")\n        source_host = ET.SubElement(by_user, \"source-host\")\n        source_host.text = kwargs.pop('source_host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef netconf_config_change_datastore(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_config_change = ET.SubElement(config, \"netconf-config-change\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        datastore = ET.SubElement(netconf_config_change, \"datastore\")\n        datastore.text = kwargs.pop('datastore')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the current resource from the datastore."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef netconf_config_change_edit_target(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_config_change = ET.SubElement(config, \"netconf-config-change\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        edit = ET.SubElement(netconf_config_change, \"edit\")\n        target = ET.SubElement(edit, \"target\")\n        target.text = kwargs.pop('target')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set config to edit target for resource netconf config change"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the config for the cluster config change edit operation.", "response": "def netconf_config_change_edit_operation(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_config_change = ET.SubElement(config, \"netconf-config-change\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        edit = ET.SubElement(netconf_config_change, \"edit\")\n        operation = ET.SubElement(edit, \"operation\")\n        operation.text = kwargs.pop('operation')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef netconf_capability_change_changed_by_server_or_user_server_server(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_capability_change = ET.SubElement(config, \"netconf-capability-change\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        changed_by = ET.SubElement(netconf_capability_change, \"changed-by\")\n        server_or_user = ET.SubElement(changed_by, \"server-or-user\")\n        server = ET.SubElement(server_or_user, \"server\")\n        server = ET.SubElement(server, \"server\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf capability change changed by server or user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef netconf_capability_change_changed_by_server_or_user_by_user_username(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_capability_change = ET.SubElement(config, \"netconf-capability-change\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        changed_by = ET.SubElement(netconf_capability_change, \"changed-by\")\n        server_or_user = ET.SubElement(changed_by, \"server-or-user\")\n        by_user = ET.SubElement(server_or_user, \"by-user\")\n        username = ET.SubElement(by_user, \"username\")\n        username.text = kwargs.pop('username')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf Capability Change from server or user by username."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets Netconf Capability Change from server or user by session id.", "response": "def netconf_capability_change_changed_by_server_or_user_by_user_session_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_capability_change = ET.SubElement(config, \"netconf-capability-change\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        changed_by = ET.SubElement(netconf_capability_change, \"changed-by\")\n        server_or_user = ET.SubElement(changed_by, \"server-or-user\")\n        by_user = ET.SubElement(server_or_user, \"by-user\")\n        session_id = ET.SubElement(by_user, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef netconf_capability_change_changed_by_server_or_user_by_user_source_host(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_capability_change = ET.SubElement(config, \"netconf-capability-change\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        changed_by = ET.SubElement(netconf_capability_change, \"changed-by\")\n        server_or_user = ET.SubElement(changed_by, \"server-or-user\")\n        by_user = ET.SubElement(server_or_user, \"by-user\")\n        source_host = ET.SubElement(by_user, \"source-host\")\n        source_host.text = kwargs.pop('source_host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf capability change changed by server or user by source host."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconfigure username for current netconf session start", "response": "def netconf_session_start_username(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_session_start = ET.SubElement(config, \"netconf-session-start\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        username = ET.SubElement(netconf_session_start, \"username\")\n        username.text = kwargs.pop('username')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset session id for Netconf", "response": "def netconf_session_start_session_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_session_start = ET.SubElement(config, \"netconf-session-start\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        session_id = ET.SubElement(netconf_session_start, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart the netconf session for the source host", "response": "def netconf_session_start_source_host(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_session_start = ET.SubElement(config, \"netconf-session-start\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        source_host = ET.SubElement(netconf_session_start, \"source-host\")\n        source_host.text = kwargs.pop('source_host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nending the username of the current session.", "response": "def netconf_session_end_username(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_session_end = ET.SubElement(config, \"netconf-session-end\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        username = ET.SubElement(netconf_session_end, \"username\")\n        username.text = kwargs.pop('username')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nending the session id of the current resource.", "response": "def netconf_session_end_session_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_session_end = ET.SubElement(config, \"netconf-session-end\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        session_id = ET.SubElement(netconf_session_end, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nends the netconf session for a source host", "response": "def netconf_session_end_source_host(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_session_end = ET.SubElement(config, \"netconf-session-end\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        source_host = ET.SubElement(netconf_session_end, \"source-host\")\n        source_host.text = kwargs.pop('source_host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef netconf_session_end_killed_by(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_session_end = ET.SubElement(config, \"netconf-session-end\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        killed_by = ET.SubElement(netconf_session_end, \"killed-by\")\n        killed_by.text = kwargs.pop('killed_by')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "End of Killed By"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef netconf_session_end_termination_reason(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_session_end = ET.SubElement(config, \"netconf-session-end\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        termination_reason = ET.SubElement(netconf_session_end, \"termination-reason\")\n        termination_reason.text = kwargs.pop('termination_reason')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set termination reason of the current session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the username of the user that the user has confirmed the log entries for this bundle.", "response": "def netconf_confirmed_commit_username(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_confirmed_commit = ET.SubElement(config, \"netconf-confirmed-commit\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        username = ET.SubElement(netconf_confirmed_commit, \"username\")\n        username.text = kwargs.pop('username')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef netconf_confirmed_commit_session_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_confirmed_commit = ET.SubElement(config, \"netconf-confirmed-commit\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        session_id = ET.SubElement(netconf_confirmed_commit, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf Confirmed Commit Session ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef netconf_confirmed_commit_source_host(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_confirmed_commit = ET.SubElement(config, \"netconf-confirmed-commit\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        source_host = ET.SubElement(netconf_confirmed_commit, \"source-host\")\n        source_host.text = kwargs.pop('source_host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the current NIC."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the config element for the Netconf Confirmed Commit event.", "response": "def netconf_confirmed_commit_confirm_event(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_confirmed_commit = ET.SubElement(config, \"netconf-confirmed-commit\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        confirm_event = ET.SubElement(netconf_confirmed_commit, \"confirm-event\")\n        confirm_event.text = kwargs.pop('confirm_event')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef netconf_confirmed_commit_timeout(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_confirmed_commit = ET.SubElement(config, \"netconf-confirmed-commit\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\")\n        timeout = ET.SubElement(netconf_confirmed_commit, \"timeout\")\n        timeout.text = kwargs.pop('timeout')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set timeout for Netconf Confirmed Commit"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef maps_re_apply_policy_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        maps_re_apply_policy = ET.Element(\"maps_re_apply_policy\")\n        config = maps_re_apply_policy\n        input = ET.SubElement(maps_re_apply_policy, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Configure Airflow resource to apply policy input rbridge - id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef maps_get_default_rules_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        maps_get_default_rules = ET.Element(\"maps_get_default_rules\")\n        config = maps_get_default_rules\n        input = ET.SubElement(maps_get_default_rules, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get default rules input rbridge_id."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget default rules output rules rbridgeid", "response": "def maps_get_default_rules_output_rules_rbridgeid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_default_rules = ET.Element(\"maps_get_default_rules\")\n        config = maps_get_default_rules\n        output = ET.SubElement(maps_get_default_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        rbridgeid = ET.SubElement(rules, \"rbridgeid\")\n        rbridgeid.text = kwargs.pop('rbridgeid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef maps_get_default_rules_output_rules_rulename(self, **kwargs):\n        config = ET.Element(\"config\")\n        maps_get_default_rules = ET.Element(\"maps_get_default_rules\")\n        config = maps_get_default_rules\n        output = ET.SubElement(maps_get_default_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        rulename = ET.SubElement(rules, \"rulename\")\n        rulename.text = kwargs.pop('rulename')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get default rules output rules rulename"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets default rules output rules groupname", "response": "def maps_get_default_rules_output_rules_groupname(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_default_rules = ET.Element(\"maps_get_default_rules\")\n        config = maps_get_default_rules\n        output = ET.SubElement(maps_get_default_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        groupname = ET.SubElement(rules, \"groupname\")\n        groupname.text = kwargs.pop('groupname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef maps_get_default_rules_output_rules_monitor(self, **kwargs):\n        config = ET.Element(\"config\")\n        maps_get_default_rules = ET.Element(\"maps_get_default_rules\")\n        config = maps_get_default_rules\n        output = ET.SubElement(maps_get_default_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        monitor = ET.SubElement(rules, \"monitor\")\n        monitor.text = kwargs.pop('monitor')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get default rules output rules monitor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting default rules output rules and op.", "response": "def maps_get_default_rules_output_rules_op(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_default_rules = ET.Element(\"maps_get_default_rules\")\n        config = maps_get_default_rules\n        output = ET.SubElement(maps_get_default_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        op = ET.SubElement(rules, \"op\")\n        op.text = kwargs.pop('op')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget default rules output rules value", "response": "def maps_get_default_rules_output_rules_value(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_default_rules = ET.Element(\"maps_get_default_rules\")\n        config = maps_get_default_rules\n        output = ET.SubElement(maps_get_default_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        value = ET.SubElement(rules, \"value\")\n        value.text = kwargs.pop('value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting default rules output rules action", "response": "def maps_get_default_rules_output_rules_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_default_rules = ET.Element(\"maps_get_default_rules\")\n        config = maps_get_default_rules\n        output = ET.SubElement(maps_get_default_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        action = ET.SubElement(rules, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting default rules output rules timebase", "response": "def maps_get_default_rules_output_rules_timebase(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        maps_get_default_rules = ET.Element(\"maps_get_default_rules\")\n        config = maps_get_default_rules\n        output = ET.SubElement(maps_get_default_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        timebase = ET.SubElement(rules, \"timebase\")\n        timebase.text = kwargs.pop('timebase')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef maps_get_default_rules_output_rules_policyname(self, **kwargs):\n        config = ET.Element(\"config\")\n        maps_get_default_rules = ET.Element(\"maps_get_default_rules\")\n        config = maps_get_default_rules\n        output = ET.SubElement(maps_get_default_rules, \"output\")\n        rules = ET.SubElement(output, \"rules\")\n        policyname = ET.SubElement(rules, \"policyname\")\n        policyname.text = kwargs.pop('policyname')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get default rules output rules policyname"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms authentication on the incoming request.", "response": "def perform_authentication(self):\n        \"\"\"\n        Perform authentication on the incoming request.\n        \"\"\"\n\n        if not self.authenticators:\n            return\n\n        request.user = None\n        request.auth = None\n\n        for authenticator in self.authenticators:\n            auth_tuple = authenticator.authenticate()\n\n            if auth_tuple:\n                request.user = auth_tuple[0]\n                request.auth = auth_tuple[1]\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef perform_authorization(self):\n\n        for permission in self.permissions:\n            if not permission.has_permission():\n                if request.user:\n                    raise errors.PermissionDenied()\n                else:\n                    raise errors.NotAuthenticated()", "response": "Check if the request should be permitted. Raises an appropriate exception if the request is not authenticated."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clock_sa_clock_timezone(self, **kwargs):\n        config = ET.Element(\"config\")\n        clock_sa = ET.SubElement(config, \"clock-sa\", xmlns=\"urn:brocade.com:mgmt:brocade-clock\")\n        clock = ET.SubElement(clock_sa, \"clock\")\n        timezone = ET.SubElement(clock, \"timezone\")\n        timezone.text = kwargs.pop('timezone')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the Identity System in the UTC timezone."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_clock_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_clock = ET.Element(\"show_clock\")\n        config = show_clock\n        input = ET.SubElement(show_clock, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Clock input with rbridge - id."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows Clock output clock time and rbridge - id - out.", "response": "def show_clock_output_clock_time_rbridge_id_out(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_clock = ET.Element(\"show_clock\")\n        config = show_clock\n        output = ET.SubElement(show_clock, \"output\")\n        clock_time = ET.SubElement(output, \"clock-time\")\n        rbridge_id_out = ET.SubElement(clock_time, \"rbridge-id-out\")\n        rbridge_id_out.text = kwargs.pop('rbridge_id_out')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_clock_output_clock_time_current_time(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_clock = ET.Element(\"show_clock\")\n        config = show_clock\n        output = ET.SubElement(show_clock, \"output\")\n        clock_time = ET.SubElement(output, \"clock-time\")\n        current_time = ET.SubElement(clock_time, \"current-time\")\n        current_time.text = kwargs.pop('current_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Clock output Clock time and current time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow Clock output clock time and timezone", "response": "def show_clock_output_clock_time_timezone(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_clock = ET.Element(\"show_clock\")\n        config = show_clock\n        output = ET.SubElement(show_clock, \"output\")\n        clock_time = ET.SubElement(output, \"clock-time\")\n        timezone = ET.SubElement(clock_time, \"timezone\")\n        timezone.text = kwargs.pop('timezone')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets system utime input rbridge - id.", "response": "def get_system_uptime_input_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_system_uptime = ET.Element(\"get_system_uptime\")\n        config = get_system_uptime\n        input = ET.SubElement(get_system_uptime, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting system Uptime output and show system Uptime rbridge ID.", "response": "def get_system_uptime_output_show_system_uptime_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_system_uptime = ET.Element(\"get_system_uptime\")\n        config = get_system_uptime\n        output = ET.SubElement(get_system_uptime, \"output\")\n        show_system_uptime = ET.SubElement(output, \"show-system-uptime\")\n        rbridge_id = ET.SubElement(show_system_uptime, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_system_uptime_output_show_system_uptime_days(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_system_uptime = ET.Element(\"get_system_uptime\")\n        config = get_system_uptime\n        output = ET.SubElement(get_system_uptime, \"output\")\n        show_system_uptime = ET.SubElement(output, \"show-system-uptime\")\n        rbridge_id_key = ET.SubElement(show_system_uptime, \"rbridge-id\")\n        rbridge_id_key.text = kwargs.pop('rbridge_id')\n        days = ET.SubElement(show_system_uptime, \"days\")\n        days.text = kwargs.pop('days')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get system uptime output and show system uptime days."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets system Uptime output and show system Uptime hours.", "response": "def get_system_uptime_output_show_system_uptime_hours(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_system_uptime = ET.Element(\"get_system_uptime\")\n        config = get_system_uptime\n        output = ET.SubElement(get_system_uptime, \"output\")\n        show_system_uptime = ET.SubElement(output, \"show-system-uptime\")\n        rbridge_id_key = ET.SubElement(show_system_uptime, \"rbridge-id\")\n        rbridge_id_key.text = kwargs.pop('rbridge_id')\n        hours = ET.SubElement(show_system_uptime, \"hours\")\n        hours.text = kwargs.pop('hours')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_system_uptime_output_show_system_uptime_minutes(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_system_uptime = ET.Element(\"get_system_uptime\")\n        config = get_system_uptime\n        output = ET.SubElement(get_system_uptime, \"output\")\n        show_system_uptime = ET.SubElement(output, \"show-system-uptime\")\n        rbridge_id_key = ET.SubElement(show_system_uptime, \"rbridge-id\")\n        rbridge_id_key.text = kwargs.pop('rbridge_id')\n        minutes = ET.SubElement(show_system_uptime, \"minutes\")\n        minutes.text = kwargs.pop('minutes')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get System Uptime output and show system Uptime minutes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets System Uptime output and show system Uptime Seconds.", "response": "def get_system_uptime_output_show_system_uptime_seconds(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_system_uptime = ET.Element(\"get_system_uptime\")\n        config = get_system_uptime\n        output = ET.SubElement(get_system_uptime, \"output\")\n        show_system_uptime = ET.SubElement(output, \"show-system-uptime\")\n        rbridge_id_key = ET.SubElement(show_system_uptime, \"rbridge-id\")\n        rbridge_id_key.text = kwargs.pop('rbridge_id')\n        seconds = ET.SubElement(show_system_uptime, \"seconds\")\n        seconds.text = kwargs.pop('seconds')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets System Uptime Entry", "response": "def get_system_uptime_output_cmd_error(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_system_uptime = ET.Element(\"get_system_uptime\")\n        config = get_system_uptime\n        output = ET.SubElement(get_system_uptime, \"output\")\n        cmd_error = ET.SubElement(output, \"cmd-error\")\n        cmd_error.text = kwargs.pop('cmd_error')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rgb_to_short(rgb, mapping):\n    # Thanks to Micah Elliott (http://MicahElliott.com) for colortrans.py\n    rgb = rgb.lstrip('#') if rgb.startswith('#') else rgb\n    incs = (0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff)\n    # Break 6-char RGB code into 3 integer vals.\n    parts = [int(h, 16) for h in re.split(r'(..)(..)(..)', rgb)[1:4]]\n    res = []\n    for part in parts:\n        i = 0\n        while i < len(incs)-1:\n            s, b = incs[i], incs[i+1]  # smaller, bigger\n            if s <= part <= b:\n                s1 = abs(s - part)\n                b1 = abs(b - part)\n                if s1 < b1: closest = s\n                else: closest = b\n                res.append(closest)\n                break\n            i += 1\n    res = ''.join([ ('%02.x' % i) for i in res ])\n    equiv = mapping[res]\n    return equiv, res", "response": "Find the closest xterm - 256 approximation to the given RGB value."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts pygmets style to urwid palatte", "response": "def register_palette(self):\n        \"\"\"Converts pygmets style to urwid palatte\"\"\"\n        default = 'default'\n        palette = list(self.palette)\n        mapping = CONFIG['rgb_to_short']\n        for tok in self.style.styles.keys():\n            for t in tok.split()[::-1]:\n                st = self.style.styles[t]\n                if '#' in st:\n                    break\n            if '#' not in st:\n                st = ''\n            st = st.split()\n            st.sort()   # '#' comes before '[A-Za-z0-9]'\n            if len(st) == 0:\n                c = default\n            elif st[0].startswith('bg:'):\n                c = default\n            elif len(st[0]) == 7:\n                c = 'h' + rgb_to_short(st[0][1:], mapping)[0]\n            elif len(st[0]) == 4:\n                c = 'h' + rgb_to_short(st[0][1]*2 + st[0][2]*2 + st[0][3]*2, mapping)[0]\n            else:\n                c = default\n            a = urwid.AttrSpec(c, default, colors=256)\n            row = (tok, default, default, default, a.foreground, default)\n            palette.append(row)\n        self.loop.screen.register_palette(palette)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ntp_server_ip(self, **kwargs):\n        config = ET.Element(\"config\")\n        ntp = ET.SubElement(config, \"ntp\", xmlns=\"urn:brocade.com:mgmt:brocade-ntp\")\n        server = ET.SubElement(ntp, \"server\")\n        use_vrf_key = ET.SubElement(server, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        ip = ET.SubElement(server, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NTP server IP"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ntp_server_key(self, **kwargs):\n        config = ET.Element(\"config\")\n        ntp = ET.SubElement(config, \"ntp\", xmlns=\"urn:brocade.com:mgmt:brocade-ntp\")\n        server = ET.SubElement(ntp, \"server\")\n        ip_key = ET.SubElement(server, \"ip\")\n        ip_key.text = kwargs.pop('ip')\n        use_vrf_key = ET.SubElement(server, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        key = ET.SubElement(server, \"key\")\n        key.text = kwargs.pop('key')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get NTP server key"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset use - vrf of the NTP server", "response": "def ntp_server_use_vrf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ntp = ET.SubElement(config, \"ntp\", xmlns=\"urn:brocade.com:mgmt:brocade-ntp\")\n        server = ET.SubElement(ntp, \"server\")\n        ip_key = ET.SubElement(server, \"ip\")\n        ip_key.text = kwargs.pop('ip')\n        use_vrf = ET.SubElement(server, \"use-vrf\")\n        use_vrf.text = kwargs.pop('use_vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef increment(self):\n        # Increment position from the deepest place of the tree first.\n        for index in reversed(range(self.depth)):\n            self.indexes[index] += 1\n            # We haven't reached the end of board, no need to adjust upper\n            # level.\n            if self.indexes[index] < self.range_size:\n                break\n            # We've reached the end of board. Reset current level and increment\n            # the upper level.\n            self.indexes[index] = 0\n\n        # Now that we incremented our indexes, we need to deduplicate positions\n        # shering the same UIDs, by aligning piece's indexes to their parents.\n        # This works thanks to the sort performed on self.pieces\n        # initialization. See #7.\n        for i in range(self.depth - 1):\n            if (self.pieces[i] == self.pieces[i + 1]) and (\n                    self.indexes[i] > self.indexes[i + 1]):\n                self.indexes[i + 1] = self.indexes[i]", "response": "Increment the last permutation we returned to the next."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a level skip to the next branch.", "response": "def skip_branch(self, level):\n        \"\"\" Abandon the branch at the provided level and skip to the next.\n\n        When we call out to skip to the next branch of the search space, we\n        push sublevel pieces to the maximum positions of the board. So that the\n        next time the permutation iterator is called, it can produce the vector\n        state of the next adjacent branch. See #3.\n        \"\"\"\n        for i in range(level + 1, self.depth):\n            self.indexes[i] = self.range_size - 1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef solve(self):\n        # Create a new, empty board.\n        board = Board(self.length, self.height)\n\n        # Iterate through all combinations of positions.\n        permutations = Permutations(self.pieces, self.vector_size)\n        for positions in permutations:\n\n            # Reuse board but flush all pieces.\n            board.reset()\n\n            for level, (piece_uid, linear_position) in enumerate(positions):\n                # Try to place the piece on the board.\n                try:\n                    board.add(piece_uid, linear_position)\n                # If one of the piece can't be added, throw the whole set, skip\n                # the rotten branch and proceed to the next.\n                except (OccupiedPosition, VulnerablePosition, AttackablePiece):\n                    permutations.skip_branch(level)\n                    break\n\n            else:\n                # All pieces fits, save solution and proceeed to the next\n                # permutation.\n                self.result_counter += 1\n                yield board", "response": "Solve all possible positions of pieces within the context."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_raslog_input_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        input = ET.SubElement(show_raslog, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show AirSaslog entry entry."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows All Raslog entry attributes.", "response": "def show_raslog_output_show_all_raslog_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        show_all_raslog = ET.SubElement(output, \"show-all-raslog\")\n        rbridge_id = ET.SubElement(show_all_raslog, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing All Raslog entries", "response": "def show_raslog_output_show_all_raslog_number_of_entries(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        show_all_raslog = ET.SubElement(output, \"show-all-raslog\")\n        number_of_entries = ET.SubElement(show_all_raslog, \"number-of-entries\")\n        number_of_entries.text = kwargs.pop('number_of_entries')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_raslog_output_show_all_raslog_raslog_entries_index(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        show_all_raslog = ET.SubElement(output, \"show-all-raslog\")\n        raslog_entries = ET.SubElement(show_all_raslog, \"raslog-entries\")\n        index = ET.SubElement(raslog_entries, \"index\")\n        index.text = kwargs.pop('index')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show All Raslog entries index."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_raslog_output_show_all_raslog_raslog_entries_message_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        show_all_raslog = ET.SubElement(output, \"show-all-raslog\")\n        raslog_entries = ET.SubElement(show_all_raslog, \"raslog-entries\")\n        message_id = ET.SubElement(raslog_entries, \"message-id\")\n        message_id.text = kwargs.pop('message_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show All Raslog entries"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows All Raslog Entry entries date and time info.", "response": "def show_raslog_output_show_all_raslog_raslog_entries_date_and_time_info(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        show_all_raslog = ET.SubElement(output, \"show-all-raslog\")\n        raslog_entries = ET.SubElement(show_all_raslog, \"raslog-entries\")\n        date_and_time_info = ET.SubElement(raslog_entries, \"date-and-time-info\")\n        date_and_time_info.text = kwargs.pop('date_and_time_info')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_raslog_output_show_all_raslog_raslog_entries_severity(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        show_all_raslog = ET.SubElement(output, \"show-all-raslog\")\n        raslog_entries = ET.SubElement(show_all_raslog, \"raslog-entries\")\n        severity = ET.SubElement(raslog_entries, \"severity\")\n        severity.text = kwargs.pop('severity')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show All Raslog entries severity"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_raslog_output_show_all_raslog_raslog_entries_repeat_count(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        show_all_raslog = ET.SubElement(output, \"show-all-raslog\")\n        raslog_entries = ET.SubElement(show_all_raslog, \"raslog-entries\")\n        repeat_count = ET.SubElement(raslog_entries, \"repeat-count\")\n        repeat_count.text = kwargs.pop('repeat_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show All Raslog entries repeat_count."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing All Raslog Entry messages", "response": "def show_raslog_output_show_all_raslog_raslog_entries_message(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        show_all_raslog = ET.SubElement(output, \"show-all-raslog\")\n        raslog_entries = ET.SubElement(show_all_raslog, \"raslog-entries\")\n        message = ET.SubElement(raslog_entries, \"message\")\n        message.text = kwargs.pop('message')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_raslog_output_show_all_raslog_raslog_entries_message_flag(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        show_all_raslog = ET.SubElement(output, \"show-all-raslog\")\n        raslog_entries = ET.SubElement(show_all_raslog, \"raslog-entries\")\n        message_flag = ET.SubElement(raslog_entries, \"message-flag\")\n        message_flag.text = kwargs.pop('message_flag')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show All Raslog entries message flag."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_raslog_output_show_all_raslog_raslog_entries_log_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        show_all_raslog = ET.SubElement(output, \"show-all-raslog\")\n        raslog_entries = ET.SubElement(show_all_raslog, \"raslog-entries\")\n        log_type = ET.SubElement(raslog_entries, \"log-type\")\n        log_type.text = kwargs.pop('log_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show All Raslog entries log type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow All Raslog entries switch or chassis name.", "response": "def show_raslog_output_show_all_raslog_raslog_entries_switch_or_chassis_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        show_all_raslog = ET.SubElement(output, \"show-all-raslog\")\n        raslog_entries = ET.SubElement(show_all_raslog, \"raslog-entries\")\n        switch_or_chassis_name = ET.SubElement(raslog_entries, \"switch-or-chassis-name\")\n        switch_or_chassis_name.text = kwargs.pop('switch_or_chassis_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshowing the resource status of the current resource.", "response": "def show_raslog_output_cmd_status_error_msg(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_raslog = ET.Element(\"show_raslog\")\n        config = show_raslog\n        output = ET.SubElement(show_raslog, \"output\")\n        cmd_status_error_msg = ET.SubElement(output, \"cmd-status-error-msg\")\n        cmd_status_error_msg.text = kwargs.pop('cmd_status_error_msg')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshows Support Save Status input rbridge - id.", "response": "def show_support_save_status_input_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_support_save_status = ET.Element(\"show_support_save_status\")\n        config = show_support_save_status\n        input = ET.SubElement(show_support_save_status, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshow Support Save Status output for a resource.", "response": "def show_support_save_status_output_show_support_save_status_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_support_save_status = ET.Element(\"show_support_save_status\")\n        config = show_support_save_status\n        output = ET.SubElement(show_support_save_status, \"output\")\n        show_support_save_status = ET.SubElement(output, \"show-support-save-status\")\n        rbridge_id = ET.SubElement(show_support_save_status, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_support_save_status_output_show_support_save_status_status(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_support_save_status = ET.Element(\"show_support_save_status\")\n        config = show_support_save_status\n        output = ET.SubElement(show_support_save_status, \"output\")\n        show_support_save_status = ET.SubElement(output, \"show-support-save-status\")\n        status = ET.SubElement(show_support_save_status, \"status\")\n        status.text = kwargs.pop('status')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Support Save Status output"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_support_save_status_output_show_support_save_status_message(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_support_save_status = ET.Element(\"show_support_save_status\")\n        config = show_support_save_status\n        output = ET.SubElement(show_support_save_status, \"output\")\n        show_support_save_status = ET.SubElement(output, \"show-support-save-status\")\n        message = ET.SubElement(show_support_save_status, \"message\")\n        message.text = kwargs.pop('message')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show Support Save Status output"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing Support Save Status output for a specific resource.", "response": "def show_support_save_status_output_show_support_save_status_percentage_of_completion(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_support_save_status = ET.Element(\"show_support_save_status\")\n        config = show_support_save_status\n        output = ET.SubElement(show_support_save_status, \"output\")\n        show_support_save_status = ET.SubElement(output, \"show-support-save-status\")\n        percentage_of_completion = ET.SubElement(show_support_save_status, \"percentage-of-completion\")\n        percentage_of_completion.text = kwargs.pop('percentage_of_completion')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nshow system info input rbridge - id.", "response": "def show_system_info_input_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_system_info = ET.Element(\"show_system_info\")\n        config = show_system_info\n        input = ET.SubElement(show_system_info, \"input\")\n        rbridge_id = ET.SubElement(input, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshows System Info output with rbridge_id.", "response": "def show_system_info_output_show_system_info_rbridge_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        show_system_info = ET.Element(\"show_system_info\")\n        config = show_system_info\n        output = ET.SubElement(show_system_info, \"output\")\n        show_system_info = ET.SubElement(output, \"show-system-info\")\n        rbridge_id = ET.SubElement(show_system_info, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_system_info_output_show_system_info_stack_mac(self, **kwargs):\n        config = ET.Element(\"config\")\n        show_system_info = ET.Element(\"show_system_info\")\n        config = show_system_info\n        output = ET.SubElement(show_system_info, \"output\")\n        show_system_info = ET.SubElement(output, \"show-system-info\")\n        stack_mac = ET.SubElement(show_system_info, \"stack-mac\")\n        stack_mac.text = kwargs.pop('stack_mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Show System Info output for a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget trill link details", "response": "def trill_links(self):\n        \"\"\"dict: trill link details\n        \"\"\"\n        xmlns = 'urn:brocade.com:mgmt:brocade-fabric-service'\n        get_links_info = ET.Element('show-linkinfo', xmlns=xmlns)\n        results = self._callback(get_links_info, handler='get')\n        result = []\n        for item in results.findall('{%s}show-link-info' % xmlns):\n            src_rbridge_id = item.find('{%s}linkinfo-rbridgeid' % xmlns).text\n            src_switch_wwn = item.find('{%s}linkinfo-wwn' % xmlns).text\n            for link in item.findall('{%s}linkinfo-isl' % xmlns):\n                dest_rbridge_id = link.find(\n                    '{%s}linkinfo-isllink-destdomain' % xmlns).text\n                src_interface = link.find(\n                    '{%s}linkinfo-isllink-srcport-interface' % xmlns).text\n                dest_interface = link.find(\n                    '{%s}linkinfo-isllink-destport-interface' % xmlns).text\n                link_cost = link.find('{%s}linkinfo-isl-linkcost' % xmlns).text\n                link_cost_count = link.find(\n                    '{%s}linkinfo-isllink-costcount' % xmlns).text\n\n                item_results = {'source-rbridgeid': src_rbridge_id,\n                                'source-switch-wwn': src_switch_wwn,\n                                'dest-rbridgeid': dest_rbridge_id,\n                                'source-interface': src_interface,\n                                'dest-interface': dest_interface,\n                                'link-cost': link_cost,\n                                'link-costcount': link_cost_count}\n\n                result.append(item_results)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the name of the resource in the netconf state datastores datastore.", "response": "def netconf_state_datastores_datastore_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        datastores = ET.SubElement(netconf_state, \"datastores\")\n        datastore = ET.SubElement(datastores, \"datastore\")\n        name = ET.SubElement(datastore, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef netconf_state_datastores_datastore_locks_lock_type_global_lock_global_lock_locked_time(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        datastores = ET.SubElement(netconf_state, \"datastores\")\n        datastore = ET.SubElement(datastores, \"datastore\")\n        name_key = ET.SubElement(datastore, \"name\")\n        name_key.text = kwargs.pop('name')\n        locks = ET.SubElement(datastore, \"locks\")\n        lock_type = ET.SubElement(locks, \"lock-type\")\n        global_lock = ET.SubElement(lock_type, \"global-lock\")\n        global_lock = ET.SubElement(global_lock, \"global-lock\")\n        locked_time = ET.SubElement(global_lock, \"locked-time\")\n        locked_time.text = kwargs.pop('locked_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf State Datastores Datastore Locks Lock Type Global Lock Global Lock Time"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget Netconf State Datastores Datastore Locks Type Partial Lock and Lock ID.", "response": "def netconf_state_datastores_datastore_locks_lock_type_partial_lock_partial_lock_lock_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        datastores = ET.SubElement(netconf_state, \"datastores\")\n        datastore = ET.SubElement(datastores, \"datastore\")\n        name_key = ET.SubElement(datastore, \"name\")\n        name_key.text = kwargs.pop('name')\n        locks = ET.SubElement(datastore, \"locks\")\n        lock_type = ET.SubElement(locks, \"lock-type\")\n        partial_lock = ET.SubElement(lock_type, \"partial-lock\")\n        partial_lock = ET.SubElement(partial_lock, \"partial-lock\")\n        lock_id = ET.SubElement(partial_lock, \"lock-id\")\n        lock_id.text = kwargs.pop('lock_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef netconf_state_datastores_datastore_locks_lock_type_partial_lock_partial_lock_locked_by_session(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        datastores = ET.SubElement(netconf_state, \"datastores\")\n        datastore = ET.SubElement(datastores, \"datastore\")\n        name_key = ET.SubElement(datastore, \"name\")\n        name_key.text = kwargs.pop('name')\n        locks = ET.SubElement(datastore, \"locks\")\n        lock_type = ET.SubElement(locks, \"lock-type\")\n        partial_lock = ET.SubElement(lock_type, \"partial-lock\")\n        partial_lock = ET.SubElement(partial_lock, \"partial-lock\")\n        lock_id_key = ET.SubElement(partial_lock, \"lock-id\")\n        lock_id_key.text = kwargs.pop('lock_id')\n        locked_by_session = ET.SubElement(partial_lock, \"locked-by-session\")\n        locked_by_session.text = kwargs.pop('locked_by_session')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf State Datastores Datastore Locks Lock Type Partial Lock Partial Lock"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the state of the resource from the Netconf Data Store and the datastore transaction_id.", "response": "def netconf_state_datastores_datastore_transaction_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        datastores = ET.SubElement(netconf_state, \"datastores\")\n        datastore = ET.SubElement(datastores, \"datastore\")\n        name_key = ET.SubElement(datastore, \"name\")\n        name_key.text = kwargs.pop('name')\n        transaction_id = ET.SubElement(datastore, \"transaction-id\", xmlns=\"http://tail-f.com/yang/netconf-monitoring\")\n        transaction_id.text = kwargs.pop('transaction_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef netconf_state_schemas_schema_identifier(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        schemas = ET.SubElement(netconf_state, \"schemas\")\n        schema = ET.SubElement(schemas, \"schema\")\n        version_key = ET.SubElement(schema, \"version\")\n        version_key.text = kwargs.pop('version')\n        format_key = ET.SubElement(schema, \"format\")\n        format_key.text = kwargs.pop('format')\n        identifier = ET.SubElement(schema, \"identifier\")\n        identifier.text = kwargs.pop('identifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the netconf state schemas schema identifier"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the config of the netconf - state schemas schema version", "response": "def netconf_state_schemas_schema_version(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        schemas = ET.SubElement(netconf_state, \"schemas\")\n        schema = ET.SubElement(schemas, \"schema\")\n        identifier_key = ET.SubElement(schema, \"identifier\")\n        identifier_key.text = kwargs.pop('identifier')\n        format_key = ET.SubElement(schema, \"format\")\n        format_key.text = kwargs.pop('format')\n        version = ET.SubElement(schema, \"version\")\n        version.text = kwargs.pop('version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets Netconf State Schemas Schema Format", "response": "def netconf_state_schemas_schema_format(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        schemas = ET.SubElement(netconf_state, \"schemas\")\n        schema = ET.SubElement(schemas, \"schema\")\n        identifier_key = ET.SubElement(schema, \"identifier\")\n        identifier_key.text = kwargs.pop('identifier')\n        version_key = ET.SubElement(schema, \"version\")\n        version_key.text = kwargs.pop('version')\n        format = ET.SubElement(schema, \"format\")\n        format.text = kwargs.pop('format')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef netconf_state_schemas_schema_namespace(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        schemas = ET.SubElement(netconf_state, \"schemas\")\n        schema = ET.SubElement(schemas, \"schema\")\n        identifier_key = ET.SubElement(schema, \"identifier\")\n        identifier_key.text = kwargs.pop('identifier')\n        version_key = ET.SubElement(schema, \"version\")\n        version_key.text = kwargs.pop('version')\n        format_key = ET.SubElement(schema, \"format\")\n        format_key.text = kwargs.pop('format')\n        namespace = ET.SubElement(schema, \"namespace\")\n        namespace.text = kwargs.pop('namespace')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the netconf - state schemas schema namespace"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef netconf_state_sessions_session_session_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        sessions = ET.SubElement(netconf_state, \"sessions\")\n        session = ET.SubElement(sessions, \"session\")\n        session_id = ET.SubElement(session, \"session-id\")\n        session_id.text = kwargs.pop('session_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current state of the session ID of the current netconf state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the netconf state sessions session transport", "response": "def netconf_state_sessions_session_transport(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        sessions = ET.SubElement(netconf_state, \"sessions\")\n        session = ET.SubElement(sessions, \"session\")\n        session_id_key = ET.SubElement(session, \"session-id\")\n        session_id_key.text = kwargs.pop('session_id')\n        transport = ET.SubElement(session, \"transport\")\n        transport.text = kwargs.pop('transport')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the state of the netconf sessions session_id and username.", "response": "def netconf_state_sessions_session_username(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        sessions = ET.SubElement(netconf_state, \"sessions\")\n        session = ET.SubElement(sessions, \"session\")\n        session_id_key = ET.SubElement(session, \"session-id\")\n        session_id_key.text = kwargs.pop('session_id')\n        username = ET.SubElement(session, \"username\")\n        username.text = kwargs.pop('username')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef netconf_state_sessions_session_source_host(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        sessions = ET.SubElement(netconf_state, \"sessions\")\n        session = ET.SubElement(sessions, \"session\")\n        session_id_key = ET.SubElement(session, \"session-id\")\n        session_id_key.text = kwargs.pop('session_id')\n        source_host = ET.SubElement(session, \"source-host\")\n        source_host.text = kwargs.pop('source_host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of the netconf sessions session source host"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget Netconf State Sessions Session Login Time", "response": "def netconf_state_sessions_session_login_time(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        sessions = ET.SubElement(netconf_state, \"sessions\")\n        session = ET.SubElement(sessions, \"session\")\n        session_id_key = ET.SubElement(session, \"session-id\")\n        session_id_key.text = kwargs.pop('session_id')\n        login_time = ET.SubElement(session, \"login-time\")\n        login_time.text = kwargs.pop('login_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting Netconf State Sessions in RPcs", "response": "def netconf_state_sessions_session_in_rpcs(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        sessions = ET.SubElement(netconf_state, \"sessions\")\n        session = ET.SubElement(sessions, \"session\")\n        session_id_key = ET.SubElement(session, \"session-id\")\n        session_id_key.text = kwargs.pop('session_id')\n        in_rpcs = ET.SubElement(session, \"in-rpcs\")\n        in_rpcs.text = kwargs.pop('in_rpcs')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets Netconf State Sessions in Bad Rpcs", "response": "def netconf_state_sessions_session_in_bad_rpcs(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        sessions = ET.SubElement(netconf_state, \"sessions\")\n        session = ET.SubElement(sessions, \"session\")\n        session_id_key = ET.SubElement(session, \"session-id\")\n        session_id_key.text = kwargs.pop('session_id')\n        in_bad_rpcs = ET.SubElement(session, \"in-bad-rpcs\")\n        in_bad_rpcs.text = kwargs.pop('in_bad_rpcs')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef netconf_state_sessions_session_out_rpc_errors(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        sessions = ET.SubElement(netconf_state, \"sessions\")\n        session = ET.SubElement(sessions, \"session\")\n        session_id_key = ET.SubElement(session, \"session-id\")\n        session_id_key.text = kwargs.pop('session_id')\n        out_rpc_errors = ET.SubElement(session, \"out-rpc-errors\")\n        out_rpc_errors.text = kwargs.pop('out_rpc_errors')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf State Sessions Session Out RPC Errors"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef netconf_state_sessions_session_out_notifications(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        sessions = ET.SubElement(netconf_state, \"sessions\")\n        session = ET.SubElement(sessions, \"session\")\n        session_id_key = ET.SubElement(session, \"session-id\")\n        session_id_key.text = kwargs.pop('session_id')\n        out_notifications = ET.SubElement(session, \"out-notifications\")\n        out_notifications.text = kwargs.pop('out_notifications')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf State Sessions Session Out Notifications"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef netconf_state_statistics_netconf_start_time(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        statistics = ET.SubElement(netconf_state, \"statistics\")\n        netconf_start_time = ET.SubElement(statistics, \"netconf-start-time\")\n        netconf_start_time.text = kwargs.pop('netconf_start_time')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf state statistics netconf start time"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Netconf State Statistics In Bad Hellos", "response": "def netconf_state_statistics_in_bad_hellos(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        statistics = ET.SubElement(netconf_state, \"statistics\")\n        in_bad_hellos = ET.SubElement(statistics, \"in-bad-hellos\")\n        in_bad_hellos.text = kwargs.pop('in_bad_hellos')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets Network State Statistics in Sessions", "response": "def netconf_state_statistics_in_sessions(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        statistics = ET.SubElement(netconf_state, \"statistics\")\n        in_sessions = ET.SubElement(statistics, \"in-sessions\")\n        in_sessions.text = kwargs.pop('in_sessions')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef netconf_state_statistics_dropped_sessions(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        statistics = ET.SubElement(netconf_state, \"statistics\")\n        dropped_sessions = ET.SubElement(statistics, \"dropped-sessions\")\n        dropped_sessions.text = kwargs.pop('dropped_sessions')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of netconf - monitoring dropped - sessions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Netconf State Statistics in RPCs", "response": "def netconf_state_statistics_in_rpcs(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        statistics = ET.SubElement(netconf_state, \"statistics\")\n        in_rpcs = ET.SubElement(statistics, \"in-rpcs\")\n        in_rpcs.text = kwargs.pop('in_rpcs')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef netconf_state_statistics_in_bad_rpcs(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        statistics = ET.SubElement(netconf_state, \"statistics\")\n        in_bad_rpcs = ET.SubElement(statistics, \"in-bad-rpcs\")\n        in_bad_rpcs.text = kwargs.pop('in_bad_rpcs')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Netconf State Statistics in Bad RPCs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Netconf State Statistics Out RPC Errors", "response": "def netconf_state_statistics_out_rpc_errors(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        statistics = ET.SubElement(netconf_state, \"statistics\")\n        out_rpc_errors = ET.SubElement(statistics, \"out-rpc-errors\")\n        out_rpc_errors.text = kwargs.pop('out_rpc_errors')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Netconf State Statistics Out Notifications", "response": "def netconf_state_statistics_out_notifications(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        statistics = ET.SubElement(netconf_state, \"statistics\")\n        out_notifications = ET.SubElement(statistics, \"out-notifications\")\n        out_notifications.text = kwargs.pop('out_notifications')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the current state of the resource from the netconf state files file name.", "response": "def netconf_state_files_file_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        files = ET.SubElement(netconf_state, \"files\", xmlns=\"http://tail-f.com/yang/netconf-monitoring\")\n        file = ET.SubElement(files, \"file\")\n        name = ET.SubElement(file, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef netconf_state_files_file_creator(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        files = ET.SubElement(netconf_state, \"files\", xmlns=\"http://tail-f.com/yang/netconf-monitoring\")\n        file = ET.SubElement(files, \"file\")\n        name_key = ET.SubElement(file, \"name\")\n        name_key.text = kwargs.pop('name')\n        creator = ET.SubElement(file, \"creator\")\n        creator.text = kwargs.pop('creator')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the config of the netconf state files file creator"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the state of the resource from the netconf state files file created event", "response": "def netconf_state_files_file_created(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        files = ET.SubElement(netconf_state, \"files\", xmlns=\"http://tail-f.com/yang/netconf-monitoring\")\n        file = ET.SubElement(files, \"file\")\n        name_key = ET.SubElement(file, \"name\")\n        name_key.text = kwargs.pop('name')\n        created = ET.SubElement(file, \"created\")\n        created.text = kwargs.pop('created')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef netconf_state_files_file_context(self, **kwargs):\n        config = ET.Element(\"config\")\n        netconf_state = ET.SubElement(config, \"netconf-state\", xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\")\n        files = ET.SubElement(netconf_state, \"files\", xmlns=\"http://tail-f.com/yang/netconf-monitoring\")\n        file = ET.SubElement(files, \"file\")\n        name_key = ET.SubElement(file, \"name\")\n        name_key.text = kwargs.pop('name')\n        context = ET.SubElement(file, \"context\")\n        context.text = kwargs.pop('context')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of the file context for the current log entry."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_schema_input_identifier(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_schema = ET.Element(\"get_schema\")\n        config = get_schema\n        input = ET.SubElement(get_schema, \"input\")\n        identifier = ET.SubElement(input, \"identifier\")\n        identifier.text = kwargs.pop('identifier')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get schema input identifier"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget schema input version", "response": "def get_schema_input_version(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_schema = ET.Element(\"get_schema\")\n        config = get_schema\n        input = ET.SubElement(get_schema, \"input\")\n        version = ET.SubElement(input, \"version\")\n        version.text = kwargs.pop('version')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the configuration of the fan threshold and marginal threshold", "response": "def system_monitor_fan_threshold_marginal_threshold(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        fan = ET.SubElement(system_monitor, \"fan\")\n        threshold = ET.SubElement(fan, \"threshold\")\n        marginal_threshold = ET.SubElement(threshold, \"marginal-threshold\")\n        marginal_threshold.text = kwargs.pop('marginal_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef system_monitor_fan_threshold_down_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        fan = ET.SubElement(system_monitor, \"fan\")\n        threshold = ET.SubElement(fan, \"threshold\")\n        down_threshold = ET.SubElement(threshold, \"down-threshold\")\n        down_threshold.text = kwargs.pop('down_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the fan threshold and down threshold"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef system_monitor_fan_alert_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        fan = ET.SubElement(system_monitor, \"fan\")\n        alert = ET.SubElement(fan, \"alert\")\n        state = ET.SubElement(alert, \"state\")\n        state.text = kwargs.pop('state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of fan and alert"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef system_monitor_fan_alert_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        fan = ET.SubElement(system_monitor, \"fan\")\n        alert = ET.SubElement(fan, \"alert\")\n        action = ET.SubElement(alert, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of fan and alert actions"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef system_monitor_power_threshold_marginal_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        power = ET.SubElement(system_monitor, \"power\")\n        threshold = ET.SubElement(power, \"threshold\")\n        marginal_threshold = ET.SubElement(threshold, \"marginal-threshold\")\n        marginal_threshold.text = kwargs.pop('marginal_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the system monitor power threshold and marginal threshold"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget System Monitor power threshold and down threshold", "response": "def system_monitor_power_threshold_down_threshold(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        power = ET.SubElement(system_monitor, \"power\")\n        threshold = ET.SubElement(power, \"threshold\")\n        down_threshold = ET.SubElement(threshold, \"down-threshold\")\n        down_threshold.text = kwargs.pop('down_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting System Monitor power alert state", "response": "def system_monitor_power_alert_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        power = ET.SubElement(system_monitor, \"power\")\n        alert = ET.SubElement(power, \"alert\")\n        state = ET.SubElement(alert, \"state\")\n        state.text = kwargs.pop('state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef system_monitor_power_alert_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        power = ET.SubElement(system_monitor, \"power\")\n        alert = ET.SubElement(power, \"alert\")\n        action = ET.SubElement(alert, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get System Monitor power alert action."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the marginal threshold of a resource in the system monitor", "response": "def system_monitor_temp_threshold_marginal_threshold(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        temp = ET.SubElement(system_monitor, \"temp\")\n        threshold = ET.SubElement(temp, \"threshold\")\n        marginal_threshold = ET.SubElement(threshold, \"marginal-threshold\")\n        marginal_threshold.text = kwargs.pop('marginal_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef system_monitor_temp_threshold_down_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        temp = ET.SubElement(system_monitor, \"temp\")\n        threshold = ET.SubElement(temp, \"threshold\")\n        down_threshold = ET.SubElement(threshold, \"down-threshold\")\n        down_threshold.text = kwargs.pop('down_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set threshold and down threshold for a resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef system_monitor_cid_card_threshold_marginal_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        cid_card = ET.SubElement(system_monitor, \"cid-card\")\n        threshold = ET.SubElement(cid_card, \"threshold\")\n        marginal_threshold = ET.SubElement(threshold, \"marginal-threshold\")\n        marginal_threshold.text = kwargs.pop('marginal_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the system monitor cid card threshold and marginal threshold"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the configuration of the system monitor cid card threshold and down threshold", "response": "def system_monitor_cid_card_threshold_down_threshold(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        cid_card = ET.SubElement(system_monitor, \"cid-card\")\n        threshold = ET.SubElement(cid_card, \"threshold\")\n        down_threshold = ET.SubElement(threshold, \"down-threshold\")\n        down_threshold.text = kwargs.pop('down_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef system_monitor_cid_card_alert_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        cid_card = ET.SubElement(system_monitor, \"cid-card\")\n        alert = ET.SubElement(cid_card, \"alert\")\n        state = ET.SubElement(alert, \"state\")\n        state.text = kwargs.pop('state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of the system monitor cid card alert."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the state of a system monitor cid card alert action.", "response": "def system_monitor_cid_card_alert_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        cid_card = ET.SubElement(system_monitor, \"cid-card\")\n        alert = ET.SubElement(cid_card, \"alert\")\n        action = ET.SubElement(alert, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the state of the system monitor SFP and alert", "response": "def system_monitor_sfp_alert_state(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        sfp = ET.SubElement(system_monitor, \"sfp\")\n        alert = ET.SubElement(sfp, \"alert\")\n        state = ET.SubElement(alert, \"state\")\n        state.text = kwargs.pop('state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef system_monitor_sfp_alert_action(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        sfp = ET.SubElement(system_monitor, \"sfp\")\n        alert = ET.SubElement(sfp, \"alert\")\n        action = ET.SubElement(alert, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the state of the system monitor sfp alert and action"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef system_monitor_compact_flash_threshold_marginal_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        compact_flash = ET.SubElement(system_monitor, \"compact-flash\")\n        threshold = ET.SubElement(compact_flash, \"threshold\")\n        marginal_threshold = ET.SubElement(threshold, \"marginal-threshold\")\n        marginal_threshold.text = kwargs.pop('marginal_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set threshold of compact flash"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef system_monitor_compact_flash_threshold_down_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        compact_flash = ET.SubElement(system_monitor, \"compact-flash\")\n        threshold = ET.SubElement(compact_flash, \"threshold\")\n        down_threshold = ET.SubElement(threshold, \"down-threshold\")\n        down_threshold.text = kwargs.pop('down_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get compact flash threshold and down threshold"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef system_monitor_MM_threshold_marginal_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        MM = ET.SubElement(system_monitor, \"MM\")\n        threshold = ET.SubElement(MM, \"threshold\")\n        marginal_threshold = ET.SubElement(threshold, \"marginal-threshold\")\n        marginal_threshold.text = kwargs.pop('marginal_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the system monitor MM threshold and marginal threshold"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef system_monitor_MM_threshold_down_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        MM = ET.SubElement(system_monitor, \"MM\")\n        threshold = ET.SubElement(MM, \"threshold\")\n        down_threshold = ET.SubElement(threshold, \"down-threshold\")\n        down_threshold.text = kwargs.pop('down_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the system monitor MM threshold and down threshold"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef system_monitor_LineCard_threshold_marginal_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        LineCard = ET.SubElement(system_monitor, \"LineCard\")\n        threshold = ET.SubElement(LineCard, \"threshold\")\n        marginal_threshold = ET.SubElement(threshold, \"marginal-threshold\")\n        marginal_threshold.text = kwargs.pop('marginal_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set threshold value for the system monitor line card threshold and marginal threshold"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef system_monitor_LineCard_threshold_down_threshold(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        LineCard = ET.SubElement(system_monitor, \"LineCard\")\n        threshold = ET.SubElement(LineCard, \"threshold\")\n        down_threshold = ET.SubElement(threshold, \"down-threshold\")\n        down_threshold.text = kwargs.pop('down_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set threshold and down threshold for system monitor line card"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef system_monitor_LineCard_alert_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        LineCard = ET.SubElement(system_monitor, \"LineCard\")\n        alert = ET.SubElement(LineCard, \"alert\")\n        state = ET.SubElement(alert, \"state\")\n        state.text = kwargs.pop('state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set alert state of System Monitor LineCard"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget System Monitor Line Card Alert Action", "response": "def system_monitor_LineCard_alert_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        LineCard = ET.SubElement(system_monitor, \"LineCard\")\n        alert = ET.SubElement(LineCard, \"alert\")\n        action = ET.SubElement(alert, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the marginal threshold of the system monitorSFM", "response": "def system_monitor_SFM_threshold_marginal_threshold(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        SFM = ET.SubElement(system_monitor, \"SFM\")\n        threshold = ET.SubElement(SFM, \"threshold\")\n        marginal_threshold = ET.SubElement(threshold, \"marginal-threshold\")\n        marginal_threshold.text = kwargs.pop('marginal_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting threshold and down threshold for system monitorSFM", "response": "def system_monitor_SFM_threshold_down_threshold(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor = ET.SubElement(config, \"system-monitor\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        SFM = ET.SubElement(system_monitor, \"SFM\")\n        threshold = ET.SubElement(SFM, \"threshold\")\n        down_threshold = ET.SubElement(threshold, \"down-threshold\")\n        down_threshold.text = kwargs.pop('down_threshold')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nenables FRU on System Monitor Mail", "response": "def system_monitor_mail_fru_enable(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor_mail = ET.SubElement(config, \"system-monitor-mail\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        fru = ET.SubElement(system_monitor_mail, \"fru\")\n        enable = ET.SubElement(fru, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of a system monitor mail fru email list email", "response": "def system_monitor_mail_fru_email_list_email(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor_mail = ET.SubElement(config, \"system-monitor-mail\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        fru = ET.SubElement(system_monitor_mail, \"fru\")\n        email_list = ET.SubElement(fru, \"email-list\")\n        email = ET.SubElement(email_list, \"email\")\n        email.text = kwargs.pop('email')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef system_monitor_mail_sfp_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor_mail = ET.SubElement(config, \"system-monitor-mail\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        sfp = ET.SubElement(system_monitor_mail, \"sfp\")\n        enable = ET.SubElement(sfp, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable system monitor mail for the current locale"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef system_monitor_mail_sfp_email_list_email(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor_mail = ET.SubElement(config, \"system-monitor-mail\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        sfp = ET.SubElement(system_monitor_mail, \"sfp\")\n        email_list = ET.SubElement(sfp, \"email-list\")\n        email = ET.SubElement(email_list, \"email\")\n        email.text = kwargs.pop('email')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the system monitor mail sfp email list email"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef system_monitor_mail_security_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor_mail = ET.SubElement(config, \"system-monitor-mail\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        security = ET.SubElement(system_monitor_mail, \"security\")\n        enable = ET.SubElement(security, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable or disable system monitor mail security"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the configuration of the system monitor mail security email list email", "response": "def system_monitor_mail_security_email_list_email(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor_mail = ET.SubElement(config, \"system-monitor-mail\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        security = ET.SubElement(system_monitor_mail, \"security\")\n        email_list = ET.SubElement(security, \"email-list\")\n        email = ET.SubElement(email_list, \"email\")\n        email.text = kwargs.pop('email')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nenabling or disable the system monitor mail interface.", "response": "def system_monitor_mail_interface_enable(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor_mail = ET.SubElement(config, \"system-monitor-mail\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        interface = ET.SubElement(system_monitor_mail, \"interface\")\n        enable = ET.SubElement(interface, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef system_monitor_mail_interface_email_list_email(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor_mail = ET.SubElement(config, \"system-monitor-mail\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        interface = ET.SubElement(system_monitor_mail, \"interface\")\n        email_list = ET.SubElement(interface, \"email-list\")\n        email = ET.SubElement(email_list, \"email\")\n        email.text = kwargs.pop('email')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the system monitor mail interface email list email"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef system_monitor_mail_relay_host_ip(self, **kwargs):\n        config = ET.Element(\"config\")\n        system_monitor_mail = ET.SubElement(config, \"system-monitor-mail\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        relay = ET.SubElement(system_monitor_mail, \"relay\")\n        host_ip = ET.SubElement(relay, \"host-ip\")\n        host_ip.text = kwargs.pop('host_ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the system monitor mail relay host IP"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the configuration of the system monitor mail relay domain name.", "response": "def system_monitor_mail_relay_domain_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        system_monitor_mail = ET.SubElement(config, \"system-monitor-mail\", xmlns=\"urn:brocade.com:mgmt:brocade-system-monitor\")\n        relay = ET.SubElement(system_monitor_mail, \"relay\")\n        host_ip_key = ET.SubElement(relay, \"host-ip\")\n        host_ip_key.text = kwargs.pop('host_ip')\n        domain_name = ET.SubElement(relay, \"domain-name\")\n        domain_name.text = kwargs.pop('domain_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets Syslog server syslogip", "response": "def logging_syslog_server_syslogip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        syslog_server = ET.SubElement(logging, \"syslog-server\")\n        use_vrf_key = ET.SubElement(syslog_server, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        syslogip = ET.SubElement(syslog_server, \"syslogip\")\n        syslogip.text = kwargs.pop('syslogip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef logging_syslog_server_use_vrf(self, **kwargs):\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        syslog_server = ET.SubElement(logging, \"syslog-server\")\n        syslogip_key = ET.SubElement(syslog_server, \"syslogip\")\n        syslogip_key.text = kwargs.pop('syslogip')\n        use_vrf = ET.SubElement(syslog_server, \"use-vrf\")\n        use_vrf.text = kwargs.pop('use_vrf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set use - vrf flag for syslog server"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting Syslog Server Security", "response": "def logging_syslog_server_secure(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        syslog_server = ET.SubElement(logging, \"syslog-server\")\n        syslogip_key = ET.SubElement(syslog_server, \"syslogip\")\n        syslogip_key.text = kwargs.pop('syslogip')\n        use_vrf_key = ET.SubElement(syslog_server, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        secure = ET.SubElement(syslog_server, \"secure\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef logging_syslog_server_port(self, **kwargs):\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        syslog_server = ET.SubElement(logging, \"syslog-server\")\n        syslogip_key = ET.SubElement(syslog_server, \"syslogip\")\n        syslogip_key.text = kwargs.pop('syslogip')\n        use_vrf_key = ET.SubElement(syslog_server, \"use-vrf\")\n        use_vrf_key.text = kwargs.pop('use_vrf')\n        port = ET.SubElement(syslog_server, \"port\")\n        port.text = kwargs.pop('port')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Syslog Server Port"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef logging_auditlog_class_class(self, **kwargs):\n        config = ET.Element(\"config\")\n        logging = ET.SubElement(config, \"logging\", xmlns=\"urn:brocade.com:mgmt:brocade-ras\")\n        auditlog = ET.SubElement(logging, \"auditlog\")\n        class_el = ET.SubElement(auditlog, \"class\")\n        class_el = ET.SubElement(class_el, \"class\")\n        class_el.text = kwargs.pop('class')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set logging auditlog class class"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef diag_post_rbridge_id_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        diag = ET.SubElement(config, \"diag\", xmlns=\"urn:brocade.com:mgmt:brocade-diagnostics\")\n        post = ET.SubElement(diag, \"post\")\n        rbridge_id = ET.SubElement(post, \"rbridge-id\")\n        rbridge_id_key = ET.SubElement(rbridge_id, \"rbridge-id\")\n        rbridge_id_key.text = kwargs.pop('rbridge_id')\n        enable = ET.SubElement(rbridge_id, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable or disable the log entry for the log entry."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef diag_post_rbridge_id_rbridge_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        diag = ET.SubElement(config, \"diag\", xmlns=\"urn:brocade.com:mgmt:brocade-diagnostics\")\n        post = ET.SubElement(diag, \"post\")\n        rbridge_id = ET.SubElement(post, \"rbridge-id\")\n        rbridge_id = ET.SubElement(rbridge_id, \"rbridge-id\")\n        rbridge_id.text = kwargs.pop('rbridge_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of the log entry."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef diag_post_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        diag = ET.SubElement(config, \"diag\", xmlns=\"urn:brocade.com:mgmt:brocade-diagnostics\")\n        post = ET.SubElement(diag, \"post\")\n        enable = ET.SubElement(post, \"enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Auto Generated Code\n        enable"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mac_address_table_static_mac_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        static = ET.SubElement(mac_address_table, \"static\")\n        forward_key = ET.SubElement(static, \"forward\")\n        forward_key.text = kwargs.pop('forward')\n        interface_type_key = ET.SubElement(static, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(static, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        vlan_key = ET.SubElement(static, \"vlan\")\n        vlan_key.text = kwargs.pop('vlan')\n        vlanid_key = ET.SubElement(static, \"vlanid\")\n        vlanid_key.text = kwargs.pop('vlanid')\n        mac_address = ET.SubElement(static, \"mac-address\")\n        mac_address.text = kwargs.pop('mac_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Initialize a new MAC Address Table for a static interface"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd static to the MAC address table.", "response": "def mac_address_table_static_forward(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        static = ET.SubElement(mac_address_table, \"static\")\n        mac_address_key = ET.SubElement(static, \"mac-address\")\n        mac_address_key.text = kwargs.pop('mac_address')\n        interface_type_key = ET.SubElement(static, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(static, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        vlan_key = ET.SubElement(static, \"vlan\")\n        vlan_key.text = kwargs.pop('vlan')\n        vlanid_key = ET.SubElement(static, \"vlanid\")\n        vlanid_key.text = kwargs.pop('vlanid')\n        forward = ET.SubElement(static, \"forward\")\n        forward.text = kwargs.pop('forward')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of a static MAC address table", "response": "def mac_address_table_static_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        static = ET.SubElement(mac_address_table, \"static\")\n        mac_address_key = ET.SubElement(static, \"mac-address\")\n        mac_address_key.text = kwargs.pop('mac_address')\n        forward_key = ET.SubElement(static, \"forward\")\n        forward_key.text = kwargs.pop('forward')\n        interface_name_key = ET.SubElement(static, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        vlan_key = ET.SubElement(static, \"vlan\")\n        vlan_key.text = kwargs.pop('vlan')\n        vlanid_key = ET.SubElement(static, \"vlanid\")\n        vlanid_key.text = kwargs.pop('vlanid')\n        interface_type = ET.SubElement(static, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of a static MAC address table", "response": "def mac_address_table_static_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        static = ET.SubElement(mac_address_table, \"static\")\n        mac_address_key = ET.SubElement(static, \"mac-address\")\n        mac_address_key.text = kwargs.pop('mac_address')\n        forward_key = ET.SubElement(static, \"forward\")\n        forward_key.text = kwargs.pop('forward')\n        interface_type_key = ET.SubElement(static, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        vlan_key = ET.SubElement(static, \"vlan\")\n        vlan_key.text = kwargs.pop('vlan')\n        vlanid_key = ET.SubElement(static, \"vlanid\")\n        vlanid_key.text = kwargs.pop('vlanid')\n        interface_name = ET.SubElement(static, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mac_address_table_static_vlan(self, **kwargs):\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        static = ET.SubElement(mac_address_table, \"static\")\n        mac_address_key = ET.SubElement(static, \"mac-address\")\n        mac_address_key.text = kwargs.pop('mac_address')\n        forward_key = ET.SubElement(static, \"forward\")\n        forward_key.text = kwargs.pop('forward')\n        interface_type_key = ET.SubElement(static, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(static, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        vlanid_key = ET.SubElement(static, \"vlanid\")\n        vlanid_key.text = kwargs.pop('vlanid')\n        vlan = ET.SubElement(static, \"vlan\")\n        vlan.text = kwargs.pop('vlan')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a static vlan mac address table"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mac_address_table_static_vlanid(self, **kwargs):\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        static = ET.SubElement(mac_address_table, \"static\")\n        mac_address_key = ET.SubElement(static, \"mac-address\")\n        mac_address_key.text = kwargs.pop('mac_address')\n        forward_key = ET.SubElement(static, \"forward\")\n        forward_key.text = kwargs.pop('forward')\n        interface_type_key = ET.SubElement(static, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(static, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        vlan_key = ET.SubElement(static, \"vlan\")\n        vlan_key.text = kwargs.pop('vlan')\n        vlanid = ET.SubElement(static, \"vlanid\")\n        vlanid.text = kwargs.pop('vlanid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MAC Address Table static vlanid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting learning mode of the mac address table", "response": "def mac_address_table_learning_mode(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        learning_mode = ET.SubElement(mac_address_table, \"learning-mode\")\n        learning_mode.text = kwargs.pop('learning_mode')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the configuration of the mac address table aging time conversational time out", "response": "def mac_address_table_aging_time_conversational_time_out(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        aging_time = ET.SubElement(mac_address_table, \"aging-time\")\n        conversational_time_out = ET.SubElement(aging_time, \"conversational-time-out\")\n        conversational_time_out.text = kwargs.pop('conversational_time_out')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the configuration of the mac address table aging time and legacy time out", "response": "def mac_address_table_aging_time_legacy_time_out(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        aging_time = ET.SubElement(mac_address_table, \"aging-time\")\n        legacy_time_out = ET.SubElement(aging_time, \"legacy-time-out\")\n        legacy_time_out.text = kwargs.pop('legacy_time_out')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mac_address_table_mac_move_mac_move_detect_enable(self, **kwargs):\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        mac_move = ET.SubElement(mac_address_table, \"mac-move\")\n        mac_move_detect_enable = ET.SubElement(mac_move, \"mac-move-detect-enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Enable MAC Address Table MAC Move detect enable"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmove mac address table mac - move - limit", "response": "def mac_address_table_mac_move_mac_move_limit(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        mac_move = ET.SubElement(mac_address_table, \"mac-move\")\n        mac_move_limit = ET.SubElement(mac_move, \"mac-move-limit\")\n        mac_move_limit.text = kwargs.pop('mac_move_limit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsuppress MAC Address Table Consistency Check", "response": "def mac_address_table_consistency_check_mac_consistency_check_suppress(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        consistency_check = ET.SubElement(mac_address_table, \"consistency-check\")\n        mac_consistency_check_suppress = ET.SubElement(consistency_check, \"mac-consistency-check-suppress\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mac_address_table_consistency_check_mac_consistency_check_interval(self, **kwargs):\n        config = ET.Element(\"config\")\n        mac_address_table = ET.SubElement(config, \"mac-address-table\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        consistency_check = ET.SubElement(mac_address_table, \"consistency-check\")\n        mac_consistency_check_interval = ET.SubElement(consistency_check, \"mac-consistency-check-interval\")\n        mac_consistency_check_interval.text = kwargs.pop('mac_consistency_check_interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Set the interval of the MAC Address Table consistency check"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mac_group_mac_group_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        mac_group = ET.SubElement(config, \"mac-group\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        mac_group_id = ET.SubElement(mac_group, \"mac-group-id\")\n        mac_group_id.text = kwargs.pop('mac_group_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the MAC group ID for the current user"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mac_group_mac_group_entry_entry_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        mac_group = ET.SubElement(config, \"mac-group\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-address-table\")\n        mac_group_id_key = ET.SubElement(mac_group, \"mac-group-id\")\n        mac_group_id_key.text = kwargs.pop('mac_group_id')\n        mac_group_entry = ET.SubElement(mac_group, \"mac-group-entry\")\n        entry_address = ET.SubElement(mac_group_entry, \"entry-address\")\n        entry_address.text = kwargs.pop('entry_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the details of a MAC group entry address"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting MAC Address Table input request type get request mac_address", "response": "def get_mac_address_table_input_request_type_get_request_mac_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        input = ET.SubElement(get_mac_address_table, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_request = ET.SubElement(request_type, \"get-request\")\n        mac_address = ET.SubElement(get_request, \"mac-address\")\n        mac_address.text = kwargs.pop('mac_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_mac_address_table_input_request_type_get_next_request_last_mac_address_details_last_mac_address(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        input = ET.SubElement(get_mac_address_table, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        last_mac_address_details = ET.SubElement(get_next_request, \"last-mac-address-details\")\n        last_mac_address = ET.SubElement(last_mac_address_details, \"last-mac-address\")\n        last_mac_address.text = kwargs.pop('last_mac_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Next Request for Mac Address Table"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_mac_address_table_input_request_type_get_next_request_last_mac_address_details_last_vlan_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        input = ET.SubElement(get_mac_address_table, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        last_mac_address_details = ET.SubElement(get_next_request, \"last-mac-address-details\")\n        last_vlan_id = ET.SubElement(last_mac_address_details, \"last-vlan-id\")\n        last_vlan_id.text = kwargs.pop('last_vlan_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Next Request for Mac Address Table"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting Next Request for Mac Address Table", "response": "def get_mac_address_table_input_request_type_get_next_request_last_mac_address_details_last_mac_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        input = ET.SubElement(get_mac_address_table, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        last_mac_address_details = ET.SubElement(get_next_request, \"last-mac-address-details\")\n        last_mac_type = ET.SubElement(last_mac_address_details, \"last-mac-type\")\n        last_mac_type.text = kwargs.pop('last_mac_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets MAC Address Table output", "response": "def get_mac_address_table_output_mac_address_table_vlanid(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        output = ET.SubElement(get_mac_address_table, \"output\")\n        mac_address_table = ET.SubElement(output, \"mac-address-table\")\n        mac_address_key = ET.SubElement(mac_address_table, \"mac-address\")\n        mac_address_key.text = kwargs.pop('mac_address')\n        vlanid = ET.SubElement(mac_address_table, \"vlanid\")\n        vlanid.text = kwargs.pop('vlanid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget MAC Address Table output", "response": "def get_mac_address_table_output_mac_address_table_mac_address(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        output = ET.SubElement(get_mac_address_table, \"output\")\n        mac_address_table = ET.SubElement(output, \"mac-address-table\")\n        vlanid_key = ET.SubElement(mac_address_table, \"vlanid\")\n        vlanid_key.text = kwargs.pop('vlanid')\n        mac_address = ET.SubElement(mac_address_table, \"mac-address\")\n        mac_address.text = kwargs.pop('mac_address')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_mac_address_table_output_mac_address_table_mac_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        output = ET.SubElement(get_mac_address_table, \"output\")\n        mac_address_table = ET.SubElement(output, \"mac-address-table\")\n        vlanid_key = ET.SubElement(mac_address_table, \"vlanid\")\n        vlanid_key.text = kwargs.pop('vlanid')\n        mac_address_key = ET.SubElement(mac_address_table, \"mac-address\")\n        mac_address_key.text = kwargs.pop('mac_address')\n        mac_type = ET.SubElement(mac_address_table, \"mac-type\")\n        mac_type.text = kwargs.pop('mac_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MAC Address Table output"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_mac_address_table_output_mac_address_table_mac_state(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        output = ET.SubElement(get_mac_address_table, \"output\")\n        mac_address_table = ET.SubElement(output, \"mac-address-table\")\n        vlanid_key = ET.SubElement(mac_address_table, \"vlanid\")\n        vlanid_key.text = kwargs.pop('vlanid')\n        mac_address_key = ET.SubElement(mac_address_table, \"mac-address\")\n        mac_address_key.text = kwargs.pop('mac_address')\n        mac_state = ET.SubElement(mac_address_table, \"mac-state\")\n        mac_state.text = kwargs.pop('mac_state')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MAC Address Table output and mac state"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget MAC Address Table output and forwarding interface type.", "response": "def get_mac_address_table_output_mac_address_table_forwarding_interface_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        output = ET.SubElement(get_mac_address_table, \"output\")\n        mac_address_table = ET.SubElement(output, \"mac-address-table\")\n        vlanid_key = ET.SubElement(mac_address_table, \"vlanid\")\n        vlanid_key.text = kwargs.pop('vlanid')\n        mac_address_key = ET.SubElement(mac_address_table, \"mac-address\")\n        mac_address_key.text = kwargs.pop('mac_address')\n        forwarding_interface = ET.SubElement(mac_address_table, \"forwarding-interface\")\n        interface_type = ET.SubElement(forwarding_interface, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_mac_address_table_output_has_more(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        output = ET.SubElement(get_mac_address_table, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MAC Address Table output has - more."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of all filenames marked as flagged.", "response": "def get_flagged_names():\n    \"\"\"Return a list of all filenames marked as flagged.\"\"\"\n\n    l = []\n    for w in _widget_cache.values():\n        if w.flagged:\n            l.append(w.get_node().get_value())\n    return l"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef starts_expanded(name):\n\n    if name is '/':\n        return True\n\n    l = name.split(dir_sep())\n    if len(l) > len(_initial_cwd):\n        return False\n\n    if l != _initial_cwd[:len(l)]:\n        return False\n\n    return True", "response": "Return True if directory is a parent of initial cwd."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef escape_filename_sh(name):\n\n    # check whether we have unprintable characters\n    for ch in name:\n        if ord(ch) < 32:\n            # found one so use the ansi-c escaping\n            return escape_filename_sh_ansic(name)\n\n    # all printable characters, so return a double-quoted version\n    name.replace('\\\\','\\\\\\\\')\n    name.replace('\"','\\\\\"')\n    name.replace('`','\\\\`')\n    name.replace('$','\\\\$')\n    return '\"'+name+'\"'", "response": "Return a hopefully safe shell - escaped version of a filename."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an ansi - c shell - escaped version of a filename.", "response": "def escape_filename_sh_ansic(name):\n    \"\"\"Return an ansi-c shell-escaped version of a filename.\"\"\"\n\n    out =[]\n    # gather the escaped characters into a list\n    for ch in name:\n        if ord(ch) < 32:\n            out.append(\"\\\\x%02x\"% ord(ch))\n        elif ch == '\\\\':\n            out.append('\\\\\\\\')\n        else:\n            out.append(ch)\n\n    # slap them back together in an ansi-c quote  $'...'\n    return \"$'\" + \"\".join(out) + \"'\""}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef keypress(self, size, key):\n        key = self.__super.keypress(size, key)\n        if key:\n            key = self.unhandled_keys(size, key)\n        return key", "response": "allow subclasses to intercept keystrokes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unhandled_keys(self, size, key):\n        if key == \" \":\n            if not self.flagged:\n                self.display.new_files.append(self.get_node().get_value())\n            else:\n                self.display.new_files.remove(self.get_node().get_value())\n            self.flagged = not self.flagged\n            self.update_w()\n            self.display.update_status()\n        else:\n            return key", "response": "Handles keystrokes that are not handled by the user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_w(self):\n        if self.flagged:\n            self._w.attr = 'flagged'\n            self._w.focus_attr = 'flagged focus'\n        else:\n            self._w.attr = 'body'\n            self._w.focus_attr = 'focus'", "response": "Update the attributes of self. widget based on self. flagged."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_child_node(self, key):\n        index = self.get_child_index(key)\n        if key is None:\n            return EmptyNode(None)\n        else:\n            path = os.path.join(self.get_value(), key)\n            if index < self.dir_count:\n                return DirectoryNode(path, self.display, parent=self)\n            else:\n                path = os.path.join(self.get_value(), key)\n                return FileNode(path, self.display, parent=self)", "response": "Return either a FileNode or DirectoryNode"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget NTP Authentication Key md5", "response": "def ntp_authentication_key_md5(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        ntp = ET.SubElement(config, \"ntp\", xmlns=\"urn:brocade.com:mgmt:brocade-ntp\")\n        authentication_key = ET.SubElement(ntp, \"authentication-key\")\n        keyid_key = ET.SubElement(authentication_key, \"keyid\")\n        keyid_key.text = kwargs.pop('keyid')\n        md5 = ET.SubElement(authentication_key, \"md5\")\n        md5.text = kwargs.pop('md5')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render(self, data, mimetype):\n\n        indent = self.__get_indent(mimetype)\n        encoding = mimetype.params.get('charset') or 'utf-8'\n        return json.dumps(data, indent=indent).encode(encoding)", "response": "Serializes a Python object into a byte array containing a JSON document."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the indent parameter from the mimetype.", "response": "def __get_indent(self, mimetype):\n        \"\"\"\n        Gets the indent parameter from the mimetype.\n        :param MimeType mimetype: The mimetype with parameters.\n        :return int: The indent if found, otherwise none.\n        \"\"\"\n        indent = max(int(mimetype.params.get('indent', '0')), 0)\n\n        if indent == 0:\n            return None\n\n        return indent"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef policy_map_class_cl_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        policy_map = ET.SubElement(config, \"policy-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        po_name_key = ET.SubElement(policy_map, \"po-name\")\n        po_name_key.text = kwargs.pop('po_name')\n        class_el = ET.SubElement(policy_map, \"class_el\")\n        cl_name = ET.SubElement(class_el, \"cl-name\")\n        cl_name.text = kwargs.pop('cl_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the current NIC policy map class and class name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the current state of the class police and eir", "response": "def policy_map_class_police_eir(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        policy_map = ET.SubElement(config, \"policy-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        po_name_key = ET.SubElement(policy_map, \"po-name\")\n        po_name_key.text = kwargs.pop('po_name')\n        class_el = ET.SubElement(policy_map, \"class\")\n        cl_name_key = ET.SubElement(class_el, \"cl-name\")\n        cl_name_key.text = kwargs.pop('cl_name')\n        police = ET.SubElement(class_el, \"police\")\n        eir = ET.SubElement(police, \"eir\")\n        eir.text = kwargs.pop('eir')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef policy_map_class_scheduler_strict_priority_priority_number(self, **kwargs):\n        config = ET.Element(\"config\")\n        policy_map = ET.SubElement(config, \"policy-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        po_name_key = ET.SubElement(policy_map, \"po-name\")\n        po_name_key.text = kwargs.pop('po_name')\n        class_el = ET.SubElement(policy_map, \"class\")\n        cl_name_key = ET.SubElement(class_el, \"cl-name\")\n        cl_name_key.text = kwargs.pop('cl_name')\n        scheduler = ET.SubElement(class_el, \"scheduler\")\n        strict_priority = ET.SubElement(scheduler, \"strict-priority\")\n        priority_number = ET.SubElement(strict_priority, \"priority-number\")\n        priority_number.text = kwargs.pop('priority_number')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the configuration of a specific policy map class and scheduler strict priority number."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef policy_map_class_set_set_cos_tc_traffic_class_el(self, **kwargs):\n        config = ET.Element(\"config\")\n        policy_map = ET.SubElement(config, \"policy-map\", xmlns=\"urn:brocade.com:mgmt:brocade-policer\")\n        po_name_key = ET.SubElement(policy_map, \"po-name\")\n        po_name_key.text = kwargs.pop('po_name')\n        class_el = ET.SubElement(policy_map, \"class\")\n        cl_name_key = ET.SubElement(class_el, \"cl-name\")\n        cl_name_key.text = kwargs.pop('cl_name')\n        set = ET.SubElement(class_el, \"set\")\n        set_cos_tc = ET.SubElement(set, \"set_cos_tc\")\n        traffic_class = ET.SubElement(set_cos_tc, \"traffic-class\")\n        traffic_class.text = kwargs.pop('traffic_class')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the information of a policy map class set costc and traffic class el."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates that the password matches the current user s password.", "response": "def clean_password(self):\n        \"\"\"\n        Validates that the password is a current password\n        \"\"\"\n        user_pass = self.cleaned_data.get('password')\n        matches = Password.objects.filter(password=user_pass)\n        if not matches:\n            raise forms.ValidationError(\"Your password does not match.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nenables the IGMP Snooping IP and PIM v4.", "response": "def igmp_snooping_ip_pim_snooping_pimv4_enable(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        igmp_snooping = ET.SubElement(config, \"igmp-snooping\", xmlns=\"urn:brocade.com:mgmt:brocade-igmp-snooping\")\n        ip = ET.SubElement(igmp_snooping, \"ip\")\n        pim = ET.SubElement(ip, \"pim\")\n        snooping = ET.SubElement(pim, \"snooping\")\n        pimv4_enable = ET.SubElement(snooping, \"pimv4-enable\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_vnetwork_hosts_input_vcenter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        input = ET.SubElement(get_vnetwork_hosts, \"input\")\n        vcenter = ET.SubElement(input, \"vcenter\")\n        vcenter.text = kwargs.pop('vcenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get USHosts input VCenter"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_vnetwork_hosts_input_datacenter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        input = ET.SubElement(get_vnetwork_hosts, \"input\")\n        datacenter = ET.SubElement(input, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get USD host list input datacenter"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget HP Get Vlan Host Name", "response": "def get_vnetwork_hosts_input_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        input = ET.SubElement(get_vnetwork_hosts, \"input\")\n        name = ET.SubElement(input, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vnetwork_hosts_input_last_rcvd_instance(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        input = ET.SubElement(get_vnetwork_hosts, \"input\")\n        last_rcvd_instance = ET.SubElement(input, \"last-rcvd-instance\")\n        last_rcvd_instance.text = kwargs.pop('last_rcvd_instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the list of available node names for the last RCVD instance in the network."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vnetwork_hosts_output_vnetwork_hosts_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        output = ET.SubElement(get_vnetwork_hosts, \"output\")\n        vnetwork_hosts = ET.SubElement(output, \"vnetwork-hosts\")\n        name = ET.SubElement(vnetwork_hosts, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the nnetwork hosts output and name of the current node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the output of the get_vnetwork_hosts operation for a VMNIC.", "response": "def get_vnetwork_hosts_output_vnetwork_hosts_vmnic(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        output = ET.SubElement(get_vnetwork_hosts, \"output\")\n        vnetwork_hosts = ET.SubElement(output, \"vnetwork-hosts\")\n        vmnic = ET.SubElement(vnetwork_hosts, \"vmnic\")\n        vmnic.text = kwargs.pop('vmnic')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the vnetwork host list output and datacenter.", "response": "def get_vnetwork_hosts_output_vnetwork_hosts_datacenter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        output = ET.SubElement(get_vnetwork_hosts, \"output\")\n        vnetwork_hosts = ET.SubElement(output, \"vnetwork-hosts\")\n        datacenter = ET.SubElement(vnetwork_hosts, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vnetwork_hosts_output_vnetwork_hosts_mac(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        output = ET.SubElement(get_vnetwork_hosts, \"output\")\n        vnetwork_hosts = ET.SubElement(output, \"vnetwork-hosts\")\n        mac = ET.SubElement(vnetwork_hosts, \"mac\")\n        mac.text = kwargs.pop('mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork host output for a specific mac address."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vnetwork_hosts_output_vnetwork_hosts_vswitch(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        output = ET.SubElement(get_vnetwork_hosts, \"output\")\n        vnetwork_hosts = ET.SubElement(output, \"vnetwork-hosts\")\n        vswitch = ET.SubElement(vnetwork_hosts, \"vswitch\")\n        vswitch.text = kwargs.pop('vswitch')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the output of the get_vnetwork_hosts operation for a vswitch."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the vnetwork host output and interface type of the resource.", "response": "def get_vnetwork_hosts_output_vnetwork_hosts_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        output = ET.SubElement(get_vnetwork_hosts, \"output\")\n        vnetwork_hosts = ET.SubElement(output, \"vnetwork-hosts\")\n        interface_type = ET.SubElement(vnetwork_hosts, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the output of the get_vnetwork_hosts operation", "response": "def get_vnetwork_hosts_output_vnetwork_hosts_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        output = ET.SubElement(get_vnetwork_hosts, \"output\")\n        vnetwork_hosts = ET.SubElement(output, \"vnetwork-hosts\")\n        interface_name = ET.SubElement(vnetwork_hosts, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget HP Get Vlan Host output has - more.", "response": "def get_vnetwork_hosts_output_has_more(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        output = ET.SubElement(get_vnetwork_hosts, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the node for the node that has an output element with the instance_id attribute.", "response": "def get_vnetwork_hosts_output_instance_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_hosts = ET.Element(\"get_vnetwork_hosts\")\n        config = get_vnetwork_hosts\n        output = ET.SubElement(get_vnetwork_hosts, \"output\")\n        instance_id = ET.SubElement(output, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vnetwork_vms_input_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vms = ET.Element(\"get_vnetwork_vms\")\n        config = get_vnetwork_vms\n        input = ET.SubElement(get_vnetwork_vms, \"input\")\n        name = ET.SubElement(input, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Vlan Link input name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vnetwork_vms_input_vcenter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vms = ET.Element(\"get_vnetwork_vms\")\n        config = get_vnetwork_vms\n        input = ET.SubElement(get_vnetwork_vms, \"input\")\n        vcenter = ET.SubElement(input, \"vcenter\")\n        vcenter.text = kwargs.pop('vcenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get VNR VM input VCenter"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting Vlan Resource Name from Get Vlan Node", "response": "def get_vnetwork_vms_input_datacenter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_vms = ET.Element(\"get_vnetwork_vms\")\n        config = get_vnetwork_vms\n        input = ET.SubElement(get_vnetwork_vms, \"input\")\n        datacenter = ET.SubElement(input, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the list of VMs with last rcvd instance as last rcvd instance.", "response": "def get_vnetwork_vms_input_last_rcvd_instance(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_vms = ET.Element(\"get_vnetwork_vms\")\n        config = get_vnetwork_vms\n        input = ET.SubElement(get_vnetwork_vms, \"input\")\n        last_rcvd_instance = ET.SubElement(input, \"last-rcvd-instance\")\n        last_rcvd_instance.text = kwargs.pop('last_rcvd_instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_vnetwork_vms_output_vnetwork_vms_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vms = ET.Element(\"get_vnetwork_vms\")\n        config = get_vnetwork_vms\n        output = ET.SubElement(get_vnetwork_vms, \"output\")\n        vnetwork_vms = ET.SubElement(output, \"vnetwork-vms\")\n        name = ET.SubElement(vnetwork_vms, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the nnetwork vnetwork VM output and name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vnetwork_vms_output_vnetwork_vms_mac(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vms = ET.Element(\"get_vnetwork_vms\")\n        config = get_vnetwork_vms\n        output = ET.SubElement(get_vnetwork_vms, \"output\")\n        vnetwork_vms = ET.SubElement(output, \"vnetwork-vms\")\n        mac = ET.SubElement(vnetwork_vms, \"mac\")\n        mac.text = kwargs.pop('mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork VM output for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vnetwork_vms_output_vnetwork_vms_datacenter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vms = ET.Element(\"get_vnetwork_vms\")\n        config = get_vnetwork_vms\n        output = ET.SubElement(get_vnetwork_vms, \"output\")\n        vnetwork_vms = ET.SubElement(output, \"vnetwork-vms\")\n        datacenter = ET.SubElement(vnetwork_vms, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the nnetwork vnetwork attributes from the output of the get_vnetwork_vms request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the nnetwork vswitch entry output.", "response": "def get_vnetwork_vms_output_vnetwork_vms_ip(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_vms = ET.Element(\"get_vnetwork_vms\")\n        config = get_vnetwork_vms\n        output = ET.SubElement(get_vnetwork_vms, \"output\")\n        vnetwork_vms = ET.SubElement(output, \"vnetwork-vms\")\n        ip = ET.SubElement(vnetwork_vms, \"ip\")\n        ip.text = kwargs.pop('ip')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vnetwork_vms_output_vnetwork_vms_host_nn(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vms = ET.Element(\"get_vnetwork_vms\")\n        config = get_vnetwork_vms\n        output = ET.SubElement(get_vnetwork_vms, \"output\")\n        vnetwork_vms = ET.SubElement(output, \"vnetwork-vms\")\n        host_nn = ET.SubElement(vnetwork_vms, \"host-nn\")\n        host_nn.text = kwargs.pop('host_nn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork_vms output of the get_vnetwork_vms command."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets Vlan Resource List", "response": "def get_vnetwork_vms_output_has_more(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_vms = ET.Element(\"get_vnetwork_vms\")\n        config = get_vnetwork_vms\n        output = ET.SubElement(get_vnetwork_vms, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the node for the node that has an output element with the instance_id attribute.", "response": "def get_vnetwork_vms_output_instance_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_vms = ET.Element(\"get_vnetwork_vms\")\n        config = get_vnetwork_vms\n        output = ET.SubElement(get_vnetwork_vms, \"output\")\n        instance_id = ET.SubElement(output, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets HP GS entry name.", "response": "def get_vnetwork_dvpgs_input_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_dvpgs = ET.Element(\"get_vnetwork_dvpgs\")\n        config = get_vnetwork_dvpgs\n        input = ET.SubElement(get_vnetwork_dvpgs, \"input\")\n        name = ET.SubElement(input, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the vcenter of the virtual network.", "response": "def get_vnetwork_dvpgs_input_vcenter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_dvpgs = ET.Element(\"get_vnetwork_dvpgs\")\n        config = get_vnetwork_dvpgs\n        input = ET.SubElement(get_vnetwork_dvpgs, \"input\")\n        vcenter = ET.SubElement(input, \"vcenter\")\n        vcenter.text = kwargs.pop('vcenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vnetwork_dvpgs_input_datacenter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvpgs = ET.Element(\"get_vnetwork_dvpgs\")\n        config = get_vnetwork_dvpgs\n        input = ET.SubElement(get_vnetwork_dvpgs, \"input\")\n        datacenter = ET.SubElement(input, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get HP GS entry from DVPGS input datacenter."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vnetwork_dvpgs_input_last_rcvd_instance(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvpgs = ET.Element(\"get_vnetwork_dvpgs\")\n        config = get_vnetwork_dvpgs\n        input = ET.SubElement(get_vnetwork_dvpgs, \"input\")\n        last_rcvd_instance = ET.SubElement(input, \"last-rcvd-instance\")\n        last_rcvd_instance.text = kwargs.pop('last_rcvd_instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the next DVPGS entry from the last RCVD instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vnetwork_dvpgs_output_vnetwork_dvpgs_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvpgs = ET.Element(\"get_vnetwork_dvpgs\")\n        config = get_vnetwork_dvpgs\n        output = ET.SubElement(get_vnetwork_dvpgs, \"output\")\n        vnetwork_dvpgs = ET.SubElement(output, \"vnetwork-dvpgs\")\n        name = ET.SubElement(vnetwork_dvpgs, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the nexus vnetwork output of a get_vnetwork_dvpgs request."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the vnetwork DVPGS output for the single node.", "response": "def get_vnetwork_dvpgs_output_vnetwork_dvpgs_datacenter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_dvpgs = ET.Element(\"get_vnetwork_dvpgs\")\n        config = get_vnetwork_dvpgs\n        output = ET.SubElement(get_vnetwork_dvpgs, \"output\")\n        vnetwork_dvpgs = ET.SubElement(output, \"vnetwork-dvpgs\")\n        datacenter = ET.SubElement(vnetwork_dvpgs, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the vnetwork DVPGS output for the single node node.", "response": "def get_vnetwork_dvpgs_output_vnetwork_dvpgs_dvs_nn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_dvpgs = ET.Element(\"get_vnetwork_dvpgs\")\n        config = get_vnetwork_dvpgs\n        output = ET.SubElement(get_vnetwork_dvpgs, \"output\")\n        vnetwork_dvpgs = ET.SubElement(output, \"vnetwork-dvpgs\")\n        dvs_nn = ET.SubElement(vnetwork_dvpgs, \"dvs-nn\")\n        dvs_nn.text = kwargs.pop('dvs_nn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vnetwork_dvpgs_output_vnetwork_dvpgs_vlan(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvpgs = ET.Element(\"get_vnetwork_dvpgs\")\n        config = get_vnetwork_dvpgs\n        output = ET.SubElement(get_vnetwork_dvpgs, \"output\")\n        vnetwork_dvpgs = ET.SubElement(output, \"vnetwork-dvpgs\")\n        vlan = ET.SubElement(vnetwork_dvpgs, \"vlan\")\n        vlan.text = kwargs.pop('vlan')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork DVPGS output for the single node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_vnetwork_dvpgs_output_has_more(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvpgs = ET.Element(\"get_vnetwork_dvpgs\")\n        config = get_vnetwork_dvpgs\n        output = ET.SubElement(get_vnetwork_dvpgs, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get HPGS NIC metadata from the virtual network."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_vnetwork_dvpgs_output_instance_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvpgs = ET.Element(\"get_vnetwork_dvpgs\")\n        config = get_vnetwork_dvpgs\n        output = ET.SubElement(get_vnetwork_dvpgs, \"output\")\n        instance_id = ET.SubElement(output, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the HP GS entry for the single node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_vnetwork_dvs_input_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        input = ET.SubElement(get_vnetwork_dvs, \"input\")\n        name = ET.SubElement(input, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the nexus network host s input name."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the vcenter of the current node for the vcenter.", "response": "def get_vnetwork_dvs_input_vcenter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        input = ET.SubElement(get_vnetwork_dvs, \"input\")\n        vcenter = ET.SubElement(input, \"vcenter\")\n        vcenter.text = kwargs.pop('vcenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting Vlan HP node from the network input datacenter.", "response": "def get_vnetwork_dvs_input_datacenter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        input = ET.SubElement(get_vnetwork_dvs, \"input\")\n        datacenter = ET.SubElement(input, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the node for the last RVD instance in the network.", "response": "def get_vnetwork_dvs_input_last_rcvd_instance(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        input = ET.SubElement(get_vnetwork_dvs, \"input\")\n        last_rcvd_instance = ET.SubElement(input, \"last-rcvd-instance\")\n        last_rcvd_instance.text = kwargs.pop('last_rcvd_instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vnetwork_dvs_output_vnetwork_dvs_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        output = ET.SubElement(get_vnetwork_dvs, \"output\")\n        vnetwork_dvs = ET.SubElement(output, \"vnetwork-dvs\")\n        name = ET.SubElement(vnetwork_dvs, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork_dvs output of get_vnetwork_dvs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vnetwork_dvs_output_vnetwork_dvs_host(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        output = ET.SubElement(get_vnetwork_dvs, \"output\")\n        vnetwork_dvs = ET.SubElement(output, \"vnetwork-dvs\")\n        host = ET.SubElement(vnetwork_dvs, \"host\")\n        host.text = kwargs.pop('host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork_dvs output of the get_vnetwork_dvs command."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vnetwork_dvs_output_vnetwork_dvs_datacenter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        output = ET.SubElement(get_vnetwork_dvs, \"output\")\n        vnetwork_dvs = ET.SubElement(output, \"vnetwork-dvs\")\n        datacenter = ET.SubElement(vnetwork_dvs, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork_dvs output of the get_vnetwork_dvs operation"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vnetwork_dvs_output_vnetwork_dvs_pnic(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        output = ET.SubElement(get_vnetwork_dvs, \"output\")\n        vnetwork_dvs = ET.SubElement(output, \"vnetwork-dvs\")\n        pnic = ET.SubElement(vnetwork_dvs, \"pnic\")\n        pnic.text = kwargs.pop('pnic')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork output of the get_vnetwork_dvs operation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_vnetwork_dvs_output_vnetwork_dvs_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        output = ET.SubElement(get_vnetwork_dvs, \"output\")\n        vnetwork_dvs = ET.SubElement(output, \"vnetwork-dvs\")\n        interface_type = ET.SubElement(vnetwork_dvs, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork_dvs output of the get_vnetwork_dvs operation"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vnetwork_dvs_output_vnetwork_dvs_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        output = ET.SubElement(get_vnetwork_dvs, \"output\")\n        vnetwork_dvs = ET.SubElement(output, \"vnetwork-dvs\")\n        interface_name = ET.SubElement(vnetwork_dvs, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork_dvs output of the get_vnetwork_dvs operation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting HP Get Vlan DVS output has_more.", "response": "def get_vnetwork_dvs_output_has_more(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        output = ET.SubElement(get_vnetwork_dvs, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vnetwork_dvs_output_instance_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_dvs = ET.Element(\"get_vnetwork_dvs\")\n        config = get_vnetwork_dvs\n        output = ET.SubElement(get_vnetwork_dvs, \"output\")\n        instance_id = ET.SubElement(output, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the node for the node that has the instance_id attribute."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the nexus vswitches input name.", "response": "def get_vnetwork_vswitches_input_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        input = ET.SubElement(get_vnetwork_vswitches, \"input\")\n        name = ET.SubElement(input, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the vswitches input vcenter", "response": "def get_vnetwork_vswitches_input_vcenter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        input = ET.SubElement(get_vnetwork_vswitches, \"input\")\n        vcenter = ET.SubElement(input, \"vcenter\")\n        vcenter.text = kwargs.pop('vcenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_vnetwork_vswitches_input_datacenter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        input = ET.SubElement(get_vnetwork_vswitches, \"input\")\n        datacenter = ET.SubElement(input, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Vswitches input datacenter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vnetwork_vswitches_input_last_rcvd_instance(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        input = ET.SubElement(get_vnetwork_vswitches, \"input\")\n        last_rcvd_instance = ET.SubElement(input, \"last-rcvd-instance\")\n        last_rcvd_instance.text = kwargs.pop('last_rcvd_instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the list of vswitches that have the last RVD instance set."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_vnetwork_vswitches_output_vnetwork_vswitches_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        output = ET.SubElement(get_vnetwork_vswitches, \"output\")\n        vnetwork_vswitches = ET.SubElement(output, \"vnetwork-vswitches\")\n        name = ET.SubElement(vnetwork_vswitches, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the nnetwork vswitches output and the name of the vswitches."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the vnetwork vswitches output for the current user.", "response": "def get_vnetwork_vswitches_output_vnetwork_vswitches_host(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        output = ET.SubElement(get_vnetwork_vswitches, \"output\")\n        vnetwork_vswitches = ET.SubElement(output, \"vnetwork-vswitches\")\n        host = ET.SubElement(vnetwork_vswitches, \"host\")\n        host.text = kwargs.pop('host')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vnetwork_vswitches_output_vnetwork_vswitches_datacenter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        output = ET.SubElement(get_vnetwork_vswitches, \"output\")\n        vnetwork_vswitches = ET.SubElement(output, \"vnetwork-vswitches\")\n        datacenter = ET.SubElement(vnetwork_vswitches, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork vswitches output and datacenter."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_vnetwork_vswitches_output_vnetwork_vswitches_pnic(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        output = ET.SubElement(get_vnetwork_vswitches, \"output\")\n        vnetwork_vswitches = ET.SubElement(output, \"vnetwork-vswitches\")\n        pnic = ET.SubElement(vnetwork_vswitches, \"pnic\")\n        pnic.text = kwargs.pop('pnic')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the nexus vswitches output for the single node pnic."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_vnetwork_vswitches_output_vnetwork_vswitches_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        output = ET.SubElement(get_vnetwork_vswitches, \"output\")\n        vnetwork_vswitches = ET.SubElement(output, \"vnetwork-vswitches\")\n        interface_type = ET.SubElement(vnetwork_vswitches, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vnetwork vswitches output and return the config"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the output of the get_vnetwork_vswitches operation for a specific vnetwork_vswitches interface_name.", "response": "def get_vnetwork_vswitches_output_vnetwork_vswitches_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        output = ET.SubElement(get_vnetwork_vswitches, \"output\")\n        vnetwork_vswitches = ET.SubElement(output, \"vnetwork-vswitches\")\n        interface_name = ET.SubElement(vnetwork_vswitches, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the list of vswitches with has - more attributes.", "response": "def get_vnetwork_vswitches_output_has_more(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        output = ET.SubElement(get_vnetwork_vswitches, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_vnetwork_vswitches_output_instance_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_vswitches = ET.Element(\"get_vnetwork_vswitches\")\n        config = get_vnetwork_vswitches\n        output = ET.SubElement(get_vnetwork_vswitches, \"output\")\n        instance_id = ET.SubElement(output, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the n_vnetwork_vswitches output and instance_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vnetwork_portgroups_input_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vnetwork_portgroups = ET.Element(\"get_vnetwork_portgroups\")\n        config = get_vnetwork_portgroups\n        input = ET.SubElement(get_vnetwork_portgroups, \"input\")\n        name = ET.SubElement(input, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the nexus portgroup input name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the list of portgroups with input vcenter", "response": "def get_vnetwork_portgroups_input_vcenter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_portgroups = ET.Element(\"get_vnetwork_portgroups\")\n        config = get_vnetwork_portgroups\n        input = ET.SubElement(get_vnetwork_portgroups, \"input\")\n        vcenter = ET.SubElement(input, \"vcenter\")\n        vcenter.text = kwargs.pop('vcenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets Vlan Link input datacenter", "response": "def get_vnetwork_portgroups_input_datacenter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_portgroups = ET.Element(\"get_vnetwork_portgroups\")\n        config = get_vnetwork_portgroups\n        input = ET.SubElement(get_vnetwork_portgroups, \"input\")\n        datacenter = ET.SubElement(input, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the list of portgroups that have the last RCVD instance in the input element.", "response": "def get_vnetwork_portgroups_input_last_rcvd_instance(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_portgroups = ET.Element(\"get_vnetwork_portgroups\")\n        config = get_vnetwork_portgroups\n        input = ET.SubElement(get_vnetwork_portgroups, \"input\")\n        last_rcvd_instance = ET.SubElement(input, \"last-rcvd-instance\")\n        last_rcvd_instance.text = kwargs.pop('last_rcvd_instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the nnetwork portgroups output and vnetwork - pgs name.", "response": "def get_vnetwork_portgroups_output_vnetwork_pgs_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_portgroups = ET.Element(\"get_vnetwork_portgroups\")\n        config = get_vnetwork_portgroups\n        output = ET.SubElement(get_vnetwork_portgroups, \"output\")\n        vnetwork_pgs = ET.SubElement(output, \"vnetwork-pgs\")\n        name = ET.SubElement(vnetwork_pgs, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the vnetwork portgroups output and datacenter.", "response": "def get_vnetwork_portgroups_output_vnetwork_pgs_datacenter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_portgroups = ET.Element(\"get_vnetwork_portgroups\")\n        config = get_vnetwork_portgroups\n        output = ET.SubElement(get_vnetwork_portgroups, \"output\")\n        vnetwork_pgs = ET.SubElement(output, \"vnetwork-pgs\")\n        datacenter = ET.SubElement(vnetwork_pgs, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the vnetwork output of the get_vnetwork_portgroups operation", "response": "def get_vnetwork_portgroups_output_vnetwork_pgs_vs_nn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_portgroups = ET.Element(\"get_vnetwork_portgroups\")\n        config = get_vnetwork_portgroups\n        output = ET.SubElement(get_vnetwork_portgroups, \"output\")\n        vnetwork_pgs = ET.SubElement(output, \"vnetwork-pgs\")\n        vs_nn = ET.SubElement(vnetwork_pgs, \"vs-nn\")\n        vs_nn.text = kwargs.pop('vs_nn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the vnetwork output of the get_vnetwork_portgroups operation", "response": "def get_vnetwork_portgroups_output_vnetwork_pgs_vlan(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_portgroups = ET.Element(\"get_vnetwork_portgroups\")\n        config = get_vnetwork_portgroups\n        output = ET.SubElement(get_vnetwork_portgroups, \"output\")\n        vnetwork_pgs = ET.SubElement(output, \"vnetwork-pgs\")\n        vlan = ET.SubElement(vnetwork_pgs, \"vlan\")\n        vlan.text = kwargs.pop('vlan')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the vnetwork output of the get_vnetwork_portgroups operation.", "response": "def get_vnetwork_portgroups_output_vnetwork_pgs_host_nn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_portgroups = ET.Element(\"get_vnetwork_portgroups\")\n        config = get_vnetwork_portgroups\n        output = ET.SubElement(get_vnetwork_portgroups, \"output\")\n        vnetwork_pgs = ET.SubElement(output, \"vnetwork-pgs\")\n        host_nn = ET.SubElement(vnetwork_pgs, \"host-nn\")\n        host_nn.text = kwargs.pop('host_nn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget Vlan Link output has - more.", "response": "def get_vnetwork_portgroups_output_has_more(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_portgroups = ET.Element(\"get_vnetwork_portgroups\")\n        config = get_vnetwork_portgroups\n        output = ET.SubElement(get_vnetwork_portgroups, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the node for the get_vnetwork_portgroups output and instance_id.", "response": "def get_vnetwork_portgroups_output_instance_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vnetwork_portgroups = ET.Element(\"get_vnetwork_portgroups\")\n        config = get_vnetwork_portgroups\n        output = ET.SubElement(get_vnetwork_portgroups, \"output\")\n        instance_id = ET.SubElement(output, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the vmpolicy MAC address input MAC.", "response": "def get_vmpolicy_macaddr_input_mac(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        input = ET.SubElement(get_vmpolicy_macaddr, \"input\")\n        mac = ET.SubElement(input, \"mac\")\n        mac.text = kwargs.pop('mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_vmpolicy_macaddr_input_vcenter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        input = ET.SubElement(get_vmpolicy_macaddr, \"input\")\n        vcenter = ET.SubElement(input, \"vcenter\")\n        vcenter.text = kwargs.pop('vcenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vmpolicy macaddr input for a vcenter"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vmpolicy_macaddr_input_datacenter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        input = ET.SubElement(get_vmpolicy_macaddr, \"input\")\n        datacenter = ET.SubElement(input, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vmpolicy macaddr input datacenter."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_vmpolicy_macaddr_input_last_rcvd_instance(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        input = ET.SubElement(get_vmpolicy_macaddr, \"input\")\n        last_rcvd_instance = ET.SubElement(input, \"last-rcvd-instance\")\n        last_rcvd_instance.text = kwargs.pop('last_rcvd_instance')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vmpolicy macaddr input element and last rcvd instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vmpolicy_macaddr_output_vmpolicy_macaddr_mac(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        output = ET.SubElement(get_vmpolicy_macaddr, \"output\")\n        vmpolicy_macaddr = ET.SubElement(output, \"vmpolicy-macaddr\")\n        mac = ET.SubElement(vmpolicy_macaddr, \"mac\")\n        mac.text = kwargs.pop('mac')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vmpolicy macaddr output."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vmpolicy_macaddr_output_vmpolicy_macaddr_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        output = ET.SubElement(get_vmpolicy_macaddr, \"output\")\n        vmpolicy_macaddr = ET.SubElement(output, \"vmpolicy-macaddr\")\n        name = ET.SubElement(vmpolicy_macaddr, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vmpolicy macaddr output."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_vmpolicy_macaddr_output_vmpolicy_macaddr_datacenter(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        output = ET.SubElement(get_vmpolicy_macaddr, \"output\")\n        vmpolicy_macaddr = ET.SubElement(output, \"vmpolicy-macaddr\")\n        datacenter = ET.SubElement(vmpolicy_macaddr, \"datacenter\")\n        datacenter.text = kwargs.pop('datacenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the vmpolicy macaddr output for a user."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the VMPolicy MAC address output for DVPG NN.", "response": "def get_vmpolicy_macaddr_output_vmpolicy_macaddr_dvpg_nn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        output = ET.SubElement(get_vmpolicy_macaddr, \"output\")\n        vmpolicy_macaddr = ET.SubElement(output, \"vmpolicy-macaddr\")\n        dvpg_nn = ET.SubElement(vmpolicy_macaddr, \"dvpg-nn\")\n        dvpg_nn.text = kwargs.pop('dvpg_nn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the vmpolicy macaddr output for a specific port_nn.", "response": "def get_vmpolicy_macaddr_output_vmpolicy_macaddr_port_nn(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        output = ET.SubElement(get_vmpolicy_macaddr, \"output\")\n        vmpolicy_macaddr = ET.SubElement(output, \"vmpolicy-macaddr\")\n        port_nn = ET.SubElement(vmpolicy_macaddr, \"port-nn\")\n        port_nn.text = kwargs.pop('port_nn')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vmpolicy_macaddr_output_vmpolicy_macaddr_port_prof(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        output = ET.SubElement(get_vmpolicy_macaddr, \"output\")\n        vmpolicy_macaddr = ET.SubElement(output, \"vmpolicy-macaddr\")\n        port_prof = ET.SubElement(vmpolicy_macaddr, \"port-prof\")\n        port_prof.text = kwargs.pop('port_prof')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the VMPolicy MAC address output for a specific class."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the vmpolicy macaddr output.", "response": "def get_vmpolicy_macaddr_output_has_more(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        output = ET.SubElement(get_vmpolicy_macaddr, \"output\")\n        has_more = ET.SubElement(output, \"has-more\")\n        has_more.text = kwargs.pop('has_more')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_vmpolicy_macaddr_output_instance_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_vmpolicy_macaddr = ET.Element(\"get_vmpolicy_macaddr\")\n        config = get_vmpolicy_macaddr\n        output = ET.SubElement(get_vmpolicy_macaddr, \"output\")\n        instance_id = ET.SubElement(output, \"instance-id\")\n        instance_id.text = kwargs.pop('instance_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the VMPolicy MAC address output and instance ID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef vcenter_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcenter = ET.SubElement(config, \"vcenter\", xmlns=\"urn:brocade.com:mgmt:brocade-vswitch\")\n        id = ET.SubElement(vcenter, \"id\")\n        id.text = kwargs.pop('id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the ID of the current vcenter"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vcenter_credentials_url(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcenter = ET.SubElement(config, \"vcenter\", xmlns=\"urn:brocade.com:mgmt:brocade-vswitch\")\n        id_key = ET.SubElement(vcenter, \"id\")\n        id_key.text = kwargs.pop('id')\n        credentials = ET.SubElement(vcenter, \"credentials\")\n        url = ET.SubElement(credentials, \"url\")\n        url.text = kwargs.pop('url')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the credentials and url for the vcenter"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef vcenter_credentials_username(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcenter = ET.SubElement(config, \"vcenter\", xmlns=\"urn:brocade.com:mgmt:brocade-vswitch\")\n        id_key = ET.SubElement(vcenter, \"id\")\n        id_key.text = kwargs.pop('id')\n        credentials = ET.SubElement(vcenter, \"credentials\")\n        username = ET.SubElement(credentials, \"username\")\n        username.text = kwargs.pop('username')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the credentials and username for the current vcenter"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vcenter_credentials_password(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcenter = ET.SubElement(config, \"vcenter\", xmlns=\"urn:brocade.com:mgmt:brocade-vswitch\")\n        id_key = ET.SubElement(vcenter, \"id\")\n        id_key.text = kwargs.pop('id')\n        credentials = ET.SubElement(vcenter, \"credentials\")\n        password = ET.SubElement(credentials, \"password\")\n        password.text = kwargs.pop('password')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the credentials and password for the current vcenter"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vcenter_credentials_vrf_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcenter = ET.SubElement(config, \"vcenter\", xmlns=\"urn:brocade.com:mgmt:brocade-vswitch\")\n        id_key = ET.SubElement(vcenter, \"id\")\n        id_key.text = kwargs.pop('id')\n        credentials = ET.SubElement(vcenter, \"credentials\")\n        vrf_name = ET.SubElement(credentials, \"vrf-name\")\n        vrf_name.text = kwargs.pop('vrf_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the VCenter Credentials VRF Name"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nactivates a new resource in the vCenter", "response": "def vcenter_activate(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vcenter = ET.SubElement(config, \"vcenter\", xmlns=\"urn:brocade.com:mgmt:brocade-vswitch\")\n        id_key = ET.SubElement(vcenter, \"id\")\n        id_key.text = kwargs.pop('id')\n        activate = ET.SubElement(vcenter, \"activate\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets interval of the available virtual center", "response": "def vcenter_interval(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        vcenter = ET.SubElement(config, \"vcenter\", xmlns=\"urn:brocade.com:mgmt:brocade-vswitch\")\n        id_key = ET.SubElement(vcenter, \"id\")\n        id_key.text = kwargs.pop('id')\n        interval = ET.SubElement(vcenter, \"interval\")\n        interval.text = kwargs.pop('interval')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vcenter_discovery_ignore_delete_all_response_ignore_value(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcenter = ET.SubElement(config, \"vcenter\", xmlns=\"urn:brocade.com:mgmt:brocade-vswitch\")\n        id_key = ET.SubElement(vcenter, \"id\")\n        id_key.text = kwargs.pop('id')\n        discovery = ET.SubElement(vcenter, \"discovery\")\n        ignore_delete_all_response = ET.SubElement(discovery, \"ignore-delete-all-response\")\n        ignore_value = ET.SubElement(ignore_delete_all_response, \"ignore-value\")\n        ignore_value.text = kwargs.pop('ignore_value')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get a new config element for the vcenter discovery ignore delete all response ignore_value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef vcenter_discovery_ignore_delete_all_response_always(self, **kwargs):\n        config = ET.Element(\"config\")\n        vcenter = ET.SubElement(config, \"vcenter\", xmlns=\"urn:brocade.com:mgmt:brocade-vswitch\")\n        id_key = ET.SubElement(vcenter, \"id\")\n        id_key.text = kwargs.pop('id')\n        discovery = ET.SubElement(vcenter, \"discovery\")\n        ignore_delete_all_response = ET.SubElement(discovery, \"ignore-delete-all-response\")\n        always = ET.SubElement(ignore_delete_all_response, \"always\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get No response from VCenter Discovery ignore delete all response."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fcoe_fcoe_map_fcoe_map_fabric_map_fcoe_map_fabric_map_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_map = ET.SubElement(fcoe, \"fcoe-map\")\n        fcoe_map_name_key = ET.SubElement(fcoe_map, \"fcoe-map-name\")\n        fcoe_map_name_key.text = kwargs.pop('fcoe_map_name')\n        fcoe_map_fabric_map = ET.SubElement(fcoe_map, \"fcoe-map-fabric-map\")\n        fcoe_map_fabric_map_name = ET.SubElement(fcoe_map_fabric_map, \"fcoe-map-fabric-map-name\")\n        fcoe_map_fabric_map_name.text = kwargs.pop('fcoe_map_fabric_map_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCoE Map from Fabric Map"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget FCF map name", "response": "def fcoe_fcoe_fcf_map_fcf_map_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fcf_map = ET.SubElement(fcoe, \"fcoe-fcf-map\")\n        fcf_map_name = ET.SubElement(fcoe_fcf_map, \"fcf-map-name\")\n        fcf_map_name.text = kwargs.pop('fcf_map_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting FCF map leaf", "response": "def fcoe_fcoe_fcf_map_fcf_map_fcoe_map_fcf_map_fcoe_map_leaf(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fcf_map = ET.SubElement(fcoe, \"fcoe-fcf-map\")\n        fcf_map_name_key = ET.SubElement(fcoe_fcf_map, \"fcf-map-name\")\n        fcf_map_name_key.text = kwargs.pop('fcf_map_name')\n        fcf_map_fcoe_map = ET.SubElement(fcoe_fcf_map, \"fcf-map-fcoe-map\")\n        fcf_map_fcoe_map_leaf = ET.SubElement(fcf_map_fcoe_map, \"fcf-map-fcoe-map-leaf\")\n        fcf_map_fcoe_map_leaf.text = kwargs.pop('fcf_map_fcoe_map_leaf')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fcoe_fcoe_fcf_map_fcf_map_ag_rbid(self, **kwargs):\n        config = ET.Element(\"config\")\n        fcoe = ET.SubElement(config, \"fcoe\", xmlns=\"urn:brocade.com:mgmt:brocade-fcoe\")\n        fcoe_fcf_map = ET.SubElement(fcoe, \"fcoe-fcf-map\")\n        fcf_map_name_key = ET.SubElement(fcoe_fcf_map, \"fcf-map-name\")\n        fcf_map_name_key.text = kwargs.pop('fcf_map_name')\n        fcf_map_ag_rbid = ET.SubElement(fcoe_fcf_map, \"fcf-map-ag-rbid\")\n        fcf_map_ag_rbid.text = kwargs.pop('fcf_map_ag_rbid')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get FCF map ag rbid"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gfm(text):\n    extractions = {}\n\n    def extract_pre_block(matchobj):\n        match = matchobj.group(0)\n        hashed_match = hashlib.md5(match.encode('utf-8')).hexdigest()\n        extractions[hashed_match] = match\n        result = \"{gfm-extraction-%s}\" % hashed_match\n        return result\n\n    def escape_underscore(matchobj):\n        match = matchobj.group(0)\n\n        if match.count('_') > 1:\n            return re.sub('_', '\\_', match)\n        else:\n            return match\n\n    def newlines_to_brs(matchobj):\n        match = matchobj.group(0)\n        if re.search(\"\\n{2}\", match):\n            return match\n        else:\n            match = match.strip()\n            return match + \"  \\n\"\n\n    def insert_pre_block(matchobj):\n        string = \"\\n\\n\" + extractions[matchobj.group(1)]\n        return string\n\n    text = re.sub(\"(?s)<pre>.*?<\\/pre>\", extract_pre_block, text)\n    text = re.sub(\"(^(?! {4}|\\t)\\w+_\\w+_\\w[\\w_]*)\", escape_underscore, text)\n    text = re.sub(\"(?m)^[\\w\\<][^\\n]*\\n+\", newlines_to_brs, text)\n    text = re.sub(\"\\{gfm-extraction-([0-9a-f]{32})\\}\", insert_pre_block, text)\n\n    return text", "response": "Processes Markdown according to GitHub Flavored Markdown spec."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess GFM then converts it to HTML.", "response": "def markdown(text):\n    \"\"\"Processes GFM then converts it to HTML.\"\"\"\n    text = gfm(text)\n    text = markdown_lib.markdown(text)\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget Port Channel Detail input last - aggregator - id.", "response": "def get_port_channel_detail_input_last_aggregator_id(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_port_channel_detail = ET.Element(\"get_port_channel_detail\")\n        config = get_port_channel_detail\n        input = ET.SubElement(get_port_channel_detail, \"input\")\n        last_aggregator_id = ET.SubElement(input, \"last-aggregator-id\")\n        last_aggregator_id.text = kwargs.pop('last_aggregator_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_mac_address_table_input_request_type_get_interface_based_request_forwarding_interface_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        input = ET.SubElement(get_mac_address_table, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_interface_based_request = ET.SubElement(request_type, \"get-interface-based-request\")\n        forwarding_interface = ET.SubElement(get_interface_based_request, \"forwarding-interface\")\n        interface_type = ET.SubElement(forwarding_interface, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MAC Address Table input request - type get - interface - based - request forwarding - interface - type"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_mac_address_table_input_request_type_get_interface_based_request_forwarding_interface_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        input = ET.SubElement(get_mac_address_table, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_interface_based_request = ET.SubElement(request_type, \"get-interface-based-request\")\n        forwarding_interface = ET.SubElement(get_interface_based_request, \"forwarding-interface\")\n        interface_name = ET.SubElement(forwarding_interface, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MAC Address Table input request type get - interface - based - request forwarding - interface - name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget MAC Address Table input request type get interface based request mac type", "response": "def get_mac_address_table_input_request_type_get_interface_based_request_mac_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        input = ET.SubElement(get_mac_address_table, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_interface_based_request = ET.SubElement(request_type, \"get-interface-based-request\")\n        mac_type = ET.SubElement(get_interface_based_request, \"mac-type\")\n        mac_type.text = kwargs.pop('mac_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_mac_address_table_input_request_type_get_next_request_forwarding_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        input = ET.SubElement(get_mac_address_table, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        forwarding_interface_type = ET.SubElement(get_next_request, \"forwarding-interface-type\")\n        forwarding_interface_type.text = kwargs.pop('forwarding_interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Next Request Type for Mac Address Table input request - type get next request forwarding - interface - type"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_mac_address_table_input_request_type_get_next_request_forwarding_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        input = ET.SubElement(get_mac_address_table, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        forwarding_interface_name = ET.SubElement(get_next_request, \"forwarding-interface-name\")\n        forwarding_interface_name.text = kwargs.pop('forwarding_interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Next Request for Mac Address Table input request type get next request forwarding interface name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_mac_address_table_input_request_type_get_next_request_mac_address_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        input = ET.SubElement(get_mac_address_table, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_next_request = ET.SubElement(request_type, \"get-next-request\")\n        mac_address_type = ET.SubElement(get_next_request, \"mac-address-type\")\n        mac_address_type.text = kwargs.pop('mac_address_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Next Request for Mac Address Table input request - type get - next - request - mac - address - type"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mac_access_list_standard_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        mac = ET.SubElement(config, \"mac\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-access-list\")\n        access_list = ET.SubElement(mac, \"access-list\")\n        standard = ET.SubElement(access_list, \"standard\")\n        name = ET.SubElement(standard, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the name of the mac_access_list standard element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mac_access_list_standard_hide_mac_acl_std_seq_seq_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        mac = ET.SubElement(config, \"mac\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-access-list\")\n        access_list = ET.SubElement(mac, \"access-list\")\n        standard = ET.SubElement(access_list, \"standard\")\n        name_key = ET.SubElement(standard, \"name\")\n        name_key.text = kwargs.pop('name')\n        hide_mac_acl_std = ET.SubElement(standard, \"hide-mac-acl-std\")\n        seq = ET.SubElement(hide_mac_acl_std, \"seq\")\n        seq_id = ET.SubElement(seq, \"seq-id\")\n        seq_id.text = kwargs.pop('seq_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the information of a MAC Access List standard element and hide the MAC ACL standard."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the information of a MAC Access List standard hidden MAC ACL standard and seq action", "response": "def mac_access_list_standard_hide_mac_acl_std_seq_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        mac = ET.SubElement(config, \"mac\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-access-list\")\n        access_list = ET.SubElement(mac, \"access-list\")\n        standard = ET.SubElement(access_list, \"standard\")\n        name_key = ET.SubElement(standard, \"name\")\n        name_key.text = kwargs.pop('name')\n        hide_mac_acl_std = ET.SubElement(standard, \"hide-mac-acl-std\")\n        seq = ET.SubElement(hide_mac_acl_std, \"seq\")\n        seq_id_key = ET.SubElement(seq, \"seq-id\")\n        seq_id_key.text = kwargs.pop('seq_id')\n        action = ET.SubElement(seq, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the extended name of the mac access list", "response": "def mac_access_list_extended_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        mac = ET.SubElement(config, \"mac\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-access-list\")\n        access_list = ET.SubElement(mac, \"access-list\")\n        extended = ET.SubElement(access_list, \"extended\")\n        name = ET.SubElement(extended, \"name\")\n        name.text = kwargs.pop('name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mac_access_list_extended_hide_mac_acl_ext_seq_seq_id(self, **kwargs):\n        config = ET.Element(\"config\")\n        mac = ET.SubElement(config, \"mac\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-access-list\")\n        access_list = ET.SubElement(mac, \"access-list\")\n        extended = ET.SubElement(access_list, \"extended\")\n        name_key = ET.SubElement(extended, \"name\")\n        name_key.text = kwargs.pop('name')\n        hide_mac_acl_ext = ET.SubElement(extended, \"hide-mac-acl-ext\")\n        seq = ET.SubElement(hide_mac_acl_ext, \"seq\")\n        seq_id = ET.SubElement(seq, \"seq-id\")\n        seq_id.text = kwargs.pop('seq_id')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get the details of a MAC Access List extended element and hide the MAC ACL extended element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the details of a MAC Access List extended attribute and hide the MAC ACL extended attribute.", "response": "def mac_access_list_extended_hide_mac_acl_ext_seq_action(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        mac = ET.SubElement(config, \"mac\", xmlns=\"urn:brocade.com:mgmt:brocade-mac-access-list\")\n        access_list = ET.SubElement(mac, \"access-list\")\n        extended = ET.SubElement(access_list, \"extended\")\n        name_key = ET.SubElement(extended, \"name\")\n        name_key.text = kwargs.pop('name')\n        hide_mac_acl_ext = ET.SubElement(extended, \"hide-mac-acl-ext\")\n        seq = ET.SubElement(hide_mac_acl_ext, \"seq\")\n        seq_id_key = ET.SubElement(seq, \"seq-id\")\n        seq_id_key.text = kwargs.pop('seq_id')\n        action = ET.SubElement(seq, \"action\")\n        action.text = kwargs.pop('action')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget MAC ACL for Interface input interface type.", "response": "def get_mac_acl_for_intf_input_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_mac_acl_for_intf = ET.Element(\"get_mac_acl_for_intf\")\n        config = get_mac_acl_for_intf\n        input = ET.SubElement(get_mac_acl_for_intf, \"input\")\n        interface_type = ET.SubElement(input, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting MAC ACL for Interface input interface name.", "response": "def get_mac_acl_for_intf_input_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_mac_acl_for_intf = ET.Element(\"get_mac_acl_for_intf\")\n        config = get_mac_acl_for_intf\n        input = ET.SubElement(get_mac_acl_for_intf, \"input\")\n        interface_name = ET.SubElement(input, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget MAC ACL for Interface input direction.", "response": "def get_mac_acl_for_intf_input_direction(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n        config = ET.Element(\"config\")\n        get_mac_acl_for_intf = ET.Element(\"get_mac_acl_for_intf\")\n        config = get_mac_acl_for_intf\n        input = ET.SubElement(get_mac_acl_for_intf, \"input\")\n        direction = ET.SubElement(input, \"direction\")\n        direction.text = kwargs.pop('direction')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_mac_acl_for_intf_output_interface_interface_type(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_acl_for_intf = ET.Element(\"get_mac_acl_for_intf\")\n        config = get_mac_acl_for_intf\n        output = ET.SubElement(get_mac_acl_for_intf, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        interface_type = ET.SubElement(interface, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MAC ACL for Interface output interface type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_mac_acl_for_intf_output_interface_interface_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_acl_for_intf = ET.Element(\"get_mac_acl_for_intf\")\n        config = get_mac_acl_for_intf\n        output = ET.SubElement(get_mac_acl_for_intf, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name = ET.SubElement(interface, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MAC ACL for Interface output interface name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_mac_acl_for_intf_output_interface_ingress_policy_policy_name(self, **kwargs):\n        config = ET.Element(\"config\")\n        get_mac_acl_for_intf = ET.Element(\"get_mac_acl_for_intf\")\n        config = get_mac_acl_for_intf\n        output = ET.SubElement(get_mac_acl_for_intf, \"output\")\n        interface = ET.SubElement(output, \"interface\")\n        interface_type_key = ET.SubElement(interface, \"interface-type\")\n        interface_type_key.text = kwargs.pop('interface_type')\n        interface_name_key = ET.SubElement(interface, \"interface-name\")\n        interface_name_key.text = kwargs.pop('interface_name')\n        ingress_policy = ET.SubElement(interface, \"ingress-policy\")\n        policy_name = ET.SubElement(ingress_policy, \"policy-name\")\n        policy_name.text = kwargs.pop('policy_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get MAC ACL for Interface output and ingress policy name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_log_options(self, verbose_func=None, quiet_func=None):\n\n        if not verbose_func:\n            def verbose_func():\n                return log.config(verbose=True)\n\n        if not quiet_func:\n            def quiet_func():\n                return log.config(quiet=True)\n\n        self.option('-v, --verbose', 'show more logs', verbose_func)\n        self.option('-q, --quiet', 'show less logs', quiet_func)\n        return self", "response": "A helper for setting up log options"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef local_asn(self, **kwargs):\n        is_get_config = kwargs.pop('get', False)\n        if not is_get_config:\n            local_as = kwargs.pop('local_as')\n        else:\n            local_as = ''\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        local_as_args = dict(local_as=local_as,\n                             rbridge_id=rbridge_id)\n        enable_bgp = getattr(self._rbridge,\n                             'rbridge_id_router_router_bgp_router_bgp_'\n                             'attributes_local_as')(**local_as_args)\n        bgp = enable_bgp.find('.//*.//*.//*')\n        bgp.remove(bgp.find('.//*'))\n        if not is_get_config:\n            callback(enable_bgp)\n        local_as = getattr(self._rbridge,\n                           'rbridge_id_router_router_bgp_router_bgp_attri'\n                           'butes_local_as')\n        config = local_as(**local_as_args)\n        if is_get_config:\n            return callback(config, handler='get_config')\n        return callback(config)", "response": "Set BGP local ASN of NOS deice."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef as4_capability(self, **kwargs):\n        enabled = kwargs.pop('enabled', True)\n        callback = kwargs.pop('callback', self._callback)\n\n        if not isinstance(enabled, bool):\n            raise ValueError('%s must be `True` or `False`.' % repr(enabled))\n\n        as4_capability_args = dict(vrf_name=kwargs.pop('vrf', 'default'),\n                                   rbridge_id=kwargs.pop('rbridge_id', '1'))\n\n        as4_capability = getattr(self._rbridge,\n                                 'rbridge_id_router_router_bgp_router_bgp'\n                                 '_attributes_capability_as4_enable')\n\n        config = as4_capability(**as4_capability_args)\n\n        if not enabled:\n            capability = config.find('.//*capability')\n            capability.set('operation', 'delete')\n            # shutdown = capability.find('.//*as4-enable')\n            # shutdown.set('operation', 'delete')\n\n        return callback(config)", "response": "Set Spanning Tree state."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_bgp(self, **kwargs):\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        callback = kwargs.pop('callback', self._callback)\n        disable_args = dict(rbridge_id=rbridge_id, local_as='65000')\n        config = getattr(self._rbridge,\n                         'rbridge_id_router_router_bgp_router_bgp_'\n                         'attributes_local_as')(**disable_args)\n        bgp = config.find('.//*.//*.//*')\n        bgp.remove(bgp.find('.//*'))\n        bgp.set('operation', 'delete')\n\n        return callback(config)", "response": "Remove BGP process completely."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef neighbor(self, **kwargs):\n        ip_addr = kwargs.pop('ip_addr')\n        remote_as = kwargs.pop('remote_as', None)\n        rbridge_id = kwargs.pop('rbridge_id', '1')\n        delete = kwargs.pop('delete', False)\n        callback = kwargs.pop('callback', self._callback)\n        ip_addr = ip_interface(unicode(ip_addr))\n\n        if not delete and remote_as is None:\n            raise ValueError('When configuring a neighbor, you must specify '\n                             'its remote-as.')\n\n        neighbor_args = dict(router_bgp_neighbor_address=str(ip_addr.ip),\n                             remote_as=remote_as,\n                             rbridge_id=rbridge_id)\n        if ip_addr.version == 6:\n            neighbor_args['router_bgp_neighbor_ipv6_address'] = str(ip_addr.ip)\n\n        if ip_addr.version == 4:\n            neighbor = getattr(self._rbridge,\n                               'rbridge_id_router_router_bgp_'\n                               'router_bgp_attributes_neighbor_neighbor_ips_'\n                               'neighbor_addr_remote_as')\n            ip_addr_path = './/*remote-as'\n        else:\n            neighbor = getattr(self._rbridge,\n                               'rbridge_id_router_router_bgp_'\n                               'router_bgp_attributes_neighbor_'\n                               'neighbor_ipv6s_neighbor_ipv6_addr_remote_as')\n            ip_addr_path = './/*remote-as'\n\n        config = neighbor(**neighbor_args)\n\n        if delete and config.find(ip_addr_path) is not None:\n            if ip_addr.version == 4:\n                config.find(ip_addr_path).set('operation', 'delete')\n                config.find('.//*router-bgp-neighbor-address').set('operation',\n                                                                   'delete')\n            elif ip_addr.version == 6:\n                config.find(ip_addr_path).set('operation', 'delete')\n                config.find('.//*router-bgp-neighbor-ipv6-address').set(\n                    'operation', 'delete')\n        else:\n            if ip_addr.version == 6:\n                callback(config)\n                activate_args = dict(rbridge_id=rbridge_id,\n                                     af_ipv6_neighbor_address=str(ip_addr.ip))\n                activate_neighbor = getattr(self._rbridge,\n                                            'rbridge_id_router_router_bgp_'\n                                            'address_family_ipv6_ipv6_unicast_'\n                                            'default_vrf_neighbor_af_ipv6_'\n                                            'neighbor_address_holder_af_ipv6_'\n                                            'neighbor_address_activate')\n                config = activate_neighbor(**activate_args)\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        return callback(config)", "response": "Adds a BGP neighbor to the BGP tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef redistribute(self, **kwargs):\n        # This method is the same as the base method except for one place.\n        # The class doesn't inherit from the base class, though, so we have\n        # to duplicate.\n        source = kwargs.pop('source')\n        afi = kwargs.pop('afi', 'ipv4')\n        callback = kwargs.pop('callback', self._callback)\n        if afi not in ['ipv4', 'ipv6']:\n            raise AttributeError('Invalid AFI.')\n        args = dict(rbridge_id=kwargs.pop('rbridge_id', '1'),\n                    afi=afi, source=source)\n        redistribute = self._redistribute_builder(afi=afi, source=source)\n        config = redistribute(**args)\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        if kwargs.pop('delete', False):\n            tag = 'redistribute-%s' % source\n            config.find('.//*%s' % tag).set('operation', 'delete')\n        return callback(config)", "response": "Set BGP redistribute properties."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding BGP redistribute method.", "response": "def _redistribute_builder(self, afi='ipv4', source=None):\n        \"\"\"Build BGP redistribute method.\n\n        Do not use this method directly.  You probably want ``redistribute``.\n\n        Args:\n            source (str): Source for redistributing. (connected)\n            afi (str): Address family to configure. (ipv4, ipv6)\n\n        Returns:\n            Method to redistribute desired source.\n\n        Raises:\n            KeyError: if `source` is not specified.\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.203', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.bgp._redistribute_builder(source='connected',\n            ...     afi='ipv4')\n            ...     dev.bgp._redistribute_builder(source='hodor',\n            ...     afi='ipv4') # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            AttributeError\n        \"\"\"\n        if source == 'connected':\n            return getattr(self._rbridge,\n                           'rbridge_id_router_router_bgp_address_family_{0}_'\n                           '{0}_unicast_default_vrf_af_{0}_uc_and_vrf_cmds_'\n                           'call_point_holder_redistribute_connected_'\n                           'redistribute_connected'.format(afi))\n        # TODO: Add support for 'static' and 'ospf'\n        else:\n            raise AttributeError('Invalid source.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets BGP max paths property.", "response": "def max_paths(self, **kwargs):\n        \"\"\"Set BGP max paths property.\n\n        Args:\n            vrf (str): The VRF for this BGP process.\n            rbridge_id (str): The rbridge ID of the device on which BGP will be\n                configured in a VCS fabric.\n            paths (str): Number of paths for BGP ECMP (default: 8).\n            afi (str): Address family to configure. (ipv4, ipv6)\n            get (bool): Get config instead of editing config. (True, False)\n            callback (function): A function executed upon completion of the\n                method.  The only parameter passed to `callback` will be the\n                ``ElementTree`` `config`.\n\n        Returns:\n            Return value of `callback`.\n\n        Raises:\n            ``AttributeError``: When `afi` is not one of ['ipv4', 'ipv6']\n\n        Examples:\n            >>> import pynos.device\n            >>> conn = ('10.24.39.203', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     output = dev.bgp.max_paths(paths='8',\n            ...     rbridge_id='225')\n            ...     output = dev.bgp.max_paths(paths='8',\n            ...     rbridge_id='225', get=True)\n            ...     output = dev.bgp.max_paths(paths='8',\n            ...     rbridge_id='225', delete=True)\n            ...     output = dev.bgp.max_paths(paths='8', afi='ipv6',\n            ...     rbridge_id='225')\n            ...     output = dev.bgp.max_paths(paths='8', afi='ipv6',\n            ...     rbridge_id='225', get=True)\n            ...     output = dev.bgp.max_paths(paths='8', afi='ipv6',\n            ...     rbridge_id='225', delete=True)\n            ...     output = dev.bgp.max_paths(paths='8', afi='ipv5',\n            ...     rbridge_id='225') # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            AttributeError\n        \"\"\"\n        afi = kwargs.pop('afi', 'ipv4')\n        callback = kwargs.pop('callback', self._callback)\n        if afi not in ['ipv4', 'ipv6']:\n            raise AttributeError('Invalid AFI.')\n        args = dict(rbridge_id=kwargs.pop('rbridge_id', '1'),\n                    load_sharing_value=kwargs.pop('paths', '8'))\n        max_paths = getattr(self._rbridge,\n                            'rbridge_id_router_router_bgp_address_family_{0}_'\n                            '{0}_unicast_default_vrf_af_common_cmds_holder_'\n                            'maximum_paths_load_sharing_value'.format(afi))\n        config = max_paths(**args)\n        if kwargs.pop('get', False):\n            return callback(config, handler='get_config')\n        if kwargs.pop('delete', False):\n            tag = 'maximum-paths'\n            config.find('.//*%s' % tag).set('operation', 'delete')\n        return callback(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding BGP multihop XML.", "response": "def _multihop_xml(self, **kwargs):\n        \"\"\"Build BGP multihop XML.\n\n        Do not use this method directly.  You probably want ``multihop``.\n\n        Args:\n            rbridge_id (str): The rbridge ID of the device on which BGP will be\n                configured in a VCS fabric.\n            neighbor (ipaddress.ip_interface): `ip_interface` object containing\n                peer IP address (IPv4 or IPv6).\n            count (str): Number of hops to allow. (1-255)\n\n        Returns:\n            ``ElementTree``: XML for configuring BGP multihop.\n\n        Raises:\n            KeyError: if any arg is not specified.\n\n        Examples:\n            >>> import pynos.device\n            >>> from ipaddress import ip_interface\n            >>> conn = ('10.24.39.230', '22')\n            >>> auth = ('admin', 'password')\n            >>> with pynos.device.Device(conn=conn, auth=auth) as dev:\n            ...     dev.bgp._multihop_xml(neighbor=ip_interface(unicode(\n            ...     '10.10.10.10')), count='5', vrf='default', rbridge_id='1')\n            ...     dev.bgp._multihop_xml(\n            ...     ip='10.10.10.10') # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            KeyError\n        \"\"\"\n        ip_addr = kwargs.pop('neighbor')\n        ip = str(ip_addr.ip)\n        rbr_ns = 'urn:brocade.com:mgmt:brocade-rbridge'\n        bgp_ns = 'urn:brocade.com:mgmt:brocade-bgp'\n        config = ET.Element('config')\n        ele = ET.SubElement(config, 'rbridge-id', xmlns=rbr_ns)\n        ET.SubElement(ele, 'rbridge-id').text = kwargs.pop('rbridge_id')\n        ele = ET.SubElement(ele, 'router')\n        ele = ET.SubElement(ele, 'router-bgp', xmlns=bgp_ns)\n        ele = ET.SubElement(ele, 'router-bgp-attributes')\n        ele = ET.SubElement(ele, 'neighbor')\n        if ip_addr.version == 4:\n            ele = ET.SubElement(ele, 'neighbor-ips')\n            ele = ET.SubElement(ele, 'neighbor-addr')\n            ET.SubElement(ele, 'router-bgp-neighbor-address').text = ip\n        else:\n            ele = ET.SubElement(ele, 'neighbor-ipv6s')\n            ele = ET.SubElement(ele, 'neighbor-ipv6-addr')\n            ET.SubElement(ele, 'router-bgp-neighbor-ipv6-address').text = ip\n        ele = ET.SubElement(ele, 'ebgp-multihop')\n        ET.SubElement(ele, 'ebgp-multihop-count').text = kwargs.pop('count')\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an XML Element.", "response": "def return_xml(element_tree):\n    \"\"\"Return an XML Element.\n\n        Args:\n            element_tree (Element): XML Element to be returned.  If sent as a\n                ``str``, this function will attempt to convert it to an\n                ``Element``.\n\n        Returns:\n            Element: An XML Element.\n\n        Raises:\n            TypeError: if `element_tree` is not of type ``Element`` and it\n                cannot be converted from a ``str``.\n\n        Examples:\n            >>> import pynos.utilities\n            >>> import xml.etree.ElementTree as ET\n            >>> ele = pynos.utilities.return_xml(ET.Element('config'))\n            >>> assert isinstance(ele, ET.Element)\n            >>> ele = pynos.utilities.return_xml('<config />')\n            >>> assert isinstance(ele, ET.Element)\n            >>> ele = pynos.utilities.return_xml(\n            ... ['hodor']) # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            TypeError\n    \"\"\"\n    if isinstance(element_tree, ET.Element):\n        return element_tree\n    try:\n        return ET.fromstring(element_tree)\n    except TypeError:\n        raise TypeError('{} takes either {} or {} type.'\n                        .format(repr(return_xml.__name__),\n                                repr(str.__name__),\n                                repr(ET.Element.__name__)))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef valid_vlan_id(vlan_id, extended=True):\n    minimum_vlan_id = 1\n    maximum_vlan_id = 4095\n    if extended:\n        maximum_vlan_id = 8191\n    return minimum_vlan_id <= int(vlan_id) <= maximum_vlan_id", "response": "Validates a VLAN ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmerging two XML documents into a single XML document.", "response": "def merge_xml(first_doc, second_doc):\n    \"\"\"Merges two XML documents.\n\n    Args:\n        first_doc (str): First XML document.  `second_doc` is merged into this\n            document.\n        second_doc (str): Second XML document.  It is merged into the first.\n\n    Returns:\n        XML Document: The merged document.\n\n    Raises:\n        None\n\n    Example:\n        >>> import pynos.utilities\n        >>> import lxml\n        >>> import xml\n        >>> x = xml.etree.ElementTree.fromstring('<config />')\n        >>> y = lxml.etree.fromstring('<config><hello /></config>')\n        >>> x = pynos.utilities.merge_xml(x, y)\n    \"\"\"\n    # Adapted from:\n    # http://stackoverflow.com/questions/27258013/merge-two-xml-files-python\n    # Maps each elements tag to the element from the first document\n    if isinstance(first_doc, lxml.etree._Element):\n        first_doc = ET.fromstring(lxml.etree.tostring(first_doc))\n    if isinstance(second_doc, lxml.etree._Element):\n        second_doc = ET.fromstring(lxml.etree.tostring(second_doc))\n    mapping = {element.tag: element for element in first_doc}\n    for element in second_doc:\n        if not len(element):\n            # Recursed fully.  This element has no children.\n            try:\n                # Update the first document's element's text\n                mapping[element.tag].text = element.text\n            except KeyError:\n                # The element doesn't exist\n                # add it to the mapping and the root document\n                mapping[element.tag] = element\n                first_doc.append(element)\n        else:\n            # This element has children.  Recurse.\n            try:\n                merge_xml(mapping[element.tag], element)\n            except KeyError:\n                # The element doesn't exist\n                # add it to the mapping and the root document\n                mapping[element.tag] = element\n                first_doc.append(element)\n    return lxml.etree.fromstring(ET.tostring(first_doc))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef terminal_cfg_line_exec_timeout(self, **kwargs):\n        config = ET.Element(\"config\")\n        terminal_cfg = ET.SubElement(config, \"terminal-cfg\", xmlns=\"urn:brocade.com:mgmt:brocade-terminal\")\n        line = ET.SubElement(terminal_cfg, \"line\")\n        sessionid_key = ET.SubElement(line, \"sessionid\")\n        sessionid_key.text = kwargs.pop('sessionid')\n        exec_timeout = ET.SubElement(line, \"exec-timeout\")\n        exec_timeout.text = kwargs.pop('exec_timeout')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "response": "Get Config Element for Terminal Config Line Exec Timeout"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_scss_files(self, skip_partials=True, with_source_path=False):\n        scss_files = []\n\n        for root, dirs, files in os.walk(self._source_path):\n            for filename in fnmatch.filter(files, \"*.scss\"):\n                if filename.startswith(\"_\") and skip_partials:\n                    continue\n\n                full_path = os.path.join(root, filename)\n                if not with_source_path:\n                    full_path = full_path.split(self._source_path)[1]\n\n                    if full_path.startswith(\"/\"):\n                        full_path = full_path[1:]\n\n                scss_files.append(full_path)\n\n        return scss_files", "response": "Gets all SCSS files in the source directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _or_join(self, terms):\n        from six import text_type\n\n        if isinstance(terms, (tuple, list)):\n            if len(terms) > 1:\n                return ' | '.join(text_type(t) for t in terms)\n            else:\n                return terms[0]\n        else:\n            return terms", "response": "Joins terms using OR operator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch for datasets by search phrase.", "response": "def search(self, search_phrase, limit=None):\n        \"\"\" Finds datasets by search phrase.\n\n        Args:\n            search_phrase (str or unicode):\n            limit (int, optional): how many results to return. None means without limit.\n\n        Returns:\n            list of DatasetSearchResult instances.\n\n        \"\"\"\n\n        query, query_params = self._make_query_from_terms(search_phrase, limit=limit)\n\n        self._parsed_query = (str(query), query_params)\n\n        assert isinstance(query, TextClause)\n\n        datasets = {}\n\n        def make_result(vid=None, b_score=0, p_score=0):\n            res = DatasetSearchResult()\n            res.b_score = b_score\n            res.p_score = p_score\n            res.partitions = set()\n            res.vid = vid\n            return res\n\n        if query_params:\n            results = self.execute(query, **query_params)\n\n            for result in results:\n                vid, dataset_score = result\n\n                datasets[vid] = make_result(vid, b_score=dataset_score)\n\n\n        logger.debug('Extending datasets with partitions.')\n\n        for partition in self.backend.partition_index.search(search_phrase):\n\n            if partition.dataset_vid not in datasets:\n                datasets[partition.dataset_vid] = make_result(partition.dataset_vid)\n\n            datasets[partition.dataset_vid].p_score += partition.score\n            datasets[partition.dataset_vid].partitions.add(partition)\n\n        return list(datasets.values())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn list with all indexed datasets.", "response": "def all(self):\n        \"\"\" Returns list with all indexed datasets. \"\"\"\n        datasets = []\n\n        query = text(\"\"\"\n            SELECT vid\n            FROM dataset_index;\"\"\")\n\n        for result in self.execute(query):\n            res = DatasetSearchResult()\n            res.vid = result[0]\n            res.b_score = 1\n            datasets.append(res)\n        return datasets"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _index_document(self, document, force=False):\n        query = text(\"\"\"\n            INSERT INTO dataset_index(vid, title, keywords, doc)\n            VALUES(:vid, :title, string_to_array(:keywords, ' '), to_tsvector('english', :doc));\n        \"\"\")\n        self.execute(query, **document)", "response": "Adds a document to the index."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _make_query_from_terms(self, terms, limit=None):\n\n        expanded_terms = self._expand_terms(terms)\n\n        if expanded_terms['doc']:\n            # create query with real score.\n            query_parts = [\"SELECT vid, ts_rank_cd(setweight(doc,'C'), to_tsquery(:doc)) as score\"]\n        if expanded_terms['doc'] and expanded_terms['keywords']:\n            query_parts = [\"SELECT vid, ts_rank_cd(setweight(doc,'C'), to_tsquery(:doc)) \"\n                           \" +  ts_rank_cd(setweight(to_tsvector(coalesce(keywords::text,'')),'B'), to_tsquery(:keywords))\"\n                           ' as score']\n        else:\n            # create query with score = 1 because query will not touch doc field.\n            query_parts = ['SELECT vid, 1 as score']\n\n        query_parts.append('FROM dataset_index')\n        query_params = {}\n        where_counter = 0\n\n        if expanded_terms['doc']:\n            where_counter += 1\n            query_parts.append('WHERE doc @@ to_tsquery(:doc)')\n            query_params['doc'] = self.backend._and_join(expanded_terms['doc'])\n\n        if expanded_terms['keywords']:\n\n            query_params['keywords'] = self.backend._and_join(expanded_terms['keywords'])\n\n            kw_q = \"to_tsvector(coalesce(keywords::text,'')) @@ to_tsquery(:keywords)\"\n\n            query_parts.append( (\"AND \" if where_counter else \"WHERE \") + kw_q )\n\n\n        query_parts.append('ORDER BY score DESC')\n        if limit:\n            query_parts.append('LIMIT :limit')\n            query_params['limit'] = limit\n\n        query_parts.append(';')\n        deb_msg = 'Dataset terms conversion: `{}` terms converted to `{}` with `{}` params query.'\\\n            .format(terms, query_parts, query_params)\n        logger.debug(deb_msg)\n\n\n        q = text('\\n'.join(query_parts)), query_params\n        logger.debug('Dataset search query: {}'.format(q))\n        return q", "response": "Creates a query for dataset from decomposed search terms."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _delete(self, vid=None):\n        assert vid is not None\n        query = text(\"\"\"\n            DELETE FROM dataset_index\n            WHERE vid = :vid;\n        \"\"\")\n        self.execute(query, vid=vid)", "response": "Deletes given dataset from index."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a query for partition from decomposed search terms.", "response": "def _make_query_from_terms(self, terms, limit=None):\n        \"\"\" Creates a query for partition from decomposed search terms.\n\n        Args:\n            terms (dict or unicode or string):\n\n        Returns:\n            tuple of (TextClause, dict): First element is FTS query, second is\n            parameters of the query. Element of the execution of the query is\n            tuple of three elements: (vid, dataset_vid, score).\n\n        \"\"\"\n        expanded_terms = self._expand_terms(terms)\n        terms_used = 0\n\n        if expanded_terms['doc']:\n            # create query with real score.\n            query_parts = [\"SELECT vid, dataset_vid, ts_rank_cd(setweight(doc,'C'), to_tsquery(:doc)) as score\"]\n        if expanded_terms['doc'] and expanded_terms['keywords']:\n            query_parts = [\"SELECT vid, dataset_vid, ts_rank_cd(setweight(doc,'C'), to_tsquery(:doc)) \"\n                           \" +  ts_rank_cd(setweight(to_tsvector(coalesce(keywords::text,'')),'B'), to_tsquery(:keywords))\"\n                           ' as score']\n        else:\n            # create query with score = 1 because query will not touch doc field.\n            query_parts = ['SELECT vid, dataset_vid, 1 as score']\n\n        query_parts.append('FROM partition_index')\n        query_params = {}\n        where_count = 0\n\n        if expanded_terms['doc']:\n            query_parts.append('WHERE doc @@ to_tsquery(:doc)')\n            query_params['doc'] = self.backend._and_join(expanded_terms['doc'])\n            where_count += 1\n            terms_used += 1\n\n        if expanded_terms['keywords']:\n            query_params['keywords'] = self.backend._and_join(expanded_terms['keywords'])\n\n            kw_q = \"to_tsvector(coalesce(keywords::text,'')) @@ to_tsquery(:keywords)\"\n\n            query_parts.append((\"AND \" if where_count else \"WHERE \") + kw_q)\n\n            where_count += 1\n            terms_used += 1\n\n        if expanded_terms['from']:\n\n            query_parts.append((\"AND \" if where_count else \"WHERE \") + ' from_year >= :from_year')\n\n            query_params['from_year'] = expanded_terms['from']\n            where_count += 1\n            terms_used += 1\n\n        if expanded_terms['to']:\n\n            query_parts.append((\"AND \" if where_count else \"WHERE \") + ' to_year <= :to_year')\n\n            query_params['to_year'] = expanded_terms['to']\n            where_count += 1\n            terms_used += 1\n\n        query_parts.append('ORDER BY score DESC')\n\n        if limit:\n            query_parts.append('LIMIT :limit')\n            query_params['limit'] = limit\n\n        if not terms_used:\n            logger.debug('No terms used; not creating query')\n            return None, None\n\n        query_parts.append(';')\n        deb_msg = 'Dataset terms conversion: `{}` terms converted to `{}` with `{}` params query.'\\\n            .format(terms, query_parts, query_params)\n        logger.debug(deb_msg)\n\n        return text('\\n'.join(query_parts)), query_params"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch for partitions by search phrase.", "response": "def search(self, search_phrase, limit=None):\n        \"\"\" Finds partitions by search phrase.\n\n        Args:\n            search_phrase (str or unicode):\n            limit (int, optional): how many results to generate. None means without limit.\n\n        Generates:\n            PartitionSearchResult instances.\n        \"\"\"\n        query, query_params = self._make_query_from_terms(search_phrase, limit=limit)\n\n        self._parsed_query = (str(query), query_params)\n\n        if query is not None:\n\n            self.backend.library.database.set_connection_search_path()\n\n            results = self.execute(query, **query_params)\n\n            for result in results:\n                vid, dataset_vid, score = result\n                yield PartitionSearchResult(\n                    vid=vid, dataset_vid=dataset_vid, score=score)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert the given partition to a document indexed by to FTS index.", "response": "def _as_document(self, partition):\n        \"\"\" Converts partition to document indexed by to FTS index.\n\n        Args:\n            partition (orm.Partition): partition to convert.\n\n        Returns:\n            dict with structure matches to BasePartitionIndex._schema.\n\n        \"\"\"\n        doc = super(self.__class__, self)._as_document(partition)\n\n        # pass time_coverage to the _index_document.\n        doc['time_coverage'] = partition.time_coverage\n        return doc"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a parition document to the index.", "response": "def _index_document(self, document, force=False):\n        \"\"\" Adds parition document to the index. \"\"\"\n\n        time_coverage = document.pop('time_coverage', [])\n        from_year = None\n        to_year = None\n        if time_coverage:\n            from_year = int(time_coverage[0]) if time_coverage and time_coverage[0] else None\n            to_year = int(time_coverage[-1]) if time_coverage and time_coverage[-1] else None\n\n        query = text(\"\"\"\n            INSERT INTO partition_index(vid, dataset_vid, title, keywords, doc, from_year, to_year)\n            VALUES(\n                :vid, :dataset_vid, :title,\n                string_to_array(:keywords, ' '),\n                to_tsvector('english', :doc),\n                :from_year, :to_year); \"\"\")\n\n        self.execute(query, from_year=from_year, to_year=to_year, **document)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_indexed(self, partition):\n        query = text(\"\"\"\n            SELECT vid\n            FROM partition_index\n            WHERE vid = :vid;\n        \"\"\")\n        result = self.execute(query, vid=partition.vid)\n        return bool(result.fetchall())", "response": "Returns True if the given partition is already indexed otherwise returns False."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all(self):\n        partitions = []\n\n        query = text(\"\"\"\n            SELECT dataset_vid, vid\n            FROM partition_index;\"\"\")\n\n        for result in self.execute(query):\n            dataset_vid, vid = result\n            partitions.append(PartitionSearchResult(dataset_vid=dataset_vid, vid=vid, score=1))\n        return partitions", "response": "Returns list with vids of all indexed partitions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch the database for identifiers by a search phrase.", "response": "def search(self, search_phrase, limit=None):\n        \"\"\" Finds identifiers by search phrase.\n\n        Args:\n            search_phrase (str or unicode):\n            limit (int, optional): how many results to return. None means without limit.\n\n        Returns:\n            list of IdentifierSearchResult instances.\n\n        \"\"\"\n\n        query_parts = [\n            'SELECT identifier, type, name, similarity(name, :word) AS sml',\n            'FROM identifier_index',\n            'WHERE name % :word',\n            'ORDER BY sml DESC, name']\n\n        query_params = {\n            'word': search_phrase}\n\n        if limit:\n            query_parts.append('LIMIT :limit')\n            query_params['limit'] = limit\n\n        query_parts.append(';')\n\n        query = text('\\n'.join(query_parts))\n\n        self.backend.library.database.set_connection_search_path()\n\n        results = self.execute(query, **query_params).fetchall()\n\n        for result in results:\n            vid, type, name, score = result\n            yield IdentifierSearchResult(\n                score=score, vid=vid,\n                type=type, name=name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the given identifier document to the index.", "response": "def _index_document(self, identifier, force=False):\n        \"\"\" Adds identifier document to the index. \"\"\"\n\n        query = text(\"\"\"\n            INSERT INTO identifier_index(identifier, type, name)\n            VALUES(:identifier, :type, :name);\n        \"\"\")\n        self.execute(query, **identifier)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _delete(self, identifier=None):\n        query = text(\"\"\"\n            DELETE FROM identifier_index\n            WHERE identifier = :identifier;\n        \"\"\")\n        self.execute(query, identifier=identifier)", "response": "Deletes given identifier from index."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_indexed(self, identifier):\n        query = text(\"\"\"\n            SELECT identifier\n            FROM identifier_index\n            WHERE identifier = :identifier;\n        \"\"\")\n        result = self.execute(query, identifier=identifier['identifier'])\n        return bool(result.fetchall())", "response": "Returns True if identifier is already indexed otherwise returns False."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef all(self):\n        identifiers = []\n\n        query = text(\"\"\"\n            SELECT identifier, type, name\n            FROM identifier_index;\"\"\")\n\n        for result in self.execute(query):\n            vid, type_, name = result\n            res = IdentifierSearchResult(\n                score=1, vid=vid, type=type_, name=name)\n            identifiers.append(res)\n        return identifiers", "response": "Returns list with all indexed identifiers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npare text to have maximum size and add etc to the end if it s changed", "response": "def pare(text, size, etc='...'):\n    '''Pare text to have maximum size and add etc to the end if it's\n    changed'''\n    size = int(size)\n    text = text.strip()\n    if len(text)>size:\n        # strip the last word or not\n        to_be_stripped = not whitespace_re.findall(text[size-1:size+2])\n\n        text = text[:size]\n        if to_be_stripped:\n            half = size//2\n            last = None\n            for mo in whitespace_re.finditer(text[half:]):\n                last = mo\n\n            if last is not None:\n                text = text[:half+last.start()+1]\n\n        return text.rstrip() + etc\n    else:\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_environment(id=None, name=None):\n    data = get_environment_raw(id, name)\n    if data:\n        return utils.format_json(data)", "response": "Get a specific Environment by name or ID"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over the dimension columns regardless of parent and child status", "response": "def dimensions(self):\n        \"\"\"Iterate over the dimension columns, regardless of parent/child status\n\n        \"\"\"\n        from ambry.valuetype.core import ROLE\n\n        for c in self.columns:\n\n            if c.role == ROLE.DIMENSION:\n                yield c"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over the primary dimension columns which do not have a parent", "response": "def primary_dimensions(self):\n        \"\"\"Iterate over the primary dimension columns, columns which do not have a parent\n\n        \"\"\"\n        from ambry.valuetype.core import ROLE\n\n        for c in self.columns:\n\n            if not c.parent and c.role == ROLE.DIMENSION:\n                    yield c"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef primary_measures(self):\n        from ambry.valuetype.core import ROLE\n\n        for c in self.columns:\n\n            if not c.parent and c.role == ROLE.MEASURE:\n                    yield c", "response": "Iterate over the primary columns which do not have a parent"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_column(self, name, update_existing=False, **kwargs):\n        from ..identity import ColumnNumber\n\n        try:\n            c = self.column(name)\n            extant = True\n\n            if not update_existing:\n                return c\n\n        except NotFoundError:\n\n            sequence_id = len(self.columns) + 1\n\n            assert sequence_id\n\n            c = Column(t_vid=self.vid,\n                       sequence_id=sequence_id,\n                       vid=str(ColumnNumber(ObjectNumber.parse(self.vid), sequence_id)),\n                       name=name,\n                       datatype='str')\n            extant = False\n\n        # Update possibly existing data\n        c.data = dict((list(c.data.items()) if c.data else []) + list(kwargs.get('data', {}).items()))\n\n        for key, value in list(kwargs.items()):\n\n            if key[0] != '_' and key not in ['t_vid', 'name',  'sequence_id', 'data']:\n\n                # Don't update the type if the user has specfied a custom type\n                if key == 'datatype' and not c.type_is_builtin():\n                    continue\n\n                # Don't change a datatype if the value is set and the new value is unknown\n                if key == 'datatype' and value == 'unknown' and c.datatype:\n                    continue\n\n                # Don't change a datatype if the value is set and the new value is unknown\n                if key == 'description' and not value:\n                    continue\n\n                try:\n                    setattr(c, key, value)\n                except AttributeError:\n                    raise AttributeError(\"Column record has no attribute {}\".format(key))\n\n            if key == 'is_primary_key' and isinstance(value, str) and len(value) == 0:\n                value = False\n                setattr(c, key, value)\n\n        # If the id column has a description and the table does not, add it to\n        # the table.\n        if c.name == 'id' and c.is_primary_key and not self.description:\n            self.description = c.description\n\n        if not extant:\n            self.columns.append(c)\n\n        return c", "response": "Add a column to the table or update an existing one."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the table has no columns and only the id column", "response": "def is_empty(self):\n        \"\"\"Return True if the table has no columns or the only column is the id\"\"\"\n        if len(self.columns) == 0:\n            return True\n\n        if len(self.columns) == 1 and self.columns[0].name == 'id':\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate columns based on partition statistics", "response": "def update_from_stats(self, stats):\n        \"\"\"Update columns based on partition statistics\"\"\"\n\n        sd = dict(stats)\n\n        for c in self.columns:\n\n            if c not in sd:\n                continue\n\n            stat = sd[c]\n\n            if stat.size and stat.size > c.size:\n                c.size = stat.size\n\n            c.lom = stat.lom"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the sequence id and all of the names and ids derived from it.", "response": "def update_id(self, sequence_id=None, force=True):\n        \"\"\"Alter the sequence id, and all of the names and ids derived from it. This\n        often needs to be don after an IntegrityError in a multiprocessing run\"\"\"\n        from ..identity import ObjectNumber\n\n        if sequence_id:\n            self.sequence_id = sequence_id\n\n        assert self.d_vid\n\n        if self.id is None or force:\n            dataset_id = ObjectNumber.parse(self.d_vid).rev(None)\n            self.d_id = str(dataset_id)\n            self.id = str(TableNumber(dataset_id, self.sequence_id))\n\n        if self.vid is None or force:\n            dataset_vid = ObjectNumber.parse(self.d_vid)\n            self.vid = str(TableNumber(dataset_vid, self.sequence_id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an array of arrays of column transformations.", "response": "def transforms(self):\n        \"\"\"Return an array of arrays of column transforms.\n\n        #The return value is an list of list, with each list being a segment of column transformations, and\n        #each segment having one entry per column.\n\n        \"\"\"\n\n        tr = []\n        for c in self.columns:\n            tr.append(c.expanded_transform)\n\n        return six.moves.zip_longest(*tr)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef before_insert(mapper, conn, target):\n        if target.sequence_id is None:\n            from ambry.orm.exc import DatabaseError\n            raise DatabaseError('Must have sequence id before insertion')\n\n        Table.before_update(mapper, conn, target)", "response": "event. listen method for Sqlalchemy to set the seqience_id for this object and create an ObjectNumber value for the id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef before_update(mapper, conn, target):\n\n        target.name = Table.mangle_name(target.name)\n\n        if isinstance(target, Column):\n            raise TypeError('Got a column instead of a table')\n\n        target.update_id(target.sequence_id, False)", "response": "Set the Table ID based on the dataset number and the sequence number of the table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deduplicate(s, ch):\n    return ch.join([substring for substring in s.strip().split(ch) if substring])", "response": "Remove duplicate characters from a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving all text inside brackets from a string.", "response": "def remove_text_inside_brackets(s, brackets=\"()[]\"):\n    \"\"\"\n    From http://stackoverflow.com/a/14603508/610569\n    \"\"\"\n    count = [0] * (len(brackets) // 2) # count open/close brackets\n    saved_chars = []\n    for character in s:\n        for i, b in enumerate(brackets):\n            if character == b: # found bracket\n                kind, is_close = divmod(i, 2)\n                count[kind] += (-1)**is_close # `+1`: open, `-1`: close\n                if count[kind] < 0: # unbalanced bracket\n                    count[kind] = 0\n                break\n        else: # character is not a bracket\n            if not any(count): # outside brackets\n                saved_chars.append(character)\n    return ''.join(saved_chars)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef color_print(s, color=None, highlight=None, end='\\n', file=sys.stdout,\n                **kwargs):\n    \"\"\"\n    From http://stackoverflow.com/a/287944/610569\n    See also https://gist.github.com/Sheljohn/68ca3be74139f66dbc6127784f638920\n    \"\"\"\n    if color in palette and color != 'default':\n        s = palette[color] + s\n    # Highlight / Background color.\n    if highlight and highlight in highlighter:\n        s = highlighter[highlight] + s\n    # Custom string format.\n    for name, value in kwargs.items():\n        if name in formatter and value == True:\n            s = formatter[name] + s\n    print(s + palette['default'], end=end, file=file)", "response": "Print a string to stdout with color."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait_for_tasks(self, raise_if_error=True):\n        errors = []\n        tasks_seen = TaskCache()\n        while True:\n            for session in self.values():\n                errs = session.wait_for_tasks(raise_if_error=False)\n                errors.extend(errs)\n            # look for tasks created after the wait (in callbacks of\n            # tasks from different sessions)\n            tasks = []\n            for session in self.values():\n                tasks.extend(session.tasks())\n            # if none, then just break - else loop to wait for them\n            if not any(t for t in tasks if t not in tasks_seen):\n                break\n        if raise_if_error and errors:\n            raise TaskErrors(errors)\n        return errors", "response": "Wait for all running tasks from the sessions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef error(self):\n        if self.__timed_out:\n            return TimeoutError(self.session, self, \"timeout\")\n        if self.__exit_code is not None and \\\n                self.__expected_exit_code is not None and \\\n                self.__exit_code != self.__expected_exit_code:\n            return ExitCodeError(self.session, self,\n                                 'bad exit code: Got %s' % self.__exit_code)", "response": "Return an instance of Exception if any else None."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new LicenseSingleton clf", "response": "def create_new(self, **kwargs):\n        \"\"\"\n        Creates a new License\n        \n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.create_new(callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param LicenseRest body:\n        :return: LicenseSingleton\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.create_new_with_http_info(**kwargs)\n        else:\n            (data) = self.create_new_with_http_info(**kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete(self, id, **kwargs):\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.delete_with_http_info(id, **kwargs)\n        else:\n            (data) = self.delete_with_http_info(id, **kwargs)\n            return data", "response": "Delete an existing License in the specified base."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all Licenses This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please define a `callback` function to be invoked when receiving the response. >>> def callback_function(response): >>> pprint(response) >>> >>> thread = api.get_all(callback=callback_function) :param callback function: The callback function for asynchronous request. (optional) :param int page_index: Page Index :param int page_size: Pagination size :param str sort: Sorting RSQL :param str q: RSQL Query :return: LicensePage If the method is called asynchronously, returns the request thread.", "response": "def get_all(self, **kwargs):\n        \"\"\"\n        Gets all Licenses\n        \n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.get_all(callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param int page_index: Page Index\n        :param int page_size: Pagination size\n        :param str sort: Sorting RSQL\n        :param str q: RSQL Query\n        :return: LicensePage\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.get_all_with_http_info(**kwargs)\n        else:\n            (data) = self.get_all_with_http_info(**kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_specific(self, id, **kwargs):\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.get_specific_with_http_info(id, **kwargs)\n        else:\n            (data) = self.get_specific_with_http_info(id, **kwargs)\n            return data", "response": "Get specific LicenseSingleton\n clf."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating an existing License with the specified id.", "response": "def update(self, id, **kwargs):\n        \"\"\"\n        Updates an existing License\n        \n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.update(id, callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param int id: License id (required)\n        :param LicenseRest body:\n        :return: None\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.update_with_http_info(id, **kwargs)\n        else:\n            (data) = self.update_with_http_info(id, **kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef incver(self):\n        d = {}\n        for p in self.__mapper__.attrs:\n            if p.key in ['vid','vname','fqname', 'version', 'cache_key']:\n                continue\n            if p.key == 'revision':\n                d[p.key] = self.revision + 1\n            else:\n                d[p.key] = getattr(self, p.key)\n\n        n =  Dataset(**d)\n\n        return n", "response": "Increment all of the version numbers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef next_sequence_id(self, table_class, force_query=False):\n\n        from . import next_sequence_id\n        from sqlalchemy.orm import object_session\n\n        # NOTE: This next_sequence_id uses a different algorithm than dataset.next_sequence_id\n        # FIXME replace this one with dataset.next_sequence_id\n        return next_sequence_id(object_session(self), self._sequence_ids, self.vid, table_class, force_query=force_query)", "response": "Return the next sequence id for a child object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef new_unique_object(self, table_class, sequence_id=None, force_query=False, **kwargs):\n        from sqlalchemy.exc import IntegrityError\n        from sqlalchemy.orm.exc import FlushError\n\n        # If a sequence ID was specified, the caller is certain\n        #  that there is no potential for conflicts,\n        # so there is no need to commit here.\n        if not sequence_id:\n            commit = True\n            sequence_id = self.next_sequence_id(table_class, force_query=force_query)\n        else:\n            commit = False\n\n        o = table_class(\n            d_vid=self.vid,\n            **kwargs\n        )\n\n        o.update_id(sequence_id)\n\n        if commit is False:\n            return o\n\n        self.commit()\n\n        if self._database.driver == 'sqlite':\n            # The Sqlite database can't have concurrency, so there no problem.\n            self.session.add(o)\n            self.commit()\n            return o\n        else: # Postgres. Concurrency is a bitch.\n            table_name = table_class.__tablename__\n            child_sequence_id = table_class.sequence_id.property.columns[0].name\n\n        try:\n\n            self.session.add(o)\n            self.commit()\n            return o\n\n        except (IntegrityError, FlushError) as e:\n            self.rollback()\n            self.session.merge(self)\n            print 'Failed'\n            return None\n\n        return\n        # This is horrible, but it's the only thing that has worked for both\n        # Sqlite and Postgres in both single processes and multiprocesses.\n        d_vid = self.vid\n        while True:\n            try:\n                self.session.add(o)\n                self.commit()\n                return o\n\n            except (IntegrityError, FlushError) as e:\n\n                self.rollback()\n\n                self.session.expunge_all()\n                ds = self._database.dataset(d_vid)\n                sequence_id = ds.next_sequence_id(table_class, force_query=True)\n\n                o.update_id(sequence_id)\n\n            except Exception as e:\n\n                print('Completely failed to get a new {} sequence_id; {}'.format(table_class, e))\n                self.rollback()\n                import traceback\n\n                # This bit is helpful in a multiprocessing run.\n                tb = traceback.format_exc()\n\n                print(tb)\n                raise", "response": "Create a new unique object in the database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a new table to the schema or update it already exists. If updating will only update data.", "response": "def new_table(self, name, add_id=True, **kwargs):\n        '''Add a table to the schema, or update it it already exists.\n\n        If updating, will only update data.\n        '''\n        from . import Table\n        from .exc import NotFoundError\n\n        try:\n            table = self.table(name)\n            extant = True\n        except NotFoundError:\n\n            extant = False\n\n            if 'sequence_id' not in kwargs:\n                kwargs['sequence_id'] = self._database.next_sequence_id(Dataset, self.vid, Table)\n\n            table = Table(name=name, d_vid=self.vid, **kwargs)\n\n            table.update_id()\n\n        # Update possibly extant data\n        table.data = dict(\n            (list(table.data.items()) if table.data else []) + list(kwargs.get('data', {}).items()))\n\n        for key, value in list(kwargs.items()):\n\n            if not key:\n                continue\n            if key[0] != '_' and key not in ['vid', 'id', 'id_', 'd_id', 'name', 'sequence_id', 'table', 'column', 'data']:\n                setattr(table, key, value)\n\n        if add_id:\n            table.add_id_column()\n\n        if not extant:\n            self.tables.append(table)\n\n        return table"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new partition and returns it.", "response": "def new_partition(self, table, **kwargs):\n        \"\"\" Creates new partition and returns it.\n\n        Args:\n            table (orm.Table):\n\n        Returns:\n            orm.Partition\n        \"\"\"\n\n        from . import Partition\n\n        # Create the basic partition record, with a sequence ID.\n\n        if isinstance(table, string_types):\n            table = self.table(table)\n\n        if 'sequence_id' in kwargs:\n            sequence_id = kwargs['sequence_id']\n            del kwargs['sequence_id']\n        else:\n            sequence_id = self._database.next_sequence_id(Dataset, self.vid, Partition)\n\n        p = Partition(\n            t_vid=table.vid,\n            table_name=table.name,\n            sequence_id=sequence_id,\n            dataset=self,\n            d_vid=self.vid,\n            **kwargs\n        )\n\n\n        p.update_id()\n\n        return p"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the first partition in the dataset with the given ref.", "response": "def partition(self, ref=None, **kwargs):\n        \"\"\" Returns partition by ref. \"\"\"\n        from .exc import NotFoundError\n        from six import text_type\n\n        if ref:\n\n            for p in self.partitions: # This is slow for large datasets, like Census years.\n                if (text_type(ref) == text_type(p.name) or text_type(ref) == text_type(p.id) or\n                            text_type(ref) == text_type(p.vid)):\n                    return p\n\n            raise NotFoundError(\"Failed to find partition for ref '{}' in dataset '{}'\".format(ref, self.name))\n\n        elif kwargs:\n            from ..identity import PartitionNameQuery\n\n            pnq = PartitionNameQuery(**kwargs)\n            return self._find_orm"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bsfile(self, path):\n        from sqlalchemy.orm.exc import NoResultFound\n        from ambry.orm.exc import NotFoundError\n\n        try:\n\n            f =  object_session(self)\\\n                .query(File)\\\n                .filter(File.d_vid == self.vid)\\\n                .filter(File.major_type == File.MAJOR_TYPE.BUILDSOURCE)\\\n                .filter(File.path == path)\\\n                .one()\n\n            return f\n\n        except NoResultFound:\n            raise NotFoundError(\"Failed to find file for path '{}' \".format(path))", "response": "Return a Build Source file ref creating a new one if the one requested does not exist"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef row(self, fields):\n\n        d = self.dict\n\n        row = [None] * len(fields)\n\n        for i, f in enumerate(fields):\n            if f in d:\n                row[i] = d[f]\n\n        return row", "response": "Return a row for fields for CSV files pretty printing etc give a set of fields give a set of fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef metadata(self):\n        from ambry.metadata.schema import Top  # cross-module import\n        top = Top()\n        top.build_from_db(self.dataset)\n        return top", "response": "Access process configuarion values as attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all of the rows for a dataset.", "response": "def rows(self):\n        \"\"\"Return configuration in a form that can be used to reconstitute a\n        Metadata object. Returns all of the rows for a dataset.\n\n        This is distinct from get_config_value, which returns the value\n        for the library.\n\n        \"\"\"\n        from ambry.orm import Config as SAConfig\n        from sqlalchemy import or_\n\n        rows = []\n        configs = self.dataset.session\\\n            .query(SAConfig)\\\n            .filter(or_(SAConfig.group == 'config', SAConfig.group == 'process'),\n                    SAConfig.d_vid == self.dataset.vid)\\\n            .all()\n\n        for r in configs:\n            parts = r.key.split('.', 3)\n\n            if r.group == 'process':\n                parts = ['process'] + parts\n\n            cr = ((parts[0] if len(parts) > 0 else None,\n                   parts[1] if len(parts) > 1 else None,\n                   parts[2] if len(parts) > 2 else None\n                   ), r.value)\n\n            rows.append(cr)\n\n        return rows"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_value(instance_to_path_map, path_to_instance_map, prop_tree, config_instance):\n    path = instance_to_path_map[config_instance]\n\n    # find group\n    group = prop_tree\n    for elem in path[:-1]:\n        group = getattr(group, elem)\n\n    assert group._key == config_instance.parent.key\n    setattr(group, config_instance.key, config_instance.value)\n\n    #\n    # bind config to the term\n    #\n    # FIXME: Make all the terms to store config instance the same way.\n    term = getattr(group, config_instance.key)\n    try:\n        if hasattr(term, '_term'):\n            # ScalarTermS and ScalarTermU case\n            term._term._config = config_instance\n            return\n    except KeyError:\n        # python3 case. TODO: Find the way to make it simple.\n        pass\n\n    try:\n        if hasattr(term, '_config'):\n            term._config = config_instance\n            return\n    except KeyError:\n        # python3 case. TODO: Find the way to make it simple.\n        pass\n    else:\n        pass", "response": "Sets the value of the config instance in the property tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets or create sqlalchemy instance.", "response": "def get_or_create(session, model, **kwargs):\n    \"\"\" Get or create sqlalchemy instance.\n\n    Args:\n        session (Sqlalchemy session):\n        model (sqlalchemy model):\n        kwargs (dict): kwargs to lookup or create instance.\n\n    Returns:\n        Tuple: first element is found or created instance, second is boolean - True if instance created,\n            False if instance found.\n    \"\"\"\n    instance = session.query(model).filter_by(**kwargs).first()\n    if instance:\n        return instance, False\n    else:\n        instance = model(**kwargs)\n        if 'dataset' in kwargs:\n            instance.update_sequence_id(session, kwargs['dataset'])\n        session.add(instance)\n        session.commit()\n        return instance, True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind appropriate config instance and returns it.", "response": "def _get_config_instance(group_or_term, session, **kwargs):\n    \"\"\" Finds appropriate config instance and returns it.\n\n    Args:\n        group_or_term (Group or Term):\n        session (Sqlalchemy session):\n        kwargs (dict): kwargs to pass to get_or_create.\n\n    Returns:\n        tuple of (Config, bool):\n    \"\"\"\n    path = group_or_term._get_path()\n    cached = group_or_term._top._cached_configs.get(path)\n    if cached:\n        config = cached\n        created = False\n    else:\n        # does not exist or not yet cached\n        config, created = get_or_create(session, Config, **kwargs)\n    return config, created"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_members(self):\n\n        self._members = {\n            name: attr for name, attr in iteritems(type(self).__dict__) if isinstance(attr, Group)}\n\n        for name, m in iteritems(self._members):\n            m.init_descriptor(name, self)", "response": "Register the members of the class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_error(self, group, term, sub_term, value):\n\n        self._errors[(group, term, sub_term)] = value", "response": "Add an error to the errors list."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a Jina template engine then perform substitutions on a string", "response": "def _jinja_sub(self, st):\n        \"\"\"Create a Jina template engine, then perform substitutions on a string\"\"\"\n\n        if isinstance(st, string_types):\n            from jinja2 import Template\n\n            try:\n                for i in range(5):  # Only do 5 recursive substitutions.\n                    st = Template(st).render(**(self._top.dict))\n                    if '{{' not in st:\n                        break\n                return st\n            except Exception as e:\n                return st\n                #raise ValueError(\n                #    \"Failed to render jinja template for metadata value '{}': {}\".format(st, e))\n\n        return st"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef scalar_term(self, st):\n        if isinstance(st, binary_type):\n            return _ScalarTermS(st, self._jinja_sub)\n        elif isinstance(st, text_type):\n            return _ScalarTermU(st, self._jinja_sub)\n        elif st is None:\n            return _ScalarTermU(u(''), self._jinja_sub)\n        else:\n            return st", "response": "Return a _ScalarTermS or _ScalarTermU from a string to perform text and HTML substitutions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_config(self):\n        dataset = self._top._config.dataset\n        session = object_session(self._top._config)\n        logger.debug(\n            'Updating group config. dataset: {}, type: {}, key: {}'.format(dataset.vid, self._top._type, self._key))\n\n        self._config, created = _get_config_instance(\n            self, session,\n            parent_id=self._parent._config.id, d_vid=dataset.vid,\n            group=self._key, key=self._key, type=self._top._type, dataset = dataset)\n        if created:\n            self._top._cached_configs[self._get_path()] = self._config\n        self._top._add_valid(self._config)\n\n        if created:\n            logger.debug(\n                'New group config created and linked. config: {}'.format(self._config))\n        else:\n            logger.debug(\n                'Existing group config linked. config: {}'.format(self._config))", "response": "Updates or creates a config of that group. Requires tree bound to db."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_group_instance(self, parent):\n        o = copy.copy(self)\n        o.init_instance(parent)\n        return o", "response": "Create an instance object for the group"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the config of the VarDictGroup. Requires bound to db tree.", "response": "def update_config(self, key, value):\n        \"\"\" Creates or updates db config of the VarDictGroup. Requires bound to db tree. \"\"\"\n        dataset = self._top._config.dataset\n        session = object_session(self._top._config)\n        logger.debug(\n            'Updating VarDictGroup config. dataset: {}, type: {}, key: {}, value: {}'.format(\n                dataset, self._top._type, key, value))\n\n        if not self._parent._config:\n            self._parent.update_config()\n\n        # create or update group config\n        self._config, created = get_or_create(\n            session, Config,\n            d_vid=dataset.vid, type=self._top._type,\n            parent=self._parent._config, group=self._key,\n            key=self._key,dataset=dataset)\n        self._top._add_valid(self._config)\n\n        # create or update value config\n        config, created = get_or_create(\n            session, Config, parent=self._config, d_vid=dataset.vid,\n            type=self._top._type, key=key,dataset=dataset)\n\n        if config.value != value:\n            # sync db value with term value.\n            config.value = value\n            session.merge(config)\n            session.commit()\n            logger.debug(\n                'Config bound to the VarDictGroup key updated. config: {}'.format(config))\n        self._top._add_valid(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates or updates db config of the term. Requires bound to db tree.", "response": "def update_config(self):\n        \"\"\" Creates or updates db config of the term. Requires bound to db tree. \"\"\"\n        dataset = self._top._config.dataset\n        session = object_session(self._top._config)\n\n        #logger.debug('Updating term config. dataset: {}, type: {}, key: {}, value: {}'.format(\n        #        dataset, self._top._type, self._key, self.get()))\n\n        if not self._parent._config:\n            self._parent.update_config()\n\n        self._config, created = _get_config_instance(\n            self, session,\n            parent=self._parent._config, d_vid=dataset.vid,\n            type=self._top._type, key=self._key, dataset=dataset)\n        if created:\n            self._top._cached_configs[self._get_path()] = self._config\n\n        # We update ScalarTerm and ListTerm values only. Composite terms (DictTerm for example)\n        # should not contain value.\n        if isinstance(self, (ScalarTerm, ListTerm)):\n            if self._config.value != self.get():\n                self._config.value = self.get()\n                session.merge(self._config)\n                session.commit()\n        self._top._add_valid(self._config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef text(self):\n\n        s = MLStripper()\n        s.feed(self.html)\n        return s.get_data()", "response": "Interpret the scalar as Markdown strip the HTML and return the text"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start(self, *args, **kwargs):\n        queue = Queue()\n        stdout_reader, stderr_reader = \\\n            self._create_readers(queue, *args, **kwargs)\n\n        self.thread = threading.Thread(target=self._read,\n                                       args=(stdout_reader,\n                                             stderr_reader,\n                                             queue))\n        self.thread.daemon = True\n        self.thread.start()", "response": "Start reading the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef quoteattrs(data):\n    '''Takes dict of attributes and returns their HTML representation'''\n    items = []\n    for key, value in data.items():\n        items.append('{}={}'.format(key, quoteattr(value)))\n    return ' '.join(items)", "response": "Takes dict of attributes and returns their HTML representation"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nquote text to be used as JavaScript string in HTML templates. The result doesn t contain surrounding quotes.", "response": "def quote_js(text):\n    '''Quotes text to be used as JavaScript string in HTML templates. The\n    result doesn't contain surrounding quotes.'''\n    if isinstance(text, six.binary_type):\n        text = text.decode('utf-8') # for Jinja2 Markup\n    text = text.replace('\\\\', '\\\\\\\\');\n    text = text.replace('\\n', '\\\\n');\n    text = text.replace('\\r', '');\n    for char in '\\'\"<>&':\n        text = text.replace(char, '\\\\x{:02x}'.format(ord(char)))\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a ramp plan for a single system.", "response": "def create_ramp_plan(err, ramp):\n    \"\"\"\n    Formulate and execute on a plan to slowly add heat or cooling to the system\n\n    `err` initial error (PV - SP)\n    `ramp` the size of the ramp\n\n    A ramp plan might yield MVs in this order at every timestep:\n        [5, 0, 4, 0, 3, 0, 2, 0, 1]\n        where err == 5 + 4 + 3 + 2 + 1\n    \"\"\"\n    if ramp == 1:  # basecase\n        yield int(err)\n        while True:\n            yield 0\n    # np.arange(n).sum() == err\n    # --> solve for n\n    # err = (n - 1) * (n // 2) == .5 * n**2 - .5 * n\n    # 0 = n**2 - n  --> solve for n\n    n = np.abs(np.roots([.5, -.5, 0]).max())\n    niter = int(ramp // (2 * n))  # 2 means add all MV in first half of ramp\n    MV = n\n    log.info('Initializing a ramp plan', extra=dict(\n        ramp_size=ramp, err=err, niter=niter))\n    for x in range(int(n)):\n        budget = MV\n        for x in range(niter):\n            budget -= MV // niter\n            yield int(np.sign(err) * (MV // niter))\n        yield int(budget * np.sign(err))\n        MV -= 1\n    while True:\n        yield 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls the user-defined function: stop_condition(errdata) If the function returns -1, do nothing. Otherwise, sys.exit.", "response": "def evaluate_stop_condition(errdata, stop_condition):\n    \"\"\"\n    Call the user-defined function: stop_condition(errdata)\n    If the function returns -1, do nothing.  Otherwise, sys.exit.\n    \"\"\"\n    if stop_condition:\n        return_code = stop_condition(list(errdata))\n        if return_code != -1:\n            log.info(\n                'Stop condition triggered!  Relay is terminating.',\n                extra=dict(return_code=return_code))\n            sys.exit(return_code)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking the Python source given by codeString for flakes.", "response": "def check(codeString, filename):\n    \"\"\"\n    Check the Python source given by C{codeString} for flakes.\n\n    @param codeString: The Python source to check.\n    @type codeString: C{str}\n\n    @param filename: The name of the file the source came from, used to report\n        errors.\n    @type filename: C{str}\n\n    @return: The number of warnings emitted.\n    @rtype: C{int}\n    \"\"\"\n    # First, compile into an AST and handle syntax errors.\n    try:\n        tree = compile(codeString, filename, \"exec\", ast.PyCF_ONLY_AST)\n    except SyntaxError, value:\n        msg = value.args[0]\n\n        (lineno, offset, text) = value.lineno, value.offset, value.text\n\n        # If there's an encoding problem with the file, the text is None.\n        if text is None:\n            # Avoid using msg, since for the only known case, it contains a\n            # bogus message that claims the encoding the file declared was\n            # unknown.\n            sys.stderr.write(\"%s: problem decoding source\\n\" % (filename, ))\n        else:\n            line = text.splitlines()[-1]\n\n            if offset is not None:\n                offset = offset - (len(text) - len(line))\n\n            sys.stderr.write('%s:%d: %s' % (filename, lineno, msg))\n            sys.stderr.write(line + '\\n')\n\n            if offset is not None:\n                sys.stderr.write(\" \" * offset + \"^\\n\")\n\n        return 1\n    else:\n        # Okay, it's syntactically valid.  Now check it.\n        w = checker.Checker(tree, filename)\n        lines = codeString.split('\\n')\n        messages = [message for message in w.messages\n                    if lines[message.lineno - 1].find('pyflakes:ignore') < 0]\n        messages.sort(lambda a, b: cmp(a.lineno, b.lineno))\n        false_positives = 0\n        for warning in messages:\n            if not (re.match('.*__init__.py', str(warning))\n                    and isinstance(warning, (UnusedImport, ImportStarUsed))):\n                print(warning)\n            else:\n                false_positives += 1\n        return len(messages) - false_positives"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks the given path and print out any warnings detected.", "response": "def checkPath(filename):\n    \"\"\"\n    Check the given path, printing out any warnings detected.\n\n    @return: the number of warnings printed\n    \"\"\"\n    try:\n        return check(file(filename, 'U').read() + '\\n', filename)\n    except IOError, msg:\n        sys.stderr.write(\"%s: %s\\n\" % (filename, msg.args[1]))\n        return 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clean_value(self):\n        '''\n        Current field's converted value from form's python_data.\n        '''\n        # XXX cached_property is used only for set initial state\n        #     this property should be set every time field data\n        #     has been changed, for instance, in accept method\n        python_data = self.parent.python_data\n        if self.name in python_data:\n            return python_data[self.name]\n        return self.get_initial()", "response": "Clean value of the current value from form s python_data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef accept(self):\n        '''Extracts raw value from form's raw data and passes it to converter'''\n        value = self.raw_value\n        if not self._check_value_type(value):\n            # XXX should this be silent or TypeError?\n            value = [] if self.multiple else self._null_value\n        self.clean_value = self.conv.accept(value)\n        return {self.name: self.clean_value}", "response": "Extracts raw value from form s raw data and passes it to converter"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef python_data(self):\n        '''Representation of aggregate value as dictionary.'''\n        try:\n            value = self.clean_value\n        except LookupError:\n            # XXX is this necessary?\n            value = self.get_initial()\n        return self.from_python(value)", "response": "Representation of aggregate value as dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccept all children fields collects resulting values into dict and passes that dict to converter.", "response": "def accept(self):\n        '''\n        Accepts all children fields, collects resulting values into dict and\n        passes that dict to converter.\n\n        Returns result of converter as separate value in parent `python_data`\n        '''\n        result = dict(self.python_data)\n        for field in self.fields:\n            if field.writable:\n                result.update(field.accept())\n            else:\n                # readonly field\n                field.set_raw_value(self.form.raw_data,\n                                    field.from_python(result[field.name]))\n        self.clean_value = self.conv.accept(result)\n        return {self.name: self.clean_value}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nacting as Field. accepts but returns result of every child field as value in parent python_data.", "response": "def accept(self):\n        '''\n        Acts as `Field.accepts` but returns result of every child field \n        as value in parent `python_data`.\n        '''\n        result = FieldSet.accept(self)\n        self.clean_value = result[self.name]\n        return self.clean_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle(conn, addr, gateway, *args, **kwargs):\n    conn.sendall(b'OK pubsub 1.0\\n')\n    while True:\n        try:\n            s = conn.recv(1024).decode('utf-8').strip()\n            if not s:\n                conn.close()\n                break\n        except ConnectionResetError:\n            logger.debug('Client close the connection.')\n            break\n\n        parts = s.split(' ')\n        if len(parts) != 2:\n            conn.send(b\"Invalid command\\n\")\n            continue\n        cmd, topic = parts\n        if cmd.lower() != 'sub':\n            conn.send(bytes(\"Unknown command '{}'\\n\".format(cmd.lower()), 'utf-8'))\n            continue\n        if topic not in gateway.topics:\n            conn.send(bytes(\"Unknown topic '{}'\\n\".format(topic), 'utf-8'))\n            continue\n        conn.sendall(bytes('ACK {} {}\\n'.format(cmd, topic), 'utf-8'))\n        subscriber = Subscriber(addr, conn)\n        gateway.link(topic, subscriber)\n        break", "response": "Handle incoming messages from the broker."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds files in a directory and yield them.", "response": "def find_files(dir_path, extension=\"*\"):\n    \"\"\"\n    From https://stackoverflow.com/a/2186565/610569\n    \"\"\"\n    if sys.version_info.major == 3 and sys.version_info.minor >= 5:\n        pattern = '/'.join([dir_path, '**', extension])\n        for filename in glob.iglob(pattern, recursive=True):\n            yield filename\n    else:\n        for root, dirnames, filenames in os.walk(dir_path):\n            for filename in fnmatch.filter(filenames, extension):\n                yield os.path.join(root, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a Ticker instance for the given pair.", "response": "def getTicker(pair, connection=None, info=None):\n    \"\"\"Retrieve the ticker for the given pair.  Returns a Ticker instance.\"\"\"\n\n    if info is not None:\n        info.validate_pair(pair)\n\n    if connection is None:\n        connection = common.BTCEConnection()\n\n    response = connection.makeJSONRequest(\"/api/3/ticker/%s\" % pair)\n\n    if type(response) is not dict:\n        raise TypeError(\"The response is a %r, not a dict.\" % type(response))\n    elif u'error' in response:\n        print(\"There is a error \\\"%s\\\" while obtaining ticker %s\" % (response['error'], pair))\n        ticker = None\n    else:\n        ticker = Ticker(**response[pair])\n\n    return ticker"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getDepth(pair, connection=None, info=None):\n\n    if info is not None:\n        info.validate_pair(pair)\n\n    if connection is None:\n        connection = common.BTCEConnection()\n\n    response = connection.makeJSONRequest(\"/api/3/depth/%s\" % pair)\n    if type(response) is not dict:\n        raise TypeError(\"The response is not a dict.\")\n\n    depth = response.get(pair)\n    if type(depth) is not dict:\n        raise TypeError(\"The pair depth is not a dict.\")\n\n    asks = depth.get(u'asks')\n    if type(asks) is not list:\n        raise TypeError(\"The response does not contain an asks list.\")\n\n    bids = depth.get(u'bids')\n    if type(bids) is not list:\n        raise TypeError(\"The response does not contain a bids list.\")\n\n    return asks, bids", "response": "Retrieve the depth for the given pair. Returns a tuple ( asks bids ) ; Each of these is a list of ( price volume ) tuples."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getTradeHistory(pair, connection=None, info=None, count=None):\n\n    if info is not None:\n        info.validate_pair(pair)\n\n    if connection is None:\n        connection = common.BTCEConnection()\n\n    response = connection.makeJSONRequest(\"/api/3/trades/%s\" % pair)\n    if type(response) is not dict:\n        raise TypeError(\"The response is not a dict.\")\n\n    history = response.get(pair)\n    if type(history) is not list:\n        raise TypeError(\"The response is a %r, not a list.\" % type(history))\n\n    result = []\n\n    # Limit the number of items returned if requested.\n    if count is not None:\n        history = history[:count]\n\n    for h in history:\n        h[\"pair\"] = pair\n        t = Trade(**h)\n        result.append(t)\n    return result", "response": "Returns the trade history for the given pair."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove file from filesystem.", "response": "def remove(self):\n        \"\"\" Removes file from filesystem. \"\"\"\n        from fs.errors import ResourceNotFoundError\n\n        try:\n            self._fs.remove(self.file_name)\n        except ResourceNotFoundError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreporting on which direction a synchronization should be done.", "response": "def sync_dir(self):\n        \"\"\" Report on which direction a synchronization should be done.\n        :return:\n        \"\"\"\n\n        # NOTE: These are ordered so the FILE_TO_RECORD has preference over RECORD_TO_FILE\n        # if there is a conflict.\n\n        if self.exists() and bool(self.size()) and not self.record.size:\n            # The fs exists, but the record is empty\n            return self.SYNC_DIR.FILE_TO_RECORD\n\n        if (self.fs_modtime or 0) > (self.record.modified or 0) and self.record.source_hash != self.fs_hash:\n            # Filesystem is newer\n\n            return self.SYNC_DIR.FILE_TO_RECORD\n\n        if self.record.size and not self.exists():\n            # Record exists, but not the FS\n\n            return self.SYNC_DIR.RECORD_TO_FILE\n\n        if (self.record.modified or 0) > (self.fs_modtime or 0):\n            # Record is newer\n            return self.SYNC_DIR.RECORD_TO_FILE\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsynchronize between the file in the file system and the field record", "response": "def sync(self, force=None):\n        \"\"\"Synchronize between the file in the file system and the field record\"\"\"\n\n        try:\n            if force:\n                sd = force\n            else:\n                sd = self.sync_dir()\n\n            if sd == self.SYNC_DIR.FILE_TO_RECORD:\n\n                if force and not self.exists():\n                    return None\n\n                self.fs_to_record()\n\n            elif sd == self.SYNC_DIR.RECORD_TO_FILE:\n                self.record_to_fs()\n\n            else:\n                return None\n\n            self._dataset.config.sync[self.file_const][sd] = time.time()\n            return sd\n        except Exception as e:\n            self._bundle.rollback()\n            self._bundle.error(\"Failed to sync '{}': {}\".format(self.file_const, e))\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a file in the filesystem into a record", "response": "def fh_to_record(self, f):\n        \"\"\"Load a file in the filesystem into the file record\"\"\"\n        import unicodecsv as csv\n\n        fn_path = self.file_name\n\n        fr = self.record\n        fr.path = fn_path\n        rows = []\n\n        # NOTE. There were two cases here, for PY2 and PY3. Py two had\n        # encoding='utf-8' in the reader. I've combined them b/c that's the default for\n        # unicode csv, so it shouldn't be necessary.\n\n        # Should probably be something like this:\n        #if sys.version_info[0] >= 3:  # Python 3\n        #    import csv\n        #    f = open(self._fstor.syspath, 'rtU', encoding=encoding)\n        #    reader = csv.reader(f)\n        #else:  # Python 2\n        #    import unicodecsv as csv\n        #    f = open(self._fstor.syspath, 'rbU')\n        #    reader = csv.reader(f, encoding=encoding)\n\n        for row in csv.reader(f):\n            row = [e if e.strip() != '' else None for e in row]\n            if any(bool(e) for e in row):\n                rows.append(row)\n        try:\n            fr.update_contents(msgpack.packb(rows), 'application/msgpack')\n        except AssertionError:\n            raise\n\n        fr.source_hash = self.fs_hash\n        fr.synced_fs = self.fs_modtime\n        fr.modified = self.fs_modtime"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a filesystem file from a File", "response": "def record_to_fs(self):\n        \"\"\"Create a filesystem file from a File\"\"\"\n\n        fr = self.record\n\n        fn_path = self.file_name\n\n        if fr.contents:\n            if six.PY2:\n                with self._fs.open(fn_path, 'wb') as f:\n                    self.record_to_fh(f)\n            else:\n                # py3\n                with self._fs.open(fn_path, 'w', newline='') as f:\n                    self.record_to_fh(f)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites the record in filesystem format to a file handle or file object", "response": "def record_to_fh(self, f):\n        \"\"\"Write the record, in filesystem format, to a file handle or file object\"\"\"\n\n        fr = self.record\n\n        if fr.contents:\n            yaml.safe_dump(fr.unpacked_contents, f, default_flow_style=False, encoding='utf-8')\n            fr.source_hash = self.fs_hash\n            fr.modified = self.fs_modtime"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fh_to_record(self, f):\n\n        fn_path = self.file_name\n        fr = self.record\n        fr.path = fn_path\n\n        fr.update_contents(f.read(), 'text/plain')\n\n        fr.source_hash = self.fs_hash\n        fr.synced_fs = self.fs_modtime\n        fr.modified = self.fs_modtime", "response": "Load a file in the filesystem into a file record"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating config records to match the file metadata", "response": "def record_to_objects(self):\n        \"\"\"Create config records to match the file metadata\"\"\"\n        from ..util import AttrDict\n\n        fr = self.record\n\n        contents = fr.unpacked_contents\n\n        if not contents:\n            return\n\n        ad = AttrDict(contents)\n\n\n        # Get time that filessystem was synchronized to the File record.\n        # Maybe use this to avoid overwriting configs that changed by bundle program.\n        # fs_sync_time = self._dataset.config.sync[self.file_const][self.file_to_record]\n\n        self._dataset.config.metadata.set(ad)\n\n        self._dataset._database.commit()\n\n        return ad"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite from object metadata to the record.", "response": "def objects_to_record(self):\n        \"\"\"Write from object metadata to the record. Note that we don't write everything\"\"\"\n\n        o = self.get_object()\n\n        o.about = self._bundle.metadata.about\n        o.identity = self._dataset.identity.ident_dict\n        o.names = self._dataset.identity.names_dict\n        o.contacts = self._bundle.metadata.contacts\n\n        self.set_object(o)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the identity and names to match the dataset id and version", "response": "def update_identity(self):\n        \"\"\"Update the identity and names to match the dataset id and version\"\"\"\n\n        fr = self.record\n\n        d = fr.unpacked_contents\n\n        d['identity'] = self._dataset.identity.ident_dict\n        d['names'] = self._dataset.identity.names_dict\n\n        fr.update_contents(msgpack.packb(d), 'application/msgpack')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning contents in object form an AttrDict", "response": "def get_object(self):\n        \"\"\"Return contents in object form, an AttrDict\"\"\"\n\n        from ..util import AttrDict\n\n        c = self.record.unpacked_contents\n\n        if not c:\n            c = yaml.safe_load(self.default)\n\n        return AttrDict(c)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert the notebook to a python script and execute it returning the local context as a dict", "response": "def execute(self):\n        \"\"\"Convert the notebook to a python script and execute it, returning the local context\n        as a dict\"\"\"\n\n        from nbformat import read\n        from nbconvert.exporters import export_script\n        from cStringIO import StringIO\n\n        notebook = read(StringIO(self.record.unpacked_contents), 4)\n\n        script, resources = export_script(notebook)\n\n        env_dict = {}\n\n        exec (compile(script.replace('# coding: utf-8', ''), 'script', 'exec'), env_dict)\n\n        return env_dict"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a filesystem file from a File", "response": "def record_to_fs(self):\n        \"\"\"Create a filesystem file from a File\"\"\"\n\n        fr = self.record\n\n        if fr.contents:\n            with self._fs.open(self.file_name, 'w', encoding='utf-8') as f:\n                self.record_to_fh(f)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_module(self, module_path = 'ambry.build', **kwargs):\n        from fs.errors import NoSysPathError\n\n        if module_path in sys.modules:\n            module = sys.modules[module_path]\n        else:\n            module = imp.new_module(module_path)\n            sys.modules[module_path] = module\n\n        bf = self.record\n\n        if not bf.contents:\n            return module\n\n        module.__dict__.update(**kwargs)\n\n        try:\n            abs_path = self._fs.getsyspath(self.file_name)\n        except NoSysPathError:\n            abs_path = '<string>'\n\n        import re\n\n        if re.search(r'-\\*-\\s+coding:', bf.contents):\n            # Has encoding, so don't decode\n            contents = bf.contents\n        else:\n            contents = bf.unpacked_contents  # Assumes utf-8\n\n        exec(compile(contents, abs_path, 'exec'), module.__dict__)\n\n        return module", "response": "Imports the contents of the file into the ambry. build module."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nimports the bundle from the file as Python", "response": "def import_bundle(self):\n        \"\"\"Add the filesystem to the Python sys path with an import hook, then import\n        to file as Python\"\"\"\n        from fs.errors import NoSysPathError\n\n        try:\n            import ambry.build\n            module = sys.modules['ambry.build']\n        except ImportError:\n            module = imp.new_module('ambry.build')\n            sys.modules['ambry.build'] = module\n\n        bf = self.record\n\n        if not bf.has_contents:\n            from ambry.bundle import Bundle\n            return Bundle\n\n        try:\n            abs_path = self._fs.getsyspath(self.file_name)\n        except NoSysPathError:\n            abs_path = '<string>'\n\n        exec(compile(bf.contents, abs_path, 'exec'), module.__dict__)\n\n        return module.Bundle"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef import_lib(self):\n\n        try:\n            import ambry.build\n            module = sys.modules['ambry.build']\n        except ImportError:\n            module = imp.new_module('ambry.build')\n            sys.modules['ambry.build'] = module\n\n        bf = self.record\n\n        if not bf.has_contents:\n            return\n\n        try:\n            exec (compile(bf.contents, self.path, 'exec'), module.__dict__)\n\n        except Exception:\n            self._bundle.error(\"Failed to load code from {}\".format(self.path))\n            raise\n\n        # print(self.file_const, bundle.__dict__.keys())\n        # print(bf.contents)\n\n        return module", "response": "Import the lib. py file into the bundle module"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates config records to match the file metadata.", "response": "def record_to_objects(self):\n        \"\"\"Create config records to match the file metadata\"\"\"\n        from ambry.orm.exc import NotFoundError\n\n        fr = self.record\n\n        contents = fr.unpacked_contents\n\n        if not contents:\n            return\n\n        # Zip transposes an array when in the form of a list of lists, so this transposes so\n        # each row starts with the heading and the rest of the row are the values\n        # for that row. The bool and filter return false when none of the values\n        # are non-empty. Then zip again to transpose to original form.\n\n        non_empty_rows = drop_empty(contents)\n\n        s = self._dataset._database.session\n\n        for i, row in enumerate(non_empty_rows):\n\n            if i == 0:\n                header = row\n            else:\n                d = dict(six.moves.zip(header, row))\n\n                if 'widths' in d:\n                    del d['widths']  # Obsolete column in old spreadsheets.\n\n                if 'table' in d:\n                    d['dest_table_name'] = d['table']\n                    del d['table']\n\n                if 'order' in d:\n                    d['stage'] = d['order']\n                    del d['order']\n\n                if 'dest_table' in d:\n                    d['dest_table_name'] = d['dest_table']\n                    del d['dest_table']\n\n                if 'source_table' in d:\n                    d['source_table_name'] = d['source_table']\n                    del d['source_table']\n\n                d['d_vid'] = self._dataset.vid\n\n                d['state'] = 'synced'\n\n                try:\n                    ds = self._dataset.source_file(str(d['name']))\n                    ds.update(**d)\n                except NotFoundError:\n                    name = d['name']\n                    del d['name']\n\n                    try:\n                        ds = self._dataset.new_source(name, **d)\n                    except:\n                        print(name, d)\n                        import pprint\n                        pprint.pprint(d)\n                        raise\n                except:  # Odd error with 'none' in keys for d\n                    print('!!!', header)\n                    print('!!!', row)\n                    raise\n\n                s.merge(ds)\n\n        self._dataset._database.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate config records to match the file metadata", "response": "def record_to_objects(self):\n        \"\"\"Create config records to match the file metadata\"\"\"\n        from ambry.orm import Column, Table, Dataset\n\n        def _clean_int(i):\n            if i is None:\n                return None\n            elif isinstance(i, int):\n                return i\n            elif isinstance(i, string_types):\n                if len(i) == 0:\n                    return None\n\n                return int(i.strip())\n\n        bsfile = self.record\n\n        contents = bsfile.unpacked_contents\n\n        if not contents:\n            return\n\n        line_no = 1  # Accounts for file header. Data starts on line 2\n\n        errors = []\n        warnings = []\n\n        extant_tables = {t.name: t for t in self._dataset.tables}\n\n        old_types_map = {\n            'varchar': Column.DATATYPE_STR,\n            'integer': Column.DATATYPE_INTEGER,\n            'real': Column.DATATYPE_FLOAT,\n        }\n\n        def run_progress_f(line_no):\n            self._bundle.log('Loading tables from file. Line #{}'.format(line_no))\n\n        from ambry.bundle.process import CallInterval\n        run_progress_f = CallInterval(run_progress_f, 10)\n\n        table_number = self._dataset._database.next_sequence_id(Dataset, self._dataset.vid, Table)\n        for row in bsfile.dict_row_reader:\n\n            line_no += 1\n\n            run_progress_f(line_no)\n\n            # Skip blank lines\n            if not row.get('column', False) and not row.get('table', False):\n                continue\n\n            if not row.get('column', False):\n                raise ConfigurationError('Row error: no column on line {}'.format(line_no))\n\n            if not row.get('table', False):\n                raise ConfigurationError('Row error: no table on line {}'.format(line_no))\n\n            if not row.get('datatype', False) and not row.get('valuetype', False):\n                raise ConfigurationError('Row error: no type on line {}'.format(line_no))\n\n            value_type = row.get('valuetype', '').strip() if row.get('valuetype', False) else None\n            data_type = row.get('datatype', '').strip() if row.get('datatype', False) else None\n\n            def resolve_data_type(value_type):\n                from ambry.valuetype import resolve_value_type\n                vt_class = resolve_value_type(value_type)\n\n                if not vt_class:\n                    raise ConfigurationError(\"Row error: unknown valuetype '{}'\".format(value_type))\n\n                return vt_class.python_type().__name__\n\n            # If we have a value type field, and not the datatype,\n            # the value type is as specified, and the data type is derived from it.\n            if value_type and not data_type:\n                data_type = resolve_data_type(value_type)\n\n            elif data_type and not value_type:\n                value_type = data_type\n                data_type = resolve_data_type(value_type)\n\n            # There are still some old data types hanging around\n            data_type = old_types_map.get(data_type.lower(), data_type)\n\n            table_name = row['table']\n\n            try:\n                table = extant_tables[table_name]\n            except KeyError:\n                table = self._dataset.new_table(\n                    table_name,\n                    sequence_id=table_number,\n                    description=row.get('description') if row['column'] == 'id' else ''\n                )\n\n                table_number += 1\n                extant_tables[table_name] = table\n\n            data = {k.replace('d_', '', 1): v\n                    for k, v in list(row.items()) if k and k.startswith('d_') and v}\n\n            if row['column'] == 'id':\n                table.data.update(data)\n                data = {}\n\n            table.add_column(\n                row['column'],\n                fk_vid=row['is_fk'] if row.get('is_fk', False) else None,\n                description=(row.get('description', '') or '').strip(),\n                datatype=data_type,\n                valuetype=value_type,\n                parent=row.get('parent'),\n                proto_vid=row.get('proto_vid'),\n                size=_clean_int(row.get('size', None)),\n                width=_clean_int(row.get('width', None)),\n                data=data,\n                keywords=row.get('keywords'),\n                measure=row.get('measure'),\n                transform=row.get('transform'),\n                derivedfrom=row.get('derivedfrom'),\n                units=row.get('units', None),\n                universe=row.get('universe'),\n                update_existing= True)\n\n        self._dataset.t_sequence_id = table_number\n\n        return warnings, errors"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite from the stored file data to the source records", "response": "def record_to_objects(self):\n        \"\"\"Write from the stored file data to the source records\"\"\"\n        from ambry.orm import SourceTable\n\n        bsfile = self.record\n\n        failures = set()\n\n        # Clear out all of the columns from existing tables. We don't clear out the\n        # tables, since they may be referenced by sources\n\n        for row in bsfile.dict_row_reader:\n            st = self._dataset.source_table(row['table'])\n\n            if st:\n                st.columns[:] = []\n\n        self._dataset.commit()\n\n        for row in bsfile.dict_row_reader:\n            st = self._dataset.source_table(row['table'])\n\n            if not st:\n                st = self._dataset.new_source_table(row['table'])\n                # table_number += 1\n\n            if 'datatype' not in row:\n                row['datatype'] = 'unknown'\n\n            del row['table']\n\n            st.add_column(**row)  # Create or update\n\n        if failures:\n            raise ConfigurationError('Failed to load source schema, missing sources: {} '.format(failures))\n\n        self._dataset.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute all sql statements from bundle. sql.", "response": "def execute(self):\n        \"\"\" Executes all sql statements from bundle.sql. \"\"\"\n        from ambry.mprlib import execute_sql\n\n        execute_sql(self._bundle.library, self.record_content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_records(self, file_const=None):\n        for r in self._dataset.files:\n            if file_const and r.minor_type != file_const:\n                continue\n            yield self.instance_from_name(r.path)", "response": "Iterate through the file records"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef record_to_objects(self, preference=None):\n        from ambry.orm.file import File\n\n        for f in self.list_records():\n\n            pref = preference if preference else f.record.preference\n\n            if pref == File.PREFERENCE.FILE:\n                self._bundle.logger.debug('   Cleaning objects for file {}'.format(f.path))\n                f.clean_objects()\n\n            if pref in (File.PREFERENCE.FILE, File.PREFERENCE.MERGE):\n                self._bundle.logger.debug('   rto {}'.format(f.path))\n                f.record_to_objects()", "response": "Create objects from files or merge the files into the objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating file records from objects.", "response": "def objects_to_record(self, preference=None):\n        \"\"\"Create file records from objects. \"\"\"\n        from ambry.orm.file import File\n\n        raise NotImplementedError(\"Still uses obsolete file_info_map\")\n        for file_const, (file_name, clz) in iteritems(file_info_map):\n            f = self.file(file_const)\n\n            pref = preference if preference else f.record.preference\n\n            if pref in (File.PREFERENCE.MERGE, File.PREFERENCE.OBJECT):\n                self._bundle.logger.debug('   otr {}'.format(file_const))\n                f.objects_to_record()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd default content to any file record that is empty", "response": "def set_defaults(self):\n        \"\"\"Add default content to any file record that is empty\"\"\"\n\n        for const_name, c in file_classes.items():\n            if c.multiplicity == '1':\n                f = self.file(const_name)\n                if not f.record.unpacked_contents:\n                    f.setcontent(f.default)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a private key and a certificate and write them to a file.", "response": "def main(args=None):\n    \"\"\"\n    Create a private key and a certificate and write them to a file.\n    \"\"\"\n    if args is None:\n        args = sys.argv[1:]\n\n    o = Options()\n    try:\n        o.parseOptions(args)\n    except usage.UsageError, e:\n        raise SystemExit(str(e))\n    else:\n        return createSSLCertificate(o)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, f):\n\n        for p in self.__mapper__.attrs:\n\n            if p.key == 'oid':\n                continue\n            try:\n                setattr(self, p.key, getattr(f, p.key))\n\n            except AttributeError:\n                # The dict() method copies data property values into the main dict,\n                # and these don't have associated class properties.\n                continue", "response": "Copy another files properties into this one."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresets the timeout count down", "response": "def resetTimeout(self):\n        \"\"\"Reset the timeout count down\"\"\"\n        if self.__timeoutCall is not None and self.timeOut is not None:\n            self.__timeoutCall.reset(self.timeOut)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nchange the timeout period", "response": "def setTimeout(self, period):\n        \"\"\"Change the timeout period\n\n        @type period: C{int} or C{NoneType}\n        @param period: The period, in seconds, to change the timeout to, or\n        C{None} to disable the timeout.\n        \"\"\"\n        prev = self.timeOut\n        self.timeOut = period\n\n        if self.__timeoutCall is not None:\n            if period is None:\n                self.__timeoutCall.cancel()\n                self.__timeoutCall = None\n            else:\n                self.__timeoutCall.reset(period)\n        elif period is not None:\n            self.__timeoutCall = self.callLater(period, self.__timedOut)\n\n        return prev"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads all controllers from folder controllers.", "response": "def _load_controllers(self):\n        \"\"\"\n        Load all controllers from folder 'controllers'.\n\n        Ignore files with leading underscore (for example: controllers/_blogs.py)\n        \"\"\"\n        for file_name in os.listdir(os.path.join(self._project_dir, 'controllers')):\n            # ignore disabled controllers\n            if not file_name.startswith('_'):\n                module_name = file_name.split('.', 1)[0]\n                module_path = \"controllers.{}\".format(module_name)\n                module = import_module(module_path)\n                # transform 'blog_articles' file name to 'BlogArticles' class\n                controller_class_name = module_name.title().replace('_', '')\n                controller_class = getattr(module, controller_class_name)\n                controller = controller_class()\n                for action_name in dir(controller):\n                    action = getattr(controller, action_name)\n                    if action_name.startswith('_') or not callable(action):\n                        continue\n                    url_path = \"/\".join([module_name, action_name])\n                    self._controllers[url_path] = action\n        return self._controllers"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_view(self):\n        views_engine = get_config('rails.views.engine', 'jinja')\n        templates_dir = os.path.join(self._project_dir, \"views\", \"templates\")\n        self._view = View(views_engine, templates_dir)", "response": "Initialize View with project settings."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_action_handler(self, controller_name, action_name):\n        try_actions = [\n            controller_name + '/' + action_name,\n            controller_name + '/not_found',\n            # call Index controller to catch all unhandled pages\n            'index/not_found'\n        ]\n        # search first appropriate action handler\n        for path in try_actions:\n            if path in self._controllers:\n                return self._controllers[path]\n        return None", "response": "Return action handler of requested controller or Index controller."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstarting a server:: ./manage.py flup:start [--daemonize]", "response": "def command_start(self, daemonize=False):\n        '''\n        Start a server::\n\n            ./manage.py flup:start [--daemonize]\n        '''\n        if daemonize:\n            safe_makedirs(self.logfile, self.pidfile)\n        flup_fastcgi(self.app, bind=self.bind, pidfile=self.pidfile,\n                     logfile=self.logfile, daemonize=daemonize,\n                     cwd=self.cwd, umask=self.umask, **self.fastcgi_params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef command_stop(self):\n        '''\n        Stop a server::\n\n            ./manage.py flup:stop\n        '''\n        if self.pidfile:\n            if not os.path.exists(self.pidfile):\n                sys.exit(\"Pidfile {!r} doesn't exist\".format(self.pidfile))\n            with open(self.pidfile) as pidfile:\n                pid = int(pidfile.read())\n            for sig in [signal.SIGINT, signal.SIGTERM, signal.SIGKILL]:\n                try:\n                    if terminate(pid, sig, 3):\n                        os.remove(self.pidfile)\n                        # NOTE: we are not performing sys.exit here,\n                        # otherwise restart command will not work\n                        return\n                except OSError as exc:\n                    if exc.errno != errno.ESRCH:\n                        raise\n                    elif sig == signal.SIGINT:\n                        sys.exit('Not running')\n        sys.exit('No pidfile provided')", "response": "Stop a server::\n\n            ./manage.py flup:stop"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _preprocess_sqlite_view(asql_query, library, backend, connection):\n\n    new_query = None\n\n    if 'create materialized view' in asql_query.lower() or 'create view' in asql_query.lower():\n\n        logger.debug(\n            '_preprocess_sqlite_view: materialized view found.\\n    asql query: {}'\n            .format(asql_query))\n\n        view = parse_view(asql_query)\n\n        tablename = view.name.replace('-', '_').lower().replace('.', '_')\n        create_query_columns = {}\n        for column in view.columns:\n            create_query_columns[column.name] = column.alias\n\n        ref_to_partition_map = {}  # key is ref found in the query, value is Partition instance.\n        alias_to_partition_map = {}  # key is alias of ref found in the query, value is Partition instance.\n\n        # collect sources from select statement of the view.\n        for source in view.sources:\n            partition = library.partition(source.name)\n            ref_to_partition_map[source.name] = partition\n            if source.alias:\n                alias_to_partition_map[source.alias] = partition\n\n        # collect sources from joins of the view.\n        for join in view.joins:\n            partition = library.partition(join.source.name)\n            ref_to_partition_map[join.source.name] = partition\n            if join.source.alias:\n                alias_to_partition_map[join.source.alias] = partition\n\n        # collect and convert columns.\n        TYPE_MAP = {\n            'int': 'INTEGER',\n            'float': 'REAL',\n            six.binary_type.__name__: 'TEXT',\n            six.text_type.__name__: 'TEXT',\n            'date': 'DATE',\n            'datetime': 'TIMESTAMP WITHOUT TIME ZONE'\n        }\n        column_types = []\n        column_names = []\n        for column in view.columns:\n            if '.' in column.name:\n                source_alias, column_name = column.name.split('.')\n            else:\n                # TODO: Test that case.\n                source_alias = None\n                column_name = column.name\n\n            # find column specification in the mpr file.\n            if source_alias:\n                partition = alias_to_partition_map[source_alias]\n                for part_column in partition.datafile.reader.columns:\n                    if part_column['name'] == column_name:\n                        sqlite_type = TYPE_MAP.get(part_column['type'])\n                        if not sqlite_type:\n                            raise Exception(\n                                'Do not know how to convert {} to sql column.'\n                                .format(column['type']))\n\n                        column_types.append(\n                            '    {} {}'\n                            .format(column.alias if column.alias else column.name, sqlite_type))\n                        column_names.append(column.alias if column.alias else column.name)\n\n        column_types_str = ',\\n'.join(column_types)\n        column_names_str = ', '.join(column_names)\n\n        create_query = 'CREATE TABLE IF NOT EXISTS {}(\\n{});'.format(tablename, column_types_str)\n\n        # drop 'create materialized view' part\n        _, select_part = asql_query.split(view.name)\n        select_part = select_part.strip()\n        assert select_part.lower().startswith('as')\n\n        # drop 'as' keyword\n        select_part = select_part.strip()[2:].strip()\n        assert select_part.lower().strip().startswith('select')\n\n        # Create query to copy data from mpr to just created table.\n        copy_query = 'INSERT INTO {table}(\\n{columns})\\n  {select}'.format(\n            table=tablename, columns=column_names_str, select=select_part)\n        if not copy_query.strip().lower().endswith(';'):\n            copy_query = copy_query + ';'\n        new_query = '{}\\n\\n{}'.format(create_query, copy_query)\n    logger.debug(\n        '_preprocess_sqlite_view: preprocess finished.\\n    asql query: {}\\n\\n    new query: {}'\n        .format(asql_query, new_query))\n\n\n    return new_query or asql_query", "response": "Given an SQL query and a library and a connection returns a virtual table that is used to create the tables and inserts the rows."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates materialized view for each indexed partition found in the query. Args: asql_query (str): asql query library (ambry.Library): backend (SQLiteBackend): connection (apsw.Connection): Returns: str: converted asql if it contains index query. If not, returns asql_query as is.", "response": "def _preprocess_sqlite_index(asql_query, library, backend, connection):\n    \"\"\" Creates materialized view for each indexed partition found in the query.\n\n    Args:\n        asql_query (str): asql query\n        library (ambry.Library):\n        backend (SQLiteBackend):\n        connection (apsw.Connection):\n\n    Returns:\n        str: converted asql if it contains index query. If not, returns asql_query as is.\n    \"\"\"\n\n    new_query = None\n\n    if asql_query.strip().lower().startswith('index'):\n\n        logger.debug(\n            '_preprocess_index: create index query found.\\n    asql query: {}'\n            .format(asql_query))\n\n        index = parse_index(asql_query)\n        partition = library.partition(index.source)\n        table = backend.install(connection, partition, materialize=True)\n        index_name = '{}_{}_ind'.format(partition.vid, '_'.join(index.columns))\n        new_query = 'CREATE INDEX IF NOT EXISTS {index} ON {table} ({columns});'.format(\n            index=index_name, table=table, columns=','.join(index.columns))\n\n    logger.debug(\n        '_preprocess_index: preprocess finished.\\n    asql query: {}\\n    new query: {}'\n        .format(asql_query, new_query))\n\n    return new_query or asql_query"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninstalls the given partition into the virtual table or creates a read - only table.", "response": "def install(self, connection, partition, table_name = None, index_columns=None, materialize=False,\n                logger = None):\n        \"\"\" Creates virtual table or read-only table for gion.\n\n        Args:\n            ref (str): id, vid, name or versioned name of the partition.\n            materialize (boolean): if True, create read-only table. If False create virtual table.\n\n        Returns:\n            str: name of the created table.\n\n        \"\"\"\n        virtual_table = partition.vid\n\n        table = partition.vid if not table_name else table_name\n\n        if self._relation_exists(connection, table):\n            if logger:\n                logger.debug(\"Skipping '{}'; already installed\".format(table))\n            return\n        else:\n            if logger:\n                logger.info(\"Installing '{}'\".format(table))\n\n        partition.localize()\n\n\n        virtual_table = partition.vid + '_vt'\n\n        self._add_partition(connection, partition)\n\n        if materialize:\n\n            if self._relation_exists(connection, table):\n                debug_logger.debug(\n                    'Materialized table of the partition already exists.\\n partition: {}, table: {}'\n                    .format(partition.name, table))\n            else:\n                cursor = connection.cursor()\n\n                # create table\n                create_query = self.__class__._get_create_query(partition, table)\n                debug_logger.debug(\n                    'Creating new materialized view for partition mpr.'\n                    '\\n    partition: {}, view: {}, query: {}'\n                    .format(partition.name, table, create_query))\n\n                cursor.execute(create_query)\n\n                # populate just created table with data from virtual table.\n                copy_query = '''INSERT INTO {} SELECT * FROM {};'''.format(table, virtual_table)\n                debug_logger.debug(\n                    'Populating sqlite table with rows from partition mpr.'\n                    '\\n    partition: {}, view: {}, query: {}'\n                    .format(partition.name, table, copy_query))\n                cursor.execute(copy_query)\n\n                cursor.close()\n\n        else:\n            cursor = connection.cursor()\n            view_q = \"CREATE VIEW IF NOT EXISTS {} AS SELECT * FROM {} \".format(partition.vid, virtual_table)\n            cursor.execute(view_q)\n            cursor.close()\n\n        if index_columns is not None:\n            self.index(connection,table, index_columns)\n\n        return table"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating an index on the columns.", "response": "def index(self, connection, partition, columns):\n        \"\"\" Create an index on the columns.\n\n        Args:\n            connection (apsw.Connection): connection to sqlite database who stores mpr table or view.\n            partition (orm.Partition):\n            columns (list of str):\n        \"\"\"\n\n        import hashlib\n\n        query_tmpl = '''\n            CREATE INDEX IF NOT EXISTS {index_name} ON {table_name} ({columns});\n        '''\n\n        if not isinstance(columns,(list,tuple)):\n            columns = [columns]\n\n        col_list = ','.join('\"{}\"'.format(col) for col in columns)\n\n        col_hash = hashlib.md5(col_list).hexdigest()\n\n        try:\n            table_name = partition.vid\n        except AttributeError:\n            table_name = partition # Its really a table name\n\n        query = query_tmpl.format(\n            index_name='{}_{}_i'.format(table_name, col_hash), table_name=table_name,\n            columns=col_list)\n\n        logger.debug('Creating sqlite index: query: {}'.format(query))\n        cursor = connection.cursor()\n\n        cursor.execute(query)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncloses connection to sqlite database.", "response": "def close(self):\n        \"\"\" Closes connection to sqlite database. \"\"\"\n        if getattr(self, '_connection', None):\n            logger.debug('Closing sqlite connection.')\n            self._connection.close()\n            self._connection = None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_mpr_view(self, connection, table):\n        logger.debug(\n            'Looking for view of the table.\\n    table: {}'.format(table.vid))\n        view = self.get_view_name(table)\n        view_exists = self._relation_exists(connection, view)\n        if view_exists:\n            logger.debug(\n                'View of the table exists.\\n    table: {}, view: {}'\n                .format(table.vid, view))\n            return view\n        raise MissingViewError('sqlite database does not have view for {} table.'\n                               .format(table.vid))", "response": "Finds and returns the view name in the sqlite db represented by given connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the name of the sqlite table who stores mpr data.", "response": "def _get_mpr_table(self, connection, partition):\n        \"\"\" Returns name of the sqlite table who stores mpr data.\n\n        Args:\n            connection (apsw.Connection): connection to sqlite database who stores mpr data.\n            partition (orm.Partition):\n\n        Returns:\n            str:\n\n        Raises:\n            MissingTableError: if partition table not found in the db.\n\n        \"\"\"\n        # TODO: This is the first candidate for optimization. Add field to partition\n        # with table name and update it while table creation.\n        # Optimized version.\n        #\n        # return partition.mpr_table or raise exception\n\n        # Not optimized version.\n        #\n        # first check either partition has readonly table.\n        virtual_table = partition.vid\n        table = '{}_v'.format(virtual_table)\n        logger.debug(\n            'Looking for materialized table of the partition.\\n    partition: {}'.format(partition.name))\n        table_exists = self._relation_exists(connection, table)\n        if table_exists:\n            logger.debug(\n                'Materialized table of the partition found.\\n    partition: {}, table: {}'\n                .format(partition.name, table))\n            return table\n\n        # now check for virtual table\n        logger.debug(\n            'Looking for a virtual table of the partition.\\n    partition: {}'.format(partition.name))\n        virtual_exists = self._relation_exists(connection, virtual_table)\n        if virtual_exists:\n            logger.debug(\n                'Virtual table of the partition found.\\n    partition: {}, table: {}'\n                .format(partition.name, table))\n            return virtual_table\n        raise MissingTableError('sqlite database does not have table for mpr of {} partition.'\n                                .format(partition.vid))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if the relation exists in the sqlite db otherwise returns False.", "response": "def _relation_exists(self, connection, relation):\n        \"\"\" Returns True if relation (table or view) exists in the sqlite db. Otherwise returns False.\n\n        Args:\n            connection (apsw.Connection): connection to sqlite database who stores mpr data.\n            partition (orm.Partition):\n\n        Returns:\n            boolean: True if relation exists, False otherwise.\n\n        \"\"\"\n        query = 'SELECT 1 FROM sqlite_master WHERE (type=\\'table\\' OR type=\\'view\\') AND name=?;'\n        cursor = connection.cursor()\n        cursor.execute(query, [relation])\n        result = cursor.fetchall()\n        return result == [(1,)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating and returns a CREATE TABLE... sql statement for given mprows.", "response": "def _get_create_query(partition, tablename, include=None):\n        \"\"\" Creates and returns `CREATE TABLE ...` sql statement for given mprows.\n\n        Args:\n            partition (orm.Partition):\n            tablename (str): name of the table in the return create query.\n            include (list of str, optional): list of columns to include to query.\n\n        Returns:\n            str: create table query.\n\n        \"\"\"\n        TYPE_MAP = {\n            'int': 'INTEGER',\n            'float': 'REAL',\n            six.binary_type.__name__: 'TEXT',\n            six.text_type.__name__: 'TEXT',\n            'date': 'DATE',\n            'datetime': 'TIMESTAMP WITHOUT TIME ZONE'\n        }\n        columns_types = []\n        if not include:\n            include = []\n        for column in sorted(partition.datafile.reader.columns, key=lambda x: x['pos']):\n            if include and column['name'] not in include:\n                continue\n            sqlite_type = TYPE_MAP.get(column['type'])\n            if not sqlite_type:\n                raise Exception('Do not know how to convert {} to sql column.'.format(column['type']))\n            columns_types.append('    \"{}\" {}'.format(column['name'], sqlite_type))\n        columns_types_str = ',\\n'.join(columns_types)\n        query = 'CREATE TABLE IF NOT EXISTS {}(\\n{})'.format(tablename, columns_types_str)\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a connection to sqlite db.", "response": "def _get_connection(self):\n        \"\"\" Returns connection to sqlite db.\n\n        Returns:\n            connection to the sqlite db who stores mpr data.\n\n        \"\"\"\n        if getattr(self, '_connection', None):\n            logger.debug('Connection to sqlite db already exists. Using existing one.')\n        else:\n            dsn = self._dsn\n            if dsn == 'sqlite://':\n                dsn = ':memory:'\n            else:\n                dsn = dsn.replace('sqlite:///', '')\n\n            logger.debug(\n                'Creating new apsw connection.\\n   dsn: {}, config_dsn: {}'\n                .format(dsn, self._dsn))\n            self._connection = apsw.Connection(dsn)\n\n        return self._connection"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a partition to the sqlite virtual table.", "response": "def _add_partition(self, connection, partition):\n        \"\"\" Creates sqlite virtual table for mpr file of the given partition.\n\n        Args:\n            connection: connection to the sqlite db who stores mpr data.\n            partition (orm.Partition):\n\n        \"\"\"\n        logger.debug('Creating virtual table for partition.\\n    partition: {}'.format(partition.name))\n        sqlite_med.add_partition(connection, partition.datafile, partition.vid+'_vt')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _execute(self, connection, query, fetch=True):\n        cursor = connection.cursor()\n\n        try:\n            cursor.execute(query)\n        except Exception as e:\n            from ambry.mprlib.exceptions import BadSQLError\n            raise BadSQLError(\"Failed to execute query: {}; {}\".format(query, e))\n\n        if fetch:\n            return cursor.fetchall()\n        else:\n            return cursor", "response": "Executes given query using given connection."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _log_disconnect(self):\n        if self.logged:\n            self.server.stats.connectionClosed()\n            self.logged = False", "response": "Log a disconnect event."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef enable_cache(self):\n        self.set_header('Cache-Control', 'max-age=%d, public' % self.CACHE_TIME)\n\n        now = datetime.datetime.now()\n        expires = now + datetime.timedelta(seconds=self.CACHE_TIME)\n        self.set_header('Expires', expires.strftime('%a, %d %b %Y %H:%M:%S'))\n\n        self.set_header('access-control-max-age', self.CACHE_TIME)", "response": "Enable client - side caching for the current request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_milestone(id, **kwargs):\n    data = update_milestone_raw(id, **kwargs)\n    if data:\n        return utils.format_json(data)", "response": "Update a ProductMilestone with the given id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclose a specific resource in a cluster.", "response": "def close_milestone(id, **kwargs):\n    \"\"\"\n    Close a milestone. This triggers its release process.\n\n    The user can optionally specify the release-date, otherwise today's date is\n    used.\n\n    If the wait parameter is specified and set to True, upon closing the milestone,\n    we'll periodically check that the release being processed is done.\n\n    Required:\n    - id: int\n\n    Optional:\n    - wait key: bool\n    \"\"\"\n    data = close_milestone_raw(id, **kwargs)\n    if data:\n        return utils.format_json(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_app(self, app):\n        app.config.setdefault('FLASK_AUTH_ALL', False)\n        app.config.setdefault('FLASK_AUTH_REALM', 'Login Required')\n        # Default set to bad file to trigger IOError\n        app.config.setdefault('FLASK_HTPASSWD_PATH', '/^^^/^^^')\n\n        # Load up user database\n        try:\n            self.load_users(app)\n        except IOError:\n            log.critical(\n                'No htpasswd file loaded, please set `FLASK_HTPASSWD`'\n                'or `FLASK_HTPASSWD_PATH` environment variable to a '\n                'valid apache htpasswd file.'\n            )\n\n        # Allow requiring auth for entire app, with pre request method\n        @app.before_request\n        def require_auth():  # pylint: disable=unused-variable\n            \"\"\"Pre request processing for enabling full app authentication.\"\"\"\n            if not current_app.config['FLASK_AUTH_ALL']:\n                return\n            is_valid, user = self.authenticate()\n            if not is_valid:\n                return self.auth_failed()\n            g.user = user", "response": "Initialize the application with the user database."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_basic_auth(self, username, password):\n        valid = self.users.check_password(\n            username, password\n        )\n        if not valid:\n            log.warning('Invalid login from %s', username)\n            valid = False\n        return (\n            valid,\n            username\n        )", "response": "Checks if a username and password combination is valid via the htpasswd file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_hashhash(self, username):\n        return hashlib.sha256(\n            self.users.get_hash(username)\n        ).hexdigest()", "response": "Generate a hash of the htpasswd hash"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_token(self, username):\n        serializer = self.get_signature()\n        return serializer.dumps(\n            {\n                'username': username,\n                'hashhash': self.get_hashhash(username)\n            }\n        ).decode('UTF-8')", "response": "Generate a token for the given user"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_token_auth(self, token):\n        serializer = self.get_signature()\n\n        try:\n            data = serializer.loads(token)\n        except BadSignature:\n            log.warning('Received bad token signature')\n            return False, None\n        if data['username'] not in self.users.users():\n            log.warning(\n                'Token auth signed message, but invalid user %s',\n                data['username']\n            )\n            return False, None\n        if data['hashhash'] != self.get_hashhash(data['username']):\n            log.warning(\n                'Token and password do not match, %s '\n                'needs to regenerate token',\n                data['username']\n            )\n            return False, None\n        return True, data['username']", "response": "Check to see if the token is valid and if they are then regenerate the token."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef authenticate(self):\n        basic_auth = request.authorization\n        is_valid = False\n        user = None\n        if basic_auth:\n            is_valid, user = self.check_basic_auth(\n                basic_auth.username, basic_auth.password\n            )\n        else:  # Try token auth\n            token = request.headers.get('Authorization', None)\n            param_token = request.args.get('access_token')\n            if token or param_token:\n                if token:\n                    # slice the 'token ' piece of the header (following\n                    # github style):\n                    token = token[6:]\n                else:\n                    # Grab it from query dict instead\n                    token = param_token\n                log.debug('Received token: %s', token)\n\n                is_valid, user = self.check_token_auth(token)\n        return (is_valid, user)", "response": "Authenticate user by any means and return either True or False."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef required(self, func):\n        @wraps(func)\n        def decorated(*args, **kwargs):\n            \"\"\"\n            Actual wrapper to run the auth checks.\n            \"\"\"\n            is_valid, user = self.authenticate()\n            if not is_valid:\n                return self.auth_failed()\n            kwargs['user'] = user\n            return func(*args, **kwargs)\n        return decorated", "response": "Decorator to run the auth checks on the resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the identity as a dict.", "response": "def _dict(self, with_name=True):\n        \"\"\"Returns the identity as a dict.\n\n        values that are empty are removed\n\n        \"\"\"\n\n        d = dict([(k, getattr(self, k)) for k, _, _ in self.name_parts])\n\n        if with_name:\n            d['name'] = self.name\n            try:\n                d['vname'] = self.vname\n            except ValueError:\n                pass\n\n        return self.clear_dict(d)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef source_path(self):\n        # Need to do this to ensure the function produces the\n        # bundle path when called from subclasses\n        names = [k for k, _, _ in self._name_parts]\n\n        parts = [self.source]\n\n        if self.bspace:\n            parts.append(self.bspace)\n\n        parts.append(\n            self._path_join(names=names, excludes=['source', 'version', 'bspace'], sep=self.NAME_PART_SEP))\n\n        return os.path.join(*parts)", "response": "The name in a form suitable for use in a filesystem."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ver(self, revision):\n\n        c = self.clone()\n\n        c.version = self._parse_version(self.version)\n\n        return c", "response": "Clone and change the version."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef as_partition(self, **kwargs):\n\n        return PartitionName(**dict(list(self.dict.items()) + list(kwargs.items())))", "response": "Return a PartitionName based on this name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npromote to a PartitionName by combining with a bundle Name.", "response": "def promote(self, name):\n        \"\"\"Promote to a PartitionName by combining with a bundle Name.\"\"\"\n        return PartitionName(**dict(list(name.dict.items()) + list(self.dict.items())))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef path(self):\n\n        # Need to do this to ensure the function produces the\n        # bundle path when called from subclasses\n        names = [k for k, _, _ in Name._name_parts]\n\n        return os.path.join(self.source,\n                            self._path_join(names=names, excludes=['source', 'format'], sep=self.NAME_PART_SEP),\n                            *self._local_parts()\n                            )", "response": "The path of the bundle source."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef partital_dict(self, with_name=True):\n\n        d = self._dict(with_name=False)\n\n        d = {k: d.get(k) for k, _, _ in PartialPartitionName._name_parts if d.get(k, False)}\n\n        if 'format' in d and d['format'] == Name.DEFAULT_FORMAT:\n            del d['format']\n\n        d['name'] = self.name\n\n        return d", "response": "Returns the name as a dict but with only the items that are\n        particular to a PartitionName."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the identity as a dict.", "response": "def _dict(self, with_name=True):\n        \"\"\"Returns the identity as a dict.\n\n        values that are empty are removed\n\n        \"\"\"\n\n        d = dict([(k, getattr(self, k)) for k, _, _ in self.name_parts])\n\n        return self.clear_dict(d)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef with_none(self):\n\n        n = self.clone()\n\n        for k, _, _ in n.name_parts:\n\n            if getattr(n, k) == n.NONE:\n                delattr(n, k)\n\n        n.use_clear_dict = False\n\n        return n", "response": "Convert the NameQuery. NONE to None."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nworks with PartialNameMixin. clear_dict to set NONE and ANY values.", "response": "def name_parts(self):\n        \"\"\"Works with PartialNameMixin.clear_dict to set NONE and ANY\n        values.\"\"\"\n\n        default = PartialMixin.ANY\n\n        np = ([(k, default, True)\n               for k, _, _ in super(NameQuery, self).name_parts]\n              +\n              [(k, default, True)\n               for k, _, _ in Name._generated_names]\n              )\n\n        return np"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef name_parts(self):\n\n        default = PartialMixin.ANY\n\n        return ([(k, default, True)\n                for k, _, _ in PartitionName._name_parts]\n                +\n                [(k, default, True)\n                 for k, _, _ in Name._generated_names]\n                )", "response": "Returns a list of tuples containing the name parts of the name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a string into one of the object number classes.", "response": "def parse(cls, on_str, force_type=None):  # @ReservedAssignment\n        \"\"\"Parse a string into one of the object number classes.\"\"\"\n\n        on_str_orig = on_str\n\n        if on_str is None:\n            return None\n\n        if not on_str:\n            raise NotObjectNumberError(\"Got null input\")\n\n        if not isinstance(on_str, string_types):\n            raise NotObjectNumberError(\"Must be a string. Got a {} \".format(type(on_str)))\n\n        # if isinstance(on_str, unicode):\n        #     dataset = on_str.encode('ascii')\n\n        if force_type:\n            type_ = force_type\n        else:\n            type_ = on_str[0]\n\n        on_str = on_str[1:]\n\n        if type_ not in list(cls.NDS_LENGTH.keys()):\n            raise NotObjectNumberError(\"Unknown type character '{}' for '{}'\".format(type_, on_str_orig))\n\n        ds_length = len(on_str) - cls.NDS_LENGTH[type_]\n\n        if ds_length not in cls.DATASET_LENGTHS:\n            raise NotObjectNumberError(\n                \"Dataset string '{}' has an unfamiliar length: {}\".format(on_str_orig, ds_length))\n\n        ds_lengths = cls.DATASET_LENGTHS[ds_length]\n\n        assignment_class = ds_lengths[2]\n\n        try:\n            dataset = int(ObjectNumber.base62_decode(on_str[0:ds_lengths[0]]))\n\n            if ds_lengths[1]:\n                i = len(on_str) - ds_lengths[1]\n                revision = int(ObjectNumber.base62_decode(on_str[i:]))\n                on_str = on_str[0:i]  # remove the revision\n            else:\n                revision = None\n\n            on_str = on_str[ds_lengths[0]:]\n\n            if type_ == cls.TYPE.DATASET:\n                return DatasetNumber(dataset, revision=revision, assignment_class=assignment_class)\n\n            elif type_ == cls.TYPE.TABLE:\n                table = int(ObjectNumber.base62_decode(on_str))\n                return TableNumber(\n                    DatasetNumber(dataset, assignment_class=assignment_class), table, revision=revision)\n\n            elif type_ == cls.TYPE.PARTITION:\n                partition = int(ObjectNumber.base62_decode(on_str))\n                return PartitionNumber(\n                    DatasetNumber(dataset, assignment_class=assignment_class), partition, revision=revision)\n\n            elif type_ == cls.TYPE.COLUMN:\n                table = int(ObjectNumber.base62_decode(on_str[0:cls.DLEN.TABLE]))\n                column = int(ObjectNumber.base62_decode(on_str[cls.DLEN.TABLE:]))\n\n                return ColumnNumber(\n                    TableNumber(DatasetNumber(dataset, assignment_class=assignment_class), table),\n                    column, revision=revision)\n\n            elif type_ == cls.TYPE.OTHER1 or type_ == cls.TYPE.CONFIG:\n                    return GeneralNumber1(on_str_orig[0],\n                                          DatasetNumber(dataset, assignment_class=assignment_class),\n                                          int(ObjectNumber.base62_decode(on_str[0:cls.DLEN.OTHER1])),\n                                          revision=revision)\n\n            elif type_ == cls.TYPE.OTHER2:\n                    return GeneralNumber2(on_str_orig[0],\n                                          DatasetNumber(dataset, assignment_class=assignment_class),\n                                          int(ObjectNumber.base62_decode(on_str[0:cls.DLEN.OTHER1])),\n                                          int(ObjectNumber.base62_decode(\n                                              on_str[cls.DLEN.OTHER1:cls.DLEN.OTHER1+cls.DLEN.OTHER2])),\n                                          revision=revision)\n\n            else:\n\n                raise NotObjectNumberError('Unknown type character: ' + type_ + ' in ' + str(on_str_orig))\n\n        except Base62DecodeError as e:\n            raise NotObjectNumberError('Unknown character:  ' + str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nencode a number in Base X.", "response": "def base62_encode(cls, num):\n        \"\"\"Encode a number in Base X.\n\n        `num`: The number to encode\n        `alphabet`: The alphabet to use for encoding\n        Stolen from: http://stackoverflow.com/a/1119769/1144479\n\n        \"\"\"\n\n        alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n        if num == 0:\n            return alphabet[0]\n        arr = []\n        base = len(alphabet)\n        while num:\n            rem = num % base\n            num = num // base\n            arr.append(alphabet[rem])\n        arr.reverse()\n        return ''.join(arr)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndecode a Base X encoded string into a number.", "response": "def base62_decode(cls, string):\n        \"\"\"Decode a Base X encoded string into the number.\n\n        Arguments:\n        - `string`: The encoded string\n        - `alphabet`: The alphabet to use for encoding\n        Stolen from: http://stackoverflow.com/a/1119769/1144479\n\n        \"\"\"\n\n        alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n        base = len(alphabet)\n        strlen = len(string)\n        num = 0\n\n        idx = 0\n        for char in string:\n            power = (strlen - (idx + 1))\n            try:\n                num += alphabet.index(char) * (base ** power)\n            except ValueError:\n                raise Base62DecodeError(\n                    \"Failed to decode char: '{}'\".format(char))\n            idx += 1\n\n        return num"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nincrements the version number of an object number of object number string", "response": "def increment(cls, v):\n        \"\"\"Increment the version number of an object number of object number string\"\"\"\n        if not isinstance(v, ObjectNumber):\n            v = ObjectNumber.parse(v)\n\n        return v.rev(v.revision+1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a clone with a different revision.", "response": "def rev(self, i):\n        \"\"\"Return a clone with a different revision.\"\"\"\n        on = copy(self)\n        on.revision = i\n        return on"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproducing a TopNumber object from a hex string.", "response": "def from_hex(cls, h, space, assignment_class='self'):\n        \"\"\"Produce a TopNumber, with a length to match the given assignment\n        class, based on an input hex string.\n\n        This can be used to create TopNumbers from a hash of a string.\n\n        \"\"\"\n\n        from math import log\n\n        # Use the ln(N)/ln(base) trick to find the right number of hext digits\n        # to  use\n\n        hex_digits = int(\n            round(log(62 ** TopNumber.DLEN.DATASET_CLASSES[assignment_class]) / log(16), 0))\n\n        i = int(h[:hex_digits], 16)\n\n        return TopNumber(space, i, assignment_class=assignment_class)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nproducing a TopNumber by hashing a string.", "response": "def from_string(cls, s, space):\n        \"\"\"Produce a TopNumber by hashing a string.\"\"\"\n\n        import hashlib\n\n        hs = hashlib.sha1(s).hexdigest()\n\n        return cls.from_hex(hs, space)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclassifying the type of otherCOOKIENAME or NAME into parts and returns a named tuple that indicates which parts of input string are name components object number and version number.", "response": "def classify(cls, o):\n        \"\"\"Break an Identity name into parts, or describe the type of other\n        forms.\n\n        Break a name or object number into parts and classify them. Returns a named tuple\n        that indicates which parts of input string are name components, object number and\n        version number. Does not completely parse the name components.\n\n        Also can handle Name, Identity and ObjectNumbers\n\n        :param o: Input object to split\n\n        \"\"\"\n        # from collections import namedtuple\n\n        s = str(o)\n\n        if o is None:\n            raise ValueError(\"Input cannot be None\")\n\n        class IdentityParts(object):\n            on = None\n            name = None\n            isa = None\n            name = None\n            vname = None\n            sname = None\n            name_parts = None\n            version = None\n            cache_key = None\n\n        # namedtuple('IdentityParts', ['isa', 'name', 'name_parts','on','version', 'vspec'])\n        ip = IdentityParts()\n\n        if isinstance(o, (DatasetNumber, PartitionNumber)):\n            ip.on = o\n            ip.name = None\n            ip.isa = type(ip.on)\n            ip.name_parts = None\n\n        elif isinstance(o, Name):\n            ip.on = None\n            ip.isa = type(o)\n            ip.name = str(o)\n            ip.name_parts = ip.name.split(Name.NAME_PART_SEP)\n\n        elif '/' in s:\n            # A cache key\n            ip.cache_key = s.strip()\n            ip.isa = str\n\n        elif cls.OBJECT_NUMBER_SEP in s:\n            # Must be a fqname\n            ip.name, on_s = s.strip().split(cls.OBJECT_NUMBER_SEP)\n            ip.on = ObjectNumber.parse(on_s)\n            ip.name_parts = ip.name.split(Name.NAME_PART_SEP)\n            ip.isa = type(ip.on)\n\n        elif Name.NAME_PART_SEP in s:\n            # Must be an sname or vname\n            ip.name = s\n            ip.on = None\n            ip.name_parts = ip.name.split(Name.NAME_PART_SEP)\n            ip.isa = Name\n\n        else:\n            # Probably an Object Number in string form\n            ip.name = None\n            ip.name_parts = None\n            ip.on = ObjectNumber.parse(s.strip())\n            ip.isa = type(ip.on)\n\n        if ip.name_parts:\n            last = ip.name_parts[-1]\n\n            try:\n                ip.version = sv.Version(last)\n                ip.vname = ip.name\n            except ValueError:\n                try:\n                    ip.version = sv.Spec(last)\n                    ip.vname = None  # Specs aren't vnames you can query\n                except ValueError:\n                    pass\n\n            if ip.version:\n                ip.name_parts.pop()\n                ip.sname = Name.NAME_PART_SEP.join(ip.name_parts)\n            else:\n                ip.sname = ip.name\n\n        return ip"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_meta(self, md5=None, file=None):\n        # from collections import OrderedDict\n\n        if not md5:\n            if not file:\n                raise ValueError('Must specify either file or md5')\n\n            md5 = md5_for_file(file)\n            size = os.stat(file).st_size\n        else:\n            size = None\n\n        return {\n            'id': self.id_,\n            'identity': json.dumps(self.dict),\n            'name': self.sname,\n            'fqname': self.fqname,\n            'md5': md5,\n            # This causes errors with calculating the AWS signature\n            'size': size\n        }", "response": "Return a dictionary of metadata for use in the Remote API."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ident_dict(self):\n\n        SKIP_KEYS = ['name','vname','fqname','vid','cache_key']\n        return {k: v for k, v in iteritems(self.dict) if k not in SKIP_KEYS}", "response": "A dictionary with only the items required to specify the identy and\n        excluding the generated names vname and fqname."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_partition(self, partition=0, **kwargs):\n\n        assert isinstance(self._name, Name), \"Wrong type: {}\".format(type(self._name))\n        assert isinstance(self._on, DatasetNumber), \"Wrong type: {}\".format(type(self._on))\n\n        name = self._name.as_partition(**kwargs)\n        on = self._on.as_partition(partition)\n\n        return PartitionIdentity(name, on)", "response": "Return a new PartitionIdentity based on this Identity."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a partition identity as a child of a dataset identity.", "response": "def add_partition(self, p):\n        \"\"\"Add a partition identity as a child of a dataset identity.\"\"\"\n\n        if not self.partitions:\n            self.partitions = {}\n\n        self.partitions[p.vid] = p"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a partition identity as a child of a dataset identity.", "response": "def add_file(self, f):\n        \"\"\"Add a partition identity as a child of a dataset identity.\"\"\"\n\n        if not self.files:\n            self.files = set()\n\n        self.files.add(f)\n\n        self.locations.set(f.type_)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef partition(self):\n\n        if not self.partitions:\n            return None\n\n        if len(self.partitions) > 1:\n            raise ValueError(\n                \"Can't use this method when there is more than one partition\")\n\n        return list(self.partitions.values())[0]", "response": "Convenience function for accessing the first partition in the the\n        partitions list when there is only one."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rev(self, rev):\n        d = self.dict\n        d['revision'] = rev\n        return self.from_dict(d)", "response": "Return a new identity with the given revision"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _info(self):\n        d = OrderedDict()\n\n        d['vid'] = self.vid\n        d['sname'] = self.sname\n        d['vname'] = self.vname\n\n        return d", "response": "Returns an OrderedDict of information for human display."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_dict(cls, d):\n\n        name = PartitionIdentity._name_class(**d)\n\n        if 'id' in d and 'revision' in d:\n            # The vid should be constructed from the id and the revision\n            on = (ObjectNumber.parse(d['id']).rev(d['revision']))\n        elif 'vid' in d:\n            on = ObjectNumber.parse(d['vid'])\n        else:\n            raise ValueError(\"Must have id and revision, or vid\")\n\n        try:\n            return PartitionIdentity(name, on)\n        except TypeError as e:\n            raise TypeError(\n                \"Failed to make identity from \\n{}\\n: {}\".format(\n                    d,\n                    e.message))", "response": "Like Identity. from_dict but will cast the class type based on the dict format. i. e. the format is hdf return an HdfPartitionIdentity."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting this identity to the corresponding dataset.", "response": "def as_dataset(self):\n        \"\"\"Convert this identity to the identity of the corresponding\n        dataset.\"\"\"\n\n        on = self.on.dataset\n\n        on.revision = self.on.revision\n\n        name = Name(**self.name.dict)\n\n        return Identity(name, on)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sleep(self):\n\n        if self.next_time and time.time() < self.next_time:\n            time.sleep(self.next_time - time.time())", "response": "Wait for the sleep time of the last response."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_file_system(self, source_url=False, build_url=False):\n\n        assert isinstance(source_url, string_types) or source_url is None or source_url is False\n        assert isinstance(build_url, string_types) or build_url is False\n\n        if source_url:\n            self._source_url = source_url\n            self.dataset.config.library.source.url = self._source_url\n            self._source_fs = None\n\n        elif source_url is None:\n            self._source_url = None\n            self.dataset.config.library.source.url = self._source_url\n            self._source_fs = None\n\n        if build_url:\n            self._build_url = build_url\n            self.dataset.config.library.build.url = self._build_url\n            self._build_fs = None\n\n        self.dataset.commit()", "response": "Set the source file filesystem and build file system"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear_file_systems(self):\n\n        self._source_url = None\n        self.dataset.config.library.source.url = None\n        self._source_fs = None\n\n        self._build_url = None\n        self.dataset.config.library.build.url = None\n        self._build_fs = None\n\n        self.dataset.commit()", "response": "Remove references to source and build file systems reverting to the defaults"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading the bundle file from the database and return a new bundle built on that class.", "response": "def cast_to_subclass(self):\n        \"\"\"\n        Load the bundle file from the database to get the derived bundle class,\n        then return a new bundle built on that class\n\n        :return:\n        \"\"\"\n        self.import_lib()\n        self.load_requirements()\n\n        try:\n            self.commit()  # To ensure the rollback() doesn't clear out anything important\n            bsf = self.build_source_files.file(File.BSFILE.BUILD)\n        except Exception as e:\n            self.log('Error trying to create a bundle source file ... {} '.format(e))\n            raise\n            self.rollback()\n            return self\n\n        try:\n            clz = bsf.import_bundle()\n\n        except Exception as e:\n\n            raise BundleError('Failed to load bundle code file, skipping : {}'.format(e))\n\n        b = clz(self._dataset, self._library, self._source_url, self._build_url)\n        b.limited_run = self.limited_run\n        b.capture_exceptions = self.capture_exceptions\n        b.multi = self.multi\n\n\n        return b"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the python packages from the metadata.", "response": "def load_requirements(self):\n        \"\"\"If there are python library requirements set, append the python dir\n        to the path.\"\"\"\n\n        for module_name, pip_name in iteritems(self.metadata.requirements):\n            extant = self.dataset.config.requirements[module_name].url\n\n            force = (extant and extant != pip_name)\n\n            self._library.install_packages(module_name, pip_name, force=force)\n\n            self.dataset.config.requirements[module_name].url = pip_name\n\n        python_dir = self._library.filesystem.python()\n        sys.path.append(python_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dep(self, source_name):\n        from ambry.orm.exc import NotFoundError\n        from ambry.dbexceptions import ConfigurationError\n\n        source = self.source(source_name)\n\n        ref = source.url\n\n        if not ref:\n            raise ValueError(\"Got an empty ref for source '{}' \".format(source.name))\n\n        try:\n            try:\n\n                p = self.library.partition(ref)\n            except NotFoundError:\n\n                self.warn(\"Partition reference {} not found, try to download it\".format(ref))\n                remote, vname = self.library.find_remote_bundle(ref, try_harder=True)\n                if remote:\n                    self.warn(\"Installing {} from {}\".format(remote, vname))\n                    self.library.checkin_remote_bundle(vname, remote)\n                    p = self.library.partition(ref)\n                else:\n                    raise\n\n            if not p.is_local:\n                with self.progress.start('test', 0, message='localizing') as ps:\n                    p.localize(ps)\n\n            return p\n\n        except NotFoundError:\n            return self.library.bundle(ref)", "response": "Return a bundle dependency from the sources list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the documentation from the documentation. md file with template substitutions", "response": "def documentation(self):\n        \"\"\"Return the documentation, from the documentation.md file, with template substitutions\"\"\"\n\n        # Return the documentation as a scalar term, which has .text() and .html methods to do\n        # metadata substitution using Jinja\n\n        s = ''\n\n        rc = self.build_source_files.documentation.record_content\n\n        if rc:\n            s += rc\n\n        for k, v in  self.metadata.documentation.items():\n            if  v:\n                s += '\\n### {}\\n{}'.format(k.title(), v)\n\n        return self.metadata.scalar_term(s)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a ProcessLogger to record build progress", "response": "def progress(self):\n        \"\"\"Returned a cached ProcessLogger to record build progress \"\"\"\n\n        if not self._progress:\n\n            # If won't be building, only use one connection\n            new_connection = False if self._library.read_only else True\n\n            self._progress = ProcessLogger(self.dataset, self.logger, new_connection=new_connection)\n\n        return self._progress"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a partition in this bundle for a vid reference or name parts", "response": "def partition(self, ref=None, **kwargs):\n        \"\"\"Return a partition in this bundle for a vid reference or name parts\"\"\"\n        from ambry.orm.exc import NotFoundError\n        from sqlalchemy.orm.exc import NoResultFound\n\n        if not ref and not kwargs:\n            return None\n\n        if ref:\n            for p in self.partitions:\n                if ref == p.name or ref == p.vname or ref == p.vid or ref == p.id:\n                  p._bundle = self\n                  return p\n\n            raise NotFoundError(\"No partition found for '{}' (a)\".format(ref))\n\n        elif kwargs:\n            from ..identity import PartitionNameQuery\n            pnq = PartitionNameQuery(**kwargs)\n            try:\n                p = self.partitions._find_orm(pnq).one()\n                if p:\n                    p._bundle = self\n                    return p\n            except NoResultFound:\n                raise NotFoundError(\"No partition found for '{}' (b)\".format(kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef partition_by_vid(self, ref):\n        from ambry.orm import Partition\n\n        p = self.session.query(Partition).filter(Partition.vid == str(ref)).first()\n        if p:\n            return self.wrap_partition(p)\n        else:\n            return None", "response": "A much faster way to get partitions by vid only"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tables(self):\n        from ambry.orm import Table\n        from sqlalchemy.orm import lazyload\n\n        return (self.dataset.session.query(Table)\n                .filter(Table.d_vid == self.dataset.vid)\n                .options(lazyload('*'))\n                .all())", "response": "Return a iterator of tables in this bundle"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new table if it does not exist or update an existing table if it does not exist.", "response": "def new_table(self, name, add_id=True, **kwargs):\n        \"\"\"\n        Create a new table, if it does not exist, or update an existing table if it does\n        :param name:  Table name\n        :param add_id: If True, add an id field ( default is True )\n        :param kwargs: Other options passed to table object\n        :return:\n        \"\"\"\n\n        return self.dataset.new_table(name=name, add_id=add_id, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sources(self):\n\n        def set_bundle(s):\n            s._bundle = self\n            return s\n        return list(set_bundle(s) for s in self.dataset.sources)", "response": "Iterate over downloadable sources"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nresolve the sources to run from an input of sources and tables.", "response": "def _resolve_sources(self, sources, tables, stage=None, predicate=None):\n        \"\"\"\n        Determine what sources to run from an input of sources and tables\n\n        :param sources:  A collection of source objects, source names, or source vids\n        :param tables: A collection of table names\n        :param stage: If not None, select only sources from this stage\n        :param predicate: If not none, a callable that selects a source to return when True\n        :return:\n        \"\"\"\n\n        assert sources is None or tables is None\n\n        if not sources:\n            if tables:\n                sources = list(s for s in self.sources if s.dest_table_name in tables)\n            else:\n                sources = self.sources\n\n        elif not isinstance(sources, (list, tuple)):\n            sources = [sources]\n\n        def objectify(source):\n            if isinstance(source, basestring):\n                source_name = source\n                return self.source(source_name)\n            else:\n                return source\n\n        sources = [objectify(s) for s in sources]\n\n        if predicate:\n            sources = [s for s in sources if predicate(s)]\n\n        if stage:\n            sources = [s for s in sources if str(s.stage) == str(stage)]\n\n        return sources"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\niterate over downloadable sources -- references and templates", "response": "def refs(self):\n        \"\"\"Iterate over downloadable sources -- references and templates\"\"\"\n\n        def set_bundle(s):\n            s._bundle = self\n            return s\n\n        return list(set_bundle(s) for s in self.dataset.sources if not s.is_downloadable)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_source_files(self):\n\n        from .files import BuildSourceFileAccessor\n        return BuildSourceFileAccessor(self, self.dataset, self.source_fs)", "response": "Return acessors to the build files"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a pyfilesystem subdirectory for the build directory for the bundle. This is the sub - directory of the build FS that holds the compiled SQLite file and the partition data files. This is the sub - directory of the build FS that holds the compiled SQLite file and the partition data files.", "response": "def build_partition_fs(self):\n        \"\"\"Return a pyfilesystem subdirectory for the build directory for the bundle. This the sub-directory\n        of the build FS that holds the compiled SQLite file and the partition data files\"\"\"\n\n        base_path = os.path.dirname(self.identity.cache_key)\n\n        if not self.build_fs.exists(base_path):\n            self.build_fs.makedir(base_path, recursive=True, allow_recreate=True)\n\n        return self.build_fs.opendir(base_path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a pyfilesystem subdirectory for the ingested source files", "response": "def build_ingest_fs(self):\n        \"\"\"Return a pyfilesystem subdirectory for the ingested source files\"\"\"\n\n        base_path = 'ingest'\n\n        if not self.build_fs.exists(base_path):\n            self.build_fs.makedir(base_path, recursive=True, allow_recreate=True)\n\n        return self.build_fs.opendir(base_path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsearch the bundle. yaml metadata file for pipeline configurations.", "response": "def phase_search_names(self, source, phase):\n        \"\"\"Search the bundle.yaml metadata file for pipeline configurations. Looks for:\n        - <phase>-<source_table>\n        - <phase>-<dest_table>\n        - <phase>-<source_name>\n\n        \"\"\"\n        search = []\n\n        assert phase is not None\n\n        # Create a search list of names for getting a pipline from the metadata\n        if source and source.source_table_name:\n            search.append(phase + '-' + source.source_table_name)\n\n        if source and source.dest_table_name:\n            search.append(phase + '-' + source.dest_table_name)\n\n        if source:\n            search.append(phase + '-' + source.name)\n\n        search.append(phase)\n\n        return search"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a log message only to the file", "response": "def log_to_file(self, message):\n        \"\"\"Write a log message only to the file\"\"\"\n\n        with self.build_fs.open(self.log_file, 'a+') as f:\n            f.write(unicode(message + '\\n'))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlog an error message.", "response": "def error(self, message, set_error_state=False):\n        \"\"\"Log an error messsage.\n\n        :param message:  Log message.\n\n        \"\"\"\n        if set_error_state:\n            if message not in self._errors:\n                self._errors.append(message)\n\n            self.set_error_state()\n\n        self.logger.error(message)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlogs an exception messsage.", "response": "def exception(self, e):\n        \"\"\"Log an error messsage.\n\n        :param e:  Exception to log.\n\n        \"\"\"\n        self.logged_exception(e)\n        self.logger.exception(e)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrecording the exception but don t log it", "response": "def logged_exception(self, e):\n        \"\"\"Record the exception, but don't log it; it's already been logged\n\n        :param e:  Exception to log.\n\n        \"\"\"\n        if str(e) not in self._errors:\n            self._errors.append(str(e))\n\n        self.set_error_state()\n        self.buildstate.state.exception_type = str(e.__class__.__name__)\n        self.buildstate.state.exception = str(e)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef warn(self, message):\n        if message not in self._warnings:\n            self._warnings.append(message)\n\n        self.logger.warn(message)", "response": "Log an error messsage."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fatal(self, message):\n\n        self.logger.fatal(message)\n        sys.stderr.flush()\n        if self.exit_on_fatal:\n            sys.exit(1)\n        else:\n            raise FatalError(message)", "response": "Log a fatal messsage and exit."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef log_pipeline(self, pl):\n        from datetime import datetime\n        from ambry.etl.pipeline import CastColumns\n\n        self.build_fs.makedir('pipeline', allow_recreate=True)\n\n        try:\n            ccp = pl[CastColumns]\n            caster_code = ccp.pretty_code\n        except Exception as e:\n            caster_code = str(e)\n\n        templ = u(\"\"\"\nPipeline     : {}\nrun time     : {}\nphase        : {}\nsource name  : {}\nsource table : {}\ndest table   : {}\n========================================================\n{}\n\nPipeline Headers\n================\n{}\n\nCaster Code\n===========\n{}\n\n\"\"\")\n        try:\n            v = templ.format(pl.name, str(datetime.now()), pl.phase, pl.source_name, pl.source_table,\n                             pl.dest_table, unicode(pl), pl.headers_report(), caster_code)\n        except UnicodeError as e:\n            v = ''\n            self.error('Faled to write pipeline log for pipeline {} '.format(pl.name))\n\n        path = os.path.join('pipeline', pl.phase + '-' + pl.file_name + '.txt')\n\n        self.build_fs.makedir(os.path.dirname(path), allow_recreate=True, recursive=True)\n        # LazyFS should handled differently because of:\n        # TypeError: lazy_fs.setcontents(..., encoding='utf-8') got an unexpected keyword argument 'encoding'\n        if isinstance(self.build_fs, LazyFS):\n            self.build_fs.wrapped_fs.setcontents(path, v, encoding='utf8')\n        else:\n            self.build_fs.setcontents(path, v, encoding='utf8')", "response": "Write a report of the pipeline pl to a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pipeline(self, source=None, phase='build', ps=None):\n        from ambry.etl.pipeline import Pipeline, PartitionWriter\n        from ambry.dbexceptions import ConfigurationError\n\n        if source:\n            source = self.source(source) if isinstance(source, string_types) else source\n        else:\n            source = None\n\n        sf, sp = self.source_pipe(source, ps) if source else (None, None)\n\n\n        pl = Pipeline(self, source=sp)\n\n        # Get the default pipeline, from the config at the head of this file.\n        try:\n            phase_config = self.default_pipelines[phase]\n        except KeyError:\n            phase_config = None  # Ok for non-conventional pipe names\n\n        if phase_config:\n            pl.configure(phase_config)\n\n        # Find the pipe configuration, from the metadata\n        pipe_config = None\n        pipe_name = None\n        if source and source.pipeline:\n            pipe_name = source.pipeline\n            try:\n                pipe_config = self.metadata.pipelines[pipe_name]\n            except KeyError:\n                raise ConfigurationError(\"Pipeline '{}' declared in source '{}', but not found in metadata\"\n                                         .format(source.pipeline, source.name))\n        else:\n            pipe_name, pipe_config = self._find_pipeline(source, phase)\n\n        if pipe_name:\n            pl.name = pipe_name\n        else:\n            pl.name = phase\n\n        pl.phase = phase\n\n        # The pipe_config can either be a list, in which case it is a list of pipe pipes for the\n        # augment segment or it could be a dict, in which case each is a list of pipes\n        # for the named segments.\n\n        def apply_config(pl, pipe_config):\n\n            if isinstance(pipe_config, (list, tuple)):\n                # Just convert it to dict form for the next section\n\n                # PartitionWriters are always moved to the 'store' section\n                store, body = [], []\n\n                for pipe in pipe_config:\n                    store.append(pipe) if isinstance(pipe, PartitionWriter) else body.append(pipe)\n\n                pipe_config = dict(body=body, store=store)\n\n            if pipe_config:\n                pl.configure(pipe_config)\n\n        apply_config(pl, pipe_config)\n\n        # One more time, for the configuration for 'all' phases\n        if 'all' in self.metadata.pipelines:\n            apply_config(pl, self.metadata.pipelines['all'])\n\n        # Allows developer to over ride pipe configuration in code\n\n        self.edit_pipeline(pl)\n\n        try:\n\n            pl.dest_table = source.dest_table_name\n            pl.source_table = source.source_table.name\n            pl.source_name = source.name\n        except AttributeError:\n            pl.dest_table = None\n\n        return pl", "response": "Construct a pipeline for all phases."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of values to match the fields values. This is used when listing bundles to get a table of information about the bundle.", "response": "def field_row(self, fields):\n        \"\"\"\n        Return a list of values to match the fields values. This is used when listing bundles to\n        produce a table of information about the bundle.\n\n        :param fields: A list of names of data items.\n        :return: A list of values, in the same order as the fields input\n\n        The names in the fields llist can be:\n\n        - state: The current build state\n        - source_fs: The URL of the build source filesystem\n        - about.*: Any of the metadata fields in the about section\n\n        \"\"\"\n\n        row = self.dataset.row(fields)\n\n        # Modify for special fields\n        for i, f in enumerate(fields):\n            if f == 'bstate':\n                row[i] = self.state\n            elif f == 'dstate':\n                row[i] = self.dstate\n            elif f == 'source_fs':\n                row[i] = self.source_fs\n            elif f.startswith('about'):  # all metadata in the about section, ie: about.title\n                _, key = f.split('.')\n                row[i] = self.metadata.about[key]\n            elif f.startswith('state'):\n                _, key = f.split('.')\n                row[i] = self.buildstate.state[key]\n            elif f.startswith('count'):\n                _, key = f.split('.')\n                if key == 'sources':\n                    row[i] = len(self.dataset.sources)\n                elif key == 'tables':\n                    row[i] = len(self.dataset.tables)\n\n        return row"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a source pipe for a source", "response": "def source_pipe(self, source, ps=None):\n        \"\"\"Create a source pipe for a source, giving it access to download files to the local cache\"\"\"\n\n        if isinstance(source, string_types):\n            source = self.source(source)\n\n        source.dataset = self.dataset\n        source._bundle = self\n\n        iter_source, source_pipe = self._iterable_source(source, ps)\n\n        if self.limited_run:\n            source_pipe.limit = 500\n\n        return iter_source, source_pipe"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_source(self, source, clean=False,  callback=None):\n        from fs.zipfs import ZipOpenError\n        import os\n        from ambry_sources.sources import ( GoogleSource, CsvSource, TsvSource, FixedSource,\n                                            ExcelSource, PartitionSource, SourceError, DelayedOpen,\n                                            DelayedDownload, ShapefileSource, SocrataSource )\n        from ambry_sources import extract_file_from_zip\n\n\n        spec = source.spec\n        cache_fs = self.library.download_cache\n        account_accessor = self.library.account_accessor\n\n        # FIXME. urltype should be moved to reftype.\n        url_type = spec.get_urltype()\n\n        def do_download():\n            from ambry_sources.fetch import download\n\n            return download(spec.url, cache_fs, account_accessor, clean=clean,\n                            logger=self.logger, callback=callback)\n\n        if url_type == 'file':\n\n            from fs.opener import fsopen\n\n            syspath = spec.url.replace('file://', '')\n\n            cache_path = syspath.strip('/')\n            cache_fs.makedir(os.path.dirname(cache_path), recursive=True, allow_recreate=True)\n\n            if os.path.isabs(syspath):\n                # FIXME! Probably should not be\n                with open(syspath) as f:\n                    cache_fs.setcontents(cache_path, f)\n            else:\n                cache_fs.setcontents(cache_path, self.source_fs.getcontents(syspath))\n\n        elif url_type not in ('gs', 'socrata'):  # FIXME. Need to clean up the logic for gs types.\n\n            try:\n\n                cache_path, download_time = do_download()\n                spec.download_time = download_time\n            except Exception as e:\n                from ambry_sources.exceptions import DownloadError\n                raise DownloadError(\"Failed to download {}; {}\".format(spec.url, e))\n        else:\n            cache_path, download_time = None, None\n\n\n\n        if url_type == 'zip':\n            try:\n                fstor = extract_file_from_zip(cache_fs, cache_path, spec.url, spec.file)\n            except ZipOpenError:\n                # Try it again\n                cache_fs.remove(cache_path)\n                cache_path, spec.download_time = do_download()\n                fstor = extract_file_from_zip(cache_fs, cache_path, spec.url, spec.file)\n\n            file_type = spec.get_filetype(fstor.path)\n\n        elif url_type == 'gs':\n            fstor = get_gs(spec.url, spec.segment, account_accessor)\n            file_type = 'gs'\n\n        elif url_type == 'socrata':\n            spec.encoding = 'utf8'\n            spec.header_lines = [0]\n            spec.start_line = 1\n            url = SocrataSource.download_url(spec)\n            fstor = DelayedDownload(url, cache_fs)\n            file_type = 'socrata'\n\n        else:\n            fstor = DelayedOpen(cache_fs, cache_path, 'rb')\n            file_type = spec.get_filetype(fstor.path)\n\n        spec.filetype = file_type\n\n        TYPE_TO_SOURCE_MAP = {\n            'gs': GoogleSource,\n            'csv': CsvSource,\n            'tsv': TsvSource,\n            'fixed': FixedSource,\n            'txt': FixedSource,\n            'xls': ExcelSource,\n            'xlsx': ExcelSource,\n            'partition': PartitionSource,\n            'shape': ShapefileSource,\n            'socrata': SocrataSource\n        }\n\n        cls = TYPE_TO_SOURCE_MAP.get(file_type)\n        if cls is None:\n            raise SourceError(\n                \"Failed to determine file type for source '{}'; unknown type '{}' \"\n                    .format(spec.name, file_type))\n\n        return cls(spec, fstor)", "response": "Download a file from a URL and return it wrapped in a row - generating acessor object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the error condition", "response": "def error_state(self):\n        \"\"\"Set the error condition\"\"\"\n        self.buildstate.state.lasttime = time()\n        self.buildstate.commit()\n        return self.buildstate.state.error"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the current build state and record the time to maintain history.", "response": "def state(self, state):\n        \"\"\"Set the current build state and record the time to maintain history.\n\n        Note! This is different from the dataset state. Setting the build set is commiteed to the\n        progress table/database immediately. The dstate is also set, but is not committed until the\n        bundle is committed. So, the dstate changes more slowly.\n        \"\"\"\n\n        assert state != 'build_bundle'\n\n        self.buildstate.state.current = state\n        self.buildstate.state[state] = time()\n        self.buildstate.state.lasttime = time()\n\n        self.buildstate.state.error = False\n        self.buildstate.state.exception = None\n        self.buildstate.state.exception_type = None\n        self.buildstate.commit()\n\n        if state in (self.STATES.NEW, self.STATES.CLEANED, self.STATES.BUILT, self.STATES.FINALIZED,\n                     self.STATES.SOURCE):\n            state = state if state != self.STATES.CLEANED else self.STATES.NEW\n            self.dstate = state"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef record_stage_state(self, phase, stage):\n\n        key = '{}-{}'.format(phase, stage if stage else 1)\n\n        self.buildstate.state[key] = time()", "response": "Record the completion times of phases and stages"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_last_access(self, tag):\n        import time\n        # time defeats check that value didn't change\n\n        self.buildstate.access.last = '{}-{}'.format(tag, time.time())\n        self.buildstate.commit()", "response": "Mark the time that this bundle was last accessed"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sync_in(self, force=False):\n        self.log('---- Sync In ----')\n\n        self.dstate = self.STATES.BUILDING\n\n        for path_name in self.source_fs.listdir():\n\n            f = self.build_source_files.instance_from_name(path_name)\n\n            if not f:\n                self.warn('Ignoring unknown file: {}'.format(path_name))\n                continue\n\n            if f and f.exists and (f.fs_is_newer or force):\n                self.log('Sync: {}'.format(f.record.path))\n                f.fs_to_record()\n                f.record_to_objects()\n\n        self.commit()\n\n        self.library.search.index_bundle(self, force=True)", "response": "Synchronize from files to records and records to objects"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsynchronize from files to records", "response": "def sync_in_files(self, force=False):\n        \"\"\"Synchronize from files to records\"\"\"\n        self.log('---- Sync Files ----')\n\n        self.dstate = self.STATES.BUILDING\n\n        for f in self.build_source_files:\n\n            if self.source_fs.exists(f.record.path):\n                # print f.path, f.fs_modtime, f.record.modified, f.record.source_hash, f.fs_hash\n                if f.fs_is_newer or force:\n                    self.log('Sync: {}'.format(f.record.path))\n                    f.fs_to_record()\n\n        self.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sync_in_records(self, force=False):\n        self.log('---- Sync Files ----')\n\n        for f in self.build_source_files:\n            f.record_to_objects()\n\n        # Only the metadata needs to be driven to the objects, since the other files are used as code,\n        # directly from the file record.\n        self.build_source_files.file(File.BSFILE.META).record_to_objects()\n\n        self.commit()", "response": "Synchronize from files to records"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sync_out(self, file_name=None, force=False):\n        self.log('---- Sync Out ----')\n        from ambry.bundle.files import BuildSourceFile\n\n        self.dstate = self.STATES.BUILDING\n\n        for f in self.build_source_files.list_records():\n\n            if (f.sync_dir() == BuildSourceFile.SYNC_DIR.RECORD_TO_FILE or f.record.path == file_name) or force:\n                self.log('Sync: {}'.format(f.record.path))\n                f.record_to_fs()\n\n        self.commit()", "response": "Synchronize from objects to records"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sync_objects_in(self):\n        self.dstate = self.STATES.BUILDING\n        self.build_source_files.record_to_objects()", "response": "Synchronize from records to objects"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sync_objects_out(self, force=False):\n        self.log('---- Sync Objects Out ----')\n        from ambry.bundle.files import BuildSourceFile\n\n        self.dstate = self.STATES.BUILDING\n\n        for f in self.build_source_files.list_records():\n\n            self.log('Sync: {}'.format(f.record.path))\n            f.objects_to_record()\n\n        self.commit()", "response": "Synchronize from objects to records and records to files"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sync_schema(self):\n        from ambry.orm.file import File\n        from ambry.bundle.files import BuildSourceFile\n\n        self.dstate = self.STATES.BUILDING\n\n        synced = 0\n        for fc in [File.BSFILE.SCHEMA, File.BSFILE.SOURCESCHEMA]:\n            bsf = self.build_source_files.file(fc)\n            if bsf.fs_is_newer:\n                self.log('Syncing {}'.format(bsf.file_name))\n                bsf.sync(BuildSourceFile.SYNC_DIR.FILE_TO_RECORD)\n                synced += 1\n\n        return synced", "response": "Sync in code files and meta files with the source files"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npropagate schema object changes to file records", "response": "def update_schema(self):\n        \"\"\"Propagate schema object changes to file records\"\"\"\n\n        self.commit()\n        self.build_source_files.schema.objects_to_record()\n        self.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clean(self, force=False):\n\n        if self.is_finalized and not force:\n            self.warn(\"Can't clean; bundle is finalized\")\n            return False\n\n        self.log('---- Cleaning ----')\n        self.state = self.STATES.CLEANING\n        self.dstate = self.STATES.BUILDING\n\n        self.commit()\n\n        self.clean_sources()\n        self.clean_tables()\n        self.clean_partitions()\n        self.clean_build()\n        self.clean_files()\n        self.clean_ingested()\n        self.clean_build_state()\n        self.clean_progress()\n\n        self.state = self.STATES.CLEANED\n\n        self.commit()\n\n        return True", "response": "Clean generated objects from the dataset but only if there are File contents\n         to regenerate them"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncleaning everything except the build source files", "response": "def clean_except_files(self):\n        \"\"\"Clean everything except the build source files\"\"\"\n\n        if self.is_finalized:\n            self.warn(\"Can't clean; bundle is finalized\")\n            return False\n\n        self.log('---- Cleaning ----')\n        self.state = self.STATES.CLEANING\n\n        self.commit()\n\n        self.clean_sources()\n        self.clean_tables()\n        self.clean_partitions()\n        self.clean_build()\n        self.clean_ingested()\n        self.clean_build_state()\n\n        self.state = self.STATES.CLEANED\n\n        self.commit()\n\n        self.log('---- Done Cleaning ----')\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlikes clean but clears out files.", "response": "def clean_sources(self):\n        \"\"\"Like clean, but also clears out files. \"\"\"\n\n        for src in self.dataset.sources:\n            src.st_id = None\n            src.t_id = None\n\n        self.dataset.sources[:] = []\n        self.dataset.source_tables[:] = []\n        self.dataset.st_sequence_id = 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete partition records and any built partition files.", "response": "def clean_partitions(self):\n        \"\"\"Delete partition records and any built partition files. \"\"\"\n        import shutil\n        from ambry.orm import ColumnStat\n\n        # FIXME. There is a problem with the cascades for ColumnStats that prevents them from\n        # being  deleted with the partitions. Probably, they are seen to be owed by the columns instead.\n        self.session.query(ColumnStat).filter(ColumnStat.d_vid == self.dataset.vid).delete()\n\n        self.dataset.delete_partitions()\n\n        for s in self.sources:\n            s.state = None\n\n        if self.build_partition_fs.exists:\n            try:\n                shutil.rmtree(self.build_partition_fs.getsyspath('/'))\n            except NoSysPathError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clean_build(self):\n        import shutil\n\n        if self.build_fs.exists:\n            try:\n                shutil.rmtree(self.build_fs.getsyspath('/'))\n            except NoSysPathError:\n                pass", "response": "Delete the build directory and all ingested files"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves all process and build metadata", "response": "def clean_process_meta(self):\n        \"\"\"Remove all process and build metadata\"\"\"\n        ds = self.dataset\n        ds.config.build.clean()\n        ds.config.process.clean()\n        ds.commit()\n        self.state = self.STATES.CLEANED"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clean_source_files(self):\n\n        self.build_source_files.file(File.BSFILE.SOURCESCHEMA).remove()\n        self.build_source_files.file(File.BSFILE.SCHEMA).remove()\n        self.commit()", "response": "Remove the schema. csv and source_schema. csv files"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ingest(self, sources=None, tables=None, stage=None, force=False, load_meta=False):\n\n        from itertools import groupby\n        from ambry.bundle.events import TAG\n        from fs.errors import ResourceNotFoundError\n        import zlib\n\n        self.log('---- Ingesting ----')\n\n        self.dstate = self.STATES.BUILDING\n        self.commit() # WTF? Without this, postgres blocks between table query, and update seq id in source tables.\n\n        key = lambda s: s.stage if s.stage else 1\n\n        def not_final_or_delete(s):\n            import zlib\n\n            if force:\n                return True\n\n            try:\n                return s.is_processable and not s.is_ingested and not s.is_built\n            except (IOError, zlib.error):\n                s.local_datafile.remove()\n                return True\n\n        sources = sorted(self._resolve_sources(sources, tables, stage, predicate=not_final_or_delete),\n                         key=key)\n\n        if not sources:\n            self.log('No sources left to ingest')\n            return\n\n        self.state = self.STATES.INGESTING\n\n        count = 0\n        errors = 0\n\n        self._run_events(TAG.BEFORE_INGEST, 0)\n        # Clear out all ingested files that are malformed\n        for s in self.sources:\n            if s.is_downloadable:\n                df = s.datafile\n                try:\n                    info = df.info\n                    df.close()\n                except (ResourceNotFoundError, zlib.error, IOError):\n                    df.remove()\n\n        for stage, g in groupby(sources, key):\n            sources = [s for s in g if not_final_or_delete(s)]\n\n            if not len(sources):\n                continue\n\n            self._run_events(TAG.BEFORE_INGEST, stage)\n\n            stage_errors = self._ingest_sources(sources, stage, force=force)\n\n            errors += stage_errors\n\n            count += len(sources) - stage_errors\n\n            self._run_events(TAG.AFTER_INGEST, stage)\n            self.record_stage_state(self.STATES.INGESTING, stage)\n\n        self.state = self.STATES.INGESTED\n\n        try:\n            pass\n        finally:\n            self._run_events(TAG.AFTER_INGEST, 0)\n\n        self.log('Ingested {} sources'.format(count))\n\n        if load_meta:\n\n            if len(sources) == 1:\n                iterable_source, source_pipe = self.source_pipe(sources[0])\n\n                try:\n                    meta = iterable_source.meta\n                    if meta:\n                        self.metadata.about.title = meta['title']\n                        self.metadata.about.summary = meta['summary']\n                        self.build_source_files.bundle_meta.objects_to_record()\n\n                except AttributeError as e:\n                    self.warn(\"Failed to set metadata: {}\".format(e))\n                    pass\n            else:\n                self.warn(\"Didn't not load meta from source. Must have exactly one soruce, got {}\".format(len(sources)))\n\n        self.commit()\n\n        if errors == 0:\n            return True\n        else:\n            return False", "response": "Ingest a set of sources and return a new set of sources."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _ingest_sources(self, sources, stage, force=False):\n        from concurrent import ingest_mp\n\n        self.state = self.STATES.INGESTING\n\n        downloadable_sources = [s for s in sources if force or\n                                (s.is_processable and not s.is_ingested and not s.is_built)]\n\n        errors = 0\n\n        with self.progress.start('ingest', stage,\n                                 message='Ingesting ' + ('MP' if self.multi else 'SP'),\n                                 item_total=len(sources), item_type='source',\n                                 item_count=len(downloadable_sources)\n                                 ) as ps:\n\n            # Create all of the source tables first, so we can't get contention for creating them\n            # in MP.\n\n            for source in sources:\n                _ = source.source_table\n\n            if self.multi:\n                args = [(self.identity.vid, stage, source.vid, force) for source in downloadable_sources]\n\n                pool = self.library.process_pool(limited_run=self.limited_run)\n\n                try:\n                    # The '1' for chunksize ensures that the subprocess only gets one\n                    # source to build. Combined with maxchildspertask = 1 in the pool,\n                    # each process will only handle one source before exiting.\n                    result = pool.map_async(ingest_mp, args, 1)\n\n                    pool.close()\n                    pool.join()\n\n                except KeyboardInterrupt:\n                    self.log('Got keyboard interrrupt; terminating workers')\n                    pool.terminate()\n                    raise\n            else:\n                for i, source in enumerate(downloadable_sources, 1):\n                    ps.add(\n                        message='Ingesting source #{}, {}'.format(i, source.name),\n                        source=source, state='running')\n                    r = self._ingest_source(source, ps, force)\n                    if not r:\n                        errors += 1\n\n            if errors > 0:\n                from ambry.dbexceptions import IngestionError\n                raise IngestionError('Failed to ingest {} sources'.format(errors))\n\n        return errors", "response": "Ingest a set of sources for one stage"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ningesting a single source", "response": "def _ingest_source(self, source, ps, force=None):\n        \"\"\"Ingest a single source\"\"\"\n        from ambry.bundle.process import call_interval\n\n        try:\n\n            from ambry.orm.exc import NotFoundError\n\n            if not source.is_partition and source.datafile.exists:\n\n                if not source.datafile.is_finalized:\n                    source.datafile.remove()\n                elif force:\n                    source.datafile.remove()\n                else:\n                    ps.update(\n                        message='Source {} already ingested, skipping'.format(source.name),\n                        state='skipped')\n                    return True\n\n            if source.is_partition:\n                # Check if the partition exists\n                try:\n                    self.library.partition(source.ref)\n                except NotFoundError:\n                    # Maybe it is an internal reference, in which case we can just delay\n                    # until the partition is built\n                    ps.update(message=\"Not Ingesting {}: referenced partition '{}' does not exist\"\n                              .format(source.name, source.ref), state='skipped')\n                    return True\n\n            source.state = source.STATES.INGESTING\n\n            iterable_source, source_pipe = self.source_pipe(source, ps)\n\n            if not source.is_ingestible:\n                ps.update(message='Not an ingestiable source: {}'.format(source.name),\n                          state='skipped', source=source)\n                source.state = source.STATES.NOTINGESTABLE\n\n                return True\n\n            ps.update('Ingesting {} from {}'.format(source.spec.name, source.url or source.generator),\n                      item_type='rows', item_count=0)\n\n            @call_interval(5)\n            def ingest_progress_f(i):\n                (desc, n_records, total, rate) = source.datafile.report_progress()\n\n                ps.update(\n                    message='Ingesting {}: rate: {}'.format(source.spec.name, rate), item_count=n_records)\n\n            source.datafile.load_rows(iterable_source,\n                                      callback=ingest_progress_f,\n                                      limit=500 if self.limited_run else None,\n                                      intuit_type=True, run_stats=False)\n\n            if source.datafile.meta['warnings']:\n                for w in source.datafile.meta['warnings']:\n                    self.error(\"Ingestion error: {}\".format(w))\n\n            ps.update(message='Ingested to {}'.format(source.datafile.syspath))\n\n            ps.update(message='Updating tables and specs for {}'.format(source.name))\n\n            # source.update_table()  # Generate the source tables.\n            source.update_spec()  # Update header_lines, start_line, etc.\n\n            if self.limited_run:\n                source.end_line = None  # Otherwize, it will be 500\n\n            self.build_source_files.sources.objects_to_record()\n\n            ps.update(message='Ingested {}'.format(source.datafile.path), state='done')\n            source.state = source.STATES.INGESTED\n            self.commit()\n\n            return True\n\n        except Exception as e:\n            import traceback\n            from ambry.util import qualified_class_name\n\n            ps.update(\n                message='Source {} failed with exception: {}'.format(source.name, e),\n                exception_class=qualified_class_name(e),\n                exception_trace=str(traceback.format_exc()),\n                state='error'\n            )\n\n            source.state = source.STATES.INGESTING + '_error'\n            self.commit()\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef source_schema(self, sources=None, tables=None, clean=False):\n\n        sources = self._resolve_sources(sources, tables, None,\n                                        predicate=lambda s: s.is_processable)\n\n        for source in sources:\n            source.update_table()\n            self.log(\"Creating source schema for '{}': Table {},  {} columns\"\n                     .format(source.name, source.source_table.name, len(source.source_table.columns)))\n\n        self.commit()", "response": "Create a schema for all sources."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef schema(self, sources=None, tables=None, clean=False, force=False, use_pipeline=False):\n        from itertools import groupby\n        from operator import attrgetter\n        from ambry.etl import Collect, Head\n        from ambry.orm.exc import NotFoundError\n\n        self.dstate = self.STATES.BUILDING\n        self.commit()  # Workaround for https://github.com/CivicKnowledge/ambry/issues/171\n\n        self.log('---- Schema ----')\n\n        resolved_sources = self._resolve_sources(sources, tables, predicate=lambda s: s.is_processable)\n\n        if clean:\n            self.dataset.delete_tables_partitions()\n            self.commit()\n\n        # Group the sources by the destination table name\n        keyfunc = attrgetter('dest_table')\n        for t, table_sources in groupby(sorted(resolved_sources, key=keyfunc), keyfunc):\n\n            if use_pipeline:\n                for source in table_sources:\n                    pl = self.pipeline(source)\n\n                    pl.cast = [ambry.etl.CastSourceColumns]\n                    pl.select_partition = []\n                    pl.write = [Head, Collect]\n                    pl.final = []\n\n                    self.log_pipeline(pl)\n\n                    pl.run()\n                    pl.phase = 'build_schema'\n                    self.log_pipeline(pl)\n\n                    for h, c in zip(pl.write[Collect].headers, pl.write[Collect].rows[1]):\n                        c = t.add_column(name=h, datatype=type(c).__name__ if c is not None else 'str',\n                                         update_existing=True)\n\n                self.log(\"Populated destination table '{}' from pipeline '{}'\"\n                         .format(t.name, pl.name))\n\n            else:\n                # Get all of the header names, for each source, associating the header position in the table\n                # with the header, then sort on the postition. This will produce a stream of header names\n                # that may have duplicates, but which is generally in the order the headers appear in the\n                # sources. The duplicates are properly handled when we add the columns in add_column()\n\n                self.commit()\n\n                def source_cols(source):\n                    if source.is_partition and not source.source_table_exists:\n                        return enumerate(source.partition.table.columns)\n\n                    else:\n                        return enumerate(source.source_table.columns)\n\n                columns = sorted(set([(i, col.dest_header, col.datatype, col.description, col.has_codes)\n                                      for source in table_sources for i, col in source_cols(source)]))\n\n                initial_count = len(t.columns)\n\n                for pos, name, datatype, desc, has_codes in columns:\n\n                    kwds = dict(\n                        name=name,\n                        datatype=datatype,\n                        description=desc,\n                        update_existing=True\n                    )\n\n\n                    try:\n                        extant = t.column(name)\n                    except NotFoundError:\n                        extant = None\n\n                    if extant is None or not extant.description:\n                        kwds['description'] = desc\n\n                    c = t.add_column(**kwds)\n\n\n                final_count = len(t.columns)\n\n                if final_count > initial_count:\n                    diff = final_count - initial_count\n\n                    self.log(\"Populated destination table '{}' from source table '{}' with {} columns\"\n                             .format(t.name, source.source_table.name, diff))\n\n        self.commit()\n\n        return True", "response": "Generate destination schemas for the specified sources and tables."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _reset_build(self, sources):\n        from ambry.orm.exc import NotFoundError\n\n        for p in self.dataset.partitions:\n            if p.type == p.TYPE.SEGMENT:\n                self.log(\"Removing old segment partition: {}\".format(p.identity.name))\n                try:\n                    self.wrap_partition(p).local_datafile.remove()\n                    self.session.delete(p)\n                except NotFoundError:\n                    pass\n\n        for s in sources:\n\n            # Don't delete partitions fro mother bundles!\n            if s.reftype == 'partition':\n                continue\n\n            p = s.partition\n            if p:\n                try:\n                    self.wrap_partition(p).local_datafile.remove()\n                    self.session.delete(p)\n                except NotFoundError:\n                    pass\n\n            if s.state in (self.STATES.BUILDING, self.STATES.BUILT):\n                s.state = self.STATES.INGESTED\n\n        self.commit()", "response": "Remove partition datafiles and reset the datafiles to the INGESTED state"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build(self, sources=None, tables=None, stage=None, force=False):\n\n        from operator import attrgetter\n        from itertools import groupby\n        from .concurrent import build_mp, unify_mp\n        from ambry.bundle.events import TAG\n\n        self.log('==== Building ====')\n        self.state = self.STATES.BUILDING\n        self.commit()\n\n        class SourceSet(object):\n            \"\"\"Container for sources that can reload them after they get expired from the session\"\"\"\n            def __init__(self, bundle, v):\n                self.bundle = bundle\n                self.sources = v\n                self._s_vids = [s.vid for s in self.sources]\n\n            def reload(self):\n                self.sources = [self.bundle.source(vid) for vid in self._s_vids]\n\n            def __iter__(self):\n                for s in self.sources:\n                    yield s\n\n            def __len__(self):\n                return len(self._s_vids)\n\n        self._run_events(TAG.BEFORE_BUILD, 0)\n\n        resolved_sources = SourceSet(self, self._resolve_sources(sources, tables, stage=stage,\n                                                                 predicate=lambda s: s.is_processable))\n        with self.progress.start('build', stage, item_total=len(resolved_sources)) as ps:\n\n            if len(resolved_sources) == 0:\n                ps.update(message='No sources', state='skipped')\n                self.log('No processable sources, skipping build stage {}'.format(stage))\n                return True\n\n            if not self.pre_build(force):\n                ps.update(message='Pre-build failed', state='skipped')\n                return False\n\n            if force:\n                self._reset_build(resolved_sources)\n\n            resolved_sources.reload()\n\n            e = [\n                (stage, SourceSet(self, list(stage_sources)))\n                for stage, stage_sources in groupby(sorted(resolved_sources, key=attrgetter('stage')),\n                                                    attrgetter('stage'))\n\n                ]\n\n            for stage, stage_sources in e:\n\n                stage_sources.reload()\n\n                for s in stage_sources:\n                    s.state = self.STATES.WAITING\n                self.commit()\n\n                stage_sources.reload()\n\n                self.log('Processing {} sources, stage {} ; first 10: {}'\n                         .format(len(stage_sources), stage, [x.name for x in stage_sources.sources[:10]]))\n                self._run_events(TAG.BEFORE_BUILD, stage)\n\n                if self.multi:\n\n                    try:\n                        # The '1' for chunksize ensures that the subprocess only gets one\n                        # source to build. Combined with maxchildspertask = 1 in the pool,\n                        # each process will only handle one source before exiting.\n\n                        args = [(self.identity.vid, stage, source.vid, force) for source in stage_sources]\n                        pool = self.library.process_pool(limited_run=self.limited_run)\n                        r = pool.map_async(build_mp, args, 1)\n                        completed_sources = r.get()\n\n                        ps.add('Finished MP building {} sources. Starting MP coalescing'\n                               .format(len(completed_sources)))\n\n                        partition_names = [(self.identity.vid, k) for k, v\n                                           in self.collect_segment_partitions().items()]\n\n                        r = pool.map_async(unify_mp, partition_names, 1)\n\n                        completed_partitions = r.get()\n\n                        ps.add('Finished MP coalescing {} partitions'.format(len(completed_partitions)))\n\n                        pool.close()\n                        pool.join()\n\n                    except KeyboardInterrupt:\n                        self.log('Got keyboard interrrupt; terminating workers')\n                        pool.terminate()\n\n                else:\n\n                    for i, source in enumerate(stage_sources):\n                        id_ = ps.add(message='Running source {}'.format(source.name),\n                                     source=source, item_count=i, state='running')\n\n                        self.build_source(stage, source, ps, force=force)\n\n                        ps.update(message='Finished processing source', state='done')\n\n                        # This bit seems to solve a problem where the records from the ps.add above\n                        # never gets closed out.\n                        ps.get(id_).state = 'done'\n                        self.progress.commit()\n\n                    self.unify_partitions()\n\n                self._run_events(TAG.AFTER_BUILD, stage)\n\n        self.state = self.STATES.BUILT\n        self.commit()\n\n        self._run_events(TAG.AFTER_BUILD, 0)\n\n        self.close_session()\n\n        self.log('==== Done Building ====')\n        self.buildstate.commit()\n        self.state = self.STATES.BUILT\n        self.commit()\n        return True", "response": "Build the bundle and return a new version of the bundle."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_table(self, table, force=False):\n\n        sources = self._resolve_sources(None, [table])\n\n        for source in sources:\n            self.build_source(None, source, force=force)\n\n        self.unify_partitions()", "response": "Build all of the sources for a table"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_source(self, stage, source, ps, force=False):\n        from ambry.bundle.process import call_interval\n\n        assert source.is_processable, source.name\n\n        if source.state == self.STATES.BUILT and not force:\n            ps.update(message='Source {} already built'.format(source.name), state='skipped')\n            return\n\n        pl = self.pipeline(source, ps=ps)\n\n        source.state = self.STATES.BUILDING\n\n        # Doing this before hand to get at least some information about the pipline,\n        # in case there is an error during the run. It will get overwritten with more information\n        # after successful run\n        self.log_pipeline(pl)\n\n        try:\n\n            source_name = source.name  # In case the source drops out of the session, which is does.\n            s_vid = source.vid\n\n            ps.update(message='Running pipeline {}'.format(pl.name), s_vid=s_vid, item_type='rows', item_count=0)\n\n            @call_interval(5)\n            def run_progress_f(sink_pipe, rows):\n                (n_records, rate) = sink_pipe.report_progress()\n                if n_records > 0:\n                    ps.update(message='Running pipeline {}: rate: {}'\n                              .format(pl.name, rate),\n                              s_vid=s_vid, item_type='rows', item_count=n_records)\n\n\n            pl.run(callback=run_progress_f)\n\n            # Run the final routines at the end of the pipelin\n            for f in pl.final:\n                ps.update(message='Run final routine: {}'.format(f.__name__))\n                f(pl)\n\n            ps.update(message='Finished building source')\n\n        except:\n            self.log_pipeline(pl)\n            raise\n\n        self.commit()\n\n        try:\n            partitions = list(pl[ambry.etl.PartitionWriter].partitions)\n            ps.update(message='Finalizing segment partition',\n                      item_type='partitions', item_total=len(partitions), item_count=0)\n            for i, p in enumerate(partitions):\n\n                ps.update(message='Finalizing segment partition {}'.format(p.name), item_count=i, p_vid=p.vid)\n\n                try:\n                    p.finalize()\n                except AttributeError:\n                    print(self.table(p.table_name))\n                    raise\n\n                # FIXME Shouldn't need to do this commit, but without it, some stats get added multiple\n                # times, causing an error later. Probably could be avoided by adding the stats to the\n                # collection in the dataset\n\n                self.commit()\n\n        except IndexError:\n            self.error(\"Pipeline didn't have a PartitionWriters, won't try to finalize\")\n\n        self.log_pipeline(pl)\n        source.state = self.STATES.BUILT\n\n        self.commit()\n\n        return source.name", "response": "Build a single source."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dict of segments partitions keyed on the name of the parent partition", "response": "def collect_segment_partitions(self):\n        \"\"\"Return a dict of segments partitions, keyed on the name of the parent partition\n        \"\"\"\n        from collections import defaultdict\n\n        # Group the segments by their parent partition name, which is the\n        # same name, but without the segment.\n        partitions = defaultdict(set)\n        for p in self.dataset.partitions:\n            if p.type == p.TYPE.SEGMENT:\n                name = p.identity.name\n                name.segment = None\n                partitions[name].add(p)\n\n        return partitions"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate the parent partition and combine the children into the parent partition and delete the children.", "response": "def unify_partitions(self):\n        \"\"\"For all of the segments for a partition, create the parent partition, combine the\n        children into the parent, and delete the children. \"\"\"\n\n        partitions = self.collect_segment_partitions()\n\n        # For each group, copy the segment partitions to the parent partitions, then\n        # delete the segment partitions.\n\n        with self.progress.start('coalesce', 0, message='Coalescing partition segments') as ps:\n\n            for name, segments in iteritems(partitions):\n                ps.add(item_type='partitions', item_count=len(segments),\n                       message='Colescing partition {}'.format(name))\n                self.unify_partition(name, segments, ps)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef exec_context(self, **kwargs):\n        import inspect\n        import dateutil.parser\n        import datetime\n        import random\n        from functools import partial\n        from ambry.valuetype.types import parse_date, parse_time, parse_datetime\n        import ambry.valuetype.types\n        import ambry.valuetype.exceptions\n        import ambry.valuetype.test\n        import ambry.valuetype\n\n\n        def set_from(f, frm):\n            try:\n                try:\n                    f.ambry_from = frm\n                except AttributeError:  # for instance methods\n                    f.im_func.ambry_from = frm\n            except (TypeError, AttributeError):  # Builtins, non python code\n                pass\n\n            return f\n\n        test_env = dict(\n            parse_date=parse_date,\n            parse_time=parse_time,\n            parse_datetime=parse_datetime,\n            partial=partial,\n            bundle=self\n        )\n\n        test_env.update(kwargs)\n        test_env.update(dateutil.parser.__dict__)\n        test_env.update(datetime.__dict__)\n        test_env.update(random.__dict__)\n        test_env.update(ambry.valuetype.core.__dict__)\n        test_env.update(ambry.valuetype.types.__dict__)\n        test_env.update(ambry.valuetype.exceptions.__dict__)\n        test_env.update(ambry.valuetype.test.__dict__)\n        test_env.update(ambry.valuetype.__dict__)\n\n        localvars = {}\n\n        for f_name, func in test_env.items():\n            if not isinstance(func, (str, tuple)):\n                localvars[f_name] = set_from(func, 'env')\n\n        # The 'b' parameter of randint is assumed to be a bundle, but\n        # replacing it with a lambda prevents the param assignment\n        localvars['randint'] = lambda a, b: random.randint(a, b)\n\n        if self != Bundle:\n            # Functions from the bundle\n            base = set(inspect.getmembers(Bundle, predicate=inspect.isfunction))\n            mine = set(inspect.getmembers(self.__class__, predicate=inspect.isfunction))\n\n            localvars.update({f_name: set_from(func, 'bundle') for f_name, func in mine - base})\n\n            # Bound methods. In python 2, these must be called referenced from the bundle, since\n            # there is a difference between bound and unbound methods. In Python 3, there is no differnce,\n            # so the lambda functions may not be necessary.\n            base = set(inspect.getmembers(Bundle, predicate=inspect.ismethod))\n            mine = set(inspect.getmembers(self.__class__, predicate=inspect.ismethod))\n\n            # Functions are descriptors, and the __get__ call binds the function to its object to make a bound method\n            localvars.update({f_name: set_from(func.__get__(self), 'bundle') for f_name, func in (mine - base)})\n\n        # Bundle module functions\n\n        module_entries = inspect.getmembers(sys.modules['ambry.build'], predicate=inspect.isfunction)\n\n\n        localvars.update({f_name: set_from(func, 'module') for f_name, func in module_entries})\n\n        return localvars", "response": "Execute the environment for all evals."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef post_build_time_coverage(self):\n        from ambry.util.datestimes import expand_to_years\n\n        years = set()\n\n        # From the bundle about\n        if self.metadata.about.time:\n            for year in expand_to_years(self.metadata.about.time):\n                years.add(year)\n\n        # From the bundle name\n        if self.identity.btime:\n            for year in expand_to_years(self.identity.btime):\n                years.add(year)\n\n        # From all of the partitions\n        for p in self.partitions:\n            years |= set(p.time_coverage)", "response": "Collect all of the time coverage for the bundle."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef post_build_geo_coverage(self):\n\n        spaces = set()\n        grains = set()\n\n        def resolve(term):\n            places = list(self.library.search.search_identifiers(term))\n\n            if not places:\n                raise BuildError(\n                    \"Failed to find space identifier '{}' in full text identifier search\".format(term))\n\n            return places[0].vid\n\n        if self.metadata.about.space:  # From the bundle metadata\n            spaces.add(resolve(self.metadata.about.space))\n\n        if self.metadata.about.grain:  # From the bundle metadata\n            grains.add(self.metadata.about.grain)\n\n        if self.identity.bspace:  # And from the bundle name\n            spaces.add(resolve(self.identity.bspace))\n\n        # From all of the partitions\n        for p in self.partitions.all:\n            if 'geo_coverage' in p.record.data:\n                for space in p.record.data['geo_coverage']:\n                    spaces.add(space)\n\n            if 'geo_grain' in p.record.data:\n                for grain in p.record.data['geo_grain']:\n                    grains.add(grain)\n\n        def conv_grain(g):\n            \"\"\"Some grain are expressed as summary level names, not gvids.\"\"\"\n            try:\n                c = GVid.get_class(g)\n                return b(c().summarize())\n            except NotASummaryName:\n                return g\n\n        self.metadata.coverage.geo = sorted(spaces)\n        self.metadata.coverage.grain = sorted(conv_grain(g) for g in grains)\n\n        self.metadata.write_to_dir()", "response": "Collect all of the geocoverage for the bundle and write the metadata. coverage. geo and metadata. coverage. grain."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if the bundle is finalized.", "response": "def is_finalized(self):\n        \"\"\"Return True if the bundle is installed.\"\"\"\n\n        return self.state == self.STATES.FINALIZED or self.state == self.STATES.INSTALLED"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _run_events(self, tag, stage=None):\n\n        self._run_event_methods(tag, stage)\n        self._run_tests(tag, stage)", "response": "Run events marked with a particular tag and stage"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun code in the bundle that is marked with events.", "response": "def _run_event_methods(self, tag, stage=None):\n        \"\"\"Run code in the bundle that is marked with events. \"\"\"\n        import inspect\n        from ambry.bundle.events import _runable_for_event\n\n        funcs = []\n\n        for func_name, f in inspect.getmembers(self, predicate=inspect.ismethod):\n            if _runable_for_event(f, tag, stage):\n                funcs.append(f)\n\n        for func in funcs:\n            func()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_installed(self):\n\n        r = self.library.resolve(self.identity.vid)\n\n        return r is not None", "response": "Return True if the bundle is installed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef exclude(prop):\n    '''Don't replicate property that is normally replicated: ordering column,\n    many-to-one relation that is marked for replication from other side.'''\n    if isinstance(prop, QueryableAttribute):\n        prop = prop.property\n    assert isinstance(prop, (Column, ColumnProperty, RelationshipProperty))\n    _excluded.add(prop)\n    if isinstance(prop, RelationshipProperty):\n        # Also exclude columns that participate in this relationship\n        for local in prop.local_columns:\n            _excluded.add(local)", "response": "Don t replicate property that is normally replicated : ordering column many - to - one relation that is marked for replication from other side."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds an object of class model with the same identifier as the source object", "response": "def reflect(source, model, cache=None):\n    '''Finds an object of class `model` with the same identifier as the\n    `source` object'''\n    if source is None:\n        return None\n    if cache and source in cache:\n        return cache[source]\n    db = object_session(source)\n    ident = identity_key(instance=source)[1]\n    assert ident is not None\n    return db.query(model).get(ident)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreplicate common SQLAlchemy attributes from the source object to the target object.", "response": "def replicate_attributes(source, target, cache=None):\n    '''Replicates common SQLAlchemy attributes from the `source` object to the\n    `target` object.'''\n    target_manager = manager_of_class(type(target))\n    column_attrs = set()\n    relationship_attrs = set()\n    relationship_columns = set()\n    for attr in manager_of_class(type(source)).attributes:\n        if attr.key not in target_manager:\n            # It's not common attribute\n            continue\n        target_attr = target_manager[attr.key]\n        if isinstance(attr.property, ColumnProperty):\n            assert isinstance(target_attr.property, ColumnProperty)\n            column_attrs.add(attr)\n        elif isinstance(attr.property, RelationshipProperty):\n            assert isinstance(target_attr.property, RelationshipProperty)\n            relationship_attrs.add(attr)\n            if attr.property.direction is MANYTOONE:\n                relationship_columns.update(attr.property.local_columns)\n    for attr in column_attrs:\n        if _column_property_in_registry(attr.property, _excluded):\n            continue\n        elif (not _column_property_in_registry(attr.property, _included) and\n                 all(column in relationship_columns\n                     for column in attr.property.columns)):\n            continue\n        setattr(target, attr.key, getattr(source, attr.key))\n    for attr in relationship_attrs:\n        target_attr_model = target_manager[attr.key].property.argument\n        if not is_relation_replicatable(attr):\n            continue\n        replicate_relation(source, target, attr, target_manager[attr.key],\n                           cache=cache)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreplicating the source object to model class and returns its reflection.", "response": "def replicate_no_merge(source, model, cache=None):\n    '''Replicates the `source` object to `model` class and returns its\n    reflection.'''\n    # `cache` is used to break circular dependency: we need to replicate\n    # attributes before merging target into the session, but replication of\n    # some attributes may require target to be in session to avoid infinite\n    # loop.\n    if source is None:\n        return None\n    if cache is None:\n        cache = {}\n    elif source in cache:\n        return cache[source]\n    db = object_session(source)\n    cls, ident = identity_key(instance=source)\n    target = db.query(model).get(ident)\n    if target is None:\n        target = model()\n    cache[source] = target\n    try:\n        replicate_attributes(source, target, cache=cache)\n    except _PrimaryKeyIsNull:\n        return None\n    else:\n        return target"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef replicate(source, model, cache=None):\n    '''Replicates the `source` object to `model` class and returns its\n    reflection.'''\n    target = replicate_no_merge(source, model, cache=cache)\n    if target is not None:\n        db = object_session(source)\n        target = db.merge(target)\n    return target", "response": "Replicates the source object to model class and returns its\n    reflection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replicate_filter(sources, model, cache=None):\n    '''Replicates the list of objects to other class and returns their\n    reflections'''\n    targets = [replicate_no_merge(source, model, cache=cache)\n               for source in sources]\n    # Some objects may not be available in target DB (not published), so we\n    # have to exclude None from the list.\n    return [target for target in targets if target is not None]", "response": "Replicates the list of objects to other class and returns their\n    reflections"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of reflections of objects in the source list to other class. Objects that are not found in target table are silently discarded.", "response": "def reflect_filter(sources, model, cache=None):\n    '''Returns the list of reflections of objects in the `source` list to other\n    class. Objects that are not found in target table are silently discarded.\n    '''\n    targets = [reflect(source, model, cache=cache) for source in sources]\n    # Some objects may not be available in target DB (not published), so we\n    # have to exclude None from the list.\n    return [target for target in targets if target is not None]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef valuetype_class(self):\n\n        from ambry.valuetype import resolve_value_type\n\n        if self.valuetype:\n            return resolve_value_type(self.valuetype)\n\n        else:\n            return resolve_value_type(self.datatype)", "response": "Return the valuetype class if one is defined or a built - in type if it isn t."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the python type for the row possibly getting it from a valuetype reference", "response": "def python_type(self):\n        \"\"\"Return the python type for the row, possibly getting it from a valuetype reference \"\"\"\n\n        from ambry.valuetype import resolve_value_type\n\n        if self.valuetype and resolve_value_type(self.valuetype):\n            return resolve_value_type(self.valuetype)._pythontype\n\n        elif self.datatype:\n            try:\n                return self.types[self.datatype][1]\n            except KeyError:\n                return resolve_value_type(self.datatype)._pythontype\n\n        else:\n            from ambry.exc import ConfigurationError\n            raise ConfigurationError(\"Can't get python_type: neither datatype of valuetype is defined\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef role(self):\n        '''Return the code for the role,  measure, dimension or error'''\n        from ambry.valuetype.core import ROLE\n\n        if not self.valuetype_class:\n            return ''\n\n        role = self.valuetype_class.role\n        if role == ROLE.UNKNOWN:\n            vt_code = self.valuetype_class.vt_code\n\n            if len(vt_code) == 1 or vt_code[1] == '/':\n                return vt_code[0]\n            else:\n                return ''\n\n        return role", "response": "Return the code for the role measure dimension or error"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn true if the colum is a dimension", "response": "def is_dimension(self):\n        \"\"\"Return true if the colum is a dimension\"\"\"\n        from ambry.valuetype.core import ROLE\n        return self.role == ROLE.DIMENSION"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_measure(self):\n        from ambry.valuetype.core import ROLE\n        return self.role == ROLE.MEASURE", "response": "Return true if the colum is a dimension"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning true if the colum is a dimension", "response": "def is_label(self):\n        \"\"\"Return true if the colum is a dimension\"\"\"\n        from ambry.valuetype.core import ROLE\n        return self.role == ROLE.LABEL"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if the colum is an error dimension", "response": "def is_error(self):\n        \"\"\"Return true if the colum is a dimension\"\"\"\n        from ambry.valuetype.core import ROLE\n        return self.role == ROLE.ERROR"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the table s other column that have this column as a parent excluding labels", "response": "def children(self):\n        \"\"\"\"Return the table's other column that have this column as a parent, excluding labels\"\"\"\n        for c in self.table.columns:\n            if c.parent == self.name and  not c.valuetype_class.is_label():\n                yield c"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning first child of the column that is marked as a label. Returns self if the column is a label. Returns None if the column is a label. Returns self if the column is a label. Returns self if the column is a label. Returns None if the column is a label. Returns self if the column is a label. Returns None if the column is a label.", "response": "def label(self):\n        \"\"\"\"Return first child of the column that is marked as a label. Returns self if the column is a label\"\"\"\n\n        if self.valuetype_class.is_label():\n            return self\n\n        for c in self.table.columns:\n            if c.parent == self.name and  c.valuetype_class.is_label():\n                return c\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef geoid(self):\n\n        if self.valuetype_class.is_geoid():\n            return self\n\n        for c in self.table.columns:\n            if c.parent == self.name and  c.valuetype_class.is_geoid():\n                return c", "response": "Return first child of the column or self that is marked as a geographic identifier"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef python_cast(self, v):\n\n        if self.type_is_time():\n            dt = dateutil.parser.parse(v)\n\n            if self.datatype == Column.DATATYPE_TIME:\n                dt = dt.time()\n            if not isinstance(dt, self.python_type):\n                raise TypeError('{} was parsed to {}, expected {}'.format(v, type(dt), self.python_type))\n\n            return dt\n        else:\n            # This isn't calling the python_type method -- it's getting a python type, then instantialting it,\n            # such as \"int(v)\"\n            return self.python_type(v)", "response": "Cast a value to the type of the column."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_numpy_type(cls, dtype):\n\n        m = {\n            'int64': cls.DATATYPE_INTEGER64,\n            'float64': cls.DATATYPE_FLOAT,\n            'object': cls.DATATYPE_TEXT  # Hack. Pandas makes strings into object.\n        }\n\n        t = m.get(dtype.name, None)\n\n        if not t:\n            raise TypeError(\n                \"Failed to convert numpy type: '{}' \".format(\n                    dtype.name))\n\n        return t", "response": "Convert a numpy dtype into a Column datatype. Only handles common\n        types. Only handles numpy types."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dict(self):\n        d = {p.key: getattr(self, p.key) for p in self.__mapper__.attrs\n             if p.key not in ('table', 'stats', '_codes', 'data')}\n\n        if not d:\n            raise Exception(self.__dict__)\n\n        d['schema_type'] = self.schema_type\n\n        if self.data:\n            # Copy data fields into top level dict, but don't overwrite existind values.\n            for k, v in six.iteritems(self.data):\n                if k not in d and k not in ('table', 'stats', '_codes', 'data'):\n                    d[k] = v\n\n        return d", "response": "A dict that holds all of the properties in the the\nTaxonomy object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nonull_dict(self):\n        return {k: v for k, v in six.iteritems(self.dict) if v and k != '_codes'}", "response": "Like dict but does not hold any null values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mangle_name(name):\n        import re\n        try:\n            return re.sub('_+', '_', re.sub('[^\\w_]', '_', name).lower()).rstrip('_')\n        except TypeError:\n            raise TypeError(\n                'Trying to mangle name with invalid type of: ' + str(type(name)))", "response": "Mangles a column name to a standard form remoing illegal\n        characters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reverse_code_map(self):\n\n        return {c.value: (c.ikey if c.ikey else c.key) for c in self.codes}", "response": "Return a map from a code to the shorter numeric value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexpand the transform string into segments", "response": "def expanded_transform(self):\n        \"\"\"Expands the transform string into segments \"\"\"\n\n        segments = self._expand_transform(self.transform)\n\n        if segments:\n\n            segments[0]['datatype'] = self.valuetype_class\n\n            for s in segments:\n                s['column'] = self\n\n        else:\n\n            segments = [self.make_xform_seg(datatype=self.valuetype_class, column=self)]\n\n        # If we want to add the find datatype cast to a transform.\n        #segments.append(self.make_xform_seg(transforms=[\"cast_\"+self.datatype], column=self))\n\n        return segments"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef before_insert(mapper, conn, target):\n\n        # from identity import ObjectNumber\n        # assert not target.fk_vid or not ObjectNumber.parse(target.fk_vid).revision\n\n        if target.sequence_id is None:\n            from ambry.orm.exc import DatabaseError\n            raise DatabaseError('Must have sequence_id before insertion')\n\n        # Check that the id column is always sequence id 1\n        assert (target.name == 'id') == (target.sequence_id == 1), (target.name, target.sequence_id)\n\n        Column.before_update(mapper, conn, target)", "response": "event. listen method for Sqlalchemy to set the seqience_id for this object and create an ObjectNumber value for the id_"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the column id number based on the table number and the sequence number for the column.", "response": "def before_update(mapper, conn, target):\n        \"\"\"Set the column id number based on the table number and the sequence\n        id for the column.\"\"\"\n\n        assert target.datatype or target.valuetype\n\n        target.name = Column.mangle_name(target.name)\n\n        Column.update_number(target)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlaunch a process with a particular Python environment.", "response": "def spawnProcess(processProtocol, executable, args=(), env={},\n                 path=None, uid=None, gid=None, usePTY=0,\n                 packages=()):\n    \"\"\"Launch a process with a particular Python environment.\n\n    All arguments as to reactor.spawnProcess(), except for the\n    addition of an optional packages iterable.  This should be\n    of strings naming packages the subprocess is to be able to\n    import.\n    \"\"\"\n\n    env = env.copy()\n\n    pythonpath = []\n    for pkg in packages:\n        p = os.path.split(imp.find_module(pkg)[1])[0]\n        if p.startswith(os.path.join(sys.prefix, 'lib')):\n            continue\n        pythonpath.append(p)\n    pythonpath = list(set(pythonpath))\n    pythonpath.extend(env.get('PYTHONPATH', '').split(os.pathsep))\n    env['PYTHONPATH'] = os.pathsep.join(pythonpath)\n\n    return reactor.spawnProcess(processProtocol, executable, args,\n                                env, path, uid, gid, usePTY)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlaunches a Python process.", "response": "def spawnPythonProcess(processProtocol, args=(), env={},\n                       path=None, uid=None, gid=None, usePTY=0,\n                       packages=()):\n    \"\"\"Launch a Python process\n\n    All arguments as to spawnProcess(), except the executable\n    argument is omitted.\n    \"\"\"\n    return spawnProcess(processProtocol, sys.executable,\n                        args, env, path, uid, gid, usePTY,\n                        packages)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _runable_for_event(f, tag, stage):\n\n    if not hasattr(f, '__ambry_event__'):\n        return False\n\n    f_tag, f_stage = f.__ambry_event__\n\n    if stage is None:\n        stage = 0\n\n    if tag != f_tag or stage != f_stage:\n        return False\n\n    return True", "response": "Check if a function is run at this stage."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload a python object from an import path.", "response": "def load_obj_from_path(import_path, prefix=None, ld=dict()):\n    \"\"\"\n    import a python object from an import path\n\n    `import_path` - a python import path.  For instance:\n            mypackage.module.func\n        or\n            mypackage.module.class\n    `prefix` (str) - a value to prepend to the import path\n        if it isn't already there.  For instance:\n            load_obj_from_path('module.func', prefix='mypackage')\n        is the same as\n            load_obj_from_path('mypackage.module.func')\n    `ld` (dict) key:value data to pass to the logger if an error occurs\n    \"\"\"\n    if prefix and not import_path.startswith(prefix):\n        import_path = '.'.join([prefix, import_path])\n\n    log.debug(\n        'attempting to load a python object from an import path',\n        extra=dict(import_path=import_path, **ld))\n    try:\n        mod = importlib.import_module(import_path)\n        return mod  # yay, we found a module.  return it\n    except:\n        pass  # try to extract an object from a module\n    try:\n        path, obj_name = import_path.rsplit('.', 1)\n    except ValueError:\n        log_raise(\n            (\"import path needs at least 1 period in your import path.\"\n             \" An example import path is something like: module.obj\"),\n            dict(import_path=import_path, **ld), InvalidImportPath)\n    try:\n        mod = importlib.import_module(path)\n    except ImportError:\n        newpath = path.replace(prefix, '', 1).lstrip('.')\n        log.debug(\n            \"Could not load import path.  Trying a different one\",\n            extra=dict(oldpath=path, newpath=newpath))\n        path = newpath\n        mod = importlib.import_module(path)\n    try:\n        obj = getattr(mod, obj_name)\n    except AttributeError:\n        log_raise(\n            (\"object does not exist in given module.\"\n             \" Your import path is not\"\n             \" properly defined because the given `obj_name` does not exist\"),\n            dict(import_path=path, obj_name=obj_name, **ld),\n            InvalidImportPath)\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the artifact_quality of this ArtifactRest.", "response": "def artifact_quality(self, artifact_quality):\n        \"\"\"\n        Sets the artifact_quality of this ArtifactRest.\n\n        :param artifact_quality: The artifact_quality of this ArtifactRest.\n        :type: str\n        \"\"\"\n        allowed_values = [\"NEW\", \"VERIFIED\", \"TESTED\", \"DEPRECATED\", \"BLACKLISTED\", \"DELETED\", \"TEMPORARY\"]\n        if artifact_quality not in allowed_values:\n            raise ValueError(\n                \"Invalid value for `artifact_quality` ({0}), must be one of {1}\"\n                .format(artifact_quality, allowed_values)\n            )\n\n        self._artifact_quality = artifact_quality"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of tuples containing the names datatype and position of the columns in the table.", "response": "def _get_sqlite_columns(connection, table):\n    \"\"\" Returns list of tuple containg columns of the table.\n\n    Args:\n        connection: sqlalchemy connection to sqlite database.\n        table (str): name of the table\n\n    Returns:\n        list of (name, datatype, position): where name is column name, datatype is\n            python type of the column, position is ordinal position of the column.\n\n    \"\"\"\n    # TODO: Move to the sqlite wrapper.\n    # TODO: Consider sqlalchemy mapping.\n    SQL_TO_PYTHON_TYPES = {\n        'INT': int,\n        'INTEGER': int,\n        'TINYINT': int,\n        'SMALLINT': int,\n        'MEDIUMINT': int,\n        'BIGINT': int,\n        'UNSIGNED BIG INT': int,\n        'INT': int,\n        'INT8': int,\n        'NUMERIC': float,\n        'REAL': float,\n        'FLOAT': float,\n        'DOUBLE': float,\n        'BOOLEAN': bool,\n        'CHARACTER': str,\n        'VARCHAR': str,\n        'TEXT': str\n    }\n    query = 'PRAGMA table_info(\\'{}\\');'\n    result = connection.execute(query.format(table))\n    ret = []\n\n    for row in result:\n        position = row[0] + 1\n        name = row[1]\n        datatype = row[2]\n        try:\n            datatype = SQL_TO_PYTHON_TYPES[datatype]\n        except KeyError:\n            raise Exception(\n                'Do not know how to convert {} sql datatype to python data type.'\n                .format(datatype))\n        ret.append((name, datatype, position))\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef partition(self):\n\n        if self.urltype != 'partition':\n            return None\n\n        return self._bundle.library.partition(self.url)", "response": "Returns the partition specified by the ref"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef datafile(self):\n        from ambry_sources import MPRowsFile\n\n        if self._datafile is None:\n            if self.urltype == 'partition':\n                    self._datafile = self.partition.datafile\n            else:\n                self._datafile = MPRowsFile(self._bundle.build_ingest_fs, self.name)\n\n        return self._datafile", "response": "Return an MPR datafile from the build filesystem"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a SourceSpec to describe this source", "response": "def spec(self):\n        \"\"\"Return a SourceSpec to describe this source\"\"\"\n        from ambry_sources.sources import SourceSpec\n\n        d = self.dict\n        d['url'] = self.url\n\n        # Will get the URL twice; once as ref and once as URL, but the ref is ignored\n\n        return SourceSpec(**d)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef account(self):\n        from ambry.util import parse_url_to_dict\n\n        d = parse_url_to_dict(self.url)\n\n        return self._bundle.library.account(d['netloc'])", "response": "Return an account record based on the host in the url"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_table(self, unknown_type='str'):\n        from ambry_sources.intuit import TypeIntuiter\n\n        st = self.source_table\n\n        if self.reftype == 'partition':\n            for c in self.partition.table.columns:\n                st.add_column(c.sequence_id, source_header=c.name, dest_header=c.name,\n                              datatype=c.datatype, description = c.description)\n\n        elif self.datafile.exists:\n            with self.datafile.reader as r:\n\n                names = set()\n\n                for col in r.columns:\n\n                    name = col['name']\n\n                    if name in names:  # Handle duplicate names.\n                        name = name+\"_\"+str(col['pos'])\n\n                    names.add(name)\n\n                    c = st.column(name)\n\n                    dt = col['resolved_type'] if col['resolved_type'] != 'unknown' else unknown_type\n\n                    if c:\n                        c.datatype = TypeIntuiter.promote_type(c.datatype, col['resolved_type'])\n\n                    else:\n\n                        c = st.add_column(col['pos'],\n                                          source_header=name,\n                                          dest_header=name,\n                                          datatype=col['resolved_type'],\n                                          description=col['description'],\n                                          has_codes=col['has_codes'])", "response": "Update the source table from the datafile"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the source specification with information from the row intuiter but only if the values are not already set.", "response": "def update_spec(self):\n        \"\"\"Update the source specification with information from the row intuiter, but only if the spec values\n        are not already set. \"\"\"\n\n        if self.datafile.exists:\n            with self.datafile.reader as r:\n\n                self.header_lines = r.info['header_rows']\n                self.comment_lines = r.info['comment_rows']\n                self.start_line = r.info['data_start_row']\n                self.end_line = r.info['data_end_row']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dict(self):\n        SKIP_KEYS = ('_source_table', '_dest_table', 'd_vid', 't_vid', 'st_id',\n                     'dataset', 'hash', 'process_records')\n        return OrderedDict([(k, getattr(self, k)) for k in self.properties if k not in SKIP_KEYS])", "response": "A dict that holds all of the properties in the the\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_runconfig(path=None, root=None, db=None):\n\n    return load(path, root=root, db=db)", "response": "Load the main configuration files and accounts file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading all of the config files.", "response": "def load(path=None, root=None, db=None, load_user=True):\n    \"Load all of the config files. \"\n\n    config = load_config(path, load_user=load_user)\n\n    remotes = load_remotes(path, load_user=load_user)\n\n    # The external file overwrites the main config\n    if remotes:\n        if not 'remotes' in config:\n            config.remotes = AttrDict()\n\n        for k, v in remotes.remotes.items():\n            config.remotes[k] = v\n\n    accounts = load_accounts(path, load_user=load_user)\n\n    # The external file overwrites the main config\n    if accounts:\n        if not 'accounts' in config:\n            config.accounts = AttrDict()\n        for k, v in accounts.accounts.items():\n            config.accounts[k] = v\n\n    update_config(config)\n\n    if root:\n        config.library.filesystem_root = root\n\n    if db:\n        config.library.database = db\n\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_config_file(file_name, extra_path=None, load_user=True):\n\n    paths = []\n\n    if extra_path is not None:\n        paths.append(extra_path)\n\n    if os.getenv(ENVAR.CONFIG):\n        paths.append(os.getenv(ENVAR.CONFIG))\n\n    if os.getenv(ENVAR.VIRT):\n        paths.append(os.path.join(os.getenv(ENVAR.VIRT), USER_DIR))\n\n    if load_user:\n        paths.append(os.path.expanduser('~/' + USER_DIR))\n\n    paths.append(ROOT_DIR)\n\n    for path in paths:\n        if os.path.isdir(path) and os.path.exists(os.path.join(path, file_name)):\n            f = os.path.join(path, file_name)\n            return f\n\n    raise ConfigurationError(\n        \"Failed to find configuration file '{}'. Looked for : {} \".format(file_name, paths))", "response": "Find a configuration file in one of the directories."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading the yaml account files ArcGIS", "response": "def load_accounts(extra_path=None, load_user=True):\n    \"\"\"Load the yaml account files\n\n    :param load_user:\n    :return: An `AttrDict`\n    \"\"\"\n\n    from os.path import getmtime\n\n\n    try:\n        accts_file = find_config_file(ACCOUNTS_FILE, extra_path=extra_path, load_user=load_user)\n    except ConfigurationError:\n        accts_file = None\n\n    if accts_file is not None and os.path.exists(accts_file):\n        config = AttrDict()\n        config.update_yaml(accts_file)\n\n        if not 'accounts' in config:\n            config.remotes = AttrDict()\n\n        config.accounts.loaded = [accts_file, getmtime(accts_file)]\n        return config\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload the YAML remotes file which sort of combines the Accounts file with part of the remotes sections from the main config file.", "response": "def load_remotes(extra_path=None, load_user=True):\n    \"\"\"Load the YAML remotes file, which sort of combines the Accounts file with part of the\n    remotes sections from the main config\n\n    :return: An `AttrDict`\n    \"\"\"\n\n    from os.path import getmtime\n\n    try:\n        remotes_file = find_config_file(REMOTES_FILE, extra_path=extra_path, load_user=load_user)\n    except ConfigurationError:\n        remotes_file = None\n\n\n    if remotes_file is not None and os.path.exists(remotes_file):\n        config = AttrDict()\n        config.update_yaml(remotes_file)\n\n        if not 'remotes' in config:\n            config.remotes = AttrDict()\n\n        config.remotes.loaded = [remotes_file, getmtime(remotes_file)]\n\n        return config\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_config(path=None, load_user=True):\n\n    from os.path import getmtime\n\n    config = AttrDict()\n\n    if not path:\n        path = ROOT_DIR\n\n    config_file = find_config_file(CONFIG_FILE, extra_path=path, load_user=load_user)\n\n    if os.path.exists(config_file):\n\n        config.update_yaml(config_file)\n        config.loaded = [config_file, getmtime(config_file)]\n\n    else:\n        # Probably never get here, since the find_config_dir would have thrown a ConfigurationError\n        config = AttrDict()\n        config.loaded = [None, 0]\n\n    return config", "response": "Load configuration information from a config file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the configuration from environmental variables.", "response": "def update_config(config, use_environ=True):\n    \"\"\"Update the configuration from environmental variables. Updates:\n\n    - config.library.database from the AMBRY_DB environmental variable.\n    - config.library.filesystem_root from the AMBRY_ROOT environmental variable.\n    - config.accounts.password from the AMBRY_PASSWORD  environmental variable.\n\n    :param config: An `attrDict` of configuration information.\n    \"\"\"\n    from ambry.util import select_from_url\n\n\n    try:\n        _ = config.library\n    except KeyError:\n        config.library = AttrDict()\n\n    try:\n        _ = config.filesystem\n    except KeyError:\n        config.filesystem = AttrDict()\n\n    try:\n        _ = config.accounts\n    except KeyError:\n        config.accounts = AttrDict()\n\n    if not config.accounts.get('loaded'):\n        config.accounts.loaded = [None, 0]\n\n    try:\n        _ = config.accounts.password\n    except KeyError:\n        config.accounts.password = None\n\n    try:\n        _ = config.remotes\n    except KeyError:\n        config.remotes = AttrDict()  # Default empty\n\n    if not config.remotes.get('loaded'):\n        config.remotes.loaded = [None, 0]\n\n    if use_environ:\n        if os.getenv(ENVAR.DB):\n            config.library.database = os.getenv(ENVAR.DB)\n\n        if os.getenv(ENVAR.ROOT):\n            config.library.filesystem_root = os.getenv(ENVAR.ROOT)\n\n        if os.getenv(ENVAR.PASSWORD):\n            config.accounts.password = os.getenv(ENVAR.PASSWORD)\n\n    # Move any remotes that were configured under the library to the remotes section\n\n    try:\n        for k, v in config.library.remotes.items():\n            config.remotes[k] = {\n                'url': v\n            }\n\n        del config.library['remotes']\n\n    except KeyError as e:\n        pass\n\n    # Then move any of the account entries that are linked to remotes into the remotes.\n\n    try:\n        for k, v in config.remotes.items():\n            if 'url' in v:\n                host = select_from_url(v['url'], 'netloc')\n                if host in config.accounts:\n                    config.remotes[k].update(config.accounts[host])\n                    del config.accounts[host]\n\n    except KeyError:\n        pass\n\n\n    # Set a default for the library database\n    try:\n        _ = config.library.database\n    except KeyError:\n        config.library.database = 'sqlite:///{root}/library.db'\n\n    # Raise exceptions on missing items\n    checks = [\n        'config.library.filesystem_root',\n    ]\n\n    for check in checks:\n        try:\n            _ = eval(check)\n        except KeyError:\n            raise ConfigurationError(\"Configuration is missing '{}'; loaded from {} \"\n                                     .format(check, config.loaded[0]))\n\n    _, config.library.database = normalize_dsn_or_dict(config.library.database)\n\n    for k, v in filesystem_defaults.items():\n        if k not in config.filesystem:\n            config.filesystem[k] = v\n\n    config.modtime = max(config.loaded[1], config.remotes.loaded[1], config.accounts.loaded[1])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef normalize_dsn_or_dict(d):\n    if isinstance(d, dict):\n\n        try:\n            # Convert from an AttrDict to a real dict\n            d = d.to_dict()\n        except AttributeError:\n            pass  # Already a real dict\n\n        config = d\n        dsn = None\n\n    elif isinstance(d, string_types):\n        config = None\n        dsn = d\n\n    else:\n        raise ConfigurationError(\"Can't deal with database config '{}' type '{}' \".format(d, type(d)))\n\n    if dsn:\n\n        if dsn.startswith('sqlite') or dsn.startswith('spatialite'):\n            driver, path = dsn.split(':', 1)\n\n            slashes, path = path[:2], path[2:]\n\n            if slashes != '//':\n                raise ConfigurationError(\"Sqlite DSNs must start with at least 2 slashes\")\n\n            if len(path) == 1 and path[0] == '/':\n                raise ConfigurationError(\"Sqlite DSNs can't have only 3 slashes in path\")\n\n            if len(path) > 1 and path[0] != '/':\n                raise ConfigurationError(\"Sqlite DSNs with a path must have 3 or 4 slashes.\")\n\n            path = path[1:]\n\n            config = dict(\n                server=None,\n                username=None,\n                password=None,\n                driver=driver,\n                dbname=path\n            )\n        else:\n\n            d = parse_url_to_dict(dsn)\n\n            config = dict(\n                server=d['hostname'],\n                dbname=d['path'].strip('/'),\n                driver=d['scheme'],\n                password=d.get('password', None),\n                username=d.get('username', None)\n            )\n    else:\n        up = d.get('username', '') or ''\n\n        if d.get('password'):\n\n            up += ':' + d.get('password', '')\n\n        if up:\n            up += '@'\n\n        if up and not d.get('server'):\n            raise ConfigurationError(\"Can't construct a DSN with a username or password without a hostname\")\n\n        host_part = up + d.get('server', '') if d.get('server') else ''\n\n        if d.get('dbname', False):\n            path_part = '/' + d.get('dbname')\n\n            # if d['driver'] in ('sqlite3', 'sqlite', 'spatialite'):\n            #     path_part = '/' + path_part\n\n        else:\n            path_part = ''  # w/ no dbname, Sqlite should use memory, which required 2 slash. Rel dir is 3, abs dir is 4\n\n        dsn = '{}://{}{}'.format(d['driver'], host_part, path_part)\n\n    return config, dsn", "response": "Normalizes a DSN or dict version of a database DSN or dict version of a DSN or dict version of a DSN."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new ProductVersion for a ProductVersionSingleton clf", "response": "def create_new_product_version(self, **kwargs):\n        \"\"\"\n        Create a new ProductVersion for a Product\n        \n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.create_new_product_version(callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param ProductVersionRest body:\n        :return: ProductVersionSingleton\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.create_new_product_version_with_http_info(**kwargs)\n        else:\n            (data) = self.create_new_product_version_with_http_info(**kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a list of build configuration sets associated with a product version.", "response": "def get_build_configuration_sets(self, id, **kwargs):\n        \"\"\"\n        Gets build configuration sets associated with a product version\n        \n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.get_build_configuration_sets(id, callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param int id: Product Version id (required)\n        :param int page_index: Page Index\n        :param int page_size: Pagination size\n        :param str sort: Sorting RSQL\n        :param str q: RSQL Query\n        :return: BuildConfigurationSetPage\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.get_build_configuration_sets_with_http_info(id, **kwargs)\n        else:\n            (data) = self.get_build_configuration_sets_with_http_info(id, **kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate a build configuration set with the specified id.", "response": "def update_build_configuration_sets(self, id, **kwargs):\n        \"\"\"\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.update_build_configuration_sets(id, callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param int id: Product Version id (required)\n        :param list[BuildConfigurationSetRest] body:\n        :return: None\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.update_build_configuration_sets_with_http_info(id, **kwargs)\n        else:\n            (data) = self.update_build_configuration_sets_with_http_info(id, **kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef execute_command(cmd, execute, echo=True):\n    if execute:\n        if echo:\n            print(\"Executing: \" + cmd)\n        return os.system(cmd)\n    else:\n        print(cmd)\n        return 0", "response": "Execute a command in shell or just print it"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the desired log level.", "response": "def set_log_level(level):\n    \"\"\"Sets the desired log level.\"\"\"\n    lLevel = level.lower()\n    unrecognized = False\n    if (lLevel == 'debug-all'):\n        loglevel = logging.DEBUG\n    elif (lLevel == 'debug'):\n        loglevel = logging.DEBUG\n    elif (lLevel == 'info'):\n        loglevel = logging.INFO\n    elif (lLevel == 'warning'):\n        loglevel = logging.WARNING\n    elif (lLevel == 'error'):\n        loglevel = logging.ERROR\n    elif (lLevel == 'critical'):\n        loglevel = logging.CRITICAL\n    else:\n        loglevel = logging.DEBUG\n        unrecognized = True\n    formatter = logging.Formatter('%(asctime)s %(levelname)s %(filename)s:%(lineno)d/%(funcName)s: %(message)s')\n    console = logging.StreamHandler()\n    console.setLevel(loglevel)\n    console.setFormatter(formatter)\n    logging.getLogger('').addHandler(console)\n    logging.getLogger('').setLevel(loglevel)\n    #logging.basicConfig(format='%(asctime)s %(levelname)s %(filename)s:%(lineno)d/%(funcName)s: %(message)s', level=loglevel)\n    if lLevel != 'debug-all':\n        # lower the loglevel for enumerated packages to avoid unwanted messages\n        packagesWarning = [\"requests.packages.urllib3\", \"urllib3\", \"requests_kerberos\", \"jenkinsapi\"]\n        for package in packagesWarning:\n            logging.debug(\"Setting loglevel for %s to WARNING.\", package)\n            logger = logging.getLogger(package)\n            logger.setLevel(logging.WARNING)\n\n    if unrecognized:\n        logging.warning('Unrecognized log level: %s  Log level set to debug', level)\n\n    #TODO ref: use external log config\n    fh = logging.FileHandler('builder.log')\n    fh.setLevel(loglevel)\n    fh.setFormatter(formatter)\n    logging.getLogger('').addHandler(fh)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing command line options into a dictionary of options which can be used for overlaying on top of config", "response": "def parse_conf_args(argv):\n    \"\"\"Parse command line options into {section: (option, key)} which can be\n    used for overlaying on top of config\n\n    :param argv: list of argumets to be parsed\n    :return: Dictionary in the following format: {section: (option, key)}\"\"\"\n\n    args = {}\n    for rarg in argv:\n        if re.match(\"^--.*\", rarg):\n            arg = rarg.replace('--','', 1)\n\n            fsplit = arg.split('=', 1)\n            if len(fsplit) != 2:\n                raise Exception(\n                    \"Command option '%s' not recognized.\" % rarg)\n\n            rkey, value = fsplit\n            ssplit = rkey.split('.', 1)\n            if len(ssplit) != 2 or not ssplit[1]:\n                raise Exception(\n                    \"Command option '%s' not recognized.\" % rarg)\n\n            section, option = ssplit\n            args[section] = (option, value)\n        else:\n            raise Exception(\n                    \"Command option '%s' not recognized.\" % rarg)\n\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef required(field):\n\n    def wrap(f):\n        def wrappedf(*args):\n            result = f(*args)\n            if result is None or result == \"\":\n                raise Exception(\n                    \"Config option '%s' is required.\" % field)\n            else:\n                return result\n        return wrappedf\n    return wrap", "response": "Decorator that checks if return value is set."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef split_unescape(s, delim, escape='\\\\', unescape=True):\n    ret = []\n    current = []\n    itr = iter(s)\n    for ch in itr:\n        if ch == escape:\n            try:\n                # skip the next character; it has been escaped!\n                if not unescape:\n                    current.append(escape)\n                current.append(next(itr))\n            except StopIteration:\n                if unescape:\n                    current.append(escape)\n        elif ch == delim:\n            # split! (add current to the list and reset it)\n            ret.append(''.join(current))\n            current = []\n        else:\n            current.append(ch)\n    ret.append(''.join(current))\n    return ret", "response": "Split a string into a list of lists of items."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render(self, template_name, variables=None):\n        if variables is None:\n            variables = {}\n        template = self._engine.get_template(template_name)\n        return template.render(**variables)", "response": "Render a template with the passed variables."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef render_source(self, source, variables=None):\n        if variables is None:\n            variables = {}\n        template = self._engine.from_string(source)\n        return template.render(**variables)", "response": "Render a source with the passed variables."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef construct_re(url_template, match_whole_str=False, converters=None,\n                 default_converter='string', anonymous=False):\n    '''\n    url_template - str or unicode representing template\n\n    Constructed pattern expects urlencoded string!\n\n    returns  (compiled re pattern, \n              dict {url param name: [converter name, converter args (str)]},\n              list of (variable name, converter name, converter args name))\n\n    If anonymous=True is set, regexp will be compiled without names of variables.\n    This is handy for example, if you want to dump an url map to JSON.\n    '''\n    # needed for reverse url building (or not needed?)\n    builder_params = []\n    # found url params and their converters\n    url_params = {}\n    result = r'^'\n    parts = _split_pattern.split(url_template)\n    for i, part in enumerate(parts):\n        is_url_pattern = _static_url_pattern.match(part)\n        if is_url_pattern:\n            #NOTE: right order:\n            #      - make part str if it was unicode\n            #      - urlquote part\n            #      - escape all specific for re chars in part\n            result += re.escape(urlquote(part))\n            builder_params.append(part)\n            continue\n        is_converter = _converter_pattern.match(part)\n        if is_converter:\n            groups = is_converter.groupdict()\n            converter_name = groups['converter'] or default_converter\n            conv_object = init_converter(converters[converter_name],\n                                         groups['args'])\n            variable = groups['variable']\n            builder_params.append((variable, conv_object))\n            url_params[variable] = conv_object\n            if anonymous:\n                result += conv_object.regex\n            else:\n                result += '(?P<{}>{})'.format(variable, conv_object.regex)\n            continue\n        raise ValueError('Incorrect url template {!r}'.format(url_template))\n    if match_whole_str:\n        result += '$'\n    return re.compile(result), url_params, builder_params", "response": "Construct a compiled re pattern for the given url template."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmatches the path and return the kwargs and the kwargs of the matched object.", "response": "def match(self, path, **kw):\n        '''\n        path - str (urlencoded)\n        '''\n        m = self._pattern.match(path)\n        if m:\n            kwargs = m.groupdict()\n            # convert params\n            for url_arg_name, value_urlencoded in kwargs.items():\n                conv_obj = self._url_params[url_arg_name]\n                unicode_value = unquote(value_urlencoded)\n                if isinstance(unicode_value, six.binary_type):\n                    # XXX ??\n                    unicode_value = unicode_value.decode('utf-8', 'replace')\n                try:\n                    kwargs[url_arg_name] = conv_obj.to_python(unicode_value, **kw)\n                except ConvertError as err:\n                    logger.debug('ConvertError in parameter \"%s\" '\n                                 'by %r, value \"%s\"',\n                                 url_arg_name,\n                                 err.converter.__class__,\n                                 err.value)\n                    return None, {}\n            return m.group(), kwargs\n        return None, {}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef export(bundle, force=False, force_restricted=False):\n    if not ckan:\n        raise EnvironmentError(MISSING_CREDENTIALS_MSG)\n\n    # publish dataset.\n    try:\n        ckan.action.package_create(**_convert_bundle(bundle))\n    except ckanapi.ValidationError:\n        if force:\n            logger.warning(\n                '{} dataset already exported, but new export forced. Continue to export dataset stuff.'\n                .format(bundle.dataset))\n        else:\n            raise\n\n    # set permissions.\n    access = bundle.dataset.config.metadata.about.access\n\n    if access == 'restricted' and force_restricted:\n        access = 'private'\n\n    assert access, 'CKAN publishing requires access level.'\n\n    if access in ('internal',  'controlled', 'restricted', 'census'):\n        # Never publish dataset with such access.\n        raise UnpublishedAccessError(\n            '{} dataset can not be published because of {} access.'\n            .format(bundle.dataset.vid, bundle.dataset.config.metadata.about.access))\n    elif access == 'public':\n        # The default permission of the CKAN allows to edit and create dataset without logging in. But\n        # admin of the certain CKAN instance can change default permissions.\n        # http://docs.ckan.org/en/ckan-1.7/authorization.html#anonymous-edit-mode\n        user_roles = [\n            {'user': 'visitor', 'domain_object': bundle.dataset.vid.lower(), 'roles': ['editor']},\n            {'user': 'logged_in', 'domain_object': bundle.dataset.vid.lower(), 'roles': ['editor']},\n        ]\n\n    elif access == 'registered':\n        # Anonymous has no access, logged in users can read/edit.\n        # http://docs.ckan.org/en/ckan-1.7/authorization.html#logged-in-edit-mode\n        user_roles = [\n            {'user': 'visitor', 'domain_object': bundle.dataset.vid.lower(), 'roles': []},\n            {'user': 'logged_in', 'domain_object': bundle.dataset.vid.lower(), 'roles': ['editor']}\n        ]\n    elif access in ('private', 'licensed', 'test'):\n        # Organization users can read/edit\n        # http://docs.ckan.org/en/ckan-1.7/authorization.html#publisher-mode\n        # disable access for anonymous and logged_in\n        user_roles = [\n            {'user': 'visitor', 'domain_object': bundle.dataset.vid.lower(), 'roles': []},\n            {'user': 'logged_in', 'domain_object': bundle.dataset.vid.lower(), 'roles': []}\n        ]\n        organization_users = ckan.action.organization_show(id=CKAN_CONFIG.organization)['users']\n        for user in organization_users:\n            user_roles.append({\n                'user': user['id'], 'domain_object': bundle.dataset.vid.lower(), 'roles': ['editor']}),\n\n    for role in user_roles:\n        # http://docs.ckan.org/en/ckan-2.4.1/api/#ckan.logic.action.update.user_role_update\n        ckan.action.user_role_update(**role)\n\n    # TODO: Using bulk update gives http500 error. Try later with new version.\n    # http://docs.ckan.org/en/ckan-2.4.1/api/#ckan.logic.action.update.user_role_bulk_update - the same\n    # ckan.action.user_role_bulk_update(user_roles=user_roles)\n\n    # publish partitions\n    for partition in bundle.partitions:\n        ckan.action.resource_create(**_convert_partition(partition))\n\n    # publish schema.csv\n    ckan.action.resource_create(**_convert_schema(bundle))\n\n    # publish external documentation\n    for name, external in six.iteritems(bundle.dataset.config.metadata.external_documentation):\n        ckan.action.resource_create(**_convert_external(bundle, name, external))", "response": "Exports a bundle to CKAN instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if dataset is already exported to CKAN. Otherwise returns False.", "response": "def is_exported(bundle):\n    \"\"\" Returns True if dataset is already exported to CKAN. Otherwise returns False. \"\"\"\n    if not ckan:\n        raise EnvironmentError(MISSING_CREDENTIALS_MSG)\n    params = {'q': 'name:{}'.format(bundle.dataset.vid.lower())}\n    resp = ckan.action.package_search(**params)\n    return len(resp['results']) > 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts an ambry bundle to dict ready to send to CKAN API.", "response": "def _convert_bundle(bundle):\n    \"\"\" Converts ambry bundle to dict ready to send to CKAN API.\n\n    Args:\n        bundle (ambry.bundle.Bundle): bundle to convert.\n\n    Returns:\n        dict: dict to send to CKAN to create dataset.\n            See http://docs.ckan.org/en/latest/api/#ckan.logic.action.create.package_create\n\n    \"\"\"\n    # shortcut for metadata\n    meta = bundle.dataset.config.metadata\n\n    notes = ''\n\n    for f in bundle.dataset.files:\n        if f.path.endswith('documentation.md'):\n            contents = f.unpacked_contents\n            if isinstance(contents, six.binary_type):\n                contents = contents.decode('utf-8')\n            notes = json.dumps(contents)\n            break\n\n    ret = {\n        'name': bundle.dataset.vid.lower(),\n        'title': meta.about.title,\n        'author': meta.contacts.wrangler.name,\n        'author_email': meta.contacts.wrangler.email,\n        'maintainer': meta.contacts.maintainer.name,\n        'maintainer_email': meta.contacts.maintainer.email,\n        'license_id': '',\n        'notes': notes,\n        'url': meta.identity.source,\n        'version': bundle.dataset.version,\n        'state': 'active',\n        'owner_org': CKAN_CONFIG['organization'],\n    }\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _convert_partition(partition):\n    # http://docs.ckan.org/en/latest/api/#ckan.logic.action.create.resource_create\n\n    # convert bundle to csv.\n    csvfile = six.StringIO()\n    writer = unicodecsv.writer(csvfile)\n    headers = partition.datafile.headers\n    if headers:\n        writer.writerow(headers)\n    for row in partition:\n        writer.writerow([row[h] for h in headers])\n    csvfile.seek(0)\n\n    # prepare dict.\n    ret = {\n        'package_id': partition.dataset.vid.lower(),\n        'url': 'http://example.com',\n        'revision_id': '',\n        'description': partition.description or '',\n        'format': 'text/csv',\n        'hash': '',\n        'name': partition.name,\n        'resource_type': '',\n        'mimetype': 'text/csv',\n        'mimetype_inner': '',\n        'webstore_url': '',\n        'cache_url': '',\n        'upload': csvfile\n    }\n\n    return ret", "response": "Converts a partition to a dict ready to save to CKAN."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting schema of the dataset to resource dict ready to save to CKAN.", "response": "def _convert_schema(bundle):\n    \"\"\" Converts schema of the dataset to resource dict ready to save to CKAN. \"\"\"\n    # http://docs.ckan.org/en/latest/api/#ckan.logic.action.create.resource_create\n    schema_csv = None\n    for f in bundle.dataset.files:\n        if f.path.endswith('schema.csv'):\n            contents = f.unpacked_contents\n            if isinstance(contents, six.binary_type):\n                contents = contents.decode('utf-8')\n            schema_csv = six.StringIO(contents)\n            schema_csv.seek(0)\n            break\n\n    ret = {\n        'package_id': bundle.dataset.vid.lower(),\n        'url': 'http://example.com',\n        'revision_id': '',\n        'description': 'Schema of the dataset tables.',\n        'format': 'text/csv',\n        'hash': '',\n        'name': 'schema',\n        'upload': schema_csv,\n    }\n\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _convert_external(bundle, name, external):\n    # http://docs.ckan.org/en/latest/api/#ckan.logic.action.create.resource_create\n    ret = {\n        'package_id': bundle.dataset.vid.lower(),\n        'url': external.url,\n        'description': external.description,\n        'name': name,\n    }\n\n    return ret", "response": "Converts external documentation to resource dict ready to save to CKAN."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new BuildConfiguration and return the ID of the new BuildConfiguration.", "response": "def create_build_configuration_process(repository, revision, **kwargs):\n    \"\"\"\n    Create a new BuildConfiguration. BuildConfigurations represent the settings and configuration required to run a build of a specific version of the associated Project's source code.\n    If a ProductVersion ID is provided, the BuildConfiguration will have access to artifacts which were produced for that version, but may not have been released yet.\n    :return BPM Task ID of the new BuildConfiguration creation\n    \"\"\"\n\n    if not kwargs.get(\"dependency_ids\"):\n        kwargs[\"dependency_ids\"] = []\n\n    if not kwargs.get(\"build_configuration_set_ids\"):\n        kwargs[\"build_configuration_set_ids\"] = []\n\n    if kwargs.get(\"generic_parameters\"):\n        kwargs[\"generic_parameters\"] = ast.literal_eval(kwargs.get(\"generic_parameters\"))\n\n\n    if not kwargs.get(\"project\"):\n        kwargs[\"project\"] = pnc_api.projects.get_specific(kwargs.get(\"project_id\")).content\n    if not kwargs.get(\"environment\"):\n        kwargs[\"environment\"] = pnc_api.environments.get_specific(kwargs.get(\"build_environment_id\")).content\n\n    build_configuration = create_build_conf_object(scm_revision=revision, **kwargs)\n    repo_creation = swagger_client.RepositoryCreationUrlAutoRest()\n    repo_creation.scm_url = repository\n    repo_creation.build_configuration_rest = build_configuration\n\n    response = utils.checked_api_call(\n        pnc_api.bpm, 'start_r_creation_task_with_single_url', body=repo_creation)\n    if response:\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new RepositoryConfiguration.", "response": "def create_repository_configuration(repository, no_sync=False):\n    \"\"\"\n    Create a new RepositoryConfiguration. If the provided repository URL is for external repository, it is cloned into internal one.\n    :return BPM Task ID of the new RepositoryConfiguration creation\n    \"\"\"\n    repo = create_repository_configuration_raw(repository, no_sync)\n    if repo:\n        return utils.format_json(repo)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wait_for_repo_creation(task_id, retry=30):\n    success_event_types = (\"RC_CREATION_SUCCESS\", )\n    error_event_types = (\"RC_REPO_CREATION_ERROR\", \"RC_REPO_CLONE_ERROR\", \"RC_CREATION_ERROR\")\n    while retry > 0:\n        bpm_task = get_bpm_task_by_id(task_id)\n\n        if contains_event_type(bpm_task.content.events, success_event_types):\n            break\n\n        if contains_event_type(bpm_task.content.events, error_event_types):\n            logging.error(\"Creation of Repository Configuration failed\")\n            logging.error(bpm_task.content)\n            return False\n\n        logging.info(\"Waiting until Repository Configuration creation task \"+str(task_id)+\" finishes.\")\n        time.sleep(10)\n        retry -= 1\n    return retry > 0", "response": "Wait until the task finished by polling until the task finished."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_sources_zip(milestone_id=None, output=None):\n    if not is_input_valid(milestone_id, output):\n        logging.error(\"invalid input\")\n        return 1\n    create_work_dir(output)\n    download_sources_artifacts(milestone_id, output)\n    create_zip(output)", "response": "Generate a sources archive for given milestone id."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_repository_configuration(id):\n\n    response = utils.checked_api_call(pnc_api.repositories, 'get_specific', id=id)\n    if response:\n        return response.content", "response": "Retrieve a specific RepositoryConfiguration"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_repository_configuration(id, external_repository=None, prebuild_sync=None):\n    to_update_id = id\n\n    rc_to_update = pnc_api.repositories.get_specific(id=to_update_id).content\n\n    if external_repository is None:\n        external_repository = rc_to_update.external_url\n    else:\n        rc_to_update.external_url = external_repository\n\n    if prebuild_sync is not None:\n        rc_to_update.pre_build_sync_enabled = prebuild_sync\n\n    if not external_repository and prebuild_sync:\n        logging.error(\"You cannot enable prebuild sync without external repository\")\n        return\n\n    response = utils.checked_api_call(pnc_api.repositories, 'update', id=to_update_id, body=rc_to_update)\n    if response:\n        return response.content", "response": "Update an existing RepositoryConfiguration with new information"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsearch for Repository Configurations based on internal or external url", "response": "def search_repository_configuration(url, page_size=10, page_index=0, sort=\"\"):\n    \"\"\"\n    Search for Repository Configurations based on internal or external url\n    \"\"\"\n    content = search_repository_configuration_raw(url, page_size, page_index, sort)\n    if content:\n        return utils.format_json_list(content)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef search_repository_configuration_raw(url, page_size=10, page_index=0, sort=\"\"):\n    response = utils.checked_api_call(pnc_api.repositories, 'search', page_size=page_size, page_index=page_index, sort=sort, search=url)\n    if response:\n        return response.content", "response": "Search for Repository Configurations based on internal or external url"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match_repository_configuration(url, page_size=10, page_index=0, sort=\"\"):\n    content = match_repository_configuration_raw(url, page_size, page_index, sort)\n    if content:\n        return utils.format_json_list(content)", "response": "Search for Repository Configurations based on internal or external url with exact match"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntrying to accpet MultiDict - like object and return if it is valid.", "response": "def accept(self, data):\n        '''\n        Try to accpet MultiDict-like object and return if it is valid.\n        '''\n        self.raw_data = MultiDict(data)\n        self.errors = {}\n        for field in self.fields:\n            if field.writable:\n                self.python_data.update(field.accept())\n            else:\n                for name in field.field_names:\n                    # readonly field\n                    subfield = self.get_field(name)\n                    value = self.python_data[subfield.name]\n                    subfield.set_raw_value(self.raw_data, subfield.from_python(value))\n        return self.is_valid"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn data representing current state of the form.", "response": "def get_data(self, compact=True):\n        '''\n        Returns data representing current state of the form. While\n        Form.raw_data may contain alien fields and invalid data, this method\n        returns only valid fields that belong to this form only. It's designed\n        to pass somewhere current state of the form (as query string or by\n        other means).\n        '''\n        data = MultiDict()\n        for field in self.fields:\n            raw_value = field.from_python(self.python_data[field.name])\n            field.set_raw_value(data, raw_value)\n        if compact:\n            data = MultiDict([(k, v) for k, v in data.items() if v])\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_configuration(self, id, **kwargs):\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.add_configuration_with_http_info(id, **kwargs)\n        else:\n            (data) = self.add_configuration_with_http_info(id, **kwargs)\n            return data", "response": "Adds a configuration to the Specified Set\n        \n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild the Configurations for the Specified Set", "response": "def build(self, id, **kwargs):\n        \"\"\"\n        Builds the Configurations for the Specified Set\n        \n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.build(id, callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param int id: Build Configuration Set id (required)\n        :param str callback_url: Optional Callback URL\n        :param bool temporary_build: Is it a temporary build or a standard build?\n        :param bool force_rebuild: DEPRECATED: Use RebuildMode.\n        :param bool timestamp_alignment: Should we add a timestamp during the alignment? Valid only for temporary builds.\n        :param str rebuild_mode: Rebuild Modes: FORCE: always rebuild all the configurations in the set; EXPLICIT_DEPENDENCY_CHECK: check if any of user defined dependencies has been update; IMPLICIT_DEPENDENCY_CHECK: check if any captured dependency has been updated;\n        :return: BuildConfigSetRecordSingleton\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.build_with_http_info(id, **kwargs)\n        else:\n            (data) = self.build_with_http_info(id, **kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds the configurations for the Specified Set with an exact revision of a BC", "response": "def build_versioned(self, id, **kwargs):\n        \"\"\"\n        Builds the configurations for the Specified Set with an option to specify exact revision of a BC\n        \n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.build_versioned(id, callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param int id: Build Configuration Set id (required)\n        :param str callback_url: Optional Callback URL\n        :param bool temporary_build: Is it a temporary build or a standard build?\n        :param bool force_rebuild: DEPRECATED: Use RebuildMode.\n        :param bool timestamp_alignment: Should we add a timestamp during the alignment? Valid only for temporary builds.\n        :param BuildConfigurationSetWithAuditedBCsRest body:\n        :param str rebuild_mode: Rebuild Modes: FORCE: always rebuild all the configurations in the set; EXPLICIT_DEPENDENCY_CHECK: check if any of user defined dependencies has been update; IMPLICIT_DEPENDENCY_CHECK: check if any captured dependency has been updated;\n        :return: BuildConfigSetRecordSingleton\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.build_versioned_with_http_info(id, **kwargs)\n        else:\n            (data) = self.build_versioned_with_http_info(id, **kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes a specific Build Configuration Set.", "response": "def delete_specific(self, id, **kwargs):\n        \"\"\"\n        Removes a specific Build Configuration Set\n        \n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.delete_specific(id, callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param int id: Build Configuration Set id (required)\n        :return: None\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.delete_specific_with_http_info(id, **kwargs)\n        else:\n            (data) = self.delete_specific_with_http_info(id, **kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_all_build_config_set_records(self, id, **kwargs):\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.get_all_build_config_set_records_with_http_info(id, **kwargs)\n        else:\n            (data) = self.get_all_build_config_set_records_with_http_info(id, **kwargs)\n            return data", "response": "Get all build config set execution records associated with this build config set. Returns empty list if none are found."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget all build records associated with the contained build configurations", "response": "def get_build_records(self, id, **kwargs):\n        \"\"\"\n        Gets all build records associated with the contained build configurations\n        \n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.get_build_records(id, callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param int id: Build configuration set id (required)\n        :param int page_index: Page Index\n        :param int page_size: Pagination size\n        :param str sort: Sorting RSQL\n        :param str q: RSQL Query\n        :return: BuildRecordPage\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.get_build_records_with_http_info(id, **kwargs)\n        else:\n            (data) = self.get_build_records_with_http_info(id, **kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_configurations(self, id, **kwargs):\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.get_configurations_with_http_info(id, **kwargs)\n        else:\n            (data) = self.get_configurations_with_http_info(id, **kwargs)\n            return data", "response": "Get the Configurations for the Specified Set\n        \n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_configuration(self, id, config_id, **kwargs):\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.remove_configuration_with_http_info(id, config_id, **kwargs)\n        else:\n            (data) = self.remove_configuration_with_http_info(id, config_id, **kwargs)\n            return data", "response": "Remove a configuration from the specified config set."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_configurations(self, id, **kwargs):\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.update_configurations_with_http_info(id, **kwargs)\n        else:\n            (data) = self.update_configurations_with_http_info(id, **kwargs)\n            return data", "response": "Update Build Configuration Set"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of absolute paths to other directories which may be searched for plugin modules for the named plugin package.", "response": "def pluginPackagePaths(name):\n    \"\"\"\n    Return a list of additional directories which should be searched for\n    modules to be included as part of the named plugin package.\n\n    @type name: C{str}\n    @param name: The fully-qualified Python name of a plugin package, eg\n        C{'twisted.plugins'}.\n\n    @rtype: C{list} of C{str}\n    @return: The absolute paths to other directories which may contain plugin\n        modules for the named plugin package.\n    \"\"\"\n    package = name.split('.')\n    # Note that this may include directories which do not exist.  It may be\n    # preferable to remove such directories at this point, rather than allow\n    # them to be searched later on.\n    #\n    # Note as well that only '__init__.py' will be considered to make a\n    # directory a package (and thus exclude it from this list).  This means\n    # that if you create a master plugin package which has some other kind of\n    # __init__ (eg, __init__.pyc) it will be incorrectly treated as a\n    # supplementary plugin directory.\n    return [\n        os.path.abspath(os.path.join(x, *package))\n        for x\n        in sys.path\n        if\n        not os.path.exists(os.path.join(x, *package + ['__init__.py']))]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef storage_method(func):\n    '''Calls decorated method with VersionedStorage as self'''\n    def wrap(self, *args, **kwargs):\n        return func(self._root_storage, *args, **kwargs)\n    return wrap", "response": "Calls decorated method with VersionedStorage as self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render(self, template_name, **kw):\n        'Interface method called from `Template.render`'\n        return self.env.get_template(template_name).render(**kw)", "response": "Interface method called from Template. render"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cancel_all_builds_in_group(self, id, **kwargs):\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.cancel_all_builds_in_group_with_http_info(id, **kwargs)\n        else:\n            (data) = self.cancel_all_builds_in_group_with_http_info(id, **kwargs)\n            return data", "response": "Cancel all Build Configuration Set running in a Build Group."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget all Build Records for a specific Build Configuration.", "response": "def get_all_for_bc(self, id, **kwargs):\n        \"\"\"\n        Gets running Build Records for a specific Build Configuration.\n        \n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.get_all_for_bc(id, callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param int id: Build Configuration id (required)\n        :param int page_index: Page Index\n        :param int page_size: Pagination size\n        :param str search: Since this endpoint does not support queries, fulltext search is hard-coded for some predefined fields (record id, configuration name) and performed using this argument. Empty string leaves all data unfiltered.\n        :return: BuildRecordPage\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.get_all_for_bc_with_http_info(id, **kwargs)\n        else:\n            (data) = self.get_all_for_bc_with_http_info(id, **kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting all Build Records for a specific Build Configuration Set Record.", "response": "def get_all_for_bc_set_record(self, id, **kwargs):\n        \"\"\"\n        Gets running Build Records for a specific Build Configuration Set Record.\n        \n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please define a `callback` function\n        to be invoked when receiving the response.\n        >>> def callback_function(response):\n        >>>     pprint(response)\n        >>>\n        >>> thread = api.get_all_for_bc_set_record(id, callback=callback_function)\n\n        :param callback function: The callback function\n            for asynchronous request. (optional)\n        :param int id: Build Configuration Set id (required)\n        :param int page_index: Page Index\n        :param int page_size: Pagination size\n        :param str search: Since this endpoint does not support queries, fulltext search is hard-coded for some predefined fields (record id, configuration name) and performed using this argument. Empty string leaves all data unfiltered.\n        :return: BuildRecordPage\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.get_all_for_bc_set_record_with_http_info(id, **kwargs)\n        else:\n            (data) = self.get_all_for_bc_set_record_with_http_info(id, **kwargs)\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dictmapper(typename, mapping):\n    def init(self, d, *args, **kwargs):\n        \"\"\"\n        Initialize `dictmapper` classes with a dict to back getters.\n        \"\"\"\n        self._original_dict = d\n\n    def getter_from_dict_path(path):\n        if not callable(path) and len(path) < 1:\n            raise ValueError('Dict paths should be iterables with at least one'\n                             ' key or callable objects that take one argument.')\n        def getter(self):\n            cur_dict = self._original_dict\n            if callable(path):\n                return path(cur_dict)\n            return dict_value_from_path(cur_dict, path)\n        return getter\n\n    prop_mapping = dict((k, property(getter_from_dict_path(v))) \n                        for k, v in mapping.iteritems())\n    prop_mapping['__init__'] = init\n    return type(typename, tuple(), prop_mapping)", "response": "A factory to create namedtuples from a field - to - dict - path mapping."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn arguments for constructing a copy of the object", "response": "def ctor_args(self):\n        \"\"\"Return arguments for constructing a copy\"\"\"\n\n        return dict(\n            config=self._config,\n            search=self._search,\n            echo=self._echo,\n            read_only=self.read_only\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_debug(self):\n        import signal\n\n        def debug_trace(sig, frame):\n            \"\"\"Interrupt running process, and provide a python prompt for interactive\n            debugging.\"\"\"\n\n            self.log('Trace signal received')\n            self.log(''.join(traceback.format_stack(frame)))\n\n        signal.signal(signal.SIGUSR2, debug_trace)", "response": "Initialize debugging features such as a handler for USR2 to print a trace"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resolve_object_number(self, ref):\n\n        if not isinstance(ref, ObjectNumber):\n            on = ObjectNumber.parse(ref)\n        else:\n            on = ref\n\n        ds_on = on.as_dataset\n\n        return ds_on", "response": "Resolve a variety of object numebrs to a dataset number"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dataset(self, ref, load_all=False, exception=True):\n        return self.database.dataset(ref, load_all=load_all, exception=exception)", "response": "Return a dataset object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_bundle(self, assignment_class=None, **kwargs):\n\n        if not ('id' in kwargs and bool(kwargs['id'])) or assignment_class is not None:\n            kwargs['id'] = self.number(assignment_class)\n\n        ds = self._db.new_dataset(**kwargs)\n        self._db.commit()\n\n        b = self.bundle(ds.vid)\n        b.state = Bundle.STATES.NEW\n\n        b.set_last_access(Bundle.STATES.NEW)\n\n        b.set_file_system(source_url=self._fs.source(b.identity.source_path),\n                          build_url=self._fs.build(b.identity.source_path))\n\n        bs_meta = b.build_source_files.file(File.BSFILE.META)\n        bs_meta.set_defaults()\n        bs_meta.record_to_objects()\n        bs_meta.objects_to_record()\n        b.commit()\n\n        self._db.commit()\n        return b", "response": "Create a new bundle with the same arguments as creating a new dataset"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef new_from_bundle_config(self, config):\n        identity = Identity.from_dict(config['identity'])\n\n        ds = self._db.dataset(identity.vid, exception=False)\n\n        if not ds:\n            ds = self._db.new_dataset(**identity.dict)\n\n        b = Bundle(ds, self)\n        b.commit()\n        b.state = Bundle.STATES.NEW\n        b.set_last_access(Bundle.STATES.NEW)\n\n        # b.set_file_system(source_url=self._fs.source(ds.name),\n        #                   build_url=self._fs.build(ds.name))\n\n        return b", "response": "Create a new bundle based on the identity in config data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a bundle build on a dataset with the given vid or id reference", "response": "def bundle(self, ref, capture_exceptions=False):\n        \"\"\"Return a bundle build on a dataset, with the given vid or id reference\"\"\"\n        from ..orm.exc import NotFoundError\n\n        if isinstance(ref, Dataset):\n            ds = ref\n        else:\n            try:\n                ds = self._db.dataset(ref)\n            except NotFoundError:\n                ds = None\n\n        if not ds:\n            try:\n                p = self.partition(ref)\n                ds = p._bundle.dataset\n            except NotFoundError:\n                ds = None\n\n        if not ds:\n            raise NotFoundError('Failed to find dataset for ref: {}'.format(ref))\n\n        b = Bundle(ds, self)\n        b.capture_exceptions = capture_exceptions\n\n        return b"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding a partition by ref and converts it to bundle partition.", "response": "def partition(self, ref, localize=False):\n        \"\"\" Finds partition by ref and converts to bundle partition.\n\n        :param ref: A partition reference\n        :param localize: If True, copy a remote partition to local filesystem. Defaults to False\n        :raises: NotFoundError: if partition with given ref not found.\n        :return: orm.Partition: found partition.\n        \"\"\"\n\n        if not ref:\n            raise NotFoundError(\"No partition for empty ref\")\n\n        try:\n            on = ObjectNumber.parse(ref)\n            ds_on = on.as_dataset\n\n            ds = self._db.dataset(ds_on)  # Could do it in on SQL query, but this is easier.\n\n            # The refresh is required because in some places the dataset is loaded without the partitions,\n            # and if that persist, we won't have partitions in it until it is refreshed.\n\n            self.database.session.refresh(ds)\n\n            p = ds.partition(ref)\n\n        except NotObjectNumberError:\n            q = (self.database.session.query(Partition)\n                 .filter(or_(Partition.name == str(ref), Partition.vname == str(ref)))\n                 .order_by(Partition.vid.desc()))\n\n            p = q.first()\n\n        if not p:\n            raise NotFoundError(\"No partition for ref: '{}'\".format(ref))\n\n        b = self.bundle(p.d_vid)\n        p = b.wrap_partition(p)\n\n        if localize:\n            p.localize()\n\n        return p"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind table by ref and returns it.", "response": "def table(self, ref):\n        \"\"\" Finds table by ref and returns it.\n\n        Args:\n            ref (str): id, vid (versioned id) or name of the table\n\n        Raises:\n            NotFoundError: if table with given ref not found.\n\n        Returns:\n            orm.Table\n\n        \"\"\"\n\n        try:\n            obj_number = ObjectNumber.parse(ref)\n            ds_obj_number = obj_number.as_dataset\n\n            dataset = self._db.dataset(ds_obj_number)  # Could do it in on SQL query, but this is easier.\n            table = dataset.table(ref)\n\n        except NotObjectNumberError:\n            q = self.database.session.query(Table)\\\n                .filter(Table.name == str(ref))\\\n                .order_by(Table.vid.desc())\n\n            table = q.first()\n\n        if not table:\n            raise NotFoundError(\"No table for ref: '{}'\".format(ref))\n        return table"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove(self, bundle):\n        from six import string_types\n\n        if isinstance(bundle, string_types):\n            bundle = self.bundle(bundle)\n\n        self.database.remove_dataset(bundle.dataset)", "response": "Removes a bundle from the library and deletes the configuration for\n        it from the library database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef duplicate(self, b):\n\n        on = b.identity.on\n        on.revision = on.revision + 1\n\n        try:\n            extant = self.bundle(str(on))\n\n            if extant:\n                raise ConflictError('Already have a bundle with vid: {}'.format(str(on)))\n        except NotFoundError:\n            pass\n\n        d = b.dataset.dict\n        d['revision'] = on.revision\n        d['vid'] = str(on)\n        del d['name']\n        del d['vname']\n        del d['version']\n        del d['fqname']\n        del d['cache_key']\n\n        ds = self.database.new_dataset(**d)\n\n        nb = self.bundle(ds.vid)\n        nb.set_file_system(source_url=b.source_fs.getsyspath('/'))\n        nb.state = Bundle.STATES.NEW\n\n        nb.commit()\n\n        # Copy all of the files.\n        for f in b.dataset.files:\n            assert f.major_type == f.MAJOR_TYPE.BUILDSOURCE\n            nb.dataset.files.append(nb.dataset.bsfile(f.minor_type, f.path).update(f))\n\n        # Load the metadata in to records, then back out again. The objects_to_record process will set the\n        # new identity object numbers in the metadata file\n        nb.build_source_files.file(File.BSFILE.META).record_to_objects()\n        nb.build_source_files.file(File.BSFILE.META).objects_to_record()\n\n        ds.commit()\n\n        return nb", "response": "Duplicate a bundle with a higher version number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a bundle as a Sqlite file to this library", "response": "def checkin_bundle(self, db_path, replace=True, cb=None):\n        \"\"\"Add a bundle, as a Sqlite file, to this library\"\"\"\n        from ambry.orm.exc import NotFoundError\n\n        db = Database('sqlite:///{}'.format(db_path))\n        db.open()\n\n        if len(db.datasets) == 0:\n            raise NotFoundError(\"Did not get a dataset in the {} bundle\".format(db_path))\n\n\n        ds = db.dataset(db.datasets[0].vid)  # There should only be one\n\n        assert ds is not None\n        assert ds._database\n\n        try:\n            b = self.bundle(ds.vid)\n            self.logger.info(\n                \"Removing old bundle before checking in new one of same number: '{}'\"\n                .format(ds.vid))\n            self.remove(b)\n        except NotFoundError:\n            pass\n\n        try:\n            self.dataset(ds.vid)  # Skip loading bundles we already have\n        except NotFoundError:\n            self.database.copy_dataset(ds, cb=cb)\n\n        b = self.bundle(ds.vid)  # It had better exist now.\n        # b.state = Bundle.STATES.INSTALLED\n        b.commit()\n\n        #self.search.index_library_datasets(tick)\n\n        self.search.index_bundle(b)\n\n        return b"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_to_remote(self, b, no_partitions=False):\n\n        raise DeprecationWarning(\"Don't use any more?\")\n\n        from ambry.bundle.process import call_interval\n\n        remote_name = self.resolve_remote(b)\n\n        remote = self.remote(remote_name)\n\n        db_path = b.package()\n\n        with b.progress.start('checkin', 0, message='Check in bundle') as ps:\n\n            ps.add(message='Checking in bundle {} to {}'.format(b.identity.vname, remote))\n\n            db_ck = b.identity.cache_key + '.db'\n\n            ps.add(message='Upload bundle file', item_type='bytes', item_count=0)\n            total = [0]\n\n            @call_interval(5)\n            def upload_cb(n):\n                total[0] += n\n                ps.update(message='Upload bundle file', item_count=total[0])\n\n            with open(db_path) as f:\n                remote.makedir(os.path.dirname(db_ck), recursive=True, allow_recreate=True)\n                self.logger.info('Send bundle file {} '.format(db_path))\n                e = remote.setcontents_async(db_ck, f, progress_callback=upload_cb)\n                e.wait()\n\n            ps.update(state='done')\n\n            if not no_partitions:\n                for p in b.partitions:\n\n                    ps.add(message='Upload partition', item_type='bytes', item_count=0, p_vid=p.vid)\n\n                    with p.datafile.open(mode='rb') as fin:\n\n                        total = [0]\n\n                        @call_interval(5)\n                        def progress(bytes):\n                            total[0] += bytes\n                            ps.update(\n                                message='Upload partition'.format(p.identity.vname),\n                                item_count=total[0])\n\n                        remote.makedir(os.path.dirname(p.datafile.path), recursive=True, allow_recreate=True)\n                        event = remote.setcontents_async(p.datafile.path, fin, progress_callback=progress)\n                        event.wait()\n\n                        ps.update(state='done')\n\n            ps.add(message='Setting metadata')\n            ident = json.dumps(b.identity.dict)\n            remote.setcontents(os.path.join('_meta', 'vid', b.identity.vid), ident)\n            remote.setcontents(os.path.join('_meta', 'id', b.identity.id_), ident)\n            remote.setcontents(os.path.join('_meta', 'vname', text_type(b.identity.vname)), ident)\n            remote.setcontents(os.path.join('_meta', 'name', text_type(b.identity.name)), ident)\n            ps.update(state='done')\n\n            b.dataset.commit()\n\n            return remote_name, db_ck", "response": "Copy a bundle to a new Sqlite file then store the file on the remote."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef checkin_remote_bundle(self, ref, remote=None):\n\n        if not remote:\n            remote, vname = self.find_remote_bundle(ref)\n            if vname:\n                ref = vname\n        else:\n            pass\n\n        if not remote:\n            raise NotFoundError(\"Failed to find bundle ref '{}' in any remote\".format(ref))\n\n        self.logger.info(\"Load '{}' from '{}'\".format(ref, remote))\n\n        vid = self._checkin_remote_bundle(remote, ref)\n\n        self.commit()\n\n        return vid", "response": "Checkin a remote bundle to this library."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _checkin_remote_bundle(self, remote, ref):\n        from ambry.bundle.process import call_interval\n        from ambry.orm.exc import NotFoundError\n        from ambry.orm import Remote\n        from ambry.util.flo import copy_file_or_flo\n        from tempfile import NamedTemporaryFile\n\n        assert isinstance(remote, Remote)\n\n        @call_interval(5)\n        def cb(r, total):\n            self.logger.info(\"{}: Downloaded {} bytes\".format(ref, total))\n\n        b = None\n        try:\n            b = self.bundle(ref)\n            self.logger.info(\"{}: Already installed\".format(ref))\n            vid = b.identity.vid\n\n        except NotFoundError:\n            self.logger.info(\"{}: Syncing\".format(ref))\n\n            db_dir = self.filesystem.downloads('bundles')\n            db_f = os.path.join(db_dir, ref) #FIXME. Could get multiple versions of same file. ie vid and vname\n\n            if not os.path.exists(os.path.join(db_dir, db_f)):\n\n                self.logger.info(\"Downloading bundle '{}' to '{}\".format(ref, db_f))\n                with open(db_f, 'wb') as f_out:\n                    with remote.checkout(ref) as f:\n                        copy_file_or_flo(f, f_out, cb=cb)\n                        f_out.flush()\n\n            self.checkin_bundle(db_f)\n\n            b = self.bundle(ref)  # Should exist now.\n\n            b.dataset.data['remote_name'] = remote.short_name\n\n            b.dataset.upstream = remote.url\n\n            b.dstate = b.STATES.CHECKEDOUT\n\n            b.commit()\n\n        finally:\n            if b:\n                b.progress.close()\n\n        vid = b.identity.vid\n\n        return vid", "response": "Checkin a remote bundle from a remote object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remotes(self):\n        from ambry.orm import Remote\n        for r in self.database.session.query(Remote).all():\n            if not r.short_name:\n                continue\n\n            yield self.remote(r.short_name)", "response": "Return the names and URLs of the remotes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a remote for which name matches the short_name or url", "response": "def _remote(self, name):\n        \"\"\"Return a remote for which 'name' matches the short_name or url \"\"\"\n        from ambry.orm import Remote\n        from sqlalchemy import or_\n        from ambry.orm.exc import NotFoundError\n        from sqlalchemy.orm.exc import NoResultFound, MultipleResultsFound\n\n        if not name.strip():\n            raise NotFoundError(\"Empty remote name\")\n\n        try:\n            try:\n                r = self.database.session.query(Remote).filter(Remote.short_name == name).one()\n            except NoResultFound as e:\n                r = None\n\n            if not r:\n                r = self.database.session.query(Remote).filter(Remote.url == name).one()\n\n        except NoResultFound as e:\n            raise NotFoundError(str(e)+'; '+name)\n        except MultipleResultsFound as e:\n            self.logger.error(\"Got multiple results for search for remote '{}': {}\".format(name, e))\n            return None\n\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlocate a remote bundle by any reference among the configured remotes.", "response": "def _find_remote_bundle(self, ref, remote_service_type='s3'):\n        \"\"\"\n        Locate a bundle, by any reference, among the configured remotes. The routine will\n        only look in the cache directory lists stored in the remotes, which must\n        be updated to be current.\n\n        :param ref:\n        :return: (remote,vname) or (None,None) if the ref is not found\n        \"\"\"\n\n        for r in self.remotes:\n\n            if remote_service_type and r.service != remote_service_type:\n                continue\n\n            if 'list' not in r.data:\n                continue\n\n            for k, v in r.data['list'].items():\n                if ref in v.values():\n                    return (r, v['vname'])\n\n        return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_remote_bundle(self, ref, try_harder=None):\n        from ambry.identity import ObjectNumber\n\n        remote, vid = self._find_remote_bundle(ref)\n\n        if remote:\n            return (remote, vid)\n\n        if try_harder:\n\n            on = ObjectNumber.parse(vid)\n\n            if on:\n                raise NotImplementedError()\n                don = on.as_dataset\n                return self._find_remote_bundle(vid)\n\n            # Try subsets of a name, assuming it is a name\n            parts = ref.split('-')\n\n            for i in range(len(parts) - 1, 2, -1):\n                remote, vid = self._find_remote_bundle('-'.join(parts[:i]))\n\n                if remote:\n                    return (remote, vid)\n        return (None, None)", "response": "Locate a bundle by any reference."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef account(self, url):\n        from sqlalchemy.orm.exc import NoResultFound\n        from ambry.orm.exc import NotFoundError\n        from ambry.util import parse_url_to_dict\n        from ambry.orm import Account\n\n        pd = parse_url_to_dict(url)\n\n        # Old method of storing account information.\n        try:\n            act = self.database.session.query(Account).filter(Account.account_id == pd['netloc']).one()\n            act.secret_password = self._account_password\n            return act\n        except NoResultFound:\n            pass\n\n        # Try the remotes.\n        for r in self.remotes:\n            if url.startswith(r.url):\n                return r\n\n\n        raise NotFoundError(\"Did not find account for url: '{}' \".format(url))", "response": "Return accounts references for the given url."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an account reference with the same account_id and the same secret_password", "response": "def accounts(self):\n        \"\"\"\n        Return an account reference\n        :param account_id:\n        :param accounts_password: The password for decrypting the secret\n        :return:\n        \"\"\"\n        d = {}\n\n        if False and not self._account_password:\n            from ambry.dbexceptions import ConfigurationError\n            raise ConfigurationError(\n                \"Can't access accounts without setting an account password\"\n                \" either in the accounts.password config, or in the AMBRY_ACCOUNT_PASSWORD\"\n                \" env var.\")\n\n        for act in self.database.session.query(Account).all():\n            if self._account_password:\n                act.secret_password = self._account_password\n            e = act.dict\n            a_id = e['account_id']\n            d[a_id] = e\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a number for the given assignment class.", "response": "def number(self, assignment_class=None, namespace='d'):\n        \"\"\"\n        Return a new number.\n\n        :param assignment_class: Determines the length of the number. Possible values are 'authority' (3 characters) ,\n            'registered' (5) , 'unregistered' (7)  and 'self' (9). Self assigned numbers are random and acquired locally,\n            while the other assignment classes use the number server defined in the configuration. If None,\n            then look in the number server configuration for one of the class keys, starting\n            with the longest class and working to the shortest.\n        :param namespace: The namespace character, the first character in the number. Can be one of 'd', 'x' or 'b'\n        :return:\n        \"\"\"\n        if assignment_class == 'self':\n            # When 'self' is explicit, don't look for number server config\n            return str(DatasetNumber())\n\n        elif assignment_class is None:\n\n            try:\n                nsconfig = self.services['numbers']\n\n            except ConfigurationError:\n                # A missing configuration is equivalent to 'self'\n                self.logger.error('No number server configuration; returning self assigned number')\n                return str(DatasetNumber())\n\n            for assignment_class in ('self', 'unregistered', 'registered', 'authority'):\n                if assignment_class+'-key' in nsconfig:\n                    break\n\n            # For the case where the number configuratoin references a self-assigned key\n            if assignment_class == 'self':\n                return str(DatasetNumber())\n\n        else:\n            try:\n                nsconfig = self.services['numbers']\n\n            except ConfigurationError:\n                raise ConfigurationError('No number server configuration')\n\n            if assignment_class + '-key' not in nsconfig:\n                raise ConfigurationError(\n                    'Assignment class {} not number server config'.format(assignment_class))\n\n        try:\n\n            key = nsconfig[assignment_class + '-key']\n            config = {\n                'key': key,\n                'host': nsconfig['host'],\n                'port': nsconfig.get('port', 80)\n            }\n\n            ns = NumberServer(**config)\n\n            n = str(next(ns))\n            self.logger.info('Got number from number server: {}'.format(n))\n\n        except HTTPError as e:\n            self.logger.error('Failed to get number from number server for key: {}'.format(key, e.message))\n            self.logger.error('Using self-generated number. There is no problem with this, '\n                              'but they are longer than centrally generated numbers.')\n            n = str(DatasetNumber())\n\n        return n"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn config record information about the most recent bundle accesses and operations", "response": "def edit_history(self):\n        \"\"\"Return config record information about the most recent bundle accesses and operations\"\"\"\n\n        ret = self._db.session\\\n            .query(Config)\\\n            .filter(Config.type == 'buildstate')\\\n            .filter(Config.group == 'access')\\\n            .filter(Config.key == 'last')\\\n            .order_by(Config.modified.desc())\\\n            .all()\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nimporting bundles from a directory.", "response": "def import_bundles(self, dir, detach=False, force=False):\n        \"\"\"\n        Import bundles from a directory\n\n        :param dir:\n        :return:\n        \"\"\"\n\n        import yaml\n\n        fs = fsopendir(dir)\n\n        bundles = []\n\n        for f in fs.walkfiles(wildcard='bundle.yaml'):\n\n            self.logger.info('Visiting {}'.format(f))\n            config = yaml.load(fs.getcontents(f))\n\n            if not config:\n                self.logger.error(\"Failed to get a valid bundle configuration from '{}'\".format(f))\n\n            bid = config['identity']['id']\n\n            try:\n                b = self.bundle(bid)\n\n            except NotFoundError:\n                b = None\n\n            if not b:\n                b = self.new_from_bundle_config(config)\n                self.logger.info('{} Loading New'.format(b.identity.fqname))\n            else:\n                self.logger.info('{} Loading Existing'.format(b.identity.fqname))\n\n            source_url = os.path.dirname(fs.getsyspath(f))\n            b.set_file_system(source_url=source_url)\n            self.logger.info('{} Loading from {}'.format(b.identity.fqname, source_url))\n            b.sync_in()\n\n            if detach:\n                self.logger.info('{} Detaching'.format(b.identity.fqname))\n                b.set_file_system(source_url=None)\n\n            if force:\n                self.logger.info('{} Sync out'.format(b.identity.fqname))\n                # FIXME. It won't actually sync out until re-starting the bundle.\n                # The source_file_system is probably cached\n                b = self.bundle(bid)\n                b.sync_out()\n\n            bundles.append(b)\n            b.close()\n\n        return bundles"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a pool for multiprocess operations sized either to the number of CPUS or a configured value", "response": "def process_pool(self, limited_run=False):\n        \"\"\"Return a pool for multiprocess operations, sized either to the number of CPUS, or a configured value\"\"\"\n\n        from multiprocessing import cpu_count\n        from ambry.bundle.concurrent import Pool, init_library\n\n        if self.processes:\n            cpus = self.processes\n        else:\n            cpus = cpu_count()\n\n        self.logger.info('Starting MP pool with {} processors'.format(cpus))\n        return Pool(self, processes=cpus, initializer=init_library,\n                    maxtasksperchild=1,\n                    initargs=[self.database.dsn, self._account_password, limited_run])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef file_loc():\n    import sys\n    import inspect\n    try:\n        raise Exception\n    except:\n        file_ = '.../' + '/'.join((inspect.currentframe().f_code.co_filename.split('/'))[-3:])\n        line_ = sys.exc_info()[2].tb_frame.f_back.f_lineno\n        return \"{}:{}\".format(file_, line_)", "response": "Return file and line number of the current node"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes multiple row processors for all of the columns in a table.", "response": "def make_row_processors(bundle, source_headers, dest_table, env):\n    \"\"\"\n    Make multiple row processors for all of the columns in a table.\n\n    :param source_headers:\n\n    :return:\n    \"\"\"\n\n    dest_headers = [c.name for c in dest_table.columns]\n\n    row_processors = []\n\n    out = [file_header]\n\n    transforms = list(dest_table.transforms)\n    column_names = []\n    column_types = []\n    for i, segments in enumerate(transforms):\n\n        seg_funcs = []\n\n        for col_num, (segment, column) in enumerate(zip(segments, dest_table.columns), 1):\n\n            if not segment:\n                seg_funcs.append('row[{}]'.format(col_num - 1))\n                continue\n\n            assert column\n            assert column.name == segment['column'].name\n            col_name = column.name\n            preamble, try_lines, exception = make_stack(env, i, segment)\n\n            assert col_num == column.sequence_id, (dest_table.name, col_num, column.sequence_id)\n\n            column_names.append(col_name)\n            column_types.append(column.datatype)\n\n            f_name = \"{table_name}_{column_name}_{stage}\".format(\n                table_name=dest_table.name,\n                column_name=col_name,\n                stage=i\n            )\n\n            exception = (exception if exception else\n                                  ('raise ValueError(\"Failed to cast column \\'{}\\', in '\n                                   'function {}, value \\'{}\\': {}\".format(header_d,\"') + f_name +\n                                  '\", v.encode(\\'ascii\\', \\'replace\\'), exc) ) ')\n\n            try:\n                i_s = source_headers.index(column.name)\n                header_s = column.name\n                v = 'row[{}]'.format(i_s)\n\n            except ValueError as e:\n\n                i_s = 'None'\n                header_s = None\n                v = 'None' if col_num > 1 else 'row_n' # Give the id column the row number\n\n\n            i_d = column.sequence_id - 1\n\n            header_d = column.name\n\n            template_args = dict(\n                f_name=f_name,\n                table_name=dest_table.name,\n                column_name=col_name,\n                stage=i,\n                i_s=i_s,\n                i_d=i_d,\n                header_s=header_s,\n                header_d=header_d,\n                v=v,\n                exception=indent + exception,\n                stack='\\n'.join(indent + l for l in try_lines),\n                col_args = '# col_args not implemented yet'\n            )\n\n            seg_funcs.append(f_name\n                             + ('({v}, {i_s}, {i_d}, {header_s}, \\'{header_d}\\', '\n                                'row, row_n, errors, scratch, accumulator, pipe, bundle, source)')\n                             .format(v=v, i_s=i_s, i_d=i_d, header_s=\"'\" + header_s + \"'\" if header_s else 'None',\n                                     header_d=header_d))\n\n            out.append('\\n'.join(preamble))\n\n            out.append(column_template.format(**template_args))\n\n        source_headers = dest_headers\n\n        stack = '\\n'.join(\"{}{}, # {}\".format(indent,l,cn)\n                          for l,cn, dt in zip(seg_funcs, column_names, column_types))\n\n        out.append(row_template.format(\n            table=dest_table.name,\n            stage=i,\n            stack=stack\n        ))\n\n        row_processors.append('row_{table}_{stage}'.format(stage=i, table=dest_table.name))\n\n    # Add the final datatype cast, which is done seperately to avoid an unecessary function call.\n\n    stack = '\\n'.join(\"{}cast_{}(row[{}], '{}', errors),\".format(indent, c.datatype, i, c.name)\n                      for i, c in enumerate(dest_table.columns) )\n\n    out.append(row_template.format(\n        table=dest_table.name,\n        stage=len(transforms),\n        stack=stack\n    ))\n\n    row_processors.append('row_{table}_{stage}'.format(stage=len(transforms), table=dest_table.name))\n\n    out.append('row_processors = [{}]'.format(','.join(row_processors)))\n\n    return '\\n'.join(out)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calling_code(f, f_name=None, raise_for_missing=True):\n    import inspect\n    from ambry.dbexceptions import ConfigurationError\n\n    if inspect.isclass(f):\n        try:\n            args = inspect.getargspec(f.__init__).args\n        except TypeError as e:\n            raise TypeError(\"Failed to inspect {}: {}\".format(f, e))\n\n    else:\n        args = inspect.getargspec(f).args\n\n    if len(args) > 1 and args[0] == 'self':\n        args = args[1:]\n\n    for a in args:\n        if a not in all_args + ('exception',):  # exception arg is only for exception handlers\n            if raise_for_missing:\n                raise ConfigurationError('Caster code {} has unknown argument '\n                                         'name: \\'{}\\'. Must be one of: {} '.format(f, a, ','.join(all_args)))\n\n    arg_map = {e: e for e in var_args}\n\n    args = [arg_map.get(a, a) for a in args]\n\n    return \"{}({})\".format(f_name if f_name else f.__name__, ','.join(args))", "response": "Return the code string for calling a function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a stack of code for each transform segment.", "response": "def make_stack(env, stage, segment):\n    \"\"\"For each transform segment, create the code in the try/except block with the\n    assignements for pipes in the segment \"\"\"\n\n    import string\n    import random\n    from ambry.valuetype import ValueType\n\n    column = segment['column']\n\n    def make_line(column, t):\n        preamble = []\n\n        line_t = \"v = {} # {}\"\n\n        if isinstance(t, type) and issubclass(t, ValueType):  # A valuetype class, from the datatype column.\n\n            try:\n                cc, fl = calling_code(t, t.__name__), file_loc()\n            except TypeError:\n                cc, fl = \"{}(v)\".format(t.__name__), file_loc()\n\n            preamble.append(\"{} = resolve_value_type('{}') # {}\".format(t.__name__, t.vt_code, fl))\n\n        elif isinstance(t, type):  # A python type, from the datatype columns.\n            cc, fl= \"parse_{}(v, header_d)\".format(t.__name__), file_loc()\n\n        elif callable(env.get(t)):  # Transform function\n            cc, fl = calling_code(env.get(t), t), file_loc()\n\n        else:  # A transform generator, or python code.\n\n            rnd = (''.join(random.choice(string.ascii_lowercase) for _ in range(6)))\n\n            name = 'tg_{}_{}_{}'.format(column.name, stage, rnd)\n            try:\n                a, b, fl = rewrite_tg(env, name, t)\n            except CodeGenError as e:\n                raise CodeGenError(\"Failed to re-write pipe code '{}' in column '{}.{}': {} \"\n                                   .format(t, column.table.name, column.name, e))\n\n            cc = str(a)\n\n            if b:\n                preamble.append(\"{} = {} # {}\".format(name, b, fl))\n\n        line = line_t.format(cc, fl)\n\n        return line, preamble\n\n    preamble = []\n\n    try_lines = []\n\n    for t in [segment['init'], segment['datatype']] + segment['transforms']:\n\n        if not t:\n            continue\n\n        line, col_preamble = make_line(column, t)\n\n        preamble += col_preamble\n        try_lines.append(line)\n\n    exception = None\n    if segment['exception']:\n        exception, col_preamble = make_line(column, segment['exception'])\n\n    if len(try_lines) == 0:\n        try_lines.append('pass # Empty pipe segment')\n\n    assert len(try_lines) > 0, column.name\n\n    return preamble, try_lines, exception"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rewrite_tg(env, tg_name, code):\n\n    visitor = ReplaceTG(env, tg_name)\n    assert visitor.tg_name\n\n    tree = visitor.visit(ast.parse(code))\n\n    if visitor.loc:\n        loc = ' #' + visitor.loc\n    else:\n        loc = file_loc()  # The AST visitor didn't match a call node\n\n    if visitor.trans_gen:\n        tg = meta.dump_python_source(visitor.trans_gen).strip()\n    else:\n        tg = None\n\n    return meta.dump_python_source(tree).strip(), tg, loc", "response": "Re - write a transform generating function pipe specification by extracting the tranform generating part and replacing it with the generated transform."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef push(self, el):\n        count = next(self.counter)\n        heapq.heappush(self._queue, (el, count))", "response": "Push an element onto the queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a description of the geographic extents using the largest scale space and grain coverages", "response": "def geo_description(self):\n        \"\"\"Return a description of the geographic extents, using the largest scale\n        space and grain coverages\"\"\"\n\n        sc = self._p.space_coverage\n        gc = self._p.grain_coverage\n\n        if sc and gc:\n            if parse_to_gvid(gc[0]).level == 'state' and parse_to_gvid(sc[0]).level == 'state':\n                return parse_to_gvid(sc[0]).geo_name\n            else:\n                return (\"{} in {}\".format(\n                    parse_to_gvid(gc[0]).level_plural.title(),\n                    parse_to_gvid(sc[0]).geo_name))\n        elif sc:\n            return parse_to_gvid(sc[0]).geo_name.title()\n        elif sc:\n            return parse_to_gvid(gc[0]).level_plural.title()\n        else:\n            return ''"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstringing description of the year or year range", "response": "def time_description(self):\n        \"\"\"String description of the year or year range\"\"\"\n\n        tc = [t for t in self._p.time_coverage if t]\n\n        if not tc:\n            return ''\n\n        mn = min(tc)\n        mx = max(tc)\n\n        if not mn and not mx:\n            return ''\n        elif mn == mx:\n            return mn\n        else:\n            return \"{} to {}\".format(mn, mx)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sub_description(self):\n        gd = self.geo_description\n        td = self.time_description\n\n        if gd and td:\n            return '{}, {}. {} Rows.'.format(gd, td, self._p.count)\n        elif gd:\n            return '{}. {} Rows.'.format(gd, self._p.count)\n        elif td:\n            return '{}. {} Rows.'.format(td, self._p.count)\n        else:\n            return '{} Rows.'.format(self._p.count)", "response": "Return a string describing the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning this partition information as a PartitionId.", "response": "def identity(self):\n        \"\"\"Return this partition information as a PartitionId.\"\"\"\n\n        if self.dataset is None:\n            # The relationship will be null until the object is committed\n            s = object_session(self)\n\n            ds = s.query(Dataset).filter(Dataset.id_ == self.d_id).one()\n        else:\n            ds = self.dataset\n\n        d = {\n            'id': self.id,\n            'vid': self.vid,\n            'name': self.name,\n            'vname': self.vname,\n            'ref': self.ref,\n            'space': self.space,\n            'time': self.time,\n            'table': self.table_name,\n            'grain': self.grain,\n            'variant': self.variant,\n            'segment': self.segment,\n            'format': self.format if self.format else 'db'\n        }\n\n        return PartitionIdentity.from_dict(dict(list(ds.dict.items()) + list(d.items())))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_coverage(self, stats):\n        from ambry.util.datestimes import expand_to_years\n\n        scov = set()\n        tcov = set()\n        grains = set()\n\n        def summarize_maybe(gvid):\n            try:\n                return parse_to_gvid(gvid).summarize()\n            except:\n                return None\n\n        def simplifiy_maybe(values, column):\n\n            parsed = []\n\n            for gvid in values:\n                # The gvid should not be a st\n                if gvid is None or gvid == 'None':\n                    continue\n                try:\n                    parsed.append(parse_to_gvid(gvid))\n                except ValueError as e:\n                    if self._bundle:\n                        self._bundle.warn(\"While analyzing geo coverage in final partition stage, \" +\n                                           \"Failed to parse gvid '{}' in {}.{}: {}\"\n                                           .format(str(gvid), column.table.name, column.name, e))\n\n            try:\n                return isimplify(parsed)\n            except:\n                return None\n\n        def int_maybe(year):\n            try:\n                return int(year)\n            except:\n                return None\n\n        for c in self.table.columns:\n\n            if c.name not in stats:\n                continue\n\n            try:\n                if stats[c.name].is_gvid or stats[c.name].is_geoid:\n                    scov |= set(x for x in simplifiy_maybe(stats[c.name].uniques, c))\n                    grains |= set(summarize_maybe(gvid) for gvid in stats[c.name].uniques)\n\n                elif stats[c.name].is_year:\n                    tcov |= set(int_maybe(x) for x in stats[c.name].uniques)\n\n                elif stats[c.name].is_date:\n                    # The fuzzy=True argument allows ignoring the '-' char in dates produced by .isoformat()\n                    try:\n                        tcov |= set(parser.parse(x, fuzzy=True).year if isinstance(x, string_types) else x.year for x in\n                                    stats[c.name].uniques)\n                    except ValueError:\n                        pass\n\n            except Exception as e:\n                self._bundle.error(\"Failed to set coverage for column '{}', partition '{}': {}\"\n                                   .format(c.name, self.identity.vname, e))\n                raise\n\n        # Space Coverage\n\n        if 'source_data' in self.data:\n\n            for source_name, source in list(self.data['source_data'].items()):\n                scov.add(self.parse_gvid_or_place(source['space']))\n\n        if self.identity.space:  # And from the partition name\n            try:\n                scov.add(self.parse_gvid_or_place(self.identity.space))\n            except ValueError:\n                # Couldn't parse the space as a GVid\n                pass\n\n        # For geo_coverage, only includes the higher level summary levels, counties, states,\n        # places and urban areas.\n        self.space_coverage = sorted([str(x) for x in scov if bool(x) and x.sl\n                                      in (10, 40, 50, 60, 160, 400)])\n\n        #\n        # Time Coverage\n\n        # From the source\n        # If there was a time value in the source that this partition was created from, then\n        # add it to the years.\n        if 'source_data' in self.data:\n            for source_name, source in list(self.data['source_data'].items()):\n                if 'time' in source:\n                    for year in expand_to_years(source['time']):\n                        if year:\n                            tcov.add(year)\n\n        # From the partition name\n        if self.identity.name.time:\n            for year in expand_to_years(self.identity.name.time):\n                if year:\n                    tcov.add(year)\n\n        self.time_coverage = [t for t in tcov if t]\n\n        #\n        # Grains\n\n        if 'source_data' in self.data:\n            for source_name, source in list(self.data['source_data'].items()):\n                if 'grain' in source:\n                    grains.add(source['grain'])\n\n        self.grain_coverage = sorted(str(g) for g in grains if g)", "response": "Extract time space and grain coverage from the stats and store them in the partition"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the datafile for this partition from the build directory the remote or warehouse", "response": "def local_datafile(self):\n        \"\"\"Return the datafile for this partition, from the build directory, the remote, or the warehouse\"\"\"\n        from ambry_sources import MPRowsFile\n        from fs.errors import ResourceNotFoundError\n        from ambry.orm.exc import NotFoundError\n\n        try:\n            return MPRowsFile(self._bundle.build_fs, self.cache_key)\n\n        except ResourceNotFoundError:\n            raise NotFoundError(\n                'Could not locate data file for partition {} (local)'.format(self.identity.fqname))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remote(self):\n        from ambry.exc import NotFoundError\n\n        ds = self.dataset\n\n        if 'remote_name' not in ds.data:\n            raise NotFoundError('Could not determine remote for partition: {}'.format(self.identity.fqname))\n\n        return self._bundle.library.remote(ds.data['remote_name'])", "response": "Return the remote for this partition"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_local(self):\n        from ambry.orm.exc import NotFoundError\n        try:\n            if self.local_datafile.exists:\n                return True\n        except NotFoundError:\n            pass\n\n        return False", "response": "Return true is the partition file is local"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef localize(self, ps=None):\n        from filelock import FileLock\n        from ambry.util import ensure_dir_exists\n        from ambry_sources import MPRowsFile\n        from fs.errors import ResourceNotFoundError\n\n        if self.is_local:\n            return\n\n        local = self._bundle.build_fs\n\n        b = self._bundle.library.bundle(self.identity.as_dataset().vid)\n\n        remote = self._bundle.library.remote(b)\n\n        lock_path = local.getsyspath(self.cache_key + '.lock')\n\n        ensure_dir_exists(lock_path)\n\n        lock = FileLock(lock_path)\n\n        if ps:\n            ps.add_update(message='Localizing {}'.format(self.identity.name),\n                          partition=self,\n                          item_type='bytes',\n                          state='downloading')\n\n        if ps:\n            def progress(bts):\n                if ps.rec.item_total is None:\n                    ps.rec.item_count = 0\n\n                if not ps.rec.data:\n                    ps.rec.data = {}  # Should not need to do this.\n                    return self\n\n                item_count = ps.rec.item_count + bts\n                ps.rec.data['updates'] = ps.rec.data.get('updates', 0) + 1\n\n                if ps.rec.data['updates'] % 32 == 1:\n                    ps.update(message='Localizing {}'.format(self.identity.name),\n                              item_count=item_count)\n        else:\n            from ambry.bundle.process import call_interval\n            @call_interval(5)\n            def progress(bts):\n                self._bundle.log(\"Localizing {}. {} bytes downloaded\".format(self.vname, bts))\n\n        def exception_cb(e):\n            raise e\n\n        with lock:\n            # FIXME! This won't work with remote ( http) API, only FS ( s3:, file:)\n\n            if self.is_local:\n                return self\n\n            try:\n                with remote.fs.open(self.cache_key + MPRowsFile.EXTENSION, 'rb') as f:\n                    event = local.setcontents_async(self.cache_key + MPRowsFile.EXTENSION,\n                                                    f,\n                                                    progress_callback=progress,\n                                                    error_callback=exception_cb)\n                    event.wait()\n                    if ps:\n                        ps.update_done()\n            except ResourceNotFoundError as e:\n                from ambry.orm.exc import NotFoundError\n                raise NotFoundError(\"Failed to get MPRfile '{}' from {}: {} \"\n                                    .format(self.cache_key, remote.fs, e))\n\n        return self", "response": "Copy a non - local partition file to the local build directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nselects rows from the reader using a predicate to return rows and itemgetter to return a subset of elements", "response": "def select(self, predicate=None, headers=None):\n        \"\"\"\n        Select rows from the reader using a predicate to select rows and and itemgetter to return a\n        subset of elements\n        :param predicate: If defined, a callable that is called for each row, and if it returns true, the\n        row is included in the output.\n        :param headers: If defined, a list or tuple of header names to return from each row\n        :return: iterable of results\n\n        WARNING: This routine works from the reader iterator, which returns RowProxy objects. RowProxy objects\n        are reused, so if you construct a list directly from the output from this method, the list will have\n        multiple copies of a single RowProxy, which will have as an inner row the last result row. If you will\n        be directly constructing a list, use a getter that extracts the inner row, or which converts the RowProxy\n        to a dict:\n\n            list(s.datafile.select(lambda r: r.stusab == 'CA', lambda r: r.dict ))\n\n        \"\"\"\n\n        # FIXME; in Python 3, use yield from\n        with self.reader as r:\n            for row in r.select(predicate, headers):\n                yield row"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an AnalysisPartition proxy which wraps this partition to provide acess to dataframes shapely shapes and other analysis services", "response": "def analysis(self):\n        \"\"\"Return an AnalysisPartition proxy, which wraps this partition to provide acess to\n        dataframes, shapely shapes and other analysis services\"\"\"\n        if isinstance(self, PartitionProxy):\n            return AnalysisPartition(self._obj)\n        else:\n            return AnalysisPartition(self)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a MeasureDimension proxy which wraps the partition to provide access to columns in terms of measures and dimensions", "response": "def measuredim(self):\n        \"\"\"Return a MeasureDimension proxy, which wraps the partition to provide access to\n        columns in terms of measures and dimensions\"\"\"\n\n        if isinstance(self, PartitionProxy):\n            return MeasureDimensionPartition(self._obj)\n        else:\n            return MeasureDimensionPartition(self)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naltering the sequence id and all of the names and ids derived from it.", "response": "def update_id(self, sequence_id=None):\n        \"\"\"Alter the sequence id, and all of the names and ids derived from it. This\n        often needs to be done after an IntegrityError in a multiprocessing run\"\"\"\n\n        if sequence_id:\n            self.sequence_id = sequence_id\n\n        self._set_ids(force=True)\n\n        if self.dataset:\n            self._update_names()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the derived names", "response": "def _update_names(self):\n        \"\"\"Update the derived names\"\"\"\n\n        d = dict(\n            table=self.table_name,\n            time=self.time,\n            space=self.space,\n            grain=self.grain,\n            variant=self.variant,\n            segment=self.segment\n        )\n\n        assert self.dataset\n\n        name = PartialPartitionName(**d).promote(self.dataset.identity.name)\n\n        self.name = str(name.name)\n        self.vname = str(name.vname)\n        self.cache_key = name.cache_key\n        self.fqname = str(self.identity.fqname)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dataframe(self, predicate=None, filtered_columns=None, columns=None, df_class=None):\n\n        from operator import itemgetter\n        from ambry.pands import AmbryDataFrame\n\n        df_class = df_class or AmbryDataFrame\n\n        if columns:\n            ig = itemgetter(*columns)\n        else:\n            ig = None\n            columns = self.table.header\n\n        if filtered_columns:\n\n            def maybe_quote(v):\n                from six import string_types\n                if isinstance(v, string_types):\n                    return '\"{}\"'.format(v)\n                else:\n                    return v\n\n            code = ' and '.join(\"row.{} == {}\".format(k, maybe_quote(v))\n                                for k, v in filtered_columns.items())\n\n            predicate = eval('lambda row: {}'.format(code))\n\n        if predicate:\n            def yielder():\n                for row in self.reader:\n                    if predicate(row):\n                        if ig:\n                            yield ig(row)\n                        else:\n                            yield row.dict\n\n            df = df_class(yielder(), columns=columns, partition=self.measuredim)\n\n            return df\n\n        else:\n\n            def yielder():\n                for row in self.reader:\n                    yield row.values()\n\n            # Put column names in header order\n            columns = [c for c in self.table.header if c in columns]\n\n            return df_class(yielder(), columns=columns, partition=self.measuredim)", "response": "Return the partition as a Pandas dataframe."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning geodata as a list of Shapely objects.", "response": "def shapes(self, simplify=None, predicate=None):\n        \"\"\"\n        Return geodata as a list of Shapely shapes\n\n        :param simplify: Integer or None. Simplify the geometry to a tolerance, in the units of the geometry.\n        :param predicate: A single-argument function to select which records to include in the output.\n\n        :return: A list of Shapely objects\n        \"\"\"\n\n        from shapely.wkt import loads\n\n        if not predicate:\n            predicate = lambda row: True\n\n        if simplify:\n            return [loads(row.geometry).simplify(simplify) for row in self if predicate(row)]\n        else:\n            return [loads(row.geometry) for row in self if predicate(row)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the geodata as a list of Matplotlib patches.", "response": "def patches(self, basemap, simplify=None, predicate=None, args_f=None, **kwargs):\n        \"\"\"\n        Return geodata as a list of Matplotlib patches\n\n        :param basemap: A mpl_toolkits.basemap.Basemap\n        :param simplify: Integer or None. Simplify the geometry to a tolerance, in the units of the geometry.\n        :param predicate: A single-argument function to select which records to include in the output.\n        :param args_f: A function that takes a row and returns a dict of additional args for the Patch constructor\n\n        :param kwargs: Additional args to be passed to the descartes Path constructor\n        :return: A list of patch objects\n        \"\"\"\n        from descartes import PolygonPatch\n        from shapely.wkt import loads\n        from shapely.ops import transform\n\n        if not predicate:\n            predicate = lambda row: True\n\n        def map_xform(x, y, z=None):\n            return basemap(x, y)\n\n        def make_patch(shape, row):\n\n            args = dict(kwargs.items())\n\n            if args_f:\n                args.update(args_f(row))\n\n            return PolygonPatch(transform(map_xform, shape), **args)\n\n        def yield_patches(row):\n\n            if simplify:\n                shape = loads(row.geometry).simplify(simplify)\n            else:\n                shape = loads(row.geometry)\n\n            if shape.geom_type == 'MultiPolygon':\n                for subshape in shape.geoms:\n                    yield make_patch(subshape, row)\n            else:\n                yield make_patch(shape, row)\n\n        return [patch for row in self if predicate(row)\n                for patch in yield_patches(row)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\niterating over all measures", "response": "def measures(self):\n        \"\"\"Iterate over all measures\"\"\"\n        from ambry.valuetype.core import ROLE\n\n        return [c for c in self.columns if c.role == ROLE.MEASURE]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a measure given its vid or another reference", "response": "def measure(self, vid):\n        \"\"\"Return a measure, given its vid or another reference\"\"\"\n\n        from ambry.orm import Column\n\n        if isinstance(vid, PartitionColumn):\n            return vid\n        elif isinstance(vid, Column):\n            return PartitionColumn(vid)\n        else:\n            return PartitionColumn(self.table.column(vid), self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dataframe(self, measure, p_dim, s_dim=None, filters={}, df_class=None):\n\n        import numpy as np\n\n        measure = self.measure(measure)\n\n        p_dim = self.dimension(p_dim)\n\n        assert p_dim\n\n        if s_dim:\n            s_dim = self.dimension(s_dim)\n\n        columns = set([measure.name, p_dim.name])\n\n        if p_dim.label:\n\n            # For geographic datasets, also need the gvid\n            if p_dim.geoid:\n                columns.add(p_dim.geoid.name)\n\n            columns.add(p_dim.label.name)\n\n        if s_dim:\n\n            columns.add(s_dim.name)\n\n            if s_dim.label:\n                columns.add(s_dim.label.name)\n\n        def maybe_quote(v):\n            from six import string_types\n            if isinstance(v, string_types):\n                return '\"{}\"'.format(v)\n            else:\n                return v\n\n        # Create the predicate to filter out the filtered dimensions\n        if filters:\n\n            selected_filters = []\n\n            for k, v in filters.items():\n                if isinstance(v, dict):\n                    # The filter is actually the whole set of possible options, so\n                    # just select the first one\n                    v = v.keys()[0]\n\n                selected_filters.append(\"row.{} == {}\".format(k, maybe_quote(v)))\n\n            code = ' and '.join(selected_filters)\n\n            predicate = eval('lambda row: {}'.format(code))\n        else:\n            code = None\n\n            def predicate(row):\n                return True\n\n\n        df = self.analysis.dataframe(predicate, columns=columns, df_class=df_class)\n\n        if df is None or df.empty or len(df) == 0:\n            return None\n\n        # So we can track how many records were aggregated into each output row\n        df['_count'] = 1\n\n        def aggregate_string(x):\n            return ', '.join(set(str(e) for e in x))\n\n        agg = {\n            '_count': 'count',\n\n        }\n\n        for col_name in columns:\n            c = self.column(col_name)\n\n            # The primary and secondary dimensions are put into the index by groupby\n            if c.name == p_dim.name or (s_dim and c.name == s_dim.name):\n                continue\n\n            # FIXME! This will only work if the child is only level from the parent. Should\n            # have an acessor for the top level.\n            if c.parent and (c.parent == p_dim.name or (s_dim and c.parent == s_dim.name)):\n                continue\n\n            if c.is_measure:\n                agg[c.name] = np.mean\n\n            if c.is_dimension:\n                agg[c.name] = aggregate_string\n\n        plot_axes = [p_dim.name]\n\n        if s_dim:\n            plot_axes.append(s_dim.name)\n\n        df = df.groupby(list(columns - set([measure.name]))).agg(agg).reset_index()\n\n        df._metadata = ['plot_axes', 'filtered', 'floating', 'labels', 'dimension_set', 'measure']\n\n        df.plot_axes = [c for c in plot_axes]\n        df.filtered = filters\n\n        # Dimensions that are not specified as axes nor filtered\n        df.floating = list(set(c.name for c in self.primary_dimensions) -\n                           set(df.filtered.keys()) -\n                           set(df.plot_axes))\n\n        df.labels = [self.column(c).label.name if self.column(c).label else c for c in df.plot_axes]\n\n        df.dimension_set = self.dimension_set(p_dim, s_dim=s_dim)\n\n        df.measure = measure.name\n\n        def rows(self):\n            yield ['id'] + list(df.columns)\n\n            for t in df.itertuples():\n                yield list(t)\n\n        # Really should not do this, but I don't want to re-build the dataframe with another\n        # class\n        df.__class__.rows = property(rows)\n\n\n\n        return df", "response": "Return a dataframe with a sumse of the columns of the partition including a measure one_or_two_dimension and a secondary dimension."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dimension_set(self, p_dim, s_dim=None, dimensions=None, extant=set()):\n\n        if not dimensions:\n            dimensions = self.primary_dimensions\n\n        key = p_dim.name\n\n        if s_dim:\n            key += '/' + s_dim.name\n\n        # Ignore if the key already exists or the primary and secondary dims are the same\n        if key in extant or p_dim == s_dim:\n            return\n\n        # Don't allow geography to be a secondary dimension. It must either be a primary dimension\n        # ( to make a map ) or a filter, or a small-multiple\n        if s_dim and s_dim.valuetype_class.is_geo():\n            return\n\n        extant.add(key)\n\n        filtered = {}\n\n        for d in dimensions:\n            if d != p_dim and d != s_dim:\n                filtered[d.name] = d.pstats.uvalues.keys()\n\n        if p_dim.valuetype_class.is_time():\n            value_type = 'time'\n            chart_type = 'line'\n        elif p_dim.valuetype_class.is_geo():\n            value_type = 'geo'\n            chart_type = 'map'\n        else:\n            value_type = 'general'\n            chart_type = 'bar'\n\n        return dict(\n            key=key,\n            p_dim=p_dim.name,\n            p_dim_type=value_type,\n            p_label=p_dim.label_or_self.name,\n            s_dim=s_dim.name if s_dim else None,\n            s_label=s_dim.label_or_self.name if s_dim else None,\n            filters=filtered,\n            chart_type=chart_type\n        )", "response": "Return a dictionary that describes one or two dimensions for a plot."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef label(self):\n        for c in self.table.columns:\n            if c.parent == self.name and 'label' in c.valuetype:\n                return PartitionColumn(c, self._partition)", "response": "Return first child that of the column that is marked as a label"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a map of column code values mapped to labels for columns that have a label column.", "response": "def value_labels(self):\n        \"\"\"Return a map of column code values mapped to labels, for columns that have a label column\n\n        If the column is not assocaited with a label column, it returns an identity map.\n\n        WARNING! This reads the whole partition, so it is really slow\n\n        \"\"\"\n\n        from operator import itemgetter\n\n        card = self.pstats.nuniques\n\n        if self.label:\n            ig = itemgetter(self.name, self.label.name)\n        elif self.pstats.nuniques < MAX_LABELS:\n            ig = itemgetter(self.name, self.name)\n        else:\n            return {}\n\n        label_set = set()\n        for row in self._partition:\n            label_set.add(ig(row))\n\n            if len(label_set) >= card:\n                break\n\n        d = dict(label_set)\n\n        assert len(d) == len(label_set)  # Else the label set has multiple values per key\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_build_configuration_sets(page_size=200, page_index=0, sort=\"\", q=\"\"):\n    data = list_build_configuration_sets_raw(page_size, page_index, sort, q)\n    if data:\n        return utils.format_json_list(data)", "response": "List all build configuration sets in a project"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new BuildConfigurationSet object and return it.", "response": "def create_build_configuration_set_raw(**kwargs):\n    \"\"\"\n    Create a new BuildConfigurationSet.\n    \"\"\"\n    config_set = _create_build_config_set_object(**kwargs)\n    response = utils.checked_api_call(pnc_api.build_group_configs, 'create_new', body=config_set)\n    if response:\n        return response.content"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_build_configuration_set_raw(id=None, name=None):\n    found_id = common.set_id(pnc_api.build_group_configs, id, name)\n    response = utils.checked_api_call(pnc_api.build_group_configs, 'get_specific', id=found_id)\n    if response:\n        return response.content", "response": "Get a specific BuildConfigurationSet by name or ID\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a specific BuildConfigurationSet by name or ID", "response": "def get_build_configuration_set(id=None, name=None):\n    \"\"\"\n    Get a specific BuildConfigurationSet by name or ID\n    \"\"\"\n    content = get_build_configuration_set_raw(id, name)\n    if content:\n        return utils.format_json(content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates a BuildConfigurationSet with the specified ID", "response": "def update_build_configuration_set(id, **kwargs):\n    \"\"\"\n    Update a BuildConfigurationSet\n    \"\"\"\n    data = update_build_configuration_set_raw(id, **kwargs)\n    if data:\n        return utils.format_json(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new build set for the given BuildConfigurationSet.", "response": "def build_set_raw(id=None, name=None,\n                  tempbuild=False, timestamp_alignment=False,\n                  force=False, rebuild_mode=common.REBUILD_MODES_DEFAULT,\n                  **kwargs):\n    \"\"\"\n    Start a build of the given BuildConfigurationSet\n    \"\"\"\n    logging.debug(\"temp_build: \" + str(tempbuild))\n    logging.debug(\"timestamp_alignment: \" + str(timestamp_alignment))\n    logging.debug(\"force: \" + str(force))\n    if tempbuild is False and timestamp_alignment is True:\n        logging.error(\"You can only activate timestamp alignment with the temporary build flag!\")\n        sys.exit(1)\n\n    found_id = common.set_id(pnc_api.build_group_configs, id, name)\n\n    revisions = kwargs.get(\"id_revisions\")\n    if revisions:\n        id_revs = map(__parse_revision, revisions)\n\n        bcsRest = common.get_entity(pnc_api.build_group_configs, found_id)\n        body = swagger_client.BuildConfigurationSetWithAuditedBCsRest()\n        body = __fill_BCSWithAuditedBCs_body(body, bcsRest, id_revs)\n\n        response = utils.checked_api_call(pnc_api.build_group_configs, 'build_versioned', id=found_id,\n                                          temporary_build=tempbuild,\n                                          timestamp_alignment=timestamp_alignment,\n                                          force_rebuild=force,\n                                          rebuild_mode=rebuild_mode,\n                                          body=body)\n    else:\n        response = utils.checked_api_call(pnc_api.build_group_configs, 'build', id=found_id,\n                                      temporary_build=tempbuild,\n                                      timestamp_alignment=timestamp_alignment,\n                                      force_rebuild=force,\n                                      rebuild_mode=rebuild_mode)\n    if response:\n        return response.content"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart a build of a BuildConfigurationSet", "response": "def build_set(id=None, name=None, temporary_build=False, timestamp_alignment=False,\n              force=False, rebuild_mode=common.REBUILD_MODES_DEFAULT, **kwargs):\n    \"\"\"\n    Start a build of the given BuildConfigurationSet\n    \"\"\"\n    content = build_set_raw(id, name,\n                            temporary_build, timestamp_alignment, force, rebuild_mode, **kwargs)\n    if content:\n        return utils.format_json(content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_build_configurations_for_set(id=None, name=None, page_size=200, page_index=0, sort=\"\", q=\"\"):\n    content = list_build_configurations_for_set_raw(id, name, page_size, page_index, sort, q)\n    if content:\n        return utils.format_json_list(content)", "response": "List all build configurations for a given BuildConfigurationSet"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a build configuration to an existing BuildConfigurationSet", "response": "def add_build_configuration_to_set(\n        set_id=None, set_name=None, config_id=None, config_name=None):\n    \"\"\"\n    Add a build configuration to an existing BuildConfigurationSet\n    \"\"\"\n    content = add_build_configuration_to_set_raw(set_id, set_name, config_id, config_name)\n    if content:\n        return utils.format_json(content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_build_records_for_set(id=None, name=None, page_size=200, page_index=0, sort=\"\", q=\"\"):\n    content = list_build_records_for_set_raw(id, name, page_size, page_index, sort, q)\n    if content:\n        return utils.format_json_list(content)", "response": "List all build records for a BuildConfigurationSet"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists all build set records for a BuildConfigurationSet", "response": "def list_build_set_records(id=None, name=None, page_size=200, page_index=0, sort=\"\", q=\"\"):\n    \"\"\"\n    List all build set records for a BuildConfigurationSet\n    \"\"\"\n    content = list_build_set_records_raw(id, name, page_size, page_index, sort, q)\n    if content:\n        return utils.format_json_list(content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef react(reactor, main, argv):\n    stopping = []\n    reactor.addSystemEventTrigger('before', 'shutdown', stopping.append, True)\n    finished = main(reactor, *argv)\n    finished.addErrback(err, \"main function encountered error\")\n    def cbFinish(ignored):\n        if not stopping:\n            reactor.callWhenRunning(reactor.stop)\n    finished.addCallback(cbFinish)\n    reactor.run()", "response": "Call main and run the reactor until the L { Deferred s return value fires."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_model(cls, ModelClass, form_field=None, widget=None, title=None, prefix=None):\n        cls._static_registry.register(ModelClass, form_field, widget, title, prefix)", "response": "Register a model class to use in the URL field."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nresolve AnyUrlValue objects from a list of objects.", "response": "def resolve_objects(cls, objects, skip_cached_urls=False):\n        \"\"\"\n        Make sure all AnyUrlValue objects from a set of objects is resolved in bulk.\n        This avoids making a query per item.\n\n        :param objects: A list or queryset of models.\n        :param skip_cached_urls: Whether to avoid prefetching data that has it's URL cached.\n        \"\"\"\n        # Allow the queryset or list to consist of multiple models.\n        # This supports querysets from django-polymorphic too.\n        queryset = list(objects)\n        any_url_values = []\n\n        for obj in queryset:\n            model = obj.__class__\n            for field in _any_url_fields_by_model[model]:\n                any_url_value = getattr(obj, field)\n                if any_url_value and any_url_value.url_type.has_id_value:\n                    any_url_values.append(any_url_value)\n\n        AnyUrlValue.resolve_values(any_url_values, skip_cached_urls=skip_cached_urls)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the default run_config object for this installation.", "response": "def config(path=None, root=None, db=None):\n    \"\"\"Return the default run_config object for this installation.\"\"\"\n    import ambry.run\n    return ambry.run.load(path=path, root=root, db=db)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the default library for this installation.", "response": "def get_library(path=None, root=None, db=None):\n    import ambry.library as _l\n    \"\"\"Return the default library for this installation.\"\"\"\n\n    rc = config(path=path, root=root, db=db )\n\n    return _l.new_library(rc)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef doc_parser():\n\n    parser = argparse.ArgumentParser(\n        prog='ambry',\n        description='Ambry {}. Management interface for ambry, libraries '\n                    'and repositories. '.format(ambry._meta.__version__))\n\n    return parser", "response": "Utility function to allow getting the arguments for a single command for Sphinx documentation"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_extra_commands():\n    from ambry.run import find_config_file\n    from ambry.dbexceptions import ConfigurationError\n    from ambry.util import yaml\n\n    try:\n        plugins_dir = find_config_file('cli.yaml')\n    except ConfigurationError:\n        return []\n\n    with open(plugins_dir) as f:\n        cli_modules = yaml.load(f)\n\n    return cli_modules", "response": "Use the configuration to discover additional CLI packages to load"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef url(self):\n        local_path = self._find_in_local()\n        if local_path:\n            return local_path\n\n        if not self._url:\n            self._refresh_url()\n        elif time.time() > self._expired_at:\n            logger.info('song({}) url is expired, refresh...'.format(self))\n            self._refresh_url()\n        return self._url", "response": "Return the url of the local file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_handler(progname, fmt=None, datefmt=None, project_id=None,\n                credentials=None, debug_thread_worker=False, **_):\n    \"\"\"Helper function to create a Stackdriver handler.\n\n    See `ulogger.stackdriver.CloudLoggingHandlerBuilder` for arguments\n    and supported keyword arguments.\n\n    Returns:\n        (obj): Instance of `google.cloud.logging.handlers.\n                            CloudLoggingHandler`\n    \"\"\"\n    builder = CloudLoggingHandlerBuilder(\n        progname, fmt=fmt, datefmt=datefmt, project_id=project_id,\n        credentials=credentials, debug_thread_worker=debug_thread_worker)\n    return builder.get_handler()", "response": "Helper function to create a CloudLoggingHandler object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_metadata(self, data_type, key, timeout=5):\n        endpoint_url = self.METADATA_ENDPOINT.format(\n            data_type=data_type, key=key)\n        try:\n            rsp = requests.get(\n                endpoint_url,\n                headers={'Metadata-Flavor': 'Google'},\n                timeout=timeout)\n            rsp.raise_for_status()\n        except requests.exceptions.RequestException as e:\n            raise exceptions.GoogleCloudError(\n                'Could not fetch \"{key}\" from \"{type}\" metadata using \"{url}\".'\n                'Error: {e}'.format(\n                    key=key, type=data_type, url=endpoint_url, e=e))\n        metadata_value = rsp.text\n        if metadata_value.strip() == '':\n            raise exceptions.GoogleCloudError(\n                'Error when fetching metadata from \"{url}\": server returned '\n                'an empty value.'.format(url=endpoint_url))\n        return metadata_value", "response": "Get the metadata value from the Cloud Storage instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _create_gcl_resource(self):\n\n        return gcl_resource.Resource('gce_instance', {\n            'project_id': self.project_id,\n            'instance_id': self.instance_id,\n            'zone': self.zone\n        })", "response": "Create a configured GCL resource object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a fully configured logging. Formatter instance", "response": "def get_formatter(self):\n        \"\"\"Create a fully configured `logging.Formatter`\n\n        Example of formatted log message:\n        2017-08-27T20:19:24.424 cpm-example-gew1 progname (23123): hello\n\n        Returns:\n            (obj): Instance of `logging.Formatter`\n        \"\"\"\n        if not self.fmt:\n            self.fmt = ('%(asctime)s.%(msecs)03d {host} {progname} '\n                        '(%(process)d): %(message)s').format(\n                        host=self.hostname, progname=self.progname)\n        if not self.datefmt:\n            self.datefmt = '%Y-%m-%dT%H:%M:%S'\n        return logging.Formatter(fmt=self.fmt, datefmt=self.datefmt)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_worker_thread_level(self):\n        bthread_logger = logging.getLogger(\n            'google.cloud.logging.handlers.transports.background_thread')\n        if self.debug_thread_worker:\n            bthread_logger.setLevel(logging.DEBUG)\n        else:\n            bthread_logger.setLevel(logging.INFO)", "response": "Sets logging level of the background logging thread to DEBUG or INFO."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_handler(self):\n\n        gcl_client = gcl_logging.Client(\n            project=self.project_id, credentials=self.credentials)\n        handler = gcl_handlers.CloudLoggingHandler(\n            gcl_client,\n            resource=self.resource,\n            labels={\n                'resource_id': self.instance_id,\n                'resource_project': self.project_id,\n                'resource_zone': self.zone,\n                'resource_host': self.hostname\n            })\n        handler.setFormatter(self.get_formatter())\n        self._set_worker_thread_level()\n        return handler", "response": "Create a fully configured CloudLoggingHandler."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd given dataset to the index.", "response": "def index_dataset(self, dataset, force=False):\n        \"\"\" Adds given dataset to the index. \"\"\"\n        self.backend.dataset_index.index_one(dataset, force=force)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding given partition to the index.", "response": "def index_partition(self, partition, force=False):\n        \"\"\" Adds given partition to the index. \"\"\"\n        self.backend.partition_index.index_one(partition, force=force)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef index_bundle(self, bundle, force=False):\n        from ambry.orm.dataset import Dataset\n\n        dataset = bundle if isinstance(bundle, Dataset) else bundle.dataset\n\n        self.index_dataset(dataset, force)\n\n        for partition in dataset.partitions:\n            self.index_partition(partition, force)", "response": "Indexes a bundle or dataset and all of its partitions."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef index_library_datasets(self, tick_f=None):\n\n        dataset_n = 0\n        partition_n = 0\n\n        def tick(d, p):\n            if tick_f:\n                tick_f('datasets: {} partitions: {}'.format(d, p))\n\n        for dataset in self.library.datasets:\n\n            if self.backend.dataset_index.index_one(dataset):\n                # dataset added to index\n                dataset_n += 1\n                tick(dataset_n, partition_n)\n                for partition in dataset.partitions:\n                    self.backend.partition_index.index_one(partition)\n                    partition_n += 1\n                    tick(dataset_n, partition_n)\n            else:\n                # dataset already indexed\n                pass", "response": "Index all datasets of the library."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search(self, search_phrase, limit=None):\n        from ambry.identity import ObjectNumber\n        from ambry.orm.exc import NotFoundError\n        from ambry.library.search_backends.base import SearchTermParser\n\n        results = []\n\n        stp = SearchTermParser()\n\n        # Because of the split between searching for partitions and bundles, some terms don't behave right.\n        # The source term should be a limit on everything, but it isn't part of the partition doc,\n        # so we check for it here.\n        parsed_terms = stp.parse(search_phrase)\n\n        for r in self.search_datasets(search_phrase, limit):\n            vid = r.vid or ObjectNumber.parse(next(iter(r.partitions))).as_dataset\n\n            r.vid = vid\n\n            try:\n                r.bundle = self.library.bundle(r.vid)\n\n                if 'source' not in parsed_terms or parsed_terms['source'] in r.bundle.dataset.source:\n                    results.append(r)\n            except NotFoundError:\n                pass\n\n        return sorted(results, key=lambda r : r.score, reverse=True)", "response": "Search for datasets and expand to database records"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_documents(self, limit=None):\n        from itertools import chain\n\n        return chain(self.backend.dataset_index.list_documents(limit=limit),\n                     self.backend.partition_index.list_documents(limit=limit),\n                     self.backend.identifier_index.list_documents(limit=limit))", "response": "Return a list of the documents in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_parsed_query(self):\n        return '{} OR {}'.format(\n            self.backend.dataset_index.get_parsed_query()[0],\n            self.backend.partition_index.get_parsed_query()[0])", "response": "Returns string with last query parsed. Assuming called after search_datasets."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_build_configuration_set_records(page_size=200, page_index=0, sort=\"\", q=\"\"):\n    data = list_build_configuration_set_records_raw(page_size, page_index, sort, q)\n    if data:\n        return utils.format_json_list(data)", "response": "List all build configuration set records."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist all BuildRecords for a given BuildConfigSet", "response": "def list_records_for_build_config_set(id, page_size=200, page_index=0, sort=\"\", q=\"\"):\n    \"\"\"\n    Get a list of BuildRecords for the given BuildConfigSetRecord\n    \"\"\"\n    data = list_records_for_build_config_set_raw(id, page_size, page_index, sort, q)\n    if data:\n        return utils.format_json_list(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sync_accounts(self, accounts_data, clear = False, password=None, cb = None):\n\n        # Map common values into the accounts records\n\n        all_accounts = self.accounts\n\n        kmap = Account.prop_map()\n\n        for account_id, values in accounts_data.items():\n\n            if not isinstance(values, dict):\n                continue\n\n            d = {}\n\n            a = self.library.find_or_new_account(account_id)\n            a.secret_password = password or self.password\n\n            for k, v in values.items():\n                if k in ('id',):\n                    continue\n                try:\n                    if kmap[k] == 'secret' and v:\n                        a.encrypt_secret(v)\n                    else:\n                        setattr(a, kmap[k], v)\n                except KeyError:\n                    d[k] = v\n\n            a.data = d\n\n            if values.get('service') == 's3':\n                a.url = 's3://{}'.format(a.account_id)\n\n            if cb:\n                cb('Loaded account: {}'.format(a.account_id))\n\n            self.database.session.commit()", "response": "Synchronize all of the accounts in the config file into the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef robust_int(v):\n\n    if isinstance(v, int):\n        return v\n\n    if isinstance(v, float):\n        return int(v)\n\n    v = str(v).replace(',', '')\n\n    if not v:\n        return None\n\n    return int(v)", "response": "Parse an int robustly ignoring commas and other cruft."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dynamic subclass of the given class with the extra parameters built in .", "response": "def subclass(cls, vt_code, vt_args):\n        \"\"\"\n        Return a dynamic subclass that has the extra parameters built in\n        :param vt_code: The full VT code, privided to resolve_type\n        :param vt_args: The portion of the VT code to the right of the part that matched a ValueType\n        :return:\n        \"\"\"\n        return type(vt_code.replace('/', '_'), (cls,), {'vt_code': vt_code, 'vt_args': vt_args})"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a template name and template vars. Returns a string containing the rendered template.", "response": "def render(self, template_name, **kw):\n        '''\n        Given a template name and template vars.\n        Searches a template file based on engine set, and renders it \n        with corresponding engine.\n        Returns a string.\n        '''\n        logger.debug('Rendering template \"%s\"', template_name)\n        vars = self.globs.copy()\n        vars.update(kw)\n        resolved_name, engine = self.resolve(template_name)\n        return engine.render(resolved_name, **vars)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render(self, template_name, __data=None, **kw):\n        '''Given a template name and template data.\n        Renders a template and returns as string'''\n        return self.template.render(template_name,\n                                    **self._vars(__data, **kw))", "response": "Given a template name and template data.\n        Renders a template and returns as string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a template name and template data. Renders a template and returns a webob. Response object", "response": "def render_to_response(self, template_name, __data,\n                           content_type=\"text/html\"):\n        '''Given a template name and template data.\n        Renders a template and returns `webob.Response` object'''\n        resp = self.render(template_name, __data)\n        return Response(resp,\n                        content_type=content_type)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef per_section(it, is_delimiter=lambda x: x.isspace()):\n    ret = []\n    for line in it:\n        if is_delimiter(line):\n            if ret:\n                yield ret  # OR  ''.join(ret)\n                ret = []\n        else:\n            ret.append(line.rstrip())  # OR  ret.append(line)\n    if ret:\n        yield ret", "response": "Yields the list of all the items in the archive that are in the order they appear."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef per_chunk(iterable, n=1, fillvalue=None):\n    args = [iter(iterable)] * n\n    return zip_longest(*args, fillvalue=fillvalue)", "response": "Generator that returns n elements of the given iterable."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a sliding window with a constraint to check that target is inside the window.", "response": "def skipping_window(sequence, target, n=3):\n    \"\"\"\n    Return a sliding window with a constraint to check that\n    target is inside the window.\n    From http://stackoverflow.com/q/43626525/610569\n\n        >>> list(skipping_window([1,2,3,4,5], 2, 3))\n        [(1, 2, 3), (2, 3, 4)]\n    \"\"\"\n    start, stop = 0, n\n    seq = list(sequence)\n    while stop <= len(seq):\n        subseq = seq[start:stop]\n        if target in subseq:\n            yield tuple(seq[start:stop])\n        start += 1\n        stop += 1\n        # Fast forwarding the start.\n        # Find the next window which contains the target.\n        try:\n            # `seq.index(target, start) - (n-1)` would be the next\n            # window where the constraint is met.\n            start = max(seq.index(target, start) - (n-1), start)\n            stop = start + n\n        except ValueError:\n            break"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninspire by https://stackoverflow.com/q/42549212/610569 >>> list(range(12)) # Linear. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] >>> camel_shuffle(list(range(12))) # M-shape. [0, 4, 8, 9, 5, 1, 2, 6, 10, 11, 7, 3] >>> camel_shuffle(list(reversed(range(12)))) #W-shape. [11, 7, 3, 2, 6, 10, 9, 5, 1, 0, 4, 8]", "response": "def camel_shuffle(sequence):\n    \"\"\"\n    Inspired by https://stackoverflow.com/q/42549212/610569\n\n        >>> list(range(12)) # Linear.\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n\n        >>> camel_shuffle(list(range(12))) # M-shape.\n        [0, 4, 8, 9, 5, 1, 2, 6, 10, 11, 7, 3]\n\n        >>> camel_shuffle(list(reversed(range(12)))) #W-shape.\n        [11, 7, 3, 2, 6, 10, 9, 5, 1, 0, 4, 8]\n    \"\"\"\n    one_three, two_four = zigzag(sequence)\n    one, three = zigzag(one_three)\n    two, four = zigzag(two_four)\n    return one + list(reversed(two)) + three + list(reversed(four))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef url(self):\n        '''Current or base URL. Can be redefined via keyword argument on\n        initialization.\n\n        Returns `iktomi.web.URL object.\n        `'''\n        return URL.from_url(self.request.url, show_host=self.show_host)", "response": "Current or base URL. Can be redefined via keyword argument on\n        initialization."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn URL for page.", "response": "def page_url(self, page):\n        '''\n        Returns URL for page, page is included as query parameter.\n\n        Can be redefined by keyword argument\n        '''\n        if page is not None and page != 1:\n            return self.url.qs_set(**{self.page_param: page})\n        elif page is not None:\n            return self.url.qs_delete('page')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nslices the sequence of all items to obtain them for current page.", "response": "def slice(self, items):\n        '''Slice the sequence of all items to obtain them for current page.'''\n        if self.limit:\n            if self.page>self.pages_count:\n                return []\n            if self.page == self.pages_count:\n                return items[self.limit*(self.page-1):]\n            return items[self.limit*(self.page-1):self.limit*self.page]\n        else:\n            return items[:]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_build_configurations(self, id, **kwargs):\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('callback'):\n            return self.get_build_configurations_with_http_info(id, **kwargs)\n        else:\n            (data) = self.get_build_configurations_with_http_info(id, **kwargs)\n            return data", "response": "Get all BuildConfigurations associated with the specified Project Id"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists all BuildRecords in a Page", "response": "def list_build_records(page_size=200, page_index=0, sort=\"\", q=\"\"):\n    \"\"\"\n    List all BuildRecords\n    \"\"\"\n    data = list_build_records_raw(page_size, page_index, sort, q)\n    if data:\n        return utils.format_json_list(data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting all BuildRecords for a given BuildConfiguration", "response": "def list_records_for_build_configuration(id=None, name=None, page_size=200, page_index=0, sort=\"\", q=\"\"):\n    \"\"\"\n    List all BuildRecords for a given BuildConfiguration\n    \"\"\"\n    data = list_records_for_build_configuration_raw(id, name, page_size, page_index, sort, q)\n    if data:\n        return utils.format_json_list(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_records_for_project(id=None, name=None, page_size=200, page_index=0, sort=\"\", q=\"\"):\n    data = list_records_for_project_raw(id, name, page_size, page_index, sort, q)\n    if data:\n        return utils.format_json_list(data)", "response": "List all BuildRecords for a given Project"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_built_artifacts(id, page_size=200, page_index=0, sort=\"\", q=\"\"):\n    data = list_built_artifacts_raw(id, page_size, page_index, sort, q)\n    if data:\n        return utils.format_json_list(data)", "response": "List Artifacts associated with a BuildRecord"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists dependency artifacts associated with a BuildRecord", "response": "def list_dependency_artifacts(id, page_size=200, page_index=0, sort=\"\", q=\"\"):\n    \"\"\"\n    List dependency artifacts associated with a BuildRecord\n    \"\"\"\n    data = list_dependency_artifacts_raw(id, page_size, page_index, sort, q)\n    if data:\n        return utils.format_json_list(data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_start(self):\n        logger.info('StatusReporter started.')\n        # if configured not to report status then return immediately\n        if self.config['status_update_interval'] == 0:\n            logger.info('StatusReporter disabled by configuration.')\n            return\n        self.in_future.report_status()", "response": "Runs when the actor is started and schedules a status update"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef report_again(self, current_status):\n        # calculate sleep interval based on current status and configured interval\n        _m = {'playing': 1, 'paused': 2, 'stopped': 5}[current_status['state']]\n        interval = (self.config['status_update_interval'] * _m) / 1000.0\n        # sleep for computed interval and kickoff another webhook\n        time.sleep(interval)\n        self.in_future.report_status()", "response": "Checks the status of the current webhook and reports it again."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting status of player from mopidy core and send webhook.", "response": "def report_status(self):\n        \"\"\"Get status of player from mopidy core and send webhook.\n        \"\"\"\n        current_status = {\n            'current_track': self.core.playback.current_track.get(),\n            'state': self.core.playback.state.get(),\n            'time_position': self.core.playback.time_position.get(),\n        }\n        send_webhook(self.config, {'status_report': current_status})\n        self.report_again(current_status)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_urlfield_cache_key(model, pk, language_code=None):\n    return 'anyurlfield.{0}.{1}.{2}.{3}'.format(model._meta.app_label, model.__name__, pk, language_code or get_language())", "response": "Get the cache key for a model and pk."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the list of cache keys associated with an object.", "response": "def get_object_cache_keys(instance):\n    \"\"\"\n    Return the cache keys associated with an object.\n    \"\"\"\n    if not instance.pk or instance._state.adding:\n        return []\n\n    keys = []\n    for language in _get_available_languages(instance):\n        keys.append(get_urlfield_cache_key(instance.__class__, instance.pk, language))\n\n    return keys"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nflush the current accumulator to the moving average queue and resets the last average value.", "response": "def flush(self):\n        \"\"\" Add accumulator to the moving average queue and reset it. For\n        example, called by the StatsCollector once per second to calculate\n        per-second average.\n        \"\"\"\n        n = self.accumulator\n        self.accumulator = 0\n\n        stream = self.stream\n        stream.append(n)\n        self.sum += n\n\n        streamlen = len(stream)\n\n        if streamlen > self.period:\n            self.sum -= stream.popleft()\n            streamlen -= 1\n\n        if streamlen == 0:\n            self.last_average = 0\n        else:\n            self.last_average = self.sum / streamlen"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_webhook(config, payload):\n    try:\n        response = requests.post(\n            config['webhook_url'],\n            data=json.dumps(payload, cls=ModelJSONEncoder),\n            headers={config['api_key_header_name']: config['api_key']},\n        )\n    except Exception as e:\n        logger.warning('Unable to send webhook: ({1}) {2}'.format(\n            e.__class__.__name__,\n            e.message,\n        ))\n    else:\n        logger.debug('Webhook response: ({0}) {1}'.format(\n            response.status_code,\n            response.text,\n        ))", "response": "Sends a HTTP request to the configured server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving all of the tables and data from the warehouse", "response": "def clean(self):\n        \"\"\"Remove all of the tables and data from the warehouse\"\"\"\n        connection = self._backend._get_connection()\n        self._backend.clean(connection)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list(self):\n        connection = self._backend._get_connection()\n        return list(self._backend.list(connection))", "response": "List the tables in the database"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef install(self, ref, table_name=None, index_columns=None,logger=None):\n\n\n        try:\n            obj_number = ObjectNumber.parse(ref)\n            if isinstance(obj_number, TableNumber):\n                table = self._library.table(ref)\n                connection = self._backend._get_connection()\n                return self._backend.install_table(connection, table, logger=logger)\n            else:\n                # assume partition\n                raise NotObjectNumberError\n\n        except NotObjectNumberError:\n            # assume partition.\n            partition = self._library.partition(ref)\n            connection = self._backend._get_connection()\n\n            return self._backend.install(\n                connection, partition, table_name=table_name, index_columns=index_columns,\n                logger=logger)", "response": "Installs a partition by reference and installs it to warehouse db."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef materialize(self, ref, table_name=None, index_columns=None, logger=None):\n        from ambry.library import Library\n        assert isinstance(self._library, Library)\n\n        logger.debug('Materializing warehouse partition.\\n    partition: {}'.format(ref))\n        partition = self._library.partition(ref)\n\n        connection = self._backend._get_connection()\n\n        return self._backend.install(connection, partition, table_name=table_name,\n                                     index_columns=index_columns, materialize=True, logger=logger)", "response": "Creates a materialized table for the given partition reference."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates an index on the columns needed for the given ref.", "response": "def index(self, ref, columns):\n        \"\"\" Create an index on the columns.\n\n        Args:\n            ref (str): id, vid, name or versioned name of the partition.\n            columns (list of str): names of the columns needed indexes.\n\n        \"\"\"\n        from ambry.orm.exc import NotFoundError\n\n        logger.debug('Creating index for partition.\\n    ref: {}, columns: {}'.format(ref, columns))\n\n        connection = self._backend._get_connection()\n\n        try:\n            table_or_partition = self._library.partition(ref)\n        except NotFoundError:\n            table_or_partition = ref\n\n\n        self._backend.index(connection, table_or_partition, columns)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting all sql statements from an ambry sql query.", "response": "def parse_sql(self, asql):\n        \"\"\" Executes all sql statements from asql.\n\n        Args:\n            library (library.Library):\n            asql (str): ambry sql query - see https://github.com/CivicKnowledge/ambry/issues/140 for details.\n        \"\"\"\n        import sqlparse\n\n        statements = sqlparse.parse(sqlparse.format(asql, strip_comments=True))\n        parsed_statements = []\n        for statement in statements:\n\n            statement_str = statement.to_unicode().strip()\n\n            for preprocessor in self._backend.sql_processors():\n                statement_str = preprocessor(statement_str, self._library, self._backend, self.connection)\n\n            parsed_statements.append(statement_str)\n\n        return parsed_statements"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query(self, asql, logger=None):\n        import sqlparse\n        from ambry.mprlib.exceptions import BadSQLError\n        from ambry.bundle.asql_parser import process_sql\n        from ambry.orm.exc import NotFoundError\n\n        if not logger:\n            logger = self._library.logger\n\n        rec = process_sql(asql, self._library)\n\n        for drop in reversed(rec.drop):\n\n            if drop:\n                connection = self._backend._get_connection()\n                cursor = self._backend.query(connection, drop, fetch=False)\n                cursor.close()\n\n        for vid in rec.materialize:\n            logger.debug('Materialize {}'.format(vid))\n            self.materialize(vid, logger=logger)\n\n        for vid in rec.install:\n            logger.debug('Install {}'.format(vid))\n\n            self.install(vid, logger=logger)\n\n\n        for statement in rec.statements:\n\n            statement = statement.strip()\n\n            logger.debug(\"Process statement: {}\".format(statement[:60]))\n\n            if statement.lower().startswith('create'):\n                logger.debug('    Create {}'.format(statement))\n                connection = self._backend._get_connection()\n                cursor = self._backend.query(connection, statement, fetch=False)\n\n                cursor.close()\n\n            elif statement.lower().startswith('select'):\n                logger.debug('Run query {}'.format(statement))\n                connection = self._backend._get_connection()\n                return self._backend.query(connection, statement, fetch=False)\n\n        for table_or_vid, columns in rec.indexes:\n\n            logger.debug('Index {}'.format(table_or_vid))\n\n            try:\n                self.index(table_or_vid, columns)\n            except NotFoundError as e:\n                # Comon when the index table in's a VID, so no partition can be found.\n\n                logger.debug('Failed to index {}; {}'.format(vid, e))\n            except Exception as e:\n                logger.error('Failed to index {}; {}'.format(vid, e))\n\n        # A fake cursor that can be closed and iterated\n        class closable_iterable(object):\n            def close(self):\n                pass\n\n            def __iter__(self):\n                pass\n\n        return closable_iterable()", "response": "Execute an ASQL file and return the result of the first SELECT statement."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dataframe(self,asql, logger = None):\n        import pandas as pd\n        from ambry.mprlib.exceptions import BadSQLError\n\n        try:\n            def yielder(cursor):\n\n                for i, row in enumerate(cursor):\n                    if i == 0:\n                        yield [ e[0] for e in cursor.getdescription()]\n\n                    yield row\n\n            cursor = self.query(asql, logger)\n\n            yld = yielder(cursor)\n\n            header = next(yld)\n\n            return pd.DataFrame(yld, columns=header)\n        except BadSQLError as e:\n            import traceback\n            self._logger.error(\"SQL Error: {}\".format( e))\n            self._logger.debug(traceback.format_exc())", "response": "Like query but returns a Pandas dataframe"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef geoframe(self, sql, simplify=None, crs=None, epsg=4326):\n        import geopandas\n        from shapely.wkt import loads\n        from fiona.crs import from_epsg\n\n        if crs is None:\n            try:\n                crs = from_epsg(epsg)\n            except TypeError:\n                raise TypeError('Must set either crs or epsg for output.')\n\n        df = self.dataframe(sql)\n        geometry = df['geometry']\n\n        if simplify:\n            s = geometry.apply(lambda x: loads(x).simplify(simplify))\n        else:\n            s = geometry.apply(lambda x: loads(x))\n\n        df['geometry'] = geopandas.GeoSeries(s)\n\n        return geopandas.GeoDataFrame(df, crs=crs, geometry='geometry')", "response": "Return a geopandas dataframe with the data from the specified SQL."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef shapes(self, simplify=None):\n\n        from shapely.wkt import loads\n\n        if simplify:\n            return [loads(row.geometry).simplify(simplify) for row in self]\n        else:\n            return [loads(row.geometry) for row in self]", "response": "Return geodata as a list of Shapely objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets url parameter with given index.", "response": "def get_url_param(self, index, default=None):\n        \"\"\"\n        Return url parameter with given index.\n\n        Args:\n        - index: starts from zero, and come after controller and\n          action names in url.\n        \"\"\"\n        params = self.get_url_params()\n        return params[index] if index < len(params) else default"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_widget(self):\n        form_field = self.get_form_field()\n        widget = form_field.widget\n        if isinstance(widget, type):\n            widget = widget()\n\n        # Widget instantiation needs to happen manually.\n        # Auto skip if choices is not an existing attribute.\n        form_field_choices = getattr(form_field, 'choices', None)\n        if form_field_choices is not None:\n            if hasattr(widget, 'choices'):\n                widget.choices = form_field_choices\n        return widget", "response": "Create the widget for the URL type."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nregister a custom model with the AnyUrlField.", "response": "def register(self, ModelClass, form_field=None, widget=None, title=None, prefix=None, has_id_value=True):\n        \"\"\"\n        Register a custom model with the ``AnyUrlField``.\n        \"\"\"\n        if any(urltype.model == ModelClass for urltype in self._url_types):\n            raise ValueError(\"Model is already registered: '{0}'\".format(ModelClass))\n\n        opts = ModelClass._meta\n        opts = opts.concrete_model._meta\n\n        if not prefix:\n            # Store something descriptive, easier to lookup from raw database content.\n            prefix = '{0}.{1}'.format(opts.app_label, opts.object_name.lower())\n        if not title:\n            title = ModelClass._meta.verbose_name\n\n        if self.is_external_url_prefix(prefix):\n            raise ValueError(\"Invalid prefix value: '{0}'.\".format(prefix))\n        if self[prefix] is not None:\n            raise ValueError(\"Prefix is already registered: '{0}'\".format(prefix))\n        if form_field is not None and widget is not None:\n            raise ValueError(\"Provide either a form_field or widget; use the widget parameter of the form field instead.\")\n\n        urltype = UrlType(ModelClass, form_field, widget, title, prefix, has_id_value)\n        signals.post_save.connect(_on_model_save, sender=ModelClass)\n        self._url_types.append(urltype)\n        return urltype"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_for_model(self, ModelClass):\n        for urltype in self._url_types:\n            if urltype.model is ModelClass:\n                return urltype\n        return None", "response": "Returns the URL type for a given model class"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the model index for a prefix.", "response": "def index(self, prefix):\n        \"\"\"\n        Return the model index for a prefix.\n        \"\"\"\n        # Any web domain will be handled by the standard URLField.\n        if self.is_external_url_prefix(prefix):\n            prefix = 'http'\n\n        for i, urltype in enumerate(self._url_types):\n            if urltype.prefix == prefix:\n                return i\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles HTTP requests from Tropo.", "response": "def message_received(request, backend_name):\n    \"\"\"Handle HTTP requests from Tropo.\n    \"\"\"\n\n    logger.debug(\"@@ request from Tropo - raw data: %s\" % request.body)\n    try:\n        post = json.loads(request.body)\n    except ValueError:\n        logger.exception(\"EXCEPTION decoding post data in incoming request\")\n        return HttpResponseBadRequest()\n    except Exception:\n        logger.exception(\"@@responding to tropo with error\")\n        return HttpResponseServerError()\n    logger.debug(\"@@ Decoded data: %r\" % post)\n\n    if 'session' not in post:\n        logger.error(\"@@HEY, post does not contain session, \"\n                     \"what's going on?\")\n        return HttpResponseBadRequest()\n\n    session = post['session']\n    parms = session.get('parameters', {})\n\n    if 'program' in parms:\n        # Execute a program that we passed to Tropo to pass back to us.\n        # Extract the program, while verifying it came from us and\n        # has not been modified.\n        try:\n            program = signing.loads(parms['program'])\n        except signing.BadSignature:\n            logger.exception(\"@@ received program with bad signature\")\n            return HttpResponseBadRequest()\n\n        return HttpResponse(json.dumps(program))\n\n    if 'from' in session:\n        # Must have received a message\n        # FIXME: is there any way we can verify it's really Tropo calling us?\n        logger.debug(\"@@Got a text message\")\n        try:\n            from_address = session['from']['id']\n            text = session['initialText']\n\n            logger.debug(\"@@Received message from %s: %s\" %\n                         (from_address, text))\n\n            # pass the message to RapidSMS\n            identity = from_address\n            connections = lookup_connections(backend_name, [identity])\n            receive(text, connections[0])\n\n            # Respond nicely to Tropo\n            program = json.dumps({\"tropo\": [{\"hangup\": {}}]})\n            logger.debug(\"@@responding to tropo with hangup\")\n            return HttpResponse(program)\n        except Exception:\n            logger.exception(\"@@responding to tropo with error\")\n            return HttpResponseServerError()\n\n    logger.error(\"@@No recognized command in request from Tropo\")\n    return HttpResponseBadRequest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_session(self, session_id, register=True, session_factory=None):\n        if session_factory is not None:\n            # use custom class to create session\n            sess_factory, sess_args, sess_kwargs = session_factory\n            s = sess_factory(*sess_args, **sess_kwargs)\n        else:\n            # use default session and arguments if not using a custom session\n            # factory\n            s = session.Session(self._connection, self, session_id,\n                                self.settings.get('disconnect_delay'))\n\n        if register:\n            self._sessions.add(s)\n\n        return s", "response": "Creates a new session object and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\noptimize C { broadcast } implementation.", "response": "def broadcast(self, clients, msg):\n        \"\"\" Optimized C{broadcast} implementation. Depending on type of the\n        session, will json-encode message once and will call either\n        C{send_message} or C{send_jsonifed}.\n\n        @param clients: Clients iterable\n\n        @param msg: Message to send\n        \"\"\"\n        json_msg = None\n\n        count = 0\n\n        for c in clients:\n            sess = c.session\n            if not sess.is_closed:\n                if sess.send_expects_json:\n                    if json_msg is None:\n                        json_msg = proto.json_encode(msg)\n                    sess.send_jsonified(json_msg, stats=False)\n                else:\n                    sess.send_message(msg, stats=False)\n\n                count += 1\n\n        self.stats.packSent(count)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccepting a value from the form calls to_python method applies filters and validators and catches ValidationError.", "response": "def accept(self, value, silent=False):\n        '''\n        Accepts a value from the form, calls :meth:`to_python` method,\n        checks `required` condition, applies filters and validators,\n        catches ValidationError.\n\n        :param value: a value to be accepted\n        :param silent=False: write errors to `form.errors` or not\n        '''\n        try:\n            value = self.to_python(value)\n            for v in self.validators:\n                value = v(self, value)\n\n            if self.required and self._is_empty(value):\n                raise ValidationError(self.error_required)\n        except ValidationError as e:\n            if not silent:\n                e.fill_errors(self.field)\n            #NOTE: by default value for field is in python_data,\n            #      but this is not true for FieldList where data\n            #      is dynamic, so we set value to None for absent value.\n            value = self._existing_value\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncleaning value for the current locale.", "response": "def clean_value(self, value):\n        '''\n        Additional clean action to preprocess value before :meth:`to_python`\n        method.\n\n        Subclasses may define own clean_value method to allow additional clean\n        actions like html cleanup, etc.\n        '''\n        # We have to clean before checking min/max length. It's done in\n        # separate method to allow additional clean action in subclasses.\n        if self.nontext_replacement is not None:\n            value = replace_nontext(value, self.nontext_replacement)\n        if self.strip:\n            value = value.strip()\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef options(self):\n        '''\n        Yields `(raw_value, label)` pairs for all acceptable choices.\n        '''\n        conv = self.conv\n        for python_value, label in self.choices:\n            yield conv.from_python(python_value), label", "response": "Yields raw_value label pairs for all acceptable choices."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _tzinfome(tzinfo):\n  if not isinstance(tzinfo, datetime.tzinfo):\n    try:\n      tzinfo = pytz.timezone(tzinfo)\n      assert tzinfo.zone in pytz.all_timezones\n    except AttributeError:\n      raise pytz.UnknownTimeZoneError(\"Unknown timezone! %s\" % tzinfo)\n  return tzinfo", "response": "Returns a tzinfo object from a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlocalize a datetime to the local timezone.", "response": "def localize(dt, force_to_local=True):\n  \"\"\"Localize a datetime to the local timezone.\n\n  If dt is naive, returns the same datetime with the local timezone, otherwise\n  uses astimezone to convert.\n\n  Args:\n    dt: datetime object.\n    force_to_local: Force all results to be in local time.\n\n  Returns:\n    A datetime_tz object.\n  \"\"\"\n  if not isinstance(dt, datetime_tz):\n    if not dt.tzinfo:\n      return datetime_tz(dt, tzinfo=localtz())\n    dt = datetime_tz(dt)\n  if force_to_local:\n    return dt.astimezone(localtz())\n  return dt"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_naive(dt):\n  if not dt.tzinfo:\n    return dt\n  if hasattr(dt, \"asdatetime\"):\n    return dt.asdatetime()\n  return dt.replace(tzinfo=None)", "response": "Returns a naive datetime from a datetime."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntrying and detect the timezone that Python is currently running in.", "response": "def detect_timezone():\n  \"\"\"Try and detect the timezone that Python is currently running in.\n\n  We have a bunch of different methods for trying to figure this out (listed in\n  order they are attempted).\n    * In windows, use win32timezone.TimeZoneInfo.local()\n    * Try TZ environment variable.\n    * Try and find /etc/timezone file (with timezone name).\n    * Try and find /etc/localtime file (with timezone data).\n    * Try and match a TZ to the current dst/offset/shortname.\n\n  Returns:\n    The detected local timezone as a tzinfo object\n\n  Raises:\n    pytz.UnknownTimeZoneError: If it was unable to detect a timezone.\n  \"\"\"\n  if sys.platform == \"win32\":\n    tz = _detect_timezone_windows()\n    if tz is not None:\n      return tz\n\n  # First we try the TZ variable\n  tz = _detect_timezone_environ()\n  if tz is not None:\n    return tz\n\n  # Second we try /etc/timezone and use the value in that\n  tz = _detect_timezone_etc_timezone()\n  if tz is not None:\n    return tz\n\n  # Next we try and see if something matches the tzinfo in /etc/localtime\n  tz = _detect_timezone_etc_localtime()\n  if tz is not None:\n    return tz\n\n  # Next we try and use a similiar method to what PHP does.\n  # We first try to search on time.tzname, time.timezone, time.daylight to\n  # match a pytz zone.\n  warnings.warn(\"Had to fall back to worst detection method (the 'PHP' \"\n                \"method).\")\n\n  tz = _detect_timezone_php()\n  if tz is not None:\n    return tz\n\n  raise pytz.UnknownTimeZoneError(\"Unable to detect your timezone!\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload zoneinfo from local disk.", "response": "def _load_local_tzinfo():\n  \"\"\"Load zoneinfo from local disk.\"\"\"\n  tzdir = os.environ.get(\"TZDIR\", \"/usr/share/zoneinfo/posix\")\n\n  localtzdata = {}\n  for dirpath, _, filenames in os.walk(tzdir):\n    for filename in filenames:\n      filepath = os.path.join(dirpath, filename)\n      name = os.path.relpath(filepath, tzdir)\n\n      f = open(filepath, \"rb\")\n      tzinfo = pytz.tzfile.build_tzinfo(name, f)\n      f.close()\n      localtzdata[name] = tzinfo\n\n  return localtzdata"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _detect_timezone_etc_localtime():\n  matches = []\n  if os.path.exists(\"/etc/localtime\"):\n    f = open(\"/etc/localtime\", \"rb\")\n    localtime = pytz.tzfile.build_tzinfo(\"/etc/localtime\", f)\n    f.close()\n\n    # We want to match against the local database because /etc/localtime will\n    # be copied from that. Once we have found a name for /etc/localtime, we can\n    # use the name to get the \"same\" timezone from the inbuilt pytz database.\n\n    tzdatabase = _load_local_tzinfo()\n    if tzdatabase:\n      tznames = tzdatabase.keys()\n      tzvalues = tzdatabase.__getitem__\n    else:\n      tznames = pytz.all_timezones\n      tzvalues = _tzinfome\n\n    # See if we can find a \"Human Name\" for this..\n    for tzname in tznames:\n      tz = tzvalues(tzname)\n\n      if dir(tz) != dir(localtime):\n        continue\n\n      for attrib in dir(tz):\n        # Ignore functions and specials\n        if callable(getattr(tz, attrib)) or attrib.startswith(\"__\"):\n          continue\n\n        # This will always be different\n        if attrib == \"zone\" or attrib == \"_tzinfos\":\n          continue\n\n        if getattr(tz, attrib) != getattr(localtime, attrib):\n          break\n\n      # We get here iff break didn't happen, i.e. no meaningful attributes\n      # differ between tz and localtime\n      else:\n        # Try and get a timezone from pytz which has the same name as the zone\n        # which matches in the local database.\n        if tzname not in pytz.all_timezones:\n          warnings.warn(\"Skipping %s because not in pytz database.\" % tzname)\n          continue\n\n        matches.append(_tzinfome(tzname))\n\n    matches.sort(key=lambda x: x.zone)\n\n    if len(matches) == 1:\n      return matches[0]\n\n    if len(matches) > 1:\n      warnings.warn(\"We detected multiple matches for your /etc/localtime. \"\n                    \"(Matches where %s)\" % matches)\n      return matches[0]\n    else:\n      warnings.warn(\"We detected no matches for your /etc/localtime.\")\n\n    # Register /etc/localtime as the timezone loaded.\n    pytz._tzinfo_cache[\"/etc/localtime\"] = localtime\n    return localtime", "response": "Detect timezone based on localtime file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping a method which returns a datetime. datetime to return a datetime_tz. datetime_tz instead.", "response": "def _wrap_method(name):\n  \"\"\"Wrap a method.\n\n  Patch a method which might return a datetime.datetime to return a\n  datetime_tz.datetime_tz instead.\n\n  Args:\n    name: The name of the method to patch\n  \"\"\"\n  method = getattr(datetime.datetime, name)\n\n  # Have to give the second argument as method has no __module__ option.\n  @functools.wraps(method, (\"__name__\", \"__doc__\"), ())\n  def wrapper(self, *args, **kw):\n    r = method(self, *args, **kw)\n\n    if isinstance(r, datetime.datetime) and not isinstance(r, type(self)):\n      r = type(self)(r)\n    return r\n\n  setattr(datetime_tz, name, wrapper)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef asdatetime(self, naive=True):\n    args = list(self.timetuple()[0:6])+[self.microsecond]\n    if not naive:\n      args.append(self.tzinfo)\n    return datetime.datetime(*args)", "response": "Return this datetime_tz as a datetime object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef asdate(self):\n    return datetime.date(self.year, self.month, self.day)", "response": "Return this datetime_tz as a date object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef astimezone(self, tzinfo):\n    # Assert we are not a naive datetime object\n    assert self.tzinfo is not None\n\n    tzinfo = _tzinfome(tzinfo)\n\n    d = self.asdatetime(naive=False).astimezone(tzinfo)\n    return type(self)(d)", "response": "Returns a version of this timestamp converted to the given timezone."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef replace(self, **kw):\n    if \"tzinfo\" in kw:\n      if kw[\"tzinfo\"] is None:\n        raise TypeError(\"Can not remove the timezone use asdatetime()\")\n      else:\n        tzinfo = kw[\"tzinfo\"]\n        del kw[\"tzinfo\"]\n    else:\n      tzinfo = None\n\n    is_dst = None\n    if \"is_dst\" in kw:\n      is_dst = kw[\"is_dst\"]\n      del kw[\"is_dst\"]\n    else:\n      # Use our own DST setting..\n      is_dst = self.is_dst\n\n    replaced = self.asdatetime().replace(**kw)\n\n    return type(self)(\n        replaced, tzinfo=tzinfo or self.tzinfo.zone, is_dst=is_dst)", "response": "Returns a new datetime_tz object with the given fields replaced."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef utcfromtimestamp(cls, timestamp):\n    obj = datetime.datetime.utcfromtimestamp(timestamp)\n    obj = pytz.utc.localize(obj)\n    return cls(obj)", "response": "Returns a datetime object of a given timestamp in UTC."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fromtimestamp(cls, timestamp):\n    d = cls.utcfromtimestamp(timestamp)\n    return d.astimezone(localtz())", "response": "Returns a datetime object of a given timestamp in local tz."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a new datetime representing UTC day and time.", "response": "def utcnow(cls):\n    \"\"\"Return a new datetime representing UTC day and time.\"\"\"\n    obj = datetime.datetime.utcnow()\n    obj = cls(obj, tzinfo=pytz.utc)\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef now(cls, tzinfo=None):\n    obj = cls.utcnow()\n    if tzinfo is None:\n      tzinfo = localtz()\n    return obj.astimezone(tzinfo)", "response": "Returns a datetime object with tz s local day and time."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a new object with the same date and time fields.", "response": "def combine(cls, date, time, tzinfo=None):\n    \"\"\"date, time, [tz] -> datetime with same date and time fields.\"\"\"\n    if tzinfo is None:\n      tzinfo = localtz()\n    return cls(datetime.datetime.combine(date, time), tzinfo)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef between(start, delta, end=None):\n    toyield = start\n    while end is None or toyield < end:\n      yield toyield\n      toyield += delta", "response": "Return an iterator between this date till given end point."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\niterating over the days between the given datetime_tzs.", "response": "def days(start, end=None):\n    \"\"\"Iterate over the days between the given datetime_tzs.\n\n    Args:\n      start: datetime_tz to start from.\n      end: (Optional) Date to end at, if not given the iterator will never\n           terminate.\n\n    Returns:\n      An iterator which generates datetime_tz objects a day apart.\n    \"\"\"\n    return iterate.between(start, datetime.timedelta(days=1), end)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\niterating over the hours between the given datetime_tzs.", "response": "def hours(start, end=None):\n    \"\"\"Iterate over the hours between the given datetime_tzs.\n\n    Args:\n      start: datetime_tz to start from.\n      end: (Optional) Date to end at, if not given the iterator will never\n           terminate.\n\n    Returns:\n      An iterator which generates datetime_tz objects a hour apart.\n    \"\"\"\n    return iterate.between(start, datetime.timedelta(hours=1), end)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\niterate over the minutes between the given datetime_tzs.", "response": "def minutes(start, end=None):\n    \"\"\"Iterate over the minutes between the given datetime_tzs.\n\n    Args:\n      start: datetime_tz to start from.\n      end: (Optional) Date to end at, if not given the iterator will never\n           terminate.\n\n    Returns:\n      An iterator which generates datetime_tz objects a minute apart.\n    \"\"\"\n    return iterate.between(start, datetime.timedelta(minutes=1), end)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating an ISO - 8601 formatted timestamp from a datetime.", "response": "def generate(dt, utc=True, accept_naive=False, microseconds=False):\n    '''\n    Generate an :RFC:`3339`-formatted timestamp from a\n    :class:`datetime.datetime`.\n\n    >>> from datetime import datetime\n    >>> generate(datetime(2009,1,1,12,59,59,0,pytz.utc))\n    '2009-01-01T12:59:59Z'\n\n    The timestamp will use UTC unless `utc=False` is specified, in which case\n    it will use the timezone from the :class:`datetime.datetime`'s\n    :attr:`tzinfo` parameter.\n\n    >>> eastern = pytz.timezone('US/Eastern')\n    >>> dt = eastern.localize(datetime(2009,1,1,12,59,59))\n    >>> generate(dt)\n    '2009-01-01T17:59:59Z'\n    >>> generate(dt, utc=False)\n    '2009-01-01T12:59:59-05:00'\n\n    Unless `accept_naive=True` is specified, the `datetime` must not be naive.\n\n    >>> generate(datetime(2009,1,1,12,59,59,0))\n    Traceback (most recent call last):\n    ...\n    ValueError: naive datetime and accept_naive is False\n\n    >>> generate(datetime(2009,1,1,12,59,59,0), accept_naive=True)\n    '2009-01-01T12:59:59Z'\n\n    If `accept_naive=True` is specified, the `datetime` is assumed to be UTC.\n    Attempting to generate a local timestamp from a naive datetime will result\n    in an error.\n\n    >>> generate(datetime(2009,1,1,12,59,59,0), accept_naive=True, utc=False)\n    Traceback (most recent call last):\n    ...\n    ValueError: cannot generate a local timestamp from a naive datetime\n\n    '''\n    if dt.tzinfo is None:\n        if accept_naive is True:\n            if utc is True:\n                dt = dt.replace(tzinfo=pytz.utc)\n            else:\n                raise ValueError(\"cannot generate a local timestamp from \" +\n                                 \"a naive datetime\")\n        else:\n            raise ValueError(\"naive datetime and accept_naive is False\")\n\n    if utc is True:\n        dt = dt.astimezone(pytz.utc)\n\n    timestamp = dt.strftime('%Y-%m-%dT%H:%M:%S')\n    if microseconds is True:\n        timestamp += dt.strftime('.%f')\n    if dt.tzinfo is pytz.utc:\n        timestamp += 'Z'\n    else:\n        timestamp += timezone(timedelta_seconds(dt.tzinfo.utcoffset(dt)))\n\n    return timestamp"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets or create a placeholder on the given page.", "response": "def get_or_create_placeholder(page, placeholder_slot, delete_existing=False):\n    \"\"\"\n    Get or create a placeholder on the given page.\n    Optional: Delete existing placeholder.\n    \"\"\"\n    placeholder, created = page.placeholders.get_or_create(\n        slot=placeholder_slot)\n    if created:\n        log.debug(\"Create placeholder %r for page %r\", placeholder_slot,\n                  page.get_title())\n    else:\n        log.debug(\"Use existing placeholder %r for page %r\", placeholder_slot,\n                  page.get_title())\n\n    if delete_existing:\n        queryset = CMSPlugin.objects.all().filter(placeholder=placeholder)\n        log.info(\"Delete %i CMSPlugins on placeholder %s...\", queryset.count(),\n                 placeholder)\n        queryset.delete()\n\n    return placeholder, created"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npublishes a CMS page in all given languages.", "response": "def publish_page(page, languages):\n    \"\"\"\n    Publish a CMS page in all given languages.\n    \"\"\"\n    for language_code, lang_name in iter_languages(languages):\n        url = page.get_absolute_url()\n\n        if page.publisher_is_draft:\n            page.publish(language_code)\n            log.info('page \"%s\" published in %s: %s', page, lang_name, url)\n        else:\n            log.info('published page \"%s\" already exists in %s: %s', page,\n                     lang_name, url)\n    return page.reload()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating cms home page and fill >content< placeholder with TextPlugin", "response": "def create_cms_index_pages(placeholder_slot=\"content\"):\n    \"\"\"\n    create cms home page and fill >content< placeholder with TextPlugin\n    \"\"\"\n    try:\n        index_page = Page.objects.get(is_home=True, publisher_is_draft=False)\n    except Page.DoesNotExist:\n        log.debug('Create index page in \"en\" and...')\n\n        index_page = create_page(\n            title=\"index in English\",\n            template=TEMPLATE_INHERITANCE_MAGIC,\n            language=settings.LANGUAGE_CODE,\n            published=False,\n            in_navigation=True)\n        placeholder, created = index_page.placeholders.get_or_create(\n            slot=placeholder_slot)\n        for language_code, lang_name in settings.LANGUAGES:\n            with translation.override(language_code):\n                title = 'index in %s' % lang_name\n                log.info('create %r', title)\n                if language_code != settings.LANGUAGE_CODE:\n                    create_title(language_code, title, index_page)\n                add_plugin(\n                    placeholder=placeholder,\n                    plugin_type='TextPlugin',  # djangocms_text_ckeditor\n                    language=language_code,\n                    body='index page in %s' % lang_name)\n                index_page.publish(language_code)\n        created = True\n    else:\n        created = False\n        log.debug('Index page already exists.')\n\n    return index_page, created"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a cms plugin page in all existing languages.", "response": "def create_cms_plugin_page(apphook, apphook_namespace, placeholder_slot=None):\n    \"\"\"\n    Create cms plugin page in all existing languages.\n    Add a link to the index page.\n\n    :param apphook: e.g...........: 'FooBarApp'\n    :param apphook_namespace: e.g.: 'foobar'\n    :return:\n    \"\"\"\n    creator = CmsPluginPageCreator(\n        apphook=apphook,\n        apphook_namespace=apphook_namespace,\n    )\n    creator.placeholder_slot = placeholder_slot\n    plugin_page = creator.create()\n    return plugin_page"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_slug(self, language_code, lang_name):\n        title = self.get_title(language_code, lang_name)\n        assert title != \"\"\n\n        title = str(title)  # e.g.: evaluate a lazy translation\n\n        slug = slugify(title)\n        assert slug != \"\", \"Title %r results in empty slug!\" % title\n        return slug", "response": "Returns a slug for the page."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_home_page(self):\n        try:\n            home_page_draft = Page.objects.get(\n                is_home=True, publisher_is_draft=True)\n        except Page.DoesNotExist:\n            log.error('ERROR: \"home page\" doesn\\'t exists!')\n            raise RuntimeError('no home page')\n        return home_page_draft", "response": "Return the published home page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npublishing the page in all languages.", "response": "def publish(self, page):\n        \"\"\"\n        Publish the page in all languages.\n        \"\"\"\n        assert page.publisher_is_draft == True, \"Page '%s' must be a draft!\" % page\n        publish_page(page, languages=self.languages)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new page in default language and return it.", "response": "def create_page(self, **extra_kwargs):\n        \"\"\"\n        Create page (and page title) in default language\n\n        extra_kwargs will be pass to cms.api.create_page()\n        e.g.:\n            extra_kwargs={\n                \"soft_root\": True,\n                \"reverse_id\": my_reverse_id,\n            }\n        \"\"\"\n        with translation.override(self.default_language_code):\n            # for evaluate the language name lazy translation\n            # e.g.: settings.LANGUAGE_CODE is not \"en\"\n\n            self.default_lang_name = dict(\n                self.languages)[self.default_language_code]\n            self.slug = self.get_slug(self.default_language_code,\n                                      self.default_lang_name)\n            assert self.slug != \"\"\n\n        page = None\n        parent = self.get_parent_page()\n        if parent is not None:\n            assert parent.publisher_is_draft == True, \"Parent page '%s' must be a draft!\" % parent\n\n        if self.delete_first:\n            if self.apphook_namespace is not None:\n                pages = Page.objects.filter(\n                    application_namespace=self.apphook_namespace,\n                    parent=parent,\n                )\n            else:\n                pages = Page.objects.filter(\n                    title_set__slug=self.slug,\n                    parent=parent,\n                )\n            log.debug(\"Delete %i pages...\", pages.count())\n            pages.delete()\n        else:\n            if self.apphook_namespace is not None:\n                # Create a plugin page\n                queryset = Page.objects.drafts()\n                queryset = queryset.filter(parent=parent)\n                try:\n                    page = queryset.get(\n                        application_namespace=self.apphook_namespace)\n                except Page.DoesNotExist:\n                    pass  # Create page\n                else:\n                    log.debug(\"Use existing page: %s\", page)\n                    created = False\n                    return page, created\n            else:\n                # Not a plugin page\n                queryset = Title.objects.filter(\n                    language=self.default_language_code)\n                queryset = queryset.filter(page__parent=parent)\n                try:\n                    title = queryset.filter(slug=self.slug).first()\n                except Title.DoesNotExist:\n                    pass  # Create page\n                else:\n                    if title is not None:\n                        log.debug(\"Use page from title with slug %r\",\n                                  self.slug)\n                        page = title.page\n                        created = False\n\n        if page is None:\n            with translation.override(self.default_language_code):\n                # set right translation language\n                # for evaluate language name lazy translation\n                # e.g.: settings.LANGUAGE_CODE is not \"en\"\n\n                page = create_page(\n                    title=self.get_title(self.default_language_code,\n                                         self.default_lang_name),\n                    menu_title=self.get_menu_title(self.default_language_code,\n                                                   self.default_lang_name),\n                    template=self.get_template(self.default_language_code,\n                                               self.default_lang_name),\n                    language=self.default_language_code,\n                    slug=self.slug,\n                    published=False,\n                    parent=parent,\n                    in_navigation=self.in_navigation,\n                    apphook=self.apphook,\n                    apphook_namespace=self.apphook_namespace,\n                    **extra_kwargs)\n                created = True\n                log.debug(\"Page created in %s: %s\", self.default_lang_name,\n                          page)\n\n        assert page.publisher_is_draft == True\n        return page, created"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates page title in all other languages with cms. api. create_title", "response": "def create_title(self, page):\n        \"\"\"\n        Create page title in all other languages with cms.api.create_title()\n        \"\"\"\n        for language_code, lang_name in iter_languages(self.languages):\n            try:\n                title = Title.objects.get(page=page, language=language_code)\n            except Title.DoesNotExist:\n                slug = self.get_slug(language_code, lang_name)\n                assert slug != \"\", \"No slug for %r\" % language_code\n                title = create_title(\n                    language=language_code,\n                    title=self.get_title(language_code, lang_name),\n                    page=page,\n                    slug=slug,\n                )\n                log.debug(\"Title created: %s\", title)\n            else:\n                log.debug(\"Page title exist: %s\", title)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn keyword arguments for the add plugin.", "response": "def get_add_plugin_kwargs(self, page, no, placeholder, language_code,\n                              lang_name):\n        \"\"\"\n        Return \"content\" for create the plugin.\n        Called from self.add_plugins()\n        \"\"\"\n        return {\n            \"plugin_type\":\n            'TextPlugin',  # djangocms_text_ckeditor\n            \"body\":\n            self.get_dummy_text(page, no, placeholder, language_code,\n                                lang_name)\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_plugins(self, page, placeholder):\n        for language_code, lang_name in iter_languages(self.languages):\n            for no in range(1, self.dummy_text_count + 1):\n                add_plugin_kwargs = self.get_add_plugin_kwargs(\n                    page, no, placeholder, language_code, lang_name)\n\n                log.info(\n                    'add plugin to placeholder \"%s\" (pk:%i) in: %s - no: %i',\n                    placeholder, placeholder.pk, lang_name, no)\n                plugin = add_plugin(\n                    placeholder=placeholder,\n                    language=language_code,\n                    **add_plugin_kwargs)\n                log.info('Plugin \"%s\" (pk:%r) added.', str(plugin), plugin.pk)\n                placeholder.save()", "response": "Add a TextPlugin to all languages."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_or_create_placeholder(self, page, placeholder_slot):\n        placeholder, created = get_or_create_placeholder(\n            page, placeholder_slot, delete_existing=self.delete_first)\n        return placeholder, created", "response": "Get a placeholder from the cache or create it if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fill_content(self, page, placeholder_slot):\n        if len(placeholder_slot) == 1:\n            raise RuntimeError(placeholder_slot)\n        placeholder, created = self.get_or_create_placeholder(\n            page, placeholder_slot)\n        self.add_plugins(page, placeholder)", "response": "Add a new placeholder to the page."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates the plugin page in all languages and fill dummy content.", "response": "def create(self):\n        \"\"\"\n        Create the plugin page in all languages and fill dummy content.\n        \"\"\"\n        plugin = CMSPlugin.objects.filter(plugin_type=self.apphook)\n        if plugin.exists():\n            log.debug('Plugin page for \"%s\" plugin already exist, ok.',\n                      self.apphook)\n            raise plugin\n\n        page, created = super(CmsPluginPageCreator, self).create()\n\n        if created:\n            # Add a plugin with content in all languages to the created page.\n            # But only on new created page\n            for placeholder_slot in self.placeholder_slots:\n                self.fill_content(page, placeholder_slot)\n\n        return page, created"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the title for the current page", "response": "def get_title(self, language_code, lang_name):\n        \"\"\"\n        :return: 'title' string for cms.api.create_page()\n        \"\"\"\n        title = \"%s %i-%i in %s\" % (self.title_prefix, self.current_count,\n                                    self.current_level, language_code)\n        log.info(title)\n        return title"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntranslates a / - separated PATH to the local filename syntax.", "response": "def translate_path(self, pth):\n        \"\"\"Translate a /-separated PATH to the local filename syntax.\"\"\"\n        # initially copied from SimpleHTTPServer\n        words = pth.split('/')\n        words = filter(None, words)\n        pth = self.location\n        for word in words:\n            # Do not allow path separators other than /,\n            # drive names and . ..\n            drive, word = os.path.splitdrive(word)\n            head, word = os.path.split(word)\n            if drive or head or word in (os.curdir, os.pardir):\n                return None\n            pth = os.path.join(pth, word)\n\n        assert pth.startswith(self.location + '/')\n        assert pth == path.normpath(pth)\n        return pth"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dict(self):\n        from collections import OrderedDict\n        SKIP_KEYS = ()\n        return OrderedDict(\n            (p.key, getattr(self, p.key)) for p in self.__mapper__.attrs if p.key not in SKIP_KEYS)", "response": "A dict that holds all of the properties in the the\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a column by name or position.", "response": "def column(self, source_header_or_pos):\n        \"\"\"\n        Return a column by name or position\n\n        :param source_header_or_pos: If a string, a source header name. If an integer, column position\n        :return:\n        \"\"\"\n        for c in self.columns:\n            if c.source_header == source_header_or_pos:\n                assert c.st_vid == self.vid\n                return c\n            elif c.position == source_header_or_pos:\n                assert c.st_vid == self.vid\n                return c\n\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a column to the source table.", "response": "def add_column(self, position, source_header, datatype, **kwargs):\n        \"\"\"\n        Add a column to the source table.\n        :param position: Integer position of the column started from 1.\n        :param source_header: Name of the column, as it exists in the source file\n        :param datatype: Python datatype ( str, int, float, None ) for the column\n        :param kwargs:  Other source record args.\n        :return:\n        \"\"\"\n        from ..identity import GeneralNumber2\n\n        c = self.column(source_header)\n        c_by_pos = self.column(position)\n\n        datatype = 'str' if datatype == 'unicode' else datatype\n\n        assert not c or not c_by_pos or c.vid == c_by_pos.vid\n\n        # Convert almost anything to True / False\n        if 'has_codes' in kwargs:\n            FALSE_VALUES = ['False', 'false', 'F', 'f', '', None, 0, '0']\n            kwargs['has_codes'] = False if kwargs['has_codes'] in FALSE_VALUES else True\n\n        if c:\n\n            # Changing the position can result in conflicts\n            assert not c_by_pos or c_by_pos.vid == c.vid\n\n            c.update(\n                position=position,\n                datatype=datatype.__name__ if isinstance(datatype, type) else datatype,\n                **kwargs)\n\n        elif c_by_pos:\n\n            # FIXME This feels wrong; there probably should not be any changes to the both\n            # of the table, since then it won't represent the previouls source. Maybe all of the sources\n            # should get their own tables initially, then affterward the duplicates can be removed.\n\n            assert not c or c_by_pos.vid == c.vid\n\n            c_by_pos.update(\n                source_header=source_header,\n                datatype=datatype.__name__ if isinstance(datatype, type) else datatype,\n                **kwargs)\n\n        else:\n\n            assert not c and not c_by_pos\n\n            # Hacking an id number, since I don't want to create a new Identity ObjectNUmber type\n            c = SourceColumn(\n                vid=str(GeneralNumber2('C', self.d_vid, self.sequence_id, int(position))),\n                position=position,\n                st_vid=self.vid,\n                d_vid=self.d_vid,\n                datatype=datatype.__name__ if isinstance(datatype, type) else datatype,\n                source_header=source_header,\n                **kwargs)\n\n            self.columns.append(c)\n\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nalter the sequence id and all of the names and ids derived from it.", "response": "def update_id(self, sequence_id=None):\n        \"\"\"Alter the sequence id, and all of the names and ids derived from it. This\n        often needs to be don after an IntegrityError in a multiprocessing run\"\"\"\n        from ..identity import GeneralNumber1\n\n        if sequence_id:\n            self.sequence_id = sequence_id\n\n        self.vid = str(GeneralNumber1('T', self.d_vid, self.sequence_id))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget table metadata from the database.", "response": "def table_convert_geometry(metadata, table_name):\n    \"\"\"Get table metadata from the database.\"\"\"\n    from sqlalchemy import Table\n    from ..orm import Geometry\n\n    table = Table(table_name, metadata, autoload=True)\n\n    for c in table.columns:\n\n        # HACK! Sqlalchemy sees spatialte GEOMETRY types\n        # as NUMERIC\n\n        if c.name == 'geometry':\n            c.type = Geometry # What about variants?\n\n    return table"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef next_sequence_id(session, sequence_ids, parent_vid, table_class, force_query = False):\n\n    from sqlalchemy import text\n\n    seq_col = table_class.sequence_id.property.columns[0].name\n\n    try:\n        parent_col = table_class._parent_col\n    except AttributeError:\n        parent_col = table_class.d_vid.property.columns[0].name\n\n    assert bool(parent_vid)\n\n    key = (parent_vid, table_class.__name__)\n\n    number = sequence_ids.get(key, None)\n\n    if (not number and session) or force_query:\n\n        sql = text(\"SELECT max({seq_col})+1 FROM {table} WHERE {parent_col} = '{vid}'\"\n                   .format(table=table_class.__tablename__, parent_col=parent_col,\n                           seq_col=seq_col, vid=parent_vid))\n\n        max_id, = session.execute(sql).fetchone()\n\n        if not max_id:\n            max_id = 1\n\n        sequence_ids[key] = int(max_id)\n\n    elif not session:\n        # There was no session set. This should only happen when the parent object is new, and therefore,\n        # there are no child number, so the appropriate starting number is 1. If the object is not new,\n        # there will be conflicts.\n        sequence_ids[key] = 1\n\n    else:\n        # There were no previous numbers, so start with 1\n        sequence_ids[key] += 1\n\n    return sequence_ids[key]", "response": "Returns the next sequence id for a child object identified by the parent object and the database prefix for the child object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef incver(o, prop_names):\n    from ambry.identity import ObjectNumber\n\n    d = {}\n\n    for p in o.__mapper__.attrs:\n        v = getattr(o, p.key)\n        if v is None:\n            d[p.key] = None\n        elif p.key in prop_names:\n            d[p.key] = str(ObjectNumber.increment(v))\n        else:\n            if not hasattr(v, '__mapper__'): # Only copy values, never objects\n                d[p.key] = v\n\n    return o.__class__(**d)", "response": "Increment the version numbers of a set of properties and return a new object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef coerce(cls, key, value):\n\n        if isinstance(value, string_types):\n            value = value.strip()\n            if value[0] == '[':  # It's json encoded, probably\n                try:\n                    value = json.loads(value)\n                except ValueError:\n                    raise ValueError(\"Failed to parse JSON: '{}' \".format(value))\n            else:\n                value = value.split(',')\n\n        if not value:\n            value = []\n\n        self = MutationList((MutationObj.coerce(key, v) for v in value))\n        self._key = key\n        return self", "response": "Convert plain list to MutationList."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_view(query):\n\n    try:\n        idx = query.lower().index('where')\n        query = query[:idx]\n    except ValueError:\n        pass\n\n    if not query.endswith(';'):\n        query = query.strip()\n        query += ';'\n\n    result = _view_stmt.parseString(query)\n\n    return View(result)", "response": "Parses a asql query to view object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _flat_alias(t):\n    t.name = t.parsed_name\n    t.alias = t.parsed_alias[0] if t.parsed_alias else ''\n    return t", "response": "Populates token t with parsed name and alias."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a join token.", "response": "def _build_join(t):\n    \"\"\" Populates join token fields. \"\"\"\n    t.source.name = t.source.parsed_name\n    t.source.alias = t.source.parsed_alias[0] if t.source.parsed_alias else ''\n\n    return t"}
